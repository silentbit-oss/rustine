{
    "ZopfliOptions": {
        "source_code": "typedef struct ZopfliOptions\n{\n  int verbose;\n  int verbose_more;\n  int numiterations;\n  int blocksplitting;\n  int blocksplittinglast;\n  int blocksplittingmax;\n} ZopfliOptions",
        "translated_code": "#[derive(Clone)]\npub struct ZopfliOptions {\n    pub verbose: i32,\n    pub verbose_more: i32,\n    pub numiterations: i32,\n    pub blocksplitting: i32,\n    pub blocksplittinglast: i32,\n    pub blocksplittingmax: i32,\n}",
        "hint": "special_types",
        "section": "src",
        "file": "ZopfliOptions.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliFormat": {
        "source_code": "typedef enum \n{\n  ZOPFLI_FORMAT_GZIP,\n  ZOPFLI_FORMAT_ZLIB,\n  ZOPFLI_FORMAT_DEFLATE\n} ZopfliFormat",
        "translated_code": "#[derive(Clone, Copy, Debug, PartialEq, Eq)]\npub enum ZopfliFormat {\n    ZOPFLI_FORMAT_GZIP,\n    ZOPFLI_FORMAT_ZLIB,\n    ZOPFLI_FORMAT_DEFLATE,\n}",
        "hint": "special_types",
        "section": "src",
        "file": "ZopfliFormat.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Enum'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliLongestMatchCache": {
        "source_code": "typedef struct ZopfliLongestMatchCache\n{\n  unsigned short *length;\n  unsigned short *dist;\n  unsigned char *sublen;\n} ZopfliLongestMatchCache",
        "translated_code": "#[derive(Clone)]\npub struct ZopfliLongestMatchCache {\n    pub length: Option<Vec<u16>>,\n    pub dist: Option<Vec<u16>>,\n    pub sublen: Option<Vec<u8>>,\n}",
        "hint": "special_types",
        "section": "src",
        "file": "ZopfliLongestMatchCache.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliHash": {
        "source_code": "typedef struct ZopfliHash\n{\n  int *head;\n  unsigned short *prev;\n  int *hashval;\n  int val;\n  int *head2;\n  unsigned short *prev2;\n  int *hashval2;\n  int val2;\n  unsigned short *same;\n} ZopfliHash",
        "translated_code": "#[derive(Clone)]\npub struct ZopfliHash {\n    pub head: Option<Vec<i32>>,\n    pub prev: Option<Vec<u16>>,\n    pub hashval: Option<Vec<i32>>,\n    pub val: i32,\n    pub head2: Option<Vec<i32>>,\n    pub prev2: Option<Vec<u16>>,\n    pub hashval2: Option<Vec<i32>>,\n    pub val2: i32,\n    pub same: Option<Vec<u16>>,\n}",
        "hint": "special_types",
        "section": "src",
        "file": "ZopfliHash.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliLZ77Store": {
        "source_code": "typedef struct ZopfliLZ77Store\n{\n  unsigned short *litlens;\n  unsigned short *dists;\n  size_t size;\n  const unsigned char *data;\n  size_t *pos;\n  unsigned short *ll_symbol;\n  unsigned short *d_symbol;\n  size_t *ll_counts;\n  size_t *d_counts;\n} ZopfliLZ77Store",
        "translated_code": "use std::vec::Vec;\n\n#[derive(Clone)]\npub struct ZopfliLz77Store {\n    pub litlens: Option<Vec<u16>>,\n    pub dists: Option<Vec<u16>>,\n    pub size: usize,\n    pub data: Option<Vec<u8>>,\n    pub pos: Option<Vec<usize>>,\n    pub ll_symbol: Option<Vec<u16>>,\n    pub d_symbol: Option<Vec<u16>>,\n    pub ll_counts: Option<Vec<usize>>,\n    pub d_counts: Option<Vec<usize>>,\n}",
        "hint": "special_types",
        "section": "src",
        "file": "ZopfliLZ77Store.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "FindMinimumFun": {
        "source_code": "typedef double FindMinimumFun(size_t i, void *context)",
        "translated_code": "pub type FindMinimumFun = fn(usize, Option<Box<dyn std::any::Any>>) -> f64;",
        "hint": "special_types",
        "section": "src",
        "file": "FindMinimumFun.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.FuncDecl'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "SymbolStats": {
        "source_code": "typedef struct SymbolStats\n{\n  size_t litlens[288];\n  size_t dists[32];\n  double ll_symbols[288];\n  double d_symbols[32];\n} SymbolStats",
        "translated_code": "#[derive(Clone)]\npub struct SymbolStats {\n    pub litlens: [usize; 288],\n    pub dists: [usize; 32],\n    pub ll_symbols: [f64; 288],\n    pub d_symbols: [f64; 32],\n}",
        "hint": "special_types",
        "section": "src",
        "file": "SymbolStats.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "RanState": {
        "source_code": "typedef struct RanState\n{\n  unsigned int m_w;\n  unsigned int m_z;\n} RanState",
        "translated_code": "#[derive(Clone)]\npub struct RanState {\n    pub m_w: u32,\n    pub m_z: u32,\n}",
        "hint": "special_types",
        "section": "src",
        "file": "RanState.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "CostModelFun": {
        "source_code": "typedef double CostModelFun(unsigned litlen, unsigned dist, void *context)",
        "translated_code": "/// Function pointer type for cost model calculations\npub type CostModelFun = fn(litlen: u32, dist: u32, context: Option<Box<dyn std::any::Any>>) -> f64;",
        "hint": "special_types",
        "section": "src",
        "file": "CostModelFun.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.FuncDecl'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "Node": {
        "source_code": "struct Node\n{\n  size_t weight;\n  Node *tail;\n  int count;\n}",
        "translated_code": "use std::usize;\n\n#[derive(Clone)]\npub struct Node {\n    pub weight: usize,\n    pub tail: Option<Box<Node>>,\n    pub count: i32,\n}",
        "hint": "special_types",
        "section": "src",
        "file": "Node.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "tests_passed": {
        "source_code": "static int tests_passed = 0",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::atomic::{AtomicI32, Ordering};\n\nlazy_static! {\n    pub static ref TESTS_PASSED: AtomicI32 = AtomicI32::new(0);\n}",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "int",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "tests_failed": {
        "source_code": "static int tests_failed = 0",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::atomic::{AtomicI32, Ordering};\n\nlazy_static! {\n    pub static ref TESTS_FAILED: AtomicI32 = AtomicI32::new(0);\n}",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "int",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "total_tests": {
        "source_code": "static int total_tests = 0",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::atomic::{AtomicI32, Ordering};\n\nlazy_static! {\n    pub static ref TOTAL_TESTS: AtomicI32 = AtomicI32::new(0);\n}",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "int",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_data_small": {
        "source_code": "static const char *test_data_small = \"Hello, World!\"",
        "translated_code": "pub static TEST_DATA_SMALL: &str = \"Hello, World!\";",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "const char *",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_data_medium": {
        "source_code": "static const char *test_data_medium = \"This is a medium-sized test string for Zopfli compression. It should compress reasonably well due to repeated patterns and words. The algorithm should find common substrings and optimize the output.\"",
        "translated_code": "pub static TEST_DATA_MEDIUM: &str = \"This is a medium-sized test string for Zopfli compression. It should compress reasonably well due to repeated patterns and words. The algorithm should find common substrings and optimize the output.\";",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "const char *",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_data_large": {
        "source_code": "static const char *test_data_large = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"",
        "translated_code": "use lazy_static::lazy_static;\n\nlazy_static! {\n    pub static ref TEST_DATA_LARGE: &'static str = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\";\n}",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "const char *",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "crc32_table": {
        "source_code": "static const unsigned long crc32_table[256] = {0u, 1996959894u, 3993919788u, 2567524794u, 124634137u, 1886057615u, 3915621685u, 2657392035u, 249268274u, 2044508324u, 3772115230u, 2547177864u, 162941995u, 2125561021u, 3887607047u, 2428444049u, 498536548u, 1789927666u, 4089016648u, 2227061214u, 450548861u, 1843258603u, 4107580753u, 2211677639u, 325883990u, 1684777152u, 4251122042u, 2321926636u, 335633487u, 1661365465u, 4195302755u, 2366115317u, 997073096u, 1281953886u, 3579855332u, 2724688242u, 1006888145u, 1258607687u, 3524101629u, 2768942443u, 901097722u, 1119000684u, 3686517206u, 2898065728u, 853044451u, 1172266101u, 3705015759u, 2882616665u, 651767980u, 1373503546u, 3369554304u, 3218104598u, 565507253u, 1454621731u, 3485111705u, 3099436303u, 671266974u, 1594198024u, 3322730930u, 2970347812u, 795835527u, 1483230225u, 3244367275u, 3060149565u, 1994146192u, 31158534u, 2563907772u, 4023717930u, 1907459465u, 112637215u, 2680153253u, 3904427059u, 2013776290u, 251722036u, 2517215374u, 3775830040u, 2137656763u, 141376813u, 2439277719u, 3865271297u, 1802195444u, 476864866u, 2238001368u, 4066508878u, 1812370925u, 453092731u, 2181625025u, 4111451223u, 1706088902u, 314042704u, 2344532202u, 4240017532u, 1658658271u, 366619977u, 2362670323u, 4224994405u, 1303535960u, 984961486u, 2747007092u, 3569037538u, 1256170817u, 1037604311u, 2765210733u, 3554079995u, 1131014506u, 879679996u, 2909243462u, 3663771856u, 1141124467u, 855842277u, 2852801631u, 3708648649u, 1342533948u, 654459306u, 3188396048u, 3373015174u, 1466479909u, 544179635u, 3110523913u, 3462522015u, 1591671054u, 702138776u, 2966460450u, 3352799412u, 1504918807u, 783551873u, 3082640443u, 3233442989u, 3988292384u, 2596254646u, 62317068u, 1957810842u, 3939845945u, 2647816111u, 81470997u, 1943803523u, 3814918930u, 2489596804u, 225274430u, 2053790376u, 3826175755u, 2466906013u, 167816743u, 2097651377u, 4027552580u, 2265490386u, 503444072u, 1762050814u, 4150417245u, 2154129355u, 426522225u, 1852507879u, 4275313526u, 2312317920u, 282753626u, 1742555852u, 4189708143u, 2394877945u, 397917763u, 1622183637u, 3604390888u, 2714866558u, 953729732u, 1340076626u, 3518719985u, 2797360999u, 1068828381u, 1219638859u, 3624741850u, 2936675148u, 906185462u, 1090812512u, 3747672003u, 2825379669u, 829329135u, 1181335161u, 3412177804u, 3160834842u, 628085408u, 1382605366u, 3423369109u, 3138078467u, 570562233u, 1426400815u, 3317316542u, 2998733608u, 733239954u, 1555261956u, 3268935591u, 3050360625u, 752459403u, 1541320221u, 2607071920u, 3965973030u, 1969922972u, 40735498u, 2617837225u, 3943577151u, 1913087877u, 83908371u, 2512341634u, 3803740692u, 2075208622u, 213261112u, 2463272603u, 3855990285u, 2094854071u, 198958881u, 2262029012u, 4057260610u, 1759359992u, 534414190u, 2176718541u, 4139329115u, 1873836001u, 414664567u, 2282248934u, 4279200368u, 1711684554u, 285281116u, 2405801727u, 4167216745u, 1634467795u, 376229701u, 2685067896u, 3608007406u, 1308918612u, 956543938u, 2808555105u, 3495958263u, 1231636301u, 1047427035u, 2932959818u, 3654703836u, 1088359270u, 936918000u, 2847714899u, 3736837829u, 1202900863u, 817233897u, 3183342108u, 3401237130u, 1404277552u, 615818150u, 3134207493u, 3453421203u, 1423857449u, 601450431u, 3009837614u, 3294710456u, 1567103746u, 711928724u, 3020668471u, 3272380065u, 1510334235u, 755167117u}",
        "translated_code": "use lazy_static::lazy_static;\n\nlazy_static! {\n    pub static ref CRC32_TABLE: [u32; 256] = [\n        0u32, 1996959894u32, 3993919788u32, 2567524794u32, 124634137u32, 1886057615u32, 3915621685u32, 2657392035u32,\n        249268274u32, 2044508324u32, 3772115230u32, 2547177864u32, 162941995u32, 2125561021u32, 3887607047u32, 2428444049u32,\n        498536548u32, 1789927666u32, 4089016648u32, 2227061214u32, 450548861u32, 1843258603u32, 4107580753u32, 2211677639u32,\n        325883990u32, 1684777152u32, 4251122042u32, 2321926636u32, 335633487u32, 1661365465u32, 4195302755u32, 2366115317u32,\n        997073096u32, 1281953886u32, 3579855332u32, 2724688242u32, 1006888145u32, 1258607687u32, 3524101629u32, 2768942443u32,\n        901097722u32, 1119000684u32, 3686517206u32, 2898065728u32, 853044451u32, 1172266101u32, 3705015759u32, 2882616665u32,\n        651767980u32, 1373503546u32, 3369554304u32, 3218104598u32, 565507253u32, 1454621731u32, 3485111705u32, 3099436303u32,\n        671266974u32, 1594198024u32, 3322730930u32, 2970347812u32, 795835527u32, 1483230225u32, 3244367275u32, 3060149565u32,\n        1994146192u32, 31158534u32, 2563907772u32, 4023717930u32, 1907459465u32, 112637215u32, 2680153253u32, 3904427059u32,\n        2013776290u32, 251722036u32, 2517215374u32, 3775830040u32, 2137656763u32, 141376813u32, 2439277719u32, 3865271297u32,\n        1802195444u32, 476864866u32, 2238001368u32, 4066508878u32, 1812370925u32, 453092731u32, 2181625025u32, 4111451223u32,\n        1706088902u32, 314042704u32, 2344532202u32, 4240017532u32, 1658658271u32, 366619977u32, 2362670323u32, 4224994405u32,\n        1303535960u32, 984961486u32, 2747007092u32, 3569037538u32, 1256170817u32, 1037604311u32, 2765210733u32, 3554079995u32,\n        1131014506u32, 879679996u32, 2909243462u32, 3663771856u32, 1141124467u32, 855842277u32, 2852801631u32, 3708648649u32,\n        1342533948u32, 654459306u32, 3188396048u32, 3373015174u32, 1466479909u32, 544179635u32, 3110523913u32, 3462522015u32,\n        1591671054u32, 702138776u32, 2966460450u32, 3352799412u32, 1504918807u32, 783551873u32, 3082640443u32, 3233442989u32,\n        3988292384u32, 2596254646u32, 62317068u32, 1957810842u32, 3939845945u32, 2647816111u32, 81470997u32, 1943803523u32,\n        3814918930u32, 2489596804u32, 225274430u32, 2053790376u32, 3826175755u32, 2466906013u32, 167816743u32, 2097651377u32,\n        4027552580u32, 2265490386u32, 503444072u32, 1762050814u32, 4150417245u32, 2154129355u32, 426522225u32, 1852507879u32,\n        4275313526u32, 2312317920u32, 282753626u32, 1742555852u32, 4189708143u32, 2394877945u32, 397917763u32, 1622183637u32,\n        3604390888u32, 2714866558u32, 953729732u32, 1340076626u32, 3518719985u32, 2797360999u32, 1068828381u32, 1219638859u32,\n        3624741850u32, 2936675148u32, 906185462u32, 1090812512u32, 3747672003u32, 2825379669u32, 829329135u32, 1181335161u32,\n        3412177804u32, 3160834842u32, 628085408u32, 1382605366u32, 3423369109u32, 3138078467u32, 570562233u32, 1426400815u32,\n        3317316542u32, 2998733608u32, 733239954u32, 1555261956u32, 3268935591u32, 3050360625u32, 752459403u32, 1541320221u32,\n        2607071920u32, 3965973030u32, 1969922972u32, 40735498u32, 2617837225u32, 3943577151u32, 1913087877u32, 83908371u32,\n        2512341634u32, 3803740692u32, 2075208622u32, 213261112u32, 2463272603u32, 3855990285u32, 2094854071u32, 198958881u32,\n        2262029012u32, 4057260610u32, 1759359992u32, 534414190u32, 2176718541u32, 4139329115u32, 1873836001u32, 414664567u32,\n        2282248934u32, 4279200368u32, 1711684554u32, 285281116u32, 2405801727u32, 4167216745u32, 1634467795u32, 376229701u32,\n        2685067896u32, 3608007406u32, 1308918612u32, 956543938u32, 2808555105u32, 3495958263u32, 1231636301u32, 1047427035u32,\n        2932959818u32, 3654703836u32, 1088359270u32, 936918000u32, 2847714899u32, 3736837829u32, 1202900863u32, 817233897u32,\n        3183342108u32, 3401237130u32, 1404277552u32, 615818150u32, 3134207493u32, 3453421203u32, 1423857449u32, 601450431u32,\n        3009837614u32, 3294710456u32, 1567103746u32, 711928724u32, 3020668471u32, 3272380065u32, 1510334235u32, 755167117u32\n    ];\n}",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "const unsigned long [256]",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "verify_gzip_header": {
        "source_code": "static int verify_gzip_header(const unsigned char *data, size_t size)\n{\n  if (size < 10)\n  {\n    return 0;\n  }\n  if ((data[0] != 0x1f) || (data[1] != 0x8b))\n  {\n    return 0;\n  }\n  if (data[2] != 8)\n  {\n    return 0;\n  }\n  return 1;\n}\n\n",
        "translated_code": "pub fn verify_gzip_header(data: Option<&[u8]>, size: usize) -> bool {\n    // Check if data is None (equivalent to NULL check in C)\n    if data.is_none() {\n        return false;\n    }\n    let data = data.unwrap();\n\n    // Check size first (Rust slices are bounds-checked, but we need to verify minimum length)\n    if size < 10 {\n        return false;\n    }\n\n    // Check magic bytes (0x1f, 0x8b)\n    if data[0] != 0x1f || data[1] != 0x8b {\n        return false;\n    }\n\n    // Check compression method (must be 8 for DEFLATE)\n    if data[2] != 8 {\n        return false;\n    }\n\n    true\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_zopfli.rs",
        "error": "",
        "dependent": [],
        "params": [
            "const unsigned char *data",
            "size_t size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "data",
            "size"
        ],
        "calle": [],
        "calle_c": [],
        "key": "verify_gzip_header",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "verify_zlib_header": {
        "source_code": "static int verify_zlib_header(const unsigned char *data, size_t size)\n{\n  if (size < 2)\n  {\n    return 0;\n  }\n  if ((data[0] & 0x0f) != 0x08)\n  {\n    return 0;\n  }\n  if ((((data[0] << 8) + data[1]) % 31) != 0)\n  {\n    return 0;\n  }\n  return 1;\n}\n\n",
        "translated_code": "pub fn verify_zlib_header(data: Option<&[u8]>, size: usize) -> bool {\n    // Check if data is None (equivalent to NULL check in C)\n    let data = match data {\n        Some(d) => d,\n        None => return false,\n    };\n\n    // Check size condition (line 3-6)\n    if size < 2 {\n        return false;\n    }\n\n    // Check first byte condition (line 7-10)\n    if (data[0] & 0x0f) != 0x08 {\n        return false;\n    }\n\n    // Check checksum condition (line 11-14)\n    if (u16::from(data[0]) << 8 | u16::from(data[1])) % 31 != 0 {\n        return false;\n    }\n\n    // All checks passed (line 15)\n    true\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_zopfli.rs",
        "error": "",
        "dependent": [],
        "params": [
            "const unsigned char *data",
            "size_t size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "data",
            "size"
        ],
        "calle": [],
        "calle_c": [],
        "key": "verify_zlib_header",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "verify_deflate_format": {
        "source_code": "static int verify_deflate_format(const unsigned char *data, size_t size)\n{\n  if (size < 1)\n  {\n    return 0;\n  }\n  unsigned char first_byte = data[0];\n  unsigned char block_type = (first_byte >> 1) & 0x03;\n  return block_type <= 2;\n}\n\n",
        "translated_code": "pub fn verify_deflate_format(data: Option<&[u8]>, size: usize) -> bool {\n    // Check if data is None or size is too small\n    if size < 1 || data.is_none() {\n        return false;\n    }\n\n    let data = data.unwrap(); // Safe unwrap since we checked is_none()\n    let first_byte = data[0];\n    let block_type = (first_byte >> 1) & 0x03;\n    \n    block_type <= 2\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_zopfli.rs",
        "error": "",
        "dependent": [],
        "params": [
            "const unsigned char *data",
            "size_t size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "data",
            "size",
            "first_byte",
            "block_type"
        ],
        "calle": [],
        "calle_c": [],
        "key": "verify_deflate_format",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliBlockSplitSimple": {
        "source_code": "void ZopfliBlockSplitSimple(const unsigned char *in, size_t instart, size_t inend, size_t blocksize, size_t **splitpoints, size_t *npoints)\n{\n  size_t i = instart;\n  while (i < inend)\n  {\n    {\n      if (!((*npoints) & ((*npoints) - 1)))\n      {\n        *splitpoints = ((*npoints) == 0) ? (malloc(sizeof(*(*splitpoints)))) : (realloc(*splitpoints, ((*npoints) * 2) * (sizeof(*(*splitpoints)))));\n      }\n      (*splitpoints)[*npoints] = i;\n      *npoints += 1;\n    }\n    ;\n    i += blocksize;\n  }\n\n  (void) in;\n}\n\n",
        "translated_code": "pub fn ZopfliBlockSplitSimple(\n    in_data: &[u8],\n    instart: usize,\n    inend: usize,\n    blocksize: usize,\n    splitpoints: &mut Vec<usize>,\n    npoints: &mut usize,\n) {\n    let mut i = instart;\n    while i < inend {\n        // Check if npoints is a power of 2 (including 0)\n        if (*npoints & (*npoints - 1)) == 0 {\n            // Double the capacity when npoints is a power of 2\n            if *npoints == splitpoints.capacity() {\n                splitpoints.reserve(if *npoints == 0 { 1 } else { *npoints });\n            }\n        }\n\n        splitpoints.push(i);\n        *npoints += 1;\n\n        i += blocksize;\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "blocksplitter.rs",
        "error": "",
        "dependent": [],
        "header": "void ZopfliBlockSplitSimple(const unsigned char *in, size_t instart, size_t inend, size_t blocksize, size_t **splitpoints, size_t *npoints)",
        "params": [
            "const unsigned char *in",
            "size_t instart",
            "size_t inend",
            "size_t blocksize",
            "size_t **splitpoints",
            "size_t *npoints"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "in",
            "instart",
            "inend",
            "blocksize",
            "splitpoints",
            "npoints",
            "i"
        ],
        "calle": [
            "realloc",
            "malloc"
        ],
        "calle_c": [
            "realloc",
            "malloc"
        ],
        "key": "ZopfliBlockSplitSimple",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "AddSorted": {
        "source_code": "static void AddSorted(size_t value, size_t **out, size_t *outsize)\n{\n  size_t i;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = value;\n    *outsize += 1;\n  }\n  ;\n  for (i = 0; (i + 1) < (*outsize); i += 1)\n  {\n    if ((*out)[i] > value)\n    {\n      size_t j;\n      for (j = (*outsize) - 1; j > i; j -= 1)\n      {\n        (*out)[j] = (*out)[j - 1];\n      }\n\n      (*out)[i] = value;\n      break;\n    }\n  }\n\n}\n\n",
        "translated_code": "use std::vec;\n\npub fn AddSorted(value: usize, out: &mut Option<Vec<usize>>, outsize: &mut usize) {\n    // Check if outsize is a power of 2 (including 0)\n    if (*outsize & (*outsize - 1)) == 0 {\n        // Equivalent to the C malloc/realloc logic but using Vec\n        match out {\n            Some(vec) => {\n                // Double the capacity when needed (similar to realloc)\n                if vec.capacity() == *outsize {\n                    vec.reserve(if *outsize == 0 { 1 } else { *outsize });\n                }\n            }\n            None => {\n                // Equivalent to malloc for initial allocation\n                *out = Some(Vec::with_capacity(1));\n            }\n        }\n    }\n\n    // Push the value to the end (equivalent to line 9-10 in C)\n    if let Some(vec) = out {\n        vec.push(value);\n        *outsize += 1;\n    }\n\n    // Find insertion point and shift elements (equivalent to lines 13-26 in C)\n    if let Some(vec) = out {\n        for i in 0..(*outsize - 1) {\n            if vec[i] > value {\n                // Shift elements to make space\n                vec.insert(i, value);\n                // Remove the duplicate at the end (since we pushed earlier)\n                vec.pop();\n                break;\n            }\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "blocksplitter.rs",
        "error": "",
        "dependent": [],
        "params": [
            "size_t value",
            "size_t **out",
            "size_t *outsize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value",
            "out",
            "outsize",
            "i",
            "j"
        ],
        "calle": [
            "realloc",
            "malloc"
        ],
        "calle_c": [
            "realloc",
            "malloc"
        ],
        "key": "AddSorted",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "FindLargestSplittableBlock": {
        "source_code": "static int FindLargestSplittableBlock(size_t lz77size, const unsigned char *done, const size_t *splitpoints, size_t npoints, size_t *lstart, size_t *lend)\n{\n  size_t longest = 0;\n  int found = 0;\n  size_t i;\n  for (i = 0; i <= npoints; i += 1)\n  {\n    size_t start = (i == 0) ? (0) : (splitpoints[i - 1]);\n    size_t end = (i == npoints) ? (lz77size - 1) : (splitpoints[i]);\n    if ((!done[start]) && ((end - start) > longest))\n    {\n      *lstart = start;\n      *lend = end;\n      found = 1;\n      longest = end - start;\n    }\n  }\n\n  return found;\n}\n\n",
        "translated_code": "pub fn FindLargestSplittableBlock(\n    lz77size: usize,\n    done: &[u8],\n    splitpoints: &[usize],\n    npoints: usize,\n    lstart: &mut usize,\n    lend: &mut usize,\n) -> bool {\n    let mut longest = 0;\n    let mut found = false;\n\n    for i in 0..=npoints {\n        let start = if i == 0 { 0 } else { splitpoints[i - 1] };\n        let end = if i == npoints { lz77size - 1 } else { splitpoints[i] };\n\n        if done[start] == 0 && (end - start) > longest {\n            *lstart = start;\n            *lend = end;\n            found = true;\n            longest = end - start;\n        }\n    }\n\n    found\n}",
        "hint": "functions",
        "section": "src",
        "file": "blocksplitter.rs",
        "error": "",
        "dependent": [],
        "params": [
            "size_t lz77size",
            "const unsigned char *done",
            "const size_t *splitpoints",
            "size_t npoints",
            "size_t *lstart",
            "size_t *lend"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "lz77size",
            "done",
            "splitpoints",
            "npoints",
            "lstart",
            "lend",
            "longest",
            "found",
            "i",
            "start",
            "end"
        ],
        "calle": [],
        "calle_c": [],
        "key": "FindLargestSplittableBlock",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliGetDistExtraBits": {
        "source_code": "static int ZopfliGetDistExtraBits(int dist)\n{\n  if (dist < 5)\n  {\n    return 0;\n  }\n  return (31 ^ __builtin_clz(dist - 1)) - 1;\n}\n\n",
        "translated_code": "pub fn ZopfliGetDistExtraBits(dist: i32) -> i32 {\n    if dist < 5 {\n        return 0;\n    }\n    (31 ^ (dist - 1).leading_zeros() as i32) - 1\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [],
        "params": [
            "int dist"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "dist"
        ],
        "calle": [
            "__builtin_clz"
        ],
        "calle_c": [
            "__builtin_clz"
        ],
        "key": "ZopfliGetDistExtraBits",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliGetDistExtraBitsValue": {
        "source_code": "static int ZopfliGetDistExtraBitsValue(int dist)\n{\n  if (dist < 5)\n  {\n    return 0;\n  }\n  else\n  {\n    int l = 31 ^ __builtin_clz(dist - 1);\n    return (dist - (1 + (1 << l))) & ((1 << (l - 1)) - 1);\n  }\n}\n\n",
        "translated_code": "pub fn ZopfliGetDistExtraBitsValue(dist: i32) -> i32 {\n    if dist < 5 {\n        0\n    } else {\n        let l = 31 ^ (dist - 1).leading_zeros() as i32;\n        (dist - (1 + (1 << l))) & ((1 << (l - 1)) - 1)\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [],
        "params": [
            "int dist"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "dist",
            "l"
        ],
        "calle": [
            "__builtin_clz"
        ],
        "calle_c": [
            "__builtin_clz"
        ],
        "key": "ZopfliGetDistExtraBitsValue",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliGetDistSymbol": {
        "source_code": "static int ZopfliGetDistSymbol(int dist)\n{\n  if (dist < 5)\n  {\n    return dist - 1;\n  }\n  else\n  {\n    int l = 31 ^ __builtin_clz(dist - 1);\n    int r = ((dist - 1) >> (l - 1)) & 1;\n    return (l * 2) + r;\n  }\n}\n\n",
        "translated_code": "pub fn ZopfliGetDistSymbol(dist: i32) -> i32 {\n    if dist < 5 {\n        dist - 1\n    } else {\n        let l = 31 ^ (dist - 1).leading_zeros() as i32;\n        let r = ((dist - 1) >> (l - 1)) & 1;\n        (l * 2) + r\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [],
        "params": [
            "int dist"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "dist",
            "l",
            "r"
        ],
        "calle": [
            "__builtin_clz"
        ],
        "calle_c": [
            "__builtin_clz"
        ],
        "key": "ZopfliGetDistSymbol",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliGetLengthExtraBits": {
        "source_code": "static int ZopfliGetLengthExtraBits(int l)\n{\n  static const int table[259] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0};\n  return table[l];\n}\n\n",
        "translated_code": "pub fn ZopfliGetLengthExtraBits(l: usize) -> i32 {\n    static TABLE: [i32; 259] = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n        2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0,\n    ];\n    TABLE[l]\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [],
        "params": [
            "int l"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "l",
            "table"
        ],
        "calle": [],
        "calle_c": [],
        "key": "ZopfliGetLengthExtraBits",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliGetLengthExtraBitsValue": {
        "source_code": "static int ZopfliGetLengthExtraBitsValue(int l)\n{\n  static const int table[259] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 0};\n  return table[l];\n}\n\n",
        "translated_code": "pub fn ZopfliGetLengthExtraBitsValue(l: usize) -> i32 {\n    static TABLE: [i32; 259] = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2,\n        3, 0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0,\n        1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4,\n        5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\n        15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\n        10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0,\n        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\n        26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,\n        19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n        12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 0,\n    ];\n    TABLE[l]\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [],
        "params": [
            "int l"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "l",
            "table"
        ],
        "calle": [],
        "calle_c": [],
        "key": "ZopfliGetLengthExtraBitsValue",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliGetLengthSymbol": {
        "source_code": "static int ZopfliGetLengthSymbol(int l)\n{\n  static const int table[259] = {0, 0, 0, 257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268, 269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272, 272, 272, 273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274, 275, 275, 275, 275, 275, 275, 275, 275, 276, 276, 276, 276, 276, 276, 276, 276, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 285};\n  return table[l];\n}\n\n",
        "translated_code": "pub fn ZopfliGetLengthSymbol(l: usize) -> i32 {\n    static TABLE: [i32; 259] = [\n        0, 0, 0, 257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268,\n        269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272, 272, 272, 273, 273,\n        273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274, 275, 275, 275, 275,\n        275, 275, 275, 275, 276, 276, 276, 276, 276, 276, 276, 276, 277, 277, 277, 277, 277, 277,\n        277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 278, 278, 278, 278, 278, 278, 278, 278,\n        278, 278, 278, 278, 278, 278, 278, 278, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279,\n        279, 279, 279, 279, 279, 279, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280,\n        280, 280, 280, 280, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,\n        281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,\n        282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,\n        282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 283, 283, 283, 283,\n        283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,\n        283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 284, 284, 284, 284, 284, 284, 284, 284,\n        284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284,\n        284, 284, 284, 284, 284, 285,\n    ];\n\n    TABLE[l]\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [],
        "params": [
            "int l"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "l",
            "table"
        ],
        "calle": [],
        "calle_c": [],
        "key": "ZopfliGetLengthSymbol",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliGetLengthSymbolExtraBits": {
        "source_code": "static int ZopfliGetLengthSymbolExtraBits(int s)\n{\n  static const int table[29] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n  return table[s - 257];\n}\n\n",
        "translated_code": "pub fn ZopfliGetLengthSymbolExtraBits(s: i32) -> i32 {\n    const TABLE: [i32; 29] = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];\n    TABLE[(s - 257) as usize]\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [],
        "params": [
            "int s"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "s",
            "table"
        ],
        "calle": [],
        "calle_c": [],
        "key": "ZopfliGetLengthSymbolExtraBits",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliGetDistSymbolExtraBits": {
        "source_code": "static int ZopfliGetDistSymbolExtraBits(int s)\n{\n  static const int table[30] = {0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13};\n  return table[s];\n}\n\n",
        "translated_code": "pub fn ZopfliGetDistSymbolExtraBits(s: i32) -> i32 {\n    static TABLE: [i32; 30] = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\n    TABLE[s as usize]\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [],
        "params": [
            "int s"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "s",
            "table"
        ],
        "calle": [],
        "calle_c": [],
        "key": "ZopfliGetDistSymbolExtraBits",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "AddBit": {
        "source_code": "static void AddBit(int bit, unsigned char *bp, unsigned char **out, size_t *outsize)\n{\n  if ((*bp) == 0)\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = 0;\n    *outsize += 1;\n  }\n  ;\n  (*out)[(*outsize) - 1] |= bit << (*bp);\n  *bp = ((*bp) + 1) & 7;\n}\n\n",
        "translated_code": "use std::alloc::{alloc, realloc, Layout};\nuse std::ptr;\n\npub fn AddBit(bit: i32, bp: &mut u8, out: &mut Option<Vec<u8>>, outsize: &mut usize) {\n    if *bp == 0 {\n        if (*outsize & (*outsize - 1)) == 0 {\n            let new_size = if *outsize == 0 { 1 } else { *outsize * 2 };\n            unsafe {\n                match out {\n                    Some(vec) => {\n                        let layout = Layout::array::<u8>(new_size).unwrap();\n                        let ptr = realloc(vec.as_mut_ptr() as *mut u8, layout, new_size);\n                        if ptr.is_null() {\n                            panic!(\"realloc failed\");\n                        }\n                        *vec = Vec::from_raw_parts(ptr, *outsize, new_size);\n                    }\n                    None => {\n                        let layout = Layout::array::<u8>(1).unwrap();\n                        let ptr = alloc(layout);\n                        if ptr.is_null() {\n                            panic!(\"alloc failed\");\n                        }\n                        *out = Some(Vec::from_raw_parts(ptr, 0, 1));\n                    }\n                }\n            }\n        }\n        if let Some(vec) = out {\n            vec.push(0);\n            *outsize += 1;\n        }\n    }\n    if let Some(vec) = out {\n        if *outsize > 0 {\n            let last = vec.len() - 1;\n            vec[last] |= (bit as u8) << *bp;\n        }\n    }\n    *bp = (*bp + 1) & 7;\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [],
        "params": [
            "int bit",
            "unsigned char *bp",
            "unsigned char **out",
            "size_t *outsize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "bit",
            "bp",
            "out",
            "outsize"
        ],
        "calle": [
            "realloc",
            "malloc"
        ],
        "calle_c": [
            "realloc",
            "malloc"
        ],
        "key": "AddBit",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "AddBits": {
        "source_code": "static void AddBits(unsigned symbol, unsigned length, unsigned char *bp, unsigned char **out, size_t *outsize)\n{\n  unsigned i;\n  for (i = 0; i < length; i += 1)\n  {\n    unsigned bit = (symbol >> i) & 1;\n    if ((*bp) == 0)\n    {\n      if (!((*outsize) & ((*outsize) - 1)))\n      {\n        *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n      }\n      (*out)[*outsize] = 0;\n      *outsize += 1;\n    }\n    ;\n    (*out)[(*outsize) - 1] |= bit << (*bp);\n    *bp = ((*bp) + 1) & 7;\n  }\n\n}\n\n",
        "translated_code": "use std::alloc::{self, Layout};\nuse std::ptr;\n\npub fn AddBits(\n    symbol: u32,\n    length: u32,\n    bp: &mut u8,\n    out: &mut Option<Vec<u8>>,\n    outsize: &mut usize,\n) {\n    for i in 0..length {\n        let bit = (symbol >> i) & 1;\n        \n        if *bp == 0 {\n            if (*outsize & (*outsize - 1)) == 0 {\n                let new_size = if *outsize == 0 { 1 } else { *outsize * 2 };\n                let layout = Layout::array::<u8>(new_size).expect(\"Failed to create layout\");\n                let new_ptr = unsafe {\n                    if *outsize == 0 {\n                        alloc::alloc(layout)\n                    } else {\n                        let old_ptr = out.as_mut().unwrap().as_mut_ptr();\n                        alloc::realloc(old_ptr as *mut u8, layout, new_size)\n                    }\n                };\n\n                if new_ptr.is_null() {\n                    panic!(\"Allocation failed\");\n                }\n\n                let new_vec = unsafe { Vec::from_raw_parts(new_ptr, *outsize, new_size) };\n                *out = Some(new_vec);\n            }\n            \n            out.as_mut().unwrap().push(0);\n            *outsize += 1;\n        }\n\n        let last = out.as_mut().unwrap().last_mut().unwrap();\n        *last |= (bit as u8) << *bp;\n        *bp = (*bp + 1) & 7;\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [],
        "params": [
            "unsigned symbol",
            "unsigned length",
            "unsigned char *bp",
            "unsigned char **out",
            "size_t *outsize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "symbol",
            "length",
            "bp",
            "out",
            "outsize",
            "i",
            "bit"
        ],
        "calle": [
            "realloc",
            "malloc"
        ],
        "calle_c": [
            "realloc",
            "malloc"
        ],
        "key": "AddBits",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "AddHuffmanBits": {
        "source_code": "static void AddHuffmanBits(unsigned symbol, unsigned length, unsigned char *bp, unsigned char **out, size_t *outsize)\n{\n  unsigned i;\n  for (i = 0; i < length; i += 1)\n  {\n    unsigned bit = (symbol >> ((length - i) - 1)) & 1;\n    if ((*bp) == 0)\n    {\n      if (!((*outsize) & ((*outsize) - 1)))\n      {\n        *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n      }\n      (*out)[*outsize] = 0;\n      *outsize += 1;\n    }\n    ;\n    (*out)[(*outsize) - 1] |= bit << (*bp);\n    *bp = ((*bp) + 1) & 7;\n  }\n\n}\n\n",
        "translated_code": "use std::alloc::{alloc, realloc, Layout};\n\npub fn AddHuffmanBits(\n    symbol: u32,\n    length: u32,\n    bp: &mut u8,\n    out: &mut Option<Box<[u8]>>,\n    outsize: &mut usize,\n) {\n    for i in 0..length {\n        let bit = (symbol >> ((length - i) - 1)) & 1;\n        if *bp == 0 {\n            if (*outsize & (*outsize - 1)) == 0 {\n                let new_size = if *outsize == 0 { 1 } else { *outsize * 2 };\n                let layout = Layout::array::<u8>(new_size).unwrap();\n                \n                let new_ptr = unsafe {\n                    if let Some(ref mut boxed_slice) = out {\n                        realloc(boxed_slice.as_mut_ptr() as *mut u8, layout, new_size)\n                    } else {\n                        alloc(layout)\n                    }\n                };\n\n                if new_ptr.is_null() {\n                    panic!(\"Allocation failed\");\n                }\n\n                *out = Some(unsafe { Box::from_raw(std::slice::from_raw_parts_mut(new_ptr, new_size)) });\n            }\n            if let Some(ref mut boxed_slice) = out {\n                boxed_slice[*outsize] = 0;\n            }\n            *outsize += 1;\n        }\n\n        if let Some(ref mut boxed_slice) = out {\n            boxed_slice[(*outsize) - 1] |= (bit as u8) << *bp;\n        }\n        *bp = (*bp + 1) & 7;\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [],
        "params": [
            "unsigned symbol",
            "unsigned length",
            "unsigned char *bp",
            "unsigned char **out",
            "size_t *outsize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "symbol",
            "length",
            "bp",
            "out",
            "outsize",
            "i",
            "bit"
        ],
        "calle": [
            "realloc",
            "malloc"
        ],
        "calle_c": [
            "realloc",
            "malloc"
        ],
        "key": "AddHuffmanBits",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "PatchDistanceCodesForBuggyDecoders": {
        "source_code": "static void PatchDistanceCodesForBuggyDecoders(unsigned *d_lengths)\n{\n  int num_dist_codes = 0;\n  int i;\n  for (i = 0; i < 30; i += 1)\n  {\n    if (d_lengths[i])\n    {\n      num_dist_codes += 1;\n    }\n    if (num_dist_codes >= 2)\n    {\n      return;\n    }\n  }\n\n  if (num_dist_codes == 0)\n  {\n    d_lengths[0] = (d_lengths[1] = 1);\n  }\n  else\n    if (num_dist_codes == 1)\n  {\n    d_lengths[(d_lengths[0]) ? (1) : (0)] = 1;\n  }\n}\n\n",
        "translated_code": "pub fn PatchDistanceCodesForBuggyDecoders(d_lengths: &mut [u32; 30]) {\n    let mut num_dist_codes = 0;\n    \n    // Check for at least 2 non-zero distance codes\n    for &length in d_lengths.iter() {\n        if length != 0 {\n            num_dist_codes += 1;\n            if num_dist_codes >= 2 {\n                return;\n            }\n        }\n    }\n\n    match num_dist_codes {\n        0 => {\n            // If no distance codes, set both 0 and 1 to 1\n            d_lengths[0] = 1;\n            d_lengths[1] = 1;\n        },\n        1 => {\n            // If only one distance code, set the other index to 1\n            if d_lengths[0] != 0 {\n                d_lengths[1] = 1;\n            } else {\n                d_lengths[0] = 1;\n            }\n        },\n        _ => () // No action needed for >= 2 (already returned earlier)\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [],
        "params": [
            "unsigned *d_lengths"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "d_lengths",
            "num_dist_codes",
            "i"
        ],
        "calle": [],
        "calle_c": [],
        "key": "PatchDistanceCodesForBuggyDecoders",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "GetFixedTree": {
        "source_code": "static void GetFixedTree(unsigned *ll_lengths, unsigned *d_lengths)\n{\n  size_t i;\n  for (i = 0; i < 144; i += 1)\n  {\n    ll_lengths[i] = 8;\n  }\n\n  for (i = 144; i < 256; i += 1)\n  {\n    ll_lengths[i] = 9;\n  }\n\n  for (i = 256; i < 280; i += 1)\n  {\n    ll_lengths[i] = 7;\n  }\n\n  for (i = 280; i < 288; i += 1)\n  {\n    ll_lengths[i] = 8;\n  }\n\n  for (i = 0; i < 32; i += 1)\n  {\n    d_lengths[i] = 5;\n  }\n\n}\n\n",
        "translated_code": "pub fn GetFixedTree(ll_lengths: &mut [u32], d_lengths: &mut [u32]) {\n    // Initialize ll_lengths\n    for i in 0..144 {\n        ll_lengths[i] = 8;\n    }\n    \n    for i in 144..256 {\n        ll_lengths[i] = 9;\n    }\n    \n    for i in 256..280 {\n        ll_lengths[i] = 7;\n    }\n    \n    for i in 280..288 {\n        ll_lengths[i] = 8;\n    }\n    \n    // Initialize d_lengths\n    for i in 0..32 {\n        d_lengths[i] = 5;\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [],
        "params": [
            "unsigned *ll_lengths",
            "unsigned *d_lengths"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ll_lengths",
            "d_lengths",
            "i"
        ],
        "calle": [],
        "calle_c": [],
        "key": "GetFixedTree",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "AbsDiff": {
        "source_code": "static size_t AbsDiff(size_t x, size_t y)\n{\n  if (x > y)\n  {\n    return x - y;\n  }\n  else\n    return y - x;\n}\n\n",
        "translated_code": "pub fn AbsDiff(x: usize, y: usize) -> usize {\n    if x > y {\n        x - y\n    } else {\n        y - x\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [],
        "params": [
            "size_t x",
            "size_t y"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "x",
            "y"
        ],
        "calle": [],
        "calle_c": [],
        "key": "AbsDiff",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "LeafComparator": {
        "source_code": "static int LeafComparator(const void *a, const void *b)\n{\n  return ((const Node *) a)->weight - ((const Node *) b)->weight;\n}\n\n",
        "translated_code": "use std::cmp::Ordering;\n\npub fn LeafComparator(a: &Node, b: &Node) -> Ordering {\n    a.weight.cmp(&b.weight)\n}",
        "hint": "functions",
        "section": "src",
        "file": "katajainen.rs",
        "error": "",
        "dependent": [],
        "params": [
            "const void *a",
            "const void *b"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "a",
            "b"
        ],
        "calle": [],
        "calle_c": [],
        "key": "LeafComparator",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliVerifyLenDist": {
        "source_code": "void ZopfliVerifyLenDist(const unsigned char *data, size_t datasize, size_t pos, unsigned short dist, unsigned short length)\n{\n  size_t i;\n  assert((pos + length) <= datasize);\n  for (i = 0; i < length; i += 1)\n  {\n    if (data[(pos - dist) + i] != data[pos + i])\n    {\n      assert(data[(pos - dist) + i] == data[pos + i]);\n      break;\n    }\n  }\n\n}\n\n",
        "translated_code": "use std::assert;\n\npub fn ZopfliVerifyLenDist(data: &[u8], pos: usize, dist: u16, length: u16) {\n    assert!(pos + length as usize <= data.len(), \"Position and length exceed data bounds\");\n    \n    for i in 0..length as usize {\n        assert_eq!(\n            data[(pos - dist as usize) + i],\n            data[pos + i],\n            \"Mismatch in data verification at position {}\",\n            i\n        );\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "lz77.rs",
        "error": "",
        "dependent": [],
        "header": "void ZopfliVerifyLenDist(const unsigned char *data, size_t datasize, size_t pos, unsigned short dist, unsigned short length)",
        "params": [
            "const unsigned char *data",
            "size_t datasize",
            "size_t pos",
            "unsigned short dist",
            "unsigned short length"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "data",
            "datasize",
            "pos",
            "dist",
            "length",
            "i"
        ],
        "calle": [
            "assert"
        ],
        "calle_c": [
            "assert"
        ],
        "key": "ZopfliVerifyLenDist",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "CeilDiv": {
        "source_code": "static size_t CeilDiv(size_t a, size_t b)\n{\n  return ((a + b) - 1) / b;\n}\n\n",
        "translated_code": "pub fn CeilDiv(a: usize, b: usize) -> usize {\n    ((a + b) - 1) / b\n}",
        "hint": "functions",
        "section": "src",
        "file": "lz77.rs",
        "error": "",
        "dependent": [],
        "params": [
            "size_t a",
            "size_t b"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "a",
            "b"
        ],
        "calle": [],
        "calle_c": [],
        "key": "CeilDiv",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "GetLengthScore": {
        "source_code": "static int GetLengthScore(int length, int distance)\n{\n  return (distance > 1024) ? (length - 1) : (length);\n}\n\n",
        "translated_code": "pub fn GetLengthScore(length: i32, distance: i32) -> i32 {\n    if distance > 1024 {\n        length - 1\n    } else {\n        length\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "lz77.rs",
        "error": "",
        "dependent": [],
        "params": [
            "int length",
            "int distance"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "length",
            "distance"
        ],
        "calle": [],
        "calle_c": [],
        "key": "GetLengthScore",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "GetMatch": {
        "source_code": "static const unsigned char *GetMatch(const unsigned char *scan, const unsigned char *match, const unsigned char *end, const unsigned char *safe_end)\n{\n  if ((sizeof(size_t)) == 8)\n  {\n    while ((scan < safe_end) && ((*((size_t *) scan)) == (*((size_t *) match))))\n    {\n      scan += 8;\n      match += 8;\n    }\n\n  }\n  else\n    if ((sizeof(unsigned int)) == 4)\n  {\n    while ((scan < safe_end) && ((*((unsigned int *) scan)) == (*((unsigned int *) match))))\n    {\n      scan += 4;\n      match += 4;\n    }\n\n  }\n  else\n  {\n    while (((((((((scan < safe_end) && ((*scan) == (*match))) && ((*(++scan)) == (*(++match)))) && ((*(++scan)) == (*(++match)))) && ((*(++scan)) == (*(++match)))) && ((*(++scan)) == (*(++match)))) && ((*(++scan)) == (*(++match)))) && ((*(++scan)) == (*(++match)))) && ((*(++scan)) == (*(++match))))\n    {\n      scan += 1;\n      match += 1;\n    }\n\n  }\n  while ((scan != end) && ((*scan) == (*match)))\n  {\n    scan += 1;\n    match += 1;\n  }\n\n  return scan;\n}\n\n",
        "translated_code": "pub fn GetMatch<'a>(\n    scan: &'a [u8],\n    match_: &'a [u8],\n    end: &'a [u8],\n    safe_end: &'a [u8],\n) -> Option<&'a [u8]> {\n    let mut scan_ptr = scan.as_ptr();\n    let mut match_ptr = match_.as_ptr();\n    let end_ptr = end.as_ptr();\n    let safe_end_ptr = safe_end.as_ptr();\n    \n    // Process in chunks based on architecture size\n    if std::mem::size_of::<usize>() == 8 {\n        while (scan_ptr as usize) < (safe_end_ptr as usize) {\n            unsafe {\n                let scan_val = *(scan_ptr as *const usize);\n                let match_val = *(match_ptr as *const usize);\n                if scan_val != match_val {\n                    break;\n                }\n                scan_ptr = scan_ptr.add(8);\n                match_ptr = match_ptr.add(8);\n            }\n        }\n    } else if std::mem::size_of::<usize>() == 4 {\n        while (scan_ptr as usize) < (safe_end_ptr as usize) {\n            unsafe {\n                let scan_val = *(scan_ptr as *const u32);\n                let match_val = *(match_ptr as *const u32);\n                if scan_val != match_val {\n                    break;\n                }\n                scan_ptr = scan_ptr.add(4);\n                match_ptr = match_ptr.add(4);\n            }\n        }\n    } else {\n        while (scan_ptr as usize) < (safe_end_ptr as usize) {\n            unsafe {\n                if *scan_ptr != *match_ptr\n                    || *scan_ptr.add(1) != *match_ptr.add(1)\n                    || *scan_ptr.add(2) != *match_ptr.add(2)\n                    || *scan_ptr.add(3) != *match_ptr.add(3)\n                    || *scan_ptr.add(4) != *match_ptr.add(4)\n                    || *scan_ptr.add(5) != *match_ptr.add(5)\n                    || *scan_ptr.add(6) != *match_ptr.add(6)\n                    || *scan_ptr.add(7) != *match_ptr.add(7)\n                {\n                    break;\n                }\n                scan_ptr = scan_ptr.add(8);\n                match_ptr = match_ptr.add(8);\n            }\n        }\n    }\n\n    // Process remaining bytes one by one\n    while (scan_ptr as usize) < (end_ptr as usize) {\n        unsafe {\n            if *scan_ptr != *match_ptr {\n                break;\n            }\n            scan_ptr = scan_ptr.add(1);\n            match_ptr = match_ptr.add(1);\n        }\n    }\n\n    // Calculate the offset and return a slice reference\n    let offset = (scan_ptr as usize - scan.as_ptr() as usize);\n    if offset > 0 {\n        Some(&scan[offset..])\n    } else {\n        Option::None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "lz77.rs",
        "error": "",
        "dependent": [],
        "params": [
            "const unsigned char *scan",
            "const unsigned char *match",
            "const unsigned char *end",
            "const unsigned char *safe_end"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "scan",
            "match",
            "end",
            "safe_end",
            "match_idx",
            "scan_idx"
        ],
        "calle": [],
        "calle_c": [],
        "key": "GetMatch",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "zopfli_min": {
        "source_code": "static size_t zopfli_min(size_t a, size_t b)\n{\n  return (a < b) ? (a) : (b);\n}\n\n",
        "translated_code": "pub fn zopfli_min(a: usize, b: usize) -> usize {\n    if a < b { a } else { b }\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [],
        "params": [
            "size_t a",
            "size_t b"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "a",
            "b"
        ],
        "calle": [],
        "calle_c": [],
        "key": "zopfli_min",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "TraceBackwards": {
        "source_code": "static void TraceBackwards(size_t size, const unsigned short *length_array, unsigned short **path, size_t *pathsize)\n{\n  size_t index = size;\n  if (size == 0)\n  {\n    return;\n  }\n  for (;;)\n  {\n    {\n      if (!((*pathsize) & ((*pathsize) - 1)))\n      {\n        *path = ((*pathsize) == 0) ? (malloc(sizeof(*(*path)))) : (realloc(*path, ((*pathsize) * 2) * (sizeof(*(*path)))));\n      }\n      (*path)[*pathsize] = length_array[index];\n      *pathsize += 1;\n    }\n    ;\n    assert(length_array[index] <= index);\n    assert(length_array[index] <= 258);\n    assert(length_array[index] != 0);\n    index -= length_array[index];\n    if (index == 0)\n    {\n      break;\n    }\n  }\n\n  for (index = 0; index < ((*pathsize) / 2); index += 1)\n  {\n    unsigned short temp = (*path)[index];\n    (*path)[index] = (*path)[((*pathsize) - index) - 1];\n    (*path)[((*pathsize) - index) - 1] = temp;\n  }\n\n}\n\n",
        "translated_code": "use std::assert;\n\npub fn TraceBackwards(\n    size: usize,\n    length_array: &[u16],\n    path: &mut Option<Vec<u16>>,\n    pathsize: &mut usize,\n) {\n    let mut index = size;\n    if size == 0 {\n        return;\n    }\n\n    loop {\n        // Check if pathsize is a power of two (including zero)\n        if (*pathsize & (*pathsize - 1)) == 0 {\n            match path {\n                Some(vec) => {\n                    vec.resize(*pathsize * 2, 0);\n                }\n                None => {\n                    *path = Some(vec![0; 1]);\n                }\n            }\n        }\n\n        if let Some(vec) = path {\n            vec.push(length_array[index]);\n        }\n        *pathsize += 1;\n\n        assert!(length_array[index] <= index as u16);\n        assert!(length_array[index] <= 258);\n        assert!(length_array[index] != 0);\n\n        index -= length_array[index] as usize;\n        if index == 0 {\n            break;\n        }\n    }\n\n    if let Some(vec) = path {\n        for i in 0..(*pathsize / 2) {\n            let temp = vec[i];\n            vec[i] = vec[*pathsize - i - 1];\n            vec[*pathsize - i - 1] = temp;\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [],
        "params": [
            "size_t size",
            "const unsigned short *length_array",
            "unsigned short **path",
            "size_t *pathsize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "size",
            "length_array",
            "path",
            "pathsize",
            "index",
            "temp"
        ],
        "calle": [
            "realloc",
            "assert",
            "malloc"
        ],
        "calle_c": [
            "realloc",
            "assert",
            "malloc"
        ],
        "key": "TraceBackwards",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliLengthsToSymbols": {
        "source_code": "void ZopfliLengthsToSymbols(const unsigned *lengths, size_t n, unsigned maxbits, unsigned *symbols)\n{\n  size_t *bl_count = (size_t *) malloc((sizeof(size_t)) * (maxbits + 1));\n  size_t *next_code = (size_t *) malloc((sizeof(size_t)) * (maxbits + 1));\n  unsigned bits;\n  unsigned i;\n  unsigned code;\n  for (i = 0; i < n; i += 1)\n  {\n    symbols[i] = 0;\n  }\n\n  for (bits = 0; bits <= maxbits; bits += 1)\n  {\n    bl_count[bits] = 0;\n  }\n\n  for (i = 0; i < n; i += 1)\n  {\n    assert(lengths[i] <= maxbits);\n    bl_count[lengths[i]] += 1;\n  }\n\n  code = 0;\n  bl_count[0] = 0;\n  for (bits = 1; bits <= maxbits; bits += 1)\n  {\n    code = (code + bl_count[bits - 1]) << 1;\n    next_code[bits] = code;\n  }\n\n  for (i = 0; i < n; i += 1)\n  {\n    unsigned len = lengths[i];\n    if (len != 0)\n    {\n      symbols[i] = next_code[len];\n      next_code[len] += 1;\n    }\n  }\n\n  free(bl_count);\n  free(next_code);\n}\n\n",
        "translated_code": "use std::assert;\n\npub fn ZopfliLengthsToSymbols(lengths: &[u32], n: usize, maxbits: u32, symbols: &mut [u32]) {\n    // Allocate vectors instead of using malloc\n    let mut bl_count = vec![0; (maxbits + 1) as usize];\n    let mut next_code = vec![0; (maxbits + 1) as usize];\n\n    // Initialize symbols to 0\n    for i in 0..n {\n        symbols[i] = 0;\n    }\n\n    // Initialize bl_count to 0\n    for bits in 0..=maxbits {\n        bl_count[bits as usize] = 0;\n    }\n\n    // Count the number of codes for each length\n    for i in 0..n {\n        assert!(lengths[i] <= maxbits);\n        bl_count[lengths[i] as usize] += 1;\n    }\n\n    // Calculate the next code for each length\n    let mut code = 0;\n    bl_count[0] = 0;\n    for bits in 1..=maxbits {\n        code = (code + bl_count[(bits - 1) as usize]) << 1;\n        next_code[bits as usize] = code;\n    }\n\n    // Assign symbols\n    for i in 0..n {\n        let len = lengths[i];\n        if len != 0 {\n            symbols[i] = next_code[len as usize];\n            next_code[len as usize] += 1;\n        }\n    }\n    // Vectors are automatically dropped when they go out of scope\n}",
        "hint": "functions",
        "section": "src",
        "file": "tree.rs",
        "error": "",
        "dependent": [],
        "header": "void ZopfliLengthsToSymbols(const unsigned *lengths, size_t n, unsigned maxbits, unsigned *symbols)",
        "params": [
            "const unsigned *lengths",
            "size_t n",
            "unsigned maxbits",
            "unsigned *symbols"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "lengths",
            "n",
            "maxbits",
            "symbols",
            "bl_count",
            "next_code",
            "bits",
            "i",
            "code",
            "len"
        ],
        "calle": [
            "free",
            "assert",
            "malloc"
        ],
        "calle_c": [
            "free",
            "assert",
            "malloc"
        ],
        "key": "ZopfliLengthsToSymbols",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliCalculateEntropy": {
        "source_code": "void ZopfliCalculateEntropy(const size_t *count, size_t n, double *bitlengths)\n{\n  static const double kInvLog2 = 1.4426950408889;\n  unsigned sum = 0;\n  unsigned i;\n  double log2sum;\n  for (i = 0; i < n; i += 1)\n  {\n    sum += count[i];\n  }\n\n  log2sum = ((sum == 0) ? (log(n)) : (log(sum))) * kInvLog2;\n  for (i = 0; i < n; i += 1)\n  {\n    if (count[i] == 0)\n    {\n      bitlengths[i] = log2sum;\n    }\n    else\n      bitlengths[i] = log2sum - (log(count[i]) * kInvLog2);\n    if ((bitlengths[i] < 0) && (bitlengths[i] > (-1e-5)))\n    {\n      bitlengths[i] = 0;\n    }\n    assert(bitlengths[i] >= 0);\n  }\n\n}\n\n",
        "translated_code": "use std::f64::consts::LN_2;\nuse std::assert;\n\npub fn ZopfliCalculateEntropy(count: &[usize], bitlengths: &mut [f64]) {\n    const K_INV_LOG2: f64 = 1.4426950408889;  // 1.0 / ln(2)\n    \n    let sum: usize = count.iter().sum();\n    let n = count.len() as f64;\n    \n    let log2sum = if sum == 0 {\n        n.ln() * K_INV_LOG2\n    } else {\n        (sum as f64).ln() * K_INV_LOG2\n    };\n    \n    for (i, &cnt) in count.iter().enumerate() {\n        bitlengths[i] = if cnt == 0 {\n            log2sum\n        } else {\n            log2sum - (cnt as f64).ln() * K_INV_LOG2\n        };\n        \n        // Handle very small negative values (round to zero)\n        if bitlengths[i] < 0.0 && bitlengths[i] > -1e-5 {\n            bitlengths[i] = 0.0;\n        }\n        \n        assert!(bitlengths[i] >= 0.0, \"Bitlength must be non-negative\");\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "tree.rs",
        "error": "",
        "dependent": [],
        "header": "void ZopfliCalculateEntropy(const size_t *count, size_t n, double *bitlengths)",
        "params": [
            "const size_t *count",
            "size_t n",
            "double *bitlengths"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "count",
            "n",
            "bitlengths",
            "kInvLog2",
            "sum",
            "i",
            "log2sum"
        ],
        "calle": [
            "log",
            "assert"
        ],
        "calle_c": [
            "log",
            "assert"
        ],
        "key": "ZopfliCalculateEntropy",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "adler32": {
        "source_code": "static unsigned adler32(const unsigned char *data, size_t size)\n{\n  static const unsigned sums_overflow = 5550;\n  unsigned s1 = 1;\n  unsigned s2 = 1 >> 16;\n  while (size > 0)\n  {\n    size_t amount = (size > sums_overflow) ? (sums_overflow) : (size);\n    size -= amount;\n    while (amount > 0)\n    {\n      s1 += *data;\n      data += 1;\n      s2 += s1;\n      amount -= 1;\n    }\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s2 << 16) | s1;\n}\n\n",
        "translated_code": "use std::cmp::min;\n\npub fn adler32(data: &[u8]) -> u32 {\n    const SUMS_OVERFLOW: usize = 5550;\n    const MOD: u32 = 65521;\n    \n    let mut s1: u32 = 1;\n    let mut s2: u32 = 0;\n    let mut remaining = data.len();\n    let mut data_idx = 0;\n    \n    while remaining > 0 {\n        let amount = min(remaining, SUMS_OVERFLOW);\n        remaining -= amount;\n        \n        for _ in 0..amount {\n            s1 = s1.wrapping_add(data[data_idx] as u32);\n            data_idx += 1;\n            s2 = s2.wrapping_add(s1);\n        }\n        \n        s1 %= MOD;\n        s2 %= MOD;\n    }\n    \n    (s2 << 16) | s1\n}",
        "hint": "functions",
        "section": "src",
        "file": "zlib_container.rs",
        "error": "",
        "dependent": [],
        "params": [
            "const unsigned char *data",
            "size_t size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "data",
            "size",
            "data_idx",
            "sums_overflow",
            "s1",
            "s2",
            "amount"
        ],
        "calle": [],
        "calle_c": [],
        "key": "adler32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "f": {
        "source_code": "pub f: _XImage_funcs",
        "translated_code": "",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": true,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "SplitCostContext": {
        "source_code": "typedef struct SplitCostContext\n{\n  const ZopfliLZ77Store *lz77;\n  size_t start;\n  size_t end;\n} SplitCostContext",
        "translated_code": "use std::vec::Vec;\n\n#[derive(Clone)]\npub struct SplitCostContext {\n    pub lz77: Option<ZopfliLz77Store>,\n    pub start: usize,\n    pub end: usize,\n}",
        "hint": "special_types",
        "section": "src",
        "file": "SplitCostContext.rs",
        "error": "",
        "dependent": [
            "ZopfliLZ77Store"
        ],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "NodePool": {
        "source_code": "typedef struct NodePool\n{\n  Node *next;\n} NodePool",
        "translated_code": "use std::usize;\n\n#[derive(Clone)]\npub struct NodePool {\n    pub next: Option<Box<Node>>,\n}",
        "hint": "special_types",
        "section": "src",
        "file": "NodePool.rs",
        "error": "",
        "dependent": [
            "Node"
        ],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "PrintBlockSplitPoints": {
        "source_code": "static void PrintBlockSplitPoints(const ZopfliLZ77Store *lz77, const size_t *lz77splitpoints, size_t nlz77points)\n{\n  size_t *splitpoints = 0;\n  size_t npoints = 0;\n  size_t i;\n  size_t pos = 0;\n  if (nlz77points > 0)\n  {\n    for (i = 0; i < lz77->size; i += 1)\n    {\n      size_t length = (lz77->dists[i] == 0) ? (1) : (lz77->litlens[i]);\n      if (lz77splitpoints[npoints] == i)\n      {\n        {\n          if (!((*(&npoints)) & ((*(&npoints)) - 1)))\n          {\n            *(&splitpoints) = ((*(&npoints)) == 0) ? (malloc(sizeof(*(*(&splitpoints))))) : (realloc(*(&splitpoints), ((*(&npoints)) * 2) * (sizeof(*(*(&splitpoints))))));\n          }\n          (*(&splitpoints))[*(&npoints)] = pos;\n          *(&npoints) += 1;\n        }\n        ;\n        if (npoints == nlz77points)\n        {\n          break;\n        }\n      }\n      pos += length;\n    }\n\n  }\n  assert(npoints == nlz77points);\n  fprintf(stderr, \"block split points: \");\n  for (i = 0; i < npoints; i += 1)\n  {\n    fprintf(stderr, \"%d \", (int) splitpoints[i]);\n  }\n\n  fprintf(stderr, \"(hex:\");\n  for (i = 0; i < npoints; i += 1)\n  {\n    fprintf(stderr, \" %x\", (int) splitpoints[i]);\n  }\n\n  fprintf(stderr, \")\\n\");\n  free(splitpoints);\n}\n\n",
        "translated_code": "use std::fmt::Write;\n\npub fn PrintBlockSplitPoints(lz77: &ZopfliLz77Store, lz77splitpoints: &[usize], nlz77points: usize) {\n    let mut splitpoints = Vec::new();\n    let mut npoints = 0;\n    let mut pos = 0;\n\n    if nlz77points > 0 {\n        for i in 0..lz77.size {\n            let length = if lz77.dists.as_ref().unwrap()[i] == 0 {\n                1\n            } else {\n                lz77.litlens.as_ref().unwrap()[i] as usize\n            };\n\n            if lz77splitpoints[npoints] == i {\n                if (npoints & (npoints - 1)) == 0 {\n                    if npoints == 0 {\n                        splitpoints.reserve(1);\n                    } else {\n                        splitpoints.reserve(npoints * 2);\n                    }\n                }\n                splitpoints.push(pos);\n                npoints += 1;\n\n                if npoints == nlz77points {\n                    break;\n                }\n            }\n            pos += length;\n        }\n    }\n\n    assert_eq!(npoints, nlz77points);\n    \n    let mut output = String::new();\n    write!(&mut output, \"block split points: \").unwrap();\n    for point in &splitpoints {\n        write!(&mut output, \"{} \", point).unwrap();\n    }\n\n    write!(&mut output, \"(hex:\").unwrap();\n    for point in &splitpoints {\n        write!(&mut output, \" {:x}\", point).unwrap();\n    }\n    write!(&mut output, \")\\n\").unwrap();\n\n    eprint!(\"{}\", output);\n}",
        "hint": "functions",
        "section": "src",
        "file": "blocksplitter.rs",
        "error": "",
        "dependent": [
            "ZopfliLZ77Store"
        ],
        "params": [
            "const ZopfliLZ77Store *lz77",
            "const size_t *lz77splitpoints",
            "size_t nlz77points"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "lz77",
            "lz77splitpoints",
            "nlz77points",
            "splitpoints",
            "npoints",
            "i",
            "pos",
            "length"
        ],
        "calle": [
            "realloc",
            "fprintf",
            "free",
            "malloc",
            "assert"
        ],
        "calle_c": [
            "realloc",
            "fprintf",
            "free",
            "malloc",
            "assert"
        ],
        "key": "PrintBlockSplitPoints",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliInitCache": {
        "source_code": "void ZopfliInitCache(size_t blocksize, ZopfliLongestMatchCache *lmc)\n{\n  size_t i;\n  lmc->length = (unsigned short *) malloc((sizeof(unsigned short)) * blocksize);\n  lmc->dist = (unsigned short *) malloc((sizeof(unsigned short)) * blocksize);\n  lmc->sublen = (unsigned char *) malloc((8 * 3) * blocksize);\n  if (lmc->sublen == 0)\n  {\n    fprintf(stderr, \"Error: Out of memory. Tried allocating %lu bytes of memory.\\n\", (((unsigned long) 8) * 3) * blocksize);\n    exit(1);\n  }\n  for (i = 0; i < blocksize; i += 1)\n  {\n    lmc->length[i] = 1;\n  }\n\n  for (i = 0; i < blocksize; i += 1)\n  {\n    lmc->dist[i] = 0;\n  }\n\n  for (i = 0; i < ((8 * blocksize) * 3); i += 1)\n  {\n    lmc->sublen[i] = 0;\n  }\n\n}\n\n",
        "translated_code": "use std::process;\n\npub fn ZopfliInitCache(blocksize: usize, lmc: &mut ZopfliLongestMatchCache) {\n    // Allocate vectors for length and dist\n    lmc.length = Some(vec![1; blocksize]);\n    lmc.dist = Some(vec![0; blocksize]);\n    \n    // Calculate sublen size (8 * 3 * blocksize)\n    let sublen_size = 8 * 3 * blocksize;\n    lmc.sublen = Some(vec![0; sublen_size]);\n    \n    // In Rust, we don't need to manually check for allocation failure like in C\n    // because Vec::new() will panic if allocation fails (which is the desired behavior)\n    // and we don't need to manually initialize the values since vec![] does that\n}",
        "hint": "functions",
        "section": "src",
        "file": "cache.rs",
        "error": "",
        "dependent": [
            "ZopfliLongestMatchCache"
        ],
        "header": "void ZopfliInitCache(size_t blocksize, ZopfliLongestMatchCache *lmc)",
        "params": [
            "size_t blocksize",
            "ZopfliLongestMatchCache *lmc"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "blocksize",
            "lmc",
            "i"
        ],
        "calle": [
            "exit",
            "fprintf",
            "malloc"
        ],
        "calle_c": [
            "exit",
            "fprintf",
            "malloc"
        ],
        "key": "ZopfliInitCache",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliCleanCache": {
        "source_code": "void ZopfliCleanCache(ZopfliLongestMatchCache *lmc)\n{\n  free(lmc->length);\n  free(lmc->dist);\n  free(lmc->sublen);\n}\n\n",
        "translated_code": "pub fn ZopfliCleanCache(lmc: &mut ZopfliLongestMatchCache) {\n    // In Rust, we don't need explicit free() calls - dropping the Vec will handle deallocation\n    // We can just set all fields to None, which will drop any existing Vecs\n    lmc.length = None;\n    lmc.dist = None;\n    lmc.sublen = None;\n}",
        "hint": "functions",
        "section": "src",
        "file": "cache.rs",
        "error": "",
        "dependent": [
            "ZopfliLongestMatchCache"
        ],
        "header": "void ZopfliCleanCache(ZopfliLongestMatchCache *lmc)",
        "params": [
            "ZopfliLongestMatchCache *lmc"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "lmc"
        ],
        "calle": [
            "free"
        ],
        "calle_c": [
            "free"
        ],
        "key": "ZopfliCleanCache",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliMaxCachedSublen": {
        "source_code": "unsigned ZopfliMaxCachedSublen(const ZopfliLongestMatchCache *lmc, size_t pos, size_t length)\n{\n  unsigned char *cache;\n  cache = &lmc->sublen[(8 * pos) * 3];\n  (void) length;\n  if ((cache[1] == 0) && (cache[2] == 0))\n  {\n    return 0;\n  }\n  return cache[(8 - 1) * 3] + 3;\n}\n\n",
        "translated_code": "pub fn ZopfliMaxCachedSublen(lmc: &ZopfliLongestMatchCache, pos: usize, length: usize) -> u16 {\n    let _ = length; // Explicitly ignore the unused parameter\n    \n    // Access the sublen vector safely\n    let Some(sublen) = &lmc.sublen else {\n        return 0;\n    };\n    \n    let cache_idx = (8 * pos) * 3;\n    \n    // Check if we can safely access the required indices\n    if cache_idx + 2 >= sublen.len() {\n        return 0;\n    }\n    \n    if sublen[cache_idx + 1] == 0 && sublen[cache_idx + 2] == 0 {\n        return 0;\n    }\n    \n    let final_idx = cache_idx + (8 - 1) * 3;\n    if final_idx >= sublen.len() {\n        return 0;\n    }\n    \n    u16::from(sublen[final_idx]) + 3\n}",
        "hint": "functions",
        "section": "src",
        "file": "cache.rs",
        "error": "",
        "dependent": [
            "ZopfliLongestMatchCache"
        ],
        "header": "unsigned ZopfliMaxCachedSublen(const ZopfliLongestMatchCache *lmc, size_t pos, size_t length)",
        "params": [
            "const ZopfliLongestMatchCache *lmc",
            "size_t pos",
            "size_t length"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "lmc",
            "pos",
            "length",
            "cache",
            "cache_idx"
        ],
        "calle": [],
        "calle_c": [],
        "key": "ZopfliMaxCachedSublen",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "InitNode": {
        "source_code": "static void InitNode(size_t weight, int count, Node *tail, Node *node)\n{\n  node->weight = weight;\n  node->count = count;\n  node->tail = tail;\n}\n\n",
        "translated_code": "pub fn InitNode(weight: usize, count: i32, tail: Option<Box<Node>>, node: &mut Node) {\n    node.weight = weight;\n    node.count = count;\n    node.tail = tail;\n}",
        "hint": "functions",
        "section": "src",
        "file": "katajainen.rs",
        "error": "",
        "dependent": [
            "Node"
        ],
        "params": [
            "size_t weight",
            "int count",
            "Node *tail",
            "Node *node"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "weight",
            "count",
            "tail",
            "node"
        ],
        "calle": [],
        "calle_c": [],
        "key": "InitNode",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "InitLists": {
        "source_code": "static void InitLists(NodePool *pool, const Node *leaves, int maxbits, Node *(*lists)[2])\n{\n  int i;\n  Node *node0 = pool->next++;\n  Node *node1 = pool->next++;\n  InitNode(leaves[0].weight, 1, 0, node0);\n  InitNode(leaves[1].weight, 2, 0, node1);\n  for (i = 0; i < maxbits; i += 1)\n  {\n    lists[i][0] = node0;\n    lists[i][1] = node1;\n  }\n\n}\n\n",
        "translated_code": "use std::usize;\n\npub fn InitLists(pool: &mut NodePool, leaves: &[Node], maxbits: usize, lists: &mut [&mut [Option<Box<Node>>; 2]]) {\n    // Take ownership of the next two nodes from the pool\n    let mut node0 = pool.next.take().expect(\"Expected node0 in pool\");\n    let mut node1 = pool.next.take().expect(\"Expected node1 in pool\");\n\n    // Initialize the nodes\n    InitNode(leaves[0].weight, 1, None, &mut node0);\n    InitNode(leaves[1].weight, 2, None, &mut node1);\n\n    // Populate the lists\n    for i in 0..maxbits {\n        lists[i][0] = Some(node0.clone());\n        lists[i][1] = Some(node1.clone());\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "katajainen.rs",
        "error": "",
        "dependent": [
            "InitNode",
            "Node",
            "NodePool"
        ],
        "params": [
            "NodePool *pool",
            "const Node *leaves",
            "int maxbits",
            "Node *(*lists)[2]"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "pool",
            "leaves",
            "maxbits",
            "lists",
            "i",
            "node0",
            "node1"
        ],
        "calle": [
            "InitNode"
        ],
        "calle_c": [],
        "key": "InitLists",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ExtractBitLengths": {
        "source_code": "static void ExtractBitLengths(Node *chain, Node *leaves, unsigned *bitlengths)\n{\n  int counts[16] = {0};\n  unsigned end = 16;\n  unsigned ptr = 15;\n  unsigned value = 1;\n  Node *node;\n  int val;\n  for (node = chain; node; node = node->tail)\n  {\n    end -= 1;\n    counts[end] = node->count;\n  }\n\n  val = counts[15];\n  while (ptr >= end)\n  {\n    for (; val > counts[ptr - 1]; val -= 1)\n    {\n      bitlengths[leaves[val - 1].count] = value;\n    }\n\n    ptr -= 1;\n    value += 1;\n  }\n\n}\n\n",
        "translated_code": "pub fn ExtractBitLengths(chain: Option<&Node>, leaves: &[Node], bitlengths: &mut [u32]) {\n    let mut counts = [0; 16];\n    let mut end = 16;\n    let mut ptr = 15;\n    let mut value = 1;\n    let mut val;\n\n    // Traverse the chain and populate counts array\n    let mut current_node = chain;\n    while let Some(node) = current_node {\n        end -= 1;\n        counts[end] = node.count;\n        current_node = node.tail.as_deref();\n    }\n\n    val = counts[15];\n    while ptr >= end {\n        while val > counts[ptr - 1] {\n            let leaf_index = (val - 1) as usize;\n            if leaf_index < leaves.len() {\n                let node_count = leaves[leaf_index].count as usize;\n                if node_count < bitlengths.len() {\n                    bitlengths[node_count] = value;\n                }\n            }\n            val -= 1;\n        }\n        ptr -= 1;\n        value += 1;\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "katajainen.rs",
        "error": "",
        "dependent": [
            "Node"
        ],
        "params": [
            "Node *chain",
            "Node *leaves",
            "unsigned *bitlengths"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "chain",
            "leaves",
            "bitlengths",
            "counts",
            "end",
            "ptr",
            "value",
            "node",
            "node_idx",
            "val"
        ],
        "calle": [],
        "calle_c": [],
        "key": "ExtractBitLengths",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "BoundaryPMFinal": {
        "source_code": "static void BoundaryPMFinal(Node *(*lists)[2], Node *leaves, int numsymbols, NodePool *pool, int index)\n{\n  int lastcount = lists[index][1]->count;\n  size_t sum = lists[index - 1][0]->weight + lists[index - 1][1]->weight;\n  if ((lastcount < numsymbols) && (sum > leaves[lastcount].weight))\n  {\n    Node *newchain = pool->next;\n    Node *oldchain = lists[index][1]->tail;\n    lists[index][1] = newchain;\n    newchain->count = lastcount + 1;\n    newchain->tail = oldchain;\n  }\n  else\n  {\n    lists[index][1]->tail = lists[index - 1][1];\n  }\n}\n\n",
        "translated_code": "pub fn BoundaryPMFinal(lists: &mut [&mut [Option<Box<Node>>; 2]], leaves: &[Node], numsymbols: i32, pool: &mut NodePool, index: usize) {\n    let lastcount = lists[index][1].as_ref().unwrap().count;\n    let sum = lists[index - 1][0].as_ref().unwrap().weight + lists[index - 1][1].as_ref().unwrap().weight;\n    \n    if (lastcount < numsymbols) && (sum > leaves[lastcount as usize].weight) {\n        let newchain = pool.next.take();\n        let oldchain = lists[index][1].as_mut().unwrap().tail.take();\n        lists[index][1] = newchain;\n        if let Some(ref mut node) = lists[index][1] {\n            node.count = lastcount + 1;\n            node.tail = oldchain;\n        }\n    } else {\n        let prev_tail = lists[index - 1][1].take();\n        lists[index][1].as_mut().unwrap().tail = prev_tail;\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "katajainen.rs",
        "error": "",
        "dependent": [
            "Node",
            "NodePool"
        ],
        "params": [
            "Node *(*lists)[2]",
            "Node *leaves",
            "int numsymbols",
            "NodePool *pool",
            "int index"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "lists",
            "leaves",
            "numsymbols",
            "pool",
            "index",
            "lastcount",
            "sum",
            "newchain",
            "oldchain"
        ],
        "calle": [],
        "calle_c": [],
        "key": "BoundaryPMFinal",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "BoundaryPM": {
        "source_code": "static void BoundaryPM(Node *(*lists)[2], Node *leaves, int numsymbols, NodePool *pool, int index)\n{\n  Node *newchain;\n  Node *oldchain;\n  int lastcount = lists[index][1]->count;\n  if ((index == 0) && (lastcount >= numsymbols))\n  {\n    return;\n  }\n  newchain = pool->next++;\n  oldchain = lists[index][1];\n  lists[index][0] = oldchain;\n  lists[index][1] = newchain;\n  if (index == 0)\n  {\n    InitNode(leaves[lastcount].weight, lastcount + 1, 0, newchain);\n  }\n  else\n  {\n    size_t sum = lists[index - 1][0]->weight + lists[index - 1][1]->weight;\n    if ((lastcount < numsymbols) && (sum > leaves[lastcount].weight))\n    {\n      InitNode(leaves[lastcount].weight, lastcount + 1, oldchain->tail, newchain);\n    }\n    else\n    {\n      InitNode(sum, lastcount, lists[index - 1][1], newchain);\n      BoundaryPM(lists, leaves, numsymbols, pool, index - 1);\n      BoundaryPM(lists, leaves, numsymbols, pool, index - 1);\n    }\n  }\n}\n\n",
        "translated_code": "pub fn BoundaryPM(lists: &mut [Option<Box<Node>>; 2], leaves: &[Node], numsymbols: i32, pool: &mut NodePool, index: i32) {\n    let lastcount = lists[1].as_ref().unwrap().count;\n    \n    if (index == 0) && (lastcount >= numsymbols) {\n        return;\n    }\n    \n    let newchain = pool.next.take();\n    let oldchain = lists[1].take();\n    \n    lists[0] = oldchain.clone();\n    lists[1] = newchain;\n    \n    if index == 0 {\n        InitNode(\n            leaves[lastcount as usize].weight,\n            lastcount + 1,\n            Option::None,\n            lists[1].as_mut().unwrap()\n        );\n    } else {\n        let sum = lists[0].as_ref().unwrap().weight + lists[1].as_ref().unwrap().weight;\n        \n        if (lastcount < numsymbols) && (sum > leaves[lastcount as usize].weight) {\n            InitNode(\n                leaves[lastcount as usize].weight,\n                lastcount + 1,\n                lists[0].as_ref().unwrap().tail.clone(),\n                lists[1].as_mut().unwrap()\n            );\n        } else {\n            InitNode(\n                sum,\n                lastcount,\n                lists[1].clone(),\n                lists[1].as_mut().unwrap()\n            );\n            \n            BoundaryPM(lists, leaves, numsymbols, pool, index - 1);\n            BoundaryPM(lists, leaves, numsymbols, pool, index - 1);\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "katajainen.rs",
        "error": "",
        "dependent": [
            "InitNode",
            "Node",
            "NodePool"
        ],
        "params": [
            "Node *(*lists)[2]",
            "Node *leaves",
            "int numsymbols",
            "NodePool *pool",
            "int index"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "lists",
            "leaves",
            "numsymbols",
            "pool",
            "index",
            "newchain",
            "newchain_idx",
            "oldchain",
            "oldchain_idx",
            "lastcount",
            "sum"
        ],
        "calle": [
            "BoundaryPM",
            "InitNode"
        ],
        "calle_c": [
            "BoundaryPM"
        ],
        "key": "BoundaryPM",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "ZopfliLengthLimitedCodeLengths": {
        "source_code": "int ZopfliLengthLimitedCodeLengths(const size_t *frequencies, int n, int maxbits, unsigned *bitlengths)\n{\n  NodePool pool;\n  int i;\n  int numsymbols = 0;\n  int numBoundaryPMRuns;\n  Node *nodes;\n  Node *(*lists)[2];\n  Node *leaves = (Node *) malloc(n * (sizeof(*leaves)));\n  for (i = 0; i < n; i += 1)\n  {\n    bitlengths[i] = 0;\n  }\n\n  for (i = 0; i < n; i += 1)\n  {\n    if (frequencies[i])\n    {\n      leaves[numsymbols].weight = frequencies[i];\n      leaves[numsymbols].count = i;\n      numsymbols += 1;\n    }\n  }\n\n  if ((1 << maxbits) < numsymbols)\n  {\n    free(leaves);\n    return 1;\n  }\n  if (numsymbols == 0)\n  {\n    free(leaves);\n    return 0;\n  }\n  if (numsymbols == 1)\n  {\n    bitlengths[leaves[0].count] = 1;\n    free(leaves);\n    return 0;\n  }\n  if (numsymbols == 2)\n  {\n    bitlengths[leaves[0].count] += 1;\n    bitlengths[leaves[1].count] += 1;\n    free(leaves);\n    return 0;\n  }\n  for (i = 0; i < numsymbols; i += 1)\n  {\n    if (leaves[i].weight >= (((size_t) 1) << (((sizeof(leaves[0].weight)) * 8) - 9)))\n    {\n      free(leaves);\n      return 1;\n    }\n    leaves[i].weight = (leaves[i].weight << 9) | leaves[i].count;\n  }\n\n  qsort(leaves, numsymbols, sizeof(Node), LeafComparator);\n  for (i = 0; i < numsymbols; i += 1)\n  {\n    leaves[i].weight >>= 9;\n  }\n\n  if ((numsymbols - 1) < maxbits)\n  {\n    maxbits = numsymbols - 1;\n  }\n  nodes = (Node *) malloc(((maxbits * 2) * numsymbols) * (sizeof(Node)));\n  pool.next = nodes;\n  lists = (Node *(*)[2]) malloc(maxbits * (sizeof(*lists)));\n  InitLists(&pool, leaves, maxbits, lists);\n  numBoundaryPMRuns = (2 * numsymbols) - 4;\n  for (i = 0; i < (numBoundaryPMRuns - 1); i += 1)\n  {\n    BoundaryPM(lists, leaves, numsymbols, &pool, maxbits - 1);\n  }\n\n  BoundaryPMFinal(lists, leaves, numsymbols, &pool, maxbits - 1);\n  ExtractBitLengths(lists[maxbits - 1][1], leaves, bitlengths);\n  free(lists);\n  free(leaves);\n  free(nodes);\n  return 0;\n}\n\n",
        "translated_code": "pub fn ZopfliLengthLimitedCodeLengths(\n    frequencies: &[usize],\n    n: i32,\n    maxbits: i32,\n    bitlengths: &mut [u32],\n) -> i32 {\n    let mut pool = NodePool { next: None };\n    let mut numsymbols = 0;\n    let numBoundaryPMRuns;\n    \n    // Initialize bitlengths to 0\n    for i in 0..n as usize {\n        bitlengths[i] = 0;\n    }\n\n    // Count non-zero frequencies and collect leaves\n    let mut leaves: Vec<Node> = Vec::with_capacity(n as usize);\n    for i in 0..n as usize {\n        if frequencies[i] != 0 {\n            leaves.push(Node {\n                weight: frequencies[i],\n                tail: None,\n                count: i as i32,\n            });\n            numsymbols += 1;\n        }\n    }\n\n    if (1 << maxbits) < numsymbols {\n        return 1;\n    }\n    if numsymbols == 0 {\n        return 0;\n    }\n    if numsymbols == 1 {\n        bitlengths[leaves[0].count as usize] = 1;\n        return 0;\n    }\n    if numsymbols == 2 {\n        bitlengths[leaves[0].count as usize] += 1;\n        bitlengths[leaves[1].count as usize] += 1;\n        return 0;\n    }\n\n    // Check weight limits and pack weight with count\n    for i in 0..numsymbols {\n        if leaves[i].weight >= ((1 as usize) << ((std::mem::size_of::<usize>() * 8) - 9)) {\n            return 1;\n        }\n        leaves[i].weight = (leaves[i].weight << 9) | (leaves[i].count as usize);\n    }\n\n    // Sort leaves\n    leaves.sort_by(|a, b| LeafComparator(a, b));\n    \n    // Unpack weights\n    for i in 0..numsymbols {\n        leaves[i].weight >>= 9;\n    }\n\n    let mut maxbits = maxbits;\n    if (numsymbols - 1) < maxbits as usize {\n        maxbits = (numsymbols - 1) as i32;\n    }\n\n    // Allocate nodes\n    let nodes_count = (maxbits * 2) as usize * numsymbols;\n    let mut nodes: Vec<Node> = vec![\n        Node {\n            weight: 0,\n            tail: None,\n            count: 0\n        };\n        nodes_count\n    ];\n    \n    // Set up pool with nodes\n    if !nodes.is_empty() {\n        pool.next = Some(Box::new(nodes[0].clone()));\n        let mut current = &mut pool.next;\n        for i in 1..nodes_count {\n            if let Some(ref mut node) = current {\n                node.tail = Some(Box::new(nodes[i].clone()));\n                current = &mut node.tail;\n            }\n        }\n    }\n\n    let mut lists: Vec<[Option<Box<Node>>; 2]> = vec![[None, None]; maxbits as usize];\n    \n    // Convert lists to mutable references for InitLists\n    let mut lists_refs: Vec<&mut [Option<Box<Node>>; 2]> = Vec::with_capacity(maxbits as usize);\n    for list in lists.iter_mut() {\n        lists_refs.push(list);\n    }\n\n    InitLists(&mut pool, &leaves, maxbits as usize, &mut lists_refs);\n    numBoundaryPMRuns = (2 * numsymbols) - 4;\n    \n    for _ in 0..(numBoundaryPMRuns - 1) {\n        BoundaryPM(&mut lists[(maxbits - 1) as usize], &leaves, numsymbols as i32, &mut pool, maxbits - 1);\n    }\n\n    // Recreate lists_refs for BoundaryPMFinal\n    let mut lists_refs_final: Vec<&mut [Option<Box<Node>>; 2]> = Vec::with_capacity(maxbits as usize);\n    for list in lists.iter_mut() {\n        lists_refs_final.push(list);\n    }\n    \n    BoundaryPMFinal(&mut lists_refs_final, &leaves, numsymbols as i32, &mut pool, (maxbits - 1) as usize);\n    \n    if let Some(chain) = &lists[(maxbits - 1) as usize][1] {\n        ExtractBitLengths(Some(chain), &leaves, bitlengths);\n    }\n\n    0\n}",
        "hint": "functions",
        "section": "src",
        "file": "katajainen.rs",
        "error": "",
        "dependent": [
            "BoundaryPM",
            "BoundaryPMFinal",
            "ExtractBitLengths",
            "InitLists",
            "LeafComparator",
            "Node",
            "NodePool"
        ],
        "header": "int ZopfliLengthLimitedCodeLengths(const size_t *frequencies, int n, int maxbits, unsigned *bitlengths)",
        "params": [
            "const size_t *frequencies",
            "int n",
            "int maxbits",
            "unsigned *bitlengths"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "frequencies",
            "n",
            "maxbits",
            "bitlengths",
            "pool",
            "i",
            "numsymbols",
            "numBoundaryPMRuns",
            "nodes",
            "nodes_idx",
            "lists",
            "lists_idx",
            "leaves"
        ],
        "calle": [
            "free",
            "BoundaryPMFinal",
            "InitLists",
            "BoundaryPM",
            "LeafComparator",
            "ExtractBitLengths",
            "malloc",
            "qsort"
        ],
        "calle_c": [
            "free",
            "qsort",
            "malloc"
        ],
        "key": "ZopfliLengthLimitedCodeLengths",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "ZopfliCalculateBitLengths": {
        "source_code": "void ZopfliCalculateBitLengths(const size_t *count, size_t n, int maxbits, unsigned *bitlengths)\n{\n  int error = ZopfliLengthLimitedCodeLengths(count, n, maxbits, bitlengths);\n  (void) error;\n  assert(!error);\n}\n\n",
        "translated_code": "pub fn ZopfliCalculateBitLengths(\n    count: &[usize],\n    n: usize,\n    maxbits: i32,\n    bitlengths: &mut [u32],\n) {\n    let error = ZopfliLengthLimitedCodeLengths(count, n as i32, maxbits, bitlengths);\n    assert!(error == 0);\n}",
        "hint": "functions",
        "section": "src",
        "file": "tree.rs",
        "error": "",
        "dependent": [
            "ZopfliLengthLimitedCodeLengths"
        ],
        "header": "void ZopfliCalculateBitLengths(const size_t *count, size_t n, int maxbits, unsigned *bitlengths)",
        "params": [
            "const size_t *count",
            "size_t n",
            "int maxbits",
            "unsigned *bitlengths"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "count",
            "n",
            "maxbits",
            "bitlengths",
            "error"
        ],
        "calle": [
            "ZopfliLengthLimitedCodeLengths",
            "assert"
        ],
        "calle_c": [
            "assert"
        ],
        "key": "ZopfliCalculateBitLengths",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "EncodeTree": {
        "source_code": "static size_t EncodeTree(const unsigned *ll_lengths, const unsigned *d_lengths, int use_16, int use_17, int use_18, unsigned char *bp, unsigned char **out, size_t *outsize)\n{\n  unsigned lld_total;\n  unsigned *rle = 0;\n  unsigned *rle_bits = 0;\n  size_t rle_size = 0;\n  size_t rle_bits_size = 0;\n  unsigned hlit = 29;\n  unsigned hdist = 29;\n  unsigned hclen;\n  unsigned hlit2;\n  size_t i;\n  size_t j;\n  size_t clcounts[19];\n  unsigned clcl[19];\n  unsigned clsymbols[19];\n  static const unsigned order[19] = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n  int size_only = !out;\n  size_t result_size = 0;\n  for (i = 0; i < 19; i += 1)\n  {\n    clcounts[i] = 0;\n  }\n\n  while ((hlit > 0) && (ll_lengths[(257 + hlit) - 1] == 0))\n  {\n    hlit -= 1;\n  }\n\n  while ((hdist > 0) && (d_lengths[(1 + hdist) - 1] == 0))\n  {\n    hdist -= 1;\n  }\n\n  hlit2 = hlit + 257;\n  lld_total = (hlit2 + hdist) + 1;\n  for (i = 0; i < lld_total; i += 1)\n  {\n    unsigned char symbol = (i < hlit2) ? (ll_lengths[i]) : (d_lengths[i - hlit2]);\n    unsigned count = 1;\n    if (use_16 || ((symbol == 0) && (use_17 || use_18)))\n    {\n      for (j = i + 1; (j < lld_total) && (symbol == ((j < hlit2) ? (ll_lengths[j]) : (d_lengths[j - hlit2]))); j += 1)\n      {\n        count += 1;\n      }\n\n    }\n    i += count - 1;\n    if ((symbol == 0) && (count >= 3))\n    {\n      if (use_18)\n      {\n        while (count >= 11)\n        {\n          unsigned count2 = (count > 138) ? (138) : (count);\n          if (!size_only)\n          {\n            {\n              if (!((*(&rle_size)) & ((*(&rle_size)) - 1)))\n              {\n                *(&rle) = ((*(&rle_size)) == 0) ? (malloc(sizeof(*(*(&rle))))) : (realloc(*(&rle), ((*(&rle_size)) * 2) * (sizeof(*(*(&rle))))));\n              }\n              (*(&rle))[*(&rle_size)] = 18;\n              *(&rle_size) += 1;\n            }\n            ;\n            {\n              if (!((*(&rle_bits_size)) & ((*(&rle_bits_size)) - 1)))\n              {\n                *(&rle_bits) = ((*(&rle_bits_size)) == 0) ? (malloc(sizeof(*(*(&rle_bits))))) : (realloc(*(&rle_bits), ((*(&rle_bits_size)) * 2) * (sizeof(*(*(&rle_bits))))));\n              }\n              (*(&rle_bits))[*(&rle_bits_size)] = count2 - 11;\n              *(&rle_bits_size) += 1;\n            }\n            ;\n          }\n          clcounts[18] += 1;\n          count -= count2;\n        }\n\n      }\n      if (use_17)\n      {\n        while (count >= 3)\n        {\n          unsigned count2 = (count > 10) ? (10) : (count);\n          if (!size_only)\n          {\n            {\n              if (!((*(&rle_size)) & ((*(&rle_size)) - 1)))\n              {\n                *(&rle) = ((*(&rle_size)) == 0) ? (malloc(sizeof(*(*(&rle))))) : (realloc(*(&rle), ((*(&rle_size)) * 2) * (sizeof(*(*(&rle))))));\n              }\n              (*(&rle))[*(&rle_size)] = 17;\n              *(&rle_size) += 1;\n            }\n            ;\n            {\n              if (!((*(&rle_bits_size)) & ((*(&rle_bits_size)) - 1)))\n              {\n                *(&rle_bits) = ((*(&rle_bits_size)) == 0) ? (malloc(sizeof(*(*(&rle_bits))))) : (realloc(*(&rle_bits), ((*(&rle_bits_size)) * 2) * (sizeof(*(*(&rle_bits))))));\n              }\n              (*(&rle_bits))[*(&rle_bits_size)] = count2 - 3;\n              *(&rle_bits_size) += 1;\n            }\n            ;\n          }\n          clcounts[17] += 1;\n          count -= count2;\n        }\n\n      }\n    }\n    if (use_16 && (count >= 4))\n    {\n      count -= 1;\n      clcounts[symbol] += 1;\n      if (!size_only)\n      {\n        {\n          if (!((*(&rle_size)) & ((*(&rle_size)) - 1)))\n          {\n            *(&rle) = ((*(&rle_size)) == 0) ? (malloc(sizeof(*(*(&rle))))) : (realloc(*(&rle), ((*(&rle_size)) * 2) * (sizeof(*(*(&rle))))));\n          }\n          (*(&rle))[*(&rle_size)] = symbol;\n          *(&rle_size) += 1;\n        }\n        ;\n        {\n          if (!((*(&rle_bits_size)) & ((*(&rle_bits_size)) - 1)))\n          {\n            *(&rle_bits) = ((*(&rle_bits_size)) == 0) ? (malloc(sizeof(*(*(&rle_bits))))) : (realloc(*(&rle_bits), ((*(&rle_bits_size)) * 2) * (sizeof(*(*(&rle_bits))))));\n          }\n          (*(&rle_bits))[*(&rle_bits_size)] = 0;\n          *(&rle_bits_size) += 1;\n        }\n        ;\n      }\n      while (count >= 3)\n      {\n        unsigned count2 = (count > 6) ? (6) : (count);\n        if (!size_only)\n        {\n          {\n            if (!((*(&rle_size)) & ((*(&rle_size)) - 1)))\n            {\n              *(&rle) = ((*(&rle_size)) == 0) ? (malloc(sizeof(*(*(&rle))))) : (realloc(*(&rle), ((*(&rle_size)) * 2) * (sizeof(*(*(&rle))))));\n            }\n            (*(&rle))[*(&rle_size)] = 16;\n            *(&rle_size) += 1;\n          }\n          ;\n          {\n            if (!((*(&rle_bits_size)) & ((*(&rle_bits_size)) - 1)))\n            {\n              *(&rle_bits) = ((*(&rle_bits_size)) == 0) ? (malloc(sizeof(*(*(&rle_bits))))) : (realloc(*(&rle_bits), ((*(&rle_bits_size)) * 2) * (sizeof(*(*(&rle_bits))))));\n            }\n            (*(&rle_bits))[*(&rle_bits_size)] = count2 - 3;\n            *(&rle_bits_size) += 1;\n          }\n          ;\n        }\n        clcounts[16] += 1;\n        count -= count2;\n      }\n\n    }\n    clcounts[symbol] += count;\n    while (count > 0)\n    {\n      if (!size_only)\n      {\n        {\n          if (!((*(&rle_size)) & ((*(&rle_size)) - 1)))\n          {\n            *(&rle) = ((*(&rle_size)) == 0) ? (malloc(sizeof(*(*(&rle))))) : (realloc(*(&rle), ((*(&rle_size)) * 2) * (sizeof(*(*(&rle))))));\n          }\n          (*(&rle))[*(&rle_size)] = symbol;\n          *(&rle_size) += 1;\n        }\n        ;\n        {\n          if (!((*(&rle_bits_size)) & ((*(&rle_bits_size)) - 1)))\n          {\n            *(&rle_bits) = ((*(&rle_bits_size)) == 0) ? (malloc(sizeof(*(*(&rle_bits))))) : (realloc(*(&rle_bits), ((*(&rle_bits_size)) * 2) * (sizeof(*(*(&rle_bits))))));\n          }\n          (*(&rle_bits))[*(&rle_bits_size)] = 0;\n          *(&rle_bits_size) += 1;\n        }\n        ;\n      }\n      count -= 1;\n    }\n\n  }\n\n  ZopfliCalculateBitLengths(clcounts, 19, 7, clcl);\n  if (!size_only)\n  {\n    ZopfliLengthsToSymbols(clcl, 19, 7, clsymbols);\n  }\n  hclen = 15;\n  while ((hclen > 0) && (clcounts[order[(hclen + 4) - 1]] == 0))\n  {\n    hclen -= 1;\n  }\n\n  if (!size_only)\n  {\n    AddBits(hlit, 5, bp, out, outsize);\n    AddBits(hdist, 5, bp, out, outsize);\n    AddBits(hclen, 4, bp, out, outsize);\n    for (i = 0; i < (hclen + 4); i += 1)\n    {\n      AddBits(clcl[order[i]], 3, bp, out, outsize);\n    }\n\n    for (i = 0; i < rle_size; i += 1)\n    {\n      unsigned symbol = clsymbols[rle[i]];\n      AddHuffmanBits(symbol, clcl[rle[i]], bp, out, outsize);\n      if (rle[i] == 16)\n      {\n        AddBits(rle_bits[i], 2, bp, out, outsize);\n      }\n      else\n        if (rle[i] == 17)\n      {\n        AddBits(rle_bits[i], 3, bp, out, outsize);\n      }\n      else\n        if (rle[i] == 18)\n      {\n        AddBits(rle_bits[i], 7, bp, out, outsize);\n      }\n    }\n\n  }\n  result_size += 14;\n  result_size += (hclen + 4) * 3;\n  for (i = 0; i < 19; i += 1)\n  {\n    result_size += clcl[i] * clcounts[i];\n  }\n\n  result_size += clcounts[16] * 2;\n  result_size += clcounts[17] * 3;\n  result_size += clcounts[18] * 7;\n  free(rle);\n  free(rle_bits);\n  return result_size;\n}\n\n",
        "translated_code": "pub fn EncodeTree(\n    ll_lengths: &[u32],\n    d_lengths: &[u32],\n    use_16: bool,\n    use_17: bool,\n    use_18: bool,\n    bp: &mut u8,\n    out: &mut Option<Vec<u8>>,\n    outsize: &mut usize,\n) -> usize {\n    let mut lld_total;\n    let mut rle: Vec<u32> = Vec::new();\n    let mut rle_bits: Vec<u32> = Vec::new();\n    let mut hlit = 29;\n    let mut hdist = 29;\n    let mut hclen;\n    let mut hlit2;\n    let mut clcounts = [0; 19];\n    let mut clcl = [0; 19];\n    let mut clsymbols = [0; 19];\n    const ORDER: [usize; 19] = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n    let size_only = out.is_none();\n    let mut result_size = 0;\n\n    while hlit > 0 && ll_lengths[(257 + hlit) - 1] == 0 {\n        hlit -= 1;\n    }\n\n    while hdist > 0 && d_lengths[(1 + hdist) - 1] == 0 {\n        hdist -= 1;\n    }\n\n    hlit2 = hlit + 257;\n    lld_total = (hlit2 + hdist) + 1;\n\n    let mut i = 0;\n    while i < lld_total {\n        let symbol = if i < hlit2 {\n            ll_lengths[i]\n        } else {\n            d_lengths[i - hlit2]\n        };\n        let mut count = 1;\n\n        if use_16 || (symbol == 0 && (use_17 || use_18)) {\n            let mut j = i + 1;\n            while j < lld_total && symbol == if j < hlit2 { ll_lengths[j] } else { d_lengths[j - hlit2] } {\n                count += 1;\n                j += 1;\n            }\n        }\n\n        i += count - 1;\n\n        if symbol == 0 && count >= 3 {\n            if use_18 {\n                let mut remaining = count;\n                while remaining >= 11 {\n                    let count2 = if remaining > 138 { 138 } else { remaining };\n                    if !size_only {\n                        rle.push(18);\n                        rle_bits.push((count2 - 11) as u32);\n                    }\n                    clcounts[18] += 1;\n                    remaining -= count2;\n                }\n            }\n\n            if use_17 {\n                let mut remaining = count;\n                while remaining >= 3 {\n                    let count2 = if remaining > 10 { 10 } else { remaining };\n                    if !size_only {\n                        rle.push(17);\n                        rle_bits.push((count2 - 3) as u32);\n                    }\n                    clcounts[17] += 1;\n                    remaining -= count2;\n                }\n            }\n        }\n\n        if use_16 && count >= 4 {\n            count -= 1;\n            clcounts[symbol as usize] += 1;\n            if !size_only {\n                rle.push(symbol);\n                rle_bits.push(0);\n            }\n\n            let mut remaining = count;\n            while remaining >= 3 {\n                let count2 = if remaining > 6 { 6 } else { remaining };\n                if !size_only {\n                    rle.push(16);\n                    rle_bits.push((count2 - 3) as u32);\n                }\n                clcounts[16] += 1;\n                remaining -= count2;\n            }\n        }\n\n        clcounts[symbol as usize] += count as usize;\n        if !size_only {\n            for _ in 0..count {\n                rle.push(symbol);\n                rle_bits.push(0);\n            }\n        }\n\n        i += 1;\n    }\n\n    ZopfliCalculateBitLengths(&clcounts, 19, 7, &mut clcl);\n    if !size_only {\n        ZopfliLengthsToSymbols(&clcl, 19, 7, &mut clsymbols);\n    }\n\n    hclen = 15;\n    while hclen > 0 && clcounts[ORDER[(hclen + 4) - 1]] == 0 {\n        hclen -= 1;\n    }\n\n    if !size_only {\n        AddBits(hlit as u32, 5, bp, out, outsize);\n        AddBits(hdist as u32, 5, bp, out, outsize);\n        AddBits(hclen as u32, 4, bp, out, outsize);\n        for i in 0..(hclen + 4) {\n            AddBits(clcl[ORDER[i]], 3, bp, out, outsize);\n        }\n\n        // Convert Vec to Boxed slice for AddHuffmanBits\n        let mut boxed_out = out.as_mut().map(|v| v.clone().into_boxed_slice());\n        for i in 0..rle.len() {\n            let symbol = clsymbols[rle[i] as usize];\n            AddHuffmanBits(symbol as u32, clcl[rle[i] as usize], bp, &mut boxed_out, outsize);\n            match rle[i] {\n                16 => AddBits(rle_bits[i], 2, bp, out, outsize),\n                17 => AddBits(rle_bits[i], 3, bp, out, outsize),\n                18 => AddBits(rle_bits[i], 7, bp, out, outsize),\n                _ => (),\n            }\n        }\n        // Convert back to Vec if needed\n        if let Some(boxed) = boxed_out {\n            *out = Some(boxed.into_vec());\n        }\n    }\n\n    result_size += 14;\n    result_size += (hclen + 4) * 3;\n    for i in 0..19 {\n        result_size += clcl[i] as usize * clcounts[i];\n    }\n\n    result_size += clcounts[16] * 2;\n    result_size += clcounts[17] * 3;\n    result_size += clcounts[18] * 7;\n\n    result_size\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [
            "AddBits",
            "AddHuffmanBits",
            "ZopfliCalculateBitLengths",
            "ZopfliLengthsToSymbols"
        ],
        "params": [
            "const unsigned *ll_lengths",
            "const unsigned *d_lengths",
            "int use_16",
            "int use_17",
            "int use_18",
            "unsigned char *bp",
            "unsigned char **out",
            "size_t *outsize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ll_lengths",
            "d_lengths",
            "use_16",
            "use_17",
            "use_18",
            "bp",
            "out",
            "outsize",
            "lld_total",
            "rle",
            "rle_bits",
            "rle_size",
            "rle_bits_size",
            "hlit",
            "hdist",
            "hclen",
            "hlit2",
            "i",
            "j",
            "clcounts",
            "clcl",
            "clsymbols",
            "order",
            "size_only",
            "result_size",
            "symbol",
            "count",
            "count2"
        ],
        "calle": [
            "realloc",
            "free",
            "AddHuffmanBits",
            "ZopfliLengthsToSymbols",
            "ZopfliCalculateBitLengths",
            "malloc",
            "AddBits"
        ],
        "calle_c": [
            "realloc",
            "free",
            "malloc"
        ],
        "key": "EncodeTree",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "AddDynamicTree": {
        "source_code": "static void AddDynamicTree(const unsigned *ll_lengths, const unsigned *d_lengths, unsigned char *bp, unsigned char **out, size_t *outsize)\n{\n  int i;\n  int best = 0;\n  size_t bestsize = 0;\n  for (i = 0; i < 8; i += 1)\n  {\n    size_t size = EncodeTree(ll_lengths, d_lengths, i & 1, i & 2, i & 4, 0, 0, 0);\n    if ((bestsize == 0) || (size < bestsize))\n    {\n      bestsize = size;\n      best = i;\n    }\n  }\n\n  EncodeTree(ll_lengths, d_lengths, best & 1, best & 2, best & 4, bp, out, outsize);\n}\n\n",
        "translated_code": "pub fn AddDynamicTree(\n    ll_lengths: &[u32],\n    d_lengths: &[u32],\n    bp: &mut u8,\n    out: &mut Option<Vec<u8>>,\n    outsize: &mut usize,\n) {\n    let mut best = 0;\n    let mut bestsize = 0;\n\n    for i in 0..8 {\n        let size = EncodeTree(\n            ll_lengths,\n            d_lengths,\n            (i & 1) != 0,\n            (i & 2) != 0,\n            (i & 4) != 0,\n            &mut 0,  // Temporary mutable reference for comparison\n            &mut None,  // Temporary mutable reference for comparison\n            &mut 0,  // Temporary mutable reference for comparison\n        );\n\n        if bestsize == 0 || size < bestsize {\n            bestsize = size;\n            best = i;\n        }\n    }\n\n    EncodeTree(\n        ll_lengths,\n        d_lengths,\n        (best & 1) != 0,\n        (best & 2) != 0,\n        (best & 4) != 0,\n        bp,\n        out,\n        outsize,\n    );\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [
            "EncodeTree"
        ],
        "params": [
            "const unsigned *ll_lengths",
            "const unsigned *d_lengths",
            "unsigned char *bp",
            "unsigned char **out",
            "size_t *outsize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ll_lengths",
            "d_lengths",
            "bp",
            "out",
            "outsize",
            "i",
            "best",
            "bestsize",
            "size"
        ],
        "calle": [
            "EncodeTree"
        ],
        "calle_c": [],
        "key": "AddDynamicTree",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "CalculateTreeSize": {
        "source_code": "static size_t CalculateTreeSize(const unsigned *ll_lengths, const unsigned *d_lengths)\n{\n  size_t result = 0;\n  int i;\n  for (i = 0; i < 8; i += 1)\n  {\n    size_t size = EncodeTree(ll_lengths, d_lengths, i & 1, i & 2, i & 4, 0, 0, 0);\n    if ((result == 0) || (size < result))\n    {\n      result = size;\n    }\n  }\n\n  return result;\n}\n\n",
        "translated_code": "pub fn CalculateTreeSize(ll_lengths: &[u32], d_lengths: &[u32]) -> usize {\n    let mut result = 0;\n    \n    for i in 0..8 {\n        let mut bp = 0;\n        let mut out = None;\n        let mut outsize = 0;\n        \n        let size = EncodeTree(\n            ll_lengths,\n            d_lengths,\n            (i & 1) != 0,\n            (i & 2) != 0,\n            (i & 4) != 0,\n            &mut bp,\n            &mut out,\n            &mut outsize,\n        );\n        \n        if result == 0 || size < result {\n            result = size;\n        }\n    }\n    \n    result\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [
            "EncodeTree"
        ],
        "params": [
            "const unsigned *ll_lengths",
            "const unsigned *d_lengths"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ll_lengths",
            "d_lengths",
            "result",
            "i",
            "size"
        ],
        "calle": [
            "EncodeTree"
        ],
        "calle_c": [],
        "key": "CalculateTreeSize",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "OptimizeHuffmanForRle": {
        "source_code": "void OptimizeHuffmanForRle(int length, size_t *counts)\n{\n  int i;\n  int k;\n  int stride;\n  size_t symbol;\n  size_t sum;\n  size_t limit;\n  int *good_for_rle;\n  for (; length >= 0; length -= 1)\n  {\n    if (length == 0)\n    {\n      return;\n    }\n    if (counts[length - 1] != 0)\n    {\n      break;\n    }\n  }\n\n  good_for_rle = (int *) malloc(((unsigned) length) * (sizeof(int)));\n  for (i = 0; i < length; i += 1)\n  {\n    good_for_rle[i] = 0;\n  }\n\n  symbol = counts[0];\n  stride = 0;\n  for (i = 0; i < (length + 1); i += 1)\n  {\n    if ((i == length) || (counts[i] != symbol))\n    {\n      if (((symbol == 0) && (stride >= 5)) || ((symbol != 0) && (stride >= 7)))\n      {\n        for (k = 0; k < stride; k += 1)\n        {\n          good_for_rle[(i - k) - 1] = 1;\n        }\n\n      }\n      stride = 1;\n      if (i != length)\n      {\n        symbol = counts[i];\n      }\n    }\n    else\n    {\n      stride += 1;\n    }\n  }\n\n  stride = 0;\n  limit = counts[0];\n  sum = 0;\n  for (i = 0; i < (length + 1); i += 1)\n  {\n    if (((i == length) || good_for_rle[i]) || (AbsDiff(counts[i], limit) >= 4))\n    {\n      if ((stride >= 4) || ((stride >= 3) && (sum == 0)))\n      {\n        int count = (sum + (stride / 2)) / stride;\n        if (count < 1)\n        {\n          count = 1;\n        }\n        if (sum == 0)\n        {\n          count = 0;\n        }\n        for (k = 0; k < stride; k += 1)\n        {\n          counts[(i - k) - 1] = count;\n        }\n\n      }\n      stride = 0;\n      sum = 0;\n      if (i < (length - 3))\n      {\n        limit = ((((counts[i] + counts[i + 1]) + counts[i + 2]) + counts[i + 3]) + 2) / 4;\n      }\n      else\n        if (i < length)\n      {\n        limit = counts[i];\n      }\n      else\n      {\n        limit = 0;\n      }\n    }\n    stride += 1;\n    if (i != length)\n    {\n      sum += counts[i];\n    }\n  }\n\n  free(good_for_rle);\n}\n\n",
        "translated_code": "pub fn OptimizeHuffmanForRle(length: i32, counts: &mut [usize]) {\n    let mut length = length;\n    \n    // Find the last non-zero element\n    while length >= 0 {\n        if length == 0 {\n            return;\n        }\n        if counts[(length - 1) as usize] != 0 {\n            break;\n        }\n        length -= 1;\n    }\n\n    let length_usize = length as usize;\n    let mut good_for_rle = vec![0; length_usize];\n\n    let mut symbol = counts[0];\n    let mut stride = 0;\n    \n    for i in 0..=length_usize {\n        if i == length_usize || counts[i] != symbol {\n            if (symbol == 0 && stride >= 5) || (symbol != 0 && stride >= 7) {\n                for k in 0..stride {\n                    let idx = (i - k) - 1;\n                    good_for_rle[idx] = 1;\n                }\n            }\n            stride = 1;\n            if i != length_usize {\n                symbol = counts[i];\n            }\n        } else {\n            stride += 1;\n        }\n    }\n\n    let mut stride = 0;\n    let mut limit = counts[0];\n    let mut sum = 0;\n    \n    for i in 0..=length_usize {\n        if i == length_usize || good_for_rle[i] != 0 || AbsDiff(counts[i], limit) >= 4 {\n            if stride >= 4 || (stride >= 3 && sum == 0) {\n                let mut count = (sum + (stride / 2)) / stride;\n                if count < 1 {\n                    count = 1;\n                }\n                if sum == 0 {\n                    count = 0;\n                }\n                for k in 0..stride {\n                    let idx = (i - k) - 1;\n                    counts[idx] = count;\n                }\n            }\n            stride = 0;\n            sum = 0;\n            \n            if i < length_usize - 3 {\n                limit = (counts[i] + counts[i + 1] + counts[i + 2] + counts[i + 3] + 2) / 4;\n            } else if i < length_usize {\n                limit = counts[i];\n            } else {\n                limit = 0;\n            }\n        }\n        stride += 1;\n        if i != length_usize {\n            sum += counts[i];\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [
            "AbsDiff"
        ],
        "params": [
            "int length",
            "size_t *counts"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "length",
            "counts",
            "i",
            "k",
            "stride",
            "symbol",
            "sum",
            "limit",
            "good_for_rle",
            "good_for_rle_idx",
            "count"
        ],
        "calle": [
            "free",
            "AbsDiff",
            "malloc"
        ],
        "calle_c": [
            "free",
            "malloc"
        ],
        "key": "OptimizeHuffmanForRle",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "CRC": {
        "source_code": "static unsigned long CRC(const unsigned char *data, size_t size)\n{\n  unsigned long result = 0xffffffffu;\n  for (; size > 0; size -= 1)\n  {\n    result = crc32_table[(result ^ (*data)) & 0xff] ^ (result >> 8);\n    data += 1;\n  }\n\n  return result ^ 0xffffffffu;\n}\n\n",
        "translated_code": "pub fn CRC(data: Option<&[u8]>) -> Option<u32> {\n    // Check if data is None (equivalent to NULL pointer in C)\n    if data.is_none() {\n        return None;\n    }\n    \n    let data = data.unwrap();\n    let mut result = 0xffffffffu32;\n    \n    for &byte in data {\n        result = CRC32_TABLE[((result ^ u32::from(byte)) & 0xff) as usize] ^ (result >> 8);\n    }\n    \n    Some(result ^ 0xffffffffu32)\n}",
        "hint": "functions",
        "section": "src",
        "file": "gzip_container.rs",
        "error": "",
        "dependent": [
            "crc32_table"
        ],
        "params": [
            "const unsigned char *data",
            "size_t size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "data",
            "size",
            "data_idx",
            "result",
            "crc32_table"
        ],
        "calle": [],
        "calle_c": [],
        "key": "CRC",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "ZopfliAllocHash": {
        "source_code": "void ZopfliAllocHash(size_t window_size, ZopfliHash *h)\n{\n  h->head = (int *) malloc((sizeof(*h->head)) * 65536);\n  h->prev = (unsigned short *) malloc((sizeof(*h->prev)) * window_size);\n  h->hashval = (int *) malloc((sizeof(*h->hashval)) * window_size);\n  h->same = (unsigned short *) malloc((sizeof(*h->same)) * window_size);\n  h->head2 = (int *) malloc((sizeof(*h->head2)) * 65536);\n  h->prev2 = (unsigned short *) malloc((sizeof(*h->prev2)) * window_size);\n  h->hashval2 = (int *) malloc((sizeof(*h->hashval2)) * window_size);\n}\n\n",
        "translated_code": "pub fn ZopfliAllocHash(window_size: usize, h: &mut ZopfliHash) {\n    h.head = Some(vec![0; 65536]);\n    h.prev = Some(vec![0; window_size]);\n    h.hashval = Some(vec![0; window_size]);\n    h.same = Some(vec![0; window_size]);\n    h.head2 = Some(vec![0; 65536]);\n    h.prev2 = Some(vec![0; window_size]);\n    h.hashval2 = Some(vec![0; window_size]);\n}",
        "hint": "functions",
        "section": "src",
        "file": "hash.rs",
        "error": "",
        "dependent": [
            "ZopfliHash"
        ],
        "header": "void ZopfliAllocHash(size_t window_size, ZopfliHash *h)",
        "params": [
            "size_t window_size",
            "ZopfliHash *h"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "window_size",
            "h"
        ],
        "calle": [
            "malloc"
        ],
        "calle_c": [
            "malloc"
        ],
        "key": "ZopfliAllocHash",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliResetHash": {
        "source_code": "void ZopfliResetHash(size_t window_size, ZopfliHash *h)\n{\n  size_t i;\n  h->val = 0;\n  for (i = 0; i < 65536; i += 1)\n  {\n    h->head[i] = -1;\n  }\n\n  for (i = 0; i < window_size; i += 1)\n  {\n    h->prev[i] = i;\n    h->hashval[i] = -1;\n  }\n\n  for (i = 0; i < window_size; i += 1)\n  {\n    h->same[i] = 0;\n  }\n\n  h->val2 = 0;\n  for (i = 0; i < 65536; i += 1)\n  {\n    h->head2[i] = -1;\n  }\n\n  for (i = 0; i < window_size; i += 1)\n  {\n    h->prev2[i] = i;\n    h->hashval2[i] = -1;\n  }\n\n}\n\n",
        "translated_code": "pub fn ZopfliResetHash(window_size: usize, h: &mut ZopfliHash) {\n    h.val = 0;\n    \n    // Initialize head array\n    if let Some(head) = h.head.as_mut() {\n        for i in 0..65536 {\n            head[i] = -1;\n        }\n    }\n\n    // Initialize prev and hashval arrays\n    if let (Some(prev), Some(hashval)) = (h.prev.as_mut(), h.hashval.as_mut()) {\n        for i in 0..window_size {\n            prev[i] = i as u16;\n            hashval[i] = -1;\n        }\n    }\n\n    // Initialize same array\n    if let Some(same) = h.same.as_mut() {\n        for i in 0..window_size {\n            same[i] = 0;\n        }\n    }\n\n    h.val2 = 0;\n    \n    // Initialize head2 array\n    if let Some(head2) = h.head2.as_mut() {\n        for i in 0..65536 {\n            head2[i] = -1;\n        }\n    }\n\n    // Initialize prev2 and hashval2 arrays\n    if let (Some(prev2), Some(hashval2)) = (h.prev2.as_mut(), h.hashval2.as_mut()) {\n        for i in 0..window_size {\n            prev2[i] = i as u16;\n            hashval2[i] = -1;\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "hash.rs",
        "error": "",
        "dependent": [
            "ZopfliHash"
        ],
        "header": "void ZopfliResetHash(size_t window_size, ZopfliHash *h)",
        "params": [
            "size_t window_size",
            "ZopfliHash *h"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "window_size",
            "h",
            "i"
        ],
        "calle": [],
        "calle_c": [],
        "key": "ZopfliResetHash",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliCleanHash": {
        "source_code": "void ZopfliCleanHash(ZopfliHash *h)\n{\n  free(h->head);\n  free(h->prev);\n  free(h->hashval);\n  free(h->head2);\n  free(h->prev2);\n  free(h->hashval2);\n  free(h->same);\n}\n\n",
        "translated_code": "pub fn ZopfliCleanHash(h: &mut ZopfliHash) {\n    h.head = None;\n    h.prev = None;\n    h.hashval = None;\n    h.head2 = None;\n    h.prev2 = None;\n    h.hashval2 = None;\n    h.same = None;\n}",
        "hint": "functions",
        "section": "src",
        "file": "hash.rs",
        "error": "",
        "dependent": [
            "ZopfliHash"
        ],
        "header": "void ZopfliCleanHash(ZopfliHash *h)",
        "params": [
            "ZopfliHash *h"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "h"
        ],
        "calle": [
            "free"
        ],
        "calle_c": [
            "free"
        ],
        "key": "ZopfliCleanHash",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "UpdateHashValue": {
        "source_code": "static void UpdateHashValue(ZopfliHash *h, unsigned char c)\n{\n  h->val = ((h->val << 5) ^ c) & 32767;\n}\n\n",
        "translated_code": "pub fn UpdateHashValue(h: &mut ZopfliHash, c: u8) {\n    h.val = ((h.val << 5) ^ (c as i32)) & 32767;\n}",
        "hint": "functions",
        "section": "src",
        "file": "hash.rs",
        "error": "",
        "dependent": [
            "ZopfliHash"
        ],
        "params": [
            "ZopfliHash *h",
            "unsigned char c"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "h",
            "c"
        ],
        "calle": [],
        "calle_c": [],
        "key": "UpdateHashValue",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliInitLZ77Store": {
        "source_code": "void ZopfliInitLZ77Store(const unsigned char *data, ZopfliLZ77Store *store)\n{\n  store->size = 0;\n  store->litlens = 0;\n  store->dists = 0;\n  store->pos = 0;\n  store->data = data;\n  store->ll_symbol = 0;\n  store->d_symbol = 0;\n  store->ll_counts = 0;\n  store->d_counts = 0;\n}\n\n",
        "translated_code": "pub fn ZopfliInitLZ77Store(data: Option<&[u8]>, store: &mut ZopfliLz77Store) {\n    store.size = 0;\n    store.litlens = None;\n    store.dists = None;\n    store.pos = None;\n    store.data = data.map(|d| d.to_vec());\n    store.ll_symbol = None;\n    store.d_symbol = None;\n    store.ll_counts = None;\n    store.d_counts = None;\n}",
        "hint": "functions",
        "section": "src",
        "file": "lz77.rs",
        "error": "",
        "dependent": [
            "ZopfliLZ77Store"
        ],
        "header": "void ZopfliInitLZ77Store(const unsigned char *data, ZopfliLZ77Store *store)",
        "params": [
            "const unsigned char *data",
            "ZopfliLZ77Store *store"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "data",
            "store"
        ],
        "calle": [],
        "calle_c": [],
        "key": "ZopfliInitLZ77Store",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliCleanLZ77Store": {
        "source_code": "void ZopfliCleanLZ77Store(ZopfliLZ77Store *store)\n{\n  free(store->litlens);\n  free(store->dists);\n  free(store->pos);\n  free(store->ll_symbol);\n  free(store->d_symbol);\n  free(store->ll_counts);\n  free(store->d_counts);\n}\n\n",
        "translated_code": "pub fn ZopfliCleanLZ77Store(store: &mut ZopfliLz77Store) {\n    store.litlens = None;\n    store.dists = None;\n    store.pos = None;\n    store.ll_symbol = None;\n    store.d_symbol = None;\n    store.ll_counts = None;\n    store.d_counts = None;\n}",
        "hint": "functions",
        "section": "src",
        "file": "lz77.rs",
        "error": "",
        "dependent": [
            "ZopfliLZ77Store"
        ],
        "header": "void ZopfliCleanLZ77Store(ZopfliLZ77Store *store)",
        "params": [
            "ZopfliLZ77Store *store"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "store"
        ],
        "calle": [
            "free"
        ],
        "calle_c": [
            "free"
        ],
        "key": "ZopfliCleanLZ77Store",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliLZ77GetByteRange": {
        "source_code": "size_t ZopfliLZ77GetByteRange(const ZopfliLZ77Store *lz77, size_t lstart, size_t lend)\n{\n  size_t l = lend - 1;\n  if (lstart == lend)\n  {\n    return 0;\n  }\n  return (lz77->pos[l] + ((lz77->dists[l] == 0) ? (1) : (lz77->litlens[l]))) - lz77->pos[lstart];\n}\n\n",
        "translated_code": "pub fn ZopfliLZ77GetByteRange(lz77: &ZopfliLz77Store, lstart: usize, lend: usize) -> usize {\n    if lstart == lend {\n        return 0;\n    }\n\n    let l = lend - 1;\n    let pos = lz77.pos.as_ref().expect(\"pos must be initialized\");\n    let dists = lz77.dists.as_ref().expect(\"dists must be initialized\");\n    let litlens = lz77.litlens.as_ref().expect(\"litlens must be initialized\");\n\n    (pos[l] + if dists[l] == 0 { 1 } else { litlens[l] as usize }) - pos[lstart]\n}",
        "hint": "functions",
        "section": "src",
        "file": "lz77.rs",
        "error": "",
        "dependent": [
            "ZopfliLZ77Store"
        ],
        "header": "size_t ZopfliLZ77GetByteRange(const ZopfliLZ77Store *lz77, size_t lstart, size_t lend)",
        "params": [
            "const ZopfliLZ77Store *lz77",
            "size_t lstart",
            "size_t lend"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "lz77",
            "lstart",
            "lend",
            "l"
        ],
        "calle": [],
        "calle_c": [],
        "key": "ZopfliLZ77GetByteRange",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliLZ77GetHistogramAt": {
        "source_code": "static void ZopfliLZ77GetHistogramAt(const ZopfliLZ77Store *lz77, size_t lpos, size_t *ll_counts, size_t *d_counts)\n{\n  size_t llpos = 288 * (lpos / 288);\n  size_t dpos = 32 * (lpos / 32);\n  size_t i;\n  for (i = 0; i < 288; i += 1)\n  {\n    ll_counts[i] = lz77->ll_counts[llpos + i];\n  }\n\n  for (i = lpos + 1; (i < (llpos + 288)) && (i < lz77->size); i += 1)\n  {\n    ll_counts[lz77->ll_symbol[i]] -= 1;\n  }\n\n  for (i = 0; i < 32; i += 1)\n  {\n    d_counts[i] = lz77->d_counts[dpos + i];\n  }\n\n  for (i = lpos + 1; (i < (dpos + 32)) && (i < lz77->size); i += 1)\n  {\n    if (lz77->dists[i] != 0)\n    {\n      d_counts[lz77->d_symbol[i]] -= 1;\n    }\n  }\n\n}\n\n",
        "translated_code": "pub fn ZopfliLZ77GetHistogramAt(\n    lz77: &ZopfliLz77Store,\n    lpos: usize,\n    ll_counts: &mut [usize],\n    d_counts: &mut [usize],\n) {\n    let llpos = 288 * (lpos / 288);\n    let dpos = 32 * (lpos / 32);\n\n    // First loop: copy ll_counts\n    if let Some(ref lz77_ll_counts) = lz77.ll_counts {\n        for i in 0..288 {\n            ll_counts[i] = lz77_ll_counts[llpos + i];\n        }\n    }\n\n    // Second loop: decrement ll_counts based on ll_symbol\n    if let Some(ref lz77_ll_symbol) = &lz77.ll_symbol {\n        for i in (lpos + 1)..(llpos + 288).min(lz77.size) {\n            let symbol = lz77_ll_symbol[i] as usize;\n            ll_counts[symbol] -= 1;\n        }\n    }\n\n    // Third loop: copy d_counts\n    if let Some(ref lz77_d_counts) = lz77.d_counts {\n        for i in 0..32 {\n            d_counts[i] = lz77_d_counts[dpos + i];\n        }\n    }\n\n    // Fourth loop: decrement d_counts based on d_symbol and dists\n    if let (Some(ref lz77_dists), Some(ref lz77_d_symbol)) = (&lz77.dists, &lz77.d_symbol) {\n        for i in (lpos + 1)..(dpos + 32).min(lz77.size) {\n            if lz77_dists[i] != 0 {\n                let symbol = lz77_d_symbol[i] as usize;\n                d_counts[symbol] -= 1;\n            }\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "lz77.rs",
        "error": "",
        "dependent": [
            "ZopfliLZ77Store"
        ],
        "params": [
            "const ZopfliLZ77Store *lz77",
            "size_t lpos",
            "size_t *ll_counts",
            "size_t *d_counts"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "lz77",
            "lpos",
            "ll_counts",
            "d_counts",
            "llpos",
            "dpos",
            "i"
        ],
        "calle": [],
        "calle_c": [],
        "key": "ZopfliLZ77GetHistogramAt",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "InitStats": {
        "source_code": "static void InitStats(SymbolStats *stats)\n{\n  memset(stats->litlens, 0, 288 * (sizeof(stats->litlens[0])));\n  memset(stats->dists, 0, 32 * (sizeof(stats->dists[0])));\n  memset(stats->ll_symbols, 0, 288 * (sizeof(stats->ll_symbols[0])));\n  memset(stats->d_symbols, 0, 32 * (sizeof(stats->d_symbols[0])));\n}\n\n",
        "translated_code": "pub fn InitStats(stats: &mut SymbolStats) {\n    stats.litlens.fill(0);\n    stats.dists.fill(0);\n    stats.ll_symbols.fill(0.0);\n    stats.d_symbols.fill(0.0);\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [
            "SymbolStats"
        ],
        "params": [
            "SymbolStats *stats"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "stats"
        ],
        "calle": [
            "memset"
        ],
        "calle_c": [
            "memset"
        ],
        "key": "InitStats",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "CopyStats": {
        "source_code": "static void CopyStats(SymbolStats *source, SymbolStats *dest)\n{\n  memcpy(dest->litlens, source->litlens, 288 * (sizeof(dest->litlens[0])));\n  memcpy(dest->dists, source->dists, 32 * (sizeof(dest->dists[0])));\n  memcpy(dest->ll_symbols, source->ll_symbols, 288 * (sizeof(dest->ll_symbols[0])));\n  memcpy(dest->d_symbols, source->d_symbols, 32 * (sizeof(dest->d_symbols[0])));\n}\n\n",
        "translated_code": "pub fn CopyStats(source: &SymbolStats, dest: &mut SymbolStats) {\n    dest.litlens.copy_from_slice(&source.litlens);\n    dest.dists.copy_from_slice(&source.dists);\n    dest.ll_symbols.copy_from_slice(&source.ll_symbols);\n    dest.d_symbols.copy_from_slice(&source.d_symbols);\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [
            "SymbolStats"
        ],
        "params": [
            "SymbolStats *source",
            "SymbolStats *dest"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "source",
            "dest"
        ],
        "calle": [
            "memcpy"
        ],
        "calle_c": [
            "memcpy"
        ],
        "key": "CopyStats",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "AddWeighedStatFreqs": {
        "source_code": "static void AddWeighedStatFreqs(const SymbolStats *stats1, double w1, const SymbolStats *stats2, double w2, SymbolStats *result)\n{\n  size_t i;\n  for (i = 0; i < 288; i += 1)\n  {\n    result->litlens[i] = (size_t) ((stats1->litlens[i] * w1) + (stats2->litlens[i] * w2));\n  }\n\n  for (i = 0; i < 32; i += 1)\n  {\n    result->dists[i] = (size_t) ((stats1->dists[i] * w1) + (stats2->dists[i] * w2));\n  }\n\n  result->litlens[256] = 1;\n}\n\n",
        "translated_code": "pub fn AddWeighedStatFreqs(\n    stats1: &SymbolStats,\n    w1: f64,\n    stats2: &SymbolStats,\n    w2: f64,\n    result: &mut SymbolStats,\n) {\n    for i in 0..288 {\n        result.litlens[i] = ((stats1.litlens[i] as f64 * w1) + (stats2.litlens[i] as f64 * w2)) as usize;\n    }\n\n    for i in 0..32 {\n        result.dists[i] = ((stats1.dists[i] as f64 * w1) + (stats2.dists[i] as f64 * w2)) as usize;\n    }\n\n    result.litlens[256] = 1;\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [
            "SymbolStats"
        ],
        "params": [
            "const SymbolStats *stats1",
            "double w1",
            "const SymbolStats *stats2",
            "double w2",
            "SymbolStats *result"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "stats1",
            "w1",
            "stats2",
            "w2",
            "result",
            "i"
        ],
        "calle": [],
        "calle_c": [],
        "key": "AddWeighedStatFreqs",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "InitRanState": {
        "source_code": "static void InitRanState(RanState *state)\n{\n  state->m_w = 1;\n  state->m_z = 2;\n}\n\n",
        "translated_code": "pub fn InitRanState(state: &mut RanState) {\n    state.m_w = 1;\n    state.m_z = 2;\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [
            "RanState"
        ],
        "params": [
            "RanState *state"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "state"
        ],
        "calle": [],
        "calle_c": [],
        "key": "InitRanState",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "Ran": {
        "source_code": "static unsigned int Ran(RanState *state)\n{\n  state->m_z = (36969 * (state->m_z & 65535)) + (state->m_z >> 16);\n  state->m_w = (18000 * (state->m_w & 65535)) + (state->m_w >> 16);\n  return (state->m_z << 16) + state->m_w;\n}\n\n",
        "translated_code": "pub fn Ran(state: &mut RanState) -> u32 {\n    state.m_z = (36969 * (state.m_z & 65535)) + (state.m_z >> 16);\n    state.m_w = (18000 * (state.m_w & 65535)) + (state.m_w >> 16);\n    (state.m_z << 16) + state.m_w\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [
            "RanState"
        ],
        "params": [
            "RanState *state"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "state"
        ],
        "calle": [],
        "calle_c": [],
        "key": "Ran",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ClearStatFreqs": {
        "source_code": "static void ClearStatFreqs(SymbolStats *stats)\n{\n  size_t i;\n  for (i = 0; i < 288; i += 1)\n  {\n    stats->litlens[i] = 0;\n  }\n\n  for (i = 0; i < 32; i += 1)\n  {\n    stats->dists[i] = 0;\n  }\n\n}\n\n",
        "translated_code": "pub fn ClearStatFreqs(stats: &mut SymbolStats) {\n    for i in 0..288 {\n        stats.litlens[i] = 0;\n    }\n\n    for i in 0..32 {\n        stats.dists[i] = 0;\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [
            "SymbolStats"
        ],
        "params": [
            "SymbolStats *stats"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "stats",
            "i"
        ],
        "calle": [],
        "calle_c": [],
        "key": "ClearStatFreqs",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "GetCostModelMinCost": {
        "source_code": "static double GetCostModelMinCost(CostModelFun *costmodel, void *costcontext)\n{\n  double mincost;\n  int bestlength = 0;\n  int bestdist = 0;\n  int i;\n  static const int dsymbols[30] = {1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577};\n  mincost = 1e30;\n  for (i = 3; i < 259; i += 1)\n  {\n    double c = costmodel(i, 1, costcontext);\n    if (c < mincost)\n    {\n      bestlength = i;\n      mincost = c;\n    }\n  }\n\n  mincost = 1e30;\n  for (i = 0; i < 30; i += 1)\n  {\n    double c = costmodel(3, dsymbols[i], costcontext);\n    if (c < mincost)\n    {\n      bestdist = dsymbols[i];\n      mincost = c;\n    }\n  }\n\n  return costmodel(bestlength, bestdist, costcontext);\n}\n\n",
        "translated_code": "pub fn GetCostModelMinCost(\n    costmodel: CostModelFun,\n    costcontext: Option<Box<dyn std::any::Any>>,\n) -> f64 {\n    let dsymbols: [u32; 30] = [\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537,\n        2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577,\n    ];\n\n    let mut mincost = 1e30;\n    let mut bestlength = 0;\n\n    // Find best length\n    for i in 3..259 {\n        // Pass None for context in loop calls\n        let c = costmodel(i, 1, None);\n        if c < mincost {\n            bestlength = i;\n            mincost = c;\n        }\n    }\n\n    let mut mincost = 1e30;\n    let mut bestdist = 0;\n\n    // Find best distance\n    for &d in dsymbols.iter() {\n        // Pass None for context in loop calls\n        let c = costmodel(3, d, None);\n        if c < mincost {\n            bestdist = d;\n            mincost = c;\n        }\n    }\n\n    // Use original context only in final call\n    costmodel(bestlength, bestdist, costcontext)\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [
            "CostModelFun"
        ],
        "params": [
            "CostModelFun *costmodel",
            "void *costcontext"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "costmodel",
            "costcontext",
            "mincost",
            "bestlength",
            "bestdist",
            "i",
            "dsymbols",
            "c"
        ],
        "calle": [
            "costmodel"
        ],
        "calle_c": [
            "costmodel"
        ],
        "key": "GetCostModelMinCost",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliInitOptions": {
        "source_code": "void ZopfliInitOptions(ZopfliOptions *options)\n{\n  options->verbose = 0;\n  options->verbose_more = 0;\n  options->numiterations = 15;\n  options->blocksplitting = 1;\n  options->blocksplittinglast = 0;\n  options->blocksplittingmax = 15;\n}\n\n",
        "translated_code": "pub fn ZopfliInitOptions(options: &mut ZopfliOptions) {\n    options.verbose = 0;\n    options.verbose_more = 0;\n    options.numiterations = 15;\n    options.blocksplitting = 1;\n    options.blocksplittinglast = 0;\n    options.blocksplittingmax = 15;\n}",
        "hint": "functions",
        "section": "src",
        "file": "util.rs",
        "error": "",
        "dependent": [
            "ZopfliOptions"
        ],
        "header": "void ZopfliInitOptions(ZopfliOptions *options)",
        "params": [
            "ZopfliOptions *options"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options"
        ],
        "calle": [],
        "calle_c": [],
        "key": "ZopfliInitOptions",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliBlockState": {
        "source_code": "typedef struct ZopfliBlockState\n{\n  const ZopfliOptions *options;\n  ZopfliLongestMatchCache *lmc;\n  size_t blockstart;\n  size_t blockend;\n} ZopfliBlockState",
        "translated_code": "#[derive(Clone)]\npub struct ZopfliBlockState {\n    pub options: Option<Box<ZopfliOptions>>,\n    pub lmc: Option<Box<ZopfliLongestMatchCache>>,\n    pub blockstart: usize,\n    pub blockend: usize,\n}",
        "hint": "special_types",
        "section": "src",
        "file": "ZopfliBlockState.rs",
        "error": "",
        "dependent": [
            "ZopfliLongestMatchCache",
            "ZopfliOptions"
        ],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "FindMinimum": {
        "source_code": "static size_t FindMinimum(FindMinimumFun f, void *context, size_t start, size_t end, double *smallest)\n{\n  if ((end - start) < 1024)\n  {\n    double best = 1e30;\n    size_t result = start;\n    size_t i;\n    for (i = start; i < end; i += 1)\n    {\n      double v = f(i, context);\n      if (v < best)\n      {\n        best = v;\n        result = i;\n      }\n    }\n\n    *smallest = best;\n    return result;\n  }\n  else\n  {\n    size_t i;\n    size_t p[9];\n    double vp[9];\n    size_t besti;\n    double best;\n    double lastbest = 1e30;\n    size_t pos = start;\n    for (;;)\n    {\n      if ((end - start) <= 9)\n      {\n        break;\n      }\n      for (i = 0; i < 9; i += 1)\n      {\n        p[i] = start + ((i + 1) * ((end - start) / (9 + 1)));\n        vp[i] = f(p[i], context);\n      }\n\n      besti = 0;\n      best = vp[0];\n      for (i = 1; i < 9; i += 1)\n      {\n        if (vp[i] < best)\n        {\n          best = vp[i];\n          besti = i;\n        }\n      }\n\n      if (best > lastbest)\n      {\n        break;\n      }\n      start = (besti == 0) ? (start) : (p[besti - 1]);\n      end = (besti == (9 - 1)) ? (end) : (p[besti + 1]);\n      pos = p[besti];\n      lastbest = best;\n    }\n\n    *smallest = lastbest;\n    return pos;\n  }\n}\n\n",
        "translated_code": "pub fn FindMinimum(\n    f: FindMinimumFun,\n    context: Option<Box<dyn Any + 'static>>,\n    mut start: usize,\n    mut end: usize,\n    smallest: &mut f64,\n) -> usize {\n    // Convert the context into a static reference\n    let static_context: Option<&'static dyn Any> = context.as_ref().map(|c| unsafe {\n        let ptr = &**c as *const dyn Any;\n        &*ptr\n    });\n\n    if (end - start) < 1024 {\n        let mut best = 1e30;\n        let mut result = start;\n        \n        for i in start..end {\n            // Use the static context reference\n            let ctx = static_context.map(|c| Box::new(c) as Box<dyn Any>);\n            let v = f(i, ctx);\n            if v < best {\n                best = v;\n                result = i;\n            }\n        }\n\n        *smallest = best;\n        result\n    } else {\n        let mut p = [0; 9];\n        let mut vp = [0.0; 9];\n        let mut besti;\n        let mut best;\n        let mut lastbest = 1e30;\n        let mut pos = start;\n\n        loop {\n            if (end - start) <= 9 {\n                break;\n            }\n\n            for i in 0..9 {\n                p[i] = start + ((i + 1) * ((end - start) / (9 + 1)));\n                // Use the static context reference\n                let ctx = static_context.map(|c| Box::new(c) as Box<dyn Any>);\n                vp[i] = f(p[i], ctx);\n            }\n\n            besti = 0;\n            best = vp[0];\n            for i in 1..9 {\n                if vp[i] < best {\n                    best = vp[i];\n                    besti = i;\n                }\n            }\n\n            if best > lastbest {\n                break;\n            }\n\n            start = if besti == 0 { start } else { p[besti - 1] };\n            end = if besti == (9 - 1) { end } else { p[besti + 1] };\n            pos = p[besti];\n            lastbest = best;\n        }\n\n        *smallest = lastbest;\n        pos\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "blocksplitter.rs",
        "error": "",
        "dependent": [
            "FindMinimumFun",
            "f"
        ],
        "params": [
            "FindMinimumFun f",
            "void *context",
            "size_t start",
            "size_t end",
            "double *smallest"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "f",
            "context",
            "start",
            "end",
            "smallest",
            "best",
            "result",
            "i",
            "v",
            "p",
            "vp",
            "besti",
            "lastbest",
            "pos"
        ],
        "calle": [
            "f"
        ],
        "calle_c": [
            "f"
        ],
        "key": "FindMinimum",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_zopfli_init_options": {
        "source_code": "static int test_zopfli_init_options()\n{\n  ZopfliOptions options;\n  ZopfliInitOptions(&options);\n  do\n  {\n    if (!(options.verbose == 0))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Default verbose should be 0\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!(options.verbose_more == 0))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Default verbose_more should be 0\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!(options.numiterations > 0))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Default numiterations should be positive\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!(options.numiterations <= 50))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Default numiterations should be reasonable\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!(options.blocksplitting >= 0))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Default blocksplitting should be valid\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!(options.blocksplittingmax >= 0))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Default blocksplittingmax should be valid\");\n      return 0;\n    }\n  }\n  while (0);\n  printf(\"  Default iterations: %d, blocksplitting: %d, blocksplittingmax: %d\\n\", options.numiterations, options.blocksplitting, options.blocksplittingmax);\n  do\n  {\n    printf(\"PASS: %s\\n\", __func__);\n    return 1;\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn test_zopfli_init_options() -> i32 {\n    let mut options = ZopfliOptions {\n        verbose: 0,\n        verbose_more: 0,\n        numiterations: 0,\n        blocksplitting: 0,\n        blocksplittinglast: 0,\n        blocksplittingmax: 0,\n    };\n    ZopfliInitOptions(&mut options);\n\n    if options.verbose != 0 {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_init_options\", \"Default verbose should be 0\");\n        return 0;\n    }\n\n    if options.verbose_more != 0 {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_init_options\", \"Default verbose_more should be 0\");\n        return 0;\n    }\n\n    if options.numiterations <= 0 {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_init_options\", \"Default numiterations should be positive\");\n        return 0;\n    }\n\n    if options.numiterations > 50 {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_init_options\", \"Default numiterations should be reasonable\");\n        return 0;\n    }\n\n    if options.blocksplitting < 0 {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_init_options\", \"Default blocksplitting should be valid\");\n        return 0;\n    }\n\n    if options.blocksplittingmax < 0 {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_init_options\", \"Default blocksplittingmax should be valid\");\n        return 0;\n    }\n\n    println!(\"  Default iterations: {}, blocksplitting: {}, blocksplittingmax: {}\", \n             options.numiterations, options.blocksplitting, options.blocksplittingmax);\n    println!(\"PASS: {}\", \"test_zopfli_init_options\");\n    1\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_zopfli.rs",
        "error": "",
        "dependent": [
            "ZopfliInitOptions",
            "ZopfliOptions"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options"
        ],
        "calle": [
            "printf",
            "ZopfliInitOptions"
        ],
        "calle_c": [
            "printf"
        ],
        "key": "test_zopfli_init_options",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "CalculateBlockSymbolSizeSmall": {
        "source_code": "static size_t CalculateBlockSymbolSizeSmall(const unsigned *ll_lengths, const unsigned *d_lengths, const ZopfliLZ77Store *lz77, size_t lstart, size_t lend)\n{\n  size_t result = 0;\n  size_t i;\n  for (i = lstart; i < lend; i += 1)\n  {\n    assert(i < lz77->size);\n    assert(lz77->litlens[i] < 259);\n    if (lz77->dists[i] == 0)\n    {\n      result += ll_lengths[lz77->litlens[i]];\n    }\n    else\n    {\n      int ll_symbol = ZopfliGetLengthSymbol(lz77->litlens[i]);\n      int d_symbol = ZopfliGetDistSymbol(lz77->dists[i]);\n      result += ll_lengths[ll_symbol];\n      result += d_lengths[d_symbol];\n      result += ZopfliGetLengthSymbolExtraBits(ll_symbol);\n      result += ZopfliGetDistSymbolExtraBits(d_symbol);\n    }\n  }\n\n  result += ll_lengths[256];\n  return result;\n}\n\n",
        "translated_code": "pub fn CalculateBlockSymbolSizeSmall(\n    ll_lengths: &[u32],\n    d_lengths: &[u32],\n    lz77: &ZopfliLz77Store,\n    lstart: usize,\n    lend: usize,\n) -> usize {\n    let mut result = 0usize;\n\n    for i in lstart..lend {\n        assert!(i < lz77.size, \"Index out of bounds\");\n        assert!(\n            lz77.litlens.as_ref().map_or(false, |v| v[i] < 259),\n            \"Literal length out of bounds\"\n        );\n\n        if lz77.dists.as_ref().map_or(false, |v| v[i] == 0) {\n            result += ll_lengths[lz77.litlens.as_ref().unwrap()[i] as usize] as usize;\n        } else {\n            let ll_symbol = ZopfliGetLengthSymbol(lz77.litlens.as_ref().unwrap()[i] as usize);\n            let d_symbol = ZopfliGetDistSymbol(lz77.dists.as_ref().unwrap()[i] as i32);\n            result += ll_lengths[ll_symbol as usize] as usize;\n            result += d_lengths[d_symbol as usize] as usize;\n            result += ZopfliGetLengthSymbolExtraBits(ll_symbol) as usize;\n            result += ZopfliGetDistSymbolExtraBits(d_symbol) as usize;\n        }\n    }\n\n    result += ll_lengths[256] as usize;\n    result\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [
            "ZopfliGetDistSymbol",
            "ZopfliGetDistSymbolExtraBits",
            "ZopfliGetLengthSymbol",
            "ZopfliGetLengthSymbolExtraBits",
            "ZopfliLZ77Store"
        ],
        "params": [
            "const unsigned *ll_lengths",
            "const unsigned *d_lengths",
            "const ZopfliLZ77Store *lz77",
            "size_t lstart",
            "size_t lend"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ll_lengths",
            "d_lengths",
            "lz77",
            "lstart",
            "lend",
            "result",
            "i",
            "ll_symbol",
            "d_symbol"
        ],
        "calle": [
            "ZopfliGetDistSymbol",
            "ZopfliGetDistSymbolExtraBits",
            "ZopfliGetLengthSymbol",
            "ZopfliGetLengthSymbolExtraBits",
            "assert"
        ],
        "calle_c": [
            "assert"
        ],
        "key": "CalculateBlockSymbolSizeSmall",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "CalculateBlockSymbolSizeGivenCounts": {
        "source_code": "static size_t CalculateBlockSymbolSizeGivenCounts(const size_t *ll_counts, const size_t *d_counts, const unsigned *ll_lengths, const unsigned *d_lengths, const ZopfliLZ77Store *lz77, size_t lstart, size_t lend)\n{\n  size_t result = 0;\n  size_t i;\n  if ((lstart + (288 * 3)) > lend)\n  {\n    return CalculateBlockSymbolSizeSmall(ll_lengths, d_lengths, lz77, lstart, lend);\n  }\n  else\n  {\n    for (i = 0; i < 256; i += 1)\n    {\n      result += ll_lengths[i] * ll_counts[i];\n    }\n\n    for (i = 257; i < 286; i += 1)\n    {\n      result += ll_lengths[i] * ll_counts[i];\n      result += ZopfliGetLengthSymbolExtraBits(i) * ll_counts[i];\n    }\n\n    for (i = 0; i < 30; i += 1)\n    {\n      result += d_lengths[i] * d_counts[i];\n      result += ZopfliGetDistSymbolExtraBits(i) * d_counts[i];\n    }\n\n    result += ll_lengths[256];\n    return result;\n  }\n}\n\n",
        "translated_code": "pub fn CalculateBlockSymbolSizeGivenCounts(\n    ll_counts: &[usize],\n    d_counts: &[usize],\n    ll_lengths: &[u32],\n    d_lengths: &[u32],\n    lz77: &ZopfliLz77Store,\n    lstart: usize,\n    lend: usize,\n) -> usize {\n    let mut result = 0;\n\n    if (lstart + (288 * 3)) > lend {\n        return CalculateBlockSymbolSizeSmall(ll_lengths, d_lengths, lz77, lstart, lend);\n    } else {\n        for i in 0..256 {\n            result += ll_lengths[i] as usize * ll_counts[i];\n        }\n\n        for i in 257..286 {\n            result += ll_lengths[i] as usize * ll_counts[i];\n            result += ZopfliGetLengthSymbolExtraBits(i as i32) as usize * ll_counts[i];\n        }\n\n        for i in 0..30 {\n            result += d_lengths[i] as usize * d_counts[i];\n            result += ZopfliGetDistSymbolExtraBits(i as i32) as usize * d_counts[i];\n        }\n\n        result += ll_lengths[256] as usize;\n        result\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [
            "CalculateBlockSymbolSizeSmall",
            "ZopfliGetDistSymbolExtraBits",
            "ZopfliGetLengthSymbolExtraBits",
            "ZopfliLZ77Store"
        ],
        "params": [
            "const size_t *ll_counts",
            "const size_t *d_counts",
            "const unsigned *ll_lengths",
            "const unsigned *d_lengths",
            "const ZopfliLZ77Store *lz77",
            "size_t lstart",
            "size_t lend"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ll_counts",
            "d_counts",
            "ll_lengths",
            "d_lengths",
            "lz77",
            "lstart",
            "lend",
            "result",
            "i"
        ],
        "calle": [
            "ZopfliGetLengthSymbolExtraBits",
            "ZopfliGetDistSymbolExtraBits",
            "CalculateBlockSymbolSizeSmall"
        ],
        "calle_c": [],
        "key": "CalculateBlockSymbolSizeGivenCounts",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "TryOptimizeHuffmanForRle": {
        "source_code": "static double TryOptimizeHuffmanForRle(const ZopfliLZ77Store *lz77, size_t lstart, size_t lend, const size_t *ll_counts, const size_t *d_counts, unsigned *ll_lengths, unsigned *d_lengths)\n{\n  size_t ll_counts2[288];\n  size_t d_counts2[32];\n  unsigned ll_lengths2[288];\n  unsigned d_lengths2[32];\n  double treesize;\n  double datasize;\n  double treesize2;\n  double datasize2;\n  treesize = CalculateTreeSize(ll_lengths, d_lengths);\n  datasize = CalculateBlockSymbolSizeGivenCounts(ll_counts, d_counts, ll_lengths, d_lengths, lz77, lstart, lend);\n  memcpy(ll_counts2, ll_counts, sizeof(ll_counts2));\n  memcpy(d_counts2, d_counts, sizeof(d_counts2));\n  OptimizeHuffmanForRle(288, ll_counts2);\n  OptimizeHuffmanForRle(32, d_counts2);\n  ZopfliCalculateBitLengths(ll_counts2, 288, 15, ll_lengths2);\n  ZopfliCalculateBitLengths(d_counts2, 32, 15, d_lengths2);\n  PatchDistanceCodesForBuggyDecoders(d_lengths2);\n  treesize2 = CalculateTreeSize(ll_lengths2, d_lengths2);\n  datasize2 = CalculateBlockSymbolSizeGivenCounts(ll_counts, d_counts, ll_lengths2, d_lengths2, lz77, lstart, lend);\n  if ((treesize2 + datasize2) < (treesize + datasize))\n  {\n    memcpy(ll_lengths, ll_lengths2, sizeof(ll_lengths2));\n    memcpy(d_lengths, d_lengths2, sizeof(d_lengths2));\n    return treesize2 + datasize2;\n  }\n  return treesize + datasize;\n}\n\n",
        "translated_code": "pub fn TryOptimizeHuffmanForRle(\n    lz77: &ZopfliLz77Store,\n    lstart: usize,\n    lend: usize,\n    ll_counts: &[usize],\n    d_counts: &[usize],\n    ll_lengths: &mut [u32],\n    d_lengths: &mut [u32],\n) -> f64 {\n    let mut ll_counts2: [usize; 288] = [0; 288];\n    let mut d_counts2: [usize; 32] = [0; 32];\n    let mut ll_lengths2: [u32; 288] = [0; 288];\n    let mut d_lengths2: [u32; 32] = [0; 32];\n    \n    let treesize = CalculateTreeSize(ll_lengths, d_lengths);\n    let datasize = CalculateBlockSymbolSizeGivenCounts(\n        ll_counts, d_counts, ll_lengths, d_lengths, lz77, lstart, lend\n    );\n    \n    ll_counts2.copy_from_slice(&ll_counts[..288]);\n    d_counts2.copy_from_slice(&d_counts[..32]);\n    \n    OptimizeHuffmanForRle(288, &mut ll_counts2);\n    OptimizeHuffmanForRle(32, &mut d_counts2);\n    \n    ZopfliCalculateBitLengths(&ll_counts2, 288, 15, &mut ll_lengths2);\n    ZopfliCalculateBitLengths(&d_counts2, 32, 15, &mut d_lengths2);\n    \n    // Create a temporary array of size 30 for PatchDistanceCodesForBuggyDecoders\n    let mut d_lengths2_temp: [u32; 30] = [0; 30];\n    d_lengths2_temp.copy_from_slice(&d_lengths2[..30]);\n    PatchDistanceCodesForBuggyDecoders(&mut d_lengths2_temp);\n    // Copy the modified values back to the original array\n    d_lengths2[..30].copy_from_slice(&d_lengths2_temp);\n    \n    let treesize2 = CalculateTreeSize(&ll_lengths2, &d_lengths2);\n    let datasize2 = CalculateBlockSymbolSizeGivenCounts(\n        ll_counts, d_counts, &ll_lengths2, &d_lengths2, lz77, lstart, lend\n    );\n    \n    if (treesize2 + datasize2) < (treesize + datasize) {\n        ll_lengths[..288].copy_from_slice(&ll_lengths2);\n        d_lengths[..32].copy_from_slice(&d_lengths2);\n        return (treesize2 + datasize2) as f64;\n    }\n    \n    (treesize + datasize) as f64\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [
            "CalculateBlockSymbolSizeGivenCounts",
            "CalculateTreeSize",
            "OptimizeHuffmanForRle",
            "PatchDistanceCodesForBuggyDecoders",
            "ZopfliCalculateBitLengths",
            "ZopfliLZ77Store"
        ],
        "params": [
            "const ZopfliLZ77Store *lz77",
            "size_t lstart",
            "size_t lend",
            "const size_t *ll_counts",
            "const size_t *d_counts",
            "unsigned *ll_lengths",
            "unsigned *d_lengths"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "lz77",
            "lstart",
            "lend",
            "ll_counts",
            "d_counts",
            "ll_lengths",
            "d_lengths",
            "ll_counts2",
            "d_counts2",
            "ll_lengths2",
            "d_lengths2",
            "treesize",
            "datasize",
            "treesize2",
            "datasize2"
        ],
        "calle": [
            "CalculateTreeSize",
            "memcpy",
            "OptimizeHuffmanForRle",
            "PatchDistanceCodesForBuggyDecoders",
            "CalculateBlockSymbolSizeGivenCounts",
            "ZopfliCalculateBitLengths"
        ],
        "calle_c": [
            "memcpy"
        ],
        "key": "TryOptimizeHuffmanForRle",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "ZopfliLZ77GetHistogram": {
        "source_code": "void ZopfliLZ77GetHistogram(const ZopfliLZ77Store *lz77, size_t lstart, size_t lend, size_t *ll_counts, size_t *d_counts)\n{\n  size_t i;\n  if ((lstart + (288 * 3)) > lend)\n  {\n    memset(ll_counts, 0, (sizeof(*ll_counts)) * 288);\n    memset(d_counts, 0, (sizeof(*d_counts)) * 32);\n    for (i = lstart; i < lend; i += 1)\n    {\n      ll_counts[lz77->ll_symbol[i]] += 1;\n      if (lz77->dists[i] != 0)\n      {\n        d_counts[lz77->d_symbol[i]] += 1;\n      }\n    }\n\n  }\n  else\n  {\n    ZopfliLZ77GetHistogramAt(lz77, lend - 1, ll_counts, d_counts);\n    if (lstart > 0)\n    {\n      size_t ll_counts2[288];\n      size_t d_counts2[32];\n      ZopfliLZ77GetHistogramAt(lz77, lstart - 1, ll_counts2, d_counts2);\n      for (i = 0; i < 288; i += 1)\n      {\n        ll_counts[i] -= ll_counts2[i];\n      }\n\n      for (i = 0; i < 32; i += 1)\n      {\n        d_counts[i] -= d_counts2[i];\n      }\n\n    }\n  }\n}\n\n",
        "translated_code": "use std::ptr;\n\npub fn ZopfliLZ77GetHistogram(\n    lz77: &ZopfliLz77Store,\n    lstart: usize,\n    lend: usize,\n    ll_counts: &mut [usize],\n    d_counts: &mut [usize],\n) {\n    if (lstart + (288 * 3)) > lend {\n        // Equivalent to memset(ll_counts, 0, sizeof(*ll_counts) * 288)\n        for count in ll_counts.iter_mut().take(288) {\n            *count = 0;\n        }\n        \n        // Equivalent to memset(d_counts, 0, sizeof(*d_counts) * 32)\n        for count in d_counts.iter_mut().take(32) {\n            *count = 0;\n        }\n\n        // Safe to unwrap since we're in the condition where we're processing the range\n        let ll_symbol = lz77.ll_symbol.as_ref().unwrap();\n        let dists = lz77.dists.as_ref().unwrap();\n        let d_symbol = lz77.d_symbol.as_ref().unwrap();\n\n        for i in lstart..lend {\n            ll_counts[ll_symbol[i] as usize] += 1;\n            if dists[i] != 0 {\n                d_counts[d_symbol[i] as usize] += 1;\n            }\n        }\n    } else {\n        ZopfliLZ77GetHistogramAt(lz77, lend - 1, ll_counts, d_counts);\n        if lstart > 0 {\n            let mut ll_counts2 = [0; 288];\n            let mut d_counts2 = [0; 32];\n            \n            ZopfliLZ77GetHistogramAt(lz77, lstart - 1, &mut ll_counts2, &mut d_counts2);\n            \n            for i in 0..288 {\n                ll_counts[i] -= ll_counts2[i];\n            }\n            \n            for i in 0..32 {\n                d_counts[i] -= d_counts2[i];\n            }\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "lz77.rs",
        "error": "",
        "dependent": [
            "ZopfliLZ77GetHistogramAt",
            "ZopfliLZ77Store"
        ],
        "header": "void ZopfliLZ77GetHistogram(const ZopfliLZ77Store *lz77, size_t lstart, size_t lend, size_t *ll_counts, size_t *d_counts)",
        "params": [
            "const ZopfliLZ77Store *lz77",
            "size_t lstart",
            "size_t lend",
            "size_t *ll_counts",
            "size_t *d_counts"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "lz77",
            "lstart",
            "lend",
            "ll_counts",
            "d_counts",
            "i",
            "ll_counts2",
            "d_counts2"
        ],
        "calle": [
            "memset",
            "ZopfliLZ77GetHistogramAt"
        ],
        "calle_c": [
            "memset"
        ],
        "key": "ZopfliLZ77GetHistogram",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "GetDynamicLengths": {
        "source_code": "static double GetDynamicLengths(const ZopfliLZ77Store *lz77, size_t lstart, size_t lend, unsigned *ll_lengths, unsigned *d_lengths)\n{\n  size_t ll_counts[288];\n  size_t d_counts[32];\n  ZopfliLZ77GetHistogram(lz77, lstart, lend, ll_counts, d_counts);\n  ll_counts[256] = 1;\n  ZopfliCalculateBitLengths(ll_counts, 288, 15, ll_lengths);\n  ZopfliCalculateBitLengths(d_counts, 32, 15, d_lengths);\n  PatchDistanceCodesForBuggyDecoders(d_lengths);\n  return TryOptimizeHuffmanForRle(lz77, lstart, lend, ll_counts, d_counts, ll_lengths, d_lengths);\n}\n\n",
        "translated_code": "pub fn GetDynamicLengths(\n    lz77: &ZopfliLz77Store,\n    lstart: usize,\n    lend: usize,\n    ll_lengths: &mut [u32; 288],\n    d_lengths: &mut [u32; 32],\n) -> f64 {\n    let mut ll_counts = [0usize; 288];\n    let mut d_counts = [0usize; 32];\n    \n    ZopfliLZ77GetHistogram(lz77, lstart, lend, &mut ll_counts, &mut d_counts);\n    \n    ll_counts[256] = 1;\n    \n    ZopfliCalculateBitLengths(&ll_counts, 288, 15, ll_lengths);\n    ZopfliCalculateBitLengths(&d_counts, 32, 15, d_lengths);\n    \n    // Create a temporary array for the distance codes fix\n    let mut fixed_d_lengths = [0u32; 30];\n    fixed_d_lengths.copy_from_slice(&d_lengths[..30]);\n    PatchDistanceCodesForBuggyDecoders(&mut fixed_d_lengths);\n    d_lengths[..30].copy_from_slice(&fixed_d_lengths);\n    \n    TryOptimizeHuffmanForRle(\n        lz77,\n        lstart,\n        lend,\n        &ll_counts,\n        &d_counts,\n        ll_lengths,\n        d_lengths,\n    )\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [
            "PatchDistanceCodesForBuggyDecoders",
            "TryOptimizeHuffmanForRle",
            "ZopfliCalculateBitLengths",
            "ZopfliLZ77GetHistogram",
            "ZopfliLZ77Store"
        ],
        "params": [
            "const ZopfliLZ77Store *lz77",
            "size_t lstart",
            "size_t lend",
            "unsigned *ll_lengths",
            "unsigned *d_lengths"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "lz77",
            "lstart",
            "lend",
            "ll_lengths",
            "d_lengths",
            "ll_counts",
            "d_counts"
        ],
        "calle": [
            "PatchDistanceCodesForBuggyDecoders",
            "TryOptimizeHuffmanForRle",
            "ZopfliCalculateBitLengths",
            "ZopfliLZ77GetHistogram"
        ],
        "calle_c": [],
        "key": "GetDynamicLengths",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "CalculateBlockSymbolSize": {
        "source_code": "static size_t CalculateBlockSymbolSize(const unsigned *ll_lengths, const unsigned *d_lengths, const ZopfliLZ77Store *lz77, size_t lstart, size_t lend)\n{\n  if ((lstart + (288 * 3)) > lend)\n  {\n    return CalculateBlockSymbolSizeSmall(ll_lengths, d_lengths, lz77, lstart, lend);\n  }\n  else\n  {\n    size_t ll_counts[288];\n    size_t d_counts[32];\n    ZopfliLZ77GetHistogram(lz77, lstart, lend, ll_counts, d_counts);\n    return CalculateBlockSymbolSizeGivenCounts(ll_counts, d_counts, ll_lengths, d_lengths, lz77, lstart, lend);\n  }\n}\n\n",
        "translated_code": "pub fn CalculateBlockSymbolSize(\n    ll_lengths: &[u32],\n    d_lengths: &[u32],\n    lz77: &ZopfliLz77Store,\n    lstart: usize,\n    lend: usize,\n) -> usize {\n    if (lstart + (288 * 3)) > lend {\n        CalculateBlockSymbolSizeSmall(ll_lengths, d_lengths, lz77, lstart, lend)\n    } else {\n        let mut ll_counts = [0; 288];\n        let mut d_counts = [0; 32];\n        ZopfliLZ77GetHistogram(lz77, lstart, lend, &mut ll_counts, &mut d_counts);\n        CalculateBlockSymbolSizeGivenCounts(\n            &ll_counts,\n            &d_counts,\n            ll_lengths,\n            d_lengths,\n            lz77,\n            lstart,\n            lend,\n        )\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [
            "CalculateBlockSymbolSizeGivenCounts",
            "CalculateBlockSymbolSizeSmall",
            "ZopfliLZ77GetHistogram",
            "ZopfliLZ77Store"
        ],
        "params": [
            "const unsigned *ll_lengths",
            "const unsigned *d_lengths",
            "const ZopfliLZ77Store *lz77",
            "size_t lstart",
            "size_t lend"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ll_lengths",
            "d_lengths",
            "lz77",
            "lstart",
            "lend",
            "ll_counts",
            "d_counts"
        ],
        "calle": [
            "CalculateBlockSymbolSizeGivenCounts",
            "CalculateBlockSymbolSizeSmall",
            "ZopfliLZ77GetHistogram"
        ],
        "calle_c": [],
        "key": "CalculateBlockSymbolSize",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliCalculateBlockSize": {
        "source_code": "double ZopfliCalculateBlockSize(const ZopfliLZ77Store *lz77, size_t lstart, size_t lend, int btype)\n{\n  unsigned ll_lengths[288];\n  unsigned d_lengths[32];\n  double result = 3;\n  if (btype == 0)\n  {\n    size_t length = ZopfliLZ77GetByteRange(lz77, lstart, lend);\n    size_t rem = length % 65535;\n    size_t blocks = (length / 65535) + ((rem) ? (1) : (0));\n    return ((blocks * 5) * 8) + (length * 8);\n  }\n  if (btype == 1)\n  {\n    GetFixedTree(ll_lengths, d_lengths);\n    result += CalculateBlockSymbolSize(ll_lengths, d_lengths, lz77, lstart, lend);\n  }\n  else\n  {\n    result += GetDynamicLengths(lz77, lstart, lend, ll_lengths, d_lengths);\n  }\n  return result;\n}\n\n",
        "translated_code": "use std::vec::Vec;\n\npub fn ZopfliCalculateBlockSize(\n    lz77: &ZopfliLz77Store,\n    lstart: usize,\n    lend: usize,\n    btype: i32,\n) -> f64 {\n    let mut ll_lengths = [0u32; 288];\n    let mut d_lengths = [0u32; 32];\n    let mut result = 3.0;\n\n    match btype {\n        0 => {\n            let length = ZopfliLZ77GetByteRange(lz77, lstart, lend);\n            let rem = length % 65535;\n            let blocks = (length / 65535) + if rem != 0 { 1 } else { 0 };\n            return ((blocks * 5) * 8 + (length * 8)) as f64;\n        }\n        1 => {\n            GetFixedTree(&mut ll_lengths, &mut d_lengths);\n            result += CalculateBlockSymbolSize(\n                &ll_lengths,\n                &d_lengths,\n                lz77,\n                lstart,\n                lend,\n            ) as f64;\n        }\n        _ => {\n            result += GetDynamicLengths(\n                lz77,\n                lstart,\n                lend,\n                &mut ll_lengths,\n                &mut d_lengths,\n            );\n        }\n    }\n\n    result\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [
            "CalculateBlockSymbolSize",
            "GetDynamicLengths",
            "GetFixedTree",
            "ZopfliLZ77GetByteRange",
            "ZopfliLZ77Store"
        ],
        "header": "double ZopfliCalculateBlockSize(const ZopfliLZ77Store *lz77, size_t lstart, size_t lend, int btype)",
        "params": [
            "const ZopfliLZ77Store *lz77",
            "size_t lstart",
            "size_t lend",
            "int btype"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "lz77",
            "lstart",
            "lend",
            "btype",
            "ll_lengths",
            "d_lengths",
            "result",
            "length",
            "rem",
            "blocks"
        ],
        "calle": [
            "GetDynamicLengths",
            "ZopfliLZ77GetByteRange",
            "CalculateBlockSymbolSize",
            "GetFixedTree"
        ],
        "calle_c": [],
        "key": "ZopfliCalculateBlockSize",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliCalculateBlockSizeAutoType": {
        "source_code": "double ZopfliCalculateBlockSizeAutoType(const ZopfliLZ77Store *lz77, size_t lstart, size_t lend)\n{\n  double uncompressedcost = ZopfliCalculateBlockSize(lz77, lstart, lend, 0);\n  double fixedcost = (lz77->size > 1000) ? (uncompressedcost) : (ZopfliCalculateBlockSize(lz77, lstart, lend, 1));\n  double dyncost = ZopfliCalculateBlockSize(lz77, lstart, lend, 2);\n  return ((uncompressedcost < fixedcost) && (uncompressedcost < dyncost)) ? (uncompressedcost) : ((fixedcost < dyncost) ? (fixedcost) : (dyncost));\n}\n\n",
        "translated_code": "pub fn ZopfliCalculateBlockSizeAutoType(lz77: &ZopfliLz77Store, lstart: usize, lend: usize) -> f64 {\n    let uncompressedcost = ZopfliCalculateBlockSize(lz77, lstart, lend, 0);\n    let fixedcost = if lz77.size > 1000 {\n        uncompressedcost\n    } else {\n        ZopfliCalculateBlockSize(lz77, lstart, lend, 1)\n    };\n    let dyncost = ZopfliCalculateBlockSize(lz77, lstart, lend, 2);\n\n    if uncompressedcost < fixedcost && uncompressedcost < dyncost {\n        uncompressedcost\n    } else if fixedcost < dyncost {\n        fixedcost\n    } else {\n        dyncost\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [
            "ZopfliCalculateBlockSize",
            "ZopfliLZ77Store"
        ],
        "header": "double ZopfliCalculateBlockSizeAutoType(const ZopfliLZ77Store *lz77, size_t lstart, size_t lend)",
        "params": [
            "const ZopfliLZ77Store *lz77",
            "size_t lstart",
            "size_t lend"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "lz77",
            "lstart",
            "lend",
            "uncompressedcost",
            "fixedcost",
            "dyncost"
        ],
        "calle": [
            "ZopfliCalculateBlockSize"
        ],
        "calle_c": [],
        "key": "ZopfliCalculateBlockSizeAutoType",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "EstimateCost": {
        "source_code": "static double EstimateCost(const ZopfliLZ77Store *lz77, size_t lstart, size_t lend)\n{\n  return ZopfliCalculateBlockSizeAutoType(lz77, lstart, lend);\n}\n\n",
        "translated_code": "pub fn EstimateCost(lz77: &ZopfliLz77Store, lstart: usize, lend: usize) -> f64 {\n    ZopfliCalculateBlockSizeAutoType(lz77, lstart, lend)\n}",
        "hint": "functions",
        "section": "src",
        "file": "blocksplitter.rs",
        "error": "",
        "dependent": [
            "ZopfliCalculateBlockSizeAutoType",
            "ZopfliLZ77Store"
        ],
        "params": [
            "const ZopfliLZ77Store *lz77",
            "size_t lstart",
            "size_t lend"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "lz77",
            "lstart",
            "lend"
        ],
        "calle": [
            "ZopfliCalculateBlockSizeAutoType"
        ],
        "calle_c": [],
        "key": "EstimateCost",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "SplitCost": {
        "source_code": "static double SplitCost(size_t i, void *context)\n{\n  SplitCostContext *c = (SplitCostContext *) context;\n  return EstimateCost(c->lz77, c->start, i) + EstimateCost(c->lz77, i, c->end);\n}\n\n",
        "translated_code": "use std::vec::Vec;\n\npub fn SplitCost(i: usize, context: &SplitCostContext) -> f64 {\n    let c = context;\n    EstimateCost(c.lz77.as_ref().unwrap(), c.start, i) + EstimateCost(c.lz77.as_ref().unwrap(), i, c.end)\n}",
        "hint": "functions",
        "section": "src",
        "file": "blocksplitter.rs",
        "error": "",
        "dependent": [
            "EstimateCost",
            "SplitCostContext"
        ],
        "params": [
            "size_t i",
            "void *context"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "i",
            "context",
            "c"
        ],
        "calle": [
            "EstimateCost"
        ],
        "calle_c": [],
        "key": "SplitCost",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliSublenToCache": {
        "source_code": "void ZopfliSublenToCache(const unsigned short *sublen, size_t pos, size_t length, ZopfliLongestMatchCache *lmc)\n{\n  size_t i;\n  size_t j = 0;\n  unsigned bestlength = 0;\n  unsigned char *cache;\n  cache = &lmc->sublen[(8 * pos) * 3];\n  if (length < 3)\n  {\n    return;\n  }\n  for (i = 3; i <= length; i += 1)\n  {\n    if ((i == length) || (sublen[i] != sublen[i + 1]))\n    {\n      cache[j * 3] = i - 3;\n      cache[(j * 3) + 1] = sublen[i] % 256;\n      cache[(j * 3) + 2] = (sublen[i] >> 8) % 256;\n      bestlength = i;\n      j += 1;\n      if (j >= 8)\n      {\n        break;\n      }\n    }\n  }\n\n  if (j < 8)\n  {\n    assert(bestlength == length);\n    cache[(8 - 1) * 3] = bestlength - 3;\n  }\n  else\n  {\n    assert(bestlength <= length);\n  }\n  assert(bestlength == ZopfliMaxCachedSublen(lmc, pos, length));\n}\n\n",
        "translated_code": "pub fn ZopfliSublenToCache(sublen: &[u16], pos: usize, length: usize, lmc: &mut ZopfliLongestMatchCache) {\n    let mut j = 0;\n    let mut bestlength = 0;\n    \n    if length < 3 {\n        return;\n    }\n    \n    let cache_start = (8 * pos) * 3;\n    let cache_slice = lmc.sublen.as_mut().unwrap();\n    let cache = &mut cache_slice[cache_start..cache_start + 24]; // 8 * 3 = 24 bytes\n    \n    for i in (3..=length).step_by(1) {\n        if i == length || sublen[i] != sublen[i + 1] {\n            cache[j * 3] = (i - 3) as u8;\n            cache[(j * 3) + 1] = (sublen[i] % 256) as u8;\n            cache[(j * 3) + 2] = ((sublen[i] >> 8) % 256) as u8;\n            bestlength = i;\n            j += 1;\n            \n            if j >= 8 {\n                break;\n            }\n        }\n    }\n    \n    if j < 8 {\n        assert!(bestlength == length, \"bestlength should equal length\");\n        cache[(8 - 1) * 3] = (bestlength - 3) as u8;\n    } else {\n        assert!(bestlength <= length, \"bestlength should be <= length\");\n    }\n    \n    assert!(bestlength as u16 == ZopfliMaxCachedSublen(lmc, pos, length), \n            \"bestlength should match cached sublen\");\n}",
        "hint": "functions",
        "section": "src",
        "file": "cache.rs",
        "error": "",
        "dependent": [
            "ZopfliLongestMatchCache",
            "ZopfliMaxCachedSublen"
        ],
        "header": "void ZopfliSublenToCache(const unsigned short *sublen, size_t pos, size_t length, ZopfliLongestMatchCache *lmc)",
        "params": [
            "const unsigned short *sublen",
            "size_t pos",
            "size_t length",
            "ZopfliLongestMatchCache *lmc"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "sublen",
            "pos",
            "length",
            "lmc",
            "i",
            "j",
            "bestlength",
            "cache",
            "cache_idx"
        ],
        "calle": [
            "ZopfliMaxCachedSublen",
            "assert"
        ],
        "calle_c": [
            "assert"
        ],
        "key": "ZopfliSublenToCache",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "ZopfliCacheToSublen": {
        "source_code": "void ZopfliCacheToSublen(const ZopfliLongestMatchCache *lmc, size_t pos, size_t length, unsigned short *sublen)\n{\n  size_t i;\n  size_t j;\n  unsigned maxlength = ZopfliMaxCachedSublen(lmc, pos, length);\n  unsigned prevlength = 0;\n  unsigned char *cache;\n  if (length < 3)\n  {\n    return;\n  }\n  cache = &lmc->sublen[(8 * pos) * 3];\n  for (j = 0; j < 8; j += 1)\n  {\n    unsigned length = cache[j * 3] + 3;\n    unsigned dist = cache[(j * 3) + 1] + (256 * cache[(j * 3) + 2]);\n    for (i = prevlength; i <= length; i += 1)\n    {\n      sublen[i] = dist;\n    }\n\n    if (length == maxlength)\n    {\n      break;\n    }\n    prevlength = length + 1;\n  }\n\n}\n\n",
        "translated_code": "pub fn ZopfliCacheToSublen(lmc: &ZopfliLongestMatchCache, pos: usize, length: usize, sublen: &mut [u16]) {\n    if length < 3 {\n        return;\n    }\n    \n    let maxlength = ZopfliMaxCachedSublen(lmc, pos, length);\n    let mut prevlength: u16 = 0;\n    \n    // Get a reference to the cache data\n    let cache_start = (8 * pos) * 3;\n    let Some(cache_data) = lmc.sublen.as_ref() else {\n        return;\n    };\n    \n    // Ensure we don't go out of bounds\n    if cache_start + 24 > cache_data.len() {\n        return;\n    }\n    \n    let cache = &cache_data[cache_start..cache_start + 24];\n    \n    for j in 0..8 {\n        let length_val = cache[j * 3] as u16 + 3;\n        let dist = cache[(j * 3) + 1] as u16 + (256 * cache[(j * 3) + 2] as u16);\n        \n        for i in prevlength..=length_val {\n            if i < sublen.len() as u16 {\n                sublen[i as usize] = dist;\n            }\n        }\n        \n        if length_val == maxlength {\n            break;\n        }\n        prevlength = length_val + 1;\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "cache.rs",
        "error": "",
        "dependent": [
            "ZopfliLongestMatchCache",
            "ZopfliMaxCachedSublen"
        ],
        "header": "void ZopfliCacheToSublen(const ZopfliLongestMatchCache *lmc, size_t pos, size_t length, unsigned short *sublen)",
        "params": [
            "const ZopfliLongestMatchCache *lmc",
            "size_t pos",
            "size_t length",
            "unsigned short *sublen"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "lmc",
            "pos",
            "length",
            "sublen",
            "i",
            "j",
            "maxlength",
            "prevlength",
            "cache",
            "cache_idx",
            "dist"
        ],
        "calle": [
            "ZopfliMaxCachedSublen"
        ],
        "calle_c": [],
        "key": "ZopfliCacheToSublen",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "ZopfliCopyLZ77Store": {
        "source_code": "void ZopfliCopyLZ77Store(const ZopfliLZ77Store *source, ZopfliLZ77Store *dest)\n{\n  size_t i;\n  size_t llsize = 288 * CeilDiv(source->size, 288);\n  size_t dsize = 32 * CeilDiv(source->size, 32);\n  ZopfliCleanLZ77Store(dest);\n  ZopfliInitLZ77Store(source->data, dest);\n  dest->litlens = (unsigned short *) malloc((sizeof(*dest->litlens)) * source->size);\n  dest->dists = (unsigned short *) malloc((sizeof(*dest->dists)) * source->size);\n  dest->pos = (size_t *) malloc((sizeof(*dest->pos)) * source->size);\n  dest->ll_symbol = (unsigned short *) malloc((sizeof(*dest->ll_symbol)) * source->size);\n  dest->d_symbol = (unsigned short *) malloc((sizeof(*dest->d_symbol)) * source->size);\n  dest->ll_counts = (size_t *) malloc((sizeof(*dest->ll_counts)) * llsize);\n  dest->d_counts = (size_t *) malloc((sizeof(*dest->d_counts)) * dsize);\n  if ((!dest->litlens) || (!dest->dists))\n  {\n    exit(-1);\n  }\n  if (!dest->pos)\n  {\n    exit(-1);\n  }\n  if ((!dest->ll_symbol) || (!dest->d_symbol))\n  {\n    exit(-1);\n  }\n  if ((!dest->ll_counts) || (!dest->d_counts))\n  {\n    exit(-1);\n  }\n  dest->size = source->size;\n  for (i = 0; i < source->size; i += 1)\n  {\n    dest->litlens[i] = source->litlens[i];\n    dest->dists[i] = source->dists[i];\n    dest->pos[i] = source->pos[i];\n    dest->ll_symbol[i] = source->ll_symbol[i];\n    dest->d_symbol[i] = source->d_symbol[i];\n  }\n\n  for (i = 0; i < llsize; i += 1)\n  {\n    dest->ll_counts[i] = source->ll_counts[i];\n  }\n\n  for (i = 0; i < dsize; i += 1)\n  {\n    dest->d_counts[i] = source->d_counts[i];\n  }\n\n}\n\n",
        "translated_code": "use std::process;\n\npub fn ZopfliCopyLZ77Store(source: &ZopfliLz77Store, dest: &mut ZopfliLz77Store) {\n    let llsize = 288 * CeilDiv(source.size, 288);\n    let dsize = 32 * CeilDiv(source.size, 32);\n    \n    ZopfliCleanLZ77Store(dest);\n    ZopfliInitLZ77Store(source.data.as_deref(), dest);\n    \n    // Allocate vectors with proper capacity\n    dest.litlens = Some(vec![0; source.size]);\n    dest.dists = Some(vec![0; source.size]);\n    dest.pos = Some(vec![0; source.size]);\n    dest.ll_symbol = Some(vec![0; source.size]);\n    dest.d_symbol = Some(vec![0; source.size]);\n    dest.ll_counts = Some(vec![0; llsize]);\n    dest.d_counts = Some(vec![0; dsize]);\n    \n    // Check allocations (Rust's Vec will panic on allocation failure, but we'll handle it explicitly)\n    if dest.litlens.is_none() || dest.dists.is_none() {\n        process::exit(-1);\n    }\n    if dest.pos.is_none() {\n        process::exit(-1);\n    }\n    if dest.ll_symbol.is_none() || dest.d_symbol.is_none() {\n        process::exit(-1);\n    }\n    if dest.ll_counts.is_none() || dest.d_counts.is_none() {\n        process::exit(-1);\n    }\n    \n    dest.size = source.size;\n    \n    // Copy data from source to dest\n    if let (Some(src_litlens), Some(dest_litlens)) = (&source.litlens, &mut dest.litlens) {\n        dest_litlens.copy_from_slice(src_litlens);\n    }\n    \n    if let (Some(src_dists), Some(dest_dists)) = (&source.dists, &mut dest.dists) {\n        dest_dists.copy_from_slice(src_dists);\n    }\n    \n    if let (Some(src_pos), Some(dest_pos)) = (&source.pos, &mut dest.pos) {\n        dest_pos.copy_from_slice(src_pos);\n    }\n    \n    if let (Some(src_ll_symbol), Some(dest_ll_symbol)) = (&source.ll_symbol, &mut dest.ll_symbol) {\n        dest_ll_symbol.copy_from_slice(src_ll_symbol);\n    }\n    \n    if let (Some(src_d_symbol), Some(dest_d_symbol)) = (&source.d_symbol, &mut dest.d_symbol) {\n        dest_d_symbol.copy_from_slice(src_d_symbol);\n    }\n    \n    if let (Some(src_ll_counts), Some(dest_ll_counts)) = (&source.ll_counts, &mut dest.ll_counts) {\n        dest_ll_counts[..llsize].copy_from_slice(&src_ll_counts[..llsize]);\n    }\n    \n    if let (Some(src_d_counts), Some(dest_d_counts)) = (&source.d_counts, &mut dest.d_counts) {\n        dest_d_counts[..dsize].copy_from_slice(&src_d_counts[..dsize]);\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "lz77.rs",
        "error": "",
        "dependent": [
            "CeilDiv",
            "ZopfliCleanLZ77Store",
            "ZopfliInitLZ77Store",
            "ZopfliLZ77Store"
        ],
        "header": "void ZopfliCopyLZ77Store(const ZopfliLZ77Store *source, ZopfliLZ77Store *dest)",
        "params": [
            "const ZopfliLZ77Store *source",
            "ZopfliLZ77Store *dest"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "source",
            "dest",
            "i",
            "llsize",
            "dsize"
        ],
        "calle": [
            "ZopfliCleanLZ77Store",
            "exit",
            "CeilDiv",
            "ZopfliInitLZ77Store",
            "malloc"
        ],
        "calle_c": [
            "exit",
            "malloc"
        ],
        "key": "ZopfliCopyLZ77Store",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "RandomizeFreqs": {
        "source_code": "static void RandomizeFreqs(RanState *state, size_t *freqs, int n)\n{\n  int i;\n  for (i = 0; i < n; i += 1)\n  {\n    if (((Ran(state) >> 4) % 3) == 0)\n    {\n      freqs[i] = freqs[Ran(state) % n];\n    }\n  }\n\n}\n\n",
        "translated_code": "pub fn RandomizeFreqs(state: &mut RanState, freqs: &mut [usize]) {\n    for i in 0..freqs.len() {\n        if ((Ran(state) >> 4) % 3) == 0 {\n            let random_index = Ran(state) as usize % freqs.len();\n            freqs[i] = freqs[random_index];\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [
            "Ran",
            "RanState"
        ],
        "params": [
            "RanState *state",
            "size_t *freqs",
            "int n"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "state",
            "freqs",
            "n",
            "i"
        ],
        "calle": [
            "Ran"
        ],
        "calle_c": [],
        "key": "RandomizeFreqs",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "RandomizeStatFreqs": {
        "source_code": "static void RandomizeStatFreqs(RanState *state, SymbolStats *stats)\n{\n  RandomizeFreqs(state, stats->litlens, 288);\n  RandomizeFreqs(state, stats->dists, 32);\n  stats->litlens[256] = 1;\n}\n\n",
        "translated_code": "pub fn RandomizeStatFreqs(state: &mut RanState, stats: &mut SymbolStats) {\n    RandomizeFreqs(state, &mut stats.litlens);\n    RandomizeFreqs(state, &mut stats.dists);\n    stats.litlens[256] = 1;\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [
            "RanState",
            "RandomizeFreqs",
            "SymbolStats"
        ],
        "params": [
            "RanState *state",
            "SymbolStats *stats"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "state",
            "stats"
        ],
        "calle": [
            "RandomizeFreqs"
        ],
        "calle_c": [],
        "key": "RandomizeStatFreqs",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "CalculateStatistics": {
        "source_code": "static void CalculateStatistics(SymbolStats *stats)\n{\n  ZopfliCalculateEntropy(stats->litlens, 288, stats->ll_symbols);\n  ZopfliCalculateEntropy(stats->dists, 32, stats->d_symbols);\n}\n\n",
        "translated_code": "pub fn CalculateStatistics(stats: &mut SymbolStats) {\n    ZopfliCalculateEntropy(&stats.litlens, &mut stats.ll_symbols);\n    ZopfliCalculateEntropy(&stats.dists, &mut stats.d_symbols);\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [
            "SymbolStats",
            "ZopfliCalculateEntropy"
        ],
        "params": [
            "SymbolStats *stats"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "stats"
        ],
        "calle": [
            "ZopfliCalculateEntropy"
        ],
        "calle_c": [],
        "key": "CalculateStatistics",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "GetStatistics": {
        "source_code": "static void GetStatistics(const ZopfliLZ77Store *store, SymbolStats *stats)\n{\n  size_t i;\n  for (i = 0; i < store->size; i += 1)\n  {\n    if (store->dists[i] == 0)\n    {\n      stats->litlens[store->litlens[i]] += 1;\n    }\n    else\n    {\n      stats->litlens[ZopfliGetLengthSymbol(store->litlens[i])] += 1;\n      stats->dists[ZopfliGetDistSymbol(store->dists[i])] += 1;\n    }\n  }\n\n  stats->litlens[256] = 1;\n  CalculateStatistics(stats);\n}\n\n",
        "translated_code": "pub fn GetStatistics(store: &ZopfliLz77Store, stats: &mut SymbolStats) {\n    // Check if the required fields are present\n    if store.litlens.is_none() || store.dists.is_none() {\n        return;\n    }\n\n    let litlens = store.litlens.as_ref().unwrap();\n    let dists = store.dists.as_ref().unwrap();\n\n    for i in 0..store.size {\n        if dists[i] == 0 {\n            stats.litlens[litlens[i] as usize] += 1;\n        } else {\n            stats.litlens[ZopfliGetLengthSymbol(litlens[i] as usize) as usize] += 1;\n            stats.dists[ZopfliGetDistSymbol(dists[i] as i32) as usize] += 1;\n        }\n    }\n\n    stats.litlens[256] = 1;\n    CalculateStatistics(stats);\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [
            "CalculateStatistics",
            "SymbolStats",
            "ZopfliGetDistSymbol",
            "ZopfliGetLengthSymbol",
            "ZopfliLZ77Store"
        ],
        "params": [
            "const ZopfliLZ77Store *store",
            "SymbolStats *stats"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "store",
            "stats",
            "i"
        ],
        "calle": [
            "ZopfliGetDistSymbol",
            "CalculateStatistics",
            "ZopfliGetLengthSymbol"
        ],
        "calle_c": [],
        "key": "GetStatistics",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "GetCostStat": {
        "source_code": "static double GetCostStat(unsigned litlen, unsigned dist, void *context)\n{\n  SymbolStats *stats = (SymbolStats *) context;\n  if (dist == 0)\n  {\n    return stats->ll_symbols[litlen];\n  }\n  else\n  {\n    int lsym = ZopfliGetLengthSymbol(litlen);\n    int lbits = ZopfliGetLengthExtraBits(litlen);\n    int dsym = ZopfliGetDistSymbol(dist);\n    int dbits = ZopfliGetDistExtraBits(dist);\n    return ((lbits + dbits) + stats->ll_symbols[lsym]) + stats->d_symbols[dsym];\n  }\n}\n\n",
        "translated_code": "pub fn GetCostStat(litlen: usize, dist: usize, context: Option<&SymbolStats>) -> Option<f64> {\n    // Check if context is None (equivalent to NULL check in C)\n    let stats = context?;\n\n    if dist == 0 {\n        // Safe array access - litlen must be < 288 since it's used as array index\n        Some(stats.ll_symbols[litlen])\n    } else {\n        let lsym = ZopfliGetLengthSymbol(litlen);\n        let lbits = ZopfliGetLengthExtraBits(litlen);\n        let dsym = ZopfliGetDistSymbol(dist as i32);\n        let dbits = ZopfliGetDistExtraBits(dist as i32);\n        \n        // Safe array accesses - lsym must be < 288 and dsym must be < 32\n        Some((lbits + dbits) as f64 + stats.ll_symbols[lsym as usize] + stats.d_symbols[dsym as usize])\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [
            "SymbolStats",
            "ZopfliGetDistExtraBits",
            "ZopfliGetDistSymbol",
            "ZopfliGetLengthExtraBits",
            "ZopfliGetLengthSymbol"
        ],
        "params": [
            "unsigned litlen",
            "unsigned dist",
            "void *context"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "litlen",
            "dist",
            "context",
            "stats",
            "lsym",
            "lbits",
            "dsym",
            "dbits"
        ],
        "calle": [
            "ZopfliGetDistSymbol",
            "ZopfliGetDistExtraBits",
            "ZopfliGetLengthExtraBits",
            "ZopfliGetLengthSymbol"
        ],
        "calle_c": [],
        "key": "GetCostStat",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliWarmupHash": {
        "source_code": "void ZopfliWarmupHash(const unsigned char *array, size_t pos, size_t end, ZopfliHash *h)\n{\n  UpdateHashValue(h, array[pos + 0]);\n  if ((pos + 1) < end)\n  {\n    UpdateHashValue(h, array[pos + 1]);\n  }\n}\n\n",
        "translated_code": "pub fn ZopfliWarmupHash(array: &[u8], pos: usize, end: usize, h: &mut ZopfliHash) {\n    UpdateHashValue(h, array[pos]);\n    if pos + 1 < end {\n        UpdateHashValue(h, array[pos + 1]);\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "hash.rs",
        "error": "",
        "dependent": [
            "UpdateHashValue",
            "ZopfliHash"
        ],
        "header": "void ZopfliWarmupHash(const unsigned char *array, size_t pos, size_t end, ZopfliHash *h)",
        "params": [
            "const unsigned char *array",
            "size_t pos",
            "size_t end",
            "ZopfliHash *h"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "array",
            "pos",
            "end",
            "h"
        ],
        "calle": [
            "UpdateHashValue"
        ],
        "calle_c": [],
        "key": "ZopfliWarmupHash",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliUpdateHash": {
        "source_code": "void ZopfliUpdateHash(const unsigned char *array, size_t pos, size_t end, ZopfliHash *h)\n{\n  unsigned short hpos = pos & (32768 - 1);\n  size_t amount = 0;\n  UpdateHashValue(h, ((pos + 3) <= end) ? (array[(pos + 3) - 1]) : (0));\n  h->hashval[hpos] = h->val;\n  if ((h->head[h->val] != (-1)) && (h->hashval[h->head[h->val]] == h->val))\n  {\n    h->prev[hpos] = h->head[h->val];\n  }\n  else\n    h->prev[hpos] = hpos;\n  h->head[h->val] = hpos;\n  if (h->same[(pos - 1) & (32768 - 1)] > 1)\n  {\n    amount = h->same[(pos - 1) & (32768 - 1)] - 1;\n  }\n  while (((((pos + amount) + 1) < end) && (array[pos] == array[(pos + amount) + 1])) && (amount < ((unsigned short) (-1))))\n  {\n    amount += 1;\n  }\n\n  h->same[hpos] = amount;\n  h->val2 = ((h->same[hpos] - 3) & 255) ^ h->val;\n  h->hashval2[hpos] = h->val2;\n  if ((h->head2[h->val2] != (-1)) && (h->hashval2[h->head2[h->val2]] == h->val2))\n  {\n    h->prev2[hpos] = h->head2[h->val2];\n  }\n  else\n    h->prev2[hpos] = hpos;\n  h->head2[h->val2] = hpos;\n}\n\n",
        "translated_code": "pub fn ZopfliUpdateHash(array: &[u8], pos: usize, end: usize, h: &mut ZopfliHash) {\n    let hpos = pos & (32768 - 1);\n    let mut amount = 0usize;\n\n    // Update hash value based on array[pos + 3 - 1] if within bounds, else 0\n    let c = if pos + 3 <= end {\n        array[pos + 3 - 1]\n    } else {\n        0\n    };\n    UpdateHashValue(h, c);\n\n    // Safe unwrap since we know these vectors exist (from C code assumptions)\n    h.hashval.as_mut().unwrap()[hpos] = h.val;\n\n    if h.head.as_ref().unwrap()[h.val as usize] != -1 \n        && h.hashval.as_ref().unwrap()[h.head.as_ref().unwrap()[h.val as usize] as usize] == h.val \n    {\n        h.prev.as_mut().unwrap()[hpos] = h.head.as_ref().unwrap()[h.val as usize] as u16;\n    } else {\n        h.prev.as_mut().unwrap()[hpos] = hpos as u16;\n    }\n    h.head.as_mut().unwrap()[h.val as usize] = hpos as i32;\n\n    // Calculate amount\n    if h.same.as_ref().unwrap()[(pos - 1) & (32768 - 1)] > 1 {\n        amount = h.same.as_ref().unwrap()[(pos - 1) & (32768 - 1)] as usize - 1;\n    }\n\n    while (pos + amount + 1) < end \n        && array[pos] == array[pos + amount + 1] \n        && amount < u16::MAX as usize \n    {\n        amount += 1;\n    }\n\n    h.same.as_mut().unwrap()[hpos] = amount as u16;\n\n    h.val2 = ((h.same.as_ref().unwrap()[hpos] as i32 - 3) & 255) ^ h.val;\n    h.hashval2.as_mut().unwrap()[hpos] = h.val2;\n\n    if h.head2.as_ref().unwrap()[h.val2 as usize] != -1 \n        && h.hashval2.as_ref().unwrap()[h.head2.as_ref().unwrap()[h.val2 as usize] as usize] == h.val2 \n    {\n        h.prev2.as_mut().unwrap()[hpos] = h.head2.as_ref().unwrap()[h.val2 as usize] as u16;\n    } else {\n        h.prev2.as_mut().unwrap()[hpos] = hpos as u16;\n    }\n    h.head2.as_mut().unwrap()[h.val2 as usize] = hpos as i32;\n}",
        "hint": "functions",
        "section": "src",
        "file": "hash.rs",
        "error": "",
        "dependent": [
            "UpdateHashValue",
            "ZopfliHash"
        ],
        "header": "void ZopfliUpdateHash(const unsigned char *array, size_t pos, size_t end, ZopfliHash *h)",
        "params": [
            "const unsigned char *array",
            "size_t pos",
            "size_t end",
            "ZopfliHash *h"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "array",
            "pos",
            "end",
            "h",
            "hpos",
            "amount"
        ],
        "calle": [
            "UpdateHashValue"
        ],
        "calle_c": [],
        "key": "ZopfliUpdateHash",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliStoreLitLenDist": {
        "source_code": "void ZopfliStoreLitLenDist(unsigned short length, unsigned short dist, size_t pos, ZopfliLZ77Store *store)\n{\n  size_t i;\n  size_t origsize = store->size;\n  size_t llstart = 288 * (origsize / 288);\n  size_t dstart = 32 * (origsize / 32);\n  if ((origsize % 288) == 0)\n  {\n    size_t llsize = origsize;\n    for (i = 0; i < 288; i += 1)\n    {\n      {\n        if (!((*(&llsize)) & ((*(&llsize)) - 1)))\n        {\n          *(&store->ll_counts) = ((*(&llsize)) == 0) ? (malloc(sizeof(*(*(&store->ll_counts))))) : (realloc(*(&store->ll_counts), ((*(&llsize)) * 2) * (sizeof(*(*(&store->ll_counts))))));\n        }\n        (*(&store->ll_counts))[*(&llsize)] = (origsize == 0) ? (0) : (store->ll_counts[(origsize - 288) + i]);\n        *(&llsize) += 1;\n      }\n      ;\n    }\n\n  }\n  if ((origsize % 32) == 0)\n  {\n    size_t dsize = origsize;\n    for (i = 0; i < 32; i += 1)\n    {\n      {\n        if (!((*(&dsize)) & ((*(&dsize)) - 1)))\n        {\n          *(&store->d_counts) = ((*(&dsize)) == 0) ? (malloc(sizeof(*(*(&store->d_counts))))) : (realloc(*(&store->d_counts), ((*(&dsize)) * 2) * (sizeof(*(*(&store->d_counts))))));\n        }\n        (*(&store->d_counts))[*(&dsize)] = (origsize == 0) ? (0) : (store->d_counts[(origsize - 32) + i]);\n        *(&dsize) += 1;\n      }\n      ;\n    }\n\n  }\n  {\n    if (!((*(&store->size)) & ((*(&store->size)) - 1)))\n    {\n      *(&store->litlens) = ((*(&store->size)) == 0) ? (malloc(sizeof(*(*(&store->litlens))))) : (realloc(*(&store->litlens), ((*(&store->size)) * 2) * (sizeof(*(*(&store->litlens))))));\n    }\n    (*(&store->litlens))[*(&store->size)] = length;\n    *(&store->size) += 1;\n  }\n  ;\n  store->size = origsize;\n  {\n    if (!((*(&store->size)) & ((*(&store->size)) - 1)))\n    {\n      *(&store->dists) = ((*(&store->size)) == 0) ? (malloc(sizeof(*(*(&store->dists))))) : (realloc(*(&store->dists), ((*(&store->size)) * 2) * (sizeof(*(*(&store->dists))))));\n    }\n    (*(&store->dists))[*(&store->size)] = dist;\n    *(&store->size) += 1;\n  }\n  ;\n  store->size = origsize;\n  {\n    if (!((*(&store->size)) & ((*(&store->size)) - 1)))\n    {\n      *(&store->pos) = ((*(&store->size)) == 0) ? (malloc(sizeof(*(*(&store->pos))))) : (realloc(*(&store->pos), ((*(&store->size)) * 2) * (sizeof(*(*(&store->pos))))));\n    }\n    (*(&store->pos))[*(&store->size)] = pos;\n    *(&store->size) += 1;\n  }\n  ;\n  assert(length < 259);\n  if (dist == 0)\n  {\n    store->size = origsize;\n    {\n      if (!((*(&store->size)) & ((*(&store->size)) - 1)))\n      {\n        *(&store->ll_symbol) = ((*(&store->size)) == 0) ? (malloc(sizeof(*(*(&store->ll_symbol))))) : (realloc(*(&store->ll_symbol), ((*(&store->size)) * 2) * (sizeof(*(*(&store->ll_symbol))))));\n      }\n      (*(&store->ll_symbol))[*(&store->size)] = length;\n      *(&store->size) += 1;\n    }\n    ;\n    store->size = origsize;\n    {\n      if (!((*(&store->size)) & ((*(&store->size)) - 1)))\n      {\n        *(&store->d_symbol) = ((*(&store->size)) == 0) ? (malloc(sizeof(*(*(&store->d_symbol))))) : (realloc(*(&store->d_symbol), ((*(&store->size)) * 2) * (sizeof(*(*(&store->d_symbol))))));\n      }\n      (*(&store->d_symbol))[*(&store->size)] = 0;\n      *(&store->size) += 1;\n    }\n    ;\n    store->ll_counts[llstart + length] += 1;\n  }\n  else\n  {\n    store->size = origsize;\n    {\n      if (!((*(&store->size)) & ((*(&store->size)) - 1)))\n      {\n        *(&store->ll_symbol) = ((*(&store->size)) == 0) ? (malloc(sizeof(*(*(&store->ll_symbol))))) : (realloc(*(&store->ll_symbol), ((*(&store->size)) * 2) * (sizeof(*(*(&store->ll_symbol))))));\n      }\n      (*(&store->ll_symbol))[*(&store->size)] = ZopfliGetLengthSymbol(length);\n      *(&store->size) += 1;\n    }\n    ;\n    store->size = origsize;\n    {\n      if (!((*(&store->size)) & ((*(&store->size)) - 1)))\n      {\n        *(&store->d_symbol) = ((*(&store->size)) == 0) ? (malloc(sizeof(*(*(&store->d_symbol))))) : (realloc(*(&store->d_symbol), ((*(&store->size)) * 2) * (sizeof(*(*(&store->d_symbol))))));\n      }\n      (*(&store->d_symbol))[*(&store->size)] = ZopfliGetDistSymbol(dist);\n      *(&store->size) += 1;\n    }\n    ;\n    store->ll_counts[llstart + ZopfliGetLengthSymbol(length)] += 1;\n    store->d_counts[dstart + ZopfliGetDistSymbol(dist)] += 1;\n  }\n}\n\n",
        "translated_code": "use std::assert;\n\npub fn ZopfliStoreLitLenDist(length: u16, dist: u16, pos: usize, store: &mut ZopfliLz77Store) {\n    let origsize = store.size;\n    let llstart = 288 * (origsize / 288);\n    let dstart = 32 * (origsize / 32);\n\n    if origsize % 288 == 0 {\n        let mut llsize = origsize;\n        for _ in 0..288 {\n            if (llsize & (llsize - 1)) == 0 {\n                let new_capacity = if llsize == 0 { 1 } else { llsize * 2 };\n                store.ll_counts.get_or_insert_with(|| Vec::with_capacity(new_capacity))\n                    .resize(new_capacity, 0);\n            }\n            let val = if origsize == 0 { 0 } else { store.ll_counts.as_ref().unwrap()[(origsize - 288) + (llsize - origsize)] };\n            store.ll_counts.as_mut().unwrap()[llsize] = val;\n            llsize += 1;\n        }\n    }\n\n    if origsize % 32 == 0 {\n        let mut dsize = origsize;\n        for _ in 0..32 {\n            if (dsize & (dsize - 1)) == 0 {\n                let new_capacity = if dsize == 0 { 1 } else { dsize * 2 };\n                store.d_counts.get_or_insert_with(|| Vec::with_capacity(new_capacity))\n                    .resize(new_capacity, 0);\n            }\n            let val = if origsize == 0 { 0 } else { store.d_counts.as_ref().unwrap()[(origsize - 32) + (dsize - origsize)] };\n            store.d_counts.as_mut().unwrap()[dsize] = val;\n            dsize += 1;\n        }\n    }\n\n    if (store.size & (store.size - 1)) == 0 {\n        let new_capacity = if store.size == 0 { 1 } else { store.size * 2 };\n        store.litlens.get_or_insert_with(|| Vec::with_capacity(new_capacity))\n            .resize(new_capacity, 0);\n    }\n    store.litlens.as_mut().unwrap()[store.size] = length;\n    store.size += 1;\n\n    store.size = origsize;\n    if (store.size & (store.size - 1)) == 0 {\n        let new_capacity = if store.size == 0 { 1 } else { store.size * 2 };\n        store.dists.get_or_insert_with(|| Vec::with_capacity(new_capacity))\n            .resize(new_capacity, 0);\n    }\n    store.dists.as_mut().unwrap()[store.size] = dist;\n    store.size += 1;\n\n    store.size = origsize;\n    if (store.size & (store.size - 1)) == 0 {\n        let new_capacity = if store.size == 0 { 1 } else { store.size * 2 };\n        store.pos.get_or_insert_with(|| Vec::with_capacity(new_capacity))\n            .resize(new_capacity, 0);\n    }\n    store.pos.as_mut().unwrap()[store.size] = pos;\n    store.size += 1;\n\n    assert!(length < 259);\n    if dist == 0 {\n        store.size = origsize;\n        if (store.size & (store.size - 1)) == 0 {\n            let new_capacity = if store.size == 0 { 1 } else { store.size * 2 };\n            store.ll_symbol.get_or_insert_with(|| Vec::with_capacity(new_capacity))\n                .resize(new_capacity, 0);\n        }\n        store.ll_symbol.as_mut().unwrap()[store.size] = length;\n        store.size += 1;\n\n        store.size = origsize;\n        if (store.size & (store.size - 1)) == 0 {\n            let new_capacity = if store.size == 0 { 1 } else { store.size * 2 };\n            store.d_symbol.get_or_insert_with(|| Vec::with_capacity(new_capacity))\n                .resize(new_capacity, 0);\n        }\n        store.d_symbol.as_mut().unwrap()[store.size] = 0;\n        store.size += 1;\n\n        store.ll_counts.as_mut().unwrap()[llstart + length as usize] += 1;\n    } else {\n        store.size = origsize;\n        if (store.size & (store.size - 1)) == 0 {\n            let new_capacity = if store.size == 0 { 1 } else { store.size * 2 };\n            store.ll_symbol.get_or_insert_with(|| Vec::with_capacity(new_capacity))\n                .resize(new_capacity, 0);\n        }\n        store.ll_symbol.as_mut().unwrap()[store.size] = ZopfliGetLengthSymbol(length as usize) as u16;\n        store.size += 1;\n\n        store.size = origsize;\n        if (store.size & (store.size - 1)) == 0 {\n            let new_capacity = if store.size == 0 { 1 } else { store.size * 2 };\n            store.d_symbol.get_or_insert_with(|| Vec::with_capacity(new_capacity))\n                .resize(new_capacity, 0);\n        }\n        store.d_symbol.as_mut().unwrap()[store.size] = ZopfliGetDistSymbol(dist as i32) as u16;\n        store.size += 1;\n\n        store.ll_counts.as_mut().unwrap()[llstart + ZopfliGetLengthSymbol(length as usize) as usize] += 1;\n        store.d_counts.as_mut().unwrap()[dstart + ZopfliGetDistSymbol(dist as i32) as usize] += 1;\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "lz77.rs",
        "error": "",
        "dependent": [
            "ZopfliGetDistSymbol",
            "ZopfliGetLengthSymbol",
            "ZopfliLZ77Store"
        ],
        "header": "void ZopfliStoreLitLenDist(unsigned short length, unsigned short dist, size_t pos, ZopfliLZ77Store *store)",
        "params": [
            "unsigned short length",
            "unsigned short dist",
            "size_t pos",
            "ZopfliLZ77Store *store"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "length",
            "dist",
            "pos",
            "store",
            "i",
            "origsize",
            "llstart",
            "dstart",
            "llsize",
            "dsize"
        ],
        "calle": [
            "realloc",
            "ZopfliGetDistSymbol",
            "ZopfliGetLengthSymbol",
            "malloc",
            "assert"
        ],
        "calle_c": [
            "realloc",
            "assert",
            "malloc"
        ],
        "key": "ZopfliStoreLitLenDist",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "TryGetFromLongestMatchCache": {
        "source_code": "static int TryGetFromLongestMatchCache(ZopfliBlockState *s, size_t pos, size_t *limit, unsigned short *sublen, unsigned short *distance, unsigned short *length)\n{\n  size_t lmcpos = pos - s->blockstart;\n  unsigned char cache_available = s->lmc && ((s->lmc->length[lmcpos] == 0) || (s->lmc->dist[lmcpos] != 0));\n  unsigned char limit_ok_for_cache = cache_available && ((((*limit) == 258) || (s->lmc->length[lmcpos] <= (*limit))) || (sublen && (ZopfliMaxCachedSublen(s->lmc, lmcpos, s->lmc->length[lmcpos]) >= (*limit))));\n  if ((s->lmc && limit_ok_for_cache) && cache_available)\n  {\n    if ((!sublen) || (s->lmc->length[lmcpos] <= ZopfliMaxCachedSublen(s->lmc, lmcpos, s->lmc->length[lmcpos])))\n    {\n      *length = s->lmc->length[lmcpos];\n      if ((*length) > (*limit))\n      {\n        *length = *limit;\n      }\n      if (sublen)\n      {\n        ZopfliCacheToSublen(s->lmc, lmcpos, *length, sublen);\n        *distance = sublen[*length];\n        if (((*limit) == 258) && ((*length) >= 3))\n        {\n          assert(sublen[*length] == s->lmc->dist[lmcpos]);\n        }\n      }\n      else\n      {\n        *distance = s->lmc->dist[lmcpos];\n      }\n      return 1;\n    }\n    *limit = s->lmc->length[lmcpos];\n  }\n  return 0;\n}\n\n",
        "translated_code": "pub fn TryGetFromLongestMatchCache(\n    s: &ZopfliBlockState,\n    pos: usize,\n    limit: &mut usize,\n    sublen: Option<&mut [u16]>,\n    distance: &mut u16,\n    length: &mut u16,\n) -> bool {\n    let lmcpos = pos - s.blockstart;\n    \n    let cache_available = s.lmc.as_ref().map_or(false, |lmc| {\n        lmc.length.as_ref().map_or(false, |lengths| {\n            lengths[lmcpos] == 0 || lmc.dist.as_ref().map_or(false, |dists| dists[lmcpos] != 0)\n        })\n    });\n\n    let limit_ok_for_cache = cache_available && s.lmc.as_ref().map_or(false, |lmc| {\n        let lmc_length = lmc.length.as_ref().unwrap()[lmcpos];\n        (*limit == 258 || usize::from(lmc_length) <= *limit) || sublen.is_some() && \n            (usize::from(ZopfliMaxCachedSublen(lmc, lmcpos, usize::from(lmc_length))) >= *limit)\n    });\n\n    if s.lmc.is_some() && limit_ok_for_cache && cache_available {\n        if let Some(lmc) = s.lmc.as_ref() {\n            let lmc_length = lmc.length.as_ref().unwrap()[lmcpos];\n            if sublen.is_none() || lmc_length <= ZopfliMaxCachedSublen(lmc, lmcpos, usize::from(lmc_length)) {\n                *length = lmc_length;\n                if usize::from(*length) > *limit {\n                    *length = (*limit) as u16;\n                }\n                \n                if let Some(sublen) = sublen {\n                    ZopfliCacheToSublen(lmc, lmcpos, usize::from(*length), sublen);\n                    *distance = sublen[usize::from(*length)];\n                    if *limit == 258 && *length >= 3 {\n                        assert!(sublen[usize::from(*length)] == lmc.dist.as_ref().unwrap()[lmcpos]);\n                    }\n                } else {\n                    *distance = lmc.dist.as_ref().unwrap()[lmcpos];\n                }\n                return true;\n            }\n            *limit = usize::from(lmc_length);\n        }\n    }\n    false\n}",
        "hint": "functions",
        "section": "src",
        "file": "lz77.rs",
        "error": "",
        "dependent": [
            "ZopfliBlockState",
            "ZopfliCacheToSublen",
            "ZopfliMaxCachedSublen"
        ],
        "params": [
            "ZopfliBlockState *s",
            "size_t pos",
            "size_t *limit",
            "unsigned short *sublen",
            "unsigned short *distance",
            "unsigned short *length"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "s",
            "pos",
            "limit",
            "sublen",
            "distance",
            "length",
            "lmcpos",
            "cache_available",
            "limit_ok_for_cache"
        ],
        "calle": [
            "ZopfliMaxCachedSublen",
            "assert",
            "ZopfliCacheToSublen"
        ],
        "calle_c": [
            "assert"
        ],
        "key": "TryGetFromLongestMatchCache",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "StoreInLongestMatchCache": {
        "source_code": "static void StoreInLongestMatchCache(ZopfliBlockState *s, size_t pos, size_t limit, const unsigned short *sublen, unsigned short distance, unsigned short length)\n{\n  size_t lmcpos = pos - s->blockstart;\n  unsigned char cache_available = s->lmc && ((s->lmc->length[lmcpos] == 0) || (s->lmc->dist[lmcpos] != 0));\n  if (((s->lmc && (limit == 258)) && sublen) && (!cache_available))\n  {\n    assert((s->lmc->length[lmcpos] == 1) && (s->lmc->dist[lmcpos] == 0));\n    s->lmc->dist[lmcpos] = (length < 3) ? (0) : (distance);\n    s->lmc->length[lmcpos] = (length < 3) ? (0) : (length);\n    assert(!((s->lmc->length[lmcpos] == 1) && (s->lmc->dist[lmcpos] == 0)));\n    ZopfliSublenToCache(sublen, lmcpos, length, s->lmc);\n  }\n}\n\n",
        "translated_code": "use std::assert;\n\npub fn StoreInLongestMatchCache(\n    s: &mut ZopfliBlockState,\n    pos: usize,\n    limit: usize,\n    sublen: Option<&[u16]>,\n    distance: u16,\n    length: u16,\n) {\n    let lmcpos = pos - s.blockstart;\n    let cache_available = s.lmc.as_ref().map_or(false, |lmc| {\n        lmc.length.as_ref().map_or(false, |lengths| {\n            lengths[lmcpos] == 0 || lmc.dist.as_ref().map_or(false, |dists| dists[lmcpos] != 0)\n        })\n    });\n\n    if s.lmc.is_some() && limit == 258 && sublen.is_some() && !cache_available {\n        if let Some(lmc) = s.lmc.as_mut() {\n            assert!(lmc.length.as_ref().map_or(false, |lengths| lengths[lmcpos] == 1)\n                && lmc.dist.as_ref().map_or(false, |dists| dists[lmcpos] == 0));\n\n            if let Some(dists) = lmc.dist.as_mut() {\n                dists[lmcpos] = if length < 3 { 0 } else { distance };\n            }\n            if let Some(lengths) = lmc.length.as_mut() {\n                lengths[lmcpos] = if length < 3 { 0 } else { length };\n            }\n\n            assert!(!(lmc.length.as_ref().map_or(false, |lengths| lengths[lmcpos] == 1)\n                && lmc.dist.as_ref().map_or(false, |dists| dists[lmcpos] == 0)));\n\n            if let Some(sublen) = sublen {\n                ZopfliSublenToCache(sublen, lmcpos, length as usize, lmc);\n            }\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "lz77.rs",
        "error": "",
        "dependent": [
            "ZopfliBlockState",
            "ZopfliSublenToCache"
        ],
        "params": [
            "ZopfliBlockState *s",
            "size_t pos",
            "size_t limit",
            "const unsigned short *sublen",
            "unsigned short distance",
            "unsigned short length"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "s",
            "pos",
            "limit",
            "sublen",
            "distance",
            "length",
            "lmcpos",
            "cache_available"
        ],
        "calle": [
            "ZopfliSublenToCache",
            "assert"
        ],
        "calle_c": [
            "assert"
        ],
        "key": "StoreInLongestMatchCache",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliFindLongestMatch": {
        "source_code": "void ZopfliFindLongestMatch(ZopfliBlockState *s, const ZopfliHash *h, const unsigned char *array, size_t pos, size_t size, size_t limit, unsigned short *sublen, unsigned short *distance, unsigned short *length)\n{\n  unsigned short hpos = pos & (32768 - 1);\n  unsigned short p;\n  unsigned short pp;\n  unsigned short bestdist = 0;\n  unsigned short bestlength = 1;\n  const unsigned char *scan;\n  const unsigned char *match;\n  const unsigned char *arrayend;\n  const unsigned char *arrayend_safe;\n  int chain_counter = 8192;\n  unsigned dist = 0;\n  int *hhead = h->head;\n  unsigned short *hprev = h->prev;\n  int *hhashval = h->hashval;\n  int hval = h->val;\n  if (TryGetFromLongestMatchCache(s, pos, &limit, sublen, distance, length))\n  {\n    assert((pos + (*length)) <= size);\n    return;\n  }\n  assert(limit <= 258);\n  assert(limit >= 3);\n  assert(pos < size);\n  if ((size - pos) < 3)\n  {\n    *length = 0;\n    *distance = 0;\n    return;\n  }\n  if ((pos + limit) > size)\n  {\n    limit = size - pos;\n  }\n  arrayend = (&array[pos]) + limit;\n  arrayend_safe = arrayend - 8;\n  assert(hval < 65536);\n  pp = hhead[hval];\n  p = hprev[pp];\n  assert(pp == hpos);\n  dist = (p < pp) ? (pp - p) : ((32768 - p) + pp);\n  while (dist < 32768)\n  {\n    unsigned short currentlength = 0;\n    assert(p < 32768);\n    assert(p == hprev[pp]);\n    assert(hhashval[p] == hval);\n    if (dist > 0)\n    {\n      assert(pos < size);\n      assert(dist <= pos);\n      scan = &array[pos];\n      match = &array[pos - dist];\n      if (((pos + bestlength) >= size) || ((*(scan + bestlength)) == (*(match + bestlength))))\n      {\n        unsigned short same0 = h->same[pos & (32768 - 1)];\n        if ((same0 > 2) && ((*scan) == (*match)))\n        {\n          unsigned short same1 = h->same[(pos - dist) & (32768 - 1)];\n          unsigned short same = (same0 < same1) ? (same0) : (same1);\n          if (same > limit)\n          {\n            same = limit;\n          }\n          scan += same;\n          match += same;\n        }\n        scan = GetMatch(scan, match, arrayend, arrayend_safe);\n        currentlength = scan - (&array[pos]);\n      }\n      if (currentlength > bestlength)\n      {\n        if (sublen)\n        {\n          unsigned short j;\n          for (j = bestlength + 1; j <= currentlength; j += 1)\n          {\n            sublen[j] = dist;\n          }\n\n        }\n        bestdist = dist;\n        bestlength = currentlength;\n        if (currentlength >= limit)\n        {\n          break;\n        }\n      }\n    }\n    if (((hhead != h->head2) && (bestlength >= h->same[hpos])) && (h->val2 == h->hashval2[p]))\n    {\n      hhead = h->head2;\n      hprev = h->prev2;\n      hhashval = h->hashval2;\n      hval = h->val2;\n    }\n    pp = p;\n    p = hprev[p];\n    if (p == pp)\n    {\n      break;\n    }\n    dist += (p < pp) ? (pp - p) : ((32768 - p) + pp);\n    chain_counter -= 1;\n    if (chain_counter <= 0)\n    {\n      break;\n    }\n  }\n\n  StoreInLongestMatchCache(s, pos, limit, sublen, bestdist, bestlength);\n  assert(bestlength <= limit);\n  *distance = bestdist;\n  *length = bestlength;\n  assert((pos + (*length)) <= size);\n}\n\n",
        "translated_code": "pub fn ZopfliFindLongestMatch(\n    s: &mut ZopfliBlockState,\n    h: &ZopfliHash,\n    array: &[u8],\n    pos: usize,\n    size: usize,\n    limit: usize,\n    sublen: &mut Option<&mut [u16]>,\n    distance: &mut u16,\n    length: &mut u16,\n) {\n    let hpos = pos & (32768 - 1);\n    let mut p;\n    let mut pp;\n    let mut bestdist: u16 = 0;\n    let mut bestlength: u16 = 1;\n    let mut chain_counter = 8192;\n    let mut dist = 0;\n    \n    let hhead = h.head.as_ref().unwrap();\n    let hprev = h.prev.as_ref().unwrap();\n    let hhashval = h.hashval.as_ref().unwrap();\n    let hval = h.val;\n    \n    let mut limit_mut = limit;\n    if TryGetFromLongestMatchCache(s, pos, &mut limit_mut, sublen.as_deref_mut(), distance, length) {\n        assert!((pos + (*length as usize)) <= size);\n        return;\n    }\n    \n    assert!(limit_mut <= 258);\n    assert!(limit_mut >= 3);\n    assert!(pos < size);\n    \n    if (size - pos) < 3 {\n        *length = 0;\n        *distance = 0;\n        return;\n    }\n    \n    let mut actual_limit = limit_mut;\n    if (pos + actual_limit) > size {\n        actual_limit = size - pos;\n    }\n    \n    let array_slice = &array[pos..];\n    let arrayend = &array_slice[..actual_limit];\n    let arrayend_safe = if actual_limit > 8 {\n        &arrayend[..actual_limit - 8]\n    } else {\n        &arrayend[..0]\n    };\n    \n    assert!(hval < 65536);\n    pp = hhead[hval as usize] as u16;\n    p = hprev[pp as usize];\n    assert!(pp == hpos as u16);\n    \n    dist = if p < pp {\n        (pp - p) as usize\n    } else {\n        ((32768 - p) + pp) as usize\n    };\n    \n    let mut hhead_current = hhead;\n    let mut hprev_current = hprev;\n    let mut hhashval_current = hhashval;\n    let mut hval_current = hval;\n    \n    while dist < 32768 {\n        let mut currentlength: u16 = 0;\n        assert!(p < 32768);\n        assert!(p == hprev_current[pp as usize]);\n        assert!(hhashval_current[p as usize] == hval_current);\n        \n        if dist > 0 {\n            assert!(pos < size);\n            assert!(dist <= pos);\n            \n            let scan_slice = &array[pos..];\n            let match_slice = &array[pos - dist..];\n            \n            if (pos + bestlength as usize >= size) || (scan_slice.get(bestlength as usize) == match_slice.get(bestlength as usize)) {\n                let same_array = h.same.as_ref().unwrap();\n                let same0 = same_array[hpos];\n                \n                if same0 > 2 && scan_slice.get(0) == match_slice.get(0) {\n                    let same1 = same_array[(pos - dist) & (32768 - 1)];\n                    let same = if same0 < same1 { same0 } else { same1 };\n                    let same = if same > actual_limit as u16 {\n                        actual_limit as u16\n                    } else {\n                        same\n                    };\n                    \n                    let scan_advanced = &scan_slice[same as usize..];\n                    let match_advanced = &match_slice[same as usize..];\n                    \n                    if let Some(scan_result) = GetMatch(scan_advanced, match_advanced, arrayend, arrayend_safe) {\n                        currentlength = (scan_result.as_ptr() as usize - scan_slice.as_ptr() as usize) as u16;\n                    }\n                } else {\n                    if let Some(scan_result) = GetMatch(scan_slice, match_slice, arrayend, arrayend_safe) {\n                        currentlength = (scan_result.as_ptr() as usize - scan_slice.as_ptr() as usize) as u16;\n                    }\n                }\n            }\n            \n            if currentlength > bestlength {\n                if let Some(sublen_slice) = sublen.as_mut() {\n                    for j in (bestlength as usize + 1)..=currentlength as usize {\n                        if j < sublen_slice.len() {\n                            sublen_slice[j] = dist as u16;\n                        }\n                    }\n                }\n                \n                bestdist = dist as u16;\n                bestlength = currentlength;\n                \n                if currentlength >= actual_limit as u16 {\n                    break;\n                }\n            }\n        }\n        \n        if hhead_current.as_ptr() != h.head2.as_ref().unwrap().as_ptr() \n            && bestlength as usize >= h.same.as_ref().unwrap()[hpos] as usize \n            && h.val2 == h.hashval2.as_ref().unwrap()[p as usize] \n        {\n            hhead_current = h.head2.as_ref().unwrap();\n            hprev_current = h.prev2.as_ref().unwrap();\n            hhashval_current = h.hashval2.as_ref().unwrap();\n            hval_current = h.val2;\n        }\n        \n        pp = p;\n        p = hprev_current[p as usize];\n        \n        if p == pp {\n            break;\n        }\n        \n        dist += if p < pp {\n            (pp - p) as usize\n        } else {\n            ((32768 - p) + pp) as usize\n        };\n        \n        chain_counter -= 1;\n        if chain_counter <= 0 {\n            break;\n        }\n    }\n    \n    StoreInLongestMatchCache(s, pos, actual_limit, sublen.as_deref(), bestdist, bestlength);\n    assert!(bestlength <= actual_limit as u16);\n    *distance = bestdist;\n    *length = bestlength;\n    assert!((pos + (*length as usize)) <= size);\n}",
        "hint": "functions",
        "section": "src",
        "file": "lz77.rs",
        "error": "",
        "dependent": [
            "GetMatch",
            "StoreInLongestMatchCache",
            "TryGetFromLongestMatchCache",
            "ZopfliBlockState",
            "ZopfliHash"
        ],
        "header": "void ZopfliFindLongestMatch(ZopfliBlockState *s, const ZopfliHash *h, const unsigned char *array, size_t pos, size_t size, size_t limit, unsigned short *sublen, unsigned short *distance, unsigned short *length)",
        "params": [
            "ZopfliBlockState *s",
            "const ZopfliHash *h",
            "const unsigned char *array",
            "size_t pos",
            "size_t size",
            "size_t limit",
            "unsigned short *sublen",
            "unsigned short *distance",
            "unsigned short *length"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "s",
            "h",
            "array",
            "pos",
            "size",
            "limit",
            "sublen",
            "distance",
            "length",
            "hpos",
            "p",
            "pp",
            "bestdist",
            "bestlength",
            "scan",
            "scan_idx",
            "match",
            "match_idx",
            "arrayend",
            "arrayend_idx",
            "arrayend_safe",
            "arrayend_safe_idx",
            "chain_counter",
            "dist",
            "hhead",
            "hhead_idx",
            "hprev",
            "hprev_idx",
            "hhashval",
            "hhashval_idx",
            "hval",
            "currentlength",
            "same0",
            "same1",
            "same",
            "j"
        ],
        "calle": [
            "TryGetFromLongestMatchCache",
            "StoreInLongestMatchCache",
            "GetMatch",
            "assert"
        ],
        "calle_c": [
            "assert"
        ],
        "key": "ZopfliFindLongestMatch",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "ZopfliLZ77Greedy": {
        "source_code": "void ZopfliLZ77Greedy(ZopfliBlockState *s, const unsigned char *in, size_t instart, size_t inend, ZopfliLZ77Store *store, ZopfliHash *h)\n{\n  size_t i = 0;\n  size_t j;\n  unsigned short leng;\n  unsigned short dist;\n  int lengthscore;\n  size_t windowstart = (instart > 32768) ? (instart - 32768) : (0);\n  unsigned short dummysublen[259];\n  unsigned prev_length = 0;\n  unsigned prev_match = 0;\n  int prevlengthscore;\n  int match_available = 0;\n  if (instart == inend)\n  {\n    return;\n  }\n  ZopfliResetHash(32768, h);\n  ZopfliWarmupHash(in, windowstart, inend, h);\n  for (i = windowstart; i < instart; i += 1)\n  {\n    ZopfliUpdateHash(in, i, inend, h);\n  }\n\n  for (i = instart; i < inend; i += 1)\n  {\n    ZopfliUpdateHash(in, i, inend, h);\n    ZopfliFindLongestMatch(s, h, in, i, inend, 258, dummysublen, &dist, &leng);\n    lengthscore = GetLengthScore(leng, dist);\n    prevlengthscore = GetLengthScore(prev_length, prev_match);\n    if (match_available)\n    {\n      match_available = 0;\n      if (lengthscore > (prevlengthscore + 1))\n      {\n        ZopfliStoreLitLenDist(in[i - 1], 0, i - 1, store);\n        if ((lengthscore >= 3) && (leng < 258))\n        {\n          match_available = 1;\n          prev_length = leng;\n          prev_match = dist;\n          continue;\n        }\n      }\n      else\n      {\n        leng = prev_length;\n        dist = prev_match;\n        lengthscore = prevlengthscore;\n        ZopfliVerifyLenDist(in, inend, i - 1, dist, leng);\n        ZopfliStoreLitLenDist(leng, dist, i - 1, store);\n        for (j = 2; j < leng; j += 1)\n        {\n          assert(i < inend);\n          i += 1;\n          ZopfliUpdateHash(in, i, inend, h);\n        }\n\n        continue;\n      }\n    }\n    else\n      if ((lengthscore >= 3) && (leng < 258))\n    {\n      match_available = 1;\n      prev_length = leng;\n      prev_match = dist;\n      continue;\n    }\n    if (lengthscore >= 3)\n    {\n      ZopfliVerifyLenDist(in, inend, i, dist, leng);\n      ZopfliStoreLitLenDist(leng, dist, i, store);\n    }\n    else\n    {\n      leng = 1;\n      ZopfliStoreLitLenDist(in[i], 0, i, store);\n    }\n    for (j = 1; j < leng; j += 1)\n    {\n      assert(i < inend);\n      i += 1;\n      ZopfliUpdateHash(in, i, inend, h);\n    }\n\n  }\n\n}\n\n",
        "translated_code": "pub fn ZopfliLZ77Greedy(\n    s: &mut ZopfliBlockState,\n    in_data: &[u8],\n    instart: usize,\n    inend: usize,\n    store: &mut ZopfliLz77Store,\n    h: &mut ZopfliHash,\n) {\n    let mut i = 0;\n    let mut j;\n    let mut leng: u16 = 0;\n    let mut dist: u16 = 0;\n    let mut lengthscore: i32;\n    let windowstart = if instart > 32768 {\n        instart - 32768\n    } else {\n        0\n    };\n    let mut dummysublen = [0u16; 259];\n    let mut prev_length: u16 = 0;\n    let mut prev_match: u16 = 0;\n    let mut prevlengthscore: i32;\n    let mut match_available = 0;\n\n    if instart == inend {\n        return;\n    }\n\n    ZopfliResetHash(32768, h);\n    ZopfliWarmupHash(in_data, windowstart, inend, h);\n    \n    i = windowstart;\n    while i < instart {\n        ZopfliUpdateHash(in_data, i, inend, h);\n        i += 1;\n    }\n\n    i = instart;\n    while i < inend {\n        ZopfliUpdateHash(in_data, i, inend, h);\n        ZopfliFindLongestMatch(\n            s,\n            h,\n            in_data,\n            i,\n            inend,\n            258,\n            &mut Some(&mut dummysublen),\n            &mut dist,\n            &mut leng,\n        );\n        lengthscore = GetLengthScore(leng as i32, dist as i32);\n        prevlengthscore = GetLengthScore(prev_length as i32, prev_match as i32);\n\n        if match_available != 0 {\n            match_available = 0;\n            if lengthscore > (prevlengthscore + 1) {\n                ZopfliStoreLitLenDist(in_data[i - 1] as u16, 0, i - 1, store);\n                if (lengthscore >= 3) && (leng < 258) {\n                    match_available = 1;\n                    prev_length = leng;\n                    prev_match = dist;\n                    continue;\n                }\n            } else {\n                leng = prev_length;\n                dist = prev_match;\n                lengthscore = prevlengthscore;\n                ZopfliVerifyLenDist(in_data, i - 1, dist, leng);\n                ZopfliStoreLitLenDist(leng, dist, i - 1, store);\n                j = 2;\n                while j < leng {\n                    assert!(i < inend);\n                    i += 1;\n                    ZopfliUpdateHash(in_data, i, inend, h);\n                    j += 1;\n                }\n                continue;\n            }\n        } else if (lengthscore >= 3) && (leng < 258) {\n            match_available = 1;\n            prev_length = leng;\n            prev_match = dist;\n            continue;\n        }\n\n        if lengthscore >= 3 {\n            ZopfliVerifyLenDist(in_data, i, dist, leng);\n            ZopfliStoreLitLenDist(leng, dist, i, store);\n        } else {\n            leng = 1;\n            ZopfliStoreLitLenDist(in_data[i] as u16, 0, i, store);\n        }\n\n        j = 1;\n        while j < leng {\n            assert!(i < inend);\n            i += 1;\n            ZopfliUpdateHash(in_data, i, inend, h);\n            j += 1;\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "lz77.rs",
        "error": "",
        "dependent": [
            "GetLengthScore",
            "ZopfliBlockState",
            "ZopfliFindLongestMatch",
            "ZopfliHash",
            "ZopfliLZ77Store",
            "ZopfliResetHash",
            "ZopfliStoreLitLenDist",
            "ZopfliUpdateHash",
            "ZopfliVerifyLenDist",
            "ZopfliWarmupHash"
        ],
        "header": "void ZopfliLZ77Greedy(ZopfliBlockState *s, const unsigned char *in, size_t instart, size_t inend, ZopfliLZ77Store *store, ZopfliHash *h)",
        "params": [
            "ZopfliBlockState *s",
            "const unsigned char *in",
            "size_t instart",
            "size_t inend",
            "ZopfliLZ77Store *store",
            "ZopfliHash *h"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "s",
            "in",
            "instart",
            "inend",
            "store",
            "h",
            "i",
            "j",
            "leng",
            "dist",
            "lengthscore",
            "windowstart",
            "dummysublen",
            "prev_length",
            "prev_match",
            "prevlengthscore",
            "match_available"
        ],
        "calle": [
            "ZopfliVerifyLenDist",
            "ZopfliWarmupHash",
            "GetLengthScore",
            "ZopfliFindLongestMatch",
            "ZopfliUpdateHash",
            "ZopfliStoreLitLenDist",
            "ZopfliResetHash",
            "assert"
        ],
        "calle_c": [
            "assert"
        ],
        "key": "ZopfliLZ77Greedy",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "GetBestLengths": {
        "source_code": "static double GetBestLengths(ZopfliBlockState *s, const unsigned char *in, size_t instart, size_t inend, CostModelFun *costmodel, void *costcontext, unsigned short *length_array, ZopfliHash *h, float *costs)\n{\n  size_t blocksize = inend - instart;\n  size_t i = 0;\n  size_t k;\n  size_t kend;\n  unsigned short leng;\n  unsigned short dist;\n  unsigned short sublen[259];\n  size_t windowstart = (instart > 32768) ? (instart - 32768) : (0);\n  double result;\n  double mincost = GetCostModelMinCost(costmodel, costcontext);\n  double mincostaddcostj;\n  if (instart == inend)\n  {\n    return 0;\n  }\n  ZopfliResetHash(32768, h);\n  ZopfliWarmupHash(in, windowstart, inend, h);\n  for (i = windowstart; i < instart; i += 1)\n  {\n    ZopfliUpdateHash(in, i, inend, h);\n  }\n\n  for (i = 1; i < (blocksize + 1); i += 1)\n  {\n    costs[i] = 1e30;\n  }\n\n  costs[0] = 0;\n  length_array[0] = 0;\n  for (i = instart; i < inend; i += 1)\n  {\n    size_t j = i - instart;\n    ZopfliUpdateHash(in, i, inend, h);\n    if ((((h->same[i & (32768 - 1)] > (258 * 2)) && (i > ((instart + 258) + 1))) && (((i + (258 * 2)) + 1) < inend)) && (h->same[(i - 258) & (32768 - 1)] > 258))\n    {\n      double symbolcost = costmodel(258, 1, costcontext);\n      for (k = 0; k < 258; k += 1)\n      {\n        costs[j + 258] = costs[j] + symbolcost;\n        length_array[j + 258] = 258;\n        i += 1;\n        j += 1;\n        ZopfliUpdateHash(in, i, inend, h);\n      }\n\n    }\n    ZopfliFindLongestMatch(s, h, in, i, inend, 258, sublen, &dist, &leng);\n    if ((i + 1) <= inend)\n    {\n      double newCost = costmodel(in[i], 0, costcontext) + costs[j];\n      assert(newCost >= 0);\n      if (newCost < costs[j + 1])\n      {\n        costs[j + 1] = newCost;\n        length_array[j + 1] = 1;\n      }\n    }\n    kend = zopfli_min(leng, inend - i);\n    mincostaddcostj = mincost + costs[j];\n    for (k = 3; k <= kend; k += 1)\n    {\n      double newCost;\n      if (costs[j + k] <= mincostaddcostj)\n      {\n        continue;\n      }\n      newCost = costmodel(k, sublen[k], costcontext) + costs[j];\n      assert(newCost >= 0);\n      if (newCost < costs[j + k])\n      {\n        assert(k <= 258);\n        costs[j + k] = newCost;\n        length_array[j + k] = k;\n      }\n    }\n\n  }\n\n  assert(costs[blocksize] >= 0);\n  result = costs[blocksize];\n  return result;\n}\n\n",
        "translated_code": "pub fn GetBestLengths(\n    s: &mut ZopfliBlockState,\n    in_data: &[u8],\n    instart: usize,\n    inend: usize,\n    costmodel: CostModelFun,\n    costcontext: Option<Box<dyn std::any::Any>>,\n    length_array: &mut [u16],\n    h: &mut ZopfliHash,\n    costs: &mut [f64],\n) -> f64 {\n    let blocksize = inend - instart;\n    let windowstart = if instart > 32768 {\n        instart - 32768\n    } else {\n        0\n    };\n\n    if instart == inend {\n        return 0.0;\n    }\n\n    ZopfliResetHash(32768, h);\n    ZopfliWarmupHash(in_data, windowstart, inend, h);\n    for i in (windowstart..instart).step_by(1) {\n        ZopfliUpdateHash(in_data, i, inend, h);\n    }\n\n    for i in 1..(blocksize + 1) {\n        costs[i] = 1e30;\n    }\n\n    costs[0] = 0.0;\n    length_array[0] = 0;\n\n    let mincost = GetCostModelMinCost(costmodel, costcontext);\n\n    for i in instart..inend {\n        let j = i - instart;\n        ZopfliUpdateHash(in_data, i, inend, h);\n\n        if h.same.as_ref().unwrap()[i & (32768 - 1)] > (258 * 2)\n            && i > (instart + 258 + 1)\n            && (i + (258 * 2) + 1 < inend)\n            && h.same.as_ref().unwrap()[(i - 258) & (32768 - 1)] > 258\n        {\n            let symbolcost = costmodel(258, 1, Option::None);\n            for k in 0..258 {\n                costs[j + 258] = costs[j] + symbolcost;\n                length_array[j + 258] = 258;\n                ZopfliUpdateHash(in_data, i + k + 1, inend, h);\n            }\n        }\n\n        let mut leng = 0;\n        let mut dist = 0;\n        let mut sublen = [0u16; 259];\n        ZopfliFindLongestMatch(\n            s,\n            h,\n            in_data,\n            i,\n            inend,\n            258,\n            &mut Some(&mut sublen),\n            &mut dist,\n            &mut leng,\n        );\n\n        if (i + 1) <= inend {\n            let newCost = costmodel(in_data[i] as u32, 0, Option::None) + costs[j];\n            assert!(newCost >= 0.0);\n            if newCost < costs[j + 1] {\n                costs[j + 1] = newCost;\n                length_array[j + 1] = 1;\n            }\n        }\n\n        let kend = zopfli_min(leng as usize, inend - i);\n        let mincostaddcostj = mincost + costs[j];\n\n        for k in 3..=kend {\n            if costs[j + k] <= mincostaddcostj {\n                continue;\n            }\n            let newCost = costmodel(k as u32, sublen[k] as u32, Option::None) + costs[j];\n            assert!(newCost >= 0.0);\n            if newCost < costs[j + k] {\n                assert!(k <= 258);\n                costs[j + k] = newCost;\n                length_array[j + k] = k as u16;\n            }\n        }\n    }\n\n    assert!(costs[blocksize] >= 0.0);\n    costs[blocksize]\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [
            "CostModelFun",
            "GetCostModelMinCost",
            "ZopfliBlockState",
            "ZopfliFindLongestMatch",
            "ZopfliHash",
            "ZopfliResetHash",
            "ZopfliUpdateHash",
            "ZopfliWarmupHash",
            "zopfli_min"
        ],
        "params": [
            "ZopfliBlockState *s",
            "const unsigned char *in",
            "size_t instart",
            "size_t inend",
            "CostModelFun *costmodel",
            "void *costcontext",
            "unsigned short *length_array",
            "ZopfliHash *h",
            "float *costs"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "s",
            "in",
            "instart",
            "inend",
            "costmodel",
            "costcontext",
            "length_array",
            "h",
            "costs",
            "blocksize",
            "i",
            "k",
            "kend",
            "leng",
            "dist",
            "sublen",
            "windowstart",
            "result",
            "mincost",
            "mincostaddcostj",
            "j",
            "symbolcost",
            "newCost"
        ],
        "calle": [
            "costmodel",
            "ZopfliWarmupHash",
            "GetCostModelMinCost",
            "zopfli_min",
            "ZopfliFindLongestMatch",
            "ZopfliUpdateHash",
            "ZopfliResetHash",
            "assert"
        ],
        "calle_c": [
            "costmodel",
            "assert"
        ],
        "key": "GetBestLengths",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "FollowPath": {
        "source_code": "static void FollowPath(ZopfliBlockState *s, const unsigned char *in, size_t instart, size_t inend, unsigned short *path, size_t pathsize, ZopfliLZ77Store *store, ZopfliHash *h)\n{\n  size_t i;\n  size_t j;\n  size_t pos = 0;\n  size_t windowstart = (instart > 32768) ? (instart - 32768) : (0);\n  size_t total_length_test = 0;\n  if (instart == inend)\n  {\n    return;\n  }\n  ZopfliResetHash(32768, h);\n  ZopfliWarmupHash(in, windowstart, inend, h);\n  for (i = windowstart; i < instart; i += 1)\n  {\n    ZopfliUpdateHash(in, i, inend, h);\n  }\n\n  pos = instart;\n  for (i = 0; i < pathsize; i += 1)\n  {\n    unsigned short length = path[i];\n    unsigned short dummy_length;\n    unsigned short dist;\n    assert(pos < inend);\n    ZopfliUpdateHash(in, pos, inend, h);\n    if (length >= 3)\n    {\n      ZopfliFindLongestMatch(s, h, in, pos, inend, length, 0, &dist, &dummy_length);\n      assert(!(((dummy_length != length) && (length > 2)) && (dummy_length > 2)));\n      ZopfliVerifyLenDist(in, inend, pos, dist, length);\n      ZopfliStoreLitLenDist(length, dist, pos, store);\n      total_length_test += length;\n    }\n    else\n    {\n      length = 1;\n      ZopfliStoreLitLenDist(in[pos], 0, pos, store);\n      total_length_test += 1;\n    }\n    assert((pos + length) <= inend);\n    for (j = 1; j < length; j += 1)\n    {\n      ZopfliUpdateHash(in, pos + j, inend, h);\n    }\n\n    pos += length;\n  }\n\n}\n\n",
        "translated_code": "pub fn FollowPath(\n    s: &mut ZopfliBlockState,\n    in_data: &[u8],\n    instart: usize,\n    inend: usize,\n    path: &[u16],\n    pathsize: usize,\n    store: &mut ZopfliLz77Store,\n    h: &mut ZopfliHash,\n) {\n    let mut pos;\n    let windowstart = if instart > 32768 {\n        instart - 32768\n    } else {\n        0\n    };\n    let mut total_length_test = 0;\n\n    if instart == inend {\n        return;\n    }\n\n    ZopfliResetHash(32768, h);\n    ZopfliWarmupHash(in_data, windowstart, inend, h);\n    \n    for i in (windowstart..instart).step_by(1) {\n        ZopfliUpdateHash(in_data, i, inend, h);\n    }\n\n    pos = instart;\n    for i in 0..pathsize {\n        let mut length = path[i];\n        let mut dummy_length = 0;\n        let mut dist = 0;\n        \n        assert!(pos < inend);\n        ZopfliUpdateHash(in_data, pos, inend, h);\n        \n        if length >= 3 {\n            ZopfliFindLongestMatch(\n                s,\n                h,\n                in_data,\n                pos,\n                inend,\n                length as usize,\n                &mut Option::None,\n                &mut dist,\n                &mut dummy_length,\n            );\n            assert!(!((dummy_length != length) && (length > 2) && (dummy_length > 2)));\n            ZopfliVerifyLenDist(in_data, pos, dist, length);\n            ZopfliStoreLitLenDist(length, dist, pos, store);\n            total_length_test += length as usize;\n        } else {\n            length = 1;\n            ZopfliStoreLitLenDist(in_data[pos] as u16, 0, pos, store);\n            total_length_test += 1;\n        }\n        \n        assert!((pos + length as usize) <= inend);\n        for j in 1..length {\n            ZopfliUpdateHash(in_data, pos + j as usize, inend, h);\n        }\n        \n        pos += length as usize;\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [
            "ZopfliBlockState",
            "ZopfliFindLongestMatch",
            "ZopfliHash",
            "ZopfliLZ77Store",
            "ZopfliResetHash",
            "ZopfliStoreLitLenDist",
            "ZopfliUpdateHash",
            "ZopfliVerifyLenDist",
            "ZopfliWarmupHash"
        ],
        "params": [
            "ZopfliBlockState *s",
            "const unsigned char *in",
            "size_t instart",
            "size_t inend",
            "unsigned short *path",
            "size_t pathsize",
            "ZopfliLZ77Store *store",
            "ZopfliHash *h"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "s",
            "in",
            "instart",
            "inend",
            "path",
            "pathsize",
            "store",
            "h",
            "i",
            "j",
            "pos",
            "windowstart",
            "total_length_test",
            "length",
            "dummy_length",
            "dist"
        ],
        "calle": [
            "ZopfliVerifyLenDist",
            "ZopfliWarmupHash",
            "ZopfliFindLongestMatch",
            "ZopfliUpdateHash",
            "ZopfliStoreLitLenDist",
            "ZopfliResetHash",
            "assert"
        ],
        "calle_c": [
            "assert"
        ],
        "key": "FollowPath",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "LZ77OptimalRun": {
        "source_code": "static double LZ77OptimalRun(ZopfliBlockState *s, const unsigned char *in, size_t instart, size_t inend, unsigned short **path, size_t *pathsize, unsigned short *length_array, CostModelFun *costmodel, void *costcontext, ZopfliLZ77Store *store, ZopfliHash *h, float *costs)\n{\n  double cost = GetBestLengths(s, in, instart, inend, costmodel, costcontext, length_array, h, costs);\n  free(*path);\n  *path = 0;\n  *pathsize = 0;\n  TraceBackwards(inend - instart, length_array, path, pathsize);\n  FollowPath(s, in, instart, inend, *path, *pathsize, store, h);\n  assert(cost < 1e30);\n  return cost;\n}\n\n",
        "translated_code": "use rand::Rng;\n\npub fn LZ77OptimalRun(\n    s: &mut ZopfliBlockState,\n    in_data: &[u8],\n    instart: usize,\n    inend: usize,\n    path: &mut Option<Vec<u16>>,\n    pathsize: &mut usize,\n    length_array: &mut [u16],\n    costmodel: CostModelFun,\n    costcontext: Option<Box<dyn std::any::Any>>,\n    store: &mut ZopfliLz77Store,\n    h: &mut ZopfliHash,\n    costs: &mut [f64],\n) -> f64 {\n    let cost = GetBestLengths(\n        s,\n        in_data,\n        instart,\n        inend,\n        costmodel,\n        costcontext,\n        length_array,\n        h,\n        costs,\n    );\n\n    // Free the path by setting it to None (equivalent to C's free and setting to NULL)\n    *path = None;\n    *pathsize = 0;\n\n    TraceBackwards(inend - instart, length_array, path, pathsize);\n\n    if let Some(path_vec) = path {\n        FollowPath(\n            s,\n            in_data,\n            instart,\n            inend,\n            path_vec,\n            *pathsize,\n            store,\n            h,\n        );\n    }\n\n    assert!(cost < 1e30, \"Cost must be less than 1e30\");\n    cost\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [
            "CostModelFun",
            "FollowPath",
            "GetBestLengths",
            "TraceBackwards",
            "ZopfliBlockState",
            "ZopfliHash",
            "ZopfliLZ77Store"
        ],
        "params": [
            "ZopfliBlockState *s",
            "const unsigned char *in",
            "size_t instart",
            "size_t inend",
            "unsigned short **path",
            "size_t *pathsize",
            "unsigned short *length_array",
            "CostModelFun *costmodel",
            "void *costcontext",
            "ZopfliLZ77Store *store",
            "ZopfliHash *h",
            "float *costs"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "s",
            "in",
            "instart",
            "inend",
            "path",
            "pathsize",
            "length_array",
            "costmodel",
            "costcontext",
            "store",
            "h",
            "costs",
            "cost"
        ],
        "calle": [
            "free",
            "GetBestLengths",
            "FollowPath",
            "assert",
            "TraceBackwards"
        ],
        "calle_c": [
            "free",
            "assert"
        ],
        "key": "LZ77OptimalRun",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliLZ77Optimal": {
        "source_code": "void ZopfliLZ77Optimal(ZopfliBlockState *s, const unsigned char *in, size_t instart, size_t inend, int numiterations, ZopfliLZ77Store *store)\n{\n  size_t blocksize = inend - instart;\n  unsigned short *length_array = (unsigned short *) malloc((sizeof(unsigned short)) * (blocksize + 1));\n  unsigned short *path = 0;\n  size_t pathsize = 0;\n  ZopfliLZ77Store currentstore;\n  ZopfliHash hash;\n  ZopfliHash *h = &hash;\n  SymbolStats stats;\n  SymbolStats beststats;\n  SymbolStats laststats;\n  int i;\n  float *costs = (float *) malloc((sizeof(float)) * (blocksize + 1));\n  double cost;\n  double bestcost = 1e30;\n  double lastcost = 0;\n  RanState ran_state;\n  int lastrandomstep = -1;\n  if (!costs)\n  {\n    exit(-1);\n  }\n  if (!length_array)\n  {\n    exit(-1);\n  }\n  InitRanState(&ran_state);\n  InitStats(&stats);\n  ZopfliInitLZ77Store(in, &currentstore);\n  ZopfliAllocHash(32768, h);\n  ZopfliLZ77Greedy(s, in, instart, inend, &currentstore, h);\n  GetStatistics(&currentstore, &stats);\n  for (i = 0; i < numiterations; i += 1)\n  {\n    ZopfliCleanLZ77Store(&currentstore);\n    ZopfliInitLZ77Store(in, &currentstore);\n    LZ77OptimalRun(s, in, instart, inend, &path, &pathsize, length_array, GetCostStat, (void *) (&stats), &currentstore, h, costs);\n    cost = ZopfliCalculateBlockSize(&currentstore, 0, currentstore.size, 2);\n    if (s->options->verbose_more || (s->options->verbose && (cost < bestcost)))\n    {\n      fprintf(stderr, \"Iteration %d: %d bit\\n\", i, (int) cost);\n    }\n    if (cost < bestcost)\n    {\n      ZopfliCopyLZ77Store(&currentstore, store);\n      CopyStats(&stats, &beststats);\n      bestcost = cost;\n    }\n    CopyStats(&stats, &laststats);\n    ClearStatFreqs(&stats);\n    GetStatistics(&currentstore, &stats);\n    if (lastrandomstep != (-1))\n    {\n      AddWeighedStatFreqs(&stats, 1.0, &laststats, 0.5, &stats);\n      CalculateStatistics(&stats);\n    }\n    if ((i > 5) && (cost == lastcost))\n    {\n      CopyStats(&beststats, &stats);\n      RandomizeStatFreqs(&ran_state, &stats);\n      CalculateStatistics(&stats);\n      lastrandomstep = i;\n    }\n    lastcost = cost;\n  }\n\n  free(length_array);\n  free(path);\n  free(costs);\n  ZopfliCleanLZ77Store(&currentstore);\n  ZopfliCleanHash(h);\n}\n\n",
        "translated_code": "pub fn ZopfliLZ77Optimal(\n    s: &mut ZopfliBlockState,\n    in_data: &[u8],\n    instart: usize,\n    inend: usize,\n    numiterations: i32,\n    store: &mut ZopfliLz77Store,\n) {\n    let blocksize = inend - instart;\n    let mut length_array = vec![0u16; blocksize + 1];\n    let mut path: Option<Vec<u16>> = None;\n    let mut pathsize = 0;\n    let mut currentstore = ZopfliLz77Store {\n        litlens: None,\n        dists: None,\n        size: 0,\n        data: None,\n        pos: None,\n        ll_symbol: None,\n        d_symbol: None,\n        ll_counts: None,\n        d_counts: None,\n    };\n    let mut hash = ZopfliHash {\n        head: None,\n        prev: None,\n        hashval: None,\n        val: 0,\n        head2: None,\n        prev2: None,\n        hashval2: None,\n        val2: 0,\n        same: None,\n    };\n    let h = &mut hash;\n    let mut stats = SymbolStats {\n        litlens: [0; 288],\n        dists: [0; 32],\n        ll_symbols: [0.0; 288],\n        d_symbols: [0.0; 32],\n    };\n    let mut beststats = stats.clone();\n    let mut laststats = stats.clone();\n    let mut costs = vec![0.0f64; blocksize + 1];\n    let mut cost;\n    let mut bestcost = 1e30;\n    let mut lastcost = 0.0;\n    let mut ran_state = RanState { m_w: 0, m_z: 0 };\n    let mut lastrandomstep = -1;\n\n    InitRanState(&mut ran_state);\n    InitStats(&mut stats);\n    ZopfliInitLZ77Store(Some(in_data), &mut currentstore);\n    ZopfliAllocHash(32768, h);\n    ZopfliLZ77Greedy(s, in_data, instart, inend, &mut currentstore, h);\n    GetStatistics(&currentstore, &mut stats);\n\n    for i in 0..numiterations {\n        ZopfliCleanLZ77Store(&mut currentstore);\n        ZopfliInitLZ77Store(Some(in_data), &mut currentstore);\n        \n        LZ77OptimalRun(\n            s,\n            in_data,\n            instart,\n            inend,\n            &mut path,\n            &mut pathsize,\n            &mut length_array,\n            |litlen, dist, context| {\n                let stats = context.as_ref().and_then(|c| c.downcast_ref::<SymbolStats>());\n                GetCostStat(litlen as usize, dist as usize, stats)\n                    .unwrap_or(0.0)\n            },\n            Some(Box::new(stats.clone())),\n            &mut currentstore,\n            h,\n            &mut costs,\n        );\n        cost = ZopfliCalculateBlockSize(&currentstore, 0, currentstore.size, 2);\n\n        if s.options.as_ref().map_or(false, |o| o.verbose_more != 0)\n            || (s.options.as_ref().map_or(false, |o| o.verbose != 0) && (cost < bestcost))\n        {\n            eprintln!(\"Iteration {}: {} bit\", i, cost as i32);\n        }\n\n        if cost < bestcost {\n            ZopfliCopyLZ77Store(&currentstore, store);\n            CopyStats(&stats, &mut beststats);\n            bestcost = cost;\n        }\n\n        CopyStats(&stats, &mut laststats);\n        ClearStatFreqs(&mut stats);\n        GetStatistics(&currentstore, &mut stats);\n\n        if lastrandomstep != -1 {\n            let mut temp_stats = stats.clone();\n            AddWeighedStatFreqs(&stats, 1.0, &laststats, 0.5, &mut temp_stats);\n            stats = temp_stats;\n            CalculateStatistics(&mut stats);\n        }\n\n        if i > 5 && cost == lastcost {\n            CopyStats(&beststats, &mut stats);\n            RandomizeStatFreqs(&mut ran_state, &mut stats);\n            CalculateStatistics(&mut stats);\n            lastrandomstep = i;\n        }\n\n        lastcost = cost;\n    }\n\n    ZopfliCleanLZ77Store(&mut currentstore);\n    ZopfliCleanHash(h);\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [
            "AddWeighedStatFreqs",
            "CalculateStatistics",
            "ClearStatFreqs",
            "CopyStats",
            "GetCostStat",
            "GetStatistics",
            "InitRanState",
            "InitStats",
            "LZ77OptimalRun",
            "RanState",
            "RandomizeStatFreqs",
            "SymbolStats",
            "ZopfliAllocHash",
            "ZopfliBlockState",
            "ZopfliCalculateBlockSize",
            "ZopfliCleanHash",
            "ZopfliCleanLZ77Store",
            "ZopfliCopyLZ77Store",
            "ZopfliHash",
            "ZopfliInitLZ77Store",
            "ZopfliLZ77Greedy",
            "ZopfliLZ77Store"
        ],
        "header": "void ZopfliLZ77Optimal(ZopfliBlockState *s, const unsigned char *in, size_t instart, size_t inend, int numiterations, ZopfliLZ77Store *store)",
        "params": [
            "ZopfliBlockState *s",
            "const unsigned char *in",
            "size_t instart",
            "size_t inend",
            "int numiterations",
            "ZopfliLZ77Store *store"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "s",
            "in",
            "instart",
            "inend",
            "numiterations",
            "store",
            "blocksize",
            "length_array",
            "path",
            "pathsize",
            "currentstore",
            "hash",
            "h",
            "stats",
            "beststats",
            "laststats",
            "i",
            "costs",
            "cost",
            "bestcost",
            "lastcost",
            "ran_state",
            "lastrandomstep"
        ],
        "calle": [
            "free",
            "GetStatistics",
            "RandomizeStatFreqs",
            "fprintf",
            "exit",
            "InitRanState",
            "ZopfliCleanHash",
            "ZopfliLZ77Greedy",
            "InitStats",
            "CopyStats",
            "CalculateStatistics",
            "LZ77OptimalRun",
            "GetCostStat",
            "ZopfliInitLZ77Store",
            "malloc",
            "AddWeighedStatFreqs",
            "ZopfliAllocHash",
            "ZopfliCalculateBlockSize",
            "ClearStatFreqs",
            "ZopfliCleanLZ77Store",
            "ZopfliCopyLZ77Store"
        ],
        "calle_c": [
            "fprintf",
            "free",
            "exit",
            "malloc"
        ],
        "key": "ZopfliLZ77Optimal",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliBlockSplitLZ77": {
        "source_code": "void ZopfliBlockSplitLZ77(const ZopfliOptions *options, const ZopfliLZ77Store *lz77, size_t maxblocks, size_t **splitpoints, size_t *npoints)\n{\n  size_t lstart;\n  size_t lend;\n  size_t i;\n  size_t llpos = 0;\n  size_t numblocks = 1;\n  unsigned char *done;\n  double splitcost;\n  double origcost;\n  if (lz77->size < 10)\n  {\n    return;\n  }\n  done = (unsigned char *) malloc(lz77->size);\n  if (!done)\n  {\n    exit(-1);\n  }\n  for (i = 0; i < lz77->size; i += 1)\n  {\n    done[i] = 0;\n  }\n\n  lstart = 0;\n  lend = lz77->size;\n  for (;;)\n  {\n    SplitCostContext c;\n    if ((maxblocks > 0) && (numblocks >= maxblocks))\n    {\n      break;\n    }\n    c.lz77 = lz77;\n    c.start = lstart;\n    c.end = lend;\n    assert(lstart < lend);\n    llpos = FindMinimum(SplitCost, &c, lstart + 1, lend, &splitcost);\n    assert(llpos > lstart);\n    assert(llpos < lend);\n    origcost = EstimateCost(lz77, lstart, lend);\n    if (((splitcost > origcost) || (llpos == (lstart + 1))) || (llpos == lend))\n    {\n      done[lstart] = 1;\n    }\n    else\n    {\n      AddSorted(llpos, splitpoints, npoints);\n      numblocks += 1;\n    }\n    if (!FindLargestSplittableBlock(lz77->size, done, *splitpoints, *npoints, &lstart, &lend))\n    {\n      break;\n    }\n    if ((lend - lstart) < 10)\n    {\n      break;\n    }\n  }\n\n  if (options->verbose)\n  {\n    PrintBlockSplitPoints(lz77, *splitpoints, *npoints);\n  }\n  free(done);\n}\n\n",
        "translated_code": "pub fn ZopfliBlockSplitLZ77(\n    options: &ZopfliOptions,\n    lz77: &ZopfliLz77Store,\n    maxblocks: usize,\n    splitpoints: &mut Option<Vec<usize>>,\n    npoints: &mut usize,\n) {\n    if lz77.size < 10 {\n        return;\n    }\n\n    let mut done = vec![0u8; lz77.size];\n    let mut numblocks = 1;\n    let mut lstart = 0;\n    let mut lend = lz77.size;\n\n    // Wrapper function to match FindMinimum's expected signature\n    fn split_cost_wrapper(i: usize, context: Option<Box<dyn std::any::Any>>) -> f64 {\n        if let Some(boxed_context) = context {\n            if let Ok(context_ref) = boxed_context.downcast::<SplitCostContext>() {\n                return SplitCost(i, &context_ref);\n            }\n        }\n        f64::MAX // Return a large value if context is invalid\n    }\n\n    loop {\n        if maxblocks > 0 && numblocks >= maxblocks {\n            break;\n        }\n\n        assert!(lstart < lend);\n        \n        let mut splitcost = 0.0;\n        let c = SplitCostContext {\n            lz77: Some(lz77.clone()),\n            start: lstart,\n            end: lend,\n        };\n        \n        let llpos = FindMinimum(\n            split_cost_wrapper,\n            Some(Box::new(c)),\n            lstart + 1,\n            lend,\n            &mut splitcost,\n        );\n        \n        assert!(llpos > lstart);\n        assert!(llpos < lend);\n        \n        let origcost = EstimateCost(lz77, lstart, lend);\n        \n        if splitcost > origcost || llpos == lstart + 1 || llpos == lend {\n            done[lstart] = 1;\n        } else {\n            AddSorted(llpos, splitpoints, npoints);\n            numblocks += 1;\n        }\n\n        let splitpoints_ref = splitpoints.as_ref().map(|v| v.as_slice()).unwrap_or(&[]);\n        if !FindLargestSplittableBlock(\n            lz77.size,\n            &done,\n            splitpoints_ref,\n            *npoints,\n            &mut lstart,\n            &mut lend,\n        ) {\n            break;\n        }\n\n        if lend - lstart < 10 {\n            break;\n        }\n    }\n\n    if options.verbose != 0 {\n        let splitpoints_ref = splitpoints.as_ref().map(|v| v.as_slice()).unwrap_or(&[]);\n        PrintBlockSplitPoints(lz77, splitpoints_ref, *npoints);\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "blocksplitter.rs",
        "error": "",
        "dependent": [
            "AddSorted",
            "EstimateCost",
            "FindLargestSplittableBlock",
            "FindMinimum",
            "PrintBlockSplitPoints",
            "SplitCost",
            "SplitCostContext",
            "ZopfliLZ77Store",
            "ZopfliOptions"
        ],
        "header": "void ZopfliBlockSplitLZ77(const ZopfliOptions *options, const ZopfliLZ77Store *lz77, size_t maxblocks, size_t **splitpoints, size_t *npoints)",
        "params": [
            "const ZopfliOptions *options",
            "const ZopfliLZ77Store *lz77",
            "size_t maxblocks",
            "size_t **splitpoints",
            "size_t *npoints"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "lz77",
            "maxblocks",
            "splitpoints",
            "npoints",
            "lstart",
            "lend",
            "i",
            "llpos",
            "numblocks",
            "done",
            "done_idx",
            "splitcost",
            "origcost",
            "c"
        ],
        "calle": [
            "EstimateCost",
            "PrintBlockSplitPoints",
            "FindLargestSplittableBlock",
            "free",
            "exit",
            "AddSorted",
            "SplitCost",
            "FindMinimum",
            "malloc",
            "assert"
        ],
        "calle_c": [
            "free",
            "assert",
            "exit",
            "malloc"
        ],
        "key": "ZopfliBlockSplitLZ77",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "ZopfliInitBlockState": {
        "source_code": "void ZopfliInitBlockState(const ZopfliOptions *options, size_t blockstart, size_t blockend, int add_lmc, ZopfliBlockState *s)\n{\n  s->options = options;\n  s->blockstart = blockstart;\n  s->blockend = blockend;\n  if (add_lmc)\n  {\n    s->lmc = (ZopfliLongestMatchCache *) malloc(sizeof(ZopfliLongestMatchCache));\n    ZopfliInitCache(blockend - blockstart, s->lmc);\n  }\n  else\n  {\n    s->lmc = 0;\n  }\n}\n\n",
        "translated_code": "use std::boxed::Box;\n\npub fn ZopfliInitBlockState(\n    options: Option<Box<ZopfliOptions>>,\n    blockstart: usize,\n    blockend: usize,\n    add_lmc: bool,\n    s: &mut ZopfliBlockState,\n) {\n    s.options = options;\n    s.blockstart = blockstart;\n    s.blockend = blockend;\n    \n    if add_lmc {\n        let mut lmc = Box::new(ZopfliLongestMatchCache {\n            length: None,\n            dist: None,\n            sublen: None,\n        });\n        ZopfliInitCache(blockend - blockstart, &mut lmc);\n        s.lmc = Some(lmc);\n    } else {\n        s.lmc = None;\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "lz77.rs",
        "error": "",
        "dependent": [
            "ZopfliBlockState",
            "ZopfliInitCache",
            "ZopfliOptions"
        ],
        "header": "void ZopfliInitBlockState(const ZopfliOptions *options, size_t blockstart, size_t blockend, int add_lmc, ZopfliBlockState *s)",
        "params": [
            "const ZopfliOptions *options",
            "size_t blockstart",
            "size_t blockend",
            "int add_lmc",
            "ZopfliBlockState *s"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "blockstart",
            "blockend",
            "add_lmc",
            "s"
        ],
        "calle": [
            "ZopfliInitCache",
            "malloc"
        ],
        "calle_c": [
            "malloc"
        ],
        "key": "ZopfliInitBlockState",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliCleanBlockState": {
        "source_code": "void ZopfliCleanBlockState(ZopfliBlockState *s)\n{\n  if (s->lmc)\n  {\n    ZopfliCleanCache(s->lmc);\n    free(s->lmc);\n  }\n}\n\n",
        "translated_code": "pub fn ZopfliCleanBlockState(s: &mut ZopfliBlockState) {\n    if let Some(mut lmc) = s.lmc.take() {\n        ZopfliCleanCache(&mut *lmc);\n        // The Box will be automatically dropped here, freeing the memory\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "lz77.rs",
        "error": "",
        "dependent": [
            "ZopfliBlockState",
            "ZopfliCleanCache"
        ],
        "header": "void ZopfliCleanBlockState(ZopfliBlockState *s)",
        "params": [
            "ZopfliBlockState *s"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "s"
        ],
        "calle": [
            "free",
            "ZopfliCleanCache"
        ],
        "calle_c": [
            "free"
        ],
        "key": "ZopfliCleanBlockState",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliBlockSplit": {
        "source_code": "void ZopfliBlockSplit(const ZopfliOptions *options, const unsigned char *in, size_t instart, size_t inend, size_t maxblocks, size_t **splitpoints, size_t *npoints)\n{\n  size_t pos = 0;\n  size_t i;\n  ZopfliBlockState s;\n  size_t *lz77splitpoints = 0;\n  size_t nlz77points = 0;\n  ZopfliLZ77Store store;\n  ZopfliHash hash;\n  ZopfliHash *h = &hash;\n  ZopfliInitLZ77Store(in, &store);\n  ZopfliInitBlockState(options, instart, inend, 0, &s);\n  ZopfliAllocHash(32768, h);\n  *npoints = 0;\n  *splitpoints = 0;\n  ZopfliLZ77Greedy(&s, in, instart, inend, &store, h);\n  ZopfliBlockSplitLZ77(options, &store, maxblocks, &lz77splitpoints, &nlz77points);\n  pos = instart;\n  if (nlz77points > 0)\n  {\n    for (i = 0; i < store.size; i += 1)\n    {\n      size_t length = (store.dists[i] == 0) ? (1) : (store.litlens[i]);\n      if (lz77splitpoints[*npoints] == i)\n      {\n        {\n          if (!((*npoints) & ((*npoints) - 1)))\n          {\n            *splitpoints = ((*npoints) == 0) ? (malloc(sizeof(*(*splitpoints)))) : (realloc(*splitpoints, ((*npoints) * 2) * (sizeof(*(*splitpoints)))));\n          }\n          (*splitpoints)[*npoints] = pos;\n          *npoints += 1;\n        }\n        ;\n        if ((*npoints) == nlz77points)\n        {\n          break;\n        }\n      }\n      pos += length;\n    }\n\n  }\n  assert((*npoints) == nlz77points);\n  free(lz77splitpoints);\n  ZopfliCleanBlockState(&s);\n  ZopfliCleanLZ77Store(&store);\n  ZopfliCleanHash(h);\n}\n\n",
        "translated_code": "pub fn ZopfliBlockSplit(\n    options: &ZopfliOptions,\n    in_data: &[u8],\n    instart: usize,\n    inend: usize,\n    maxblocks: usize,\n    splitpoints: &mut Option<Vec<usize>>,\n    npoints: &mut usize,\n) {\n    let mut pos = instart;\n    let mut s = ZopfliBlockState {\n        options: None,\n        lmc: None,\n        blockstart: 0,\n        blockend: 0,\n    };\n    let mut lz77splitpoints = None;\n    let mut nlz77points = 0;\n    let mut store = ZopfliLz77Store {\n        litlens: None,\n        dists: None,\n        size: 0,\n        data: None,\n        pos: None,\n        ll_symbol: None,\n        d_symbol: None,\n        ll_counts: None,\n        d_counts: None,\n    };\n    let mut hash = ZopfliHash {\n        head: None,\n        prev: None,\n        hashval: None,\n        val: 0,\n        head2: None,\n        prev2: None,\n        hashval2: None,\n        val2: 0,\n        same: None,\n    };\n    \n    ZopfliInitLZ77Store(Some(in_data), &mut store);\n    ZopfliInitBlockState(Some(Box::new(options.clone())), instart, inend, false, &mut s);\n    ZopfliAllocHash(32768, &mut hash);\n    \n    *npoints = 0;\n    *splitpoints = None;\n    \n    ZopfliLZ77Greedy(&mut s, in_data, instart, inend, &mut store, &mut hash);\n    ZopfliBlockSplitLZ77(options, &store, maxblocks, &mut lz77splitpoints, &mut nlz77points);\n    \n    if nlz77points > 0 {\n        if let Some(lz77splitpoints) = &lz77splitpoints {\n            if let Some(store_dists) = &store.dists {\n                if let Some(store_litlens) = &store.litlens {\n                    for i in 0..store.size {\n                        let length = if store_dists[i] == 0 { 1 } else { store_litlens[i] };\n                        \n                        if lz77splitpoints[*npoints] == i {\n                            if (*npoints & (*npoints - 1)) == 0 {\n                                match splitpoints {\n                                    Some(vec) => {\n                                        let new_size = if *npoints == 0 { 1 } else { *npoints * 2 };\n                                        vec.resize(new_size, 0);\n                                    }\n                                    None => {\n                                        *splitpoints = Some(vec![0]);\n                                    }\n                                }\n                            }\n                            \n                            if let Some(sp) = splitpoints {\n                                sp[*npoints] = pos;\n                            }\n                            *npoints += 1;\n                            \n                            if *npoints == nlz77points {\n                                break;\n                            }\n                        }\n                        pos += length as usize;\n                    }\n                }\n            }\n        }\n    }\n    \n    assert!(*npoints == nlz77points);\n    \n    ZopfliCleanBlockState(&mut s);\n    ZopfliCleanLZ77Store(&mut store);\n    ZopfliCleanHash(&mut hash);\n}",
        "hint": "functions",
        "section": "src",
        "file": "blocksplitter.rs",
        "error": "",
        "dependent": [
            "ZopfliAllocHash",
            "ZopfliBlockSplitLZ77",
            "ZopfliBlockState",
            "ZopfliCleanBlockState",
            "ZopfliCleanHash",
            "ZopfliCleanLZ77Store",
            "ZopfliHash",
            "ZopfliInitBlockState",
            "ZopfliInitLZ77Store",
            "ZopfliLZ77Greedy",
            "ZopfliLZ77Store",
            "ZopfliOptions"
        ],
        "header": "void ZopfliBlockSplit(const ZopfliOptions *options, const unsigned char *in, size_t instart, size_t inend, size_t maxblocks, size_t **splitpoints, size_t *npoints)",
        "params": [
            "const ZopfliOptions *options",
            "const unsigned char *in",
            "size_t instart",
            "size_t inend",
            "size_t maxblocks",
            "size_t **splitpoints",
            "size_t *npoints"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "in",
            "instart",
            "inend",
            "maxblocks",
            "splitpoints",
            "npoints",
            "pos",
            "i",
            "s",
            "lz77splitpoints",
            "nlz77points",
            "store",
            "hash",
            "h",
            "length"
        ],
        "calle": [
            "ZopfliLZ77Greedy",
            "realloc",
            "free",
            "ZopfliCleanBlockState",
            "ZopfliBlockSplitLZ77",
            "assert",
            "ZopfliCleanLZ77Store",
            "ZopfliInitLZ77Store",
            "ZopfliCleanHash",
            "malloc",
            "ZopfliInitBlockState",
            "ZopfliAllocHash"
        ],
        "calle_c": [
            "realloc",
            "free",
            "assert",
            "malloc"
        ],
        "key": "ZopfliBlockSplit",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliAppendLZ77Store": {
        "source_code": "void ZopfliAppendLZ77Store(const ZopfliLZ77Store *store, ZopfliLZ77Store *target)\n{\n  size_t i;\n  for (i = 0; i < store->size; i += 1)\n  {\n    ZopfliStoreLitLenDist(store->litlens[i], store->dists[i], store->pos[i], target);\n  }\n\n}\n\n",
        "translated_code": "pub fn ZopfliAppendLZ77Store(store: &ZopfliLz77Store, target: &mut ZopfliLz77Store) {\n    // Assuming store.litlens, store.dists, and store.pos are all Some(Vec<_>)\n    if let (Some(litlens), Some(dists), Some(pos)) = (&store.litlens, &store.dists, &store.pos) {\n        for i in 0..store.size {\n            ZopfliStoreLitLenDist(litlens[i], dists[i], pos[i], target);\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "lz77.rs",
        "error": "",
        "dependent": [
            "ZopfliLZ77Store",
            "ZopfliStoreLitLenDist"
        ],
        "header": "void ZopfliAppendLZ77Store(const ZopfliLZ77Store *store, ZopfliLZ77Store *target)",
        "params": [
            "const ZopfliLZ77Store *store",
            "ZopfliLZ77Store *target"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "store",
            "target",
            "i"
        ],
        "calle": [
            "ZopfliStoreLitLenDist"
        ],
        "calle_c": [],
        "key": "ZopfliAppendLZ77Store",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "GetCostFixed": {
        "source_code": "static double GetCostFixed(unsigned litlen, unsigned dist, void *unused)\n{\n  (void) unused;\n  if (dist == 0)\n  {\n    if (litlen <= 143)\n    {\n      return 8;\n    }\n    else\n      return 9;\n  }\n  else\n  {\n    int dbits = ZopfliGetDistExtraBits(dist);\n    int lbits = ZopfliGetLengthExtraBits(litlen);\n    int lsym = ZopfliGetLengthSymbol(litlen);\n    int cost = 0;\n    if (lsym <= 279)\n    {\n      cost += 7;\n    }\n    else\n      cost += 8;\n    cost += 5;\n    return (cost + dbits) + lbits;\n  }\n}\n\n",
        "translated_code": "pub fn GetCostFixed(litlen: usize, dist: usize, unused: Option<&()>) -> f64 {\n    // The unused parameter is explicitly ignored in the C code, so we do the same\n    let _ = unused;\n\n    if dist == 0 {\n        if litlen <= 143 {\n            8.0\n        } else {\n            9.0\n        }\n    } else {\n        let dbits = ZopfliGetDistExtraBits(dist as i32);\n        let lbits = ZopfliGetLengthExtraBits(litlen);\n        let lsym = ZopfliGetLengthSymbol(litlen);\n        let mut cost = 0;\n\n        if lsym <= 279 {\n            cost += 7;\n        } else {\n            cost += 8;\n        }\n        cost += 5;\n\n        (cost + dbits + lbits) as f64\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [
            "ZopfliGetDistExtraBits",
            "ZopfliGetLengthExtraBits",
            "ZopfliGetLengthSymbol"
        ],
        "params": [
            "unsigned litlen",
            "unsigned dist",
            "void *unused"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "litlen",
            "dist",
            "unused",
            "dbits",
            "lbits",
            "lsym",
            "cost"
        ],
        "calle": [
            "ZopfliGetLengthSymbol",
            "ZopfliGetLengthExtraBits",
            "ZopfliGetDistExtraBits"
        ],
        "calle_c": [],
        "key": "GetCostFixed",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliLZ77OptimalFixed": {
        "source_code": "void ZopfliLZ77OptimalFixed(ZopfliBlockState *s, const unsigned char *in, size_t instart, size_t inend, ZopfliLZ77Store *store)\n{\n  size_t blocksize = inend - instart;\n  unsigned short *length_array = (unsigned short *) malloc((sizeof(unsigned short)) * (blocksize + 1));\n  unsigned short *path = 0;\n  size_t pathsize = 0;\n  ZopfliHash hash;\n  ZopfliHash *h = &hash;\n  float *costs = (float *) malloc((sizeof(float)) * (blocksize + 1));\n  if (!costs)\n  {\n    exit(-1);\n  }\n  if (!length_array)\n  {\n    exit(-1);\n  }\n  ZopfliAllocHash(32768, h);\n  s->blockstart = instart;\n  s->blockend = inend;\n  LZ77OptimalRun(s, in, instart, inend, &path, &pathsize, length_array, GetCostFixed, 0, store, h, costs);\n  free(length_array);\n  free(path);\n  free(costs);\n  ZopfliCleanHash(h);\n}\n\n",
        "translated_code": "pub fn ZopfliLZ77OptimalFixed(\n    s: &mut ZopfliBlockState,\n    in_data: &[u8],\n    instart: usize,\n    inend: usize,\n    store: &mut ZopfliLz77Store,\n) {\n    let blocksize = inend - instart;\n    \n    // Allocate length_array as a Vec<u16> (equivalent to unsigned short*)\n    let mut length_array = vec![0u16; blocksize + 1];\n    \n    // Initialize path as an Option<Vec<u16>> (None is equivalent to NULL)\n    let mut path: Option<Vec<u16>> = None;\n    let mut pathsize = 0;\n    \n    // Initialize hash and get mutable reference\n    let mut hash = ZopfliHash::default();\n    let h = &mut hash;\n    \n    // Allocate costs as a Vec<f64> to match LZ77OptimalRun's expected type\n    let mut costs = vec![0.0f64; blocksize + 1];\n    \n    // Initialize the hash\n    ZopfliAllocHash(32768, h);\n    \n    // Update block state\n    s.blockstart = instart;\n    s.blockend = inend;\n    \n    // Call LZ77OptimalRun with references to all mutable data\n    LZ77OptimalRun(\n        s,\n        in_data,\n        instart,\n        inend,\n        &mut path,\n        &mut pathsize,\n        &mut length_array,\n        |litlen, dist, unused| GetCostFixed(litlen as usize, dist as usize, None),\n        Option::None,\n        store,\n        h,\n        &mut costs,\n    );\n    \n    // No need to explicitly free memory in Rust - vectors are automatically dropped\n    ZopfliCleanHash(h);\n}\n\n// Helper implementation for default ZopfliHash\nimpl Default for ZopfliHash {\n    fn default() -> Self {\n        ZopfliHash {\n            head: None,\n            prev: None,\n            hashval: None,\n            val: 0,\n            head2: None,\n            prev2: None,\n            hashval2: None,\n            val2: 0,\n            same: None,\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "squeeze.rs",
        "error": "",
        "dependent": [
            "GetCostFixed",
            "LZ77OptimalRun",
            "ZopfliAllocHash",
            "ZopfliBlockState",
            "ZopfliCleanHash",
            "ZopfliHash",
            "ZopfliLZ77Store"
        ],
        "header": "void ZopfliLZ77OptimalFixed(ZopfliBlockState *s, const unsigned char *in, size_t instart, size_t inend, ZopfliLZ77Store *store)",
        "params": [
            "ZopfliBlockState *s",
            "const unsigned char *in",
            "size_t instart",
            "size_t inend",
            "ZopfliLZ77Store *store"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "s",
            "in",
            "instart",
            "inend",
            "store",
            "blocksize",
            "length_array",
            "path",
            "pathsize",
            "hash",
            "h",
            "costs"
        ],
        "calle": [
            "free",
            "LZ77OptimalRun",
            "exit",
            "ZopfliCleanHash",
            "malloc",
            "GetCostFixed",
            "ZopfliAllocHash"
        ],
        "calle_c": [
            "free",
            "exit",
            "malloc"
        ],
        "key": "ZopfliLZ77OptimalFixed",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "AddNonCompressedBlock": {
        "source_code": "static void AddNonCompressedBlock(const ZopfliOptions *options, int final, const unsigned char *in, size_t instart, size_t inend, unsigned char *bp, unsigned char **out, size_t *outsize)\n{\n  size_t pos = instart;\n  (void) options;\n  for (;;)\n  {\n    size_t i;\n    unsigned short blocksize = 65535;\n    unsigned short nlen;\n    int currentfinal;\n    if ((pos + blocksize) > inend)\n    {\n      blocksize = inend - pos;\n    }\n    currentfinal = (pos + blocksize) >= inend;\n    nlen = ~blocksize;\n    AddBit(final && currentfinal, bp, out, outsize);\n    AddBit(0, bp, out, outsize);\n    AddBit(0, bp, out, outsize);\n    *bp = 0;\n    {\n      if (!((*outsize) & ((*outsize) - 1)))\n      {\n        *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n      }\n      (*out)[*outsize] = blocksize % 256;\n      *outsize += 1;\n    }\n    ;\n    {\n      if (!((*outsize) & ((*outsize) - 1)))\n      {\n        *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n      }\n      (*out)[*outsize] = (blocksize / 256) % 256;\n      *outsize += 1;\n    }\n    ;\n    {\n      if (!((*outsize) & ((*outsize) - 1)))\n      {\n        *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n      }\n      (*out)[*outsize] = nlen % 256;\n      *outsize += 1;\n    }\n    ;\n    {\n      if (!((*outsize) & ((*outsize) - 1)))\n      {\n        *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n      }\n      (*out)[*outsize] = (nlen / 256) % 256;\n      *outsize += 1;\n    }\n    ;\n    for (i = 0; i < blocksize; i += 1)\n    {\n      {\n        if (!((*outsize) & ((*outsize) - 1)))\n        {\n          *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n        }\n        (*out)[*outsize] = in[pos + i];\n        *outsize += 1;\n      }\n      ;\n    }\n\n    if (currentfinal)\n    {\n      break;\n    }\n    pos += blocksize;\n  }\n\n}\n\n",
        "translated_code": "pub fn AddNonCompressedBlock(\n    options: &ZopfliOptions,\n    final_block: bool,\n    in_data: &[u8],\n    instart: usize,\n    inend: usize,\n    bp: &mut u8,\n    out: &mut Vec<u8>,\n) {\n    let mut pos = instart;\n    let _ = options; // Explicitly mark as unused\n    let mut outsize = out.len();\n\n    loop {\n        let blocksize = if pos + 65535 > inend {\n            inend - pos\n        } else {\n            65535\n        } as u16;\n\n        let currentfinal = (pos + blocksize as usize) >= inend;\n        let nlen = !blocksize;\n\n        let mut out_option = Some(out.to_vec());\n        AddBit(\n            if final_block && currentfinal { 1 } else { 0 },\n            bp,\n            &mut out_option,\n            &mut outsize,\n        );\n        AddBit(0, bp, &mut out_option, &mut outsize);\n        AddBit(0, bp, &mut out_option, &mut outsize);\n        *bp = 0;\n\n        // Write blocksize (little-endian)\n        out.push((blocksize % 256) as u8);\n        out.push((blocksize / 256) as u8);\n\n        // Write nlen (little-endian)\n        out.push((nlen % 256) as u8);\n        out.push((nlen / 256) as u8);\n\n        // Copy block data\n        let block_end = pos + blocksize as usize;\n        out.extend_from_slice(&in_data[pos..block_end]);\n\n        if currentfinal {\n            break;\n        }\n        pos += blocksize as usize;\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [
            "AddBit",
            "ZopfliOptions"
        ],
        "params": [
            "const ZopfliOptions *options",
            "int final",
            "const unsigned char *in",
            "size_t instart",
            "size_t inend",
            "unsigned char *bp",
            "unsigned char **out",
            "size_t *outsize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "final",
            "in",
            "instart",
            "inend",
            "bp",
            "out",
            "outsize",
            "pos",
            "i",
            "blocksize",
            "nlen",
            "currentfinal"
        ],
        "calle": [
            "realloc",
            "AddBit",
            "malloc"
        ],
        "calle_c": [
            "realloc",
            "malloc"
        ],
        "key": "AddNonCompressedBlock",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "AddLZ77Data": {
        "source_code": "static void AddLZ77Data(const ZopfliLZ77Store *lz77, size_t lstart, size_t lend, size_t expected_data_size, const unsigned *ll_symbols, const unsigned *ll_lengths, const unsigned *d_symbols, const unsigned *d_lengths, unsigned char *bp, unsigned char **out, size_t *outsize)\n{\n  size_t testlength = 0;\n  size_t i;\n  for (i = lstart; i < lend; i += 1)\n  {\n    unsigned dist = lz77->dists[i];\n    unsigned litlen = lz77->litlens[i];\n    if (dist == 0)\n    {\n      assert(litlen < 256);\n      assert(ll_lengths[litlen] > 0);\n      AddHuffmanBits(ll_symbols[litlen], ll_lengths[litlen], bp, out, outsize);\n      testlength += 1;\n    }\n    else\n    {\n      unsigned lls = ZopfliGetLengthSymbol(litlen);\n      unsigned ds = ZopfliGetDistSymbol(dist);\n      assert((litlen >= 3) && (litlen <= 288));\n      assert(ll_lengths[lls] > 0);\n      assert(d_lengths[ds] > 0);\n      AddHuffmanBits(ll_symbols[lls], ll_lengths[lls], bp, out, outsize);\n      AddBits(ZopfliGetLengthExtraBitsValue(litlen), ZopfliGetLengthExtraBits(litlen), bp, out, outsize);\n      AddHuffmanBits(d_symbols[ds], d_lengths[ds], bp, out, outsize);\n      AddBits(ZopfliGetDistExtraBitsValue(dist), ZopfliGetDistExtraBits(dist), bp, out, outsize);\n      testlength += litlen;\n    }\n  }\n\n  assert((expected_data_size == 0) || (testlength == expected_data_size));\n}\n\n",
        "translated_code": "pub fn AddLZ77Data(\n    lz77: &ZopfliLz77Store,\n    lstart: usize,\n    lend: usize,\n    expected_data_size: usize,\n    ll_symbols: &[u32],\n    ll_lengths: &[u32],\n    d_symbols: &[u32],\n    d_lengths: &[u32],\n    bp: &mut u8,\n    out: &mut Option<Vec<u8>>,\n    outsize: &mut usize,\n) {\n    let mut testlength = 0;\n\n    for i in lstart..lend {\n        let dist = lz77.dists.as_ref().unwrap()[i];\n        let litlen = lz77.litlens.as_ref().unwrap()[i];\n\n        if dist == 0 {\n            assert!(litlen < 256);\n            assert!(ll_lengths[litlen as usize] > 0);\n            AddHuffmanBits(\n                ll_symbols[litlen as usize],\n                ll_lengths[litlen as usize],\n                bp,\n                &mut out.as_mut().map(|v| v.clone().into_boxed_slice()),\n                outsize,\n            );\n            testlength += 1;\n        } else {\n            let lls = ZopfliGetLengthSymbol(litlen as usize) as usize;\n            let ds = ZopfliGetDistSymbol(dist as i32) as usize;\n            assert!((litlen >= 3) && (litlen <= 288));\n            assert!(ll_lengths[lls] > 0);\n            assert!(d_lengths[ds] > 0);\n            \n            AddHuffmanBits(ll_symbols[lls], ll_lengths[lls], bp, &mut out.as_mut().map(|v| v.clone().into_boxed_slice()), outsize);\n            AddBits(\n                ZopfliGetLengthExtraBitsValue(litlen as usize).try_into().unwrap(),\n                ZopfliGetLengthExtraBits(litlen as usize).try_into().unwrap(),\n                bp,\n                out,\n                outsize,\n            );\n            AddHuffmanBits(d_symbols[ds], d_lengths[ds], bp, &mut out.as_mut().map(|v| v.clone().into_boxed_slice()), outsize);\n            AddBits(\n                ZopfliGetDistExtraBitsValue(dist as i32).try_into().unwrap(),\n                ZopfliGetDistExtraBits(dist as i32).try_into().unwrap(),\n                bp,\n                out,\n                outsize,\n            );\n            testlength += litlen as usize;\n        }\n    }\n\n    assert!((expected_data_size == 0) || (testlength == expected_data_size));\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [
            "AddBits",
            "AddHuffmanBits",
            "ZopfliGetDistExtraBits",
            "ZopfliGetDistExtraBitsValue",
            "ZopfliGetDistSymbol",
            "ZopfliGetLengthExtraBits",
            "ZopfliGetLengthExtraBitsValue",
            "ZopfliGetLengthSymbol",
            "ZopfliLZ77Store"
        ],
        "params": [
            "const ZopfliLZ77Store *lz77",
            "size_t lstart",
            "size_t lend",
            "size_t expected_data_size",
            "const unsigned *ll_symbols",
            "const unsigned *ll_lengths",
            "const unsigned *d_symbols",
            "const unsigned *d_lengths",
            "unsigned char *bp",
            "unsigned char **out",
            "size_t *outsize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "lz77",
            "lstart",
            "lend",
            "expected_data_size",
            "ll_symbols",
            "ll_lengths",
            "d_symbols",
            "d_lengths",
            "bp",
            "out",
            "outsize",
            "testlength",
            "i",
            "dist",
            "litlen",
            "lls",
            "ds"
        ],
        "calle": [
            "ZopfliGetDistSymbol",
            "ZopfliGetDistExtraBitsValue",
            "ZopfliGetLengthExtraBitsValue",
            "AddHuffmanBits",
            "ZopfliGetLengthExtraBits",
            "ZopfliGetDistExtraBits",
            "ZopfliGetLengthSymbol",
            "assert",
            "AddBits"
        ],
        "calle_c": [
            "assert"
        ],
        "key": "AddLZ77Data",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "AddLZ77Block": {
        "source_code": "static void AddLZ77Block(const ZopfliOptions *options, int btype, int final, const ZopfliLZ77Store *lz77, size_t lstart, size_t lend, size_t expected_data_size, unsigned char *bp, unsigned char **out, size_t *outsize)\n{\n  unsigned ll_lengths[288];\n  unsigned d_lengths[32];\n  unsigned ll_symbols[288];\n  unsigned d_symbols[32];\n  size_t detect_block_size = *outsize;\n  size_t compressed_size;\n  size_t uncompressed_size = 0;\n  size_t i;\n  if (btype == 0)\n  {\n    size_t length = ZopfliLZ77GetByteRange(lz77, lstart, lend);\n    size_t pos = (lstart == lend) ? (0) : (lz77->pos[lstart]);\n    size_t end = pos + length;\n    AddNonCompressedBlock(options, final, lz77->data, pos, end, bp, out, outsize);\n    return;\n  }\n  AddBit(final, bp, out, outsize);\n  AddBit(btype & 1, bp, out, outsize);\n  AddBit((btype & 2) >> 1, bp, out, outsize);\n  if (btype == 1)\n  {\n    GetFixedTree(ll_lengths, d_lengths);\n  }\n  else\n  {\n    unsigned detect_tree_size;\n    assert(btype == 2);\n    GetDynamicLengths(lz77, lstart, lend, ll_lengths, d_lengths);\n    detect_tree_size = *outsize;\n    AddDynamicTree(ll_lengths, d_lengths, bp, out, outsize);\n    if (options->verbose)\n    {\n      fprintf(stderr, \"treesize: %d\\n\", (int) ((*outsize) - detect_tree_size));\n    }\n  }\n  ZopfliLengthsToSymbols(ll_lengths, 288, 15, ll_symbols);\n  ZopfliLengthsToSymbols(d_lengths, 32, 15, d_symbols);\n  detect_block_size = *outsize;\n  AddLZ77Data(lz77, lstart, lend, expected_data_size, ll_symbols, ll_lengths, d_symbols, d_lengths, bp, out, outsize);\n  AddHuffmanBits(ll_symbols[256], ll_lengths[256], bp, out, outsize);\n  for (i = lstart; i < lend; i += 1)\n  {\n    uncompressed_size += (lz77->dists[i] == 0) ? (1) : (lz77->litlens[i]);\n  }\n\n  compressed_size = (*outsize) - detect_block_size;\n  if (options->verbose)\n  {\n    fprintf(stderr, \"compressed block size: %d (%dk) (unc: %d)\\n\", (int) compressed_size, (int) (compressed_size / 1024), (int) uncompressed_size);\n  }\n}\n\n",
        "translated_code": "pub fn AddLZ77Block(\n    options: &ZopfliOptions,\n    btype: i32,\n    final_block: bool,\n    lz77: &ZopfliLz77Store,\n    lstart: usize,\n    lend: usize,\n    expected_data_size: usize,\n    bp: &mut u8,\n    out: &mut Option<Vec<u8>>,\n    outsize: &mut usize,\n) {\n    let mut ll_lengths = [0u32; 288];\n    let mut d_lengths = [0u32; 32];\n    let mut ll_symbols = [0u32; 288];\n    let mut d_symbols = [0u32; 32];\n    let mut detect_block_size = *outsize;\n    let mut uncompressed_size = 0;\n\n    if btype == 0 {\n        let length = ZopfliLZ77GetByteRange(lz77, lstart, lend);\n        let pos = if lstart == lend { 0 } else { lz77.pos.as_ref().unwrap()[lstart] };\n        let end = pos + length;\n        let mut vec_out = out.as_mut().unwrap();\n        AddNonCompressedBlock(\n            options,\n            final_block,\n            lz77.data.as_ref().unwrap(),\n            pos,\n            end,\n            bp,\n            &mut vec_out,\n        );\n        return;\n    }\n\n    AddBit(final_block as i32, bp, out, outsize);\n    AddBit(btype & 1, bp, out, outsize);\n    AddBit((btype & 2) >> 1, bp, out, outsize);\n\n    if btype == 1 {\n        GetFixedTree(&mut ll_lengths, &mut d_lengths);\n    } else {\n        assert!(btype == 2);\n        GetDynamicLengths(lz77, lstart, lend, &mut ll_lengths, &mut d_lengths);\n        let detect_tree_size = *outsize;\n        AddDynamicTree(&ll_lengths, &d_lengths, bp, out, outsize);\n        if options.verbose > 0 {\n            eprintln!(\"treesize: {}\", (*outsize - detect_tree_size) as i32);\n        }\n    }\n\n    ZopfliLengthsToSymbols(&ll_lengths, 288, 15, &mut ll_symbols);\n    ZopfliLengthsToSymbols(&d_lengths, 32, 15, &mut d_symbols);\n    detect_block_size = *outsize;\n\n    AddLZ77Data(\n        lz77,\n        lstart,\n        lend,\n        expected_data_size,\n        &ll_symbols,\n        &ll_lengths,\n        &d_symbols,\n        &d_lengths,\n        bp,\n        out,\n        outsize,\n    );\n\n    let mut boxed_out: Option<Box<[u8]>> = out.as_mut().map(|v| v.clone().into_boxed_slice());\n    AddHuffmanBits(ll_symbols[256], ll_lengths[256], bp, &mut boxed_out, outsize);\n    if let Some(b) = boxed_out {\n        *out = Some(b.into_vec());\n    }\n\n    if let (Some(litlens), Some(dists)) = (&lz77.litlens, &lz77.dists) {\n        for i in lstart..lend {\n            uncompressed_size += if dists[i] == 0 { 1 } else { litlens[i] as usize };\n        }\n    }\n\n    let compressed_size = *outsize - detect_block_size;\n    if options.verbose > 0 {\n        eprintln!(\n            \"compressed block size: {} ({}k) (unc: {})\",\n            compressed_size as i32,\n            (compressed_size / 1024) as i32,\n            uncompressed_size as i32\n        );\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [
            "AddBit",
            "AddDynamicTree",
            "AddHuffmanBits",
            "AddLZ77Data",
            "AddNonCompressedBlock",
            "GetDynamicLengths",
            "GetFixedTree",
            "ZopfliLZ77GetByteRange",
            "ZopfliLZ77Store",
            "ZopfliLengthsToSymbols",
            "ZopfliOptions"
        ],
        "params": [
            "const ZopfliOptions *options",
            "int btype",
            "int final",
            "const ZopfliLZ77Store *lz77",
            "size_t lstart",
            "size_t lend",
            "size_t expected_data_size",
            "unsigned char *bp",
            "unsigned char **out",
            "size_t *outsize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "btype",
            "final",
            "lz77",
            "lstart",
            "lend",
            "expected_data_size",
            "bp",
            "out",
            "outsize",
            "ll_lengths",
            "d_lengths",
            "ll_symbols",
            "d_symbols",
            "detect_block_size",
            "compressed_size",
            "uncompressed_size",
            "i",
            "length",
            "pos",
            "end",
            "detect_tree_size"
        ],
        "calle": [
            "GetDynamicLengths",
            "AddLZ77Data",
            "fprintf",
            "AddNonCompressedBlock",
            "AddBit",
            "AddHuffmanBits",
            "AddDynamicTree",
            "ZopfliLengthsToSymbols",
            "ZopfliLZ77GetByteRange",
            "GetFixedTree",
            "assert"
        ],
        "calle_c": [
            "fprintf",
            "assert"
        ],
        "key": "AddLZ77Block",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "AddLZ77BlockAutoType": {
        "source_code": "static void AddLZ77BlockAutoType(const ZopfliOptions *options, int final, const ZopfliLZ77Store *lz77, size_t lstart, size_t lend, size_t expected_data_size, unsigned char *bp, unsigned char **out, size_t *outsize)\n{\n  double uncompressedcost = ZopfliCalculateBlockSize(lz77, lstart, lend, 0);\n  double fixedcost = ZopfliCalculateBlockSize(lz77, lstart, lend, 1);\n  double dyncost = ZopfliCalculateBlockSize(lz77, lstart, lend, 2);\n  int expensivefixed = (lz77->size < 1000) || (fixedcost <= (dyncost * 1.1));\n  ZopfliLZ77Store fixedstore;\n  if (lstart == lend)\n  {\n    AddBits(final, 1, bp, out, outsize);\n    AddBits(1, 2, bp, out, outsize);\n    AddBits(0, 7, bp, out, outsize);\n    return;\n  }\n  ZopfliInitLZ77Store(lz77->data, &fixedstore);\n  if (expensivefixed)\n  {\n    size_t instart = lz77->pos[lstart];\n    size_t inend = instart + ZopfliLZ77GetByteRange(lz77, lstart, lend);\n    ZopfliBlockState s;\n    ZopfliInitBlockState(options, instart, inend, 1, &s);\n    ZopfliLZ77OptimalFixed(&s, lz77->data, instart, inend, &fixedstore);\n    fixedcost = ZopfliCalculateBlockSize(&fixedstore, 0, fixedstore.size, 1);\n    ZopfliCleanBlockState(&s);\n  }\n  if ((uncompressedcost < fixedcost) && (uncompressedcost < dyncost))\n  {\n    AddLZ77Block(options, 0, final, lz77, lstart, lend, expected_data_size, bp, out, outsize);\n  }\n  else\n    if (fixedcost < dyncost)\n  {\n    if (expensivefixed)\n    {\n      AddLZ77Block(options, 1, final, &fixedstore, 0, fixedstore.size, expected_data_size, bp, out, outsize);\n    }\n    else\n    {\n      AddLZ77Block(options, 1, final, lz77, lstart, lend, expected_data_size, bp, out, outsize);\n    }\n  }\n  else\n  {\n    AddLZ77Block(options, 2, final, lz77, lstart, lend, expected_data_size, bp, out, outsize);\n  }\n  ZopfliCleanLZ77Store(&fixedstore);\n}\n\n",
        "translated_code": "pub fn AddLZ77BlockAutoType(\n    options: &ZopfliOptions,\n    final_block: bool,\n    lz77: &ZopfliLz77Store,\n    lstart: usize,\n    lend: usize,\n    expected_data_size: usize,\n    bp: &mut u8,\n    out: &mut Option<Vec<u8>>,\n    outsize: &mut usize,\n) {\n    let uncompressedcost = ZopfliCalculateBlockSize(lz77, lstart, lend, 0);\n    let fixedcost = ZopfliCalculateBlockSize(lz77, lstart, lend, 1);\n    let dyncost = ZopfliCalculateBlockSize(lz77, lstart, lend, 2);\n    let expensivefixed = (lz77.size < 1000) || (fixedcost <= (dyncost * 1.1));\n\n    let mut fixedstore = ZopfliLz77Store {\n        litlens: None,\n        dists: None,\n        size: 0,\n        data: None,\n        pos: None,\n        ll_symbol: None,\n        d_symbol: None,\n        ll_counts: None,\n        d_counts: None,\n    };\n\n    if lstart == lend {\n        AddBits(final_block as u32, 1, bp, out, outsize);\n        AddBits(1, 2, bp, out, outsize);\n        AddBits(0, 7, bp, out, outsize);\n        return;\n    }\n\n    ZopfliInitLZ77Store(lz77.data.as_deref(), &mut fixedstore);\n\n    if expensivefixed {\n        let instart = lz77.pos.as_ref().unwrap()[lstart];\n        let inend = instart + ZopfliLZ77GetByteRange(lz77, lstart, lend);\n        let mut s = ZopfliBlockState {\n            options: None,\n            lmc: None,\n            blockstart: 0,\n            blockend: 0,\n        };\n        ZopfliInitBlockState(Some(Box::new(options.clone())), instart, inend, true, &mut s);\n        ZopfliLZ77OptimalFixed(&mut s, lz77.data.as_ref().unwrap(), instart, inend, &mut fixedstore);\n        let fixedcost = ZopfliCalculateBlockSize(&fixedstore, 0, fixedstore.size, 1);\n        ZopfliCleanBlockState(&mut s);\n    }\n\n    if (uncompressedcost < fixedcost) && (uncompressedcost < dyncost) {\n        AddLZ77Block(options, 0, final_block, lz77, lstart, lend, expected_data_size, bp, out, outsize);\n    } else if fixedcost < dyncost {\n        if expensivefixed {\n            AddLZ77Block(options, 1, final_block, &fixedstore, 0, fixedstore.size, expected_data_size, bp, out, outsize);\n        } else {\n            AddLZ77Block(options, 1, final_block, lz77, lstart, lend, expected_data_size, bp, out, outsize);\n        }\n    } else {\n        AddLZ77Block(options, 2, final_block, lz77, lstart, lend, expected_data_size, bp, out, outsize);\n    }\n\n    ZopfliCleanLZ77Store(&mut fixedstore);\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [
            "AddBits",
            "AddLZ77Block",
            "ZopfliBlockState",
            "ZopfliCalculateBlockSize",
            "ZopfliCleanBlockState",
            "ZopfliCleanLZ77Store",
            "ZopfliInitBlockState",
            "ZopfliInitLZ77Store",
            "ZopfliLZ77GetByteRange",
            "ZopfliLZ77OptimalFixed",
            "ZopfliLZ77Store",
            "ZopfliOptions"
        ],
        "params": [
            "const ZopfliOptions *options",
            "int final",
            "const ZopfliLZ77Store *lz77",
            "size_t lstart",
            "size_t lend",
            "size_t expected_data_size",
            "unsigned char *bp",
            "unsigned char **out",
            "size_t *outsize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "final",
            "lz77",
            "lstart",
            "lend",
            "expected_data_size",
            "bp",
            "out",
            "outsize",
            "uncompressedcost",
            "fixedcost",
            "dyncost",
            "expensivefixed",
            "fixedstore",
            "instart",
            "inend",
            "s"
        ],
        "calle": [
            "ZopfliLZ77OptimalFixed",
            "AddLZ77Block",
            "ZopfliCalculateBlockSize",
            "ZopfliCleanBlockState",
            "ZopfliCleanLZ77Store",
            "ZopfliLZ77GetByteRange",
            "ZopfliInitLZ77Store",
            "ZopfliInitBlockState",
            "AddBits"
        ],
        "calle_c": [],
        "key": "AddLZ77BlockAutoType",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliDeflatePart": {
        "source_code": "void ZopfliDeflatePart(const ZopfliOptions *options, int btype, int final, const unsigned char *in, size_t instart, size_t inend, unsigned char *bp, unsigned char **out, size_t *outsize)\n{\n  size_t i;\n  size_t *splitpoints_uncompressed = 0;\n  size_t npoints = 0;\n  size_t *splitpoints = 0;\n  double totalcost = 0;\n  ZopfliLZ77Store lz77;\n  if (btype == 0)\n  {\n    AddNonCompressedBlock(options, final, in, instart, inend, bp, out, outsize);\n    return;\n  }\n  else\n    if (btype == 1)\n  {\n    ZopfliLZ77Store store;\n    ZopfliBlockState s;\n    ZopfliInitLZ77Store(in, &store);\n    ZopfliInitBlockState(options, instart, inend, 1, &s);\n    ZopfliLZ77OptimalFixed(&s, in, instart, inend, &store);\n    AddLZ77Block(options, btype, final, &store, 0, store.size, 0, bp, out, outsize);\n    ZopfliCleanBlockState(&s);\n    ZopfliCleanLZ77Store(&store);\n    return;\n  }\n  if (options->blocksplitting)\n  {\n    ZopfliBlockSplit(options, in, instart, inend, options->blocksplittingmax, &splitpoints_uncompressed, &npoints);\n    splitpoints = (size_t *) malloc((sizeof(*splitpoints)) * npoints);\n  }\n  ZopfliInitLZ77Store(in, &lz77);\n  for (i = 0; i <= npoints; i += 1)\n  {\n    size_t start = (i == 0) ? (instart) : (splitpoints_uncompressed[i - 1]);\n    size_t end = (i == npoints) ? (inend) : (splitpoints_uncompressed[i]);\n    ZopfliBlockState s;\n    ZopfliLZ77Store store;\n    ZopfliInitLZ77Store(in, &store);\n    ZopfliInitBlockState(options, start, end, 1, &s);\n    ZopfliLZ77Optimal(&s, in, start, end, options->numiterations, &store);\n    totalcost += ZopfliCalculateBlockSizeAutoType(&store, 0, store.size);\n    ZopfliAppendLZ77Store(&store, &lz77);\n    if (i < npoints)\n    {\n      splitpoints[i] = lz77.size;\n    }\n    ZopfliCleanBlockState(&s);\n    ZopfliCleanLZ77Store(&store);\n  }\n\n  if (options->blocksplitting && (npoints > 1))\n  {\n    size_t *splitpoints2 = 0;\n    size_t npoints2 = 0;\n    double totalcost2 = 0;\n    ZopfliBlockSplitLZ77(options, &lz77, options->blocksplittingmax, &splitpoints2, &npoints2);\n    for (i = 0; i <= npoints2; i += 1)\n    {\n      size_t start = (i == 0) ? (0) : (splitpoints2[i - 1]);\n      size_t end = (i == npoints2) ? (lz77.size) : (splitpoints2[i]);\n      totalcost2 += ZopfliCalculateBlockSizeAutoType(&lz77, start, end);\n    }\n\n    if (totalcost2 < totalcost)\n    {\n      free(splitpoints);\n      splitpoints = splitpoints2;\n      npoints = npoints2;\n    }\n    else\n    {\n      free(splitpoints2);\n    }\n  }\n  for (i = 0; i <= npoints; i += 1)\n  {\n    size_t start = (i == 0) ? (0) : (splitpoints[i - 1]);\n    size_t end = (i == npoints) ? (lz77.size) : (splitpoints[i]);\n    AddLZ77BlockAutoType(options, (i == npoints) && final, &lz77, start, end, 0, bp, out, outsize);\n  }\n\n  ZopfliCleanLZ77Store(&lz77);\n  free(splitpoints);\n  free(splitpoints_uncompressed);\n}\n\n",
        "translated_code": "pub fn ZopfliDeflatePart(\n    options: &ZopfliOptions,\n    btype: i32,\n    final_block: bool,\n    in_data: &[u8],\n    instart: usize,\n    inend: usize,\n    bp: &mut u8,\n    out: &mut Option<Vec<u8>>,\n    outsize: &mut usize,\n) {\n    let mut splitpoints_uncompressed: Option<Vec<usize>> = None;\n    let mut npoints: usize = 0;\n    let mut splitpoints: Option<Vec<usize>> = None;\n    let mut totalcost: f64 = 0.0;\n    let mut lz77 = ZopfliLz77Store {\n        litlens: None,\n        dists: None,\n        size: 0,\n        data: None,\n        pos: None,\n        ll_symbol: None,\n        d_symbol: None,\n        ll_counts: None,\n        d_counts: None,\n    };\n\n    if btype == 0 {\n        // Convert Option<Vec<u8>> to Vec<u8> for AddNonCompressedBlock\n        let mut vec_out = out.take().unwrap_or_default();\n        AddNonCompressedBlock(options, final_block, in_data, instart, inend, bp, &mut vec_out);\n        *out = Some(vec_out);\n        return;\n    } else if btype == 1 {\n        let mut store = ZopfliLz77Store {\n            litlens: None,\n            dists: None,\n            size: 0,\n            data: None,\n            pos: None,\n            ll_symbol: None,\n            d_symbol: None,\n            ll_counts: None,\n            d_counts: None,\n        };\n        let mut s = ZopfliBlockState {\n            options: None,\n            lmc: None,\n            blockstart: 0,\n            blockend: 0,\n        };\n        ZopfliInitLZ77Store(Some(in_data), &mut store);\n        ZopfliInitBlockState(Some(Box::new(options.clone())), instart, inend, true, &mut s);\n        ZopfliLZ77OptimalFixed(&mut s, in_data, instart, inend, &mut store);\n        AddLZ77Block(\n            options,\n            btype,\n            final_block,\n            &store,\n            0,\n            store.size,\n            0,\n            bp,\n            out,\n            outsize,\n        );\n        ZopfliCleanBlockState(&mut s);\n        ZopfliCleanLZ77Store(&mut store);\n        return;\n    }\n\n    if options.blocksplitting != 0 {\n        ZopfliBlockSplit(\n            options,\n            in_data,\n            instart,\n            inend,\n            options.blocksplittingmax as usize,\n            &mut splitpoints_uncompressed,\n            &mut npoints,\n        );\n        if npoints > 0 {\n            splitpoints = Some(vec![0; npoints]);\n        }\n    }\n\n    ZopfliInitLZ77Store(Some(in_data), &mut lz77);\n\n    for i in 0..=npoints {\n        let start = if i == 0 {\n            instart\n        } else {\n            splitpoints_uncompressed.as_ref().unwrap()[i - 1]\n        };\n        let end = if i == npoints {\n            inend\n        } else {\n            splitpoints_uncompressed.as_ref().unwrap()[i]\n        };\n\n        let mut store = ZopfliLz77Store {\n            litlens: None,\n            dists: None,\n            size: 0,\n            data: None,\n            pos: None,\n            ll_symbol: None,\n            d_symbol: None,\n            ll_counts: None,\n            d_counts: None,\n        };\n        let mut s = ZopfliBlockState {\n            options: None,\n            lmc: None,\n            blockstart: 0,\n            blockend: 0,\n        };\n\n        ZopfliInitLZ77Store(Some(in_data), &mut store);\n        ZopfliInitBlockState(Some(Box::new(options.clone())), start, end, true, &mut s);\n        ZopfliLZ77Optimal(\n            &mut s,\n            in_data,\n            start,\n            end,\n            options.numiterations,\n            &mut store,\n        );\n        totalcost += ZopfliCalculateBlockSizeAutoType(&store, 0, store.size);\n        ZopfliAppendLZ77Store(&store, &mut lz77);\n\n        if i < npoints {\n            if let Some(ref mut sp) = splitpoints {\n                sp[i] = lz77.size;\n            }\n        }\n\n        ZopfliCleanBlockState(&mut s);\n        ZopfliCleanLZ77Store(&mut store);\n    }\n\n    if options.blocksplitting != 0 && npoints > 1 {\n        let mut splitpoints2: Option<Vec<usize>> = None;\n        let mut npoints2: usize = 0;\n        let mut totalcost2: f64 = 0.0;\n\n        ZopfliBlockSplitLZ77(\n            options,\n            &lz77,\n            options.blocksplittingmax as usize,\n            &mut splitpoints2,\n            &mut npoints2,\n        );\n\n        for i in 0..=npoints2 {\n            let start = if i == 0 {\n                0\n            } else {\n                splitpoints2.as_ref().unwrap()[i - 1]\n            };\n            let end = if i == npoints2 {\n                lz77.size\n            } else {\n                splitpoints2.as_ref().unwrap()[i]\n            };\n            totalcost2 += ZopfliCalculateBlockSizeAutoType(&lz77, start, end);\n        }\n\n        if totalcost2 < totalcost {\n            splitpoints = splitpoints2;\n            npoints = npoints2;\n        }\n    }\n\n    for i in 0..=npoints {\n        let start = if i == 0 {\n            0\n        } else {\n            splitpoints.as_ref().unwrap()[i - 1]\n        };\n        let end = if i == npoints {\n            lz77.size\n        } else {\n            splitpoints.as_ref().unwrap()[i]\n        };\n        AddLZ77BlockAutoType(\n            options,\n            i == npoints && final_block,\n            &lz77,\n            start,\n            end,\n            0,\n            bp,\n            out,\n            outsize,\n        );\n    }\n\n    ZopfliCleanLZ77Store(&mut lz77);\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [
            "AddLZ77Block",
            "AddLZ77BlockAutoType",
            "AddNonCompressedBlock",
            "ZopfliAppendLZ77Store",
            "ZopfliBlockSplit",
            "ZopfliBlockSplitLZ77",
            "ZopfliBlockState",
            "ZopfliCalculateBlockSizeAutoType",
            "ZopfliCleanBlockState",
            "ZopfliCleanLZ77Store",
            "ZopfliInitBlockState",
            "ZopfliInitLZ77Store",
            "ZopfliLZ77Optimal",
            "ZopfliLZ77OptimalFixed",
            "ZopfliLZ77Store",
            "ZopfliOptions"
        ],
        "header": "void ZopfliDeflatePart(const ZopfliOptions *options, int btype, int final, const unsigned char *in, size_t instart, size_t inend, unsigned char *bp, unsigned char **out, size_t *outsize)",
        "params": [
            "const ZopfliOptions *options",
            "int btype",
            "int final",
            "const unsigned char *in",
            "size_t instart",
            "size_t inend",
            "unsigned char *bp",
            "unsigned char **out",
            "size_t *outsize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "btype",
            "final",
            "in",
            "instart",
            "inend",
            "bp",
            "out",
            "outsize",
            "i",
            "splitpoints_uncompressed",
            "npoints",
            "splitpoints",
            "splitpoints_idx",
            "totalcost",
            "lz77",
            "store",
            "s",
            "start",
            "end",
            "splitpoints2",
            "npoints2",
            "totalcost2"
        ],
        "calle": [
            "AddLZ77Block",
            "ZopfliLZ77OptimalFixed",
            "ZopfliCalculateBlockSizeAutoType",
            "ZopfliAppendLZ77Store",
            "ZopfliLZ77Optimal",
            "free",
            "AddLZ77BlockAutoType",
            "ZopfliCleanBlockState",
            "ZopfliCleanLZ77Store",
            "ZopfliBlockSplit",
            "ZopfliBlockSplitLZ77",
            "ZopfliInitLZ77Store",
            "malloc",
            "ZopfliInitBlockState",
            "AddNonCompressedBlock"
        ],
        "calle_c": [
            "free",
            "malloc"
        ],
        "key": "ZopfliDeflatePart",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "ZopfliDeflate": {
        "source_code": "void ZopfliDeflate(const ZopfliOptions *options, int btype, int final, const unsigned char *in, size_t insize, unsigned char *bp, unsigned char **out, size_t *outsize)\n{\n  size_t offset = *outsize;\n  size_t i = 0;\n  do\n  {\n    int masterfinal = (i + 1000000) >= insize;\n    int final2 = final && masterfinal;\n    size_t size = (masterfinal) ? (insize - i) : (1000000);\n    ZopfliDeflatePart(options, btype, final2, in, i, i + size, bp, out, outsize);\n    i += size;\n  }\n  while (i < insize);\n  if (options->verbose)\n  {\n    fprintf(stderr, \"Original Size: %lu, Deflate: %lu, Compression: %f%% Removed\\n\", (unsigned long) insize, (unsigned long) ((*outsize) - offset), (100.0 * ((double) (insize - ((*outsize) - offset)))) / ((double) insize));\n  }\n}\n\n",
        "translated_code": "use std::io::{self, Write};\n\npub fn ZopfliDeflate(\n    options: &ZopfliOptions,\n    btype: i32,\n    final_block: bool,\n    in_data: &[u8],\n    bp: &mut u8,\n    out: &mut Option<Vec<u8>>,\n    outsize: &mut usize,\n) {\n    let offset = *outsize;\n    let mut i = 0;\n    while i < in_data.len() {\n        let masterfinal = (i + 1000000) >= in_data.len();\n        let final2 = final_block && masterfinal;\n        let size = if masterfinal {\n            in_data.len() - i\n        } else {\n            1000000\n        };\n        \n        ZopfliDeflatePart(\n            options,\n            btype,\n            final2,\n            in_data,\n            i,\n            i + size,\n            bp,\n            out,\n            outsize,\n        );\n        i += size;\n    }\n\n    if options.verbose != 0 {\n        let original_size = in_data.len();\n        let compressed_size = *outsize - offset;\n        let compression_ratio = 100.0 * (original_size as f64 - compressed_size as f64) / original_size as f64;\n        \n        writeln!(\n            io::stderr(),\n            \"Original Size: {}, Deflate: {}, Compression: {:.2}% Removed\",\n            original_size,\n            compressed_size,\n            compression_ratio\n        ).unwrap();\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "deflate.rs",
        "error": "",
        "dependent": [
            "ZopfliDeflatePart",
            "ZopfliOptions"
        ],
        "header": "void ZopfliDeflate(const ZopfliOptions *options, int btype, int final, const unsigned char *in, size_t insize, unsigned char *bp, unsigned char **out, size_t *outsize)",
        "params": [
            "const ZopfliOptions *options",
            "int btype",
            "int final",
            "const unsigned char *in",
            "size_t insize",
            "unsigned char *bp",
            "unsigned char **out",
            "size_t *outsize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "btype",
            "final",
            "in",
            "insize",
            "bp",
            "out",
            "outsize",
            "offset",
            "i",
            "masterfinal",
            "final2",
            "size"
        ],
        "calle": [
            "ZopfliDeflatePart",
            "fprintf"
        ],
        "calle_c": [
            "fprintf"
        ],
        "key": "ZopfliDeflate",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliZlibCompress": {
        "source_code": "void ZopfliZlibCompress(const ZopfliOptions *options, const unsigned char *in, size_t insize, unsigned char **out, size_t *outsize)\n{\n  unsigned char bitpointer = 0;\n  unsigned checksum = adler32(in, (unsigned) insize);\n  unsigned cmf = 120;\n  unsigned flevel = 3;\n  unsigned fdict = 0;\n  unsigned cmfflg = ((256 * cmf) + (fdict * 32)) + (flevel * 64);\n  unsigned fcheck = 31 - (cmfflg % 31);\n  cmfflg += fcheck;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = cmfflg / 256;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = cmfflg % 256;\n    *outsize += 1;\n  }\n  ;\n  ZopfliDeflate(options, 2, 1, in, insize, &bitpointer, out, outsize);\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = (checksum >> 24) % 256;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = (checksum >> 16) % 256;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = (checksum >> 8) % 256;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = checksum % 256;\n    *outsize += 1;\n  }\n  ;\n  if (options->verbose)\n  {\n    fprintf(stderr, \"Original Size: %d, Zlib: %d, Compression: %f%% Removed\\n\", (int) insize, (int) (*outsize), (100.0 * ((double) (insize - (*outsize)))) / ((double) insize));\n  }\n}\n\n",
        "translated_code": "pub fn ZopfliZlibCompress(\n    options: &ZopfliOptions,\n    in_data: &[u8],\n    out: &mut Vec<u8>,\n) -> io::Result<()> {\n    let mut bitpointer = 0;\n    let checksum = adler32(in_data);\n    let cmf = 120;\n    let flevel = 3;\n    let fdict = 0;\n    let cmfflg = ((256 * cmf) + (fdict * 32)) + (flevel * 64);\n    let fcheck = 31 - (cmfflg % 31);\n    let cmfflg = cmfflg + fcheck;\n\n    // Write CMF and FLG bytes\n    out.push((cmfflg / 256) as u8);\n    out.push((cmfflg % 256) as u8);\n\n    // Compress data using deflate\n    let mut out_option = Some(out.clone());\n    let mut outsize = out.len();\n    ZopfliDeflate(\n        options,\n        2,\n        true,  // final_block should be bool, not 1\n        in_data,\n        &mut bitpointer,\n        &mut out_option,\n        &mut outsize,\n    );\n    if let Some(updated_out) = out_option {\n        *out = updated_out;\n    }\n\n    // Write checksum (big-endian)\n    out.push((checksum >> 24) as u8);\n    out.push((checksum >> 16) as u8);\n    out.push((checksum >> 8) as u8);\n    out.push(checksum as u8);\n\n    if options.verbose != 0 {\n        let insize = in_data.len();\n        let outsize = out.len();\n        let ratio = 100.0 * (insize as f64 - outsize as f64) / insize as f64;\n        writeln!(\n            io::stderr(),\n            \"Original Size: {}, Zlib: {}, Compression: {:.2}% Removed\",\n            insize, outsize, ratio\n        )?;\n    }\n\n    Ok(())\n}",
        "hint": "functions",
        "section": "src",
        "file": "zlib_container.rs",
        "error": "",
        "dependent": [
            "ZopfliDeflate",
            "ZopfliOptions",
            "adler32"
        ],
        "header": "void ZopfliZlibCompress(const ZopfliOptions *options, const unsigned char *in, size_t insize, unsigned char **out, size_t *outsize)",
        "params": [
            "const ZopfliOptions *options",
            "const unsigned char *in",
            "size_t insize",
            "unsigned char **out",
            "size_t *outsize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "in",
            "insize",
            "out",
            "outsize",
            "bitpointer",
            "checksum",
            "cmf",
            "flevel",
            "fdict",
            "cmfflg",
            "fcheck"
        ],
        "calle": [
            "realloc",
            "fprintf",
            "adler32",
            "ZopfliDeflate",
            "malloc"
        ],
        "calle_c": [
            "realloc",
            "fprintf",
            "malloc"
        ],
        "key": "ZopfliZlibCompress",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliGzipCompress": {
        "source_code": "void ZopfliGzipCompress(const ZopfliOptions *options, const unsigned char *in, size_t insize, unsigned char **out, size_t *outsize)\n{\n  unsigned long crcvalue = CRC(in, insize);\n  unsigned char bp = 0;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = 31;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = 139;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = 8;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = 0;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = 0;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = 0;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = 0;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = 0;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = 2;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = 3;\n    *outsize += 1;\n  }\n  ;\n  ZopfliDeflate(options, 2, 1, in, insize, &bp, out, outsize);\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = crcvalue % 256;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = (crcvalue >> 8) % 256;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = (crcvalue >> 16) % 256;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = (crcvalue >> 24) % 256;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = insize % 256;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = (insize >> 8) % 256;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = (insize >> 16) % 256;\n    *outsize += 1;\n  }\n  ;\n  {\n    if (!((*outsize) & ((*outsize) - 1)))\n    {\n      *out = ((*outsize) == 0) ? (malloc(sizeof(*(*out)))) : (realloc(*out, ((*outsize) * 2) * (sizeof(*(*out)))));\n    }\n    (*out)[*outsize] = (insize >> 24) % 256;\n    *outsize += 1;\n  }\n  ;\n  if (options->verbose)\n  {\n    fprintf(stderr, \"Original Size: %d, Gzip: %d, Compression: %f%% Removed\\n\", (int) insize, (int) (*outsize), (100.0 * ((double) (insize - (*outsize)))) / ((double) insize));\n  }\n}\n\n",
        "translated_code": "pub fn ZopfliGzipCompress(\n    options: &ZopfliOptions,\n    in_data: Option<&[u8]>,\n    out: &mut Vec<u8>,\n) -> io::Result<()> {\n    let insize = in_data.map(|d| d.len()).unwrap_or(0);\n    let crcvalue = CRC(in_data).unwrap_or(0);\n    let mut bp = 0u8;\n    let mut outsize = out.len();\n\n    // Helper macro to push bytes to the output vector\n    macro_rules! push_byte {\n        ($byte:expr) => {\n            out.push($byte);\n            outsize += 1;\n        };\n    }\n\n    // Gzip header bytes\n    push_byte!(31);\n    push_byte!(139);\n    push_byte!(8);\n    push_byte!(0);\n    push_byte!(0);\n    push_byte!(0);\n    push_byte!(0);\n    push_byte!(0);\n    push_byte!(2);\n    push_byte!(3);\n\n    // Compress the data\n    let mut output_vec = Some(out.clone());\n    ZopfliDeflate(\n        options,\n        2,\n        true,\n        in_data.unwrap_or(&[]),\n        &mut bp,\n        &mut output_vec,\n        &mut outsize,\n    );\n    if let Some(new_vec) = output_vec {\n        *out = new_vec;\n    }\n\n    // CRC and size footer\n    push_byte!((crcvalue % 256) as u8);\n    push_byte!(((crcvalue >> 8) % 256) as u8);\n    push_byte!(((crcvalue >> 16) % 256) as u8);\n    push_byte!(((crcvalue >> 24) % 256) as u8);\n    push_byte!((insize % 256) as u8);\n    push_byte!(((insize >> 8) % 256) as u8);\n    push_byte!(((insize >> 16) % 256) as u8);\n    push_byte!(((insize >> 24) % 256) as u8);\n\n    if options.verbose != 0 {\n        let compression = if insize > 0 {\n            100.0 * (insize as f64 - outsize as f64) / insize as f64\n        } else {\n            0.0\n        };\n        eprintln!(\n            \"Original Size: {}, Gzip: {}, Compression: {:.2}% Removed\",\n            insize, outsize, compression\n        );\n    }\n\n    Ok(())\n}",
        "hint": "functions",
        "section": "src",
        "file": "gzip_container.rs",
        "error": "",
        "dependent": [
            "CRC",
            "ZopfliDeflate",
            "ZopfliOptions"
        ],
        "header": "void ZopfliGzipCompress(const ZopfliOptions *options, const unsigned char *in, size_t insize, unsigned char **out, size_t *outsize)",
        "params": [
            "const ZopfliOptions *options",
            "const unsigned char *in",
            "size_t insize",
            "unsigned char **out",
            "size_t *outsize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "in",
            "insize",
            "out",
            "outsize",
            "crcvalue",
            "bp"
        ],
        "calle": [
            "realloc",
            "fprintf",
            "CRC",
            "ZopfliDeflate",
            "malloc"
        ],
        "calle_c": [
            "realloc",
            "fprintf",
            "malloc"
        ],
        "key": "ZopfliGzipCompress",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "ZopfliCompress": {
        "source_code": "void ZopfliCompress(const ZopfliOptions *options, ZopfliFormat output_type, const unsigned char *in, size_t insize, unsigned char **out, size_t *outsize)\n{\n  if (output_type == ZOPFLI_FORMAT_GZIP)\n  {\n    ZopfliGzipCompress(options, in, insize, out, outsize);\n  }\n  else\n    if (output_type == ZOPFLI_FORMAT_ZLIB)\n  {\n    ZopfliZlibCompress(options, in, insize, out, outsize);\n  }\n  else\n    if (output_type == ZOPFLI_FORMAT_DEFLATE)\n  {\n    unsigned char bp = 0;\n    ZopfliDeflate(options, 2, 1, in, insize, &bp, out, outsize);\n  }\n  else\n  {\n    assert(0);\n  }\n}\n\n",
        "translated_code": "pub fn ZopfliCompress(\n    options: &ZopfliOptions,\n    output_type: ZopfliFormat,\n    in_data: Option<&[u8]>,\n    out: &mut Vec<u8>,\n) -> io::Result<()> {\n    match output_type {\n        ZopfliFormat::ZOPFLI_FORMAT_GZIP => {\n            ZopfliGzipCompress(options, in_data, out)\n        }\n        ZopfliFormat::ZOPFLI_FORMAT_ZLIB => {\n            if let Some(data) = in_data {\n                ZopfliZlibCompress(options, data, out)\n            } else {\n                Err(io::Error::new(io::ErrorKind::InvalidInput, \"Input data is None\"))\n            }\n        }\n        ZopfliFormat::ZOPFLI_FORMAT_DEFLATE => {\n            let mut bp = 0u8;\n            let mut outsize = 0usize;\n            let mut out_wrapper = Some(out.clone());\n            if let Some(data) = in_data {\n                ZopfliDeflate(\n                    options,\n                    2,\n                    true,\n                    data,\n                    &mut bp,\n                    &mut out_wrapper,\n                    &mut outsize,\n                );\n                if let Some(updated_out) = out_wrapper {\n                    *out = updated_out;\n                }\n                Ok(())\n            } else {\n                Err(io::Error::new(io::ErrorKind::InvalidInput, \"Input data is None\"))\n            }\n        }\n        _ => {\n            panic!(\"Invalid output type\");\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "zopfli_lib.rs",
        "error": "",
        "dependent": [
            "ZopfliDeflate",
            "ZopfliFormat",
            "ZopfliGzipCompress",
            "ZopfliOptions",
            "ZopfliZlibCompress"
        ],
        "header": "void ZopfliCompress(const ZopfliOptions *options, ZopfliFormat output_type, const unsigned char *in, size_t insize, unsigned char **out, size_t *outsize)",
        "params": [
            "const ZopfliOptions *options",
            "ZopfliFormat output_type",
            "const unsigned char *in",
            "size_t insize",
            "unsigned char **out",
            "size_t *outsize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "output_type",
            "in",
            "insize",
            "out",
            "outsize",
            "bp"
        ],
        "calle": [
            "ZopfliGzipCompress",
            "ZopfliZlibCompress",
            "assert",
            "ZopfliDeflate"
        ],
        "calle_c": [
            "assert"
        ],
        "key": "ZopfliCompress",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_zopfli_repetitive_data": {
        "source_code": "static int test_zopfli_repetitive_data()\n{\n  ZopfliOptions options;\n  char repetitive_data[2000];\n  unsigned char *out = 0;\n  size_t outsize = 0;\n  int i;\n  double compression_ratio;\n  for (i = 0; i < 2000; i += 1)\n  {\n    repetitive_data[i] = 'A' + (i % 5);\n  }\n\n  ZopfliInitOptions(&options);\n  ZopfliCompress(&options, ZOPFLI_FORMAT_DEFLATE, (const unsigned char *) repetitive_data, 2000, &out, &outsize);\n  do\n  {\n    if (!(out != 0))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Output buffer should not be NULL\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!(outsize > 0))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Output size should be greater than 0\");\n      return 0;\n    }\n  }\n  while (0);\n  compression_ratio = ((double) outsize) / 2000;\n  printf(\"  Repetitive data compression ratio: %.3f (%zu bytes from 2000)\\n\", compression_ratio, outsize);\n  do\n  {\n    if (!(outsize < 100))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Repetitive data should compress very well\");\n      return 0;\n    }\n  }\n  while (0);\n  free(out);\n  do\n  {\n    printf(\"PASS: %s\\n\", __func__);\n    return 1;\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn test_zopfli_repetitive_data() -> i32 {\n    let mut options = ZopfliOptions {\n        verbose: 0,\n        verbose_more: 0,\n        numiterations: 0,\n        blocksplitting: 0,\n        blocksplittinglast: 0,\n        blocksplittingmax: 0,\n    };\n    let mut repetitive_data = [0u8; 2000];\n    \n    // Fill repetitive_data with 'A' to 'E' repeating pattern\n    for i in 0..2000 {\n        repetitive_data[i] = b'A' + (i % 5) as u8;\n    }\n\n    ZopfliInitOptions(&mut options);\n    \n    let mut out = Vec::new();\n    match ZopfliCompress(&options, ZopfliFormat::ZOPFLI_FORMAT_DEFLATE, Some(&repetitive_data), &mut out) {\n        Ok(_) => (),\n        Err(e) => {\n            println!(\"FAIL: {} - {}\", \"test_zopfli_repetitive_data\", e);\n            return 0;\n        }\n    }\n\n    if out.is_empty() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_repetitive_data\", \"Output size should be greater than 0\");\n        return 0;\n    }\n\n    let outsize = out.len();\n    let compression_ratio = outsize as f64 / 2000.0;\n    println!(\"  Repetitive data compression ratio: {:.3} ({} bytes from 2000)\", compression_ratio, outsize);\n\n    if outsize >= 100 {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_repetitive_data\", \"Repetitive data should compress very well\");\n        return 0;\n    }\n\n    println!(\"PASS: {}\", \"test_zopfli_repetitive_data\");\n    1\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_zopfli.rs",
        "error": "",
        "dependent": [
            "ZopfliCompress",
            "ZopfliInitOptions",
            "ZopfliOptions"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "repetitive_data",
            "out",
            "outsize",
            "i",
            "compression_ratio"
        ],
        "calle": [
            "free",
            "ZopfliCompress",
            "ZopfliInitOptions",
            "printf"
        ],
        "calle_c": [
            "free",
            "printf"
        ],
        "key": "test_zopfli_repetitive_data",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_zopfli_empty_input": {
        "source_code": "static int test_zopfli_empty_input()\n{\n  ZopfliOptions options;\n  unsigned char *out = 0;\n  size_t outsize = 0;\n  const char *empty_data = \"\";\n  ZopfliInitOptions(&options);\n  ZopfliCompress(&options, ZOPFLI_FORMAT_DEFLATE, (const unsigned char *) empty_data, 0, &out, &outsize);\n  do\n  {\n    if (!(out != 0))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Output buffer should not be NULL even for empty input\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!(outsize > 0))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Output size should be greater than 0 even for empty input\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!verify_deflate_format(out, outsize))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Empty input should produce valid deflate\");\n      return 0;\n    }\n  }\n  while (0);\n  printf(\"  Empty input compression: %zu bytes\\n\", outsize);\n  free(out);\n  do\n  {\n    printf(\"PASS: %s\\n\", __func__);\n    return 1;\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn test_zopfli_empty_input() -> bool {\n    let mut options = ZopfliOptions {\n        verbose: 0,\n        verbose_more: 0,\n        numiterations: 0,\n        blocksplitting: 0,\n        blocksplittinglast: 0,\n        blocksplittingmax: 0,\n    };\n    ZopfliInitOptions(&mut options);\n    \n    let empty_data = b\"\";\n    let mut out = Vec::new();\n    \n    match ZopfliCompress(&options, ZopfliFormat::ZOPFLI_FORMAT_DEFLATE, Some(empty_data), &mut out) {\n        Ok(_) => {\n            if out.is_empty() {\n                println!(\"FAIL: {} - {}\", \"test_zopfli_empty_input\", \"Output size should be greater than 0 even for empty input\");\n                return false;\n            }\n            \n            if !verify_deflate_format(Some(&out), out.len()) {\n                println!(\"FAIL: {} - {}\", \"test_zopfli_empty_input\", \"Empty input should produce valid deflate\");\n                return false;\n            }\n            \n            println!(\"  Empty input compression: {} bytes\", out.len());\n            println!(\"PASS: {}\", \"test_zopfli_empty_input\");\n            true\n        }\n        Err(_) => {\n            println!(\"FAIL: {} - {}\", \"test_zopfli_empty_input\", \"Output buffer should not be NULL even for empty input\");\n            false\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_zopfli.rs",
        "error": "",
        "dependent": [
            "ZopfliCompress",
            "ZopfliInitOptions",
            "ZopfliOptions",
            "verify_deflate_format"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "out",
            "outsize",
            "empty_data"
        ],
        "calle": [
            "free",
            "verify_deflate_format",
            "ZopfliCompress",
            "ZopfliInitOptions",
            "printf"
        ],
        "calle_c": [
            "free",
            "printf"
        ],
        "key": "test_zopfli_empty_input",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_zopfli_iterations": {
        "source_code": "static int test_zopfli_iterations()\n{\n  ZopfliOptions options1;\n  ZopfliOptions options2;\n  unsigned char *out1 = 0;\n  unsigned char *out2 = 0;\n  size_t outsize1 = 0;\n  size_t outsize2 = 0;\n  clock_t start;\n  clock_t end;\n  double time1;\n  double time2;\n  ZopfliInitOptions(&options1);\n  ZopfliInitOptions(&options2);\n  options1.numiterations = 1;\n  options2.numiterations = 25;\n  start = clock();\n  ZopfliCompress(&options1, ZOPFLI_FORMAT_DEFLATE, (const unsigned char *) test_data_large, strlen(test_data_large), &out1, &outsize1);\n  end = clock();\n  time1 = ((double) (end - start)) / CLOCKS_PER_SEC;\n  start = clock();\n  ZopfliCompress(&options2, ZOPFLI_FORMAT_DEFLATE, (const unsigned char *) test_data_large, strlen(test_data_large), &out2, &outsize2);\n  end = clock();\n  time2 = ((double) (end - start)) / CLOCKS_PER_SEC;\n  do\n  {\n    if (!((out1 != 0) && (outsize1 > 0)))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Fast compression should work\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!((out2 != 0) && (outsize2 > 0)))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Slow compression should work\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!(outsize2 <= outsize1))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"More iterations should give better or equal compression\");\n      return 0;\n    }\n  }\n  while (0);\n  printf(\"  1 iteration: %zu bytes (%.3fs), 25 iterations: %zu bytes (%.3fs)\\n\", outsize1, time1, outsize2, time2);\n  free(out1);\n  free(out2);\n  do\n  {\n    printf(\"PASS: %s\\n\", __func__);\n    return 1;\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn test_zopfli_iterations() -> bool {\n    use crate::ZopfliFormat::ZOPFLI_FORMAT_DEFLATE;\n    use std::default::Default;\n    \n    let mut options1 = ZopfliOptions {\n        verbose: 0,\n        verbose_more: 0,\n        numiterations: 0,\n        blocksplitting: 0,\n        blocksplittinglast: 0,\n        blocksplittingmax: 0,\n    };\n    let mut options2 = ZopfliOptions {\n        verbose: 0,\n        verbose_more: 0,\n        numiterations: 0,\n        blocksplitting: 0,\n        blocksplittinglast: 0,\n        blocksplittingmax: 0,\n    };\n    let mut out1 = Vec::new();\n    let mut out2 = Vec::new();\n    \n    ZopfliInitOptions(&mut options1);\n    ZopfliInitOptions(&mut options2);\n    \n    options1.numiterations = 1;\n    options2.numiterations = 25;\n    \n    let test_data = TEST_DATA_LARGE.as_bytes();\n    \n    // First compression\n    let start = std::time::Instant::now();\n    if let Err(e) = ZopfliCompress(&options1, ZOPFLI_FORMAT_DEFLATE, Some(test_data), &mut out1) {\n        eprintln!(\"Error in first compression: {}\", e);\n        return false;\n    }\n    let time1 = start.elapsed().as_secs_f64();\n    \n    // Second compression\n    let start = std::time::Instant::now();\n    if let Err(e) = ZopfliCompress(&options2, ZOPFLI_FORMAT_DEFLATE, Some(test_data), &mut out2) {\n        eprintln!(\"Error in second compression: {}\", e);\n        return false;\n    }\n    let time2 = start.elapsed().as_secs_f64();\n    \n    // Check first compression result\n    if out1.is_empty() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_iterations\", \"Fast compression should work\");\n        return false;\n    }\n    \n    // Check second compression result\n    if out2.is_empty() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_iterations\", \"Slow compression should work\");\n        return false;\n    }\n    \n    // Compare compression sizes\n    if out2.len() > out1.len() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_iterations\", \"More iterations should give better or equal compression\");\n        return false;\n    }\n    \n    println!(\"  1 iteration: {} bytes ({:.3}s), 25 iterations: {} bytes ({:.3}s)\",\n             out1.len(), time1, out2.len(), time2);\n    \n    println!(\"PASS: {}\", \"test_zopfli_iterations\");\n    true\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_zopfli.rs",
        "error": "",
        "dependent": [
            "ZopfliCompress",
            "ZopfliInitOptions",
            "ZopfliOptions",
            "test_data_large"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options1",
            "options2",
            "out1",
            "out2",
            "outsize1",
            "outsize2",
            "start",
            "end",
            "time1",
            "time2",
            "test_data_large"
        ],
        "calle": [
            "free",
            "strlen",
            "clock",
            "ZopfliCompress",
            "ZopfliInitOptions",
            "printf"
        ],
        "calle_c": [
            "strlen",
            "clock",
            "printf",
            "free"
        ],
        "key": "test_zopfli_iterations",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_zopfli_binary_data": {
        "source_code": "static int test_zopfli_binary_data()\n{\n  ZopfliOptions options;\n  unsigned char binary_data[256];\n  unsigned char *out = 0;\n  size_t outsize = 0;\n  int i;\n  for (i = 0; i < 256; i += 1)\n  {\n    binary_data[i] = (unsigned char) i;\n  }\n\n  ZopfliInitOptions(&options);\n  ZopfliCompress(&options, ZOPFLI_FORMAT_ZLIB, binary_data, 256, &out, &outsize);\n  do\n  {\n    if (!(out != 0))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Output buffer should not be NULL\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!(outsize > 0))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Output size should be greater than 0\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!verify_zlib_header(out, outsize))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Should produce valid zlib format\");\n      return 0;\n    }\n  }\n  while (0);\n  printf(\"  Binary data compression: %zu bytes (from 256 input bytes)\\n\", outsize);\n  free(out);\n  do\n  {\n    printf(\"PASS: %s\\n\", __func__);\n    return 1;\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn test_zopfli_binary_data() -> i32 {\n    let mut options = ZopfliOptions {\n        verbose: 0,\n        verbose_more: 0,\n        numiterations: 0,\n        blocksplitting: 0,\n        blocksplittinglast: 0,\n        blocksplittingmax: 0,\n    };\n    \n    let mut binary_data = [0u8; 256];\n    for i in 0..256 {\n        binary_data[i] = i as u8;\n    }\n\n    ZopfliInitOptions(&mut options);\n    let mut out = Vec::new();\n    \n    match ZopfliCompress(&options, ZopfliFormat::ZOPFLI_FORMAT_DEFLATE, Some(&binary_data), &mut out) {\n        Ok(_) => {\n            if out.is_empty() {\n                println!(\"FAIL: {} - {}\", \"test_zopfli_binary_data\", \"Output buffer should not be NULL\");\n                return 0;\n            }\n            \n            let outsize = out.len();\n            if outsize == 0 {\n                println!(\"FAIL: {} - {}\", \"test_zopfli_binary_data\", \"Output size should be greater than 0\");\n                return 0;\n            }\n            \n            if !verify_zlib_header(Some(&out), outsize) {\n                println!(\"FAIL: {} - {}\", \"test_zopfli_binary_data\", \"Should produce valid zlib format\");\n                return 0;\n            }\n            \n            println!(\"  Binary data compression: {} bytes (from 256 input bytes)\", outsize);\n            println!(\"PASS: {}\", \"test_zopfli_binary_data\");\n            1\n        }\n        Err(e) => {\n            println!(\"FAIL: {} - Compression error: {}\", \"test_zopfli_binary_data\", e);\n            0\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_zopfli.rs",
        "error": "",
        "dependent": [
            "ZopfliCompress",
            "ZopfliInitOptions",
            "ZopfliOptions",
            "verify_zlib_header"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "binary_data",
            "out",
            "outsize",
            "i"
        ],
        "calle": [
            "verify_zlib_header",
            "free",
            "ZopfliCompress",
            "ZopfliInitOptions",
            "printf"
        ],
        "calle_c": [
            "free",
            "printf"
        ],
        "key": "test_zopfli_binary_data",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_zopfli_block_splitting": {
        "source_code": "static int test_zopfli_block_splitting()\n{\n  ZopfliOptions options_on;\n  ZopfliOptions options_off;\n  unsigned char *out_on = 0;\n  unsigned char *out_off = 0;\n  size_t outsize_on = 0;\n  size_t outsize_off = 0;\n  ZopfliInitOptions(&options_on);\n  ZopfliInitOptions(&options_off);\n  options_on.blocksplitting = 1;\n  options_off.blocksplitting = 0;\n  ZopfliCompress(&options_on, ZOPFLI_FORMAT_DEFLATE, (const unsigned char *) test_data_large, strlen(test_data_large), &out_on, &outsize_on);\n  ZopfliCompress(&options_off, ZOPFLI_FORMAT_DEFLATE, (const unsigned char *) test_data_large, strlen(test_data_large), &out_off, &outsize_off);\n  do\n  {\n    if (!((out_on != 0) && (outsize_on > 0)))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Block splitting ON should work\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!((out_off != 0) && (outsize_off > 0)))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Block splitting OFF should work\");\n      return 0;\n    }\n  }\n  while (0);\n  printf(\"  Block splitting ON: %zu bytes, OFF: %zu bytes\\n\", outsize_on, outsize_off);\n  do\n  {\n    if (!(outsize_on <= outsize_off))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Block splitting should improve or maintain compression\");\n      return 0;\n    }\n  }\n  while (0);\n  free(out_on);\n  free(out_off);\n  do\n  {\n    printf(\"PASS: %s\\n\", __func__);\n    return 1;\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn test_zopfli_block_splitting() -> bool {\n    let mut options_on = ZopfliOptions {\n        verbose: 0,\n        verbose_more: 0,\n        numiterations: 0,\n        blocksplitting: 0,\n        blocksplittinglast: 0,\n        blocksplittingmax: 0,\n    };\n    let mut options_off = ZopfliOptions {\n        verbose: 0,\n        verbose_more: 0,\n        numiterations: 0,\n        blocksplitting: 0,\n        blocksplittinglast: 0,\n        blocksplittingmax: 0,\n    };\n    ZopfliInitOptions(&mut options_on);\n    ZopfliInitOptions(&mut options_off);\n    \n    options_on.blocksplitting = 1;\n    options_off.blocksplitting = 0;\n\n    let test_data = TEST_DATA_LARGE.as_bytes();\n    let mut out_on = Vec::new();\n    let mut out_off = Vec::new();\n\n    if let Err(e) = ZopfliCompress(&options_on, ZOPFLI_FORMAT_DEFLATE, Some(test_data), &mut out_on) {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_block_splitting\", \"Block splitting ON should work\");\n        println!(\"Error: {}\", e);\n        return false;\n    }\n\n    if let Err(e) = ZopfliCompress(&options_off, ZOPFLI_FORMAT_DEFLATE, Some(test_data), &mut out_off) {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_block_splitting\", \"Block splitting OFF should work\");\n        println!(\"Error: {}\", e);\n        return false;\n    }\n\n    if out_on.is_empty() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_block_splitting\", \"Block splitting ON should work\");\n        return false;\n    }\n\n    if out_off.is_empty() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_block_splitting\", \"Block splitting OFF should work\");\n        return false;\n    }\n\n    println!(\"  Block splitting ON: {} bytes, OFF: {} bytes\", out_on.len(), out_off.len());\n\n    if out_on.len() > out_off.len() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_block_splitting\", \"Block splitting should improve or maintain compression\");\n        return false;\n    }\n\n    println!(\"PASS: {}\", \"test_zopfli_block_splitting\");\n    true\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_zopfli.rs",
        "error": "",
        "dependent": [
            "ZopfliCompress",
            "ZopfliInitOptions",
            "ZopfliOptions",
            "test_data_large"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options_on",
            "options_off",
            "out_on",
            "out_off",
            "outsize_on",
            "outsize_off",
            "test_data_large"
        ],
        "calle": [
            "free",
            "strlen",
            "ZopfliCompress",
            "ZopfliInitOptions",
            "printf"
        ],
        "calle_c": [
            "strlen",
            "printf",
            "free"
        ],
        "key": "test_zopfli_block_splitting",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_zopfli_consistency": {
        "source_code": "static int test_zopfli_consistency()\n{\n  ZopfliOptions options;\n  unsigned char *out1 = 0;\n  unsigned char *out2 = 0;\n  size_t outsize1 = 0;\n  size_t outsize2 = 0;\n  ZopfliInitOptions(&options);\n  ZopfliCompress(&options, ZOPFLI_FORMAT_GZIP, (const unsigned char *) test_data_medium, strlen(test_data_medium), &out1, &outsize1);\n  ZopfliCompress(&options, ZOPFLI_FORMAT_GZIP, (const unsigned char *) test_data_medium, strlen(test_data_medium), &out2, &outsize2);\n  do\n  {\n    if (!((out1 != 0) && (outsize1 > 0)))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"First compression should work\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!((out2 != 0) && (outsize2 > 0)))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Second compression should work\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!(outsize1 == outsize2))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Compression should be deterministic\");\n      return 0;\n    }\n  }\n  while (0);\n  printf(\"  Consistency check: both compressions produced %zu bytes\\n\", outsize1);\n  free(out1);\n  free(out2);\n  do\n  {\n    printf(\"PASS: %s\\n\", __func__);\n    return 1;\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn test_zopfli_consistency() -> bool {\n    let mut options = ZopfliOptions {\n        verbose: 0,\n        verbose_more: 0,\n        numiterations: 0,\n        blocksplitting: 0,\n        blocksplittinglast: 0,\n        blocksplittingmax: 0,\n    };\n    ZopfliInitOptions(&mut options);\n\n    let test_data = TEST_DATA_MEDIUM.as_bytes();\n    \n    let mut out1 = Vec::new();\n    let mut out2 = Vec::new();\n\n    // First compression\n    if let Err(e) = ZopfliCompress(&options, ZopfliFormat::ZOPFLI_FORMAT_GZIP, Some(test_data), &mut out1) {\n        println!(\"FAIL: {} - First compression failed: {}\", \"test_zopfli_consistency\", e);\n        return false;\n    }\n\n    // Second compression\n    if let Err(e) = ZopfliCompress(&options, ZopfliFormat::ZOPFLI_FORMAT_GZIP, Some(test_data), &mut out2) {\n        println!(\"FAIL: {} - Second compression failed: {}\", \"test_zopfli_consistency\", e);\n        return false;\n    }\n\n    // Check first compression output\n    if out1.is_empty() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_consistency\", \"First compression should work\");\n        return false;\n    }\n\n    // Check second compression output\n    if out2.is_empty() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_consistency\", \"Second compression should work\");\n        return false;\n    }\n\n    // Check consistency\n    if out1.len() != out2.len() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_consistency\", \"Compression should be deterministic\");\n        return false;\n    }\n\n    println!(\"  Consistency check: both compressions produced {} bytes\", out1.len());\n    println!(\"PASS: {}\", \"test_zopfli_consistency\");\n    true\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_zopfli.rs",
        "error": "",
        "dependent": [
            "ZopfliCompress",
            "ZopfliInitOptions",
            "ZopfliOptions",
            "test_data_medium"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "out1",
            "out2",
            "outsize1",
            "outsize2",
            "test_data_medium"
        ],
        "calle": [
            "free",
            "strlen",
            "ZopfliCompress",
            "ZopfliInitOptions",
            "printf"
        ],
        "calle_c": [
            "strlen",
            "printf",
            "free"
        ],
        "key": "test_zopfli_consistency",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_zopfli_verbose_options": {
        "source_code": "static int test_zopfli_verbose_options()\n{\n  ZopfliOptions options;\n  unsigned char *out = 0;\n  size_t outsize = 0;\n  ZopfliInitOptions(&options);\n  options.verbose = 1;\n  printf(\"  Testing with verbose output enabled:\\n\");\n  ZopfliCompress(&options, ZOPFLI_FORMAT_GZIP, (const unsigned char *) test_data_medium, strlen(test_data_medium), &out, &outsize);\n  do\n  {\n    if (!((out != 0) && (outsize > 0)))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Verbose compression should work\");\n      return 0;\n    }\n  }\n  while (0);\n  free(out);\n  do\n  {\n    printf(\"PASS: %s\\n\", __func__);\n    return 1;\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn test_zopfli_verbose_options() -> bool {\n    use crate::ZopfliFormat::ZOPFLI_FORMAT_GZIP;\n    \n    let mut options = ZopfliOptions {\n        verbose: 0,\n        verbose_more: 0,\n        numiterations: 0,\n        blocksplitting: 0,\n        blocksplittinglast: 0,\n        blocksplittingmax: 0,\n    };\n    ZopfliInitOptions(&mut options);\n    options.verbose = 1;\n\n    println!(\"  Testing with verbose output enabled:\");\n\n    let mut out = Vec::new();\n    let in_data = TEST_DATA_MEDIUM.as_bytes();\n    let result = ZopfliCompress(&options, ZOPFLI_FORMAT_GZIP, Some(in_data), &mut out);\n\n    if result.is_err() || out.is_empty() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_verbose_options\", \"Verbose compression should work\");\n        return false;\n    }\n\n    println!(\"PASS: {}\", \"test_zopfli_verbose_options\");\n    true\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_zopfli.rs",
        "error": "",
        "dependent": [
            "ZopfliCompress",
            "ZopfliInitOptions",
            "ZopfliOptions",
            "test_data_medium"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "out",
            "outsize",
            "test_data_medium"
        ],
        "calle": [
            "free",
            "strlen",
            "ZopfliCompress",
            "ZopfliInitOptions",
            "printf"
        ],
        "calle_c": [
            "strlen",
            "printf",
            "free"
        ],
        "key": "test_zopfli_verbose_options",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_zopfli_deflate_direct": {
        "source_code": "static int test_zopfli_deflate_direct()\n{\n  ZopfliOptions options;\n  unsigned char *out = 0;\n  size_t outsize = 0;\n  unsigned char bp = 0;\n  ZopfliInitOptions(&options);\n  ZopfliDeflate(&options, 2, 1, (const unsigned char *) test_data_small, strlen(test_data_small), &bp, &out, &outsize);\n  do\n  {\n    if (!(out != 0))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Output buffer should not be NULL\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!(outsize > 0))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Output size should be greater than 0\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!verify_deflate_format(out, outsize))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Should produce valid deflate format\");\n      return 0;\n    }\n  }\n  while (0);\n  printf(\"  Direct deflate: %zu bytes (from %zu input bytes)\\n\", outsize, strlen(test_data_small));\n  free(out);\n  do\n  {\n    printf(\"PASS: %s\\n\", __func__);\n    return 1;\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn test_zopfli_deflate_direct() -> i32 {\n    let mut options = ZopfliOptions {\n        verbose: 0,\n        verbose_more: 0,\n        numiterations: 0,\n        blocksplitting: 0,\n        blocksplittinglast: 0,\n        blocksplittingmax: 0,\n    };\n    ZopfliInitOptions(&mut options);\n    \n    let mut out: Option<Vec<u8>> = Option::None;\n    let mut outsize = 0;\n    let mut bp = 0;\n    \n    ZopfliDeflate(\n        &options,\n        2,\n        true,\n        TEST_DATA_SMALL.as_bytes(),\n        &mut bp,\n        &mut out,\n        &mut outsize,\n    );\n    \n    // Check if output buffer is not None\n    if out.is_none() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_deflate_direct\", \"Output buffer should not be NULL\");\n        return 0;\n    }\n    \n    // Check if output size is greater than 0\n    if outsize == 0 {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_deflate_direct\", \"Output size should be greater than 0\");\n        return 0;\n    }\n    \n    // Verify deflate format\n    if !verify_deflate_format(out.as_deref(), outsize) {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_deflate_direct\", \"Should produce valid deflate format\");\n        return 0;\n    }\n    \n    println!(\n        \"  Direct deflate: {} bytes (from {} input bytes)\",\n        outsize,\n        TEST_DATA_SMALL.len()\n    );\n    \n    println!(\"PASS: {}\", \"test_zopfli_deflate_direct\");\n    1\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_zopfli.rs",
        "error": "",
        "dependent": [
            "ZopfliDeflate",
            "ZopfliInitOptions",
            "ZopfliOptions",
            "test_data_small",
            "verify_deflate_format"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "out",
            "outsize",
            "bp",
            "test_data_small"
        ],
        "calle": [
            "free",
            "strlen",
            "verify_deflate_format",
            "ZopfliInitOptions",
            "ZopfliDeflate",
            "printf"
        ],
        "calle_c": [
            "strlen",
            "printf",
            "free"
        ],
        "key": "test_zopfli_deflate_direct",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_zopfli_gzip_direct": {
        "source_code": "static int test_zopfli_gzip_direct()\n{\n  ZopfliOptions options;\n  unsigned char *out = 0;\n  size_t outsize = 0;\n  ZopfliInitOptions(&options);\n  ZopfliGzipCompress(&options, (const unsigned char *) test_data_medium, strlen(test_data_medium), &out, &outsize);\n  do\n  {\n    if (!(out != 0))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Output buffer should not be NULL\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!(outsize > 0))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Output size should be greater than 0\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!(outsize < strlen(test_data_medium)))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Compressed should be smaller than original\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!verify_gzip_header(out, outsize))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Should have valid gzip header\");\n      return 0;\n    }\n  }\n  while (0);\n  printf(\"  Gzip compression: %zu bytes (from %zu input bytes)\\n\", outsize, strlen(test_data_medium));\n  free(out);\n  do\n  {\n    printf(\"PASS: %s\\n\", __func__);\n    return 1;\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn test_zopfli_gzip_direct() -> bool {\n    let mut options = ZopfliOptions {\n        verbose: 0,\n        verbose_more: 0,\n        numiterations: 0,\n        blocksplitting: 0,\n        blocksplittinglast: 0,\n        blocksplittingmax: 0,\n    };\n    ZopfliInitOptions(&mut options);\n    \n    let mut out = Vec::new();\n    let input_data = TEST_DATA_MEDIUM.as_bytes();\n    \n    if let Err(e) = ZopfliGzipCompress(&options, Some(input_data), &mut out) {\n        println!(\"FAIL: {} - Compression failed: {}\", \"test_zopfli_gzip_direct\", e);\n        return false;\n    }\n    \n    if out.is_empty() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_gzip_direct\", \"Output buffer should not be NULL\");\n        return false;\n    }\n    \n    if out.len() == 0 {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_gzip_direct\", \"Output size should be greater than 0\");\n        return false;\n    }\n    \n    if out.len() >= input_data.len() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_gzip_direct\", \"Compressed should be smaller than original\");\n        return false;\n    }\n    \n    if !verify_gzip_header(Some(&out), out.len()) {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_gzip_direct\", \"Should have valid gzip header\");\n        return false;\n    }\n    \n    println!(\"  Gzip compression: {} bytes (from {} input bytes)\", out.len(), input_data.len());\n    \n    println!(\"PASS: {}\", \"test_zopfli_gzip_direct\");\n    true\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_zopfli.rs",
        "error": "",
        "dependent": [
            "ZopfliGzipCompress",
            "ZopfliInitOptions",
            "ZopfliOptions",
            "test_data_medium",
            "verify_gzip_header"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "out",
            "outsize",
            "test_data_medium"
        ],
        "calle": [
            "ZopfliGzipCompress",
            "free",
            "strlen",
            "ZopfliInitOptions",
            "verify_gzip_header",
            "printf"
        ],
        "calle_c": [
            "strlen",
            "printf",
            "free"
        ],
        "key": "test_zopfli_gzip_direct",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_zopfli_zlib_direct": {
        "source_code": "static int test_zopfli_zlib_direct()\n{\n  ZopfliOptions options;\n  unsigned char *out = 0;\n  size_t outsize = 0;\n  ZopfliInitOptions(&options);\n  ZopfliZlibCompress(&options, (const unsigned char *) test_data_medium, strlen(test_data_medium), &out, &outsize);\n  do\n  {\n    if (!(out != 0))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Output buffer should not be NULL\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!(outsize > 0))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Output size should be greater than 0\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!(outsize < strlen(test_data_medium)))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Compressed should be smaller than original\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!verify_zlib_header(out, outsize))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Should have valid zlib header\");\n      return 0;\n    }\n  }\n  while (0);\n  printf(\"  Zlib compression: %zu bytes (from %zu input bytes)\\n\", outsize, strlen(test_data_medium));\n  free(out);\n  do\n  {\n    printf(\"PASS: %s\\n\", __func__);\n    return 1;\n  }\n  while (0);\n}\n\n",
        "translated_code": "use std::io;\n\npub fn test_zopfli_zlib_direct() -> i32 {\n    let mut options = ZopfliOptions {\n        verbose: 0,\n        verbose_more: 0,\n        numiterations: 0,\n        blocksplitting: 0,\n        blocksplittinglast: 0,\n        blocksplittingmax: 0,\n    };\n    ZopfliInitOptions(&mut options);\n\n    let mut out = Vec::new();\n    let input_data = TEST_DATA_MEDIUM.as_bytes();\n    \n    if let Err(e) = ZopfliZlibCompress(&options, input_data, &mut out) {\n        println!(\"FAIL: {} - Compression failed: {}\", \"test_zopfli_zlib_direct\", e);\n        return 0;\n    }\n\n    let outsize = out.len();\n\n    if out.is_empty() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_zlib_direct\", \"Output buffer should not be NULL\");\n        return 0;\n    }\n\n    if outsize == 0 {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_zlib_direct\", \"Output size should be greater than 0\");\n        return 0;\n    }\n\n    if outsize >= input_data.len() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_zlib_direct\", \"Compressed should be smaller than original\");\n        return 0;\n    }\n\n    if !verify_zlib_header(Some(&out), outsize) {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_zlib_direct\", \"Should have valid zlib header\");\n        return 0;\n    }\n\n    println!(\"  Zlib compression: {} bytes (from {} input bytes)\", outsize, input_data.len());\n    println!(\"PASS: {}\", \"test_zopfli_zlib_direct\");\n    1\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_zopfli.rs",
        "error": "",
        "dependent": [
            "ZopfliInitOptions",
            "ZopfliOptions",
            "ZopfliZlibCompress",
            "test_data_medium",
            "verify_zlib_header"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "out",
            "outsize",
            "test_data_medium"
        ],
        "calle": [
            "verify_zlib_header",
            "free",
            "strlen",
            "ZopfliZlibCompress",
            "ZopfliInitOptions",
            "printf"
        ],
        "calle_c": [
            "strlen",
            "printf",
            "free"
        ],
        "key": "test_zopfli_zlib_direct",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_zopfli_compress_formats": {
        "source_code": "static int test_zopfli_compress_formats()\n{\n  ZopfliOptions options;\n  unsigned char *out_deflate = 0;\n  unsigned char *out_gzip = 0;\n  unsigned char *out_zlib = 0;\n  size_t outsize_deflate = 0;\n  size_t outsize_gzip = 0;\n  size_t outsize_zlib = 0;\n  ZopfliInitOptions(&options);\n  ZopfliCompress(&options, ZOPFLI_FORMAT_DEFLATE, (const unsigned char *) test_data_medium, strlen(test_data_medium), &out_deflate, &outsize_deflate);\n  ZopfliCompress(&options, ZOPFLI_FORMAT_GZIP, (const unsigned char *) test_data_medium, strlen(test_data_medium), &out_gzip, &outsize_gzip);\n  ZopfliCompress(&options, ZOPFLI_FORMAT_ZLIB, (const unsigned char *) test_data_medium, strlen(test_data_medium), &out_zlib, &outsize_zlib);\n  do\n  {\n    if (!((out_deflate != 0) && (outsize_deflate > 0)))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Deflate compression should work\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!((out_gzip != 0) && (outsize_gzip > 0)))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Gzip compression should work\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!((out_zlib != 0) && (outsize_zlib > 0)))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Zlib compression should work\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!(outsize_gzip > outsize_deflate))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Gzip should be larger than deflate\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!(outsize_zlib > outsize_deflate))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Zlib should be larger than deflate\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!verify_gzip_header(out_gzip, outsize_gzip))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Gzip should have valid header\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!verify_zlib_header(out_zlib, outsize_zlib))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Zlib should have valid header\");\n      return 0;\n    }\n  }\n  while (0);\n  do\n  {\n    if (!verify_deflate_format(out_deflate, outsize_deflate))\n    {\n      printf(\"FAIL: %s - %s\\n\", __func__, \"Deflate should have valid format\");\n      return 0;\n    }\n  }\n  while (0);\n  printf(\"  Deflate: %zu bytes, Gzip: %zu bytes, Zlib: %zu bytes\\n\", outsize_deflate, outsize_gzip, outsize_zlib);\n  free(out_deflate);\n  free(out_gzip);\n  free(out_zlib);\n  do\n  {\n    printf(\"PASS: %s\\n\", __func__);\n    return 1;\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn test_zopfli_compress_formats() -> bool {\n    let mut options = ZopfliOptions {\n        verbose: 0,\n        verbose_more: 0,\n        numiterations: 0,\n        blocksplitting: 0,\n        blocksplittinglast: 0,\n        blocksplittingmax: 0,\n    };\n    ZopfliInitOptions(&mut options);\n\n    let test_data = TEST_DATA_MEDIUM.as_bytes();\n    \n    let mut out_deflate = Vec::new();\n    let mut out_gzip = Vec::new();\n    let mut out_zlib = Vec::new();\n\n    // Compress in different formats\n    if ZopfliCompress(&options, ZopfliFormat::ZOPFLI_FORMAT_DEFLATE, Some(test_data), &mut out_deflate).is_err() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_compress_formats\", \"Deflate compression should work\");\n        return false;\n    }\n\n    if ZopfliCompress(&options, ZopfliFormat::ZOPFLI_FORMAT_GZIP, Some(test_data), &mut out_gzip).is_err() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_compress_formats\", \"Gzip compression should work\");\n        return false;\n    }\n\n    if ZopfliCompress(&options, ZopfliFormat::ZOPFLI_FORMAT_ZLIB, Some(test_data), &mut out_zlib).is_err() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_compress_formats\", \"Zlib compression should work\");\n        return false;\n    }\n\n    // Check output sizes\n    if out_deflate.is_empty() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_compress_formats\", \"Deflate compression should work\");\n        return false;\n    }\n\n    if out_gzip.is_empty() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_compress_formats\", \"Gzip compression should work\");\n        return false;\n    }\n\n    if out_zlib.is_empty() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_compress_formats\", \"Zlib compression should work\");\n        return false;\n    }\n\n    if out_gzip.len() <= out_deflate.len() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_compress_formats\", \"Gzip should be larger than deflate\");\n        return false;\n    }\n\n    if out_zlib.len() <= out_deflate.len() {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_compress_formats\", \"Zlib should be larger than deflate\");\n        return false;\n    }\n\n    // Verify headers\n    if !verify_gzip_header(Some(&out_gzip), out_gzip.len()) {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_compress_formats\", \"Gzip should have valid header\");\n        return false;\n    }\n\n    if !verify_zlib_header(Some(&out_zlib), out_zlib.len()) {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_compress_formats\", \"Zlib should have valid header\");\n        return false;\n    }\n\n    if !verify_deflate_format(Some(&out_deflate), out_deflate.len()) {\n        println!(\"FAIL: {} - {}\", \"test_zopfli_compress_formats\", \"Deflate should have valid format\");\n        return false;\n    }\n\n    println!(\"  Deflate: {} bytes, Gzip: {} bytes, Zlib: {} bytes\", \n        out_deflate.len(), out_gzip.len(), out_zlib.len());\n\n    println!(\"PASS: {}\", \"test_zopfli_compress_formats\");\n    true\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_zopfli.rs",
        "error": "",
        "dependent": [
            "ZopfliCompress",
            "ZopfliInitOptions",
            "ZopfliOptions",
            "test_data_medium",
            "verify_deflate_format",
            "verify_gzip_header",
            "verify_zlib_header"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "options",
            "out_deflate",
            "out_gzip",
            "out_zlib",
            "outsize_deflate",
            "outsize_gzip",
            "outsize_zlib",
            "test_data_medium"
        ],
        "calle": [
            "verify_zlib_header",
            "free",
            "strlen",
            "verify_deflate_format",
            "ZopfliCompress",
            "ZopfliInitOptions",
            "verify_gzip_header",
            "printf"
        ],
        "calle_c": [
            "strlen",
            "printf",
            "free"
        ],
        "key": "test_zopfli_compress_formats",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "main#test_zopfli": {
        "source_code": "int main(int argc, char *argv[])\n{\n  int verbose = 0;\n  if ((argc > 1) && (strcmp(argv[1], \"-v\") == 0))\n  {\n    verbose = 1;\n  }\n  printf(\"Starting Zopfli Test Suite (Zlib-Free Version)\\n\");\n  printf(\"===============================================\\n\\n\");\n  do\n  {\n    printf(\"Running %s...\\n\", \"test_zopfli_init_options\");\n    if (test_zopfli_init_options())\n    {\n      tests_passed += 1;\n    }\n    else\n    {\n      tests_failed += 1;\n    }\n    total_tests += 1;\n  }\n  while (0);\n  do\n  {\n    printf(\"Running %s...\\n\", \"test_zopfli_compress_formats\");\n    if (test_zopfli_compress_formats())\n    {\n      tests_passed += 1;\n    }\n    else\n    {\n      tests_failed += 1;\n    }\n    total_tests += 1;\n  }\n  while (0);\n  do\n  {\n    printf(\"Running %s...\\n\", \"test_zopfli_deflate_direct\");\n    if (test_zopfli_deflate_direct())\n    {\n      tests_passed += 1;\n    }\n    else\n    {\n      tests_failed += 1;\n    }\n    total_tests += 1;\n  }\n  while (0);\n  do\n  {\n    printf(\"Running %s...\\n\", \"test_zopfli_gzip_direct\");\n    if (test_zopfli_gzip_direct())\n    {\n      tests_passed += 1;\n    }\n    else\n    {\n      tests_failed += 1;\n    }\n    total_tests += 1;\n  }\n  while (0);\n  do\n  {\n    printf(\"Running %s...\\n\", \"test_zopfli_zlib_direct\");\n    if (test_zopfli_zlib_direct())\n    {\n      tests_passed += 1;\n    }\n    else\n    {\n      tests_failed += 1;\n    }\n    total_tests += 1;\n  }\n  while (0);\n  do\n  {\n    printf(\"Running %s...\\n\", \"test_zopfli_empty_input\");\n    if (test_zopfli_empty_input())\n    {\n      tests_passed += 1;\n    }\n    else\n    {\n      tests_failed += 1;\n    }\n    total_tests += 1;\n  }\n  while (0);\n  do\n  {\n    printf(\"Running %s...\\n\", \"test_zopfli_iterations\");\n    if (test_zopfli_iterations())\n    {\n      tests_passed += 1;\n    }\n    else\n    {\n      tests_failed += 1;\n    }\n    total_tests += 1;\n  }\n  while (0);\n  do\n  {\n    printf(\"Running %s...\\n\", \"test_zopfli_binary_data\");\n    if (test_zopfli_binary_data())\n    {\n      tests_passed += 1;\n    }\n    else\n    {\n      tests_failed += 1;\n    }\n    total_tests += 1;\n  }\n  while (0);\n  do\n  {\n    printf(\"Running %s...\\n\", \"test_zopfli_block_splitting\");\n    if (test_zopfli_block_splitting())\n    {\n      tests_passed += 1;\n    }\n    else\n    {\n      tests_failed += 1;\n    }\n    total_tests += 1;\n  }\n  while (0);\n  do\n  {\n    printf(\"Running %s...\\n\", \"test_zopfli_repetitive_data\");\n    if (test_zopfli_repetitive_data())\n    {\n      tests_passed += 1;\n    }\n    else\n    {\n      tests_failed += 1;\n    }\n    total_tests += 1;\n  }\n  while (0);\n  do\n  {\n    printf(\"Running %s...\\n\", \"test_zopfli_consistency\");\n    if (test_zopfli_consistency())\n    {\n      tests_passed += 1;\n    }\n    else\n    {\n      tests_failed += 1;\n    }\n    total_tests += 1;\n  }\n  while (0);\n  if (verbose)\n  {\n    do\n    {\n      printf(\"Running %s...\\n\", \"test_zopfli_verbose_options\");\n      if (test_zopfli_verbose_options())\n      {\n        tests_passed += 1;\n      }\n      else\n      {\n        tests_failed += 1;\n      }\n      total_tests += 1;\n    }\n    while (0);\n  }\n  printf(\"\\n===============================================\\n\");\n  printf(\"Test Results:\\n\");\n  printf(\"Total tests: %d\\n\", total_tests);\n  printf(\"Passed: %d\\n\", tests_passed);\n  printf(\"Failed: %d\\n\", tests_failed);\n  if (tests_failed == 0)\n  {\n    printf(\"SUCCESS: All tests passed! \u2713\\n\");\n  }\n  else\n  {\n    printf(\"FAILURE: %d test(s) failed \u2717\\n\", tests_failed);\n  }\n  printf(\"Success rate: %.1f%%\\n\", (((float) tests_passed) / total_tests) * 100);\n  return (tests_failed == 0) ? (0) : (1);\n}\n\n",
        "translated_code": "use std::env;\nuse std::process::exit;\nuse std::sync::atomic::{AtomicI32, Ordering};\n\nlazy_static::lazy_static! {\n    pub static ref VERBOSE: AtomicI32 = AtomicI32::new(0);\n}\n\npub fn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() > 1 && args[1] == \"-v\" {\n        VERBOSE.store(1, Ordering::SeqCst);\n    }\n\n    println!(\"Starting Zopfli Test Suite (Zlib-Free Version)\");\n    println!(\"===============================================\\n\");\n\n    // Test 1\n    println!(\"Running {}...\", \"test_zopfli_init_options\");\n    if test_zopfli_init_options() != 0 {\n        TESTS_PASSED.fetch_add(1, Ordering::SeqCst);\n    } else {\n        TESTS_FAILED.fetch_add(1, Ordering::SeqCst);\n    }\n    TOTAL_TESTS.fetch_add(1, Ordering::SeqCst);\n\n    // Test 2\n    println!(\"Running {}...\", \"test_zopfli_compress_formats\");\n    if test_zopfli_compress_formats() {\n        TESTS_PASSED.fetch_add(1, Ordering::SeqCst);\n    } else {\n        TESTS_FAILED.fetch_add(1, Ordering::SeqCst);\n    }\n    TOTAL_TESTS.fetch_add(1, Ordering::SeqCst);\n\n    // Test 3\n    println!(\"Running {}...\", \"test_zopfli_deflate_direct\");\n    if test_zopfli_deflate_direct() != 0 {\n        TESTS_PASSED.fetch_add(1, Ordering::SeqCst);\n    } else {\n        TESTS_FAILED.fetch_add(1, Ordering::SeqCst);\n    }\n    TOTAL_TESTS.fetch_add(1, Ordering::SeqCst);\n\n    // Test 4\n    println!(\"Running {}...\", \"test_zopfli_gzip_direct\");\n    if test_zopfli_gzip_direct() {\n        TESTS_PASSED.fetch_add(1, Ordering::SeqCst);\n    } else {\n        TESTS_FAILED.fetch_add(1, Ordering::SeqCst);\n    }\n    TOTAL_TESTS.fetch_add(1, Ordering::SeqCst);\n\n    // Test 5\n    println!(\"Running {}...\", \"test_zopfli_zlib_direct\");\n    if test_zopfli_zlib_direct() != 0 {\n        TESTS_PASSED.fetch_add(1, Ordering::SeqCst);\n    } else {\n        TESTS_FAILED.fetch_add(1, Ordering::SeqCst);\n    }\n    TOTAL_TESTS.fetch_add(1, Ordering::SeqCst);\n\n    // Test 6\n    println!(\"Running {}...\", \"test_zopfli_empty_input\");\n    if test_zopfli_empty_input() {\n        TESTS_PASSED.fetch_add(1, Ordering::SeqCst);\n    } else {\n        TESTS_FAILED.fetch_add(1, Ordering::SeqCst);\n    }\n    TOTAL_TESTS.fetch_add(1, Ordering::SeqCst);\n\n    // Test 7\n    println!(\"Running {}...\", \"test_zopfli_iterations\");\n    if test_zopfli_iterations() {\n        TESTS_PASSED.fetch_add(1, Ordering::SeqCst);\n    } else {\n        TESTS_FAILED.fetch_add(1, Ordering::SeqCst);\n    }\n    TOTAL_TESTS.fetch_add(1, Ordering::SeqCst);\n\n    // Test 8\n    println!(\"Running {}...\", \"test_zopfli_binary_data\");\n    if test_zopfli_binary_data() != 0 {\n        TESTS_PASSED.fetch_add(1, Ordering::SeqCst);\n    } else {\n        TESTS_FAILED.fetch_add(1, Ordering::SeqCst);\n    }\n    TOTAL_TESTS.fetch_add(1, Ordering::SeqCst);\n\n    // Test 9\n    println!(\"Running {}...\", \"test_zopfli_block_splitting\");\n    if test_zopfli_block_splitting() {\n        TESTS_PASSED.fetch_add(1, Ordering::SeqCst);\n    } else {\n        TESTS_FAILED.fetch_add(1, Ordering::SeqCst);\n    }\n    TOTAL_TESTS.fetch_add(1, Ordering::SeqCst);\n\n    // Test 10\n    println!(\"Running {}...\", \"test_zopfli_repetitive_data\");\n    if test_zopfli_repetitive_data() != 0 {\n        TESTS_PASSED.fetch_add(1, Ordering::SeqCst);\n    } else {\n        TESTS_FAILED.fetch_add(1, Ordering::SeqCst);\n    }\n    TOTAL_TESTS.fetch_add(1, Ordering::SeqCst);\n\n    // Test 11\n    println!(\"Running {}...\", \"test_zopfli_consistency\");\n    if test_zopfli_consistency() {\n        TESTS_PASSED.fetch_add(1, Ordering::SeqCst);\n    } else {\n        TESTS_FAILED.fetch_add(1, Ordering::SeqCst);\n    }\n    TOTAL_TESTS.fetch_add(1, Ordering::SeqCst);\n\n    // Optional verbose test\n    if VERBOSE.load(Ordering::SeqCst) != 0 {\n        println!(\"Running {}...\", \"test_zopfli_verbose_options\");\n        if test_zopfli_verbose_options() {\n            TESTS_PASSED.fetch_add(1, Ordering::SeqCst);\n        } else {\n            TESTS_FAILED.fetch_add(1, Ordering::SeqCst);\n        }\n        TOTAL_TESTS.fetch_add(1, Ordering::SeqCst);\n    }\n\n    println!(\"\\n===============================================\");\n    println!(\"Test Results:\");\n    println!(\"Total tests: {}\", TOTAL_TESTS.load(Ordering::SeqCst));\n    println!(\"Passed: {}\", TESTS_PASSED.load(Ordering::SeqCst));\n    println!(\"Failed: {}\", TESTS_FAILED.load(Ordering::SeqCst));\n\n    if TESTS_FAILED.load(Ordering::SeqCst) == 0 {\n        println!(\"SUCCESS: All tests passed! \u2713\");\n    } else {\n        println!(\"FAILURE: {} test(s) failed \u2717\", TESTS_FAILED.load(Ordering::SeqCst));\n    }\n\n    let success_rate = (TESTS_PASSED.load(Ordering::SeqCst) as f32 / TOTAL_TESTS.load(Ordering::SeqCst) as f32) * 100.0;\n    println!(\"Success rate: {:.1}%\", success_rate);\n\n    exit(if TESTS_FAILED.load(Ordering::SeqCst) == 0 { 0 } else { 1 });\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_zopfli.rs",
        "error": "",
        "dependent": [
            "test_zopfli_binary_data",
            "test_zopfli_block_splitting",
            "test_zopfli_compress_formats",
            "test_zopfli_consistency",
            "test_zopfli_deflate_direct",
            "test_zopfli_empty_input",
            "test_zopfli_gzip_direct",
            "test_zopfli_init_options",
            "test_zopfli_iterations",
            "test_zopfli_repetitive_data",
            "test_zopfli_verbose_options",
            "test_zopfli_zlib_direct",
            "tests_failed",
            "tests_passed",
            "total_tests"
        ],
        "params": [
            "int argc",
            "char *argv[]"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "argc",
            "argv",
            "verbose",
            "tests_passed",
            "tests_failed",
            "total_tests"
        ],
        "calle": [
            "test_zopfli_compress_formats",
            "test_zopfli_block_splitting",
            "test_zopfli_verbose_options",
            "test_zopfli_repetitive_data",
            "strcmp",
            "test_zopfli_gzip_direct",
            "test_zopfli_binary_data",
            "test_zopfli_deflate_direct",
            "test_zopfli_iterations",
            "test_zopfli_consistency",
            "test_zopfli_empty_input",
            "printf",
            "test_zopfli_zlib_direct",
            "test_zopfli_init_options"
        ],
        "calle_c": [
            "printf",
            "strcmp"
        ],
        "key": "main#test_zopfli",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    }
}
