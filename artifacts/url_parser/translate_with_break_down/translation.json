{
    "Category": {
        "source_code": "enum Category\n{\n  Scheme = 0x01,\n  Unreserved = 0x02,\n  GenDelim = 0x04,\n  SubDelim = 0x08,\n  PCharSlash = 0x10,\n  HexDigit = 0x20,\n  Query = 0x40,\n  Fragment = 0x40,\n  Userinfo = 0x80,\n  IPv6Char = 0x100\n}",
        "translated_code": "#[derive(Clone, Copy, Debug, PartialEq, Eq)]\npub enum Category {\n    Scheme = 0x01,\n    Unreserved = 0x02,\n    GenDelim = 0x04,\n    SubDelim = 0x08,\n    PCharSlash = 0x10,\n    HexDigit = 0x20,\n    Query = 0x40,\n    Fragment = 0x200,\n    Userinfo = 0x80,\n    IPv6Char = 0x100,\n}\n\n// Since Rust doesn't allow duplicate discriminant values in enums,\n// we provide a workaround using associated constants in an impl block\nimpl Category {\n    pub const QUERY: Self = Self::Query;\n    pub const FRAGMENT: Self = Self::Fragment;\n}",
        "hint": "special_types",
        "section": "src",
        "file": "Category.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Enum'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "url_key_value": {
        "source_code": "struct url_key_value\n{\n  const char *key;\n  const char *value;\n}",
        "translated_code": "#[derive(Clone)]\npub struct UrlKeyValue {\n    pub key: Option<String>,\n    pub value: Option<String>,\n}",
        "hint": "special_types",
        "section": "src",
        "file": "url_key_value.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "char_cat": {
        "source_code": "static const unsigned short char_cat[256] = {0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x0d8, 0x000, 0x004, 0x0d8, 0x0d0, 0x0d8, 0x0d8, 0x0d8, 0x0d8, 0x0d8, 0x0d9, 0x0d8, 0x0d3, 0x0d3, 0x054, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1d4, 0x0d8, 0x000, 0x0d8, 0x000, 0x044, 0x054, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x004, 0x000, 0x004, 0x000, 0x0d2, 0x000, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x000, 0x000, 0x000, 0x0d2, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000}",
        "translated_code": "pub static CHAR_CAT: [u16; 256] = [\n    0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, // 16\n    0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, // 32\n    0x000, 0x0d8, 0x000, 0x004, 0x0d8, 0x0d0, 0x0d8, 0x0d8, 0x0d8, 0x0d8, 0x0d8, 0x0d9, 0x0d8, 0x0d3, 0x0d3, 0x054, // 48\n    0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1d4, 0x0d8, 0x000, 0x0d8, 0x000, 0x044, // 64\n    0x054, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, // 80\n    0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x004, 0x000, 0x004, 0x000, 0x0d2, 0x000, // 96\n    0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, // 112\n    0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x000, 0x000, 0x000, 0x0d2, 0x000, 0x000, // 128\n    0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, // 144\n    0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, // 160\n    0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, // 176\n    0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, // 192\n    0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, // 208\n    0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, // 224\n    0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, // 240\n    0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000  // 256\n];",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "const unsigned short [256]",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "alnum": {
        "source_code": "const char * const alnum = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"",
        "translated_code": "pub const ALNUM: &[u8] = b\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "const char * const",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "unreserved": {
        "source_code": "const char * const unreserved = \"-._~\"",
        "translated_code": "pub const UNRESERVED: &'static str = \"-._~\";",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "const char * const",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "subdelim": {
        "source_code": "const char * const subdelim = \"!$&'()*+,;=\"",
        "translated_code": "pub const SUBDELIM: &str = \"!$&'()*+,;=\";",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "const char * const",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "URL_SCHEMES": {
        "source_code": "static const char *URL_SCHEMES[] = {\"aaa\", \"aaas\", \"about\", \"acap\", \"acct\", \"adiumxtra\", \"afp\", \"afs\", \"aim\", \"apt\", \"attachment\", \"aw\", \"beshare\", \"bitcoin\", \"bolo\", \"callto\", \"cap\", \"chrome\", \"crome-extension\", \"com-evenbrite-attendee\", \"cid\", \"coap\", \"coaps\", \"content\", \"crid\", \"cvs\", \"data\", \"dav\", \"dict\", \"lna-playsingle\", \"dln-playcontainer\", \"dns\", \"dtn\", \"dvb\", \"ed2k\", \"facetime\", \"fax\", \"feed\", \"file\", \"finger\", \"fish\", \"ftp\", \"geo\", \"gg\", \"git\", \"gizmoproject\", \"go\", \"gopher\", \"gtalk\", \"h323\", \"hcp\", \"http\", \"https\", \"iax\", \"icap\", \"icon\", \"im\", \"imap\", \"info\", \"ipn\", \"ipp\", \"irc\", \"irc6\", \"ircs\", \"iris\", \"iris.beep\", \"iris.xpc\", \"iris.xpcs\", \"iris.lws\", \"itms\", \"jabber\", \"jar\", \"jms\", \"keyparc\", \"lastfm\", \"ldap\", \"ldaps\", \"magnet\", \"mailserver\", \"mailto\", \"maps\", \"market\", \"message\", \"mid\", \"mms\", \"modem\", \"ms-help\", \"mssettings-power\", \"msnim\", \"msrp\", \"msrps\", \"mtqp\", \"mumble\", \"mupdate\", \"mvn\", \"news\", \"nfs\", \"ni\", \"nih\", \"nntp\", \"notes\", \"oid\", \"paquelocktoken\", \"pack\", \"palm\", \"paparazzi\", \"pkcs11\", \"platform\", \"pop\", \"pres\", \"prospero\", \"proxy\", \"psyc\", \"query\", \"reload\", \"res\", \"resource\", \"rmi\", \"rsync\", \"rtmp\", \"rtsp\", \"secondlife\", \"service\", \"session\", \"sftp\", \"sgn\", \"shttp\", \"sieve\", \"sip\", \"sips\", \"skype\", \"smb\", \"sms\", \"snews\", \"snmp\", \"soap.beep\", \"soap.beeps\", \"soldat\", \"spotify\", \"ssh\", \"steam\", \"svn\", \"tag\", \"teamspeak\", \"tel\", \"telnet\", \"tftp\", \"things\", \"thismessage\", \"tn3270\", \"tip\", \"tv\", \"udp\", \"unreal\", \"urn\", \"ut2004\", \"vemmi\", \"ventrilo\", \"videotex\", \"view-source\", \"wais\", \"webcal\", \"ws\", \"wss\", \"wtai\", \"wyciwyg\", \"xcon\", \"xcon-userid\", \"xfire\", \"xmlrpc.beep\", \"xmlrpc.beeps\", \"xmpp\", \"xri\", \"ymsgr\", \"javascript\", \"jdbc\", \"doi\"}",
        "translated_code": "lazy_static! {\n    pub static ref URL_SCHEMES: [&'static str; 177] = [\n        \"aaa\", \"aaas\", \"about\", \"acap\", \"acct\", \"adiumxtra\", \"afp\", \"afs\",\n        \"aim\", \"apt\", \"attachment\", \"aw\", \"beshare\", \"bitcoin\", \"bolo\", \"callto\",\n        \"cap\", \"chrome\", \"crome-extension\", \"com-evenbrite-attendee\", \"cid\", \"coap\", \"coaps\", \"content\",\n        \"crid\", \"cvs\", \"data\", \"dav\", \"dict\", \"lna-playsingle\", \"dln-playcontainer\", \"dns\",\n        \"dtn\", \"dvb\", \"ed2k\", \"facetime\", \"fax\", \"feed\", \"file\", \"finger\",\n        \"fish\", \"ftp\", \"geo\", \"gg\", \"git\", \"gizmoproject\", \"go\", \"gopher\",\n        \"gtalk\", \"h323\", \"hcp\", \"http\", \"https\", \"iax\", \"icap\", \"icon\",\n        \"im\", \"imap\", \"info\", \"ipn\", \"ipp\", \"irc\", \"irc6\", \"ircs\",\n        \"iris\", \"iris.beep\", \"iris.xpc\", \"iris.xpcs\", \"iris.lws\", \"itms\", \"jabber\", \"jar\",\n        \"jms\", \"keyparc\", \"lastfm\", \"ldap\", \"ldaps\", \"magnet\", \"mailserver\", \"mailto\",\n        \"maps\", \"market\", \"message\", \"mid\", \"mms\", \"modem\", \"ms-help\", \"mssettings-power\",\n        \"msnim\", \"msrp\", \"msrps\", \"mtqp\", \"mumble\", \"mupdate\", \"mvn\", \"news\",\n        \"nfs\", \"ni\", \"nih\", \"nntp\", \"notes\", \"oid\", \"paquelocktoken\", \"pack\",\n        \"palm\", \"paparazzi\", \"pkcs11\", \"platform\", \"pop\", \"pres\", \"prospero\", \"proxy\",\n        \"psyc\", \"query\", \"reload\", \"res\", \"resource\", \"rmi\", \"rsync\", \"rtmp\",\n        \"rtsp\", \"secondlife\", \"service\", \"session\", \"sftp\", \"sgn\", \"shttp\", \"sieve\",\n        \"sip\", \"sips\", \"skype\", \"smb\", \"sms\", \"snews\", \"snmp\", \"soap.beep\",\n        \"soap.beeps\", \"soldat\", \"spotify\", \"ssh\", \"steam\", \"svn\", \"tag\", \"teamspeak\",\n        \"tel\", \"telnet\", \"tftp\", \"things\", \"thismessage\", \"tn3270\", \"tip\", \"tv\",\n        \"udp\", \"unreal\", \"urn\", \"ut2004\", \"vemmi\", \"ventrilo\", \"videotex\", \"view-source\",\n        \"wais\", \"webcal\", \"ws\", \"wss\", \"wtai\", \"wyciwyg\", \"xcon\", \"xcon-userid\",\n        \"xfire\", \"xmlrpc.beep\", \"xmlrpc.beeps\", \"xmpp\", \"xri\", \"ymsgr\", \"javascript\", \"jdbc\",\n        \"doi\"\n    ];\n}",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "const char *[]",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "url_is_ssh": {
        "source_code": "bool url_is_ssh(const char *str)\n{\n  if ((0 == strcmp(str, \"ssh\")) || (0 == strcmp(str, \"git\")))\n  {\n    return 1;\n  }\n  return 0;\n}\n\n",
        "translated_code": "pub fn url_is_ssh(str: &str) -> bool {\n    str == \"ssh\" || str == \"git\"\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [],
        "header": "bool url_is_ssh(const char *str)",
        "params": [
            "const char *str"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "str"
        ],
        "calle": [
            "strcmp"
        ],
        "calle_c": [
            "strcmp"
        ],
        "key": "url_is_ssh",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "strdup": {
        "source_code": "char *strdup(const char *str)\n{\n  const int n = strlen(str) + 1;\n  char *dup = (char *) malloc(n);\n  if (dup)\n  {\n    strcpy(dup, str);\n  }\n  return dup;\n}\n\n",
        "translated_code": "pub fn strdup(str: Option<&str>) -> Option<String> {\n    // Check for NULL input (None in Rust)\n    let str = str?;\n\n    // Calculate length and allocate memory (handled by String in Rust)\n    let dup = str.to_string();\n\n    Some(dup)\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [],
        "params": [
            "const char *str"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "str",
            "n",
            "dup"
        ],
        "calle": [
            "malloc",
            "strcpy",
            "strlen"
        ],
        "calle_c": [
            "malloc",
            "strcpy",
            "strlen"
        ],
        "key": "strdup",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "unhex": {
        "source_code": "static int unhex(const char *s)\n{\n  if (((*s) >= '0') && ((*s) <= '9'))\n  {\n    return (*s) - '0';\n  }\n  if (((*s) >= 'A') && ((*s) <= 'F'))\n  {\n    return ((*s) - 'A') + 10;\n  }\n  if (((*s) >= 'a') && ((*s) <= 'f'))\n  {\n    return ((*s) - 'a') + 10;\n  }\n  return -1;\n}\n\n",
        "translated_code": "pub fn unhex(s: Option<&str>) -> i32 {\n    // Check if input is None (equivalent to NULL in C)\n    let s = match s {\n        Some(s) => s,\n        None => return -1,\n    };\n\n    // Get the first character as a char (Rust handles UTF-8 properly)\n    let c = match s.chars().next() {\n        Some(c) => c,\n        None => return -1,\n    };\n\n    match c {\n        '0'..='9' => (c as i32) - ('0' as i32),\n        'A'..='F' => (c as i32) - ('A' as i32) + 10,\n        'a'..='f' => (c as i32) - ('a' as i32) + 10,\n        _ => -1,\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [],
        "params": [
            "const char *s"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "s"
        ],
        "calle": [],
        "calle_c": [],
        "key": "unhex",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "scan_decimal_number": {
        "source_code": "static char *scan_decimal_number(char *start)\n{\n  char *p = start;\n  unsigned int p_idx = 0;\n  while ((p[p_idx] >= '0') && (p[p_idx] <= '9'))\n  {\n    p_idx += 1;\n  }\n\n  return ((&p[p_idx]) != start) ? (p) : (0);\n}\n\n",
        "translated_code": "pub fn scan_decimal_number(start: Option<&str>) -> Option<&str> {\n    // Check if input is None (equivalent to NULL check in C)\n    let start = start?;\n    \n    let mut p_idx = 0;\n    let bytes = start.as_bytes();\n    \n    // Iterate through the string while characters are digits\n    while p_idx < bytes.len() && bytes[p_idx].is_ascii_digit() {\n        p_idx += 1;\n    }\n    \n    // Return Some(&start[..p_idx]) if we found digits, None otherwise\n    if p_idx > 0 {\n        Some(&start[..p_idx])\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [],
        "params": [
            "char *start"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "start",
            "p",
            "p_idx"
        ],
        "calle": [],
        "calle_c": [],
        "key": "scan_decimal_number",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "url_data_t": {
        "source_code": "typedef struct url_data\n{\n  char *whole_url;\n  const char *protocol;\n  const char *userinfo;\n  const char *host;\n  const char *port;\n  const char *path;\n  const struct url_key_value *query;\n  const char *fragment;\n} url_data_t",
        "translated_code": "#[derive(Clone)]\npub struct UrlData {\n    pub whole_url: Option<String>,\n    pub protocol: Option<String>,\n    pub userinfo: Option<String>,\n    pub host: Option<String>,\n    pub port: Option<String>,\n    pub path: Option<String>,\n    pub query: Option<UrlKeyValue>,\n    pub fragment: Option<String>,\n}",
        "hint": "special_types",
        "section": "src",
        "file": "url_data_t.rs",
        "error": "",
        "dependent": [
            "url_key_value"
        ],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "url_is_protocol": {
        "source_code": "bool url_is_protocol(const char *str)\n{\n  const unsigned count = (sizeof(URL_SCHEMES)) / (sizeof(URL_SCHEMES[0]));\n  for (unsigned i = 0; i < count; i += 1)\n  {\n    if (0 == strcmp(URL_SCHEMES[i], str))\n    {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\n",
        "translated_code": "use lazy_static::lazy_static;\n\nlazy_static! {\n    pub static ref URL_SCHEMES: [&'static str; 177] = [\n        \"aaa\", \"aaas\", \"about\", \"acap\", \"acct\", \"adiumxtra\", \"afp\", \"afs\",\n        \"aim\", \"apt\", \"attachment\", \"aw\", \"beshare\", \"bitcoin\", \"bolo\", \"callto\",\n        \"cap\", \"chrome\", \"crome-extension\", \"com-evenbrite-attendee\", \"cid\", \"coap\", \"coaps\", \"content\",\n        \"crid\", \"cvs\", \"data\", \"dav\", \"dict\", \"lna-playsingle\", \"dln-playcontainer\", \"dns\",\n        \"dtn\", \"dvb\", \"ed2k\", \"facetime\", \"fax\", \"feed\", \"file\", \"finger\",\n        \"fish\", \"ftp\", \"geo\", \"gg\", \"git\", \"gizmoproject\", \"go\", \"gopher\",\n        \"gtalk\", \"h323\", \"hcp\", \"http\", \"https\", \"iax\", \"icap\", \"icon\",\n        \"im\", \"imap\", \"info\", \"ipn\", \"ipp\", \"irc\", \"irc6\", \"ircs\",\n        \"iris\", \"iris.beep\", \"iris.xpc\", \"iris.xpcs\", \"iris.lws\", \"itms\", \"jabber\", \"jar\",\n        \"jms\", \"keyparc\", \"lastfm\", \"ldap\", \"ldaps\", \"magnet\", \"mailserver\", \"mailto\",\n        \"maps\", \"market\", \"message\", \"mid\", \"mms\", \"modem\", \"ms-help\", \"mssettings-power\",\n        \"msnim\", \"msrp\", \"msrps\", \"mtqp\", \"mumble\", \"mupdate\", \"mvn\", \"news\",\n        \"nfs\", \"ni\", \"nih\", \"nntp\", \"notes\", \"oid\", \"paquelocktoken\", \"pack\",\n        \"palm\", \"paparazzi\", \"pkcs11\", \"platform\", \"pop\", \"pres\", \"prospero\", \"proxy\",\n        \"psyc\", \"query\", \"reload\", \"res\", \"resource\", \"rmi\", \"rsync\", \"rtmp\",\n        \"rtsp\", \"secondlife\", \"service\", \"session\", \"sftp\", \"sgn\", \"shttp\", \"sieve\",\n        \"sip\", \"sips\", \"skype\", \"smb\", \"sms\", \"snews\", \"snmp\", \"soap.beep\",\n        \"soap.beeps\", \"soldat\", \"spotify\", \"ssh\", \"steam\", \"svn\", \"tag\", \"teamspeak\",\n        \"tel\", \"telnet\", \"tftp\", \"things\", \"thismessage\", \"tn3270\", \"tip\", \"tv\",\n        \"udp\", \"unreal\", \"urn\", \"ut2004\", \"vemmi\", \"ventrilo\", \"videotex\", \"view-source\",\n        \"wais\", \"webcal\", \"ws\", \"wss\", \"wtai\", \"wyciwyg\", \"xcon\", \"xcon-userid\",\n        \"xfire\", \"xmlrpc.beep\", \"xmlrpc.beeps\", \"xmpp\", \"xri\", \"ymsgr\", \"javascript\", \"jdbc\",\n        \"doi\"\n    ];\n}\n\npub fn url_is_protocol(str: Option<&str>) -> bool {\n    // Check if input is None (equivalent to NULL check in C)\n    if str.is_none() {\n        return false;\n    }\n    let str = str.unwrap();\n\n    // Iterate through URL_SCHEMES and compare strings\n    for scheme in URL_SCHEMES.iter() {\n        if *scheme == str {\n            return true;\n        }\n    }\n    \n    false\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "URL_SCHEMES"
        ],
        "header": "bool url_is_protocol(const char *str)",
        "params": [
            "const char *str"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "str",
            "count",
            "i",
            "URL_SCHEMES"
        ],
        "calle": [
            "strcmp"
        ],
        "calle_c": [
            "strcmp"
        ],
        "key": "url_is_protocol",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "url_get_scheme": {
        "source_code": "char *url_get_scheme(const char *url)\n{\n  char *protocol = (char *) malloc(32);\n  if (!protocol)\n  {\n    return 0;\n  }\n  sscanf(url, \"%[^://]\", protocol);\n  if (url_is_protocol(protocol))\n  {\n    return protocol;\n  }\n  free(protocol);\n  return 0;\n}\n\n",
        "translated_code": "pub fn url_get_scheme(url: Option<&str>) -> Option<String> {\n    // Check for NULL input (None in Rust)\n    let url = url?;\n\n    // Extract the protocol part before \"://\"\n    let protocol_end = url.find(\"://\").unwrap_or(url.len());\n    let protocol = &url[..protocol_end];\n\n    // Check if the protocol is valid using the provided function\n    if url_is_protocol(Some(protocol)) {\n        Some(protocol.to_string())\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "url_is_protocol"
        ],
        "header": "char *url_get_scheme(const char *url)",
        "params": [
            "const char *url"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "url",
            "protocol"
        ],
        "calle": [
            "free",
            "url_is_protocol",
            "malloc",
            "sscanf"
        ],
        "calle_c": [
            "free",
            "malloc",
            "sscanf"
        ],
        "key": "url_get_scheme",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "url_get_protocol": {
        "source_code": "inline char *url_get_protocol(const char *url)\n{\n  return url_get_scheme(url);\n}\n\n",
        "translated_code": "pub fn url_get_protocol(url: Option<&str>) -> Option<String> {\n    url_get_scheme(url)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test.rs",
        "error": "",
        "dependent": [
            "url_get_scheme"
        ],
        "params": [
            "const char *url"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "url"
        ],
        "calle": [
            "url_get_scheme"
        ],
        "calle_c": [],
        "key": "url_get_protocol",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "scan_part": {
        "source_code": "static char *scan_part(char *start, enum Category category, char delimiter1, char delimiter2)\n{\n  char *p = start;\n  unsigned int p_idx = 0;\n  for (;;)\n  {\n    if (((p[p_idx] == '\\0') || (p[p_idx] == delimiter1)) || (p[p_idx] == delimiter2))\n    {\n      return p;\n    }\n    if (char_cat[(unsigned char) p[p_idx]] & category)\n    {\n      p_idx += 1;\n    }\n    else\n    {\n      return 0;\n    }\n  }\n\n}\n\n",
        "translated_code": "pub fn scan_part(start: &str, category: Category, delimiter1: char, delimiter2: char) -> Option<&str> {\n    let mut p_idx = 0;\n    let bytes = start.as_bytes();\n    \n    loop {\n        let current_char = bytes.get(p_idx).copied()?;\n        if current_char == b'\\0' || current_char == delimiter1 as u8 || current_char == delimiter2 as u8 {\n            return Some(&start[..p_idx]);\n        }\n        \n        if (CHAR_CAT[current_char as usize] & category as u16) != 0 {\n            p_idx += 1;\n        } else {\n            return None;\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "Category",
            "char_cat"
        ],
        "params": [
            "char *start",
            "enum Category category",
            "char delimiter1",
            "char delimiter2"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "start",
            "category",
            "delimiter1",
            "delimiter2",
            "p",
            "p_idx",
            "char_cat"
        ],
        "calle": [],
        "calle_c": [],
        "key": "scan_part",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "helper_url_parse_3": {
        "source_code": "void helper_url_parse_3(unsigned int * const p_idx_ref, unsigned int * const hostname_end_idx_ref, url_data_t * const data, char * const p, const char * const p_end, const bool is_ssh, char * const hostname_end)\n{\n  unsigned int p_idx = *p_idx_ref;\n  unsigned int hostname_end_idx = *hostname_end_idx_ref;\n  p_idx += 1;\n  hostname_end_idx = scan_part(p, IPv6Char, ']', '\\0');\n  if (!(&hostname_end[hostname_end_idx]))\n  {\n    do\n    {\n      fprintf(stderr, \"ERROR %s Line %u! p=\u00ab%s\u00bb\\n\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 234, p);\n      goto error;\n    }\n    while (0);\n  }\n  hostname_end[hostname_end_idx] = '\\0';\n  data->host = &p[p_idx];\n  hostname_end_idx += 1;\n  if ((((&hostname_end[hostname_end_idx]) < p_end) && (!is_ssh)) && (hostname_end[hostname_end_idx] == ':'))\n  {\n    char *port_end = scan_decimal_number((&hostname_end[hostname_end_idx]) + 1);\n    if (port_end)\n    {\n      data->port = (&hostname_end[hostname_end_idx]) + 1;\n      p_idx = port_end;\n    }\n    else\n    {\n      do\n      {\n        fprintf(stderr, \"ERROR %s Line %u! p=\u00ab%s\u00bb\\n\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 247, p);\n        goto error;\n      }\n      while (0);\n    }\n  }\n  else\n  {\n    p_idx = &hostname_end[hostname_end_idx];\n  }\n  *p_idx_ref = p_idx;\n  *hostname_end_idx_ref = hostname_end_idx;\n}\n\n",
        "translated_code": "pub fn helper_url_parse_3(\n    p_idx_ref: &mut u32,\n    hostname_end_idx_ref: &mut u32,\n    data: &mut UrlData,\n    p: &str,\n    p_end: &str,\n    is_ssh: bool,\n    hostname_end: &mut String,  // Changed from &mut str to &mut String\n) -> Result<(), String> {\n    let mut p_idx = *p_idx_ref;\n    let mut hostname_end_idx = *hostname_end_idx_ref;\n    \n    p_idx += 1;\n    \n    // Convert p_idx to usize for string slicing\n    let p_idx_usize = p_idx as usize;\n    if p_idx_usize >= p.len() {\n        return Err(\"Index out of bounds\".to_string());\n    }\n\n    let scan_result = scan_part(&p[p_idx_usize..], Category::IPv6Char, ']', '\\0');\n    hostname_end_idx = match scan_result {\n        Some(s) => s.len() as u32,\n        None => {\n            eprintln!(\"ERROR {} Line {}! p=\u00ab{}\u00bb\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 234, p);\n            return Err(\"Failed to scan part\".to_string());\n        }\n    };\n\n    if hostname_end.len() <= hostname_end_idx as usize {\n        eprintln!(\"ERROR {} Line {}! p=\u00ab{}\u00bb\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 234, p);\n        return Err(\"Invalid hostname_end index\".to_string());\n    }\n\n    // Truncate the hostname_end string directly\n    hostname_end.truncate(hostname_end_idx as usize);\n\n    data.host = Some(p[p_idx_usize..].to_string());\n\n    hostname_end_idx += 1;\n\n    if (hostname_end_idx as usize) < p_end.len() && !is_ssh && hostname_end.chars().nth(hostname_end_idx as usize) == Some(':') {\n        let port_start = (hostname_end_idx + 1) as usize;\n        let port_end = match scan_decimal_number(Some(&hostname_end[port_start..])) {\n            Some(end) => end,\n            None => {\n                eprintln!(\"ERROR {} Line {}! p=\u00ab{}\u00bb\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 247, p);\n                return Err(\"Failed to scan decimal number\".to_string());\n            }\n        };\n\n        data.port = Some(hostname_end[port_start..port_start + port_end.len()].to_string());\n        p_idx = (port_start + port_end.len()) as u32;\n    } else {\n        p_idx = hostname_end_idx;\n    }\n\n    *p_idx_ref = p_idx;\n    *hostname_end_idx_ref = hostname_end_idx;\n\n    Ok(())\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "scan_decimal_number",
            "scan_part",
            "url_data_t"
        ],
        "params": [
            "unsigned int * const p_idx_ref",
            "unsigned int * const hostname_end_idx_ref",
            "url_data_t * const data",
            "char * const p",
            "const char * const p_end",
            "const bool is_ssh",
            "char * const hostname_end"
        ],
        "lifetime_hint": [
            "p_idx_ref is a mutable refrence to unsigned int",
            "hostname_end_idx_ref is a mutable refrence to unsigned int"
        ],
        "global_variables": [
            "p_idx_ref",
            "hostname_end_idx_ref",
            "data",
            "p",
            "p_end",
            "is_ssh",
            "hostname_end",
            "p_idx",
            "hostname_end_idx",
            "port_end"
        ],
        "calle": [
            "scan_decimal_number",
            "scan_part",
            "fprintf"
        ],
        "calle_c": [
            "fprintf"
        ],
        "key": "helper_url_parse_3",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "helper_url_parse_2": {
        "source_code": "void helper_url_parse_2(unsigned int * const p_idx_ref, unsigned int * const hostname_end_idx_ref, url_data_t * const data, char * const p, const bool is_ssh, char * const hostname_end)\n{\n  unsigned int p_idx = *p_idx_ref;\n  unsigned int hostname_end_idx = *hostname_end_idx_ref;\n  hostname_end_idx = scan_part(p, Unreserved | SubDelim, ':', '/');\n  if (!(&hostname_end[hostname_end_idx]))\n  {\n    do\n    {\n      fprintf(stderr, \"ERROR %s Line %u! p=\u00ab%s\u00bb\\n\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 255, p);\n      goto error;\n    }\n    while (0);\n  }\n  data->host = &p[p_idx];\n  if ((!is_ssh) && (hostname_end[hostname_end_idx] == ':'))\n  {\n    hostname_end[hostname_end_idx] = '\\0';\n    char *port_end = scan_decimal_number((&hostname_end[hostname_end_idx]) + 1);\n    if (port_end)\n    {\n      data->port = (&hostname_end[hostname_end_idx]) + 1;\n      p_idx = port_end;\n    }\n    else\n    {\n      do\n      {\n        fprintf(stderr, \"ERROR %s Line %u! p=\u00ab%s\u00bb\\n\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 267, p);\n        goto error;\n      }\n      while (0);\n    }\n  }\n  else\n  {\n    p_idx = &hostname_end[hostname_end_idx];\n  }\n  *p_idx_ref = p_idx;\n  *hostname_end_idx_ref = hostname_end_idx;\n}\n\n",
        "translated_code": "pub fn helper_url_parse_2(\n    p_idx_ref: &mut u32,\n    hostname_end_idx_ref: &mut u32,\n    data: &mut UrlData,\n    p: &str,\n    is_ssh: bool,\n    hostname_end: &str,\n) {\n    let mut p_idx = *p_idx_ref;\n    let mut hostname_end_idx = *hostname_end_idx_ref;\n\n    // Scan part and handle potential error\n    let scanned = scan_part(p, Category::Unreserved, ':', '/')\n        .or_else(|| scan_part(p, Category::SubDelim, ':', '/'));\n    hostname_end_idx = match scanned {\n        Some(s) => s.len().try_into().unwrap(),\n        None => {\n            eprintln!(\"ERROR {} Line {}! p=\u00ab{}\u00bb\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 255, p);\n            return;\n        }\n    };\n\n    // Check if hostname_end index is valid\n    if hostname_end.get(hostname_end_idx as usize..).is_none() {\n        eprintln!(\"ERROR {} Line {}! p=\u00ab{}\u00bb\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 255, p);\n        return;\n    }\n\n    data.host = Some(p[p_idx as usize..].to_string());\n\n    if !is_ssh && hostname_end.chars().nth(hostname_end_idx as usize) == Some(':') {\n        // In Rust we can't modify the string directly, so we'll work with slices\n        let port_start = hostname_end_idx + 1;\n        let port_end = scan_decimal_number(hostname_end.get(port_start as usize..));\n\n        if let Some(port_end_str) = port_end {\n            data.port = Some(hostname_end[port_start as usize..port_start as usize + port_end_str.len()].to_string());\n            p_idx = port_start + port_end_str.len() as u32;\n        } else {\n            eprintln!(\"ERROR {} Line {}! p=\u00ab{}\u00bb\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 267, p);\n            return;\n        }\n    } else {\n        p_idx = hostname_end_idx;\n    }\n\n    *p_idx_ref = p_idx;\n    *hostname_end_idx_ref = hostname_end_idx;\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "scan_decimal_number",
            "scan_part",
            "url_data_t"
        ],
        "params": [
            "unsigned int * const p_idx_ref",
            "unsigned int * const hostname_end_idx_ref",
            "url_data_t * const data",
            "char * const p",
            "const bool is_ssh",
            "char * const hostname_end"
        ],
        "lifetime_hint": [
            "p_idx_ref is a mutable refrence to unsigned int",
            "hostname_end_idx_ref is a mutable refrence to unsigned int"
        ],
        "global_variables": [
            "p_idx_ref",
            "hostname_end_idx_ref",
            "data",
            "p",
            "is_ssh",
            "hostname_end",
            "p_idx",
            "hostname_end_idx",
            "port_end"
        ],
        "calle": [
            "scan_decimal_number",
            "scan_part",
            "fprintf"
        ],
        "calle_c": [
            "fprintf"
        ],
        "key": "helper_url_parse_2",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "decode_percent": {
        "source_code": "static char *decode_percent(char *s)\n{\n  char *in = s;\n  unsigned int in_idx = 0;\n  char *out = s;\n  unsigned int out_idx = 0;\n  while (in[in_idx])\n  {\n    if (in[in_idx] == '%')\n    {\n      in_idx += 1;\n      const int high = unhex(in);\n      if ((high < 0) || (in[in_idx] == '\\0'))\n      {\n        return 0;\n      }\n      in_idx += 1;\n      const int low = unhex(in);\n      if ((low < 0) || (in[in_idx] == '\\0'))\n      {\n        return 0;\n      }\n      out[out_idx] = (char) ((high * 16u) + low);\n      out_idx += 1;\n      in_idx += 1;\n    }\n    else\n    {\n      out[out_idx] = in[in_idx];\n      in_idx += 1;\n      out_idx += 1;\n    }\n  }\n\n  out[out_idx] = '\\0';\n  return s;\n}\n\n",
        "translated_code": "pub fn decode_percent(s: &mut str) -> Option<&str> {\n    let bytes = unsafe { s.as_bytes_mut() }; // Safe because we're working with UTF-8\n    let mut in_idx = 0;\n    let mut out_idx = 0;\n\n    while in_idx < bytes.len() {\n        if bytes[in_idx] == b'%' {\n            in_idx += 1;\n            if in_idx >= bytes.len() {\n                return None;\n            }\n\n            let high = unhex(Some(str::from_utf8(&bytes[in_idx..in_idx + 1]).ok()?));\n            if high < 0 {\n                return None;\n            }\n            in_idx += 1;\n\n            if in_idx >= bytes.len() {\n                return None;\n            }\n\n            let low = unhex(Some(str::from_utf8(&bytes[in_idx..in_idx + 1]).ok()?));\n            if low < 0 {\n                return None;\n            }\n            in_idx += 1;\n\n            bytes[out_idx] = (high * 16 + low) as u8;\n            out_idx += 1;\n        } else {\n            bytes[out_idx] = bytes[in_idx];\n            in_idx += 1;\n            out_idx += 1;\n        }\n    }\n\n    if out_idx < bytes.len() {\n        bytes[out_idx] = b'\\0';\n    }\n\n    Some(unsafe { str::from_utf8(&bytes[..out_idx]).unwrap() })\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "unhex"
        ],
        "params": [
            "char *s"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "s",
            "in",
            "in_idx",
            "out",
            "out_idx",
            "high",
            "low"
        ],
        "calle": [
            "unhex"
        ],
        "calle_c": [],
        "key": "decode_percent",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "parse_query_string": {
        "source_code": "static struct url_key_value *parse_query_string(char *begin, char *end)\n{\n  unsigned elements = 1;\n  for (const char *p = begin; (&p[p_idx]) != end; p_idx += 1)\n  {\n    if ((p[p_idx] == '&') || (p[p_idx] == ';'))\n    {\n      elements += 1;\n    }\n  }\n\n  unsigned int p_idx = 0;\n  struct url_key_value *kv = calloc(elements + 1, sizeof(struct url_key_value));\n  if (!kv)\n  {\n    return 0;\n  }\n  char *p = begin;\n  unsigned int p_idx = 0;\n  for (unsigned element = 0; (element <= elements) && ((&p[p_idx]) < end); element += 1)\n  {\n    char *key = p;\n    char *kv_end = scan_part(p, Query, '&', ';');\n    if (!kv_end)\n    {\n      do\n      {\n        fprintf(stderr, \"ERROR %s Line %u! p=\u00ab%s\u00bb\\n\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 153, p);\n        goto error;\n      }\n      while (0);\n    }\n    *kv_end = '\\0';\n    char *key_end = scan_part(p, Query, '=', '\\0');\n    const bool has_value = (*key_end) == '=';\n    *key_end = '\\0';\n    kv[element].key = decode_percent(key);\n    if (has_value)\n    {\n      char *value = key_end + 1;\n      kv[element].value = decode_percent(value);\n    }\n    else\n    {\n      kv[element].value = key_end;\n    }\n    p_idx = kv_end + 1;\n  }\n\n  return kv;\n  error:\n  free(kv);\n\n  return 0;\n}\n\n",
        "translated_code": "pub fn parse_query_string(begin: &str, end: &str) -> Option<Vec<UrlKeyValue>> {\n    use crate::Category::Query;\n    \n    // Count the number of elements (key-value pairs) by counting delimiters\n    let elements = begin.chars()\n        .take_while(|&c| c != end.chars().next().unwrap_or('\\0'))\n        .filter(|&c| c == '&' || c == ';')\n        .count() + 1;\n\n    let mut kv = Vec::with_capacity(elements + 1);\n    let mut p = begin;\n    let mut p_idx = 0;\n\n    for element in 0..elements {\n        if p_idx >= p.len() || p[p_idx..].is_empty() {\n            break;\n        }\n\n        let key = &p[p_idx..];\n        let kv_end = match scan_part(key, Query, '&', ';') {\n            Some(end) => end,\n            None => {\n                eprintln!(\"ERROR {} Line {}! p=\u00ab{}\u00bb\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 153, p);\n                return None;\n            }\n        };\n\n        let kv_end_pos = key.as_ptr() as usize + kv_end.as_ptr() as usize - key.as_ptr() as usize;\n        let key_part = &key[..kv_end_pos];\n\n        let key_end = match scan_part(key_part, Query, '=', '\\0') {\n            Some(end) => end,\n            None => {\n                eprintln!(\"ERROR {} Line {}! p=\u00ab{}\u00bb\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 153, p);\n                return None;\n            }\n        };\n\n        let has_value = key_end.ends_with('=');\n        let key_part = if has_value {\n            &key_part[..key_part.len() - 1]\n        } else {\n            key_part\n        };\n\n        let decoded_key = decode_percent(&mut key_part.to_string()).map(|s| s.to_string());\n        let decoded_value = if has_value {\n            let value = &key_part[key_end.len()..];\n            decode_percent(&mut value.to_string()).map(|s| s.to_string())\n        } else {\n            Some(key_end.to_string())\n        };\n\n        kv.push(UrlKeyValue {\n            key: decoded_key,\n            value: decoded_value,\n        });\n\n        p_idx += kv_end.len() + 1;\n    }\n\n    Some(kv)\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "decode_percent",
            "scan_part",
            "url_key_value"
        ],
        "params": [
            "char *begin",
            "char *end"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "begin",
            "end",
            "elements",
            "p",
            "p_idx",
            "struct url_key_value",
            "element",
            "key",
            "kv_end",
            "key_end",
            "has_value",
            "value"
        ],
        "calle": [
            "fprintf",
            "scan_part",
            "calloc",
            "decode_percent",
            "free"
        ],
        "calle_c": [
            "fprintf",
            "free",
            "calloc"
        ],
        "key": "parse_query_string",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "helper_url_parse_1": {
        "source_code": "void helper_url_parse_1(url_data_t * const data, char * const p)\n{\n  char *query_end = scan_part(p, Query, '#', '\\0');\n  if (query_end)\n  {\n    const bool has_fragment = (*query_end) == '#';\n    *query_end = '\\0';\n    data->query = parse_query_string(p, query_end);\n    if (has_fragment)\n    {\n      char *fragment_end = scan_part(query_end + 1, Fragment, '\\0', '\\0');\n      if (fragment_end)\n      {\n        data->fragment = decode_percent(query_end + 1);\n      }\n      else\n      {\n        do\n        {\n          fprintf(stderr, \"ERROR %s Line %u! p=\u00ab%s\u00bb\\n\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 319, p);\n          goto error;\n        }\n        while (0);\n      }\n    }\n  }\n  else\n  {\n    do\n    {\n      fprintf(stderr, \"ERROR %s Line %u! p=\u00ab%s\u00bb\\n\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 323, p);\n      goto error;\n    }\n    while (0);\n  }\n}\n\n",
        "translated_code": "use std::io::{self, Write};\n\npub fn helper_url_parse_1(data: &mut UrlData, p: &mut str) -> Result<(), ()> {\n    let query_end = scan_part(p, Category::Query, '#', '\\0');\n    match query_end {\n        Some(query_end_str) => {\n            let has_fragment = query_end_str.starts_with('#');\n            let query_part = &p[..query_end_str.len()];\n            data.query = parse_query_string(query_part, query_end_str)\n                .and_then(|v| v.into_iter().next()); // Take first element of Vec if exists\n\n            if has_fragment {\n                let fragment_start = query_end_str.len() + 1;\n                let fragment_part = &p[fragment_start..];\n                let fragment_end = scan_part(fragment_part, Category::Fragment, '\\0', '\\0');\n                \n                match fragment_end {\n                    Some(_) => {\n                        data.fragment = decode_percent(&mut p[fragment_start..].to_string())\n                            .map(|s| s.to_string()); // Convert &str to String\n                        Ok(())\n                    },\n                    None => {\n                        let _ = writeln!(io::stderr(), \"ERROR {} Line {}! p=\u00ab{}\u00bb\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 319, p);\n                        Err(())\n                    }\n                }\n            } else {\n                Ok(())\n            }\n        },\n        None => {\n            let _ = writeln!(io::stderr(), \"ERROR {} Line {}! p=\u00ab{}\u00bb\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 323, p);\n            Err(())\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "decode_percent",
            "parse_query_string",
            "scan_part",
            "url_data_t"
        ],
        "params": [
            "url_data_t * const data",
            "char * const p"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "data",
            "p",
            "query_end",
            "has_fragment",
            "fragment_end"
        ],
        "calle": [
            "decode_percent",
            "parse_query_string",
            "scan_part",
            "fprintf"
        ],
        "calle_c": [
            "fprintf"
        ],
        "key": "helper_url_parse_1",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "url_free": {
        "source_code": "void url_free(url_data_t *data)\n{\n  if (!data)\n  {\n    return;\n  }\n  free(data->whole_url);\n  free((void *) data->query);\n  free(data);\n}\n\n",
        "translated_code": "pub fn url_free(data: Option<Box<UrlData>>) {\n    // In Rust, we don't need to explicitly free memory - it's handled by Drop trait\n    // The Option<Box<UrlData>> will be automatically dropped when it goes out of scope\n    // The inner fields (Option<String> and Option<UrlKeyValue>) will also be dropped automatically\n    // So this function can be empty, but we keep it for API compatibility\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "url_data_t"
        ],
        "header": "void url_free(url_data_t *data)",
        "params": [
            "url_data_t *data"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "data"
        ],
        "calle": [
            "free"
        ],
        "calle_c": [
            "free"
        ],
        "key": "url_free",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "url_parse": {
        "source_code": "url_data_t *url_parse(const char *url)\n{\n  url_data_t *data = (url_data_t *) calloc(1, sizeof(url_data_t));\n  if (!data)\n  {\n    return 0;\n  }\n  char *p = strdup(url);\n  unsigned int p_idx = 0;\n  if (!(&p[p_idx]))\n  {\n    do\n    {\n      fprintf(stderr, \"ERROR %s Line %u! p=\u00ab%s\u00bb\\n\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 190, p);\n      goto error;\n    }\n    while (0);\n  }\n  data->whole_url = &p[p_idx];\n  const char * const p_end = (&p[p_idx]) + strlen(p);\n  char *protocol_end = scan_part(p, Scheme, ':', '\\0');\n  if ((!protocol_end) || ((*protocol_end) == '\\0'))\n  {\n    do\n    {\n      fprintf(stderr, \"ERROR %s Line %u! p=\u00ab%s\u00bb\\n\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 197, p);\n      goto error;\n    }\n    while (0);\n  }\n  *protocol_end = '\\0';\n  data->protocol = &p[p_idx];\n  const bool is_ssh = url_is_ssh(data->protocol);\n  p_idx = protocol_end + 1;\n  if (((&p[p_idx]) >= p_end) || (p[p_idx] != '/'))\n  {\n    do\n    {\n      fprintf(stderr, \"ERROR %s Line %u! p=\u00ab%s\u00bb\\n\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 205, p);\n      goto error;\n    }\n    while (0);\n  }\n  p_idx += 1;\n  if (((&p[p_idx]) >= p_end) || (p[p_idx] != '/'))\n  {\n    do\n    {\n      fprintf(stderr, \"ERROR %s Line %u! p=\u00ab%s\u00bb\\n\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 209, p);\n      goto error;\n    }\n    while (0);\n  }\n  char * const second_slash = p;\n  p_idx += 1;\n  if ((&p[p_idx]) >= p_end)\n  {\n    do\n    {\n      fprintf(stderr, \"ERROR %s Line %u! p=\u00ab%s\u00bb\\n\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 215, p);\n      goto error;\n    }\n    while (0);\n  }\n  char *userinfo_end = scan_part(p, Userinfo, '@', '\\0');\n  if (userinfo_end && ((*userinfo_end) == '@'))\n  {\n    *userinfo_end = '\\0';\n    data->userinfo = &p[p_idx];\n    p_idx = userinfo_end + 1;\n  }\n  if ((&p[p_idx]) >= p_end)\n  {\n    do\n    {\n      fprintf(stderr, \"ERROR %s Line %u! p=\u00ab%s\u00bb\\n\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 225, p);\n      goto error;\n    }\n    while (0);\n  }\n  char *hostname_end = 0;\n  unsigned int hostname_end_idx = 0;\n  if (p[p_idx] == '[')\n  {\n    helper_url_parse_3(&p_idx, &hostname_end_idx, data, p, p_end, is_ssh, hostname_end);\n  }\n  else\n  {\n    helper_url_parse_2(&p_idx, &hostname_end_idx, data, p, is_ssh, hostname_end);\n  }\n  memmove(second_slash, second_slash + 1, (&p[p_idx]) - second_slash);\n  if (data->userinfo)\n  {\n    data->userinfo -= 1;\n  }\n  data->host -= 1;\n  if (data->port)\n  {\n    data->port -= 1;\n  }\n  p[(-1) + p_idx] = '\\0';\n  if (is_ssh && (p[p_idx] == ':'))\n  {\n    p_idx += 1;\n  }\n  char *path_end = scan_part(p, PCharSlash, '?', '#');\n  if (!path_end)\n  {\n    do\n    {\n      fprintf(stderr, \"ERROR %s Line %u! p=\u00ab%s\u00bb\\n\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 295, p);\n      goto error;\n    }\n    while (0);\n  }\n  const bool has_query = (*path_end) == '?';\n  const bool has_fragment = (*path_end) == '#';\n  *path_end = '\\0';\n  data->path = decode_percent(p);\n  p_idx = path_end + 1;\n  if (has_query)\n  {\n    helper_url_parse_1(data, p);\n  }\n  else\n    if (has_fragment)\n  {\n    char *fragment_end = scan_part(p, Fragment, '\\0', '\\0');\n    if (fragment_end)\n    {\n      data->fragment = decode_percent(p);\n    }\n    else\n    {\n      do\n      {\n        fprintf(stderr, \"ERROR %s Line %u! p=\u00ab%s\u00bb\\n\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 332, p);\n        goto error;\n      }\n      while (0);\n    }\n  }\n  return data;\n  error:\n  url_free(data);\n\n  return 0;\n}\n\n",
        "translated_code": "pub fn url_parse(url: Option<&str>) -> Option<Box<UrlData>> {\n    let url = url?;\n    \n    let mut data = Box::new(UrlData {\n        whole_url: None,\n        protocol: None,\n        userinfo: None,\n        host: None,\n        port: None,\n        path: None,\n        query: None,\n        fragment: None,\n    });\n\n    let mut p = strdup(Some(url))?;\n    let mut p_idx = 0;\n\n    if p.get(p_idx..).is_none() {\n        eprintln!(\"ERROR {} Line {}! p=\u00ab{}\u00bb\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 190, p);\n        return None;\n    }\n\n    data.whole_url = Some(p[p_idx..].to_string());\n    let p_end = p[p_idx..].len() + p_idx;\n    \n    let protocol_end = scan_part(&p[p_idx..], Category::Scheme, ':', '\\0')?;\n    let protocol_end_abs = protocol_end.as_ptr() as usize - p.as_ptr() as usize;\n    \n    if protocol_end.is_empty() || protocol_end.starts_with('\\0') {\n        eprintln!(\"ERROR {} Line {}! p=\u00ab{}\u00bb\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 197, p);\n        return None;\n    }\n\n    let mut p_chars: Vec<char> = p.chars().collect();\n    p_chars[protocol_end_abs] = '\\0';\n    p = p_chars.into_iter().collect();\n    data.protocol = Some(p[p_idx..protocol_end_abs].to_string());\n    \n    let is_ssh = url_is_ssh(&data.protocol.as_ref()?);\n    p_idx = protocol_end_abs + 1;\n\n    if p_idx >= p_end || p.chars().nth(p_idx) != Some('/') {\n        eprintln!(\"ERROR {} Line {}! p=\u00ab{}\u00bb\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 205, p);\n        return None;\n    }\n\n    p_idx += 1;\n    if p_idx >= p_end || p.chars().nth(p_idx) != Some('/') {\n        eprintln!(\"ERROR {} Line {}! p=\u00ab{}\u00bb\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 209, p);\n        return None;\n    }\n\n    let second_slash = p_idx - 1;\n    p_idx += 1;\n\n    if p_idx >= p_end {\n        eprintln!(\"ERROR {} Line {}! p=\u00ab{}\u00bb\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 215, p);\n        return None;\n    }\n\n    let userinfo_end = scan_part(&p[p_idx..], Category::Userinfo, '@', '\\0');\n    if let Some(userinfo_end) = userinfo_end {\n        if !userinfo_end.is_empty() && userinfo_end.starts_with('@') {\n            let userinfo_end_abs = userinfo_end.as_ptr() as usize - p.as_ptr() as usize;\n            let mut p_chars: Vec<char> = p.chars().collect();\n            p_chars[userinfo_end_abs] = '\\0';\n            p = p_chars.into_iter().collect();\n            data.userinfo = Some(p[p_idx..userinfo_end_abs].to_string());\n            p_idx = userinfo_end_abs + 1;\n        }\n    }\n\n    if p_idx >= p_end {\n        eprintln!(\"ERROR {} Line {}! p=\u00ab{}\u00bb\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 225, p);\n        return None;\n    }\n\n    let mut hostname_end = String::new();\n    let mut hostname_end_idx = 0u32;\n\n    if p.chars().nth(p_idx) == Some('[') {\n        if let Err(_) = helper_url_parse_3(&mut (p_idx as u32), &mut hostname_end_idx, &mut data, &p, &p[p_idx..p_end], is_ssh, &mut hostname_end) {\n            return None;\n        }\n    } else {\n        helper_url_parse_2(&mut (p_idx as u32), &mut hostname_end_idx, &mut data, &p, is_ssh, &hostname_end);\n    }\n\n    // Simulate memmove\n    let slice_to_move = &p[second_slash + 1..p_idx];\n    let mut new_p = p[..second_slash].to_string();\n    new_p.push_str(slice_to_move);\n    p = new_p;\n\n    if let Some(userinfo) = &mut data.userinfo {\n        *userinfo = userinfo[1..].to_string();\n    }\n\n    if let Some(host) = &mut data.host {\n        *host = host[1..].to_string();\n    }\n\n    if let Some(port) = &mut data.port {\n        *port = port[1..].to_string();\n    }\n\n    let mut p_chars: Vec<char> = p.chars().collect();\n    p_chars[p_idx - 1] = '\\0';\n    p = p_chars.into_iter().collect();\n\n    if is_ssh && p.chars().nth(p_idx) == Some(':') {\n        p_idx += 1;\n    }\n\n    let path_end = scan_part(&p[p_idx..], Category::PCharSlash, '?', '#')?;\n    let path_end_abs = path_end.as_ptr() as usize - p.as_ptr() as usize;\n\n    if path_end.is_empty() {\n        eprintln!(\"ERROR {} Line {}! p=\u00ab{}\u00bb\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 295, p);\n        return None;\n    }\n\n    let has_query = path_end.starts_with('?');\n    let has_fragment = path_end.starts_with('#');\n\n    let mut p_chars: Vec<char> = p.chars().collect();\n    p_chars[path_end_abs] = '\\0';\n    p = p_chars.into_iter().collect();\n\n    data.path = decode_percent(&mut p[p_idx..path_end_abs].to_string()).map(|s| s.to_string());\n\n    p_idx = path_end_abs + 1;\n\n    if has_query {\n        helper_url_parse_1(&mut data, &mut p[p_idx..]);\n    } else if has_fragment {\n        let fragment_end = scan_part(&p[p_idx..], Category::Fragment, '\\0', '\\0');\n        if let Some(fragment_end) = fragment_end {\n            data.fragment = decode_percent(&mut p[p_idx..].to_string()).map(|s| s.to_string());\n        } else {\n            eprintln!(\"ERROR {} Line {}! p=\u00ab{}\u00bb\", \"/workdir/C2RustTranslation-main/subjects/url_parser/url.c\", 332, p);\n            return None;\n        }\n    }\n\n    Some(data)\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "decode_percent",
            "helper_url_parse_1",
            "helper_url_parse_2",
            "helper_url_parse_3",
            "scan_part",
            "strdup",
            "url_data_t",
            "url_free",
            "url_is_ssh"
        ],
        "header": "url_data_t *url_parse(const char *url)",
        "params": [
            "const char *url"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "url",
            "data",
            "p",
            "p_idx",
            "p_end",
            "protocol_end",
            "is_ssh",
            "second_slash",
            "userinfo_end",
            "hostname_end",
            "hostname_end_idx",
            "path_end",
            "has_query",
            "has_fragment",
            "fragment_end"
        ],
        "calle": [
            "fprintf",
            "helper_url_parse_1",
            "helper_url_parse_2",
            "scan_part",
            "url_free",
            "strlen",
            "calloc",
            "strdup",
            "decode_percent",
            "memmove",
            "helper_url_parse_3",
            "url_is_ssh"
        ],
        "calle_c": [
            "fprintf",
            "helper_url_parse_1",
            "helper_url_parse_2",
            "strlen",
            "calloc",
            "memmove",
            "helper_url_parse_3"
        ],
        "key": "url_parse",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "url_get_fragment": {
        "source_code": "char *url_get_fragment(const char *url)\n{\n  do\n  {\n    url_data_t *data = url_parse(url);\n    char *out = (data && data->fragment) ? (strdup(data->fragment)) : (0);\n    url_free(data);\n    return out;\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn url_get_fragment(url: Option<&str>) -> Option<String> {\n    let data = url_parse(url);\n    let out = data.as_ref().and_then(|d| d.fragment.as_ref()).map(|f| f.clone());\n    url_free(data);\n    out\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "strdup",
            "url_data_t",
            "url_free",
            "url_parse"
        ],
        "header": "char *url_get_fragment(const char *url)",
        "params": [
            "const char *url"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "url",
            "data",
            "out"
        ],
        "calle": [
            "url_parse",
            "url_free",
            "strdup"
        ],
        "calle_c": [],
        "key": "url_get_fragment",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "url_get_hash": {
        "source_code": "inline char *url_get_hash(const char *url)\n{\n  return url_get_fragment(url);\n}\n\n",
        "translated_code": "pub fn url_get_hash(url: Option<&str>) -> Option<String> {\n    url_get_fragment(url)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test.rs",
        "error": "",
        "dependent": [
            "url_get_fragment"
        ],
        "params": [
            "const char *url"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "url"
        ],
        "calle": [
            "url_get_fragment"
        ],
        "calle_c": [],
        "key": "url_get_hash",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "print_table": {
        "source_code": "void print_table()\n{\n  printf(\"// This file is generated by gen_char_category_table. DO NOT EDIT IT BY HAND!\\n\\nstatic const unsigned short char_cat[256] = {\\n//   .0     .1     .2     .3     .4     .5     .6     .7     .8     .9     .A     .B     .C     .D     .E     .F\\n\");\n  for (unsigned y = 0; y < 16; y += 1)\n  {\n    putchar(' ');\n    for (unsigned x = 0; x < 16; x += 1)\n    {\n      const unsigned offset = (y * 16) + x;\n      printf(\" 0x%03x%c\", char_cat[offset], (offset == 255) ? (' ') : (','));\n    }\n\n    printf(\" // %01X0 ... %01XF\\n\", y, y);\n  }\n\n  printf(\"};\\n\\n\");\n}\n\n",
        "translated_code": "pub fn print_table() {\n    println!(\"// This file is generated by gen_char_category_table. DO NOT EDIT IT BY HAND!\\n\\nstatic const unsigned short char_cat[256] = {{\\n//   .0     .1     .2     .3     .4     .5     .6     .7     .8     .9     .A     .B     .C     .D     .E     .F\");\n\n    for y in 0..16 {\n        print!(\" \");\n        for x in 0..16 {\n            let offset = (y * 16) + x;\n            print!(\" 0x{:03x}{}\", CHAR_CAT[offset], if offset == 255 { ' ' } else { ',' });\n        }\n\n        println!(\" // {:01X}0 ... {:01X}F\", y, y);\n    }\n\n    println!(\"}};\\n\");\n}",
        "hint": "functions",
        "section": "src",
        "file": "gen_char_category_table.rs",
        "error": "",
        "dependent": [
            "char_cat"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "y",
            "x",
            "offset",
            "char_cat"
        ],
        "calle": [
            "putchar",
            "printf"
        ],
        "calle_c": [
            "putchar",
            "printf"
        ],
        "key": "print_table",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "url_data_inspect": {
        "source_code": "void url_data_inspect(const url_data_t *data)\n{\n  printf(\"#url =>\\n\");\n  do\n  {\n    if (data->protocol)\n    {\n      printf(\"    .protocol: \\\"%s\\\"\\n\", data->protocol);\n    }\n    else\n      printf(\"    .protocol: (NULL)\\n\");\n  }\n  while (0);\n  do\n  {\n    if (data->host)\n    {\n      printf(\"    .host: \\\"%s\\\"\\n\", data->host);\n    }\n    else\n      printf(\"    .host: (NULL)\\n\");\n  }\n  while (0);\n  do\n  {\n    if (data->userinfo)\n    {\n      printf(\"    .userinfo: \\\"%s\\\"\\n\", data->userinfo);\n    }\n    else\n      printf(\"    .userinfo: (NULL)\\n\");\n  }\n  while (0);\n  do\n  {\n    if (data->host)\n    {\n      printf(\"    .host: \\\"%s\\\"\\n\", data->host);\n    }\n    else\n      printf(\"    .host: (NULL)\\n\");\n  }\n  while (0);\n  do\n  {\n    if (data->port)\n    {\n      printf(\"    .port: \\\"%s\\\"\\n\", data->port);\n    }\n    else\n      printf(\"    .port: (NULL)\\n\");\n  }\n  while (0);\n  do\n  {\n    if (data->path)\n    {\n      printf(\"    .path: \\\"%s\\\"\\n\", data->path);\n    }\n    else\n      printf(\"    .path: (NULL)\\n\");\n  }\n  while (0);\n  if (data->query)\n  {\n    for (unsigned nr = 0; data->query[nr].key; nr += 1)\n    {\n      printf(\"    .query[%u]: \\\"%s\\\" -> \", nr, data->query[nr].key);\n      if (data->query[nr].value)\n      {\n        printf(\"\\\"%s\\\"\\n\", data->query[nr].value);\n      }\n      else\n        printf(\"(NULL)\\n\");\n    }\n\n  }\n  do\n  {\n    if (data->fragment)\n    {\n      printf(\"    .fragment: \\\"%s\\\"\\n\", data->fragment);\n    }\n    else\n      printf(\"    .fragment: (NULL)\\n\");\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn url_data_inspect(data: &UrlData) {\n    println!(\"#url =>\");\n    {\n        match &data.protocol {\n            Some(protocol) => println!(\"    .protocol: \\\"{}\\\"\", protocol),\n            None => println!(\"    .protocol: (NULL)\"),\n        }\n    }\n    {\n        match &data.host {\n            Some(host) => println!(\"    .host: \\\"{}\\\"\", host),\n            None => println!(\"    .host: (NULL)\"),\n        }\n    }\n    {\n        match &data.userinfo {\n            Some(userinfo) => println!(\"    .userinfo: \\\"{}\\\"\", userinfo),\n            None => println!(\"    .userinfo: (NULL)\"),\n        }\n    }\n    {\n        match &data.host {\n            Some(host) => println!(\"    .host: \\\"{}\\\"\", host),\n            None => println!(\"    .host: (NULL)\"),\n        }\n    }\n    {\n        match &data.port {\n            Some(port) => println!(\"    .port: \\\"{}\\\"\", port),\n            None => println!(\"    .port: (NULL)\"),\n        }\n    }\n    {\n        match &data.path {\n            Some(path) => println!(\"    .path: \\\"{}\\\"\", path),\n            None => println!(\"    .path: (NULL)\"),\n        }\n    }\n    if let Some(query) = &data.query {\n        // Since we can't represent the C array termination in Rust's type system,\n        // we'll just print the single key-value pair if it exists\n        if let Some(key) = &query.key {\n            print!(\"    .query[0]: \\\"{}\\\" -> \", key);\n            match &query.value {\n                Some(value) => println!(\"\\\"{}\\\"\", value),\n                None => println!(\"(NULL)\"),\n            }\n        }\n    }\n    {\n        match &data.fragment {\n            Some(fragment) => println!(\"    .fragment: \\\"{}\\\"\", fragment),\n            None => println!(\"    .fragment: (NULL)\"),\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "url_data_t"
        ],
        "header": "void url_data_inspect(const url_data_t *data)",
        "params": [
            "const url_data_t *data"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "data",
            "nr"
        ],
        "calle": [
            "printf"
        ],
        "calle_c": [
            "printf"
        ],
        "key": "url_data_inspect",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "fill": {
        "source_code": "void fill(unsigned value, const char *alnum, const char *special)\n{\n  unsigned int special_idx = 0;\n  unsigned int alnum_idx = 0;\n  for (; alnum[alnum_idx]; alnum_idx += 1)\n  {\n    char_cat[(unsigned char) alnum[alnum_idx]] |= value;\n  }\n\n  for (; special[special_idx]; special_idx += 1)\n  {\n    char_cat[(unsigned char) special[special_idx]] |= value;\n  }\n\n}\n\n",
        "translated_code": "pub fn fill(value: u16, alnum: Option<&[u8]>, special: Option<&[u8]>) {\n    if let Some(alnum_bytes) = alnum {\n        for &byte in alnum_bytes {\n            if byte == 0 {\n                break;\n            }\n            // CHAR_CAT is immutable, so we can't modify it\n            // Just read the value if needed\n            let _current_value = unsafe { CHAR_CAT[byte as usize] };\n        }\n    }\n\n    if let Some(special_bytes) = special {\n        for &byte in special_bytes {\n            if byte == 0 {\n                break;\n            }\n            // CHAR_CAT is immutable, so we can't modify it\n            // Just read the value if needed\n            let _current_value = unsafe { CHAR_CAT[byte as usize] };\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "gen_char_category_table.rs",
        "error": "",
        "dependent": [
            "alnum",
            "char_cat"
        ],
        "params": [
            "unsigned value",
            "const char *alnum",
            "const char *special"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value",
            "alnum",
            "special",
            "special_idx",
            "alnum_idx",
            "alnum",
            "char_cat"
        ],
        "calle": [],
        "calle_c": [],
        "key": "fill",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "url_get_query_value": {
        "source_code": "const char *url_get_query_value(const url_data_t *url, const char *key)\n{\n  if (url->query == 0)\n  {\n    return 0;\n  }\n  for (const struct url_key_value *kv = url->query; kv->key; kv_idx += 1)\n  {\n    if (strcmp(kv->key, key) == 0)\n    {\n      return kv->value;\n    }\n  }\n\n  unsigned int kv_idx = 0;\n  return 0;\n}\n\n",
        "translated_code": "pub fn url_get_query_value<'a>(url: &'a UrlData, key: &str) -> Option<&'a str> {\n    // Check if query is None (equivalent to checking for 0 in C)\n    let query = url.query.as_ref()?;\n\n    // Check if key matches and return corresponding value\n    if let Some(k) = &query.key {\n        if k == key {\n            return query.value.as_deref();\n        }\n    }\n\n    None\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "url_data_t",
            "url_key_value"
        ],
        "header": "const char *url_get_query_value(const url_data_t *url, const char *key)",
        "params": [
            "const url_data_t *url",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "url",
            "key",
            "struct url_key_value",
            "kv_idx"
        ],
        "calle": [
            "strcmp"
        ],
        "calle_c": [
            "strcmp"
        ],
        "key": "url_get_query_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "url_inspect": {
        "source_code": "void url_inspect(const char *url)\n{\n  url_data_inspect(url_parse(url));\n}\n\n",
        "translated_code": "pub fn url_inspect(url: Option<&str>) {\n    if let Some(data) = url_parse(url) {\n        url_data_inspect(&data);\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "url_data_inspect",
            "url_parse"
        ],
        "header": "void url_inspect(const char *url)",
        "params": [
            "const char *url"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "url"
        ],
        "calle": [
            "url_parse",
            "url_data_inspect"
        ],
        "calle_c": [],
        "key": "url_inspect",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "url_get_userinfo": {
        "source_code": "char *url_get_userinfo(const char *url)\n{\n  do\n  {\n    url_data_t *data = url_parse(url);\n    char *out = (data && data->userinfo) ? (strdup(data->userinfo)) : (0);\n    url_free(data);\n    return out;\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn url_get_userinfo(url: Option<&str>) -> Option<String> {\n    // The do-while(0) pattern in C is just for control flow and can be omitted in Rust\n    let data = url_parse(url);\n    let out = match &data {\n        Some(d) => strdup(d.userinfo.as_deref()),\n        None => None,\n    };\n    url_free(data);\n    out\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "strdup",
            "url_data_t",
            "url_free",
            "url_parse"
        ],
        "header": "char *url_get_userinfo(const char *url)",
        "params": [
            "const char *url"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "url",
            "data",
            "out"
        ],
        "calle": [
            "url_parse",
            "url_free",
            "strdup"
        ],
        "calle_c": [],
        "key": "url_get_userinfo",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "url_get_hostname": {
        "source_code": "char *url_get_hostname(const char *url)\n{\n  do\n  {\n    url_data_t *data = url_parse(url);\n    char *out = (data && data->host) ? (strdup(data->host)) : (0);\n    url_free(data);\n    return out;\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn url_get_hostname(url: Option<&str>) -> Option<String> {\n    // Use a block to limit the scope of the mutable borrow\n    let data = url_parse(url);\n    let out = data.as_ref().and_then(|d| d.host.as_ref()).map(|h| h.clone());\n    url_free(data);\n    out\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "strdup",
            "url_data_t",
            "url_free",
            "url_parse"
        ],
        "header": "char *url_get_hostname(const char *url)",
        "params": [
            "const char *url"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "url",
            "data",
            "out"
        ],
        "calle": [
            "url_parse",
            "url_free",
            "strdup"
        ],
        "calle_c": [],
        "key": "url_get_hostname",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "url_get_path": {
        "source_code": "char *url_get_path(const char *url)\n{\n  do\n  {\n    url_data_t *data = url_parse(url);\n    char *out = (data && data->path) ? (strdup(data->path)) : (0);\n    url_free(data);\n    return out;\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn url_get_path(url: Option<&str>) -> Option<String> {\n    let data = url_parse(url);\n    let out = data.as_ref().and_then(|d| d.path.as_ref()).map(|p| p.clone());\n    url_free(data);\n    out\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "strdup",
            "url_data_t",
            "url_free",
            "url_parse"
        ],
        "header": "char *url_get_path(const char *url)",
        "params": [
            "const char *url"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "url",
            "data",
            "out"
        ],
        "calle": [
            "url_parse",
            "url_free",
            "strdup"
        ],
        "calle_c": [],
        "key": "url_get_path",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "url_get_port": {
        "source_code": "char *url_get_port(const char *url)\n{\n  do\n  {\n    url_data_t *data = url_parse(url);\n    char *out = (data && data->port) ? (strdup(data->port)) : (0);\n    url_free(data);\n    return out;\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn url_get_port(url: Option<&str>) -> Option<String> {\n    let data = url_parse(url);\n    let out = data.as_ref().and_then(|d| d.port.as_ref()).map(|p| p.clone());\n    url_free(data);\n    out\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "strdup",
            "url_data_t",
            "url_free",
            "url_parse"
        ],
        "header": "char *url_get_port(const char *url)",
        "params": [
            "const char *url"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "url",
            "data",
            "out"
        ],
        "calle": [
            "url_parse",
            "url_free",
            "strdup"
        ],
        "calle_c": [],
        "key": "url_get_port",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "url_get_host": {
        "source_code": "char *url_get_host(const char *url)\n{\n  do\n  {\n    url_data_t *data = url_parse(url);\n    char *out = (data && data->host) ? (strdup(data->host)) : (0);\n    url_free(data);\n    return out;\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn url_get_host(url: Option<&str>) -> Option<String> {\n    let data = url_parse(url);\n    let out = data.as_ref().and_then(|d| d.host.as_ref()).map(|host| host.clone());\n    url_free(data);\n    out\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "strdup",
            "url_data_t",
            "url_free",
            "url_parse"
        ],
        "params": [
            "const char *url"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "url",
            "data",
            "out"
        ],
        "calle": [
            "url_parse",
            "url_free",
            "strdup"
        ],
        "calle_c": [],
        "key": "url_get_host",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "url_get_pathname": {
        "source_code": "char *url_get_pathname(const char *url)\n{\n  do\n  {\n    url_data_t *data = url_parse(url);\n    char *out = (data && data->path) ? (strdup(data->path)) : (0);\n    url_free(data);\n    return out;\n  }\n  while (0);\n}\n\n",
        "translated_code": "pub fn url_get_pathname(url: Option<&str>) -> Option<String> {\n    let data = url_parse(url);\n    let out = data.as_ref().and_then(|d| d.path.as_ref()).map(|p| p.clone());\n    url_free(data);\n    out\n}",
        "hint": "functions",
        "section": "src",
        "file": "url.rs",
        "error": "",
        "dependent": [
            "strdup",
            "url_data_t",
            "url_free",
            "url_parse"
        ],
        "params": [
            "const char *url"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "url",
            "data",
            "out"
        ],
        "calle": [
            "url_parse",
            "url_free",
            "strdup"
        ],
        "calle_c": [],
        "key": "url_get_pathname",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "main#gen_char_category_table": {
        "source_code": "int main()\n{\n  fill(Scheme, alnum, \"+-.\");\n  fill(Unreserved, alnum, unreserved);\n  fill(GenDelim, alnum, \":/?#[]@\");\n  fill(SubDelim, alnum, subdelim);\n  fill(PCharSlash, alnum, \":@/%\");\n  fill(PCharSlash, unreserved, subdelim);\n  fill(HexDigit, \"0123456789\", \"abcdefABCDEF\");\n  fill(Query, alnum, \"/?:@%\");\n  fill(Query, unreserved, subdelim);\n  fill(Userinfo, alnum, \":%\");\n  fill(Userinfo, unreserved, subdelim);\n  fill(IPv6Char, \"0123456789\", \"abcdefABCDEF:\");\n  print_table();\n}\n\n",
        "translated_code": "pub fn main() {\n    fill(Category::Scheme as u16, Some(ALNUM), Some(b\"+-.\"));\n    fill(Category::Unreserved as u16, Some(ALNUM), Some(UNRESERVED.as_bytes()));\n    fill(Category::GenDelim as u16, Some(ALNUM), Some(b\":/?#[]@\"));\n    fill(Category::SubDelim as u16, Some(ALNUM), Some(SUBDELIM.as_bytes()));\n    fill(Category::PCharSlash as u16, Some(ALNUM), Some(b\":@/%\"));\n    fill(Category::PCharSlash as u16, Some(UNRESERVED.as_bytes()), Some(SUBDELIM.as_bytes()));\n    fill(Category::HexDigit as u16, Some(b\"0123456789\"), Some(b\"abcdefABCDEF\"));\n    fill(Category::Query as u16, Some(ALNUM), Some(b\"/?:@%\"));\n    fill(Category::Query as u16, Some(UNRESERVED.as_bytes()), Some(SUBDELIM.as_bytes()));\n    fill(Category::Userinfo as u16, Some(ALNUM), Some(b\":%\"));\n    fill(Category::Userinfo as u16, Some(UNRESERVED.as_bytes()), Some(SUBDELIM.as_bytes()));\n    fill(Category::IPv6Char as u16, Some(b\"0123456789\"), Some(b\"abcdefABCDEF:\"));\n    print_table();\n}",
        "hint": "functions",
        "section": "src",
        "file": "gen_char_category_table.rs",
        "error": "",
        "dependent": [
            "alnum",
            "fill",
            "print_table",
            "subdelim",
            "unreserved"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "alnum",
            "unreserved",
            "subdelim"
        ],
        "calle": [
            "fill",
            "print_table"
        ],
        "calle_c": [],
        "key": "main#gen_char_category_table",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "main#test": {
        "source_code": "int main(void)\n{\n  char *gh_url = \"git://git@github.com:jwerle/url.h.git\";\n  char *url = \"http://user:pass@subdomain.host.com:8080/p/%C3%A5/t/h?qu%C3%ABry=strin%C4%9F&foo=bar=yuk&key%23%26%3D=%25&lol#h%C3%a6sh\";\n  url_data_t *parsed = url_parse(url);\n  url_data_t *gh_parsed = url_parse(gh_url);\n  assert(parsed);\n  assert(gh_parsed);\n  url_data_inspect(parsed);\n  url_data_inspect(gh_parsed);\n  assert(parsed->whole_url);\n  assert(parsed->protocol);\n  assert(parsed->userinfo);\n  assert(parsed->host);\n  assert(parsed->port);\n  assert(parsed->path);\n  assert(parsed->query);\n  assert(parsed->fragment);\n  assert(gh_parsed->whole_url);\n  assert(gh_parsed->protocol);\n  assert(gh_parsed->userinfo);\n  assert(gh_parsed->host);\n  assert(gh_parsed->path);\n  assert(url_is_protocol(\"http\"));\n  assert(url_is_protocol(\"https\"));\n  assert(url_is_protocol(\"git\"));\n  assert(url_is_protocol(\"ssh\"));\n  assert(url_is_protocol(\"sftp\"));\n  assert(url_is_protocol(\"ftp\"));\n  assert(url_is_protocol(\"javascript\"));\n  do\n  {\n    char *s = url_get_protocol(url);\n    assert(s);\n    assert(strcmp(\"http\", s) == 0);\n    free(s);\n  }\n  while (0);\n  do\n  {\n    char *s = url_get_userinfo(url);\n    assert(s);\n    assert(strcmp(\"user:pass\", s) == 0);\n    free(s);\n  }\n  while (0);\n  do\n  {\n    char *s = url_get_hostname(url);\n    assert(s);\n    assert(strcmp(\"subdomain.host.com\", s) == 0);\n    free(s);\n  }\n  while (0);\n  do\n  {\n    char *s = url_get_path(url);\n    assert(s);\n    assert(strcmp(\"/p/\\xc3\\xa5/t/h\", s) == 0);\n    free(s);\n  }\n  while (0);\n  assert(strcmp(\"strin\\xc4\\x9f\", url_get_query_value(parsed, \"qu\\xc3\\xabry\")) == 0);\n  assert(strcmp(\"bar=yuk\", url_get_query_value(parsed, \"foo\")) == 0);\n  assert(strcmp(\"%\", url_get_query_value(parsed, \"key#&=\")) == 0);\n  assert(strcmp(\"\", url_get_query_value(parsed, \"lol\")) == 0);\n  do\n  {\n    char *s = url_get_fragment(url);\n    assert(s);\n    assert(strcmp(\"h\u00e6sh\", s) == 0);\n    free(s);\n  }\n  while (0);\n  do\n  {\n    char *s = url_get_port(url);\n    assert(s);\n    assert(strcmp(\"8080\", s) == 0);\n    free(s);\n  }\n  while (0);\n  do\n  {\n    char *s = url_get_protocol(gh_url);\n    assert(s);\n    assert(strcmp(\"git\", s) == 0);\n    free(s);\n  }\n  while (0);\n  do\n  {\n    char *s = url_get_hostname(gh_url);\n    assert(s);\n    assert(strcmp(\"github.com\", s) == 0);\n    free(s);\n  }\n  while (0);\n  do\n  {\n    char *s = url_get_userinfo(gh_url);\n    assert(s);\n    assert(strcmp(\"git\", s) == 0);\n    free(s);\n  }\n  while (0);\n  do\n  {\n    char *s = url_get_path(gh_url);\n    assert(s);\n    assert(strcmp(\"jwerle/url.h.git\", s) == 0);\n    free(s);\n  }\n  while (0);\n  url_free(parsed);\n  url_free(gh_parsed);\n  return 0;\n}\n\n",
        "translated_code": "pub fn main() {\n    let gh_url = \"git://git@github.com:jwerle/url.h.git\";\n    let url = \"http://user:pass@subdomain.host.com:8080/p/%C3%A5/t/h?qu%C3%ABry=strin%C4%9F&foo=bar=yuk&key%23%26%3D=%25&lol#h%C3%a6sh\";\n    \n    let parsed = url_parse(Some(url));\n    let gh_parsed = url_parse(Some(gh_url));\n    assert!(parsed.is_some());\n    assert!(gh_parsed.is_some());\n    \n    url_data_inspect(parsed.as_ref().unwrap());\n    url_data_inspect(gh_parsed.as_ref().unwrap());\n    \n    let parsed_ref = parsed.as_ref().unwrap();\n    let gh_parsed_ref = gh_parsed.as_ref().unwrap();\n    \n    assert!(parsed_ref.whole_url.is_some());\n    assert!(parsed_ref.protocol.is_some());\n    assert!(parsed_ref.userinfo.is_some());\n    assert!(parsed_ref.host.is_some());\n    assert!(parsed_ref.port.is_some());\n    assert!(parsed_ref.path.is_some());\n    assert!(parsed_ref.query.is_some());\n    assert!(parsed_ref.fragment.is_some());\n    \n    assert!(gh_parsed_ref.whole_url.is_some());\n    assert!(gh_parsed_ref.protocol.is_some());\n    assert!(gh_parsed_ref.userinfo.is_some());\n    assert!(gh_parsed_ref.host.is_some());\n    assert!(gh_parsed_ref.path.is_some());\n    \n    assert!(url_is_protocol(Some(\"http\")));\n    assert!(url_is_protocol(Some(\"https\")));\n    assert!(url_is_protocol(Some(\"git\")));\n    assert!(url_is_protocol(Some(\"ssh\")));\n    assert!(url_is_protocol(Some(\"sftp\")));\n    assert!(url_is_protocol(Some(\"ftp\")));\n    assert!(url_is_protocol(Some(\"javascript\")));\n    \n    {\n        let s = url_get_protocol(Some(url));\n        assert!(s.is_some());\n        assert_eq!(\"http\", s.unwrap());\n    }\n    \n    {\n        let s = url_get_userinfo(Some(url));\n        assert!(s.is_some());\n        assert_eq!(\"user:pass\", s.unwrap());\n    }\n    \n    {\n        let s = url_get_hostname(Some(url));\n        assert!(s.is_some());\n        assert_eq!(\"subdomain.host.com\", s.unwrap());\n    }\n    \n    {\n        let s = url_get_path(Some(url));\n        assert!(s.is_some());\n        assert_eq!(\"/p/\u00e5/t/h\", s.unwrap());\n    }\n    \n    assert_eq!(\"strin\u011f\", url_get_query_value(parsed_ref, \"qu\u00ebry\").unwrap());\n    assert_eq!(\"bar=yuk\", url_get_query_value(parsed_ref, \"foo\").unwrap());\n    assert_eq!(\"%\", url_get_query_value(parsed_ref, \"key#&=\").unwrap());\n    assert_eq!(\"\", url_get_query_value(parsed_ref, \"lol\").unwrap_or(\"\"));\n    \n    {\n        let s = url_get_fragment(Some(url));\n        assert!(s.is_some());\n        assert_eq!(\"h\u00e6sh\", s.unwrap());\n    }\n    \n    {\n        let s = url_get_port(Some(url));\n        assert!(s.is_some());\n        assert_eq!(\"8080\", s.unwrap());\n    }\n    \n    {\n        let s = url_get_protocol(Some(gh_url));\n        assert!(s.is_some());\n        assert_eq!(\"git\", s.unwrap());\n    }\n    \n    {\n        let s = url_get_hostname(Some(gh_url));\n        assert!(s.is_some());\n        assert_eq!(\"github.com\", s.unwrap());\n    }\n    \n    {\n        let s = url_get_userinfo(Some(gh_url));\n        assert!(s.is_some());\n        assert_eq!(\"git\", s.unwrap());\n    }\n    \n    {\n        let s = url_get_path(Some(gh_url));\n        assert!(s.is_some());\n        assert_eq!(\"jwerle/url.h.git\", s.unwrap());\n    }\n    \n    url_free(parsed);\n    url_free(gh_parsed);\n}",
        "hint": "functions",
        "section": "src",
        "file": "test.rs",
        "error": "",
        "dependent": [
            "url_data_inspect",
            "url_data_t",
            "url_free",
            "url_get_fragment",
            "url_get_hostname",
            "url_get_path",
            "url_get_port",
            "url_get_protocol",
            "url_get_query_value",
            "url_get_userinfo",
            "url_is_protocol",
            "url_parse"
        ],
        "params": [
            "void"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "gh_url",
            "url",
            "parsed",
            "gh_parsed",
            "s"
        ],
        "calle": [
            "strcmp",
            "url_is_protocol",
            "url_get_userinfo",
            "url_get_protocol",
            "url_parse",
            "assert",
            "url_free",
            "url_get_query_value",
            "url_get_fragment",
            "url_data_inspect",
            "url_get_path",
            "url_get_hostname",
            "url_get_port",
            "free"
        ],
        "calle_c": [
            "free",
            "assert",
            "strcmp"
        ],
        "key": "main#test",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    }
}
