# 0 "/app/subjects/url_parser/url.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/app/subjects/url_parser/url.c"
# 1 "/app/pipeline/preprocess/fake_libc_include/string.h" 1
# 1 "/app/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/app/pipeline/preprocess/fake_libc_include/string.h" 2
# 1 "/app/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/app/pipeline/preprocess/fake_libc_include/string.h" 2
# 2 "/app/subjects/url_parser/url.c" 2
# 1 "/app/subjects/url_parser/url.h" 1







# 1 "/app/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 9 "/app/subjects/url_parser/url.h" 2
# 1 "/app/pipeline/preprocess/fake_libc_include/stdio.h" 1
# 10 "/app/subjects/url_parser/url.h" 2
# 1 "/app/pipeline/preprocess/fake_libc_include/stdbool.h" 1
# 11 "/app/subjects/url_parser/url.h" 2
# 47 "/app/subjects/url_parser/url.h"
struct url_key_value;





typedef struct url_data {
  char* whole_url;
  const char* protocol;
  const char* userinfo;
  const char* host;
  const char* port;
  const char* path;
  const struct url_key_value* query;
  const char* fragment;
} url_data_t;
# 71 "/app/subjects/url_parser/url.h"
url_data_t *
url_parse (const char* url);



char *
url_get_scheme (const char* url);




inline
char *
url_get_protocol (const char* url) { return url_get_scheme(url); }



char *
url_get_userinfo (const char* url);



char *
url_get_hostname (const char* url);



char *
url_get_path (const char* url);




const char *
url_get_query_value (const url_data_t* url, const char* key);



char *
url_get_fragment (const char* url);




inline
char *
url_get_hash (const char* url) { return url_get_fragment(url); }



char *
url_get_port (const char* url);


void
url_free (url_data_t* data);


bool
url_is_protocol (const char* str);


bool
url_is_ssh (const char* str);


void
url_inspect (const char* url);


void
url_data_inspect (const url_data_t* data);
# 3 "/app/subjects/url_parser/url.c" 2

# 1 "/app/subjects/url_parser/url_char_category.h" 1



enum Category
{
  Scheme = 0x01,
  Unreserved = 0x02,
  GenDelim = 0x04,
  SubDelim = 0x08,
  PCharSlash = 0x10,
  HexDigit = 0x20,
  Query = 0x40,
  Fragment = 0x40,
  Userinfo = 0x80,
  IPv6Char = 0x100,
};
# 5 "/app/subjects/url_parser/url.c" 2
# 1 "/app/subjects/url_parser/url_char_category_table.h" 1


static const unsigned short char_cat[256] = {

  0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,
  0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,
  0x000, 0x0d8, 0x000, 0x004, 0x0d8, 0x0d0, 0x0d8, 0x0d8, 0x0d8, 0x0d8, 0x0d8, 0x0d9, 0x0d8, 0x0d3, 0x0d3, 0x054,
  0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1d4, 0x0d8, 0x000, 0x0d8, 0x000, 0x044,
  0x054, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df,
  0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x004, 0x000, 0x004, 0x000, 0x0d2,
  0x000, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x1ff, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df,
  0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x0df, 0x000, 0x000, 0x000, 0x0d2, 0x000,
  0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,
  0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,
  0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,
  0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,
  0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,
  0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,
  0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,
  0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000
};
# 6 "/app/subjects/url_parser/url.c" 2
# 16 "/app/subjects/url_parser/url.c"
static const char *URL_SCHEMES[] = {

  "aaa", "aaas", "about", "acap", "acct", "adiumxtra", "afp", "afs", "aim", "apt", "attachment", "aw",
  "beshare", "bitcoin", "bolo", "callto", "cap", "chrome", "crome-extension", "com-evenbrite-attendee",
  "cid", "coap", "coaps","content", "crid", "cvs", "data", "dav", "dict", "lna-playsingle", "dln-playcontainer",
  "dns", "dtn", "dvb", "ed2k", "facetime", "fax", "feed", "file", "finger", "fish","ftp", "geo", "gg","git",
  "gizmoproject", "go", "gopher", "gtalk", "h323", "hcp", "http", "https", "iax", "icap", "icon","im",
  "imap", "info", "ipn", "ipp", "irc", "irc6", "ircs", "iris", "iris.beep", "iris.xpc", "iris.xpcs","iris.lws",
  "itms", "jabber", "jar", "jms", "keyparc", "lastfm", "ldap", "ldaps", "magnet", "mailserver","mailto",
  "maps", "market", "message", "mid", "mms", "modem", "ms-help", "mssettings-power", "msnim", "msrp",
  "msrps", "mtqp", "mumble", "mupdate", "mvn", "news", "nfs", "ni", "nih", "nntp", "notes","oid",
  "paquelocktoken", "pack", "palm", "paparazzi", "pkcs11", "platform", "pop", "pres", "prospero", "proxy",
  "psyc","query", "reload", "res", "resource", "rmi", "rsync", "rtmp","rtsp", "secondlife", "service","session",
  "sftp", "sgn", "shttp", "sieve", "sip", "sips", "skype", "smb", "sms", "snews", "snmp", "soap.beep","soap.beeps",
  "soldat", "spotify", "ssh", "steam", "svn", "tag", "teamspeak", "tel", "telnet", "tftp", "things","thismessage",
  "tn3270", "tip", "tv", "udp", "unreal", "urn", "ut2004", "vemmi","ventrilo", "videotex", "view-source", "wais","webcal",
  "ws", "wss", "wtai", "wyciwyg", "xcon", "xcon-userid", "xfire","xmlrpc.beep", "xmlrpc.beeps", "xmpp", "xri","ymsgr",


  "javascript", "jdbc", "doi"
};





char *
strdup (const char *str) {
  const int n = strlen(str) + 1;
  char *dup = (char *) malloc(n);
  if (dup) strcpy(dup, str);
  return dup;
}




struct url_key_value
{
  const char* key;
  const char* value;
};


static
int unhex(const char* s)
{
  if(*s>='0' && *s<='9')
    return *s - '0';

  if(*s>='A' && *s<='F')
    return *s - 'A' + 10;

  if(*s>='a' && *s<='f')
    return *s - 'a' + 10;

  return -1;
}




static
char* decode_percent(char* s)
{
  char* in = s;
  char* out = s;
  while(*in)
  {
    if(*in=='%')
    {
      const int high = unhex(++in); if(high<0 || *in=='\0') return 0;
      const int low = unhex(++in); if(low <0 || *in=='\0') return 0;
      *out = (char)(high*16u + low);
      ++out;
      ++in;
    }else{
      *out++ = *in++;
    }
  }
  *out = '\0';
  return s;
}


static
char*
scan_part(char* start, enum Category category, char delimiter1, char delimiter2) {
  char* p = start;
  for(;;)
  {
    if( *p=='\0' || *p==delimiter1 || *p==delimiter2)
       return p;

    if(char_cat[ (unsigned char) *p ] & category) {
      ++p;
    }else{
      return 0;
    }
  }
}


static
char*
scan_decimal_number(char* start)
{
  char* p = start;
  while(*p >='0' && *p<='9')
  {
    ++p;
  }

  return (p!=start) ? p : 0;
}


static
struct url_key_value* parse_query_string(char* begin, char* end)
{
  unsigned elements = 1;
  for(const char* p = begin; p!=end; ++p)
  {
    if(*p=='&' || *p==';')
      ++elements;
  }

  struct url_key_value* kv = calloc(elements+1, sizeof(struct url_key_value));
  if(!kv)
    return 0;

  char* p = begin;
  for(unsigned element=0; (element<=elements) && (p<end); ++element)
  {
    char* key = p;
    char* kv_end = scan_part(p, Query, '&', ';');
    if(!kv_end)
      do{ fprintf(stderr, "ERROR %s Line %u! p=«%s»\n", "/app/subjects/url_parser/url.c", 153 , p); goto error; }while(0);

    *kv_end = '\0';

    char* key_end = scan_part(p, Query, '=', '\0');

    const bool has_value = (*key_end == '=');
    *key_end = '\0';

    kv[element].key = decode_percent(key);
    if(has_value)
    {
      char* value = key_end+1;
      kv[element].value = decode_percent(value);
    }else{
      kv[element].value = key_end;
    }

    p = kv_end+1;

  }

  return kv;

error:
  free(kv);
  return 0;
}


url_data_t*
url_parse (const char* url) {
  url_data_t *data = (url_data_t *) calloc(1, sizeof(url_data_t));
  if (!data) return 0;

  char* p = strdup(url);
  if(!p)
    do{ fprintf(stderr, "ERROR %s Line %u! p=«%s»\n", "/app/subjects/url_parser/url.c", 190 , p); goto error; }while(0);

  data->whole_url = p;
  const char* const p_end = p + strlen(p);

  char* protocol_end = scan_part(p, Scheme, ':', '\0');
  if (!protocol_end || *protocol_end=='\0')
    do{ fprintf(stderr, "ERROR %s Line %u! p=«%s»\n", "/app/subjects/url_parser/url.c", 197 , p); goto error; }while(0);

  *protocol_end = '\0';
  data->protocol = p;
  const bool is_ssh = url_is_ssh(data->protocol);

  p = protocol_end + 1;
  if(p>=p_end || *p != '/')
    do{ fprintf(stderr, "ERROR %s Line %u! p=«%s»\n", "/app/subjects/url_parser/url.c", 205 , p); goto error; }while(0);

  ++p;
  if(p>=p_end || *p != '/')
    do{ fprintf(stderr, "ERROR %s Line %u! p=«%s»\n", "/app/subjects/url_parser/url.c", 209 , p); goto error; }while(0);

  char* const second_slash = p;

  ++p;
  if(p>=p_end)
    do{ fprintf(stderr, "ERROR %s Line %u! p=«%s»\n", "/app/subjects/url_parser/url.c", 215 , p); goto error; }while(0);

  char* userinfo_end = scan_part(p, Userinfo, '@', '\0');
  if(userinfo_end && *userinfo_end == '@') {
    *userinfo_end = '\0';
    data->userinfo = p;
    p = userinfo_end + 1;
  }

  if(p>=p_end)
    do{ fprintf(stderr, "ERROR %s Line %u! p=«%s»\n", "/app/subjects/url_parser/url.c", 225 , p); goto error; }while(0);

  char* hostname_end = 0;

  if(*p == '[')
  {
    ++p;
    hostname_end = scan_part( p, IPv6Char, ']', '\0' );
    if(!hostname_end)
      do{ fprintf(stderr, "ERROR %s Line %u! p=«%s»\n", "/app/subjects/url_parser/url.c", 234 , p); goto error; }while(0);

    *hostname_end = '\0';
    data->host = p;
    ++hostname_end;
    if(hostname_end < p_end && !is_ssh && *hostname_end==':')
    {
      char* port_end = scan_decimal_number( hostname_end+1 );
      if(port_end)
      {
        data->port = hostname_end+1;
        p = port_end;
      }else{
        do{ fprintf(stderr, "ERROR %s Line %u! p=«%s»\n", "/app/subjects/url_parser/url.c", 247 , p); goto error; }while(0);
      }
    }else{
      p = hostname_end;
    }
  }else{
    hostname_end = scan_part( p, Unreserved | SubDelim, ':', '/' );
    if (!hostname_end)
      do{ fprintf(stderr, "ERROR %s Line %u! p=«%s»\n", "/app/subjects/url_parser/url.c", 255 , p); goto error; }while(0);

    data->host = p;
    if(!is_ssh && *hostname_end==':')
    {
      *hostname_end = '\0';
      char* port_end = scan_decimal_number( hostname_end+1 );
      if(port_end)
      {
        data->port = hostname_end+1;
        p = port_end;
      }else{
        do{ fprintf(stderr, "ERROR %s Line %u! p=«%s»\n", "/app/subjects/url_parser/url.c", 267 , p); goto error; }while(0);
      }
    }else{
      p = hostname_end;
    }
  }


  memmove(second_slash, second_slash+1, p-second_slash);
  if(data->userinfo)
    --(data->userinfo);

  --(data->host);

  if(data->port)
    --(data->port);

  p[-1] = '\0';


  if(is_ssh && *p == ':')
  {
    ++p;
  }


  char* path_end = scan_part( p, PCharSlash, '?', '#' );
  if(!path_end)
    do{ fprintf(stderr, "ERROR %s Line %u! p=«%s»\n", "/app/subjects/url_parser/url.c", 295 , p); goto error; }while(0);

  const bool has_query = (*path_end == '?');
  const bool has_fragment = (*path_end == '#');
  *path_end = '\0';

  data->path = decode_percent(p);
  p = path_end + 1;
  if(has_query)
  {
    char* query_end = scan_part( p, Query, '#', '\0' );
    if(query_end)
    {
      const bool has_fragment = (*query_end == '#');
      *query_end = '\0';

      data->query = parse_query_string(p, query_end);
      if(has_fragment)
      {
        char* fragment_end = scan_part( query_end+1, Fragment, '\0', '\0' );
        if(fragment_end)
        {
          data->fragment = decode_percent(query_end+1);
        }else{
          do{ fprintf(stderr, "ERROR %s Line %u! p=«%s»\n", "/app/subjects/url_parser/url.c", 319 , p); goto error; }while(0);
        }
      }
    }else{
      do{ fprintf(stderr, "ERROR %s Line %u! p=«%s»\n", "/app/subjects/url_parser/url.c", 323 , p); goto error; }while(0);
    }
  }else if(has_fragment)
  {
        char* fragment_end = scan_part( p, Fragment, '\0', '\0' );
        if(fragment_end)
        {
          data->fragment = decode_percent(p);
        }else{
          do{ fprintf(stderr, "ERROR %s Line %u! p=«%s»\n", "/app/subjects/url_parser/url.c", 332 , p); goto error; }while(0);
        }
  }



  return data;

error:
  url_free(data);
  return 0;
}


bool
url_is_protocol (const char* str) {
  const unsigned count = sizeof(URL_SCHEMES) / sizeof(URL_SCHEMES[0]);

  for (unsigned i = 0; i < count; ++i) {
    if (0 == strcmp(URL_SCHEMES[i], str)) {
      return 1;
    }
  }

  return 0;
}

bool
url_is_ssh (const char* str) {
  if (0 == strcmp(str, "ssh") || 0 == strcmp(str, "git")) {
    return 1;
  }
  return 0;
}

char *
url_get_scheme (const char* url) {
  char *protocol = (char *) malloc(32);
  if (!protocol) return 0;

  sscanf(url, "%[^://]", protocol);
  if (url_is_protocol(protocol)) return protocol;

  free(protocol);
  return 0;
}
# 388 "/app/subjects/url_parser/url.c"
char *
url_get_userinfo (const char* url) {
  do{ url_data_t* data = url_parse(url); char* out = data && data->userinfo ? strdup(data->userinfo) : 0; url_free(data); return out; }while(0);
}

char *
url_get_hostname (const char* url) {
  do{ url_data_t* data = url_parse(url); char* out = data && data->host ? strdup(data->host) : 0; url_free(data); return out; }while(0);
}

char *
url_get_host (const char* url) {
  do{ url_data_t* data = url_parse(url); char* out = data && data->host ? strdup(data->host) : 0; url_free(data); return out; }while(0);
}

char *
url_get_pathname (const char* url) {
  do{ url_data_t* data = url_parse(url); char* out = data && data->path ? strdup(data->path) : 0; url_free(data); return out; }while(0);
}

char *
url_get_path (const char* url) {
  do{ url_data_t* data = url_parse(url); char* out = data && data->path ? strdup(data->path) : 0; url_free(data); return out; }while(0);
}


const char *
url_get_query_value (const url_data_t* url, const char* key)
{
  if(url->query == 0)
    return 0;

  for( const struct url_key_value* kv = url->query; kv->key; ++kv)
  {
     if(strcmp(kv->key, key) == 0)
       return kv->value;
  }
  return 0;
}


char *
url_get_fragment (const char* url) {
  do{ url_data_t* data = url_parse(url); char* out = data && data->fragment ? strdup(data->fragment) : 0; url_free(data); return out; }while(0);
}

char *
url_get_port (const char* url) {
  do{ url_data_t* data = url_parse(url); char* out = data && data->port ? strdup(data->port) : 0; url_free(data); return out; }while(0);
}

void
url_inspect (const char* url) {
  url_data_inspect(url_parse(url));
}
# 452 "/app/subjects/url_parser/url.c"
void
url_data_inspect (const url_data_t* data) {
  printf("#url =>\n");
  do{ if(data->protocol) printf("    ." "protocol" ": \"%s\"\n", data->protocol); else printf("    ." "protocol" ": (NULL)\n"); }while(0);
  do{ if(data->host) printf("    ." "host" ": \"%s\"\n", data->host); else printf("    ." "host" ": (NULL)\n"); }while(0);
  do{ if(data->userinfo) printf("    ." "userinfo" ": \"%s\"\n", data->userinfo); else printf("    ." "userinfo" ": (NULL)\n"); }while(0);
  do{ if(data->host) printf("    ." "host" ": \"%s\"\n", data->host); else printf("    ." "host" ": (NULL)\n"); }while(0);
  do{ if(data->port) printf("    ." "port" ": \"%s\"\n", data->port); else printf("    ." "port" ": (NULL)\n"); }while(0);
  do{ if(data->path) printf("    ." "path" ": \"%s\"\n", data->path); else printf("    ." "path" ": (NULL)\n"); }while(0);
  if(data->query)
  {
     for(unsigned nr=0; data->query[nr].key; ++nr)
     {
        printf("    .query[%u]: \"%s\" -> ", nr, data->query[nr].key);
        if(data->query[nr].value)
          printf("\"%s\"\n", data->query[nr].value);
        else
          printf("(NULL)\n");
     }
  }
  do{ if(data->fragment) printf("    ." "fragment" ": \"%s\"\n", data->fragment); else printf("    ." "fragment" ": (NULL)\n"); }while(0);
}

void
url_free (url_data_t *data) {
  if (!data) return;
  free(data->whole_url);
  free((void*)data->query);
  free(data);
}



extern inline
char* url_get_protocol (const char* url);

extern inline
char* url_get_hash (const char* url);
