[
  {
    "func_defid": "DefId(0:206 ~ c2rust[26e7]::src::markdown::hash_html_entity)",
    "span": "src/markdown.rs:715:1: 1026:2 (#0)",
    "pieces": [
      "src/markdown.rs:715:1: 717:4 (#0)",
      "src/markdown.rs:975:1: 975:4 (#0)",
      "src/markdown.rs:1026:1: 1026:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn hash_html_entity(mut str: *const std::os::raw::c_char,\n                                      mut len: size_t) -> std::os::raw::c_uint {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [
      {
        "caller": "DefId(0:234 ~ c2rust[26e7]::src::markdown::is_allowed_named_entity)",
        "span": "src/markdown.rs:1804:5: 1804:47 (#0)",
        "source": "let key: u32 = hash_html_entity(str, len);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/markdown.rs:717:5: 974:64 (#0)",
        "pieces": [
          "src/markdown.rs:717:5: 974:64 (#0)"
        ],
        "num_lines": 258,
        "source": "static mut asso_values: [std::os::raw::c_ushort; 257] =\n        [771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         0 as std::os::raw::c_int as std::os::raw::c_ushort,\n         95 as std::os::raw::c_int as std::os::raw::c_ushort,\n         90 as std::os::raw::c_int as std::os::raw::c_ushort,\n         0 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         0 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         115 as std::os::raw::c_int as std::os::raw::c_ushort,\n         94 as std::os::raw::c_int as std::os::raw::c_ushort,\n         55 as std::os::raw::c_int as std::os::raw::c_ushort,\n         0 as std::os::raw::c_int as std::os::raw::c_ushort,\n         150 as std::os::raw::c_int as std::os::raw::c_ushort,\n         25 as std::os::raw::c_int as std::os::raw::c_ushort,\n         0 as std::os::raw::c_int as std::os::raw::c_ushort,\n         30 as std::os::raw::c_int as std::os::raw::c_ushort,\n         195 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         30 as std::os::raw::c_int as std::os::raw::c_ushort,\n         30 as std::os::raw::c_int as std::os::raw::c_ushort,\n         5 as std::os::raw::c_int as std::os::raw::c_ushort,\n         35 as std::os::raw::c_int as std::os::raw::c_ushort,\n         45 as std::os::raw::c_int as std::os::raw::c_ushort,\n         45 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         10 as std::os::raw::c_int as std::os::raw::c_ushort,\n         0 as std::os::raw::c_int as std::os::raw::c_ushort,\n         50 as std::os::raw::c_int as std::os::raw::c_ushort,\n         125 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         5 as std::os::raw::c_int as std::os::raw::c_ushort,\n         85 as std::os::raw::c_int as std::os::raw::c_ushort,\n         75 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         40 as std::os::raw::c_int as std::os::raw::c_ushort,\n         65 as std::os::raw::c_int as std::os::raw::c_ushort,\n         20 as std::os::raw::c_int as std::os::raw::c_ushort,\n         25 as std::os::raw::c_int as std::os::raw::c_ushort,\n         60 as std::os::raw::c_int as std::os::raw::c_ushort,\n         240 as std::os::raw::c_int as std::os::raw::c_ushort,\n         240 as std::os::raw::c_int as std::os::raw::c_ushort,\n         223 as std::os::raw::c_int as std::os::raw::c_ushort,\n         10 as std::os::raw::c_int as std::os::raw::c_ushort,\n         102 as std::os::raw::c_int as std::os::raw::c_ushort,\n         20 as std::os::raw::c_int as std::os::raw::c_ushort,\n         35 as std::os::raw::c_int as std::os::raw::c_ushort,\n         135 as std::os::raw::c_int as std::os::raw::c_ushort,\n         0 as std::os::raw::c_int as std::os::raw::c_ushort,\n         5 as std::os::raw::c_int as std::os::raw::c_ushort,\n         10 as std::os::raw::c_int as std::os::raw::c_ushort,\n         183 as std::os::raw::c_int as std::os::raw::c_ushort,\n         20 as std::os::raw::c_int as std::os::raw::c_ushort,\n         5 as std::os::raw::c_int as std::os::raw::c_ushort,\n         0 as std::os::raw::c_int as std::os::raw::c_ushort,\n         50 as std::os::raw::c_int as std::os::raw::c_ushort,\n         75 as std::os::raw::c_int as std::os::raw::c_ushort,\n         10 as std::os::raw::c_int as std::os::raw::c_ushort,\n         75 as std::os::raw::c_int as std::os::raw::c_ushort,\n         175 as std::os::raw::c_int as std::os::raw::c_ushort,\n         85 as std::os::raw::c_int as std::os::raw::c_ushort,\n         15 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort,\n         771 as std::os::raw::c_int as std::os::raw::c_ushort];",
        "sub_chunks": [],
        "live_in": [],
        "live_out": []
      },
      {
        "chunk_id": 1,
        "span": "src/markdown.rs:975:5: 1024:5 (#0)",
        "pieces": [
          "src/markdown.rs:975:5: 1024:5 (#0)"
        ],
        "num_lines": 76,
        "source": "let mut hval: std::os::raw::c_uint = len as std::os::raw::c_uint;\n    let mut current_block_5: u64;\n    match hval {\n        6 => { current_block_5 = 16299309038112539419; }\n        5 => { current_block_5 = 14964981520188694172; }\n        4 => { current_block_5 = 2667878016629255385; }\n        3 => { current_block_5 = 17022361381020267513; }\n        2 => { current_block_5 = 4358686903994191085; }\n        _ => {\n            hval =\n                hval.wrapping_add(asso_values[*str.offset(6 as std::os::raw::c_int as\n                                                              isize) as\n                                                  std::os::raw::c_uchar as usize] as\n                                      std::os::raw::c_uint);\n            current_block_5 = 16299309038112539419;\n        }\n    }\n    match current_block_5 {\n        16299309038112539419 =>\n        /*FALLTHROUGH*/\n        {\n            hval =\n                hval.wrapping_add(asso_values[*str.offset(5 as std::os::raw::c_int as\n                                                              isize) as\n                                                  std::os::raw::c_uchar as usize] as\n                                      std::os::raw::c_uint);\n            current_block_5 = 14964981520188694172;\n        }\n        _ => { }\n    }\n    match current_block_5 {\n        14964981520188694172 =>\n        /*FALLTHROUGH*/\n        {\n            hval =\n                hval.wrapping_add(asso_values[*str.offset(4 as std::os::raw::c_int as\n                                                              isize) as\n                                                  std::os::raw::c_uchar as usize] as\n                                      std::os::raw::c_uint);\n            current_block_5 = 2667878016629255385;\n        }\n        _ => { }\n    }\n    match current_block_5 {\n        2667878016629255385 =>\n        /*FALLTHROUGH*/\n        {\n            hval =\n                hval.wrapping_add(asso_values[*str.offset(3 as std::os::raw::c_int as\n                                                              isize) as\n                                                  std::os::raw::c_uchar as usize] as\n                                      std::os::raw::c_uint);\n            current_block_5 = 17022361381020267513;\n        }\n        _ => { }\n    }\n    match current_block_5 {\n        17022361381020267513 =>\n        /*FALLTHROUGH*/\n        {\n            hval =\n                hval.wrapping_add(asso_values[(*str.offset(2 as std::os::raw::c_int as\n                                                               isize) as\n                                                   std::os::raw::c_uchar as\n                                                   std::os::raw::c_int +\n                                                   1 as std::os::raw::c_int) as usize]\n                                      as std::os::raw::c_uint)\n        }\n        _ => { }\n    }\n    /*FALLTHROUGH*/\n    hval =\n        hval.wrapping_add(asso_values[*str.offset(1 as std::os::raw::c_int as isize)\n                                          as std::os::raw::c_uchar as usize] as\n                              std::os::raw::c_uint);\n    return hval;",
        "sub_chunks": [],
        "live_in": [
          "mut str: *const i8",
          "mut len: u64"
        ],
        "live_out": [
          "mut str: *const i8",
          "mut len: u64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:234 ~ c2rust[26e7]::src::markdown::char_codespan)",
    "span": "src/markdown.rs:2630:1: 2694:2 (#0)",
    "pieces": [
      "src/markdown.rs:2630:1: 2694:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 65,
    "source": "unsafe extern \"C\" fn char_codespan(mut ob: *mut buf,\n                                   mut rndr: *mut sd_markdown,\n                                   mut data: *mut uint8_t,\n                                   mut max_rewind: size_t,\n                                   mut max_lookbehind: size_t,\n                                   mut size: size_t) -> size_t {\n    let mut end: size_t = 0;\n    let mut nb: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut i: size_t = 0;\n    let mut f_begin: size_t = 0;\n    let mut f_end: size_t = 0;\n    /* counting the number of backticks in the delimiter */\n    while nb < size && *data.offset(nb as isize) as std::os::raw::c_int == '`' as i32\n          {\n        nb = nb.wrapping_add(1)\n    }\n    /* finding the next delimiter */\n    i = 0 as std::os::raw::c_int as size_t; /* no matching delimiter */\n    end = nb;\n    while end < size && i < nb {\n        if *data.offset(end as isize) as std::os::raw::c_int == '`' as i32 {\n            i = i.wrapping_add(1)\n        } else { i = 0 as std::os::raw::c_int as size_t }\n        end = end.wrapping_add(1)\n    }\n    if i < nb && end >= size { return 0 as std::os::raw::c_int as size_t }\n    /* trimming outside whitespaces */\n    f_begin = nb;\n    while f_begin < end &&\n              *data.offset(f_begin as isize) as std::os::raw::c_int == ' ' as i32 {\n        f_begin = f_begin.wrapping_add(1)\n    }\n    f_end = end.wrapping_sub(nb);\n    while f_end > nb &&\n              *data.offset(f_end.wrapping_sub(1 as std::os::raw::c_int as\n                                                  std::os::raw::c_ulong) as isize) as\n                  std::os::raw::c_int == ' ' as i32 {\n        f_end = f_end.wrapping_sub(1)\n    }\n    /* real code span */\n    if f_begin < f_end {\n        let mut work: buf =\n            {\n                let mut init =\n                    buf{data: data.offset(f_begin as isize),\n                        size: f_end.wrapping_sub(f_begin),\n                        asize: 0 as std::os::raw::c_int as size_t,\n                        unit: 0 as std::os::raw::c_int as size_t,};\n                init\n            };\n        if (*rndr).cb.codespan.expect(\"non-null function pointer\")(ob,\n                                                                   &mut work,\n                                                                   (*rndr).opaque)\n               == 0 {\n            end = 0 as std::os::raw::c_int as size_t\n        }\n    } else if (*rndr).cb.codespan.expect(\"non-null function pointer\")(ob,\n                                                                      0 as\n                                                                          *const buf,\n                                                                      (*rndr).opaque)\n                  == 0 {\n        end = 0 as std::os::raw::c_int as size_t\n    }\n    return end;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:217 ~ c2rust[26e7]::src::markdown::rndr_popbuf)",
    "span": "src/markdown.rs:1896:1: 1900:2 (#0)",
    "pieces": [
      "src/markdown.rs:1896:1: 1900:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn rndr_popbuf(mut rndr: *mut sd_markdown,\n                                 mut type_0: std::os::raw::c_int) {\n    (*rndr).work_bufs[type_0 as usize].size =\n        (*rndr).work_bufs[type_0 as usize].size.wrapping_sub(1);\n}",
    "calls": [
      {
        "caller": "DefId(0:289 ~ c2rust[26e7]::src::markdown::parse_blockcode)",
        "span": "src/markdown.rs:4179:5: 4179:49 (#0)",
        "source": "rndr_popbuf(rndr, 0 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust[26e7]::src::markdown::char_autolink_subreddit_or_username)",
        "span": "src/markdown.rs:2978:9: 2978:53 (#0)",
        "source": "rndr_popbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust[26e7]::src::markdown::char_autolink_subreddit_or_username)",
        "span": "src/markdown.rs:2980:5: 2980:49 (#0)",
        "source": "rndr_popbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:285 ~ c2rust[26e7]::src::markdown::parse_blockquote)",
        "span": "src/markdown.rs:3818:5: 3818:49 (#0)",
        "source": "rndr_popbuf(rndr, 0 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:266 ~ c2rust[26e7]::src::markdown::char_autolink_www)",
        "span": "src/markdown.rs:2921:5: 2921:49 (#0)",
        "source": "rndr_popbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:292 ~ c2rust[26e7]::src::markdown::parse_atxheader)",
        "span": "src/markdown.rs:4394:9: 4394:53 (#0)",
        "source": "rndr_popbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:287 ~ c2rust[26e7]::src::markdown::parse_paragraph)",
        "span": "src/markdown.rs:3993:5: 3993:26 (#0)",
        "source": "rndr_popbuf(rndr, 0);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust[26e7]::src::markdown::char_autolink_subreddit_or_username)",
        "span": "src/markdown.rs:2970:13: 2970:57 (#0)",
        "source": "rndr_popbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:290 ~ c2rust[26e7]::src::markdown::parse_listitem)",
        "span": "src/markdown.rs:4326:5: 4326:49 (#0)",
        "source": "rndr_popbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:265 ~ c2rust[26e7]::src::markdown::char_langle_tag)",
        "span": "src/markdown.rs:2862:13: 2862:57 (#0)",
        "source": "rndr_popbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:286 ~ c2rust[26e7]::src::markdown::parse_blockspoiler)",
        "span": "src/markdown.rs:3883:5: 3883:49 (#0)",
        "source": "rndr_popbuf(rndr, 0 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:291 ~ c2rust[26e7]::src::markdown::parse_list)",
        "span": "src/markdown.rs:4348:5: 4348:49 (#0)",
        "source": "rndr_popbuf(rndr, 0 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:296 ~ c2rust[26e7]::src::markdown::parse_table_row)",
        "span": "src/markdown.rs:4698:5: 4698:49 (#0)",
        "source": "rndr_popbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:266 ~ c2rust[26e7]::src::markdown::char_autolink_www)",
        "span": "src/markdown.rs:2911:13: 2911:57 (#0)",
        "source": "rndr_popbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:298 ~ c2rust[26e7]::src::markdown::parse_table)",
        "span": "src/markdown.rs:4847:5: 4847:49 (#0)",
        "source": "rndr_popbuf(rndr, 0 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:290 ~ c2rust[26e7]::src::markdown::parse_listitem)",
        "span": "src/markdown.rs:4325:5: 4325:49 (#0)",
        "source": "rndr_popbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:287 ~ c2rust[26e7]::src::markdown::parse_paragraph)",
        "span": "src/markdown.rs:4017:13: 4017:34 (#0)",
        "source": "rndr_popbuf(rndr, 0);"
      },
      {
        "caller": "DefId(0:298 ~ c2rust[26e7]::src::markdown::parse_table)",
        "span": "src/markdown.rs:4846:5: 4846:49 (#0)",
        "source": "rndr_popbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:288 ~ c2rust[26e7]::src::markdown::parse_fencedcode)",
        "span": "src/markdown.rs:4119:5: 4119:49 (#0)",
        "source": "rndr_popbuf(rndr, 0 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:272 ~ c2rust[26e7]::src::markdown::char_superscript)",
        "span": "src/markdown.rs:3391:5: 3391:49 (#0)",
        "source": "rndr_popbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:287 ~ c2rust[26e7]::src::markdown::parse_paragraph)",
        "span": "src/markdown.rs:4030:5: 4030:26 (#0)",
        "source": "rndr_popbuf(rndr, 1);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust[26e7]::src::markdown::char_autolink_url)",
        "span": "src/markdown.rs:3032:5: 3032:49 (#0)",
        "source": "rndr_popbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:266 ~ c2rust[26e7]::src::markdown::char_autolink_www)",
        "span": "src/markdown.rs:2919:9: 2919:53 (#0)",
        "source": "rndr_popbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:269 ~ c2rust[26e7]::src::markdown::char_autolink_email)",
        "span": "src/markdown.rs:3006:5: 3006:49 (#0)",
        "source": "rndr_popbuf(rndr, 1 as std::os::raw::c_int);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:293 ~ c2rust[26e7]::src::stack::stack_push)",
    "span": "src/stack.rs:83:1: 96:2 (#0)",
    "pieces": [
      "src/stack.rs:83:1: 96:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn stack_push(mut st: *mut stack,\n                                    mut item: *mut std::os::raw::c_void)\n -> std::os::raw::c_int {\n    if stack_grow(st,\n                  (*st).size.wrapping_mul(2 as std::os::raw::c_int as std::os::raw::c_ulong))\n           < 0 as std::os::raw::c_int {\n        return -(1 as std::os::raw::c_int)\n    }\n    let fresh0 = (*st).size;\n    (*st).size = (*st).size.wrapping_add(1);\n    let ref mut fresh1 = *(*st).item.offset(fresh0 as isize);\n    *fresh1 = item;\n    return 0 as std::os::raw::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:239 ~ c2rust[26e7]::src::markdown::rndr_newbuf)",
        "span": "src/markdown.rs:1891:9: 1891:61 (#0)",
        "source": "stack_push(pool, work as *mut std::os::raw::c_void);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/stack.rs:4:1: 4:26 (#0)",
        "source": "use std::os::raw::c_void;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:62 ~ c2rust[26e7]::src::buffer::bufnew)",
    "span": "src/buffer.rs:86:1: 108:2 (#0)",
    "pieces": [
      "src/buffer.rs:86:1: 108:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn bufnew(mut unit: size_t) -> *mut buf {\n    let mut ret: *mut buf = 0 as *mut buf;\n    ret = malloc(::std::mem::size_of::<buf>() as std::os::raw::c_ulong) as *mut buf;\n    if !ret.is_null() {\n        (*ret).data = 0 as *mut uint8_t;\n        (*ret).asize = 0 as std::os::raw::c_int as size_t;\n        (*ret).size = (*ret).asize;\n        (*ret).unit = unit\n    }\n    return ret;\n}",
    "calls": [
      {
        "caller": "DefId(0:300 ~ c2rust[26e7]::src::markdown::is_ref)",
        "span": "src/markdown.rs:5137:5: 5137:64 (#0)",
        "source": "(*ref_0).link = bufnew(link_end.wrapping_sub(link_offset));"
      },
      {
        "caller": "DefId(0:239 ~ c2rust[26e7]::src::markdown::rndr_newbuf)",
        "span": "src/markdown.rs:1889:9: 1889:65 (#0)",
        "source": "let work_buf = bufnew(buf_size[type_0 as usize] as u64);"
      },
      {
        "caller": "DefId(0:300 ~ c2rust[26e7]::src::markdown::is_ref)",
        "span": "src/markdown.rs:5141:9: 5141:71 (#0)",
        "source": "(*ref_0).title = bufnew(title_end.wrapping_sub(title_offset));"
      },
      {
        "caller": "DefId(0:303 ~ c2rust[26e7]::src::markdown::sd_markdown_render)",
        "span": "src/markdown.rs:5272:5: 5272:31 (#0)",
        "source": "let text_buf = bufnew(64);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/buffer.rs:6:1: 6:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/buffer.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/buffer.rs:12:1: 12:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/buffer.rs:11:1: 11:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/buffer.rs:8:1: 8:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:214 ~ c2rust[26e7]::src::markdown::rndr_newbuf)",
    "span": "src/markdown.rs:1874:1: 1894:2 (#0)",
    "pieces": [
      "src/markdown.rs:1874:1: 1894:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "unsafe extern \"C\" fn rndr_newbuf(mut rndr: *mut sd_markdown,\n                                 mut type_0: std::os::raw::c_int) -> *mut buf {\n    static mut buf_size: [size_t; 2] =\n        [256 as std::os::raw::c_int as size_t, 64 as std::os::raw::c_int as size_t];\n    let mut work: *mut buf = 0 as *mut buf;\n    let mut pool: *mut stack =\n        &mut *(*rndr).work_bufs.as_mut_ptr().offset(type_0 as isize) as\n            *mut stack;\n    if (*pool).size < (*pool).asize &&\n           !(*(*pool).item.offset((*pool).size as isize)).is_null() {\n        let fresh0 = (*pool).size;\n        (*pool).size = (*pool).size.wrapping_add(1);\n        work = *(*pool).item.offset(fresh0 as isize) as *mut buf;\n        (*work).size = 0 as std::os::raw::c_int as size_t\n    } else {\n        work = bufnew(buf_size[type_0 as usize]);\n        stack_push(pool, work as *mut std::os::raw::c_void);\n    }\n    return work;\n}",
    "calls": [
      {
        "caller": "DefId(0:268 ~ c2rust[26e7]::src::markdown::char_autolink_subreddit_or_username)",
        "span": "src/markdown.rs:2944:5: 2944:56 (#0)",
        "source": "link = rndr_newbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:271 ~ c2rust[26e7]::src::markdown::char_link)",
        "span": "src/markdown.rs:3181:17: 3181:49 (#0)",
        "source": "let link = rndr_newbuf(rndr, 1);"
      },
      {
        "caller": "DefId(0:286 ~ c2rust[26e7]::src::markdown::parse_blockspoiler)",
        "span": "src/markdown.rs:3832:5: 3832:55 (#0)",
        "source": "out = rndr_newbuf(rndr, 0 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:266 ~ c2rust[26e7]::src::markdown::char_autolink_www)",
        "span": "src/markdown.rs:2886:5: 2886:56 (#0)",
        "source": "link = rndr_newbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:290 ~ c2rust[26e7]::src::markdown::parse_listitem)",
        "span": "src/markdown.rs:4216:5: 4216:57 (#0)",
        "source": "inter = rndr_newbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:272 ~ c2rust[26e7]::src::markdown::char_superscript)",
        "span": "src/markdown.rs:3386:5: 3386:55 (#0)",
        "source": "sup = rndr_newbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust[26e7]::src::markdown::char_autolink_subreddit_or_username)",
        "span": "src/markdown.rs:2961:13: 2961:69 (#0)",
        "source": "link_text = rndr_newbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:271 ~ c2rust[26e7]::src::markdown::char_link)",
        "span": "src/markdown.rs:3304:13: 3304:44 (#0)",
        "source": "content = rndr_newbuf(rndr, 1);"
      },
      {
        "caller": "DefId(0:292 ~ c2rust[26e7]::src::markdown::parse_atxheader)",
        "span": "src/markdown.rs:4385:9: 4385:78 (#0)",
        "source": "let mut work: *mut buf = rndr_newbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:285 ~ c2rust[26e7]::src::markdown::parse_blockquote)",
        "span": "src/markdown.rs:3769:5: 3769:55 (#0)",
        "source": "out = rndr_newbuf(rndr, 0 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust[26e7]::src::markdown::char_autolink_url)",
        "span": "src/markdown.rs:3021:5: 3021:56 (#0)",
        "source": "link = rndr_newbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:271 ~ c2rust[26e7]::src::markdown::char_link)",
        "span": "src/markdown.rs:3220:13: 3220:46 (#0)",
        "source": "let mut b = rndr_newbuf(rndr, 1);"
      },
      {
        "caller": "DefId(0:287 ~ c2rust[26e7]::src::markdown::parse_paragraph)",
        "span": "src/markdown.rs:4012:13: 4012:46 (#0)",
        "source": "let tmp_0 = rndr_newbuf(rndr, 0);"
      },
      {
        "caller": "DefId(0:290 ~ c2rust[26e7]::src::markdown::parse_listitem)",
        "span": "src/markdown.rs:4215:5: 4215:56 (#0)",
        "source": "work = rndr_newbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:291 ~ c2rust[26e7]::src::markdown::parse_list)",
        "span": "src/markdown.rs:4336:5: 4336:56 (#0)",
        "source": "work = rndr_newbuf(rndr, 0 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:266 ~ c2rust[26e7]::src::markdown::char_autolink_www)",
        "span": "src/markdown.rs:2891:9: 2891:64 (#0)",
        "source": "link_url = rndr_newbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:271 ~ c2rust[26e7]::src::markdown::char_link)",
        "span": "src/markdown.rs:3267:5: 3267:40 (#0)",
        "source": "let mut b_0 = rndr_newbuf(rndr, 1);"
      },
      {
        "caller": "DefId(0:271 ~ c2rust[26e7]::src::markdown::char_link)",
        "span": "src/markdown.rs:3185:17: 3185:50 (#0)",
        "source": "let title = rndr_newbuf(rndr, 1);"
      },
      {
        "caller": "DefId(0:298 ~ c2rust[26e7]::src::markdown::parse_table)",
        "span": "src/markdown.rs:4808:5: 4808:63 (#0)",
        "source": "header_work = rndr_newbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust[26e7]::src::markdown::char_autolink_subreddit_or_username)",
        "span": "src/markdown.rs:2955:9: 2955:64 (#0)",
        "source": "link_url = rndr_newbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:287 ~ c2rust[26e7]::src::markdown::parse_paragraph)",
        "span": "src/markdown.rs:3988:5: 3988:36 (#0)",
        "source": "let tmp = rndr_newbuf(rndr, 0);"
      },
      {
        "caller": "DefId(0:266 ~ c2rust[26e7]::src::markdown::char_autolink_www)",
        "span": "src/markdown.rs:2902:13: 2902:69 (#0)",
        "source": "link_text = rndr_newbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:289 ~ c2rust[26e7]::src::markdown::parse_blockcode)",
        "span": "src/markdown.rs:4130:5: 4130:56 (#0)",
        "source": "work = rndr_newbuf(rndr, 0 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:298 ~ c2rust[26e7]::src::markdown::parse_table)",
        "span": "src/markdown.rs:4809:5: 4809:61 (#0)",
        "source": "body_work = rndr_newbuf(rndr, 0 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:271 ~ c2rust[26e7]::src::markdown::char_link)",
        "span": "src/markdown.rs:3317:13: 3317:43 (#0)",
        "source": "u_link = rndr_newbuf(rndr, 1);"
      },
      {
        "caller": "DefId(0:265 ~ c2rust[26e7]::src::markdown::char_langle_tag)",
        "span": "src/markdown.rs:2853:13: 2853:84 (#0)",
        "source": "let mut u_link: *mut buf = rndr_newbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:287 ~ c2rust[26e7]::src::markdown::parse_paragraph)",
        "span": "src/markdown.rs:4025:5: 4025:40 (#0)",
        "source": "header_work = rndr_newbuf(rndr, 1);"
      },
      {
        "caller": "DefId(0:288 ~ c2rust[26e7]::src::markdown::parse_fencedcode)",
        "span": "src/markdown.rs:4058:5: 4058:56 (#0)",
        "source": "work = rndr_newbuf(rndr, 0 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:269 ~ c2rust[26e7]::src::markdown::char_autolink_email)",
        "span": "src/markdown.rs:2995:5: 2995:56 (#0)",
        "source": "link = rndr_newbuf(rndr, 1 as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:296 ~ c2rust[26e7]::src::markdown::parse_table_row)",
        "span": "src/markdown.rs:4632:5: 4632:60 (#0)",
        "source": "row_work = rndr_newbuf(rndr, 1 as std::os::raw::c_int);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:269 ~ c2rust[26e7]::src::markdown::parse_table_row)",
    "span": "src/markdown.rs:4619:1: 4699:2 (#0)",
    "pieces": [
      "src/markdown.rs:4619:1: 4699:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 81,
    "source": "unsafe extern \"C\" fn parse_table_row(mut ob: *mut buf,\n                                     mut rndr: *mut sd_markdown,\n                                     mut data: *mut uint8_t, mut size: size_t,\n                                     mut columns: size_t,\n                                     mut col_data: *mut std::os::raw::c_int,\n                                     mut header_flag: std::os::raw::c_int) {\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut col: size_t = 0;\n    let mut cols_left: size_t = 0;\n    let mut row_work: *mut buf = 0 as *mut buf;\n    if (*rndr).cb.table_cell.is_none() || (*rndr).cb.table_row.is_none() {\n        return\n    }\n    row_work = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n    if i < size && *data.offset(i as isize) as std::os::raw::c_int == '|' as i32 {\n        i = i.wrapping_add(1)\n    }\n    col = 0 as std::os::raw::c_int as size_t;\n    while col < columns && i < size {\n        let mut cell_start: size_t = 0;\n        let mut cell_end: size_t = 0;\n        let mut cell_work: *mut buf = 0 as *mut buf;\n        cell_work = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n        while i < size &&\n                  _isspace(*data.offset(i as isize) as std::os::raw::c_int) != 0 {\n            i = i.wrapping_add(1)\n        }\n        cell_start = i;\n        while i < size &&\n                  *data.offset(i as isize) as std::os::raw::c_int != '|' as i32 {\n            i = i.wrapping_add(1)\n        }\n        cell_end = i.wrapping_sub(1 as std::os::raw::c_int as std::os::raw::c_ulong);\n        while cell_end > cell_start &&\n                  _isspace(*data.offset(cell_end as isize) as std::os::raw::c_int) !=\n                      0 {\n            cell_end = cell_end.wrapping_sub(1)\n        }\n        parse_inline(cell_work, rndr, data.offset(cell_start as isize),\n                     (1 as std::os::raw::c_int as\n                          std::os::raw::c_ulong).wrapping_add(cell_end).wrapping_sub(cell_start));\n        (*rndr).cb.table_cell.expect(\"non-null function pointer\")(row_work,\n                                                                  cell_work,\n                                                                  *col_data.offset(col\n                                                                                       as\n                                                                                       isize)\n                                                                      |\n                                                                      header_flag,\n                                                                  (*rndr).opaque,\n                                                                  0 as\n                                                                      std::os::raw::c_int);\n        rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n        i = i.wrapping_add(1);\n        col = col.wrapping_add(1)\n    }\n    cols_left = columns.wrapping_sub(col);\n    if cols_left > 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        let mut empty_cell: buf =\n            {\n                let mut init =\n                    buf{data: 0 as *mut uint8_t,\n                        size: 0 as std::os::raw::c_int as size_t,\n                        asize: 0 as std::os::raw::c_int as size_t,\n                        unit: 0 as std::os::raw::c_int as size_t,};\n                init\n            };\n        (*rndr).cb.table_cell.expect(\"non-null function pointer\")(row_work,\n                                                                  &mut empty_cell,\n                                                                  *col_data.offset(col\n                                                                                       as\n                                                                                       isize)\n                                                                      |\n                                                                      header_flag,\n                                                                  (*rndr).opaque,\n                                                                  cols_left as\n                                                                      std::os::raw::c_int);\n    }\n    (*rndr).cb.table_row.expect(\"non-null function pointer\")(ob, row_work,\n                                                             (*rndr).opaque);\n    rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:297 ~ c2rust[26e7]::src::markdown::parse_table_header)",
        "span": "src/markdown.rs:4796:5: 4797:62 (#0)",
        "source": "parse_table_row(ob, rndr, data, header_end, *columns, *column_data,\n                    MKD_TABLE_HEADER as std::os::raw::c_int);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:270 ~ c2rust[26e7]::src::markdown::parse_table_header)",
    "span": "src/markdown.rs:4700:1: 4799:2 (#0)",
    "pieces": [
      "src/markdown.rs:4700:1: 4799:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 100,
    "source": "unsafe extern \"C\" fn parse_table_header(mut ob: *mut buf,\n                                        mut rndr: *mut sd_markdown,\n                                        mut data: *mut uint8_t,\n                                        mut size: size_t,\n                                        mut columns: *mut size_t,\n                                        mut column_data:\n                                            *mut *mut std::os::raw::c_int) -> size_t {\n    let mut pipes: std::os::raw::c_int = 0;\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut col: size_t = 0;\n    let mut header_end: size_t = 0;\n    let mut under_end: size_t = 0;\n    pipes = 0 as std::os::raw::c_int;\n    while i < size && *data.offset(i as isize) as std::os::raw::c_int != '\\n' as i32 {\n        let fresh2 = i;\n        i = i.wrapping_add(1);\n        if *data.offset(fresh2 as isize) as std::os::raw::c_int == '|' as i32 {\n            pipes += 1\n        }\n    }\n    if i == size || pipes == 0 as std::os::raw::c_int {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    header_end = i;\n    while header_end > 0 as std::os::raw::c_int as std::os::raw::c_ulong &&\n              _isspace(*data.offset(header_end.wrapping_sub(1 as std::os::raw::c_int\n                                                                as\n                                                                std::os::raw::c_ulong)\n                                        as isize) as std::os::raw::c_int) != 0 {\n        header_end = header_end.wrapping_sub(1)\n    }\n    if *data.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int == '|' as i32 {\n        pipes -= 1\n    }\n    if header_end != 0 &&\n           *data.offset(header_end.wrapping_sub(1 as std::os::raw::c_int as\n                                                    std::os::raw::c_ulong) as isize)\n               as std::os::raw::c_int == '|' as i32 {\n        pipes -= 1\n    }\n    if (pipes + 1 as std::os::raw::c_int) as std::os::raw::c_ulong > (*rndr).max_table_cols {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    *columns = (pipes + 1 as std::os::raw::c_int) as size_t;\n    *column_data =\n        calloc(*columns,\n               ::std::mem::size_of::<std::os::raw::c_int>() as std::os::raw::c_ulong) as\n            *mut std::os::raw::c_int;\n    /* Parse the header underline */\n    i = i.wrapping_add(1);\n    if i < size && *data.offset(i as isize) as std::os::raw::c_int == '|' as i32 {\n        i = i.wrapping_add(1)\n    }\n    under_end = i;\n    while under_end < size &&\n              *data.offset(under_end as isize) as std::os::raw::c_int != '\\n' as i32 {\n        under_end = under_end.wrapping_add(1)\n    }\n    col = 0 as std::os::raw::c_int as size_t;\n    while col < *columns && i < under_end {\n        let mut dashes: size_t = 0 as std::os::raw::c_int as size_t;\n        while i < under_end &&\n                  *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n            i = i.wrapping_add(1)\n        }\n        if *data.offset(i as isize) as std::os::raw::c_int == ':' as i32 {\n            i = i.wrapping_add(1);\n            *(*column_data).offset(col as isize) |=\n                MKD_TABLE_ALIGN_L as std::os::raw::c_int;\n            dashes = dashes.wrapping_add(1)\n        }\n        while i < under_end &&\n                  *data.offset(i as isize) as std::os::raw::c_int == '-' as i32 {\n            i = i.wrapping_add(1);\n            dashes = dashes.wrapping_add(1)\n        }\n        if i < under_end &&\n               *data.offset(i as isize) as std::os::raw::c_int == ':' as i32 {\n            i = i.wrapping_add(1);\n            *(*column_data).offset(col as isize) |=\n                MKD_TABLE_ALIGN_R as std::os::raw::c_int;\n            dashes = dashes.wrapping_add(1)\n        }\n        while i < under_end &&\n                  *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n            i = i.wrapping_add(1)\n        }\n        if i < under_end &&\n               *data.offset(i as isize) as std::os::raw::c_int != '|' as i32 {\n            break ;\n        }\n        if dashes < 1 as std::os::raw::c_int as std::os::raw::c_ulong { break ; }\n        i = i.wrapping_add(1);\n        col = col.wrapping_add(1)\n    }\n    if col < *columns { return 0 as std::os::raw::c_int as size_t }\n    parse_table_row(ob, rndr, data, header_end, *columns, *column_data,\n                    MKD_TABLE_HEADER as std::os::raw::c_int);\n    return under_end.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:298 ~ c2rust[26e7]::src::markdown::parse_table)",
        "span": "src/markdown.rs:4810:5: 4812:43 (#0)",
        "source": "i =\n        parse_table_header(header_work, rndr, data, size, &mut columns,\n                           &mut col_data);"
      }
    ],
    "globals": [
      {
        "span": "src/markdown.rs:168:1: 168:48 (#0)",
        "source": "pub const MKD_TABLE_HEADER: mkd_tableflags = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:271 ~ c2rust[26e7]::src::markdown::parse_table)",
    "span": "src/markdown.rs:4800:1: 4849:2 (#0)",
    "pieces": [
      "src/markdown.rs:4800:1: 4849:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 50,
    "source": "unsafe extern \"C\" fn parse_table(mut ob: *mut buf, mut rndr: *mut sd_markdown,\n                                 mut data: *mut uint8_t, mut size: size_t)\n -> size_t {\n    let mut i: size_t = 0;\n    let mut header_work: *mut buf = 0 as *mut buf;\n    let mut body_work: *mut buf = 0 as *mut buf;\n    let mut columns: size_t = 0;\n    let mut col_data: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;\n    header_work = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n    body_work = rndr_newbuf(rndr, 0 as std::os::raw::c_int);\n    i =\n        parse_table_header(header_work, rndr, data, size, &mut columns,\n                           &mut col_data);\n    if i > 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        while i < size {\n            let mut row_start: size_t = 0;\n            let mut pipes: std::os::raw::c_int = 0 as std::os::raw::c_int;\n            row_start = i;\n            while i < size &&\n                      *data.offset(i as isize) as std::os::raw::c_int != '\\n' as i32 {\n                let fresh3 = i;\n                i = i.wrapping_add(1);\n                if *data.offset(fresh3 as isize) as std::os::raw::c_int == '|' as i32\n                   {\n                    pipes += 1\n                }\n            }\n            if pipes == 0 as std::os::raw::c_int || i == size {\n                i = row_start;\n                break ;\n            } else {\n                parse_table_row(body_work, rndr,\n                                data.offset(row_start as isize),\n                                i.wrapping_sub(row_start), columns, col_data,\n                                0 as std::os::raw::c_int);\n                i = i.wrapping_add(1)\n            }\n        }\n        if (*rndr).cb.table.is_some() {\n            (*rndr).cb.table.expect(\"non-null function pointer\")(ob,\n                                                                 header_work,\n                                                                 body_work,\n                                                                 (*rndr).opaque);\n        }\n    }\n    free(col_data as *mut std::os::raw::c_void);\n    rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n    rndr_popbuf(rndr, 0 as std::os::raw::c_int);\n    return i;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:294 ~ c2rust[26e7]::src::stack::stack_top)",
    "span": "src/stack.rs:98:1: 105:2 (#0)",
    "pieces": [
      "src/stack.rs:98:1: 105:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn stack_top(mut st: *mut stack) -> *mut std::os::raw::c_void {\n    if (*st).size == 0 { return 0 as *mut std::os::raw::c_void }\n    return *(*st).item.offset((*st).size.wrapping_sub(1 as std::os::raw::c_int as\n                                                          std::os::raw::c_ulong) as\n                                  isize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stack.rs:4:1: 4:26 (#0)",
        "source": "use std::os::raw::c_void;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:255 ~ c2rust[26e7]::src::markdown::prefix_code)",
    "span": "src/markdown.rs:3683:1: 3697:2 (#0)",
    "pieces": [
      "src/markdown.rs:3683:1: 3697:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "unsafe extern \"C\" fn prefix_code(mut data: *mut uint8_t, mut size: size_t)\n -> size_t {\n    if size > 3 as std::os::raw::c_int as std::os::raw::c_ulong &&\n           *data.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n               ' ' as i32 &&\n           *data.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n               ' ' as i32 &&\n           *data.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n               ' ' as i32 &&\n           *data.offset(3 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n               ' ' as i32 {\n        return 4 as std::os::raw::c_int as size_t\n    }\n    return 0 as std::os::raw::c_int as size_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:272 ~ c2rust[26e7]::src::markdown::parse_block)",
    "span": "src/markdown.rs:4852:1: 4969:2 (#0)",
    "pieces": [
      "src/markdown.rs:4852:1: 4969:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 118,
    "source": "unsafe extern \"C\" fn parse_block(mut ob: *mut buf, mut rndr: *mut sd_markdown,\n                                 mut data: *mut uint8_t, mut size: size_t) {\n    let mut beg: size_t = 0;\n    let mut end: size_t = 0;\n    let mut i: size_t = 0;\n    let mut txt_data: *mut uint8_t = 0 as *mut uint8_t;\n    beg = 0 as std::os::raw::c_int as size_t;\n    if (*rndr).work_bufs[1 as std::os::raw::c_int as\n                             usize].size.wrapping_add((*rndr).work_bufs[0 as\n                                                                            std::os::raw::c_int\n                                                                            as\n                                                                            usize].size)\n           > (*rndr).max_nesting {\n        return\n    }\n    while beg < size {\n        txt_data = data.offset(beg as isize);\n        end = size.wrapping_sub(beg);\n        if is_atxheader(rndr, txt_data, end) != 0 {\n            beg =\n                (beg as\n                     std::os::raw::c_ulong).wrapping_add(parse_atxheader(ob, rndr,\n                                                                 txt_data,\n                                                                 end)) as\n                    size_t as size_t\n        } else if *data.offset(beg as isize) as std::os::raw::c_int == '<' as i32 &&\n                      (*rndr).cb.blockhtml.is_some() &&\n                      {\n                          i =\n                              parse_htmlblock(ob, rndr, txt_data, end,\n                                              1 as std::os::raw::c_int);\n                          (i) != 0 as std::os::raw::c_int as std::os::raw::c_ulong\n                      } {\n            beg = (beg as std::os::raw::c_ulong).wrapping_add(i) as size_t as size_t\n        } else {\n            i = is_empty(txt_data, end);\n            if i != 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n                beg =\n                    (beg as std::os::raw::c_ulong).wrapping_add(i) as size_t as size_t\n            } else if is_hrule(txt_data, end) != 0 {\n                if (*rndr).cb.hrule.is_some() {\n                    (*rndr).cb.hrule.expect(\"non-null function pointer\")(ob,\n                                                                         (*rndr).opaque);\n                }\n                while beg < size &&\n                          *data.offset(beg as isize) as std::os::raw::c_int !=\n                              '\\n' as i32 {\n                    beg = beg.wrapping_add(1)\n                }\n                beg = beg.wrapping_add(1)\n            } else if (*rndr).ext_flags &\n                          MKDEXT_FENCED_CODE as std::os::raw::c_int as std::os::raw::c_uint !=\n                          0 as std::os::raw::c_int as std::os::raw::c_uint &&\n                          {\n                              i = parse_fencedcode(ob, rndr, txt_data, end);\n                              (i) != 0 as std::os::raw::c_int as std::os::raw::c_ulong\n                          } {\n                beg =\n                    (beg as std::os::raw::c_ulong).wrapping_add(i) as size_t as size_t\n            } else if (*rndr).ext_flags &\n                          MKDEXT_TABLES as std::os::raw::c_int as std::os::raw::c_uint !=\n                          0 as std::os::raw::c_int as std::os::raw::c_uint &&\n                          {\n                              i = parse_table(ob, rndr, txt_data, end);\n                              (i) != 0 as std::os::raw::c_int as std::os::raw::c_ulong\n                          } {\n                beg =\n                    (beg as std::os::raw::c_ulong).wrapping_add(i) as size_t as size_t\n            } else if prefix_quote(txt_data, end) != 0 {\n                beg =\n                    (beg as\n                         std::os::raw::c_ulong).wrapping_add(parse_blockquote(ob,\n                                                                      rndr,\n                                                                      txt_data,\n                                                                      end)) as\n                        size_t as size_t\n            } else if prefix_blockspoiler(txt_data, end) != 0 {\n                beg =\n                    (beg as\n                         std::os::raw::c_ulong).wrapping_add(parse_blockspoiler(ob,\n                                                                        rndr,\n                                                                        txt_data,\n                                                                        end))\n                        as size_t as size_t\n            } else if prefix_code(txt_data, end) != 0 {\n                beg =\n                    (beg as\n                         std::os::raw::c_ulong).wrapping_add(parse_blockcode(ob, rndr,\n                                                                     txt_data,\n                                                                     end)) as\n                        size_t as size_t\n            } else if prefix_uli(txt_data, end) != 0 {\n                beg =\n                    (beg as\n                         std::os::raw::c_ulong).wrapping_add(parse_list(ob, rndr,\n                                                                txt_data, end,\n                                                                0 as\n                                                                    std::os::raw::c_int))\n                        as size_t as size_t\n            } else if prefix_oli(txt_data, end) != 0 {\n                beg =\n                    (beg as\n                         std::os::raw::c_ulong).wrapping_add(parse_list(ob, rndr,\n                                                                txt_data, end,\n                                                                1 as\n                                                                    std::os::raw::c_int))\n                        as size_t as size_t\n            } else {\n                beg =\n                    (beg as\n                         std::os::raw::c_ulong).wrapping_add(parse_paragraph(ob, rndr,\n                                                                     txt_data,\n                                                                     end)) as\n                        size_t as size_t\n            }\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:285 ~ c2rust[26e7]::src::markdown::parse_blockquote)",
        "span": "src/markdown.rs:3813:5: 3813:50 (#0)",
        "source": "parse_block(out, rndr, work_data, work_size);"
      },
      {
        "caller": "DefId(0:290 ~ c2rust[26e7]::src::markdown::parse_listitem)",
        "span": "src/markdown.rs:4309:13: 4309:61 (#0)",
        "source": "parse_block(inter, rndr, (*work).data, sublist);"
      },
      {
        "caller": "DefId(0:303 ~ c2rust[26e7]::src::markdown::sd_markdown_render)",
        "span": "src/markdown.rs:5358:9: 5358:57 (#0)",
        "source": "parse_block(ob, md, (*text).data, (*text).size);"
      },
      {
        "caller": "DefId(0:286 ~ c2rust[26e7]::src::markdown::parse_blockspoiler)",
        "span": "src/markdown.rs:3878:5: 3878:50 (#0)",
        "source": "parse_block(out, rndr, work_data, work_size);"
      },
      {
        "caller": "DefId(0:290 ~ c2rust[26e7]::src::markdown::parse_listitem)",
        "span": "src/markdown.rs:4315:9: 4316:57 (#0)",
        "source": "parse_block(inter, rndr, (*work).data.offset(sublist as isize),\n                    (*work).size.wrapping_sub(sublist));"
      },
      {
        "caller": "DefId(0:290 ~ c2rust[26e7]::src::markdown::parse_listitem)",
        "span": "src/markdown.rs:4310:13: 4311:61 (#0)",
        "source": "parse_block(inter, rndr, (*work).data.offset(sublist as isize),\n                        (*work).size.wrapping_sub(sublist));"
      },
      {
        "caller": "DefId(0:290 ~ c2rust[26e7]::src::markdown::parse_listitem)",
        "span": "src/markdown.rs:4312:18: 4312:71 (#0)",
        "source": "parse_block(inter, rndr, (*work).data, (*work).size);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:259 ~ c2rust[26e7]::src::markdown::parse_blockspoiler)",
    "span": "src/markdown.rs:3822:1: 3885:2 (#0)",
    "pieces": [
      "src/markdown.rs:3822:1: 3885:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 64,
    "source": "unsafe extern \"C\" fn parse_blockspoiler(mut ob: *mut buf,\n                                        mut rndr: *mut sd_markdown,\n                                        mut data: *mut uint8_t,\n                                        mut size: size_t) -> size_t {\n    let mut beg: size_t = 0; /* skipping prefix */\n    let mut end: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut pre: size_t = 0;\n    let mut work_size: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut work_data: *mut uint8_t = 0 as *mut uint8_t;\n    let mut out: *mut buf = 0 as *mut buf;\n    out = rndr_newbuf(rndr, 0 as std::os::raw::c_int);\n    beg = 0 as std::os::raw::c_int as size_t;\n    while beg < size {\n        end = beg.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong);\n        while end < size &&\n                  *data.offset(end.wrapping_sub(1 as std::os::raw::c_int as\n                                                    std::os::raw::c_ulong) as isize)\n                      as std::os::raw::c_int != '\\n' as i32 {\n            end = end.wrapping_add(1)\n        }\n        pre =\n            prefix_blockspoiler(data.offset(beg as isize),\n                                end.wrapping_sub(beg));\n        if pre != 0 {\n            beg = (beg as std::os::raw::c_ulong).wrapping_add(pre) as size_t as size_t\n        } else if is_empty(data.offset(beg as isize), end.wrapping_sub(beg))\n                      != 0 &&\n                      (end >= size ||\n                           prefix_blockspoiler(data.offset(end as isize),\n                                               size.wrapping_sub(end)) ==\n                               0 as std::os::raw::c_int as std::os::raw::c_ulong &&\n                               is_empty(data.offset(end as isize),\n                                        size.wrapping_sub(end)) == 0)\n         /* empty line followed by non-blockspoiler line */\n         {\n            break ;\n        }\n        if beg < end {\n            /* copy into the in-place working buffer */\n            /* bufput(work, data + beg, end - beg); */\n            if work_data.is_null() {\n                work_data = data.offset(beg as isize)\n            } else if data.offset(beg as isize) !=\n                          work_data.offset(work_size as isize) {\n                memmove(work_data.offset(work_size as isize) as\n                            *mut std::os::raw::c_void,\n                        data.offset(beg as isize) as *const std::os::raw::c_void,\n                        end.wrapping_sub(beg));\n            }\n            work_size =\n                (work_size as\n                     std::os::raw::c_ulong).wrapping_add(end.wrapping_sub(beg)) as\n                    size_t as size_t\n        }\n        beg = end\n    }\n    parse_block(out, rndr, work_data, work_size);\n    if (*rndr).cb.blockspoiler.is_some() {\n        (*rndr).cb.blockspoiler.expect(\"non-null function pointer\")(ob, out,\n                                                                    (*rndr).opaque);\n    }\n    rndr_popbuf(rndr, 0 as std::os::raw::c_int);\n    return end;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:226 ~ c2rust[26e7]::src::markdown::parse_inline)",
    "span": "src/markdown.rs:2131:1: 2197:2 (#0)",
    "pieces": [
      "src/markdown.rs:2131:1: 2197:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 67,
    "source": "unsafe extern \"C\" fn parse_inline(mut ob: *mut buf,\n                                  mut rndr: *mut sd_markdown,\n                                  mut data: *mut uint8_t, mut size: size_t) {\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut end: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut last_special: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut action: uint8_t = 0 as std::os::raw::c_int as uint8_t;\n    let mut work: buf =\n        {\n            let mut init =\n                buf{data: 0 as *mut uint8_t,\n                    size: 0 as std::os::raw::c_int as size_t,\n                    asize: 0 as std::os::raw::c_int as size_t,\n                    unit: 0 as std::os::raw::c_int as size_t,};\n            init\n        };\n    if (*rndr).work_bufs[1 as std::os::raw::c_int as\n                             usize].size.wrapping_add((*rndr).work_bufs[0 as\n                                                                            std::os::raw::c_int\n                                                                            as\n                                                                            usize].size)\n           > (*rndr).max_nesting {\n        return\n    }\n    while i < size {\n        /* copying inactive chars into the output */\n        while end < size &&\n                  {\n                      action =\n                          (*rndr).active_char[*data.offset(end as isize) as\n                                                  usize];\n                      (action as std::os::raw::c_int) == 0 as std::os::raw::c_int\n                  } {\n            end = end.wrapping_add(1)\n        }\n        if (*rndr).cb.normal_text.is_some() {\n            work.data = data.offset(i as isize);\n            work.size = end.wrapping_sub(i);\n            (*rndr).cb.normal_text.expect(\"non-null function pointer\")(ob,\n                                                                       &mut work,\n                                                                       (*rndr).opaque);\n        } else {\n            bufput(ob, data.offset(i as isize) as *const std::os::raw::c_void,\n                   end.wrapping_sub(i));\n        }\n        if end >= size { break ; }\n        i = end;\n        end =\n            markdown_char_ptrs[action as std::os::raw::c_int as\n                                   usize].expect(\"non-null function pointer\")(ob,\n                                                                              rndr,\n                                                                              data.offset(i\n                                                                                              as\n                                                                                              isize),\n                                                                              i.wrapping_sub(last_special),\n                                                                              i,\n                                                                              size.wrapping_sub(i));\n        if end == 0 {\n            /* no action from the callback */\n            end = i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n        } else {\n            i = (i as std::os::raw::c_ulong).wrapping_add(end) as size_t as size_t;\n            end = i;\n            last_special = end\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:290 ~ c2rust[26e7]::src::markdown::parse_listitem)",
        "span": "src/markdown.rs:4314:9: 4314:58 (#0)",
        "source": "parse_inline(inter, rndr, (*work).data, sublist);"
      },
      {
        "caller": "DefId(0:292 ~ c2rust[26e7]::src::markdown::parse_atxheader)",
        "span": "src/markdown.rs:4386:9: 4387:43 (#0)",
        "source": "parse_inline(work, rndr, data.offset(i as isize),\n                     end.wrapping_sub(i));"
      },
      {
        "caller": "DefId(0:287 ~ c2rust[26e7]::src::markdown::parse_paragraph)",
        "span": "src/markdown.rs:4013:13: 4013:61 (#0)",
        "source": "parse_inline(tmp_0, rndr, work.data, work.size);"
      },
      {
        "caller": "DefId(0:290 ~ c2rust[26e7]::src::markdown::parse_listitem)",
        "span": "src/markdown.rs:4317:14: 4317:68 (#0)",
        "source": "parse_inline(inter, rndr, (*work).data, (*work).size);"
      },
      {
        "caller": "DefId(0:271 ~ c2rust[26e7]::src::markdown::char_link)",
        "span": "src/markdown.rs:3312:17: 3312:99 (#0)",
        "source": "parse_inline(content, rndr_ref, unsafe { data.offset(1) }, txt_e.wrapping_sub(1));"
      },
      {
        "caller": "DefId(0:287 ~ c2rust[26e7]::src::markdown::parse_paragraph)",
        "span": "src/markdown.rs:4026:5: 4026:59 (#0)",
        "source": "parse_inline(header_work, rndr, work.data, work.size);"
      },
      {
        "caller": "DefId(0:287 ~ c2rust[26e7]::src::markdown::parse_paragraph)",
        "span": "src/markdown.rs:3989:5: 3989:51 (#0)",
        "source": "parse_inline(tmp, rndr, work.data, work.size);"
      },
      {
        "caller": "DefId(0:272 ~ c2rust[26e7]::src::markdown::char_superscript)",
        "span": "src/markdown.rs:3387:5: 3388:51 (#0)",
        "source": "parse_inline(sup, rndr, data.offset(sup_start as isize),\n                 sup_len.wrapping_sub(sup_start));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:229 ~ c2rust[26e7]::src::markdown::parse_emph2)",
    "span": "src/markdown.rs:2361:1: 2403:2 (#0)",
    "pieces": [
      "src/markdown.rs:2361:1: 2403:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 43,
    "source": "unsafe extern \"C\" fn parse_emph2(mut ob: *mut buf, mut rndr: *mut sd_markdown,\n                                 mut data: *mut uint8_t, mut size: size_t,\n                                 mut c: uint8_t) -> size_t {\n    let mut render_method:\n            Option<unsafe extern \"C\" fn(_: *mut buf, _: *const buf,\n                                        _: *mut std::os::raw::c_void)\n                       -> std::os::raw::c_int> = None;\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut len: size_t = 0;\n    let mut work: *mut buf = 0 as *mut buf;\n    let mut r: std::os::raw::c_int = 0;\n    render_method =\n        if c as std::os::raw::c_int == '~' as i32 {\n            (*rndr).cb.strikethrough\n        } else { (*rndr).cb.double_emphasis };\n    if render_method.is_none() { return 0 as std::os::raw::c_int as size_t }\n    while i < size {\n        len =\n            find_emph_char(data.offset(i as isize), size.wrapping_sub(i), c);\n        if len == 0 { return 0 as std::os::raw::c_int as size_t }\n        i = (i as std::os::raw::c_ulong).wrapping_add(len) as size_t as size_t;\n        if i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) < size &&\n               *data.offset(i as isize) as std::os::raw::c_int == c as std::os::raw::c_int &&\n               *data.offset(i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n                                as isize) as std::os::raw::c_int == c as std::os::raw::c_int\n               && i != 0 &&\n               _isspace(*data.offset(i.wrapping_sub(1 as std::os::raw::c_int as\n                                                        std::os::raw::c_ulong) as\n                                         isize) as std::os::raw::c_int) == 0 {\n            work = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n            parse_inline(work, rndr, data, i);\n            r =\n                render_method.expect(\"non-null function pointer\")(ob, work,\n                                                                  (*rndr).opaque);\n            rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n            return if r != 0 {\n                       i.wrapping_add(2 as std::os::raw::c_int as std::os::raw::c_ulong)\n                   } else { 0 as std::os::raw::c_int as std::os::raw::c_ulong }\n        }\n        i = i.wrapping_add(1)\n    }\n    return 0 as std::os::raw::c_int as size_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:257 ~ c2rust[26e7]::src::markdown::prefix_uli)",
    "span": "src/markdown.rs:3732:1: 3757:2 (#0)",
    "pieces": [
      "src/markdown.rs:3732:1: 3757:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 26,
    "source": "unsafe extern \"C\" fn prefix_uli(mut data: *mut uint8_t, mut size: size_t)\n -> size_t {\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    if i < size && *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i < size && *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i < size && *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) >= size ||\n           *data.offset(i as isize) as std::os::raw::c_int != '*' as i32 &&\n               *data.offset(i as isize) as std::os::raw::c_int != '+' as i32 &&\n               *data.offset(i as isize) as std::os::raw::c_int != '-' as i32 ||\n           *data.offset(i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) as\n                            isize) as std::os::raw::c_int != ' ' as i32 {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    if is_next_headerline(data.offset(i as isize), size.wrapping_sub(i)) != 0\n       {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    return i.wrapping_add(2 as std::os::raw::c_int as std::os::raw::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:290 ~ c2rust[26e7]::src::markdown::parse_listitem)",
        "span": "src/markdown.rs:4204:5: 4204:34 (#0)",
        "source": "beg = prefix_uli(data, size);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:218 ~ c2rust[26e7]::src::markdown::unscape_text)",
    "span": "src/markdown.rs:1901:1: 1929:2 (#0)",
    "pieces": [
      "src/markdown.rs:1901:1: 1929:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 29,
    "source": "unsafe extern \"C\" fn unscape_text(mut ob: *mut buf, mut src: *mut buf) {\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut org: size_t = 0;\n    while i < (*src).size {\n        org = i;\n        while i < (*src).size &&\n                  *(*src).data.offset(i as isize) as std::os::raw::c_int !=\n                      '\\\\' as i32 {\n            i = i.wrapping_add(1)\n        }\n        if i > org {\n            bufput(ob,\n                   (*src).data.offset(org as isize) as *const std::os::raw::c_void,\n                   i.wrapping_sub(org));\n        }\n        if i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) >= (*src).size {\n            break ;\n        }\n        bufputc(ob,\n                *(*src).data.offset(i.wrapping_add(1 as std::os::raw::c_int as\n                                                       std::os::raw::c_ulong) as\n                                        isize) as std::os::raw::c_int);\n        i =\n            (i as\n                 std::os::raw::c_ulong).wrapping_add(2 as std::os::raw::c_int as\n                                                 std::os::raw::c_ulong) as size_t as\n                size_t\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:265 ~ c2rust[26e7]::src::markdown::char_langle_tag)",
        "span": "src/markdown.rs:2856:13: 2856:45 (#0)",
        "source": "unscape_text(u_link, &mut work);"
      },
      {
        "caller": "DefId(0:271 ~ c2rust[26e7]::src::markdown::char_link)",
        "span": "src/markdown.rs:3318:13: 3318:40 (#0)",
        "source": "unscape_text(u_link, link);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:224 ~ c2rust[26e7]::src::markdown::is_mail_autolink)",
    "span": "src/markdown.rs:2012:1: 2039:2 (#0)",
    "pieces": [
      "src/markdown.rs:2012:1: 2039:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 28,
    "source": "unsafe extern \"C\" fn is_mail_autolink(mut data: *mut uint8_t,\n                                      mut size: size_t) -> size_t {\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut nb: size_t = 0 as std::os::raw::c_int as size_t;\n    /* address is assumed to be: [-@._a-zA-Z0-9]+ with exactly one '@' */\n    i = 0 as std::os::raw::c_int as size_t;\n    while i < size {\n        if !(*(*__ctype_b_loc()).offset(*data.offset(i as isize) as\n                                            std::os::raw::c_int as isize) as\n                 std::os::raw::c_int &\n                 _ISalnum as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int !=\n                 0) {\n            match *data.offset(i as isize) as std::os::raw::c_int {\n                64 => { nb = nb.wrapping_add(1) }\n                45 | 46 | 95 => { }\n                62 => {\n                    return if nb == 1 as std::os::raw::c_int as std::os::raw::c_ulong {\n                               i.wrapping_add(1 as std::os::raw::c_int as\n                                                  std::os::raw::c_ulong)\n                           } else { 0 as std::os::raw::c_int as std::os::raw::c_ulong }\n                }\n                _ => { return 0 as std::os::raw::c_int as size_t }\n            }\n        }\n        i = i.wrapping_add(1)\n    }\n    return 0 as std::os::raw::c_int as size_t;\n}",
    "calls": [
      {
        "caller": "DefId(0:252 ~ c2rust[26e7]::src::markdown::tag_length)",
        "span": "src/markdown.rs:2078:9: 2078:77 (#0)",
        "source": "j = is_mail_autolink(data.offset(i as isize), size.wrapping_sub(i));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:225 ~ c2rust[26e7]::src::markdown::tag_length)",
    "span": "src/markdown.rs:2041:1: 2129:2 (#0)",
    "pieces": [
      "src/markdown.rs:2041:1: 2129:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 89,
    "source": "unsafe extern \"C\" fn tag_length(mut data: *mut uint8_t, mut size: size_t,\n                                mut autolink: *mut mkd_autolink) -> size_t {\n    let mut i: size_t = 0;\n    let mut j: size_t = 0;\n    /* a valid tag can't be shorter than 3 chars */\n    if size < 3 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    /* begins with a '<' optionally followed by '/', followed by letter or number */\n    if *data.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int != '<' as i32 {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    i =\n        if *data.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n               '/' as i32 {\n            2 as std::os::raw::c_int\n        } else { 1 as std::os::raw::c_int } as size_t;\n    if *(*__ctype_b_loc()).offset(*data.offset(i as isize) as std::os::raw::c_int as\n                                      isize) as std::os::raw::c_int &\n           _ISalnum as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int == 0 {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    /* scheme test */\n    *autolink = MKDA_NOT_AUTOLINK;\n    /* try to find the beginning of an URI */\n    while i < size &&\n              (*(*__ctype_b_loc()).offset(*data.offset(i as isize) as\n                                              std::os::raw::c_int as isize) as\n                   std::os::raw::c_int &\n                   _ISalnum as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int !=\n                   0 || *data.offset(i as isize) as std::os::raw::c_int == '.' as i32\n                   || *data.offset(i as isize) as std::os::raw::c_int == '+' as i32 ||\n                   *data.offset(i as isize) as std::os::raw::c_int == '-' as i32) {\n        i = i.wrapping_add(1)\n    }\n    if i > 1 as std::os::raw::c_int as std::os::raw::c_ulong &&\n           *data.offset(i as isize) as std::os::raw::c_int == '@' as i32 {\n        j = is_mail_autolink(data.offset(i as isize), size.wrapping_sub(i));\n        if j != 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n            *autolink = MKDA_EMAIL;\n            return i.wrapping_add(j)\n        }\n    }\n    if i > 2 as std::os::raw::c_int as std::os::raw::c_ulong &&\n           *data.offset(i as isize) as std::os::raw::c_int == ':' as i32 {\n        *autolink = MKDA_NORMAL;\n        i = i.wrapping_add(1)\n    }\n    /* completing autolink test: no whitespace or ' or \" */\n    if i >= size {\n        *autolink = MKDA_NOT_AUTOLINK\n    } else if *autolink as u64 != 0 {\n        j = i;\n        while i < size {\n            if *data.offset(i as isize) as std::os::raw::c_int == '\\\\' as i32 {\n                i =\n                    (i as\n                         std::os::raw::c_ulong).wrapping_add(2 as std::os::raw::c_int as\n                                                         std::os::raw::c_ulong) as\n                        size_t as size_t\n            } else {\n                if *data.offset(i as isize) as std::os::raw::c_int == '>' as i32 ||\n                       *data.offset(i as isize) as std::os::raw::c_int == '\\'' as i32\n                       ||\n                       *data.offset(i as isize) as std::os::raw::c_int == '\\\"' as i32\n                       ||\n                       *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32\n                       ||\n                       *data.offset(i as isize) as std::os::raw::c_int == '\\n' as i32\n                   {\n                    break ;\n                }\n                i = i.wrapping_add(1)\n            }\n        }\n        if i >= size { return 0 as std::os::raw::c_int as size_t }\n        if i > j && *data.offset(i as isize) as std::os::raw::c_int == '>' as i32 {\n            return i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n        }\n        /* one of the forbidden chars has been found */\n        *autolink = MKDA_NOT_AUTOLINK\n    }\n    /* looking for sometinhg looking like a tag end */\n    while i < size && *data.offset(i as isize) as std::os::raw::c_int != '>' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i >= size { return 0 as std::os::raw::c_int as size_t }\n    return i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:265 ~ c2rust[26e7]::src::markdown::char_langle_tag)",
        "span": "src/markdown.rs:2838:5: 2838:63 (#0)",
        "source": "let mut end: size_t = tag_length(data, size, &mut altype);"
      }
    ],
    "globals": [
      {
        "span": "src/markdown.rs:165:1: 165:41 (#0)",
        "source": "pub const MKDA_NORMAL: mkd_autolink = 1;"
      },
      {
        "span": "src/markdown.rs:164:1: 164:40 (#0)",
        "source": "pub const MKDA_EMAIL: mkd_autolink = 2;"
      },
      {
        "span": "src/markdown.rs:166:1: 166:47 (#0)",
        "source": "pub const MKDA_NOT_AUTOLINK: mkd_autolink = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:238 ~ c2rust[26e7]::src::markdown::char_langle_tag)",
    "span": "src/markdown.rs:2831:1: 2871:2 (#0)",
    "pieces": [
      "src/markdown.rs:2831:1: 2871:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "unsafe extern \"C\" fn char_langle_tag(mut ob: *mut buf,\n                                     mut rndr: *mut sd_markdown,\n                                     mut data: *mut uint8_t,\n                                     mut max_rewind: size_t,\n                                     mut max_lookbehind: size_t,\n                                     mut size: size_t) -> size_t {\n    let mut altype: mkd_autolink = MKDA_NOT_AUTOLINK;\n    let mut end: size_t = tag_length(data, size, &mut altype);\n    let mut work: buf =\n        {\n            let mut init =\n                buf{data: data,\n                    size: end,\n                    asize: 0 as std::os::raw::c_int as size_t,\n                    unit: 0 as std::os::raw::c_int as size_t,};\n            init\n        };\n    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    if end > 2 as std::os::raw::c_int as std::os::raw::c_ulong {\n        if (*rndr).cb.autolink.is_some() &&\n               altype as std::os::raw::c_uint !=\n                   MKDA_NOT_AUTOLINK as std::os::raw::c_int as std::os::raw::c_uint {\n            let mut u_link: *mut buf = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n            work.data = data.offset(1 as std::os::raw::c_int as isize);\n            work.size = end.wrapping_sub(2 as std::os::raw::c_int as std::os::raw::c_ulong);\n            unscape_text(u_link, &mut work);\n            ret =\n                (*rndr).cb.autolink.expect(\"non-null function pointer\")(ob,\n                                                                        u_link,\n                                                                        altype,\n                                                                        (*rndr).opaque);\n            rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n        } else if (*rndr).cb.raw_html_tag.is_some() {\n            ret =\n                (*rndr).cb.raw_html_tag.expect(\"non-null function pointer\")(ob,\n                                                                            &mut work,\n                                                                            (*rndr).opaque)\n        }\n    }\n    if ret == 0 { return 0 as std::os::raw::c_int as size_t } else { return end };\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/markdown.rs:166:1: 166:47 (#0)",
        "source": "pub const MKDA_NOT_AUTOLINK: mkd_autolink = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:289 ~ c2rust[26e7]::src::stack::stack_grow)",
    "span": "src/stack.rs:20:1: 39:2 (#0)",
    "pieces": [
      "src/stack.rs:20:1: 39:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "pub unsafe extern \"C\" fn stack_grow(mut st: *mut stack, mut new_size: size_t)\n -> std::os::raw::c_int {\n    let mut new_st: *mut *mut std::os::raw::c_void = 0 as *mut *mut std::os::raw::c_void;\n    if (*st).asize >= new_size { return 0 as std::os::raw::c_int }\n    new_st =\n        realloc((*st).item as *mut std::os::raw::c_void,\n                new_size.wrapping_mul(::std::mem::size_of::<*mut std::os::raw::c_void>()\n                                          as std::os::raw::c_ulong)) as\n            *mut *mut std::os::raw::c_void;\n    if new_st.is_null() { return -(1 as std::os::raw::c_int) }\n    memset(new_st.offset((*st).asize as isize) as *mut std::os::raw::c_void,\n           0 as std::os::raw::c_int,\n           new_size.wrapping_sub((*st).asize).wrapping_mul(::std::mem::size_of::<*mut std::os::raw::c_void>()\n                                                               as\n                                                               std::os::raw::c_ulong));\n    (*st).item = new_st;\n    (*st).asize = new_size;\n    if (*st).size > new_size { (*st).size = new_size }\n    return 0 as std::os::raw::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:321 ~ c2rust[26e7]::src::stack::stack_init)",
        "span": "src/stack.rs:72:9: 72:52 (#0)",
        "source": "return stack_grow(st, initial_size as u64);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/stack.rs:4:1: 4:26 (#0)",
        "source": "use std::os::raw::c_void;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:291 ~ c2rust[26e7]::src::stack::stack_init)",
    "span": "src/stack.rs:65:1: 74:2 (#0)",
    "pieces": [
      "src/stack.rs:65:1: 74:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn stack_init(mut st: *mut stack,\n                                    mut initial_size: size_t) -> std::os::raw::c_int {\n    (*st).item = 0 as *mut *mut std::os::raw::c_void;\n    (*st).size = 0 as std::os::raw::c_int as size_t;\n    (*st).asize = 0 as std::os::raw::c_int as size_t;\n    if initial_size == 0 { initial_size = 8 as std::os::raw::c_int as size_t }\n    return stack_grow(st, initial_size);\n}",
    "calls": [
      {
        "caller": "DefId(0:302 ~ c2rust[26e7]::src::markdown::sd_markdown_new)",
        "span": "src/markdown.rs:5200:1: 5200:25 (#0)",
        "source": "stack_init(work_buf, 8);"
      },
      {
        "caller": "DefId(0:302 ~ c2rust[26e7]::src::markdown::sd_markdown_new)",
        "span": "src/markdown.rs:5198:1: 5198:25 (#0)",
        "source": "stack_init(work_buf, 4);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/stack.rs:4:1: 4:26 (#0)",
        "source": "use std::os::raw::c_void;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:70 ~ c2rust[26e7]::src::buffer::buftruncate)",
    "span": "src/buffer.rs:200:1: 207:2 (#0)",
    "pieces": [
      "src/buffer.rs:200:1: 207:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn buftruncate(mut buf: *mut buf, mut size: size_t)\n -> std::os::raw::c_int {\n    if (*buf).size < size || size < 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        /* bail out in debug mode so we can figure out why this happened */\n        return BUF_EINVALIDIDX as std::os::raw::c_int\n    }\n    (*buf).size = size;\n    return BUF_OK as std::os::raw::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:266 ~ c2rust[26e7]::src::markdown::char_autolink_www)",
        "span": "src/markdown.rs:2900:1: 2900:40 (#0)",
        "source": "buftruncate(&mut *ob, new_size as u64);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust[26e7]::src::markdown::char_autolink_subreddit_or_username)",
        "span": "src/markdown.rs:2959:1: 2959:40 (#0)",
        "source": "buftruncate(&mut *ob, new_size as u64);"
      },
      {
        "caller": "DefId(0:269 ~ c2rust[26e7]::src::markdown::char_autolink_email)",
        "span": "src/markdown.rs:3001:1: 3001:40 (#0)",
        "source": "buftruncate(&mut *ob, new_size as u64);"
      },
      {
        "caller": "DefId(0:270 ~ c2rust[26e7]::src::markdown::char_autolink_url)",
        "span": "src/markdown.rs:3027:1: 3027:40 (#0)",
        "source": "buftruncate(&mut *ob, new_size as u64);"
      }
    ],
    "globals": [
      {
        "span": "src/buffer.rs:36:1: 36:37 (#0)",
        "source": "pub const BUF_OK: C2RustUnnamed = 0;"
      },
      {
        "span": "src/buffer.rs:34:1: 34:47 (#0)",
        "source": "pub const BUF_EINVALIDIDX: C2RustUnnamed = -2;"
      }
    ],
    "imports": [
      {
        "span": "src/buffer.rs:6:1: 6:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/buffer.rs:12:1: 12:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/buffer.rs:8:1: 8:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/buffer.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/buffer.rs:11:1: 11:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:205 ~ c2rust[26e7]::src::markdown::is_valid_numeric_entity)",
    "span": "src/markdown.rs:700:1: 711:2 (#0)",
    "pieces": [
      "src/markdown.rs:700:1: 711:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 24,
    "source": "unsafe extern \"C\" fn is_valid_numeric_entity(mut entity_val: uint32_t)\n -> std::os::raw::c_int {\n    /* Some XML parsers will choke on entities with certain\n\t * values (mostly control characters.)\n\t *\n\t * According to lxml these are all problematic:\n\t *\n\t *\t[xrange(0, 8),\n\t *\t xrange(11, 12),\n\t *\t xrange(14, 31),\n\t *\t xrange(55296, 57343),\n\t *\t xrange(65534, 65535)]\n\t */\n    return (entity_val > 8 as std::os::raw::c_int as std::os::raw::c_uint &&\n                (entity_val != 11 as std::os::raw::c_int as std::os::raw::c_uint &&\n                     entity_val != 12 as std::os::raw::c_int as std::os::raw::c_uint) &&\n                (entity_val < 14 as std::os::raw::c_int as std::os::raw::c_uint ||\n                     entity_val > 31 as std::os::raw::c_int as std::os::raw::c_uint) &&\n                (entity_val < 55296 as std::os::raw::c_int as std::os::raw::c_uint ||\n                     entity_val > 57343 as std::os::raw::c_int as std::os::raw::c_uint) &&\n                (entity_val != 65534 as std::os::raw::c_int as std::os::raw::c_uint &&\n                     entity_val != 65535 as std::os::raw::c_int as std::os::raw::c_uint) &&\n                entity_val <= MAX_NUM_ENTITY_VAL) as std::os::raw::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:64 ~ c2rust[26e7]::src::buffer::bufput)",
    "span": "src/buffer.rs:127:1: 138:2 (#0)",
    "pieces": [
      "src/buffer.rs:127:1: 138:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn bufput(mut buf: *mut buf,\n                                mut data: *const std::os::raw::c_void,\n                                mut len: size_t) {\n    if (*buf).size.wrapping_add(len) > (*buf).asize &&\n           bufgrow(buf, (*buf).size.wrapping_add(len)) < 0 as std::os::raw::c_int {\n        return\n    }\n    memcpy((*buf).data.offset((*buf).size as isize) as *mut std::os::raw::c_void,\n           data, len);\n    (*buf).size =\n        ((*buf).size as std::os::raw::c_ulong).wrapping_add(len) as size_t as size_t;\n}",
    "calls": [
      {
        "caller": "DefId(0:266 ~ c2rust[26e7]::src::markdown::char_autolink_www)",
        "span": "src/markdown.rs:2892:9: 2897:77 (#0)",
        "source": "bufput(link_url,\n               b\"http://\\x00\" as *const u8 as *const std::os::raw::c_char as\n                   *const std::os::raw::c_void,\n               (::std::mem::size_of::<[std::os::raw::c_char; 8]>() as\n                    std::os::raw::c_ulong).wrapping_sub(1 as std::os::raw::c_int as\n                                                    std::os::raw::c_ulong));"
      },
      {
        "caller": "DefId(0:80 ~ c2rust[26e7]::src::buffer::bufputs)",
        "span": "src/buffer.rs:143:9: 143:84 (#0)",
        "source": "bufput(buf, str.as_ptr() as *const std::os::raw::c_void, str.len() as u64);"
      },
      {
        "caller": "DefId(0:41 ~ c2rust[26e7]::src::autolink::sd_autolink__url)",
        "span": "src/autolink.rs:483:5: 484:43 (#0)",
        "source": "bufput(link, data.offset(-(rewind as isize)) as *const std::os::raw::c_void,\n           link_end.wrapping_add(rewind));"
      },
      {
        "caller": "DefId(0:271 ~ c2rust[26e7]::src::markdown::char_link)",
        "span": "src/markdown.rs:3307:17: 3307:116 (#0)",
        "source": "bufput(content, unsafe { data.offset(1) as *const std::os::raw::c_void }, len.try_into().unwrap());"
      },
      {
        "caller": "DefId(0:42 ~ c2rust[26e7]::src::autolink::sd_autolink__subreddit)",
        "span": "src/autolink.rs:626:5: 627:43 (#0)",
        "source": "bufput(link, data.offset(-(rewind as isize)) as *const std::os::raw::c_void,\n           link_end.wrapping_add(rewind));"
      },
      {
        "caller": "DefId(0:39 ~ c2rust[26e7]::src::autolink::sd_autolink__www)",
        "span": "src/autolink.rs:352:5: 352:65 (#0)",
        "source": "bufput(link, data as *const std::os::raw::c_void, link_end);"
      },
      {
        "caller": "DefId(0:300 ~ c2rust[26e7]::src::markdown::is_ref)",
        "span": "src/markdown.rs:5142:9: 5142:137 (#0)",
        "source": "bufput((*ref_0).title, data.offset(title_offset as isize) as *const std::os::raw::c_void, title_end.wrapping_sub(title_offset));"
      },
      {
        "caller": "DefId(0:266 ~ c2rust[26e7]::src::markdown::char_autolink_www)",
        "span": "src/markdown.rs:2898:9: 2898:85 (#0)",
        "source": "bufput(link_url, (*link).data as *const std::os::raw::c_void, (*link).size);"
      },
      {
        "caller": "DefId(0:264 ~ c2rust[26e7]::src::markdown::char_entity)",
        "span": "src/markdown.rs:2825:9: 2826:49 (#0)",
        "source": "bufput(ob, data.offset(content_start as isize) as *const std::os::raw::c_void,\n               end.wrapping_sub(content_start));"
      },
      {
        "caller": "DefId(0:290 ~ c2rust[26e7]::src::markdown::parse_listitem)",
        "span": "src/markdown.rs:4218:5: 4219:35 (#0)",
        "source": "bufput(work, data.offset(beg as isize) as *const std::os::raw::c_void,\n           end.wrapping_sub(beg));"
      },
      {
        "caller": "DefId(0:300 ~ c2rust[26e7]::src::markdown::is_ref)",
        "span": "src/markdown.rs:5138:5: 5138:129 (#0)",
        "source": "bufput((*ref_0).link, data.offset(link_offset as isize) as *const std::os::raw::c_void, link_end.wrapping_sub(link_offset));"
      },
      {
        "caller": "DefId(0:268 ~ c2rust[26e7]::src::markdown::char_autolink_subreddit_or_username)",
        "span": "src/markdown.rs:2957:9: 2957:85 (#0)",
        "source": "bufput(link_url, (*link).data as *const std::os::raw::c_void, (*link).size);"
      },
      {
        "caller": "DefId(0:43 ~ c2rust[26e7]::src::autolink::sd_autolink__username)",
        "span": "src/autolink.rs:679:5: 680:43 (#0)",
        "source": "bufput(link, data.offset(-(rewind as isize)) as *const std::os::raw::c_void,\n           link_end.wrapping_add(rewind));"
      },
      {
        "caller": "DefId(0:271 ~ c2rust[26e7]::src::markdown::char_link)",
        "span": "src/markdown.rs:3186:17: 3186:141 (#0)",
        "source": "bufput(title, unsafe { data.add(title_b as usize) } as *const std::os::raw::c_void, (title_e.wrapping_sub(title_b)) as u64);"
      },
      {
        "caller": "DefId(0:40 ~ c2rust[26e7]::src::autolink::sd_autolink__email)",
        "span": "src/autolink.rs:419:5: 420:43 (#0)",
        "source": "bufput(link, data.offset(-(rewind as isize)) as *const std::os::raw::c_void,\n           link_end.wrapping_add(rewind));"
      },
      {
        "caller": "DefId(0:271 ~ c2rust[26e7]::src::markdown::char_link)",
        "span": "src/markdown.rs:3182:17: 3182:137 (#0)",
        "source": "bufput(link, unsafe { data.add(link_b as usize) } as *const std::os::raw::c_void, (link_e.wrapping_sub(link_b)) as u64);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/buffer.rs:8:1: 8:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/buffer.rs:11:1: 11:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/buffer.rs:6:1: 6:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/buffer.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/buffer.rs:12:1: 12:16 (#0)",
        "source": "use std::alloc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:37 ~ c2rust[26e7]::src::autolink::check_reddit_autolink_prefix)",
    "span": "src/autolink.rs:218:1: 272:2 (#0)",
    "pieces": [
      "src/autolink.rs:218:1: 272:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 55,
    "source": "unsafe extern \"C\" fn check_reddit_autolink_prefix(mut data: *const uint8_t,\n                                                  mut max_rewind: size_t,\n                                                  mut max_lookbehind: size_t,\n                                                  mut size: size_t,\n                                                  mut prefix_char:\n                                                      std::os::raw::c_char)\n -> std::os::raw::c_int {\n    /* Make sure this `/` is part of `/?r/` */\n    if size < 2 as std::os::raw::c_int as std::os::raw::c_ulong ||\n           max_rewind < 1 as std::os::raw::c_int as std::os::raw::c_ulong ||\n           *data.offset(-(1 as std::os::raw::c_int) as isize) as std::os::raw::c_int !=\n               prefix_char as std::os::raw::c_int {\n        return 0 as std::os::raw::c_int\n    }\n    /* Not at the start of the buffer, no inlines to the immediate left of the `prefix_char` */\n    if max_rewind > 1 as std::os::raw::c_int as std::os::raw::c_ulong {\n        let boundary: std::os::raw::c_char =\n            *data.offset(-(2 as std::os::raw::c_int) as isize) as std::os::raw::c_char;\n        if boundary as std::os::raw::c_int == '/' as i32 {\n            return 2 as std::os::raw::c_int\n        } else if *(*__ctype_b_loc()).offset(boundary as std::os::raw::c_int as isize)\n                      as std::os::raw::c_int &\n                      _ISpunct as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int\n                      != 0 ||\n                      *(*__ctype_b_loc()).offset(boundary as std::os::raw::c_int as\n                                                     isize) as std::os::raw::c_int &\n                          _ISspace as std::os::raw::c_int as std::os::raw::c_ushort as\n                              std::os::raw::c_int != 0 {\n            return 1 as std::os::raw::c_int\n        } else { return 0 as std::os::raw::c_int }\n    } else {\n        if max_lookbehind > 2 as std::os::raw::c_int as std::os::raw::c_ulong {\n            /* *\n\t\t * Here's where our lack of unicode-awareness bites us. We don't correctly\n\t\t * match punctuation / whitespace characters for the boundary, because we\n\t\t * reject valid cases like \"。r/example\" (note the fullwidth period.)\n\t\t *\n\t\t * A better implementation might try to rewind over bytes with the 8th bit set, try\n\t\t * to decode them to a valid codepoint, then do a unicode-aware check on the codepoint.\n\t\t */\n            /* There's an inline element just left of the `prefix_char`, is it an escaped forward\n\t\t * slash? bail out so we correctly handle stuff like \"\\/r/foo\". This will also correctly\n\t\t * allow \"\\\\/r/foo\".\n\t\t */\n            if *data.offset(-(2 as std::os::raw::c_int) as isize) as std::os::raw::c_int ==\n                   '/' as i32 &&\n                   *data.offset(-(3 as std::os::raw::c_int) as isize) as std::os::raw::c_int\n                       == '\\\\' as i32 {\n                return 0 as std::os::raw::c_int\n            }\n        }\n    }\n    /* Must be a new-style shortlink with nothing relevant to the left of it. */\n    return 1 as std::os::raw::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:42 ~ c2rust[26e7]::src::autolink::sd_autolink__subreddit)",
        "span": "src/autolink.rs:509:5: 511:84 (#0)",
        "source": "rewind =\n        check_reddit_autolink_prefix(data, max_rewind, max_lookbehind, size,\n                                     'r' as i32 as std::os::raw::c_char) as size_t;"
      },
      {
        "caller": "DefId(0:43 ~ c2rust[26e7]::src::autolink::sd_autolink__username)",
        "span": "src/autolink.rs:646:5: 648:84 (#0)",
        "source": "rewind =\n        check_reddit_autolink_prefix(data, max_rewind, max_lookbehind, size,\n                                     'u' as i32 as std::os::raw::c_char) as size_t;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/autolink.rs:19:1: 19:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:43 ~ c2rust[26e7]::src::autolink::sd_autolink__username)",
    "span": "src/autolink.rs:633:1: 684:2 (#0)",
    "pieces": [
      "src/autolink.rs:633:1: 684:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 52,
    "source": "pub unsafe extern \"C\" fn sd_autolink__username(mut rewind_p: *mut size_t,\n                                               mut link: *mut buf,\n                                               mut data: *mut uint8_t,\n                                               mut max_rewind: size_t,\n                                               mut max_lookbehind: size_t,\n                                               mut size: size_t,\n                                               mut no_slash: *mut std::os::raw::c_int)\n -> size_t {\n    let mut link_end: size_t = 0;\n    let mut rewind: size_t = 0;\n    if size < 3 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    rewind =\n        check_reddit_autolink_prefix(data, max_rewind, max_lookbehind, size,\n                                     'u' as i32 as std::os::raw::c_char) as size_t;\n    if rewind == 0 { return 0 as std::os::raw::c_int as size_t }\n    link_end = strlen(b\"/\\x00\" as *const u8 as *const std::os::raw::c_char);\n    /* the first letter of a username must... well, be valid, we don't care otherwise */\n    if *(*__ctype_b_loc()).offset(*data.offset(link_end as isize) as\n                                      std::os::raw::c_int as isize) as std::os::raw::c_int &\n           _ISalnum as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int == 0 &&\n           *data.offset(link_end as isize) as std::os::raw::c_int != '_' as i32 &&\n           *data.offset(link_end as isize) as std::os::raw::c_int != '-' as i32 {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    link_end =\n        (link_end as\n             std::os::raw::c_ulong).wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) as\n            size_t as size_t;\n    /* consume valid characters ([A-Za-z0-9_-/]) until we run out */\n    while link_end < size &&\n              (*(*__ctype_b_loc()).offset(*data.offset(link_end as isize) as\n                                              std::os::raw::c_int as isize) as\n                   std::os::raw::c_int &\n                   _ISalnum as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int !=\n                   0 ||\n                   *data.offset(link_end as isize) as std::os::raw::c_int ==\n                       '_' as i32 ||\n                   *data.offset(link_end as isize) as std::os::raw::c_int ==\n                       '/' as i32 ||\n                   *data.offset(link_end as isize) as std::os::raw::c_int ==\n                       '-' as i32) {\n        link_end = link_end.wrapping_add(1)\n    }\n    /* make the link */\n    bufput(link, data.offset(-(rewind as isize)) as *const std::os::raw::c_void,\n           link_end.wrapping_add(rewind));\n    *no_slash = (rewind == 1 as std::os::raw::c_int as std::os::raw::c_ulong) as std::os::raw::c_int;\n    *rewind_p = rewind;\n    return link_end;\n}",
    "calls": [
      {
        "caller": "DefId(0:268 ~ c2rust[26e7]::src::markdown::char_autolink_subreddit_or_username)",
        "span": "src/markdown.rs:2948:70: 2952:6 (#0)",
        "source": "{\n        link_len =\n            sd_autolink__username(&mut rewind, link, data, max_rewind,\n                                  max_lookbehind, size, &mut no_slash)\n    }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/autolink.rs:19:1: 19:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:65 ~ c2rust[26e7]::src::buffer::bufputs)",
    "span": "src/buffer.rs:141:1: 145:2 (#0)",
    "pieces": [
      "src/buffer.rs:141:1: 145:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn bufputs(mut buf: *mut buf,\n                                 mut str: *const std::os::raw::c_char) {\n    bufput(buf, str as *const std::os::raw::c_void, strlen(str));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/buffer.rs:12:1: 12:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/buffer.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/buffer.rs:8:1: 8:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/buffer.rs:11:1: 11:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/buffer.rs:6:1: 6:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:197 ~ c2rust[26e7]::src::markdown::hash_block_tag)",
    "span": "src/markdown.rs:355:1: 626:2 (#0)",
    "pieces": [
      "src/markdown.rs:355:1: 358:8 (#0)",
      "src/markdown.rs:612:1: 612:3 (#0)",
      "src/markdown.rs:624:1: 626:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn hash_block_tag(mut str: *const std::os::raw::c_char,\n                                    mut len: std::os::raw::c_uint) -> std::os::raw::c_uint {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [
      {
        "caller": "DefId(0:224 ~ c2rust[26e7]::src::markdown::find_block_tag)",
        "span": "src/markdown.rs:674:9: 674:99 (#0)",
        "source": "let mut key: std::os::raw::c_int = hash_block_tag(str, len as u32) as std::os::raw::c_int;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/markdown.rs:358:9: 611:62 (#0)",
        "pieces": [
          "src/markdown.rs:358:9: 611:62 (#0)"
        ],
        "num_lines": 254,
        "source": "static mut asso_values: [std::os::raw::c_uchar; 257] =\n        [38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         8 as std::os::raw::c_int as std::os::raw::c_uchar,\n         30 as std::os::raw::c_int as std::os::raw::c_uchar,\n         25 as std::os::raw::c_int as std::os::raw::c_uchar,\n         20 as std::os::raw::c_int as std::os::raw::c_uchar,\n         15 as std::os::raw::c_int as std::os::raw::c_uchar,\n         10 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         0 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         0 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         5 as std::os::raw::c_int as std::os::raw::c_uchar, 5 as std::os::raw::c_int as std::os::raw::c_uchar,\n         5 as std::os::raw::c_int as std::os::raw::c_uchar,\n         15 as std::os::raw::c_int as std::os::raw::c_uchar,\n         0 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         0 as std::os::raw::c_int as std::os::raw::c_uchar,\n         15 as std::os::raw::c_int as std::os::raw::c_uchar,\n         10 as std::os::raw::c_int as std::os::raw::c_uchar,\n         0 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         15 as std::os::raw::c_int as std::os::raw::c_uchar,\n         0 as std::os::raw::c_int as std::os::raw::c_uchar, 5 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         0 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         0 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         5 as std::os::raw::c_int as std::os::raw::c_uchar, 5 as std::os::raw::c_int as std::os::raw::c_uchar,\n         5 as std::os::raw::c_int as std::os::raw::c_uchar,\n         15 as std::os::raw::c_int as std::os::raw::c_uchar,\n         0 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         0 as std::os::raw::c_int as std::os::raw::c_uchar,\n         15 as std::os::raw::c_int as std::os::raw::c_uchar,\n         10 as std::os::raw::c_int as std::os::raw::c_uchar,\n         0 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         15 as std::os::raw::c_int as std::os::raw::c_uchar,\n         0 as std::os::raw::c_int as std::os::raw::c_uchar, 5 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar,\n         38 as std::os::raw::c_int as std::os::raw::c_uchar];",
        "sub_chunks": [],
        "live_in": [],
        "live_out": []
      },
      {
        "chunk_id": 1,
        "span": "src/markdown.rs:612:4: 622:20 (#0)",
        "pieces": [
          "src/markdown.rs:612:4: 622:20 (#0)"
        ],
        "num_lines": 15,
        "source": "let mut hval: std::os::raw::c_int = len as std::os::raw::c_int;\n    match hval {\n        1 => { }\n        _ => {\n            hval +=\n                asso_values[(*str.offset(1 as std::os::raw::c_int as isize) as\n                                 std::os::raw::c_uchar as std::os::raw::c_int +\n                                 1 as std::os::raw::c_int) as usize] as std::os::raw::c_int\n        }\n    }\n    /*FALLTHROUGH*/\n    hval +=\n        asso_values[*str.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_uchar as\n                        usize] as std::os::raw::c_int;\n    return hval as std::os::raw::c_uint;",
        "sub_chunks": [],
        "live_in": [
          "str: *const i8",
          "len: u32",
          "str_slice: &[u8]",
          "mut hval: i32",
          "str_slice: &[u8]"
        ],
        "live_out": [
          "str: *const i8",
          "len: u32"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:250 ~ c2rust[26e7]::src::markdown::is_atxheader)",
    "span": "src/markdown.rs:3549:1: 3568:2 (#0)",
    "pieces": [
      "src/markdown.rs:3549:1: 3568:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "unsafe extern \"C\" fn is_atxheader(mut rndr: *mut sd_markdown,\n                                  mut data: *mut uint8_t, mut size: size_t)\n -> std::os::raw::c_int {\n    if *data.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int != '#' as i32 {\n        return 0 as std::os::raw::c_int\n    }\n    if (*rndr).ext_flags & MKDEXT_SPACE_HEADERS as std::os::raw::c_int as std::os::raw::c_uint\n           != 0 {\n        let mut level: size_t = 0 as std::os::raw::c_int as size_t;\n        while level < size && level < 6 as std::os::raw::c_int as std::os::raw::c_ulong &&\n                  *data.offset(level as isize) as std::os::raw::c_int == '#' as i32 {\n            level = level.wrapping_add(1)\n        }\n        if level < size &&\n               *data.offset(level as isize) as std::os::raw::c_int != ' ' as i32 {\n            return 0 as std::os::raw::c_int\n        }\n    }\n    return 1 as std::os::raw::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:260 ~ c2rust[26e7]::src::markdown::parse_paragraph)",
    "span": "src/markdown.rs:3887:1: 4034:2 (#0)",
    "pieces": [
      "src/markdown.rs:3887:1: 3891:4 (#0)",
      "src/markdown.rs:3987:1: 3987:4 (#0)",
      "src/markdown.rs:4034:1: 4034:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn parse_paragraph(mut ob: *mut buf,\n                                     mut rndr: *mut sd_markdown,\n                                     mut data: *mut uint8_t, mut size: size_t)\n -> size_t {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/markdown.rs:3891:5: 3986:6 (#0)",
        "pieces": [
          "src/markdown.rs:3891:5: 3986:6 (#0)"
        ],
        "num_lines": 96,
        "source": "let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut end: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut level: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    let mut work: buf =\n        {\n            let mut init =\n                buf{data: data,\n                    size: 0 as std::os::raw::c_int as size_t,\n                    asize: 0 as std::os::raw::c_int as size_t,\n                    unit: 0 as std::os::raw::c_int as size_t,};\n            init\n        };\n    while i < size {\n        end = i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong);\n        while end < size &&\n                  *data.offset(end.wrapping_sub(1 as std::os::raw::c_int as\n                                                    std::os::raw::c_ulong) as isize)\n                      as std::os::raw::c_int != '\\n' as i32 {\n            /* empty */\n            end = end.wrapping_add(1)\n        }\n        if prefix_quote(data.offset(i as isize), end.wrapping_sub(i)) !=\n               0 as std::os::raw::c_int as std::os::raw::c_ulong {\n            end = i;\n            break ;\n        } else {\n            if is_empty(data.offset(i as isize), size.wrapping_sub(i)) != 0 {\n                break ;\n            }\n            level =\n                is_headerline(data.offset(i as isize), size.wrapping_sub(i));\n            if level != 0 as std::os::raw::c_int { break ; }\n            if is_atxheader(rndr, data.offset(i as isize),\n                            size.wrapping_sub(i)) != 0 ||\n                   is_hrule(data.offset(i as isize), size.wrapping_sub(i)) !=\n                       0 ||\n                   prefix_quote(data.offset(i as isize), size.wrapping_sub(i))\n                       != 0 {\n                end = i;\n                break ;\n            } else {\n                /*\n\t\t * Early termination of a paragraph with the same logic\n\t\t * as Markdown 1.0.0. If this logic is applied, the\n\t\t * Markdown 1.0.3 test suite won't pass cleanly\n\t\t *\n\t\t * :: If the first character in a new line is not a letter,\n\t\t * let's check to see if there's some kind of block starting\n\t\t * here\n\t\t */\n                if (*rndr).ext_flags &\n                       MKDEXT_LAX_SPACING as std::os::raw::c_int as std::os::raw::c_uint != 0\n                       &&\n                       *(*__ctype_b_loc()).offset(*data.offset(i as isize) as\n                                                      std::os::raw::c_int as isize) as\n                           std::os::raw::c_int &\n                           _ISalnum as std::os::raw::c_int as std::os::raw::c_ushort as\n                               std::os::raw::c_int == 0 {\n                    if prefix_oli(data.offset(i as isize),\n                                  size.wrapping_sub(i)) != 0 ||\n                           prefix_uli(data.offset(i as isize),\n                                      size.wrapping_sub(i)) != 0 {\n                        end = i;\n                        break ;\n                    } else if *data.offset(i as isize) as std::os::raw::c_int ==\n                                  '<' as i32 && (*rndr).cb.blockhtml.is_some()\n                                  &&\n                                  parse_htmlblock(ob, rndr,\n                                                  data.offset(i as isize),\n                                                  size.wrapping_sub(i),\n                                                  0 as std::os::raw::c_int) != 0 {\n                        end = i;\n                        break ;\n                    } else if (*rndr).ext_flags &\n                                  MKDEXT_FENCED_CODE as std::os::raw::c_int as\n                                      std::os::raw::c_uint !=\n                                  0 as std::os::raw::c_int as std::os::raw::c_uint &&\n                                  is_codefence(data.offset(i as isize),\n                                               size.wrapping_sub(i),\n                                               0 as *mut buf) !=\n                                      0 as std::os::raw::c_int as std::os::raw::c_ulong {\n                        end = i;\n                        break ;\n                    }\n                }\n                i = end\n            }\n        }\n    }\n    work.size = i;\n    while work.size != 0 &&\n              *data.offset(work.size.wrapping_sub(1 as std::os::raw::c_int as\n                                                      std::os::raw::c_ulong) as isize)\n                  as std::os::raw::c_int == '\\n' as i32 {\n        work.size = work.size.wrapping_sub(1)\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut ob: *mut src::autolink::buf",
          "mut rndr: *mut src::markdown::sd_markdown",
          "mut data: *mut u8",
          "mut size: u64"
        ],
        "live_out": [
          "mut ob: *mut src::autolink::buf",
          "mut rndr: *mut src::markdown::sd_markdown",
          "mut data: *mut u8",
          "mut size: u64",
          "mut i: u64",
          "mut end: u64",
          "mut level: i32",
          "mut work: src::autolink::buf"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/markdown.rs:3987:5: 4032:12 (#0)",
        "pieces": [
          "src/markdown.rs:3987:5: 4032:12 (#0)"
        ],
        "num_lines": 63,
        "source": "if level == 0 {\n        let mut tmp: *mut buf = rndr_newbuf(rndr, 0 as std::os::raw::c_int);\n        parse_inline(tmp, rndr, work.data, work.size);\n        if (*rndr).cb.paragraph.is_some() {\n            (*rndr).cb.paragraph.expect(\"non-null function pointer\")(ob, tmp,\n                                                                     (*rndr).opaque);\n        }\n        rndr_popbuf(rndr, 0 as std::os::raw::c_int);\n    } else {\n        let mut header_work: *mut buf = 0 as *mut buf;\n        if work.size != 0 {\n            let mut beg: size_t = 0;\n            i = work.size;\n            work.size =\n                (work.size as\n                     std::os::raw::c_ulong).wrapping_sub(1 as std::os::raw::c_int as\n                                                     std::os::raw::c_ulong) as size_t\n                    as size_t;\n            while work.size != 0 &&\n                      *data.offset(work.size as isize) as std::os::raw::c_int !=\n                          '\\n' as i32 {\n                work.size =\n                    (work.size as\n                         std::os::raw::c_ulong).wrapping_sub(1 as std::os::raw::c_int as\n                                                         std::os::raw::c_ulong) as\n                        size_t as size_t\n            }\n            beg = work.size.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong);\n            while work.size != 0 &&\n                      *data.offset(work.size.wrapping_sub(1 as std::os::raw::c_int as\n                                                              std::os::raw::c_ulong)\n                                       as isize) as std::os::raw::c_int == '\\n' as i32\n                  {\n                work.size =\n                    (work.size as\n                         std::os::raw::c_ulong).wrapping_sub(1 as std::os::raw::c_int as\n                                                         std::os::raw::c_ulong) as\n                        size_t as size_t\n            }\n            if work.size > 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n                let mut tmp_0: *mut buf = rndr_newbuf(rndr, 0 as std::os::raw::c_int);\n                parse_inline(tmp_0, rndr, work.data, work.size);\n                if (*rndr).cb.paragraph.is_some() {\n                    (*rndr).cb.paragraph.expect(\"non-null function pointer\")(ob,\n                                                                             tmp_0,\n                                                                             (*rndr).opaque);\n                }\n                rndr_popbuf(rndr, 0 as std::os::raw::c_int);\n                work.data = work.data.offset(beg as isize);\n                work.size = i.wrapping_sub(beg)\n            } else { work.size = i }\n        }\n        header_work = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n        parse_inline(header_work, rndr, work.data, work.size);\n        if (*rndr).cb.header.is_some() {\n            (*rndr).cb.header.expect(\"non-null function pointer\")(ob,\n                                                                  header_work,\n                                                                  level,\n                                                                  (*rndr).opaque);\n        }\n        rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n    }\n    return end;",
        "sub_chunks": [],
        "live_in": [
          "mut ob: *mut src::autolink::buf",
          "mut rndr: *mut src::markdown::sd_markdown",
          "mut data: *mut u8",
          "mut size: u64",
          "mut i: u64",
          "mut end: u64",
          "mut level: i32",
          "mut work: src::autolink::buf"
        ],
        "live_out": [
          "mut ob: *mut src::autolink::buf",
          "mut rndr: *mut src::markdown::sd_markdown",
          "mut data: *mut u8",
          "mut size: u64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:253 ~ c2rust[26e7]::src::markdown::prefix_quote)",
    "span": "src/markdown.rs:3618:1: 3642:2 (#0)",
    "pieces": [
      "src/markdown.rs:3618:1: 3642:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 25,
    "source": "unsafe extern \"C\" fn prefix_quote(mut data: *mut uint8_t, mut size: size_t)\n -> size_t {\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    if i < size && *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i < size && *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i < size && *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i < size && *data.offset(i as isize) as std::os::raw::c_int == '>' as i32 &&\n           (i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) < size &&\n                *data.offset(i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n                                 as isize) as std::os::raw::c_int != '!' as i32) {\n        if i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) < size &&\n               *data.offset(i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n                                as isize) as std::os::raw::c_int == ' ' as i32 {\n            return i.wrapping_add(2 as std::os::raw::c_int as std::os::raw::c_ulong)\n        }\n        return i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n    }\n    return 0 as std::os::raw::c_int as size_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:246 ~ c2rust[26e7]::src::markdown::is_empty)",
    "span": "src/markdown.rs:3400:1: 3411:2 (#0)",
    "pieces": [
      "src/markdown.rs:3400:1: 3411:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "unsafe extern \"C\" fn is_empty(mut data: *mut uint8_t, mut size: size_t)\n -> size_t {\n    let mut i: size_t = 0;\n    i = 0 as std::os::raw::c_int as size_t;\n    while i < size && *data.offset(i as isize) as std::os::raw::c_int != '\\n' as i32 {\n        if *data.offset(i as isize) as std::os::raw::c_int != ' ' as i32 {\n            return 0 as std::os::raw::c_int as size_t\n        }\n        i = i.wrapping_add(1)\n    }\n    return i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:295 ~ c2rust[26e7]::src::markdown::parse_htmlblock)",
        "span": "src/markdown.rs:4582:17: 4582:77 (#0)",
        "source": "j = is_empty(data.offset(i as isize), size.wrapping_sub(i));"
      },
      {
        "caller": "DefId(0:293 ~ c2rust[26e7]::src::markdown::htmlblock_end_tag)",
        "span": "src/markdown.rs:4432:17: 4434:6 (#0)",
        "source": "{\n        w = is_empty(data.offset(i as isize), size.wrapping_sub(i))\n    }"
      },
      {
        "caller": "DefId(0:295 ~ c2rust[26e7]::src::markdown::parse_htmlblock)",
        "span": "src/markdown.rs:4552:25: 4554:14 (#0)",
        "source": "{\n                j = is_empty(data.offset(i as isize), size.wrapping_sub(i))\n            }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:266 ~ c2rust[26e7]::src::markdown::htmlblock_end_tag)",
    "span": "src/markdown.rs:4400:1: 4436:2 (#0)",
    "pieces": [
      "src/markdown.rs:4400:1: 4436:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 37,
    "source": "unsafe extern \"C\" fn htmlblock_end_tag(mut tag: *const std::os::raw::c_char,\n                                       mut tag_len: size_t,\n                                       mut rndr: *mut sd_markdown,\n                                       mut data: *mut uint8_t,\n                                       mut size: size_t) -> size_t {\n    let mut i: size_t = 0;\n    let mut w: size_t = 0;\n    /* checking if tag is a match */\n    if tag_len.wrapping_add(3 as std::os::raw::c_int as std::os::raw::c_ulong) >= size ||\n           strncasecmp((data as\n                            *mut std::os::raw::c_char).offset(2 as std::os::raw::c_int as\n                                                          isize), tag,\n                       tag_len) != 0 as std::os::raw::c_int ||\n           *data.offset(tag_len.wrapping_add(2 as std::os::raw::c_int as\n                                                 std::os::raw::c_ulong) as isize) as\n               std::os::raw::c_int != '>' as i32 {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    /* checking white lines */\n    i =\n        tag_len.wrapping_add(3 as std::os::raw::c_int as\n                                 std::os::raw::c_ulong); /* non-blank after tag */\n    w = 0 as std::os::raw::c_int as size_t;\n    if i < size &&\n           {\n               w = is_empty(data.offset(i as isize), size.wrapping_sub(i));\n               (w) == 0 as std::os::raw::c_int as std::os::raw::c_ulong\n           } {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    i = (i as std::os::raw::c_ulong).wrapping_add(w) as size_t as size_t;\n    w = 0 as std::os::raw::c_int as size_t;\n    if i < size {\n        w = is_empty(data.offset(i as isize), size.wrapping_sub(i))\n    }\n    return i.wrapping_add(w);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:267 ~ c2rust[26e7]::src::markdown::htmlblock_end)",
    "span": "src/markdown.rs:4437:1: 4489:2 (#0)",
    "pieces": [
      "src/markdown.rs:4437:1: 4489:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 53,
    "source": "unsafe extern \"C\" fn htmlblock_end(mut curtag: *const std::os::raw::c_char,\n                                   mut rndr: *mut sd_markdown,\n                                   mut data: *mut uint8_t, mut size: size_t,\n                                   mut start_of_line: std::os::raw::c_int) -> size_t {\n    let mut tag_size: size_t = strlen(curtag);\n    let mut i: size_t = 1 as std::os::raw::c_int as size_t;\n    let mut end_tag: size_t = 0;\n    let mut block_lines: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    while i < size {\n        i = i.wrapping_add(1);\n        while i < size &&\n                  !(*data.offset(i.wrapping_sub(1 as std::os::raw::c_int as\n                                                    std::os::raw::c_ulong) as isize)\n                        as std::os::raw::c_int == '<' as i32 &&\n                        *data.offset(i as isize) as std::os::raw::c_int == '/' as i32)\n              {\n            if *data.offset(i as isize) as std::os::raw::c_int == '\\n' as i32 {\n                block_lines += 1\n            }\n            i = i.wrapping_add(1)\n        }\n        /* If we are only looking for unindented tags, skip the tag\n\t\t * if it doesn't follow a newline.\n\t\t *\n\t\t * The only exception to this is if the tag is still on the\n\t\t * initial line; in that case it still counts as a closing\n\t\t * tag\n\t\t */\n        if start_of_line != 0 && block_lines > 0 as std::os::raw::c_int &&\n               *data.offset(i.wrapping_sub(2 as std::os::raw::c_int as std::os::raw::c_ulong)\n                                as isize) as std::os::raw::c_int != '\\n' as i32 {\n            continue ;\n        }\n        if i.wrapping_add(2 as std::os::raw::c_int as\n                              std::os::raw::c_ulong).wrapping_add(tag_size) >= size {\n            break ;\n        }\n        end_tag =\n            htmlblock_end_tag(curtag, tag_size, rndr,\n                              data.offset(i as\n                                              isize).offset(-(1 as std::os::raw::c_int\n                                                                  as isize)),\n                              size.wrapping_sub(i).wrapping_add(1 as\n                                                                    std::os::raw::c_int\n                                                                    as\n                                                                    std::os::raw::c_ulong));\n        if end_tag != 0 {\n            return i.wrapping_add(end_tag).wrapping_sub(1 as std::os::raw::c_int as\n                                                            std::os::raw::c_ulong)\n        }\n    }\n    return 0 as std::os::raw::c_int as size_t;\n}",
    "calls": [
      {
        "caller": "DefId(0:295 ~ c2rust[26e7]::src::markdown::parse_htmlblock)",
        "span": "src/markdown.rs:4606:41: 4608:6 (#0)",
        "source": "{\n        tag_end = htmlblock_end(curtag, rndr, data, size, 0 as std::os::raw::c_int)\n    }"
      },
      {
        "caller": "DefId(0:295 ~ c2rust[26e7]::src::markdown::parse_htmlblock)",
        "span": "src/markdown.rs:4599:5: 4599:81 (#0)",
        "source": "tag_end = htmlblock_end(curtag, rndr, data, size, 1 as std::os::raw::c_int);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:200 ~ c2rust[26e7]::src::markdown::find_block_tag)",
    "span": "src/markdown.rs:629:1: 687:2 (#0)",
    "pieces": [
      "src/markdown.rs:629:1: 687:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 59,
    "source": "unsafe extern \"C\" fn find_block_tag(mut str: *const std::os::raw::c_char,\n                                    mut len: std::os::raw::c_uint)\n -> *const std::os::raw::c_char {\n    static mut wordlist: [*const std::os::raw::c_char; 39] =\n        [b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"p\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"dl\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"div\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"math\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"table\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"ul\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"del\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"form\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"blockquote\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"figure\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"ol\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"fieldset\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"h1\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"h6\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"pre\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"script\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"h5\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"noscript\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"style\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"iframe\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"h4\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"ins\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"h3\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"h2\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"span\\x00\" as *const u8 as *const std::os::raw::c_char];\n    if len <= MAX_WORD_LENGTH_0 as std::os::raw::c_int as std::os::raw::c_uint &&\n           len >= MIN_WORD_LENGTH_0 as std::os::raw::c_int as std::os::raw::c_uint {\n        let mut key: std::os::raw::c_int = hash_block_tag(str, len) as std::os::raw::c_int;\n        if key <= MAX_HASH_VALUE_0 as std::os::raw::c_int && key >= 0 as std::os::raw::c_int {\n            let mut s: *const std::os::raw::c_char = wordlist[key as usize];\n            if (*str as std::os::raw::c_uchar as std::os::raw::c_int ^\n                    *s as std::os::raw::c_uchar as std::os::raw::c_int) & !(32 as std::os::raw::c_int)\n                   == 0 as std::os::raw::c_int &&\n                   strncasecmp(str, s, len as std::os::raw::c_ulong) == 0 &&\n                   *s.offset(len as isize) as std::os::raw::c_int == '\\u{0}' as i32 {\n                return s\n            }\n        }\n    }\n    return 0 as *const std::os::raw::c_char;\n}",
    "calls": [
      {
        "caller": "DefId(0:295 ~ c2rust[26e7]::src::markdown::parse_htmlblock)",
        "span": "src/markdown.rs:4519:17: 4526:6 (#0)",
        "source": "{\n        curtag =\n            find_block_tag((data as\n                                *mut std::os::raw::c_char).offset(1 as std::os::raw::c_int as\n                                                              isize),\n                           (i as std::os::raw::c_int - 1 as std::os::raw::c_int) as\n                               std::os::raw::c_uint)\n    }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:268 ~ c2rust[26e7]::src::markdown::parse_htmlblock)",
    "span": "src/markdown.rs:4491:1: 4618:2 (#0)",
    "pieces": [
      "src/markdown.rs:4491:1: 4618:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 128,
    "source": "unsafe extern \"C\" fn parse_htmlblock(mut ob: *mut buf,\n                                     mut rndr: *mut sd_markdown,\n                                     mut data: *mut uint8_t, mut size: size_t,\n                                     mut do_render: std::os::raw::c_int) -> size_t {\n    let mut i: size_t = 0;\n    let mut j: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut tag_end: size_t = 0;\n    let mut curtag: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;\n    let mut work: buf =\n        {\n            let mut init =\n                buf{data: data,\n                    size: 0 as std::os::raw::c_int as size_t,\n                    asize: 0 as std::os::raw::c_int as size_t,\n                    unit: 0 as std::os::raw::c_int as size_t,};\n            init\n        };\n    /* identification of the opening tag */\n    if size < 2 as std::os::raw::c_int as std::os::raw::c_ulong ||\n           *data.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int !=\n               '<' as i32 {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    i = 1 as std::os::raw::c_int as size_t;\n    while i < size && *data.offset(i as isize) as std::os::raw::c_int != '>' as i32 &&\n              *data.offset(i as isize) as std::os::raw::c_int != ' ' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i < size {\n        curtag =\n            find_block_tag((data as\n                                *mut std::os::raw::c_char).offset(1 as std::os::raw::c_int as\n                                                              isize),\n                           (i as std::os::raw::c_int - 1 as std::os::raw::c_int) as\n                               std::os::raw::c_uint)\n    }\n    /* handling of special cases */\n    if curtag.is_null() {\n        /* HTML comment, laxist form */\n        if size > 5 as std::os::raw::c_int as std::os::raw::c_ulong &&\n               *data.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n                   '!' as i32 &&\n               *data.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n                   '-' as i32 &&\n               *data.offset(3 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n                   '-' as i32 {\n            i = 5 as std::os::raw::c_int as size_t;\n            while i < size &&\n                      !(*data.offset(i.wrapping_sub(2 as std::os::raw::c_int as\n                                                        std::os::raw::c_ulong) as\n                                         isize) as std::os::raw::c_int == '-' as i32\n                            &&\n                            *data.offset(i.wrapping_sub(1 as std::os::raw::c_int as\n                                                            std::os::raw::c_ulong) as\n                                             isize) as std::os::raw::c_int ==\n                                '-' as i32 &&\n                            *data.offset(i as isize) as std::os::raw::c_int ==\n                                '>' as i32) {\n                i = i.wrapping_add(1)\n            }\n            i = i.wrapping_add(1);\n            if i < size {\n                j = is_empty(data.offset(i as isize), size.wrapping_sub(i))\n            }\n            if j != 0 {\n                work.size = i.wrapping_add(j);\n                if do_render != 0 && (*rndr).cb.blockhtml.is_some() {\n                    (*rndr).cb.blockhtml.expect(\"non-null function pointer\")(ob,\n                                                                             &mut work,\n                                                                             (*rndr).opaque);\n                }\n                return work.size\n            }\n        }\n        /* HR, which is the only self-closing block tag considered */\n        if size > 4 as std::os::raw::c_int as std::os::raw::c_ulong &&\n               (*data.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n                    'h' as i32 ||\n                    *data.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n                        'H' as i32) &&\n               (*data.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n                    'r' as i32 ||\n                    *data.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n                        'R' as i32) {\n            i = 3 as std::os::raw::c_int as size_t;\n            while i < size &&\n                      *data.offset(i as isize) as std::os::raw::c_int != '>' as i32 {\n                i = i.wrapping_add(1)\n            }\n            if i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) < size {\n                i = i.wrapping_add(1);\n                j = is_empty(data.offset(i as isize), size.wrapping_sub(i));\n                if j != 0 {\n                    work.size = i.wrapping_add(j);\n                    if do_render != 0 && (*rndr).cb.blockhtml.is_some() {\n                        (*rndr).cb.blockhtml.expect(\"non-null function pointer\")(ob,\n                                                                                 &mut work,\n                                                                                 (*rndr).opaque);\n                    }\n                    return work.size\n                }\n            }\n        }\n        /* no special case recognised */\n        return 0 as std::os::raw::c_int as size_t\n    }\n    /* looking for an unindented matching closing tag */\n\t/*\tfollowed by a blank line */\n    tag_end = htmlblock_end(curtag, rndr, data, size, 1 as std::os::raw::c_int);\n    /* if not found, trying a second pass looking for indented match */\n\t/* but not if tag is \"ins\" or \"del\" (following original Markdown.pl) */\n    if tag_end == 0 &&\n           strcmp(curtag, b\"ins\\x00\" as *const u8 as *const std::os::raw::c_char) !=\n               0 as std::os::raw::c_int &&\n           strcmp(curtag, b\"del\\x00\" as *const u8 as *const std::os::raw::c_char) !=\n               0 as std::os::raw::c_int {\n        tag_end = htmlblock_end(curtag, rndr, data, size, 0 as std::os::raw::c_int)\n    }\n    if tag_end == 0 { return 0 as std::os::raw::c_int as size_t }\n    /* the end of the block has been found */\n    work.size = tag_end;\n    if do_render != 0 && (*rndr).cb.blockhtml.is_some() {\n        (*rndr).cb.blockhtml.expect(\"non-null function pointer\")(ob,\n                                                                 &mut work,\n                                                                 (*rndr).opaque);\n    }\n    return tag_end;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:292 ~ c2rust[26e7]::src::stack::stack_pop)",
    "span": "src/stack.rs:77:1: 81:2 (#0)",
    "pieces": [
      "src/stack.rs:77:1: 81:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn stack_pop(mut st: *mut stack) -> *mut std::os::raw::c_void {\n    if (*st).size == 0 { return 0 as *mut std::os::raw::c_void }\n    (*st).size = (*st).size.wrapping_sub(1);\n    return *(*st).item.offset((*st).size as isize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stack.rs:4:1: 4:26 (#0)",
        "source": "use std::os::raw::c_void;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:67 ~ c2rust[26e7]::src::buffer::bufrelease)",
    "span": "src/buffer.rs:166:1: 170:2 (#0)",
    "pieces": [
      "src/buffer.rs:166:1: 170:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn bufrelease(mut buf: *mut buf) {\n    if buf.is_null() { return }\n    free((*buf).data as *mut std::os::raw::c_void);\n    free(buf as *mut std::os::raw::c_void);\n}",
    "calls": [
      {
        "caller": "DefId(0:303 ~ c2rust[26e7]::src::markdown::sd_markdown_render)",
        "span": "src/markdown.rs:5365:5: 5365:22 (#0)",
        "source": "bufrelease(text);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/buffer.rs:8:1: 8:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/buffer.rs:11:1: 11:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/buffer.rs:12:1: 12:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/buffer.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/buffer.rs:6:1: 6:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:66 ~ c2rust[26e7]::src::buffer::bufputc)",
    "span": "src/buffer.rs:149:1: 163:2 (#0)",
    "pieces": [
      "src/buffer.rs:149:1: 163:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn bufputc(mut buf: *mut buf, mut c: std::os::raw::c_int) {\n    if (*buf).size.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) >\n           (*buf).asize &&\n           bufgrow(buf,\n                   (*buf).size.wrapping_add(1 as std::os::raw::c_int as\n                                                std::os::raw::c_ulong)) <\n               0 as std::os::raw::c_int {\n        return\n    }\n    *(*buf).data.offset((*buf).size as isize) = c as uint8_t;\n    (*buf).size =\n        ((*buf).size as\n             std::os::raw::c_ulong).wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) as\n            size_t as size_t;\n}",
    "calls": [
      {
        "caller": "DefId(0:264 ~ c2rust[26e7]::src::markdown::char_entity)",
        "span": "src/markdown.rs:2824:23: 2824:47 (#0)",
        "source": "bufputc(ob, 'x' as i32);"
      },
      {
        "caller": "DefId(0:264 ~ c2rust[26e7]::src::markdown::char_entity)",
        "span": "src/markdown.rs:2823:27: 2823:51 (#0)",
        "source": "bufputc(ob, '#' as i32);"
      },
      {
        "caller": "DefId(0:264 ~ c2rust[26e7]::src::markdown::char_entity)",
        "span": "src/markdown.rs:2822:9: 2822:33 (#0)",
        "source": "bufputc(ob, '&' as i32);"
      },
      {
        "caller": "DefId(0:288 ~ c2rust[26e7]::src::markdown::parse_fencedcode)",
        "span": "src/markdown.rs:4106:9: 4106:36 (#0)",
        "source": "bufputc(work, '\\n' as i32);"
      },
      {
        "caller": "DefId(0:262 ~ c2rust[26e7]::src::markdown::char_escape)",
        "span": "src/markdown.rs:2729:9: 2729:93 (#0)",
        "source": "bufputc(ob, *data.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:289 ~ c2rust[26e7]::src::markdown::parse_blockcode)",
        "span": "src/markdown.rs:4172:5: 4172:32 (#0)",
        "source": "bufputc(work, '\\n' as i32);"
      },
      {
        "caller": "DefId(0:262 ~ c2rust[26e7]::src::markdown::char_escape)",
        "span": "src/markdown.rs:2725:13: 2726:93 (#0)",
        "source": "bufputc(ob,\n                    *data.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:303 ~ c2rust[26e7]::src::markdown::sd_markdown_render)",
        "span": "src/markdown.rs:5356:13: 5356:40 (#0)",
        "source": "bufputc(text, '\\n' as i32);"
      },
      {
        "caller": "DefId(0:268 ~ c2rust[26e7]::src::markdown::char_autolink_subreddit_or_username)",
        "span": "src/markdown.rs:2956:28: 2956:58 (#0)",
        "source": "bufputc(link_url, '/' as i32);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/buffer.rs:6:1: 6:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/buffer.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/buffer.rs:8:1: 8:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/buffer.rs:12:1: 12:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/buffer.rs:11:1: 11:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:262 ~ c2rust[26e7]::src::markdown::parse_blockcode)",
    "span": "src/markdown.rs:4122:1: 4181:2 (#0)",
    "pieces": [
      "src/markdown.rs:4122:1: 4181:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 60,
    "source": "unsafe extern \"C\" fn parse_blockcode(mut ob: *mut buf,\n                                     mut rndr: *mut sd_markdown,\n                                     mut data: *mut uint8_t, mut size: size_t)\n -> size_t {\n    let mut beg: size_t = 0;\n    let mut end: size_t = 0;\n    let mut pre: size_t = 0;\n    let mut work: *mut buf = 0 as *mut buf;\n    work = rndr_newbuf(rndr, 0 as std::os::raw::c_int);\n    beg = 0 as std::os::raw::c_int as size_t;\n    while beg < size {\n        end = beg.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong);\n        while end < size &&\n                  *data.offset(end.wrapping_sub(1 as std::os::raw::c_int as\n                                                    std::os::raw::c_ulong) as isize)\n                      as std::os::raw::c_int != '\\n' as i32 {\n            end = end.wrapping_add(1)\n        }\n        pre = prefix_code(data.offset(beg as isize), end.wrapping_sub(beg));\n        if pre != 0 {\n            beg = (beg as std::os::raw::c_ulong).wrapping_add(pre) as size_t as size_t\n        } else if is_empty(data.offset(beg as isize), end.wrapping_sub(beg))\n                      == 0 {\n            break ;\n        }\n        if beg < end {\n            /* verbatim copy to the working buffer,\n\t\t\t\tescaping entities */\n            if is_empty(data.offset(beg as isize), end.wrapping_sub(beg)) != 0\n               {\n                bufputc(work, '\\n' as i32);\n            } else {\n                bufput(work, data.offset(beg as isize) as *const std::os::raw::c_void,\n                       end.wrapping_sub(beg));\n            }\n        }\n        beg = end\n    }\n    while (*work).size != 0 &&\n              *(*work).data.offset((*work).size.wrapping_sub(1 as std::os::raw::c_int\n                                                                 as\n                                                                 std::os::raw::c_ulong)\n                                       as isize) as std::os::raw::c_int == '\\n' as i32\n          {\n        (*work).size =\n            ((*work).size as\n                 std::os::raw::c_ulong).wrapping_sub(1 as std::os::raw::c_int as\n                                                 std::os::raw::c_ulong) as size_t as\n                size_t\n    }\n    bufputc(work, '\\n' as i32);\n    if (*rndr).cb.blockcode.is_some() {\n        (*rndr).cb.blockcode.expect(\"non-null function pointer\")(ob, work,\n                                                                 0 as\n                                                                     *const buf,\n                                                                 (*rndr).opaque);\n    }\n    rndr_popbuf(rndr, 0 as std::os::raw::c_int);\n    return beg;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:36 ~ c2rust[26e7]::src::autolink::autolink_delim)",
    "span": "src/autolink.rs:118:1: 211:2 (#0)",
    "pieces": [
      "src/autolink.rs:118:1: 211:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 94,
    "source": "unsafe extern \"C\" fn autolink_delim(mut data: *mut uint8_t,\n                                    mut link_end: size_t,\n                                    mut max_rewind: size_t, mut size: size_t)\n -> size_t {\n    let mut cclose: uint8_t = 0;\n    let mut copen: uint8_t = 0 as std::os::raw::c_int as uint8_t;\n    let mut i: size_t = 0;\n    i = 0 as std::os::raw::c_int as size_t;\n    while i < link_end {\n        if *data.offset(i as isize) as std::os::raw::c_int == '<' as i32 {\n            link_end = i;\n            break ;\n        } else { i = i.wrapping_add(1) }\n    }\n    while link_end > 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        let mut c: uint8_t =\n            *data.offset(link_end.wrapping_sub(1 as std::os::raw::c_int as\n                                                   std::os::raw::c_ulong) as isize);\n        if c as std::os::raw::c_int == 0 as std::os::raw::c_int { break ; }\n        if !strchr(b\"?!.,\\x00\" as *const u8 as *const std::os::raw::c_char,\n                   c as std::os::raw::c_int).is_null() {\n            link_end = link_end.wrapping_sub(1)\n        } else {\n            if !(c as std::os::raw::c_int == ';' as i32) { break ; }\n            let mut new_end: size_t =\n                link_end.wrapping_sub(2 as std::os::raw::c_int as std::os::raw::c_ulong);\n            while new_end > 0 as std::os::raw::c_int as std::os::raw::c_ulong &&\n                      *(*__ctype_b_loc()).offset(*data.offset(new_end as\n                                                                  isize) as\n                                                     std::os::raw::c_int as isize) as\n                          std::os::raw::c_int &\n                          _ISalpha as std::os::raw::c_int as std::os::raw::c_ushort as\n                              std::os::raw::c_int != 0 {\n                new_end = new_end.wrapping_sub(1)\n            }\n            if new_end <\n                   link_end.wrapping_sub(2 as std::os::raw::c_int as std::os::raw::c_ulong) &&\n                   *data.offset(new_end as isize) as std::os::raw::c_int == '&' as i32\n               {\n                link_end = new_end\n            } else { link_end = link_end.wrapping_sub(1) }\n        }\n    }\n    if link_end == 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    cclose =\n        *data.offset(link_end.wrapping_sub(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n                         as isize);\n    match cclose as std::os::raw::c_int {\n        34 => { copen = '\\\"' as i32 as uint8_t }\n        39 => { copen = '\\'' as i32 as uint8_t }\n        41 => { copen = '(' as i32 as uint8_t }\n        93 => { copen = '[' as i32 as uint8_t }\n        125 => { copen = '{' as i32 as uint8_t }\n        _ => { }\n    }\n    if copen as std::os::raw::c_int != 0 as std::os::raw::c_int {\n        let mut closing: size_t = 0 as std::os::raw::c_int as size_t;\n        let mut opening: size_t = 0 as std::os::raw::c_int as size_t;\n        let mut i_0: size_t = 0 as std::os::raw::c_int as size_t;\n        /* Try to close the final punctuation sign in this same line;\n\t\t * if we managed to close it outside of the URL, that means that it's\n\t\t * not part of the URL. If it closes inside the URL, that means it\n\t\t * is part of the URL.\n\t\t *\n\t\t * Examples:\n\t\t *\n\t\t *\tfoo http://www.pokemon.com/Pikachu_(Electric) bar\n\t\t *\t\t=> http://www.pokemon.com/Pikachu_(Electric)\n\t\t *\n\t\t *\tfoo (http://www.pokemon.com/Pikachu_(Electric)) bar\n\t\t *\t\t=> http://www.pokemon.com/Pikachu_(Electric)\n\t\t *\n\t\t *\tfoo http://www.pokemon.com/Pikachu_(Electric)) bar\n\t\t *\t\t=> http://www.pokemon.com/Pikachu_(Electric))\n\t\t *\n\t\t *\t(foo http://www.pokemon.com/Pikachu_(Electric)) bar\n\t\t *\t\t=> foo http://www.pokemon.com/Pikachu_(Electric)\n\t\t */\n        while i_0 < link_end {\n            if *data.offset(i_0 as isize) as std::os::raw::c_int ==\n                   copen as std::os::raw::c_int {\n                opening = opening.wrapping_add(1)\n            } else if *data.offset(i_0 as isize) as std::os::raw::c_int ==\n                          cclose as std::os::raw::c_int {\n                closing = closing.wrapping_add(1)\n            }\n            i_0 = i_0.wrapping_add(1)\n        }\n        if closing != opening { link_end = link_end.wrapping_sub(1) }\n    }\n    return link_end;\n}",
    "calls": [
      {
        "caller": "DefId(0:41 ~ c2rust[26e7]::src::autolink::sd_autolink__url)",
        "span": "src/autolink.rs:479:5: 479:65 (#0)",
        "source": "link_end = autolink_delim(data, link_end, max_rewind, size);"
      },
      {
        "caller": "DefId(0:39 ~ c2rust[26e7]::src::autolink::sd_autolink__www)",
        "span": "src/autolink.rs:348:5: 348:65 (#0)",
        "source": "link_end = autolink_delim(data, link_end, max_rewind, size);"
      },
      {
        "caller": "DefId(0:40 ~ c2rust[26e7]::src::autolink::sd_autolink__email)",
        "span": "src/autolink.rs:415:5: 415:65 (#0)",
        "source": "link_end = autolink_delim(data, link_end, max_rewind, size);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/autolink.rs:19:1: 19:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:38 ~ c2rust[26e7]::src::autolink::check_domain)",
    "span": "src/autolink.rs:273:1: 307:2 (#0)",
    "pieces": [
      "src/autolink.rs:273:1: 307:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 35,
    "source": "unsafe extern \"C\" fn check_domain(mut data: *mut uint8_t, mut size: size_t,\n                                  mut allow_short: std::os::raw::c_int) -> size_t {\n    let mut i: size_t = 0;\n    let mut np: size_t = 0 as std::os::raw::c_int as size_t;\n    if *(*__ctype_b_loc()).offset(*data.offset(0 as std::os::raw::c_int as isize) as\n                                      std::os::raw::c_int as isize) as std::os::raw::c_int &\n           _ISalnum as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int == 0 {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    i = 1 as std::os::raw::c_int as size_t;\n    while i < size.wrapping_sub(1 as std::os::raw::c_int as std::os::raw::c_ulong) {\n        if *data.offset(i as isize) as std::os::raw::c_int == '.' as i32 {\n            np = np.wrapping_add(1)\n        } else if *(*__ctype_b_loc()).offset(*data.offset(i as isize) as\n                                                 std::os::raw::c_int as isize) as\n                      std::os::raw::c_int &\n                      _ISalnum as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int\n                      == 0 &&\n                      *data.offset(i as isize) as std::os::raw::c_int != '-' as i32 {\n            break ;\n        }\n        i = i.wrapping_add(1)\n    }\n    if allow_short != 0 {\n        /* We don't need a valid domain in the strict sense (with\n\t\t * least one dot; so just make sure it's composed of valid\n\t\t * domain characters and return the length of the the valid\n\t\t * sequence. */\n        return i\n    } else {\n        /* a valid domain needs to have at least a dot.\n\t\t * that's as far as we get */\n        return if np != 0 { i } else { 0 as std::os::raw::c_int as std::os::raw::c_ulong }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:41 ~ c2rust[26e7]::src::autolink::sd_autolink__url)",
        "span": "src/autolink.rs:459:5: 464:77 (#0)",
        "source": "domain_len =\n        check_domain(data.offset(link_end as isize),\n                     size.wrapping_sub(link_end),\n                     (flags &\n                          SD_AUTOLINK_SHORT_DOMAINS as std::os::raw::c_int as\n                              std::os::raw::c_uint) as std::os::raw::c_int);"
      },
      {
        "caller": "DefId(0:39 ~ c2rust[26e7]::src::autolink::sd_autolink__www)",
        "span": "src/autolink.rs:336:5: 336:67 (#0)",
        "source": "link_end = check_domain(data, size, 0 as std::os::raw::c_int);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/autolink.rs:19:1: 19:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:41 ~ c2rust[26e7]::src::autolink::sd_autolink__url)",
    "span": "src/autolink.rs:425:1: 487:2 (#0)",
    "pieces": [
      "src/autolink.rs:425:1: 487:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 63,
    "source": "pub unsafe extern \"C\" fn sd_autolink__url(mut rewind_p: *mut size_t,\n                                          mut link: *mut buf,\n                                          mut data: *mut uint8_t,\n                                          mut max_rewind: size_t,\n                                          mut size: size_t,\n                                          mut flags: std::os::raw::c_uint) -> size_t {\n    let mut link_end: size_t = 0;\n    let mut rewind: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut domain_len: size_t = 0;\n    if size < 4 as std::os::raw::c_int as std::os::raw::c_ulong ||\n           *data.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int !=\n               '/' as i32 ||\n           *data.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int !=\n               '/' as i32 {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    while rewind < max_rewind &&\n              *(*__ctype_b_loc()).offset(*data.offset(rewind.wrapping_neg().wrapping_sub(1\n                                                                                             as\n                                                                                             std::os::raw::c_int\n                                                                                             as\n                                                                                             std::os::raw::c_ulong)\n                                                          as isize) as\n                                             std::os::raw::c_int as isize) as\n                  std::os::raw::c_int &\n                  _ISalpha as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int !=\n                  0 {\n        rewind = rewind.wrapping_add(1)\n    }\n    if sd_autolink_issafe(data.offset(-(rewind as isize)),\n                          size.wrapping_add(rewind)) == 0 {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    link_end = strlen(b\"://\\x00\" as *const u8 as *const std::os::raw::c_char);\n    domain_len =\n        check_domain(data.offset(link_end as isize),\n                     size.wrapping_sub(link_end),\n                     (flags &\n                          SD_AUTOLINK_SHORT_DOMAINS as std::os::raw::c_int as\n                              std::os::raw::c_uint) as std::os::raw::c_int);\n    if domain_len == 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    link_end =\n        (link_end as std::os::raw::c_ulong).wrapping_add(domain_len) as size_t as\n            size_t;\n    while link_end < size &&\n              *(*__ctype_b_loc()).offset(*data.offset(link_end as isize) as\n                                             std::os::raw::c_int as isize) as\n                  std::os::raw::c_int &\n                  _ISspace as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int ==\n                  0 {\n        link_end = link_end.wrapping_add(1)\n    }\n    link_end = autolink_delim(data, link_end, max_rewind, size);\n    if link_end == 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    bufput(link, data.offset(-(rewind as isize)) as *const std::os::raw::c_void,\n           link_end.wrapping_add(rewind));\n    *rewind_p = rewind;\n    return link_end;\n}",
    "calls": [
      {
        "caller": "DefId(0:270 ~ c2rust[26e7]::src::markdown::char_autolink_url)",
        "span": "src/markdown.rs:3022:5: 3024:76 (#0)",
        "source": "link_len =\n        sd_autolink__url(&mut rewind, link, data, max_rewind, size,\n                         0 as std::os::raw::c_int as std::os::raw::c_uint);"
      }
    ],
    "globals": [
      {
        "span": "src/autolink.rs:48:1: 48:56 (#0)",
        "source": "pub const SD_AUTOLINK_SHORT_DOMAINS: C2RustUnnamed = 1;"
      }
    ],
    "imports": [
      {
        "span": "src/autolink.rs:19:1: 19:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:264 ~ c2rust[26e7]::src::markdown::parse_list)",
    "span": "src/markdown.rs:4330:1: 4350:2 (#0)",
    "pieces": [
      "src/markdown.rs:4330:1: 4350:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "unsafe extern \"C\" fn parse_list(mut ob: *mut buf, mut rndr: *mut sd_markdown,\n                                mut data: *mut uint8_t, mut size: size_t,\n                                mut flags: std::os::raw::c_int) -> size_t {\n    let mut work: *mut buf = 0 as *mut buf;\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut j: size_t = 0;\n    work = rndr_newbuf(rndr, 0 as std::os::raw::c_int);\n    while i < size {\n        j =\n            parse_listitem(work, rndr, data.offset(i as isize),\n                           size.wrapping_sub(i), &mut flags);\n        i = (i as std::os::raw::c_ulong).wrapping_add(j) as size_t as size_t;\n        if j == 0 || flags & 8 as std::os::raw::c_int != 0 { break ; }\n    }\n    if (*rndr).cb.list.is_some() {\n        (*rndr).cb.list.expect(\"non-null function pointer\")(ob, work, flags,\n                                                            (*rndr).opaque);\n    }\n    rndr_popbuf(rndr, 0 as std::os::raw::c_int);\n    return i;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:219 ~ c2rust[26e7]::src::markdown::hash_link_ref)",
    "span": "src/markdown.rs:1930:1: 1939:2 (#0)",
    "pieces": [
      "src/markdown.rs:1930:1: 1939:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn hash_link_ref(mut link_ref: *const uint8_t,\n                                   mut length: size_t) -> std::os::raw::c_uint {\n    let mut i: size_t = 0;\n    let mut hash: std::os::raw::c_uint = 0 as std::os::raw::c_int as std::os::raw::c_uint;\n    i = 0 as std::os::raw::c_int as size_t;\n    while i < length {\n        hash =\n            (tolower(*link_ref.offset(i as isize) as std::os::raw::c_int) as\n                 std::os::raw::c_uint).wrapping_add(hash <<\n                                                6 as\n                                                    std::os::raw::c_int).wrapping_add(hash\n                                                                                  <<\n                                                                                  16\n                                                                                      as\n                                                                                      std::os::raw::c_int).wrapping_sub(hash);\n        i = i.wrapping_add(1)\n    }\n    return hash;\n}",
    "calls": [
      {
        "caller": "DefId(0:245 ~ c2rust[26e7]::src::markdown::add_link_ref)",
        "span": "src/markdown.rs:1950:1: 1950:41 (#0)",
        "source": "(*ref_0).id = hash_link_ref(name_slice);"
      },
      {
        "caller": "DefId(0:246 ~ c2rust[26e7]::src::markdown::find_link_ref)",
        "span": "src/markdown.rs:1963:5: 1963:41 (#0)",
        "source": "let hash: u32 = hash_link_ref(name);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:221 ~ c2rust[26e7]::src::markdown::find_link_ref)",
    "span": "src/markdown.rs:1962:1: 1974:2 (#0)",
    "pieces": [
      "src/markdown.rs:1962:1: 1974:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "unsafe extern \"C\" fn find_link_ref(mut references: *mut *mut link_ref,\n                                   mut name: *mut uint8_t, mut length: size_t)\n -> *mut link_ref {\n    let mut hash: std::os::raw::c_uint = hash_link_ref(name, length);\n    let mut ref_0: *mut link_ref = 0 as *mut link_ref;\n    ref_0 =\n        *references.offset(hash.wrapping_rem(8 as std::os::raw::c_int as std::os::raw::c_uint)\n                               as isize);\n    while !ref_0.is_null() {\n        if (*ref_0).id == hash { return ref_0 }\n        ref_0 = (*ref_0).next\n    }\n    return 0 as *mut link_ref;\n}",
    "calls": [
      {
        "caller": "DefId(0:271 ~ c2rust[26e7]::src::markdown::char_link)",
        "span": "src/markdown.rs:3284:1: 3284:122 (#0)",
        "source": "lr_0 = find_link_ref(unsafe { &mut (*rndr).refs }, unsafe { std::slice::from_raw_parts(id_0.data, id_0.size as usize) });"
      },
      {
        "caller": "DefId(0:271 ~ c2rust[26e7]::src::markdown::char_link)",
        "span": "src/markdown.rs:3241:5: 3241:109 (#0)",
        "source": "lr = find_link_ref(&mut (*rndr).refs, unsafe { std::slice::from_raw_parts(id.data, id.size as usize) });"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:244 ~ c2rust[26e7]::src::markdown::char_link)",
    "span": "src/markdown.rs:3036:1: 3346:2 (#0)",
    "pieces": [
      "src/markdown.rs:3036:1: 3040:4 (#0)",
      "src/markdown.rs:3346:1: 3346:2 (#0)"
    ],
    "sub_chunks": [
      5
    ],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn char_link(mut ob: *mut buf, mut rndr: *mut sd_markdown,\n                               mut data: *mut uint8_t, mut max_rewind: size_t,\n                               mut max_lookbehind: size_t, mut size: size_t)\n -> size_t {\n   <<chunk 5>>}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/markdown.rs:3095:5: 3192:2 (#0)",
        "pieces": [
          "src/markdown.rs:3095:5: 3192:2 (#0)"
        ],
        "num_lines": 144,
        "source": "i = i.wrapping_add(1);\n                while i < size &&\n                          _isspace(*data.offset(i as isize) as std::os::raw::c_int) !=\n                              0 {\n                    i = i.wrapping_add(1)\n                }\n                link_b = i;\n                /* looking for link end: ' \" ) */\n                while i < size {\n                    if *data.offset(i as isize) as std::os::raw::c_int == '\\\\' as i32\n                       {\n                        i =\n                            (i as\n                                 std::os::raw::c_ulong).wrapping_add(2 as std::os::raw::c_int\n                                                                 as\n                                                                 std::os::raw::c_ulong)\n                                as size_t as size_t\n                    } else {\n                        if *data.offset(i as isize) as std::os::raw::c_int ==\n                               ')' as i32 {\n                            break ;\n                        }\n                        if i >= 1 as std::os::raw::c_int as std::os::raw::c_ulong &&\n                               _isspace(*data.offset(i.wrapping_sub(1 as\n                                                                        std::os::raw::c_int\n                                                                        as\n                                                                        std::os::raw::c_ulong)\n                                                         as isize) as\n                                            std::os::raw::c_int) != 0 &&\n                               (*data.offset(i as isize) as std::os::raw::c_int ==\n                                    '\\'' as i32 ||\n                                    *data.offset(i as isize) as std::os::raw::c_int ==\n                                        '\\\"' as i32) {\n                            break ;\n                        }\n                        i = i.wrapping_add(1)\n                    }\n                }\n                if i >= size {\n                    current_block = 5149211417002599448;\n                } else {\n                    link_e = i;\n                    /* looking for title end if present */\n                    if *data.offset(i as isize) as std::os::raw::c_int == '\\'' as i32\n                           ||\n                           *data.offset(i as isize) as std::os::raw::c_int ==\n                               '\\\"' as i32 {\n                        qtype = *data.offset(i as isize) as std::os::raw::c_int;\n                        in_title = 1 as std::os::raw::c_int;\n                        i = i.wrapping_add(1);\n                        title_b = i;\n                        while i < size {\n                            if *data.offset(i as isize) as std::os::raw::c_int ==\n                                   '\\\\' as i32 {\n                                i =\n                                    (i as\n                                         std::os::raw::c_ulong).wrapping_add(2 as\n                                                                         std::os::raw::c_int\n                                                                         as\n                                                                         std::os::raw::c_ulong)\n                                        as size_t as size_t\n                            } else if *data.offset(i as isize) as std::os::raw::c_int\n                                          == qtype {\n                                in_title = 0 as std::os::raw::c_int;\n                                i = i.wrapping_add(1)\n                            } else {\n                                if *data.offset(i as isize) as std::os::raw::c_int ==\n                                       ')' as i32 && in_title == 0 {\n                                    break ;\n                                }\n                                i = i.wrapping_add(1)\n                            }\n                        }\n                        if i >= size {\n                            current_block = 5149211417002599448;\n                        } else {\n                            /* skipping whitespaces after title */\n                            title_e =\n                                i.wrapping_sub(1 as std::os::raw::c_int as\n                                                   std::os::raw::c_ulong);\n                            while title_e > title_b &&\n                                      _isspace(*data.offset(title_e as isize)\n                                                   as std::os::raw::c_int) != 0 {\n                                title_e = title_e.wrapping_sub(1)\n                            }\n                            /* checking for closing quote presence */\n                            if *data.offset(title_e as isize) as std::os::raw::c_int\n                                   != '\\'' as i32 &&\n                                   *data.offset(title_e as isize) as\n                                       std::os::raw::c_int != '\\\"' as i32 {\n                                title_e = 0 as std::os::raw::c_int as size_t;\n                                title_b = title_e;\n                                link_e = i\n                            }\n                            current_block = 13325891313334703151;\n                        }\n                    } else { current_block = 13325891313334703151; }\n                    match current_block {\n                        5149211417002599448 => { }\n                        _ => {\n                            /* remove whitespace at the end of the link */\n                            while link_e > link_b &&\n                                      _isspace(*data.offset(link_e.wrapping_sub(1\n                                                                                    as\n                                                                                    std::os::raw::c_int\n                                                                                    as\n                                                                                    std::os::raw::c_ulong)\n                                                                as isize) as\n                                                   std::os::raw::c_int) != 0 {\n                                link_e = link_e.wrapping_sub(1)\n                            }\n                            /* remove optional angle brackets around the link */\n                            if *data.offset(link_b as isize) as std::os::raw::c_int ==\n                                   '<' as i32 {\n                                link_b = link_b.wrapping_add(1)\n                            }\n                            if *data.offset(link_e.wrapping_sub(1 as\n                                                                    std::os::raw::c_int\n                                                                    as\n                                                                    std::os::raw::c_ulong)\n                                                as isize) as std::os::raw::c_int ==\n                                   '>' as i32 {\n                                link_e = link_e.wrapping_sub(1)\n                            }\n                            /* building escaped link and title */\n                            if link_e > link_b {\n                                link = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n                                bufput(link,\n                                       data.offset(link_b as isize) as\n                                           *const std::os::raw::c_void,\n                                       link_e.wrapping_sub(link_b));\n                            }\n                            if title_e > title_b {\n                                title = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n                                bufput(title,\n                                       data.offset(title_b as isize) as\n                                           *const std::os::raw::c_void,\n                                       title_e.wrapping_sub(title_b));\n                            }\n                            i = i.wrapping_add(1);\n                            current_block = 1930794479672247912;\n                        }\n                    }\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut rndr: *mut src::markdown::sd_markdown",
          "mut data: *mut u8",
          "mut size: u64",
          "mut current_block: u64",
          "mut i: u64",
          "mut link_b: u64",
          "mut link_e: u64",
          "mut title_b: u64",
          "mut title_e: u64",
          "mut link: *mut src::autolink::buf",
          "mut title: *mut src::autolink::buf",
          "mut in_title: i32",
          "mut qtype: i32"
        ],
        "live_out": [
          "mut rndr: *mut src::markdown::sd_markdown",
          "mut data: *mut u8",
          "mut size: u64",
          "mut current_block: u64",
          "mut i: u64",
          "mut link_b: u64",
          "mut link_e: u64",
          "mut title_b: u64",
          "mut title_e: u64",
          "mut link: *mut src::autolink::buf",
          "mut title: *mut src::autolink::buf",
          "mut in_title: i32",
          "mut qtype: i32",
          "mut i: u64",
          "mut link_b: u64",
          "mut link_e: u64"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/markdown.rs:3196:5: 3251:2 (#0)",
        "pieces": [
          "src/markdown.rs:3196:5: 3251:2 (#0)"
        ],
        "num_lines": 71,
        "source": "let mut id: buf =\n                    {\n                        let mut init =\n                            buf{data: 0 as *mut uint8_t,\n                                size: 0 as std::os::raw::c_int as size_t,\n                                asize: 0 as std::os::raw::c_int as size_t,\n                                unit: 0 as std::os::raw::c_int as size_t,};\n                        init\n                    };\n                let mut lr: *mut link_ref = 0 as *mut link_ref;\n                /* reference style link */\n                /* looking for the id */\n                i = i.wrapping_add(1);\n                link_b = i;\n                while i < size &&\n                          *data.offset(i as isize) as std::os::raw::c_int !=\n                              ']' as i32 {\n                    i = i.wrapping_add(1)\n                }\n                if i >= size {\n                    current_block = 5149211417002599448;\n                } else {\n                    link_e = i;\n                    /* finding the link_ref */\n                    if link_b == link_e {\n                        if text_has_nl != 0 {\n                            let mut b: *mut buf =\n                                rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n                            let mut j: size_t = 0;\n                            j = 1 as std::os::raw::c_int as size_t;\n                            while j < txt_e {\n                                if *data.offset(j as isize) as std::os::raw::c_int !=\n                                       '\\n' as i32 {\n                                    bufputc(b,\n                                            *data.offset(j as isize) as\n                                                std::os::raw::c_int);\n                                } else if *data.offset(j.wrapping_sub(1 as\n                                                                          std::os::raw::c_int\n                                                                          as\n                                                                          std::os::raw::c_ulong)\n                                                           as isize) as\n                                              std::os::raw::c_int != ' ' as i32 {\n                                    bufputc(b, ' ' as i32);\n                                }\n                                j = j.wrapping_add(1)\n                            }\n                            id.data = (*b).data;\n                            id.size = (*b).size\n                        } else {\n                            id.data = data.offset(1 as std::os::raw::c_int as isize);\n                            id.size =\n                                txt_e.wrapping_sub(1 as std::os::raw::c_int as\n                                                       std::os::raw::c_ulong)\n                        }\n                    } else {\n                        id.data = data.offset(link_b as isize);\n                        id.size = link_e.wrapping_sub(link_b)\n                    }\n                    lr =\n                        find_link_ref((*rndr).refs.as_mut_ptr(), id.data,\n                                      id.size);\n                    if lr.is_null() {\n                        current_block = 5149211417002599448;\n                    } else {\n                        /* keeping link and title from link_ref */\n                        link = (*lr).link;\n                        title = (*lr).title;\n                        i = i.wrapping_add(1);\n                        current_block = 1930794479672247912;\n                    }\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut rndr: *mut src::markdown::sd_markdown",
          "mut data: *mut u8",
          "mut size: u64",
          "mut current_block: u64",
          "mut i: u64",
          "mut txt_e: u64",
          "mut link_b: u64",
          "mut link_e: u64",
          "mut link: *mut src::autolink::buf",
          "mut title: *mut src::autolink::buf",
          "mut text_has_nl: i32",
          "mut txt_e: u64"
        ],
        "live_out": [
          "mut rndr: *mut src::markdown::sd_markdown",
          "mut data: *mut u8",
          "mut size: u64",
          "mut current_block: u64",
          "mut i: u64",
          "mut txt_e: u64",
          "mut link_b: u64",
          "mut link_e: u64",
          "mut link: *mut src::autolink::buf",
          "mut title: *mut src::autolink::buf",
          "mut text_has_nl: i32",
          "mut txt_e: u64",
          "mut id: src::autolink::buf",
          "mut lr: *mut src::markdown::link_ref"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/markdown.rs:3256:5: 3294:2 (#0)",
        "pieces": [
          "src/markdown.rs:3256:5: 3294:2 (#0)"
        ],
        "num_lines": 53,
        "source": "let mut id_0: buf =\n                    {\n                        let mut init =\n                            buf{data: 0 as *mut uint8_t,\n                                size: 0 as std::os::raw::c_int as size_t,\n                                asize: 0 as std::os::raw::c_int as size_t,\n                                unit: 0 as std::os::raw::c_int as size_t,};\n                        init\n                    };\n                let mut lr_0: *mut link_ref = 0 as *mut link_ref;\n                /* crafting the id */\n                if text_has_nl != 0 {\n                    let mut b_0: *mut buf =\n                        rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n                    let mut j_0: size_t = 0;\n                    j_0 = 1 as std::os::raw::c_int as size_t;\n                    while j_0 < txt_e {\n                        if *data.offset(j_0 as isize) as std::os::raw::c_int !=\n                               '\\n' as i32 {\n                            bufputc(b_0,\n                                    *data.offset(j_0 as isize) as\n                                        std::os::raw::c_int);\n                        } else if *data.offset(j_0.wrapping_sub(1 as\n                                                                    std::os::raw::c_int\n                                                                    as\n                                                                    std::os::raw::c_ulong)\n                                                   as isize) as std::os::raw::c_int !=\n                                      ' ' as i32 {\n                            bufputc(b_0, ' ' as i32);\n                        }\n                        j_0 = j_0.wrapping_add(1)\n                    }\n                    id_0.data = (*b_0).data;\n                    id_0.size = (*b_0).size\n                } else {\n                    id_0.data = data.offset(1 as std::os::raw::c_int as isize);\n                    id_0.size =\n                        txt_e.wrapping_sub(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n                }\n                /* finding the link_ref */\n                lr_0 =\n                    find_link_ref((*rndr).refs.as_mut_ptr(), id_0.data,\n                                  id_0.size);\n                if lr_0.is_null() {\n                    current_block = 5149211417002599448;\n                } else {\n                    /* keeping link and title from link_ref */\n                    link = (*lr_0).link;\n                    title = (*lr_0).title;\n                    /* rewinding the whitespace */\n                    i = txt_e.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong);\n                    current_block = 1930794479672247912;\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut rndr: *mut src::markdown::sd_markdown",
          "mut data: *mut u8",
          "mut size: u64",
          "mut current_block: u64",
          "mut i: u64",
          "mut txt_e: u64",
          "mut link: *mut src::autolink::buf",
          "mut title: *mut src::autolink::buf",
          "mut text_has_nl: i32",
          "mut txt_e: u64"
        ],
        "live_out": [
          "mut rndr: *mut src::markdown::sd_markdown",
          "mut data: *mut u8",
          "mut size: u64",
          "mut current_block: u64",
          "mut i: u64",
          "mut txt_e: u64",
          "mut link: *mut src::autolink::buf",
          "mut title: *mut src::autolink::buf",
          "mut text_has_nl: i32",
          "mut txt_e: u64",
          "mut id_0: src::autolink::buf",
          "mut lr_0: *mut src::markdown::link_ref"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/markdown.rs:3085:5: 3336:3 (#0)",
        "pieces": [
          "src/markdown.rs:3085:5: 3095:4 (#0)",
          "src/markdown.rs:3194:1: 3196:4 (#0)",
          "src/markdown.rs:3253:1: 3256:4 (#0)",
          "src/markdown.rs:3296:1: 3336:3 (#0)"
        ],
        "num_lines": 84,
        "source": "txt_e = i;\n            i = i.wrapping_add(1);\n            /* skip any amount of whitespace or newline */\n\t/* (this is much more laxist than original markdown syntax) */\n            while i < size &&\n                      _isspace(*data.offset(i as isize) as std::os::raw::c_int) != 0 {\n                i = i.wrapping_add(1)\n            }\n            /* inline style link */\n            if i < size &&\n                   *data.offset(i as isize) as std::os::raw::c_int == '(' as i32 {\n                /* skipping initial whitespace */\n               <<chunk 0>>            } else if i < size &&\n                          *data.offset(i as isize) as std::os::raw::c_int ==\n                              '[' as i32 {\n               <<chunk 1>>            } else {\n                /* shortcut reference style link */\n               <<chunk 2>>            }\n            match current_block {\n                5149211417002599448 => { }\n                _ => {\n                    /* building content: img alt is escaped, link content is parsed */\n                    if txt_e > 1 as std::os::raw::c_int as std::os::raw::c_ulong {\n                        content = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n                        if is_img != 0 {\n                            bufput(content,\n                                   data.offset(1 as std::os::raw::c_int as isize) as\n                                       *const std::os::raw::c_void,\n                                   txt_e.wrapping_sub(1 as std::os::raw::c_int as\n                                                          std::os::raw::c_ulong));\n                        } else {\n                            /* disable autolinking when parsing inline the\n\t\t\t * content of a link */\n                            (*rndr).in_link_body = 1 as std::os::raw::c_int;\n                            parse_inline(content, rndr,\n                                         data.offset(1 as std::os::raw::c_int as\n                                                         isize),\n                                         txt_e.wrapping_sub(1 as std::os::raw::c_int\n                                                                as\n                                                                std::os::raw::c_ulong));\n                            (*rndr).in_link_body = 0 as std::os::raw::c_int\n                        }\n                    }\n                    if !link.is_null() {\n                        u_link = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n                        unscape_text(u_link, link);\n                        /* calling the relevant rendering function */\n                        if is_img != 0 {\n                            if (*ob).size != 0 &&\n                                   *(*ob).data.offset((*ob).size.wrapping_sub(1\n                                                                                  as\n                                                                                  std::os::raw::c_int\n                                                                                  as\n                                                                                  std::os::raw::c_ulong)\n                                                          as isize) as\n                                       std::os::raw::c_int == '!' as i32 {\n                                (*ob).size =\n                                    ((*ob).size as\n                                         std::os::raw::c_ulong).wrapping_sub(1 as\n                                                                         std::os::raw::c_int\n                                                                         as\n                                                                         std::os::raw::c_ulong)\n                                        as size_t as size_t\n                            }\n                            ret =\n                                (*rndr).cb.image.expect(\"non-null function pointer\")(ob,\n                                                                                     u_link,\n                                                                                     title,\n                                                                                     content,\n                                                                                     (*rndr).opaque)\n                        } else {\n                            ret =\n                                (*rndr).cb.link.expect(\"non-null function pointer\")(ob,\n                                                                                    u_link,\n                                                                                    title,\n                                                                                    content,\n                                                                                    (*rndr).opaque)\n                        }\n                    }\n                }\n            }",
        "sub_chunks": [
          0,
          1,
          2
        ],
        "live_in": [
          "mut ob: *mut src::autolink::buf",
          "mut rndr: *mut src::markdown::sd_markdown",
          "mut data: *mut u8",
          "mut size: u64",
          "mut current_block: u64",
          "mut is_img: i32",
          "mut i: u64",
          "mut txt_e: u64",
          "mut link_b: u64",
          "mut link_e: u64",
          "mut title_b: u64",
          "mut title_e: u64",
          "mut content: *mut src::autolink::buf",
          "mut link: *mut src::autolink::buf",
          "mut title: *mut src::autolink::buf",
          "mut u_link: *mut src::autolink::buf",
          "mut text_has_nl: i32",
          "mut ret: i32",
          "mut in_title: i32",
          "mut qtype: i32"
        ],
        "live_out": [
          "mut ob: *mut src::autolink::buf",
          "mut rndr: *mut src::markdown::sd_markdown",
          "mut data: *mut u8",
          "mut size: u64",
          "mut current_block: u64",
          "mut is_img: i32",
          "mut i: u64",
          "mut txt_e: u64",
          "mut link_b: u64",
          "mut link_e: u64",
          "mut title_b: u64",
          "mut title_e: u64",
          "mut content: *mut src::autolink::buf",
          "mut link: *mut src::autolink::buf",
          "mut title: *mut src::autolink::buf",
          "mut u_link: *mut src::autolink::buf",
          "mut text_has_nl: i32",
          "mut ret: i32",
          "mut in_title: i32",
          "mut qtype: i32",
          "mut txt_e: u64"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/markdown.rs:3066:9: 3339:2 (#0)",
        "pieces": [
          "src/markdown.rs:3066:9: 3085:4 (#0)",
          "src/markdown.rs:3338:1: 3339:2 (#0)"
        ],
        "num_lines": 21,
        "source": "level = 1 as std::os::raw::c_int;\n        while i < size {\n            if *data.offset(i as isize) as std::os::raw::c_int == '\\n' as i32 {\n                text_has_nl = 1 as std::os::raw::c_int\n            } else if !(*data.offset(i.wrapping_sub(1 as std::os::raw::c_int as\n                                                        std::os::raw::c_ulong) as\n                                         isize) as std::os::raw::c_int == '\\\\' as i32)\n             {\n                if *data.offset(i as isize) as std::os::raw::c_int == '[' as i32 {\n                    level += 1\n                } else if *data.offset(i as isize) as std::os::raw::c_int ==\n                              ']' as i32 {\n                    level -= 1;\n                    if level <= 0 as std::os::raw::c_int { break ; }\n                }\n            }\n            i = i.wrapping_add(1)\n        }\n        if !(i >= size) {\n           <<chunk 3>>        }",
        "sub_chunks": [
          3
        ],
        "live_in": [
          "mut ob: *mut src::autolink::buf",
          "mut rndr: *mut src::markdown::sd_markdown",
          "mut data: *mut u8",
          "mut size: u64",
          "mut current_block: u64",
          "mut is_img: i32",
          "mut level: i32",
          "mut i: u64",
          "mut txt_e: u64",
          "mut link_b: u64",
          "mut link_e: u64",
          "mut title_b: u64",
          "mut title_e: u64",
          "mut content: *mut src::autolink::buf",
          "mut link: *mut src::autolink::buf",
          "mut title: *mut src::autolink::buf",
          "mut u_link: *mut src::autolink::buf",
          "mut text_has_nl: i32",
          "mut ret: i32",
          "mut in_title: i32",
          "mut qtype: i32"
        ],
        "live_out": [
          "mut ob: *mut src::autolink::buf",
          "mut rndr: *mut src::markdown::sd_markdown",
          "mut data: *mut u8",
          "mut size: u64",
          "mut current_block: u64",
          "mut is_img: i32",
          "mut level: i32",
          "mut i: u64",
          "mut txt_e: u64",
          "mut link_b: u64",
          "mut link_e: u64",
          "mut title_b: u64",
          "mut title_e: u64",
          "mut content: *mut src::autolink::buf",
          "mut link: *mut src::autolink::buf",
          "mut title: *mut src::autolink::buf",
          "mut u_link: *mut src::autolink::buf",
          "mut text_has_nl: i32",
          "mut ret: i32",
          "mut in_title: i32",
          "mut qtype: i32",
          "mut level: i32",
          "data_slice: &[u8]",
          "mut txt_e: u64"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/markdown.rs:3040:5: 3345:89 (#0)",
        "pieces": [
          "src/markdown.rs:3040:5: 3066:8 (#0)",
          "src/markdown.rs:3341:1: 3345:89 (#0)"
        ],
        "num_lines": 32,
        "source": "let mut current_block: u64;\n    let mut is_img: std::os::raw::c_int =\n        (max_rewind != 0 &&\n             *data.offset(-(1 as std::os::raw::c_int) as isize) as std::os::raw::c_int ==\n                 '!' as i32) as std::os::raw::c_int;\n    let mut level: std::os::raw::c_int = 0;\n    let mut i: size_t = 1 as std::os::raw::c_int as size_t;\n    let mut txt_e: size_t = 0;\n    let mut link_b: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut link_e: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut title_b: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut title_e: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut content: *mut buf = 0 as *mut buf;\n    let mut link: *mut buf = 0 as *mut buf;\n    let mut title: *mut buf = 0 as *mut buf;\n    let mut u_link: *mut buf = 0 as *mut buf;\n    let mut org_work_size: size_t =\n        (*rndr).work_bufs[1 as std::os::raw::c_int as usize].size;\n    let mut text_has_nl: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    let mut in_title: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    let mut qtype: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    /* checking whether the correct renderer exists */\n    if !(is_img != 0 && (*rndr).cb.image.is_none() ||\n             is_img == 0 && (*rndr).cb.link.is_none()) {\n        /* looking for the matching closing bracket */\n       <<chunk 4>>    }\n    /* cleanup */\n    (*rndr).work_bufs[1 as std::os::raw::c_int as usize].size =\n        org_work_size as std::os::raw::c_int as size_t;\n    return if ret != 0 { i } else { 0 as std::os::raw::c_int as std::os::raw::c_ulong };",
        "sub_chunks": [
          4
        ],
        "live_in": [
          "mut ob: *mut src::autolink::buf",
          "mut rndr: *mut src::markdown::sd_markdown",
          "mut data: *mut u8",
          "mut max_rewind: u64",
          "mut size: u64"
        ],
        "live_out": [
          "mut ob: *mut src::autolink::buf",
          "mut rndr: *mut src::markdown::sd_markdown",
          "mut data: *mut u8",
          "mut max_rewind: u64",
          "mut size: u64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:251 ~ c2rust[26e7]::src::markdown::is_headerline)",
    "span": "src/markdown.rs:3570:1: 3606:2 (#0)",
    "pieces": [
      "src/markdown.rs:3570:1: 3606:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 37,
    "source": "unsafe extern \"C\" fn is_headerline(mut data: *mut uint8_t, mut size: size_t)\n -> std::os::raw::c_int {\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    /* test of level 1 header */\n    if *data.offset(i as isize) as std::os::raw::c_int == '=' as i32 {\n        i = 1 as std::os::raw::c_int as size_t;\n        while i < size &&\n                  *data.offset(i as isize) as std::os::raw::c_int == '=' as i32 {\n            i = i.wrapping_add(1)\n        }\n        while i < size &&\n                  *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n            i = i.wrapping_add(1)\n        }\n        return if i >= size ||\n                      *data.offset(i as isize) as std::os::raw::c_int == '\\n' as i32 {\n                   1 as std::os::raw::c_int\n               } else { 0 as std::os::raw::c_int }\n    }\n    /* test of level 2 header */\n    if *data.offset(i as isize) as std::os::raw::c_int == '-' as i32 {\n        i = 1 as std::os::raw::c_int as size_t;\n        while i < size &&\n                  *data.offset(i as isize) as std::os::raw::c_int == '-' as i32 {\n            i = i.wrapping_add(1)\n        }\n        while i < size &&\n                  *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n            i = i.wrapping_add(1)\n        }\n        return if i >= size ||\n                      *data.offset(i as isize) as std::os::raw::c_int == '\\n' as i32 {\n                   2 as std::os::raw::c_int\n               } else { 0 as std::os::raw::c_int }\n    }\n    return 0 as std::os::raw::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:279 ~ c2rust[26e7]::src::markdown::is_next_headerline)",
        "span": "src/markdown.rs:3615:5: 3615:73 (#0)",
        "source": "return is_headerline(data.offset(i as isize), size.wrapping_sub(i));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:233 ~ c2rust[26e7]::src::markdown::char_linebreak)",
    "span": "src/markdown.rs:2603:1: 2628:2 (#0)",
    "pieces": [
      "src/markdown.rs:2603:1: 2628:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 26,
    "source": "unsafe extern \"C\" fn char_linebreak(mut ob: *mut buf,\n                                    mut rndr: *mut sd_markdown,\n                                    mut data: *mut uint8_t,\n                                    mut max_rewind: size_t,\n                                    mut max_lookbehind: size_t,\n                                    mut size: size_t) -> size_t {\n    if max_rewind < 2 as std::os::raw::c_int as std::os::raw::c_ulong ||\n           *data.offset(-(1 as std::os::raw::c_int) as isize) as std::os::raw::c_int !=\n               ' ' as i32 ||\n           *data.offset(-(2 as std::os::raw::c_int) as isize) as std::os::raw::c_int !=\n               ' ' as i32 {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    /* removing the last space from ob and rendering */\n    while (*ob).size != 0 &&\n              *(*ob).data.offset((*ob).size.wrapping_sub(1 as std::os::raw::c_int as\n                                                             std::os::raw::c_ulong) as\n                                     isize) as std::os::raw::c_int == ' ' as i32 {\n        (*ob).size = (*ob).size.wrapping_sub(1)\n    }\n    return if (*rndr).cb.linebreak.expect(\"non-null function pointer\")(ob,\n                                                                       (*rndr).opaque)\n                  != 0 {\n               1 as std::os::raw::c_int\n           } else { 0 as std::os::raw::c_int } as size_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:275 ~ c2rust[26e7]::src::markdown::sd_markdown_new)",
    "span": "src/markdown.rs:5183:1: 5259:2 (#0)",
    "pieces": [
      "src/markdown.rs:5183:1: 5259:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 79,
    "source": "pub unsafe extern \"C\" fn sd_markdown_new(mut extensions: std::os::raw::c_uint,\n                                         mut max_nesting: size_t,\n                                         mut max_table_cols: size_t,\n                                         mut callbacks: *const sd_callbacks,\n                                         mut opaque: *mut std::os::raw::c_void)\n -> *mut sd_markdown {\n    let mut md: *mut sd_markdown = 0 as *mut sd_markdown;\n    md =\n        malloc(::std::mem::size_of::<sd_markdown>() as std::os::raw::c_ulong) as\n            *mut sd_markdown;\n    if md.is_null() { return 0 as *mut sd_markdown }\n    memcpy(&mut (*md).cb as *mut sd_callbacks as *mut std::os::raw::c_void,\n           callbacks as *const std::os::raw::c_void,\n           ::std::mem::size_of::<sd_callbacks>() as std::os::raw::c_ulong);\n    stack_init(&mut *(*md).work_bufs.as_mut_ptr().offset(0 as std::os::raw::c_int as\n                                                             isize),\n               4 as std::os::raw::c_int as size_t);\n    stack_init(&mut *(*md).work_bufs.as_mut_ptr().offset(1 as std::os::raw::c_int as\n                                                             isize),\n               8 as std::os::raw::c_int as size_t);\n    memset((*md).active_char.as_mut_ptr() as *mut std::os::raw::c_void,\n           0 as std::os::raw::c_int, 256 as std::os::raw::c_int as std::os::raw::c_ulong);\n    if (*md).cb.emphasis.is_some() || (*md).cb.double_emphasis.is_some() ||\n           (*md).cb.triple_emphasis.is_some() {\n        (*md).active_char['*' as i32 as usize] =\n            MD_CHAR_EMPHASIS as std::os::raw::c_int as uint8_t;\n        (*md).active_char['_' as i32 as usize] =\n            MD_CHAR_EMPHASIS as std::os::raw::c_int as uint8_t;\n        (*md).active_char['>' as i32 as usize] =\n            MD_CHAR_EMPHASIS as std::os::raw::c_int as uint8_t;\n        if extensions & MKDEXT_STRIKETHROUGH as std::os::raw::c_int as std::os::raw::c_uint !=\n               0 {\n            (*md).active_char['~' as i32 as usize] =\n                MD_CHAR_EMPHASIS as std::os::raw::c_int as uint8_t\n        }\n    }\n    if (*md).cb.codespan.is_some() {\n        (*md).active_char['`' as i32 as usize] =\n            MD_CHAR_CODESPAN as std::os::raw::c_int as uint8_t\n    }\n    if (*md).cb.linebreak.is_some() {\n        (*md).active_char['\\n' as i32 as usize] =\n            MD_CHAR_LINEBREAK as std::os::raw::c_int as uint8_t\n    }\n    if (*md).cb.image.is_some() || (*md).cb.link.is_some() {\n        (*md).active_char['[' as i32 as usize] =\n            MD_CHAR_LINK as std::os::raw::c_int as uint8_t\n    }\n    (*md).active_char['<' as i32 as usize] =\n        MD_CHAR_LANGLE as std::os::raw::c_int as uint8_t;\n    (*md).active_char['\\\\' as i32 as usize] =\n        MD_CHAR_ESCAPE as std::os::raw::c_int as uint8_t;\n    (*md).active_char['&' as i32 as usize] =\n        MD_CHAR_ENTITITY as std::os::raw::c_int as uint8_t;\n    if extensions & MKDEXT_AUTOLINK as std::os::raw::c_int as std::os::raw::c_uint != 0 {\n        if extensions &\n               MKDEXT_NO_EMAIL_AUTOLINK as std::os::raw::c_int as std::os::raw::c_uint == 0 {\n            (*md).active_char['@' as i32 as usize] =\n                MD_CHAR_AUTOLINK_EMAIL as std::os::raw::c_int as uint8_t\n        }\n        (*md).active_char[':' as i32 as usize] =\n            MD_CHAR_AUTOLINK_URL as std::os::raw::c_int as uint8_t;\n        (*md).active_char['w' as i32 as usize] =\n            MD_CHAR_AUTOLINK_WWW as std::os::raw::c_int as uint8_t;\n        (*md).active_char['/' as i32 as usize] =\n            MD_CHAR_AUTOLINK_SUBREDDIT_OR_USERNAME as std::os::raw::c_int as uint8_t\n    }\n    if extensions & MKDEXT_SUPERSCRIPT as std::os::raw::c_int as std::os::raw::c_uint != 0 {\n        (*md).active_char['^' as i32 as usize] =\n            MD_CHAR_SUPERSCRIPT as std::os::raw::c_int as uint8_t\n    }\n    /* Extension data */\n    (*md).ext_flags = extensions;\n    (*md).opaque = opaque;\n    (*md).max_nesting = max_nesting;\n    (*md).max_table_cols = max_table_cols;\n    (*md).in_link_body = 0 as std::os::raw::c_int;\n    return md;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/markdown.rs:316:1: 316:49 (#0)",
        "source": "pub const MD_CHAR_EMPHASIS: markdown_char_t = 1;"
      },
      {
        "span": "src/markdown.rs:309:1: 309:55 (#0)",
        "source": "pub const MD_CHAR_AUTOLINK_EMAIL: markdown_char_t = 9;"
      },
      {
        "span": "src/markdown.rs:308:1: 308:53 (#0)",
        "source": "pub const MD_CHAR_AUTOLINK_URL: markdown_char_t = 8;"
      },
      {
        "span": "src/markdown.rs:307:1: 307:54 (#0)",
        "source": "pub const MD_CHAR_AUTOLINK_WWW: markdown_char_t = 10;"
      },
      {
        "span": "src/markdown.rs:306:1: 306:72 (#0)",
        "source": "pub const MD_CHAR_AUTOLINK_SUBREDDIT_OR_USERNAME: markdown_char_t = 11;"
      },
      {
        "span": "src/markdown.rs:305:1: 305:53 (#0)",
        "source": "pub const MD_CHAR_SUPERSCRIPT: markdown_char_t = 12;"
      },
      {
        "span": "src/markdown.rs:315:1: 315:49 (#0)",
        "source": "pub const MD_CHAR_CODESPAN: markdown_char_t = 2;"
      },
      {
        "span": "src/markdown.rs:314:1: 314:50 (#0)",
        "source": "pub const MD_CHAR_LINEBREAK: markdown_char_t = 3;"
      },
      {
        "span": "src/markdown.rs:313:1: 313:45 (#0)",
        "source": "pub const MD_CHAR_LINK: markdown_char_t = 4;"
      },
      {
        "span": "src/markdown.rs:311:1: 311:47 (#0)",
        "source": "pub const MD_CHAR_ESCAPE: markdown_char_t = 6;"
      },
      {
        "span": "src/markdown.rs:310:1: 310:49 (#0)",
        "source": "pub const MD_CHAR_ENTITITY: markdown_char_t = 7;"
      },
      {
        "span": "src/markdown.rs:312:1: 312:47 (#0)",
        "source": "pub const MD_CHAR_LANGLE: markdown_char_t = 5;"
      }
    ],
    "imports": [
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:243 ~ c2rust[26e7]::src::markdown::char_autolink_url)",
    "span": "src/markdown.rs:3009:1: 3034:2 (#0)",
    "pieces": [
      "src/markdown.rs:3009:1: 3034:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 25,
    "source": "unsafe extern \"C\" fn char_autolink_url(mut ob: *mut buf,\n                                       mut rndr: *mut sd_markdown,\n                                       mut data: *mut uint8_t,\n                                       mut max_rewind: size_t,\n                                       mut max_lookbehind: size_t,\n                                       mut size: size_t) -> size_t {\n    let mut link: *mut buf = 0 as *mut buf;\n    let mut link_len: size_t = 0;\n    let mut rewind: size_t = 0;\n    if (*rndr).cb.autolink.is_none() || (*rndr).in_link_body != 0 {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    link = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n    link_len =\n        sd_autolink__url(&mut rewind, link, data, max_rewind, size,\n                         0 as std::os::raw::c_int as std::os::raw::c_uint);\n    if link_len > 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        buftruncate(ob, (*ob).size.wrapping_sub(rewind));\n        (*rndr).cb.autolink.expect(\"non-null function pointer\")(ob, link,\n                                                                MKDA_NORMAL,\n                                                                (*rndr).opaque);\n    }\n    rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n    return link_len;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/markdown.rs:165:1: 165:41 (#0)",
        "source": "pub const MKDA_NORMAL: mkd_autolink = 1;"
      }
    ],
    "imports": [
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:32 ~ c2rust[26e7]::src::autolink::sd_autolink_issafe)",
    "span": "src/autolink.rs:78:1: 117:2 (#0)",
    "pieces": [
      "src/autolink.rs:78:1: 117:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 40,
    "source": "pub unsafe extern \"C\" fn sd_autolink_issafe(mut link: *const uint8_t,\n                                            mut link_len: size_t)\n -> std::os::raw::c_int {\n    static mut valid_uris_count: size_t = 14 as std::os::raw::c_int as size_t;\n    static mut valid_uris: [*const std::os::raw::c_char; 14] =\n        [b\"http://\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"https://\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"ftp://\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"mailto://\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"/\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"git://\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"steam://\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"irc://\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"news://\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"mumble://\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"ssh://\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"ircs://\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"ts3server://\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"#\\x00\" as *const u8 as *const std::os::raw::c_char];\n    let mut i: size_t = 0;\n    i = 0 as std::os::raw::c_int as size_t;\n    while i < valid_uris_count {\n        let mut len: size_t = strlen(valid_uris[i as usize]);\n        if link_len > len &&\n               strncasecmp(link as *mut std::os::raw::c_char, valid_uris[i as usize],\n                           len) == 0 as std::os::raw::c_int &&\n               (*(*__ctype_b_loc()).offset(*link.offset(len as isize) as\n                                               std::os::raw::c_int as isize) as\n                    std::os::raw::c_int &\n                    _ISalnum as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int\n                    != 0 ||\n                    *link.offset(len as isize) as std::os::raw::c_int == '#' as i32 ||\n                    *link.offset(len as isize) as std::os::raw::c_int == '/' as i32 ||\n                    *link.offset(len as isize) as std::os::raw::c_int == '?' as i32) {\n            return 1 as std::os::raw::c_int\n        }\n        i = i.wrapping_add(1)\n    }\n    return 0 as std::os::raw::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/autolink.rs:19:1: 19:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:265 ~ c2rust[26e7]::src::markdown::parse_atxheader)",
    "span": "src/markdown.rs:4352:1: 4397:2 (#0)",
    "pieces": [
      "src/markdown.rs:4352:1: 4397:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 46,
    "source": "unsafe extern \"C\" fn parse_atxheader(mut ob: *mut buf,\n                                     mut rndr: *mut sd_markdown,\n                                     mut data: *mut uint8_t, mut size: size_t)\n -> size_t {\n    let mut level: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut i: size_t = 0;\n    let mut end: size_t = 0;\n    let mut skip: size_t = 0;\n    while level < size && level < 6 as std::os::raw::c_int as std::os::raw::c_ulong &&\n              *data.offset(level as isize) as std::os::raw::c_int == '#' as i32 {\n        level = level.wrapping_add(1)\n    }\n    i = level;\n    while i < size && *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1)\n    }\n    end = i;\n    while end < size &&\n              *data.offset(end as isize) as std::os::raw::c_int != '\\n' as i32 {\n        end = end.wrapping_add(1)\n    }\n    skip = end;\n    while end != 0 &&\n              *data.offset(end.wrapping_sub(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n                               as isize) as std::os::raw::c_int == '#' as i32 {\n        end = end.wrapping_sub(1)\n    }\n    while end != 0 &&\n              *data.offset(end.wrapping_sub(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n                               as isize) as std::os::raw::c_int == ' ' as i32 {\n        end = end.wrapping_sub(1)\n    }\n    if end > i {\n        let mut work: *mut buf = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n        parse_inline(work, rndr, data.offset(i as isize),\n                     end.wrapping_sub(i));\n        if (*rndr).cb.header.is_some() {\n            (*rndr).cb.header.expect(\"non-null function pointer\")(ob, work,\n                                                                  level as\n                                                                      std::os::raw::c_int,\n                                                                  (*rndr).opaque);\n        }\n        rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n    }\n    return skip;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:281 ~ c2rust[26e7]::src::markdown::sd_version)",
    "span": "src/markdown.rs:5385:1: 5387:2 (#0)",
    "pieces": [
      "src/markdown.rs:5385:1: 5387:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn sd_version(mut ver_major: *mut std::os::raw::c_int,\n                                    mut ver_minor: *mut std::os::raw::c_int,\n                                    mut ver_revision: *mut std::os::raw::c_int) {\n    *ver_major = 1 as std::os::raw::c_int;\n    *ver_minor = 16 as std::os::raw::c_int;\n    *ver_revision = 0 as std::os::raw::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:252 ~ c2rust[26e7]::src::markdown::is_next_headerline)",
    "span": "src/markdown.rs:3607:1: 3616:2 (#0)",
    "pieces": [
      "src/markdown.rs:3607:1: 3616:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "unsafe extern \"C\" fn is_next_headerline(mut data: *mut uint8_t,\n                                        mut size: size_t) -> std::os::raw::c_int {\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    while i < size && *data.offset(i as isize) as std::os::raw::c_int != '\\n' as i32 {\n        i = i.wrapping_add(1)\n    }\n    i = i.wrapping_add(1);\n    if i >= size { return 0 as std::os::raw::c_int }\n    return is_headerline(data.offset(i as isize), size.wrapping_sub(i));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:42 ~ c2rust[26e7]::src::autolink::sd_autolink__subreddit)",
    "span": "src/autolink.rs:489:1: 631:2 (#0)",
    "pieces": [
      "src/autolink.rs:489:1: 631:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 143,
    "source": "pub unsafe extern \"C\" fn sd_autolink__subreddit(mut rewind_p: *mut size_t,\n                                                mut link: *mut buf,\n                                                mut data: *mut uint8_t,\n                                                mut max_rewind: size_t,\n                                                mut max_lookbehind: size_t,\n                                                mut size: size_t,\n                                                mut no_slash:\n                                                    *mut std::os::raw::c_int)\n -> size_t {\n    /* *\n\t * This is meant to handle both r/foo and /r/foo style subreddit references.\n\t * In a valid /?r/ link, `*data` will always point to the '/' after the first 'r'.\n\t * In pseudo-regex, this matches something like:\n\t *\n\t * `(/|(?<=\\b))r/(all-)?%subreddit%([-+]%subreddit%)*(/[\\w\\-/]*)?`\n\t * where %subreddit% == `((t:)?\\w{2,24}|reddit\\.com)`\n\t */\n    let mut link_end: size_t = 0;\n    let mut rewind: size_t = 0;\n    let mut is_allminus: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    rewind =\n        check_reddit_autolink_prefix(data, max_rewind, max_lookbehind, size,\n                                     'r' as i32 as std::os::raw::c_char) as size_t;\n    if rewind == 0 { return 0 as std::os::raw::c_int as size_t }\n    /* offset to the \"meat\" of the link */\n    link_end = strlen(b\"/\\x00\" as *const u8 as *const std::os::raw::c_char);\n    if size >= link_end.wrapping_add(4 as std::os::raw::c_int as std::os::raw::c_ulong) &&\n           strncasecmp((data as *mut std::os::raw::c_char).offset(link_end as isize),\n                       b\"all-\\x00\" as *const u8 as *const std::os::raw::c_char,\n                       4 as std::os::raw::c_int as std::os::raw::c_ulong) == 0 as std::os::raw::c_int\n       {\n        is_allminus = 1 as std::os::raw::c_int\n    }\n    loop  {\n        let mut start: size_t = link_end;\n        let mut max_length: std::os::raw::c_int = 24 as std::os::raw::c_int;\n        /* If we are linking to a multireddit, continue */\n        if size >= link_end.wrapping_add(10 as std::os::raw::c_int as std::os::raw::c_ulong)\n               &&\n               strncasecmp((data as\n                                *mut std::os::raw::c_char).offset(link_end as isize),\n                           b\"reddit.com\\x00\" as *const u8 as\n                               *const std::os::raw::c_char,\n                           10 as std::os::raw::c_int as std::os::raw::c_ulong) ==\n                   0 as std::os::raw::c_int {\n            link_end =\n                (link_end as\n                     std::os::raw::c_ulong).wrapping_add(10 as std::os::raw::c_int as\n                                                     std::os::raw::c_ulong) as size_t\n                    as size_t;\n            /* special case: /r/reddit.com (only subreddit containing '.'). */\n            /* Make sure there are no trailing characters (don't do\n\t\t\t * any autolinking for /r/reddit.commission) */\n            max_length = 10 as std::os::raw::c_int\n        } else {\n            /* If not a special case, verify it begins with (t:)?[A-Za-z0-9] */\n            /* support autolinking to timereddits, /r/t:when (1 April 2012) */\n            if size > link_end.wrapping_add(2 as std::os::raw::c_int as std::os::raw::c_ulong)\n                   &&\n                   strncasecmp((data as\n                                    *mut std::os::raw::c_char).offset(link_end as\n                                                                  isize),\n                               b\"t:\\x00\" as *const u8 as *const std::os::raw::c_char,\n                               2 as std::os::raw::c_int as std::os::raw::c_ulong) ==\n                       0 as std::os::raw::c_int {\n                link_end =\n                    (link_end as\n                         std::os::raw::c_ulong).wrapping_add(2 as std::os::raw::c_int as\n                                                         std::os::raw::c_ulong) as\n                        size_t as size_t\n            } /* Jump over the 't:' */\n            if *(*__ctype_b_loc()).offset(*data.offset(link_end as isize) as\n                                              std::os::raw::c_int as isize) as\n                   std::os::raw::c_int &\n                   _ISalnum as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int ==\n                   0 {\n                return 0 as std::os::raw::c_int as size_t\n            }\n            link_end =\n                (link_end as\n                     std::os::raw::c_ulong).wrapping_add(1 as std::os::raw::c_int as\n                                                     std::os::raw::c_ulong) as size_t\n                    as size_t\n        }\n        while link_end < size &&\n                  (*(*__ctype_b_loc()).offset(*data.offset(link_end as isize)\n                                                  as std::os::raw::c_int as isize) as\n                       std::os::raw::c_int &\n                       _ISalnum as std::os::raw::c_int as std::os::raw::c_ushort as\n                           std::os::raw::c_int != 0 ||\n                       *data.offset(link_end as isize) as std::os::raw::c_int ==\n                           '_' as i32)\n              /* the first character of a subreddit name must be a letter or digit */\n              /* consume valid characters ([A-Za-z0-9_]) until we run out */\n              {\n            link_end = link_end.wrapping_add(1)\n        }\n        if link_end.wrapping_sub(start) < 2 as std::os::raw::c_int as std::os::raw::c_ulong ||\n               link_end.wrapping_sub(start) > max_length as std::os::raw::c_ulong {\n            return 0 as std::os::raw::c_int as size_t\n        }\n        if !(link_end < size &&\n                 (*data.offset(link_end as isize) as std::os::raw::c_int == '+' as i32\n                      ||\n                      is_allminus != 0 &&\n                          *data.offset(link_end as isize) as std::os::raw::c_int ==\n                              '-' as i32) &&\n                 {\n                     let fresh0 = link_end;\n                     link_end = link_end.wrapping_add(1);\n                     (fresh0) != 0\n                 }) {\n            break ;\n        }\n    }\n    if link_end < size &&\n           *data.offset(link_end as isize) as std::os::raw::c_int == '/' as i32 {\n        while link_end < size &&\n                  (*(*__ctype_b_loc()).offset(*data.offset(link_end as isize)\n                                                  as std::os::raw::c_int as isize) as\n                       std::os::raw::c_int &\n                       _ISalnum as std::os::raw::c_int as std::os::raw::c_ushort as\n                           std::os::raw::c_int != 0 ||\n                       *data.offset(link_end as isize) as std::os::raw::c_int ==\n                           '_' as i32 ||\n                       *data.offset(link_end as isize) as std::os::raw::c_int ==\n                           '/' as i32 ||\n                       *data.offset(link_end as isize) as std::os::raw::c_int ==\n                           '-' as i32) {\n            link_end = link_end.wrapping_add(1)\n        }\n    }\n    /* valid subreddit names are between 3 and 21 characters, with\n\t\t * some subreddits having 2-character names. Don't bother with\n\t\t * autolinking for anything outside this length range.\n\t\t * (chksrname function in reddit/.../validator.py) */\n    /* make the link */\n    bufput(link, data.offset(-(rewind as isize)) as *const std::os::raw::c_void,\n           link_end.wrapping_add(rewind));\n    *no_slash = (rewind == 1 as std::os::raw::c_int as std::os::raw::c_ulong) as std::os::raw::c_int;\n    *rewind_p = rewind;\n    return link_end;\n}",
    "calls": [
      {
        "caller": "DefId(0:268 ~ c2rust[26e7]::src::markdown::char_autolink_subreddit_or_username)",
        "span": "src/markdown.rs:2945:5: 2947:69 (#0)",
        "source": "link_len =\n        sd_autolink__subreddit(&mut rewind, link, data, max_rewind,\n                               max_lookbehind, size, &mut no_slash);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/autolink.rs:19:1: 19:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:241 ~ c2rust[26e7]::src::markdown::char_autolink_subreddit_or_username)",
    "span": "src/markdown.rs:2924:1: 2982:2 (#0)",
    "pieces": [
      "src/markdown.rs:2924:1: 2982:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 58,
    "source": "unsafe extern \"C\" fn char_autolink_subreddit_or_username(mut ob: *mut buf,\n                                                         mut rndr:\n                                                             *mut sd_markdown,\n                                                         mut data:\n                                                             *mut uint8_t,\n                                                         mut max_rewind:\n                                                             size_t,\n                                                         mut max_lookbehind:\n                                                             size_t,\n                                                         mut size: size_t)\n -> size_t {\n    let mut link: *mut buf = 0 as *mut buf;\n    let mut link_text: *mut buf = 0 as *mut buf;\n    let mut link_url: *mut buf = 0 as *mut buf;\n    let mut link_len: size_t = 0;\n    let mut rewind: size_t = 0;\n    let mut no_slash: std::os::raw::c_int = 0;\n    if (*rndr).cb.autolink.is_none() || (*rndr).in_link_body != 0 {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    link = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n    link_len =\n        sd_autolink__subreddit(&mut rewind, link, data, max_rewind,\n                               max_lookbehind, size, &mut no_slash);\n    if link_len == 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        link_len =\n            sd_autolink__username(&mut rewind, link, data, max_rewind,\n                                  max_lookbehind, size, &mut no_slash)\n    }\n    /* Found either a user or subreddit link */\n    if link_len > 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        link_url = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n        if no_slash != 0 { bufputc(link_url, '/' as i32); }\n        bufput(link_url, (*link).data as *const std::os::raw::c_void, (*link).size);\n        buftruncate(ob, (*ob).size.wrapping_sub(rewind));\n        if (*rndr).cb.normal_text.is_some() {\n            link_text = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n            (*rndr).cb.normal_text.expect(\"non-null function pointer\")(link_text,\n                                                                       link,\n                                                                       (*rndr).opaque);\n            (*rndr).cb.link.expect(\"non-null function pointer\")(ob, link_url,\n                                                                0 as\n                                                                    *const buf,\n                                                                link_text,\n                                                                (*rndr).opaque);\n            rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n        } else {\n            (*rndr).cb.link.expect(\"non-null function pointer\")(ob, link_url,\n                                                                0 as\n                                                                    *const buf,\n                                                                link,\n                                                                (*rndr).opaque);\n        }\n        rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n    }\n    rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n    return link_len;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:39 ~ c2rust[26e7]::src::autolink::sd_autolink__www)",
    "span": "src/autolink.rs:309:1: 355:2 (#0)",
    "pieces": [
      "src/autolink.rs:309:1: 355:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 47,
    "source": "pub unsafe extern \"C\" fn sd_autolink__www(mut rewind_p: *mut size_t,\n                                          mut link: *mut buf,\n                                          mut data: *mut uint8_t,\n                                          mut max_rewind: size_t,\n                                          mut size: size_t,\n                                          mut flags: std::os::raw::c_uint) -> size_t {\n    let mut link_end: size_t = 0;\n    if max_rewind > 0 as std::os::raw::c_int as std::os::raw::c_ulong &&\n           *(*__ctype_b_loc()).offset(*data.offset(-(1 as std::os::raw::c_int) as\n                                                       isize) as std::os::raw::c_int\n                                          as isize) as std::os::raw::c_int &\n               _ISpunct as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int == 0\n           &&\n           *(*__ctype_b_loc()).offset(*data.offset(-(1 as std::os::raw::c_int) as\n                                                       isize) as std::os::raw::c_int\n                                          as isize) as std::os::raw::c_int &\n               _ISspace as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int == 0 {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    if size < 4 as std::os::raw::c_int as std::os::raw::c_ulong ||\n           memcmp(data as *const std::os::raw::c_void,\n                  b\"www.\\x00\" as *const u8 as *const std::os::raw::c_char as\n                      *const std::os::raw::c_void,\n                  strlen(b\"www.\\x00\" as *const u8 as *const std::os::raw::c_char)) !=\n               0 as std::os::raw::c_int {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    link_end = check_domain(data, size, 0 as std::os::raw::c_int);\n    if link_end == 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    while link_end < size &&\n              *(*__ctype_b_loc()).offset(*data.offset(link_end as isize) as\n                                             std::os::raw::c_int as isize) as\n                  std::os::raw::c_int &\n                  _ISspace as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int ==\n                  0 {\n        link_end = link_end.wrapping_add(1)\n    }\n    link_end = autolink_delim(data, link_end, max_rewind, size);\n    if link_end == 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    bufput(link, data as *const std::os::raw::c_void, link_end);\n    *rewind_p = 0 as std::os::raw::c_int as size_t;\n    return link_end as std::os::raw::c_int as size_t;\n}",
    "calls": [
      {
        "caller": "DefId(0:266 ~ c2rust[26e7]::src::markdown::char_autolink_www)",
        "span": "src/markdown.rs:2887:5: 2889:76 (#0)",
        "source": "link_len =\n        sd_autolink__www(&mut rewind, link, data, max_rewind, size,\n                         0 as std::os::raw::c_int as std::os::raw::c_uint);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/autolink.rs:19:1: 19:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:239 ~ c2rust[26e7]::src::markdown::char_autolink_www)",
    "span": "src/markdown.rs:2872:1: 2923:2 (#0)",
    "pieces": [
      "src/markdown.rs:2872:1: 2923:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 51,
    "source": "unsafe extern \"C\" fn char_autolink_www(mut ob: *mut buf,\n                                       mut rndr: *mut sd_markdown,\n                                       mut data: *mut uint8_t,\n                                       mut max_rewind: size_t,\n                                       mut max_lookbehind: size_t,\n                                       mut size: size_t) -> size_t {\n    let mut link: *mut buf = 0 as *mut buf;\n    let mut link_url: *mut buf = 0 as *mut buf;\n    let mut link_text: *mut buf = 0 as *mut buf;\n    let mut link_len: size_t = 0;\n    let mut rewind: size_t = 0;\n    if (*rndr).cb.link.is_none() || (*rndr).in_link_body != 0 {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    link = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n    link_len =\n        sd_autolink__www(&mut rewind, link, data, max_rewind, size,\n                         0 as std::os::raw::c_int as std::os::raw::c_uint);\n    if link_len > 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        link_url = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n        bufput(link_url,\n               b\"http://\\x00\" as *const u8 as *const std::os::raw::c_char as\n                   *const std::os::raw::c_void,\n               (::std::mem::size_of::<[std::os::raw::c_char; 8]>() as\n                    std::os::raw::c_ulong).wrapping_sub(1 as std::os::raw::c_int as\n                                                    std::os::raw::c_ulong));\n        bufput(link_url, (*link).data as *const std::os::raw::c_void, (*link).size);\n        buftruncate(ob, (*ob).size.wrapping_sub(rewind));\n        if (*rndr).cb.normal_text.is_some() {\n            link_text = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n            (*rndr).cb.normal_text.expect(\"non-null function pointer\")(link_text,\n                                                                       link,\n                                                                       (*rndr).opaque);\n            (*rndr).cb.link.expect(\"non-null function pointer\")(ob, link_url,\n                                                                0 as\n                                                                    *const buf,\n                                                                link_text,\n                                                                (*rndr).opaque);\n            rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n        } else {\n            (*rndr).cb.link.expect(\"non-null function pointer\")(ob, link_url,\n                                                                0 as\n                                                                    *const buf,\n                                                                link,\n                                                                (*rndr).opaque);\n        }\n        rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n    }\n    rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n    return link_len;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:258 ~ c2rust[26e7]::src::markdown::parse_blockquote)",
    "span": "src/markdown.rs:3759:1: 3820:2 (#0)",
    "pieces": [
      "src/markdown.rs:3759:1: 3820:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 62,
    "source": "unsafe extern \"C\" fn parse_blockquote(mut ob: *mut buf,\n                                      mut rndr: *mut sd_markdown,\n                                      mut data: *mut uint8_t,\n                                      mut size: size_t) -> size_t {\n    let mut beg: size_t = 0; /* skipping prefix */\n    let mut end: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut pre: size_t = 0;\n    let mut work_size: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut work_data: *mut uint8_t = 0 as *mut uint8_t;\n    let mut out: *mut buf = 0 as *mut buf;\n    out = rndr_newbuf(rndr, 0 as std::os::raw::c_int);\n    beg = 0 as std::os::raw::c_int as size_t;\n    while beg < size {\n        end = beg.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong);\n        while end < size &&\n                  *data.offset(end.wrapping_sub(1 as std::os::raw::c_int as\n                                                    std::os::raw::c_ulong) as isize)\n                      as std::os::raw::c_int != '\\n' as i32 {\n            end = end.wrapping_add(1)\n        }\n        pre = prefix_quote(data.offset(beg as isize), end.wrapping_sub(beg));\n        if pre != 0 {\n            beg = (beg as std::os::raw::c_ulong).wrapping_add(pre) as size_t as size_t\n        } else if is_empty(data.offset(beg as isize), end.wrapping_sub(beg))\n                      != 0 &&\n                      (end >= size ||\n                           prefix_quote(data.offset(end as isize),\n                                        size.wrapping_sub(end)) ==\n                               0 as std::os::raw::c_int as std::os::raw::c_ulong &&\n                               is_empty(data.offset(end as isize),\n                                        size.wrapping_sub(end)) == 0)\n         /* empty line followed by non-quote line */\n         {\n            break ;\n        }\n        if beg < end {\n            /* copy into the in-place working buffer */\n            /* bufput(work, data + beg, end - beg); */\n            if work_data.is_null() {\n                work_data = data.offset(beg as isize)\n            } else if data.offset(beg as isize) !=\n                          work_data.offset(work_size as isize) {\n                memmove(work_data.offset(work_size as isize) as\n                            *mut std::os::raw::c_void,\n                        data.offset(beg as isize) as *const std::os::raw::c_void,\n                        end.wrapping_sub(beg));\n            }\n            work_size =\n                (work_size as\n                     std::os::raw::c_ulong).wrapping_add(end.wrapping_sub(beg)) as\n                    size_t as size_t\n        }\n        beg = end\n    }\n    parse_block(out, rndr, work_data, work_size);\n    if (*rndr).cb.blockquote.is_some() {\n        (*rndr).cb.blockquote.expect(\"non-null function pointer\")(ob, out,\n                                                                  (*rndr).opaque);\n    }\n    rndr_popbuf(rndr, 0 as std::os::raw::c_int);\n    return end;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:222 ~ c2rust[26e7]::src::markdown::free_link_refs)",
    "span": "src/markdown.rs:1976:1: 1989:2 (#0)",
    "pieces": [
      "src/markdown.rs:1976:1: 1989:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "unsafe extern \"C\" fn free_link_refs(mut references: *mut *mut link_ref) {\n    let mut i: size_t = 0;\n    i = 0 as std::os::raw::c_int as size_t;\n    while i < 8 as std::os::raw::c_int as std::os::raw::c_ulong {\n        let mut r: *mut link_ref = *references.offset(i as isize);\n        let mut next: *mut link_ref = 0 as *mut link_ref;\n        while !r.is_null() {\n            next = (*r).next;\n            bufrelease((*r).link);\n            bufrelease((*r).title);\n            free(r as *mut std::os::raw::c_void);\n            r = next\n        }\n        i = i.wrapping_add(1)\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:303 ~ c2rust[26e7]::src::markdown::sd_markdown_render)",
        "span": "src/markdown.rs:5366:5: 5366:37 (#0)",
        "source": "free_link_refs(&mut (*md).refs);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:223 ~ c2rust[26e7]::src::markdown::_isspace)",
    "span": "src/markdown.rs:2003:2: 2005:2 (#0)",
    "pieces": [
      "src/markdown.rs:2003:2: 2005:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "extern \"C\" fn _isspace(mut c: std::os::raw::c_int) -> std::os::raw::c_int {\n    return (c == ' ' as i32 || c == '\\n' as i32) as std::os::raw::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:61 ~ c2rust[26e7]::src::buffer::bufgrow)",
    "span": "src/buffer.rs:62:1: 83:2 (#0)",
    "pieces": [
      "src/buffer.rs:62:1: 83:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 22,
    "source": "pub unsafe extern \"C\" fn bufgrow(mut buf: *mut buf, mut neosz: size_t)\n -> std::os::raw::c_int {\n    let mut neoasz: size_t = 0;\n    let mut neodata: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;\n    if neosz >\n           (1024 as std::os::raw::c_int * 1024 as std::os::raw::c_int * 16 as std::os::raw::c_int) as\n               std::os::raw::c_ulong {\n        return BUF_ENOMEM as std::os::raw::c_int\n    }\n    if (*buf).asize >= neosz { return BUF_OK as std::os::raw::c_int }\n    neoasz = (*buf).asize.wrapping_add((*buf).unit);\n    while neoasz < neosz {\n        neoasz =\n            (neoasz as std::os::raw::c_ulong).wrapping_add((*buf).unit) as size_t as\n                size_t\n    }\n    neodata = realloc((*buf).data as *mut std::os::raw::c_void, neoasz);\n    if neodata.is_null() { return BUF_ENOMEM as std::os::raw::c_int }\n    (*buf).data = neodata as *mut uint8_t;\n    (*buf).asize = neoasz;\n    return BUF_OK as std::os::raw::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:303 ~ c2rust[26e7]::src::markdown::sd_markdown_render)",
        "span": "src/markdown.rs:5276:5: 5276:29 (#0)",
        "source": "bufgrow(text, doc_size);"
      },
      {
        "caller": "DefId(0:303 ~ c2rust[26e7]::src::markdown::sd_markdown_render)",
        "span": "src/markdown.rs:5340:5: 5340:86 (#0)",
        "source": "bufgrow(ob, (*text).size.wrapping_add((*text).size >> 1 as std::os::raw::c_int));"
      }
    ],
    "globals": [
      {
        "span": "src/buffer.rs:35:1: 35:42 (#0)",
        "source": "pub const BUF_ENOMEM: C2RustUnnamed = -1;"
      },
      {
        "span": "src/buffer.rs:36:1: 36:37 (#0)",
        "source": "pub const BUF_OK: C2RustUnnamed = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/buffer.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/buffer.rs:6:1: 6:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/buffer.rs:12:1: 12:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/buffer.rs:8:1: 8:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/buffer.rs:11:1: 11:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:228 ~ c2rust[26e7]::src::markdown::parse_emph1)",
    "span": "src/markdown.rs:2299:1: 2359:2 (#0)",
    "pieces": [
      "src/markdown.rs:2299:1: 2359:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 61,
    "source": "unsafe extern \"C\" fn parse_emph1(mut ob: *mut buf, mut rndr: *mut sd_markdown,\n                                 mut data: *mut uint8_t, mut size: size_t,\n                                 mut c: uint8_t) -> size_t {\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut len: size_t = 0;\n    let mut work: *mut buf = 0 as *mut buf;\n    let mut r: std::os::raw::c_int = 0;\n    if (*rndr).cb.emphasis.is_none() { return 0 as std::os::raw::c_int as size_t }\n    /* skipping one symbol if coming from emph3 */\n    if size > 1 as std::os::raw::c_int as std::os::raw::c_ulong &&\n           *data.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n               c as std::os::raw::c_int &&\n           *data.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n               c as std::os::raw::c_int {\n        i = 1 as std::os::raw::c_int as size_t\n    }\n    while i < size {\n        len =\n            find_emph_char(data.offset(i as isize), size.wrapping_sub(i), c);\n        if len == 0 { return 0 as std::os::raw::c_int as size_t }\n        i = (i as std::os::raw::c_ulong).wrapping_add(len) as size_t as size_t;\n        if i >= size { return 0 as std::os::raw::c_int as size_t }\n        if !(*data.offset(i as isize) as std::os::raw::c_int == c as std::os::raw::c_int &&\n                 _isspace(*data.offset(i.wrapping_sub(1 as std::os::raw::c_int as\n                                                          std::os::raw::c_ulong) as\n                                           isize) as std::os::raw::c_int) == 0) {\n            continue ;\n        }\n        if (*rndr).ext_flags &\n               MKDEXT_NO_INTRA_EMPHASIS as std::os::raw::c_int as std::os::raw::c_uint != 0 &&\n               c as std::os::raw::c_int == '_' as i32 {\n            if !(i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) == size ||\n                     _isspace(*data.offset(i.wrapping_add(1 as std::os::raw::c_int as\n                                                              std::os::raw::c_ulong)\n                                               as isize) as std::os::raw::c_int) != 0\n                     ||\n                     *(*__ctype_b_loc()).offset(*data.offset(i.wrapping_add(1\n                                                                                as\n                                                                                std::os::raw::c_int\n                                                                                as\n                                                                                std::os::raw::c_ulong)\n                                                                 as isize) as\n                                                    std::os::raw::c_int as isize) as\n                         std::os::raw::c_int &\n                         _ISpunct as std::os::raw::c_int as std::os::raw::c_ushort as\n                             std::os::raw::c_int != 0) {\n                continue ;\n            }\n        }\n        work = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n        parse_inline(work, rndr, data, i);\n        r =\n            (*rndr).cb.emphasis.expect(\"non-null function pointer\")(ob, work,\n                                                                    (*rndr).opaque);\n        rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n        return if r != 0 {\n                   i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n               } else { 0 as std::os::raw::c_int as std::os::raw::c_ulong }\n    }\n    return 0 as std::os::raw::c_int as size_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:69 ~ c2rust[26e7]::src::buffer::bufslurp)",
    "span": "src/buffer.rs:186:1: 195:2 (#0)",
    "pieces": [
      "src/buffer.rs:186:1: 195:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn bufslurp(mut buf: *mut buf, mut len: size_t) {\n    if len >= (*buf).size { (*buf).size = 0 as std::os::raw::c_int as size_t; return }\n    (*buf).size =\n        ((*buf).size as std::os::raw::c_ulong).wrapping_sub(len) as size_t as size_t;\n    memmove((*buf).data as *mut std::os::raw::c_void,\n            (*buf).data.offset(len as isize) as *const std::os::raw::c_void,\n            (*buf).size);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/buffer.rs:6:1: 6:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/buffer.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/buffer.rs:12:1: 12:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/buffer.rs:11:1: 11:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/buffer.rs:8:1: 8:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:220 ~ c2rust[26e7]::src::markdown::add_link_ref)",
    "span": "src/markdown.rs:1941:1: 1961:2 (#0)",
    "pieces": [
      "src/markdown.rs:1941:1: 1961:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "unsafe extern \"C\" fn add_link_ref(mut references: *mut *mut link_ref,\n                                  mut name: *const uint8_t,\n                                  mut name_size: size_t) -> *mut link_ref {\n    let mut ref_0: *mut link_ref =\n        calloc(1 as std::os::raw::c_int as std::os::raw::c_ulong,\n               ::std::mem::size_of::<link_ref>() as std::os::raw::c_ulong) as\n            *mut link_ref;\n    if ref_0.is_null() { return 0 as *mut link_ref }\n    (*ref_0).id = hash_link_ref(name, name_size);\n    (*ref_0).next =\n        *references.offset((*ref_0).id.wrapping_rem(8 as std::os::raw::c_int as\n                                                        std::os::raw::c_uint) as\n                               isize);\n    let ref mut fresh1 =\n        *references.offset((*ref_0).id.wrapping_rem(8 as std::os::raw::c_int as\n                                                        std::os::raw::c_uint) as\n                               isize);\n    *fresh1 = ref_0;\n    return ref_0;\n}",
    "calls": [
      {
        "caller": "DefId(0:300 ~ c2rust[26e7]::src::markdown::is_ref)",
        "span": "src/markdown.rs:5133:5: 5133:105 (#0)",
        "source": "let ref_0 = add_link_ref(refs_ref, data.offset(id_offset as isize), id_end.wrapping_sub(id_offset));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:273 ~ c2rust[26e7]::src::markdown::is_ref)",
    "span": "src/markdown.rs:4974:1: 5148:2 (#0)",
    "pieces": [
      "src/markdown.rs:4974:1: 4978:4 (#0)",
      "src/markdown.rs:5096:1: 5096:4 (#0)",
      "src/markdown.rs:5148:1: 5148:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn is_ref(mut data: *const uint8_t, mut beg: size_t,\n                            mut end: size_t, mut last: *mut size_t,\n                            mut refs: *mut *mut link_ref) -> std::os::raw::c_int {\n    /*\tint n; */\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/markdown.rs:4978:5: 5095:30 (#0)",
        "pieces": [
          "src/markdown.rs:4978:5: 5095:30 (#0)"
        ],
        "num_lines": 118,
        "source": "let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut id_offset: size_t = 0;\n    let mut id_end: size_t = 0;\n    let mut link_offset: size_t = 0;\n    let mut link_end: size_t = 0;\n    let mut title_offset: size_t = 0;\n    let mut title_end: size_t = 0;\n    let mut line_end: size_t = 0;\n    /* up to 3 optional leading spaces */\n    if beg.wrapping_add(3 as std::os::raw::c_int as std::os::raw::c_ulong) >= end {\n        return 0 as std::os::raw::c_int\n    }\n    if *data.offset(beg as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = 1 as std::os::raw::c_int as size_t;\n        if *data.offset(beg.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) as\n                            isize) as std::os::raw::c_int == ' ' as i32 {\n            i = 2 as std::os::raw::c_int as size_t;\n            if *data.offset(beg.wrapping_add(2 as std::os::raw::c_int as\n                                                 std::os::raw::c_ulong) as isize) as\n                   std::os::raw::c_int == ' ' as i32 {\n                i = 3 as std::os::raw::c_int as size_t;\n                if *data.offset(beg.wrapping_add(3 as std::os::raw::c_int as\n                                                     std::os::raw::c_ulong) as isize)\n                       as std::os::raw::c_int == ' ' as i32 {\n                    return 0 as std::os::raw::c_int\n                }\n            }\n        }\n    }\n    i = (i as std::os::raw::c_ulong).wrapping_add(beg) as size_t as size_t;\n    /* id part: anything but a newline between brackets */\n    if *data.offset(i as isize) as std::os::raw::c_int != '[' as i32 {\n        return 0 as std::os::raw::c_int\n    }\n    i = i.wrapping_add(1);\n    id_offset = i;\n    while i < end && *data.offset(i as isize) as std::os::raw::c_int != '\\n' as i32 &&\n              *data.offset(i as isize) as std::os::raw::c_int != '\\r' as i32 &&\n              *data.offset(i as isize) as std::os::raw::c_int != ']' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i >= end || *data.offset(i as isize) as std::os::raw::c_int != ']' as i32 {\n        return 0 as std::os::raw::c_int\n    }\n    id_end = i;\n    /* spacer: colon (space | tab)* newline? (space | tab)* */\n    i = i.wrapping_add(1);\n    if i >= end || *data.offset(i as isize) as std::os::raw::c_int != ':' as i32 {\n        return 0 as std::os::raw::c_int\n    }\n    i = i.wrapping_add(1);\n    while i < end && *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i < end &&\n           (*data.offset(i as isize) as std::os::raw::c_int == '\\n' as i32 ||\n                *data.offset(i as isize) as std::os::raw::c_int == '\\r' as i32) {\n        i = i.wrapping_add(1);\n        if i < end && *data.offset(i as isize) as std::os::raw::c_int == '\\r' as i32\n               &&\n               *data.offset(i.wrapping_sub(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n                                as isize) as std::os::raw::c_int == '\\n' as i32 {\n            i = i.wrapping_add(1)\n        }\n    }\n    while i < end && *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i >= end { return 0 as std::os::raw::c_int }\n    /* link: whitespace-free sequence, optionally between angle brackets */\n    if *data.offset(i as isize) as std::os::raw::c_int == '<' as i32 {\n        i = i.wrapping_add(1)\n    }\n    link_offset = i;\n    while i < end && *data.offset(i as isize) as std::os::raw::c_int != ' ' as i32 &&\n              *data.offset(i as isize) as std::os::raw::c_int != '\\n' as i32 &&\n              *data.offset(i as isize) as std::os::raw::c_int != '\\r' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if *data.offset(i.wrapping_sub(1 as std::os::raw::c_int as std::os::raw::c_ulong) as\n                        isize) as std::os::raw::c_int == '>' as i32 {\n        link_end = i.wrapping_sub(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n    } else { link_end = i }\n    /* optional spacer: (space | tab)* (newline | '\\'' | '\"' | '(' ) */\n    while i < end && *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i < end && *data.offset(i as isize) as std::os::raw::c_int != '\\n' as i32 &&\n           *data.offset(i as isize) as std::os::raw::c_int != '\\r' as i32 &&\n           *data.offset(i as isize) as std::os::raw::c_int != '\\'' as i32 &&\n           *data.offset(i as isize) as std::os::raw::c_int != '\\\"' as i32 &&\n           *data.offset(i as isize) as std::os::raw::c_int != '(' as i32 {\n        return 0 as std::os::raw::c_int\n    }\n    line_end = 0 as std::os::raw::c_int as size_t;\n    /* computing end-of-line */\n    if i >= end || *data.offset(i as isize) as std::os::raw::c_int == '\\r' as i32 ||\n           *data.offset(i as isize) as std::os::raw::c_int == '\\n' as i32 {\n        line_end = i\n    }\n    if i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) < end &&\n           *data.offset(i as isize) as std::os::raw::c_int == '\\n' as i32 &&\n           *data.offset(i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) as\n                            isize) as std::os::raw::c_int == '\\r' as i32 {\n        line_end = i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n    }\n    /* optional (space|tab)* spacer after a newline */\n    if line_end != 0 {\n        i = line_end.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong);\n        while i < end && *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32\n              {\n            i = i.wrapping_add(1)\n        }\n    }\n    /* optional title: any non-newline sequence enclosed in '\"()\n\t\t\t\t\talone on its line */\n    title_end = 0 as std::os::raw::c_int as size_t;\n    title_offset = title_end;",
        "sub_chunks": [],
        "live_in": [
          "mut data: *const u8",
          "mut beg: u64",
          "mut end: u64"
        ],
        "live_out": [
          "mut data: *const u8",
          "mut beg: u64",
          "mut end: u64",
          "mut i: u64",
          "mut id_offset: u64",
          "mut id_end: u64",
          "mut link_offset: u64",
          "mut link_end: u64",
          "mut title_offset: u64",
          "mut title_end: u64",
          "mut line_end: u64"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/markdown.rs:5096:5: 5146:10 (#0)",
        "pieces": [
          "src/markdown.rs:5096:5: 5146:10 (#0)"
        ],
        "num_lines": 61,
        "source": "if i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) < end &&\n           (*data.offset(i as isize) as std::os::raw::c_int == '\\'' as i32 ||\n                *data.offset(i as isize) as std::os::raw::c_int == '\\\"' as i32 ||\n                *data.offset(i as isize) as std::os::raw::c_int == '(' as i32) {\n        i = i.wrapping_add(1);\n        title_offset = i;\n        /* looking for EOL */\n        while i < end &&\n                  *data.offset(i as isize) as std::os::raw::c_int != '\\n' as i32 &&\n                  *data.offset(i as isize) as std::os::raw::c_int != '\\r' as i32 {\n            i = i.wrapping_add(1)\n        }\n        if i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) < end &&\n               *data.offset(i as isize) as std::os::raw::c_int == '\\n' as i32 &&\n               *data.offset(i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n                                as isize) as std::os::raw::c_int == '\\r' as i32 {\n            title_end = i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n        } else { title_end = i }\n        /* stepping back */\n        i =\n            (i as\n                 std::os::raw::c_ulong).wrapping_sub(1 as std::os::raw::c_int as\n                                                 std::os::raw::c_ulong) as size_t as\n                size_t; /* garbage after the link empty link */\n        while i > title_offset &&\n                  *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n            i =\n                (i as\n                     std::os::raw::c_ulong).wrapping_sub(1 as std::os::raw::c_int as\n                                                     std::os::raw::c_ulong) as size_t\n                    as size_t\n        }\n        if i > title_offset &&\n               (*data.offset(i as isize) as std::os::raw::c_int == '\\'' as i32 ||\n                    *data.offset(i as isize) as std::os::raw::c_int == '\\\"' as i32 ||\n                    *data.offset(i as isize) as std::os::raw::c_int == ')' as i32) {\n            line_end = title_end;\n            title_end = i\n        }\n    }\n    if line_end == 0 || link_end == link_offset { return 0 as std::os::raw::c_int }\n    /* a valid ref has been found, filling-in return structures */\n    if !last.is_null() { *last = line_end }\n    if !refs.is_null() {\n        let mut ref_0: *mut link_ref = 0 as *mut link_ref;\n        ref_0 =\n            add_link_ref(refs, data.offset(id_offset as isize),\n                         id_end.wrapping_sub(id_offset));\n        if ref_0.is_null() { return 0 as std::os::raw::c_int }\n        (*ref_0).link = bufnew(link_end.wrapping_sub(link_offset));\n        bufput((*ref_0).link,\n               data.offset(link_offset as isize) as *const std::os::raw::c_void,\n               link_end.wrapping_sub(link_offset));\n        if title_end > title_offset {\n            (*ref_0).title = bufnew(title_end.wrapping_sub(title_offset));\n            bufput((*ref_0).title,\n                   data.offset(title_offset as isize) as *const std::os::raw::c_void,\n                   title_end.wrapping_sub(title_offset));\n        }\n    }\n    return 1 as std::os::raw::c_int;",
        "sub_chunks": [],
        "live_in": [
          "mut data: *const u8",
          "mut end: u64",
          "mut last: *mut u64",
          "mut refs: *mut *mut src::markdown::link_ref",
          "mut i: u64",
          "mut id_offset: u64",
          "mut id_end: u64",
          "mut link_offset: u64",
          "mut link_end: u64",
          "mut title_offset: u64",
          "mut title_end: u64",
          "mut line_end: u64"
        ],
        "live_out": [
          "mut data: *const u8",
          "mut end: u64",
          "mut last: *mut u64",
          "mut refs: *mut *mut src::markdown::link_ref",
          "mut i: u64",
          "mut id_offset: u64",
          "mut id_end: u64",
          "mut link_offset: u64",
          "mut link_end: u64",
          "mut title_offset: u64",
          "mut title_end: u64",
          "mut line_end: u64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:276 ~ c2rust[26e7]::src::markdown::sd_markdown_render)",
    "span": "src/markdown.rs:5261:1: 5367:2 (#0)",
    "pieces": [
      "src/markdown.rs:5261:1: 5367:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 106,
    "source": "pub unsafe extern \"C\" fn sd_markdown_render(mut ob: *mut buf,\n                                            mut document: *const uint8_t,\n                                            mut doc_size: size_t,\n                                            mut md: *mut sd_markdown) {\n    static mut UTF8_BOM: [std::os::raw::c_char; 3] =\n        [0xef as std::os::raw::c_int as std::os::raw::c_char,\n         0xbb as std::os::raw::c_int as std::os::raw::c_char,\n         0xbf as std::os::raw::c_int as std::os::raw::c_char];\n    let mut text: *mut buf = 0 as *mut buf;\n    let mut beg: size_t = 0;\n    let mut end: size_t = 0;\n    text = bufnew(64 as std::os::raw::c_int as size_t);\n    if text.is_null() { return }\n    /* Preallocate enough space for our buffer to avoid expanding while copying */\n    bufgrow(text, doc_size);\n    /* reset the references table */\n    memset(&mut (*md).refs as *mut [*mut link_ref; 8] as *mut std::os::raw::c_void,\n           0 as std::os::raw::c_int,\n           (8 as std::os::raw::c_int as\n                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*mut std::os::raw::c_void>()\n                                                as std::os::raw::c_ulong));\n    /* first pass: looking for references, copying everything else */\n    beg = 0 as std::os::raw::c_int as size_t;\n    /* Skip a possible UTF-8 BOM, even though the Unicode standard\n\t * discourages having these in UTF-8 documents */\n    if doc_size >= 3 as std::os::raw::c_int as std::os::raw::c_ulong &&\n           memcmp(document as *const std::os::raw::c_void,\n                  UTF8_BOM.as_ptr() as *const std::os::raw::c_void,\n                  3 as std::os::raw::c_int as std::os::raw::c_ulong) == 0 as std::os::raw::c_int {\n        beg =\n            (beg as\n                 std::os::raw::c_ulong).wrapping_add(3 as std::os::raw::c_int as\n                                                 std::os::raw::c_ulong) as size_t as\n                size_t\n    }\n    while beg < doc_size {\n        /* iterating over lines */\n        if is_ref(document, beg, doc_size, &mut end, (*md).refs.as_mut_ptr())\n               != 0 {\n            beg = end\n        } else {\n            /* skipping to the next line */\n            end = beg;\n            while end < doc_size &&\n                      *document.offset(end as isize) as std::os::raw::c_int !=\n                          '\\n' as i32 &&\n                      *document.offset(end as isize) as std::os::raw::c_int !=\n                          '\\r' as i32 {\n                end = end.wrapping_add(1)\n            }\n            /* adding the line body if present */\n            if end > beg {\n                expand_tabs(text, document.offset(beg as isize),\n                            end.wrapping_sub(beg));\n            }\n            while end < doc_size &&\n                      (*document.offset(end as isize) as std::os::raw::c_int ==\n                           '\\n' as i32 ||\n                           *document.offset(end as isize) as std::os::raw::c_int ==\n                               '\\r' as i32) {\n                /* add one \\n per newline */\n                if *document.offset(end as isize) as std::os::raw::c_int ==\n                       '\\n' as i32 ||\n                       end.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) <\n                           doc_size &&\n                           *document.offset(end.wrapping_add(1 as std::os::raw::c_int\n                                                                 as\n                                                                 std::os::raw::c_ulong)\n                                                as isize) as std::os::raw::c_int !=\n                               '\\n' as i32 {\n                    bufputc(text, '\\n' as i32);\n                }\n                end = end.wrapping_add(1)\n            }\n            beg = end\n        }\n    }\n    /* pre-grow the output buffer to minimize allocations */\n    bufgrow(ob, (*text).size.wrapping_add((*text).size >> 1 as std::os::raw::c_int));\n    /* second pass: actual rendering */\n    if (*md).cb.doc_header.is_some() {\n        (*md).cb.doc_header.expect(\"non-null function pointer\")(ob,\n                                                                (*md).opaque);\n    }\n    if (*text).size != 0 {\n        /* adding a final newline if not already present */\n        if *(*text).data.offset((*text).size.wrapping_sub(1 as std::os::raw::c_int as\n                                                              std::os::raw::c_ulong)\n                                    as isize) as std::os::raw::c_int != '\\n' as i32 &&\n               *(*text).data.offset((*text).size.wrapping_sub(1 as std::os::raw::c_int\n                                                                  as\n                                                                  std::os::raw::c_ulong)\n                                        as isize) as std::os::raw::c_int !=\n                   '\\r' as i32 {\n            bufputc(text, '\\n' as i32);\n        }\n        parse_block(ob, md, (*text).data, (*text).size);\n    }\n    if (*md).cb.doc_footer.is_some() {\n        (*md).cb.doc_footer.expect(\"non-null function pointer\")(ob,\n                                                                (*md).opaque);\n    }\n    /* clean-up */\n    bufrelease(text);\n    free_link_refs((*md).refs.as_mut_ptr());\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:232 ~ c2rust[26e7]::src::markdown::char_emphasis)",
    "span": "src/markdown.rs:2512:1: 2601:2 (#0)",
    "pieces": [
      "src/markdown.rs:2512:1: 2601:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 90,
    "source": "unsafe extern \"C\" fn char_emphasis(mut ob: *mut buf,\n                                   mut rndr: *mut sd_markdown,\n                                   mut data: *mut uint8_t,\n                                   mut max_rewind: size_t,\n                                   mut max_lookbehind: size_t,\n                                   mut size: size_t) -> size_t {\n    let mut c: uint8_t = *data.offset(0 as std::os::raw::c_int as isize);\n    let mut ret: size_t = 0;\n    if size > 3 as std::os::raw::c_int as std::os::raw::c_ulong &&\n           c as std::os::raw::c_int == '>' as i32 &&\n           *data.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n               '!' as i32 {\n        if _isspace(*data.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int) !=\n               0 ||\n               {\n                   ret =\n                       parse_spoilerspan(ob, rndr,\n                                         data.offset(2 as std::os::raw::c_int as\n                                                         isize),\n                                         size.wrapping_sub(2 as std::os::raw::c_int as\n                                                               std::os::raw::c_ulong));\n                   (ret) == 0 as std::os::raw::c_int as std::os::raw::c_ulong\n               } {\n            return 0 as std::os::raw::c_int as size_t\n        }\n        return ret.wrapping_add(2 as std::os::raw::c_int as std::os::raw::c_ulong)\n    }\n    if size > 2 as std::os::raw::c_int as std::os::raw::c_ulong &&\n           *data.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int !=\n               c as std::os::raw::c_int {\n        /* whitespace cannot follow an opening emphasis;\n\t\t * strikethrough only takes two characters '~~' */\n        if c as std::os::raw::c_int == '~' as i32 || c as std::os::raw::c_int == '>' as i32 ||\n               _isspace(*data.offset(1 as std::os::raw::c_int as isize) as\n                            std::os::raw::c_int) != 0 ||\n               {\n                   ret =\n                       parse_emph1(ob, rndr,\n                                   data.offset(1 as std::os::raw::c_int as isize),\n                                   size.wrapping_sub(1 as std::os::raw::c_int as\n                                                         std::os::raw::c_ulong), c);\n                   (ret) == 0 as std::os::raw::c_int as std::os::raw::c_ulong\n               } {\n            return 0 as std::os::raw::c_int as size_t\n        }\n        return ret.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n    }\n    if size > 3 as std::os::raw::c_int as std::os::raw::c_ulong &&\n           *data.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n               c as std::os::raw::c_int &&\n           *data.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int !=\n               c as std::os::raw::c_int {\n        if _isspace(*data.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int) !=\n               0 ||\n               {\n                   ret =\n                       parse_emph2(ob, rndr,\n                                   data.offset(2 as std::os::raw::c_int as isize),\n                                   size.wrapping_sub(2 as std::os::raw::c_int as\n                                                         std::os::raw::c_ulong), c);\n                   (ret) == 0 as std::os::raw::c_int as std::os::raw::c_ulong\n               } {\n            return 0 as std::os::raw::c_int as size_t\n        }\n        return ret.wrapping_add(2 as std::os::raw::c_int as std::os::raw::c_ulong)\n    }\n    if size > 4 as std::os::raw::c_int as std::os::raw::c_ulong &&\n           *data.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n               c as std::os::raw::c_int &&\n           *data.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n               c as std::os::raw::c_int &&\n           *data.offset(3 as std::os::raw::c_int as isize) as std::os::raw::c_int !=\n               c as std::os::raw::c_int {\n        if c as std::os::raw::c_int == '~' as i32 || c as std::os::raw::c_int == '>' as i32 ||\n               _isspace(*data.offset(3 as std::os::raw::c_int as isize) as\n                            std::os::raw::c_int) != 0 ||\n               {\n                   ret =\n                       parse_emph3(ob, rndr,\n                                   data.offset(3 as std::os::raw::c_int as isize),\n                                   size.wrapping_sub(3 as std::os::raw::c_int as\n                                                         std::os::raw::c_ulong), c);\n                   (ret) == 0 as std::os::raw::c_int as std::os::raw::c_ulong\n               } {\n            return 0 as std::os::raw::c_int as size_t\n        }\n        return ret.wrapping_add(3 as std::os::raw::c_int as std::os::raw::c_ulong)\n    }\n    return 0 as std::os::raw::c_int as size_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:63 ~ c2rust[26e7]::src::buffer::bufcstr)",
    "span": "src/buffer.rs:112:1: 123:2 (#0)",
    "pieces": [
      "src/buffer.rs:112:1: 123:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 18,
    "source": "pub unsafe extern \"C\" fn bufcstr(mut buf: *mut buf) -> *const std::os::raw::c_char {\n    if (*buf).size < (*buf).asize &&\n           *(*buf).data.offset((*buf).size as isize) as std::os::raw::c_int ==\n               0 as std::os::raw::c_int {\n        return (*buf).data as *mut std::os::raw::c_char\n    }\n    if (*buf).size.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) <=\n           (*buf).asize ||\n           bufgrow(buf,\n                   (*buf).size.wrapping_add(1 as std::os::raw::c_int as\n                                                std::os::raw::c_ulong)) ==\n               0 as std::os::raw::c_int {\n        *(*buf).data.offset((*buf).size as isize) =\n            0 as std::os::raw::c_int as uint8_t;\n        return (*buf).data as *mut std::os::raw::c_char\n    }\n    return 0 as *const std::os::raw::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/buffer.rs:11:1: 11:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/buffer.rs:6:1: 6:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/buffer.rs:8:1: 8:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/buffer.rs:12:1: 12:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/buffer.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:237 ~ c2rust[26e7]::src::markdown::char_entity)",
    "span": "src/markdown.rs:2734:1: 2829:2 (#0)",
    "pieces": [
      "src/markdown.rs:2734:1: 2829:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 96,
    "source": "unsafe extern \"C\" fn char_entity(mut ob: *mut buf, mut rndr: *mut sd_markdown,\n                                 mut data: *mut uint8_t,\n                                 mut max_rewind: size_t,\n                                 mut max_lookbehind: size_t, mut size: size_t)\n -> size_t {\n    let mut end: size_t = 1 as std::os::raw::c_int as size_t; /* not an entity */\n    let mut content_start: size_t = 0; /* well-formed entity */\n    let mut content_end: size_t = 0;\n    let mut work: buf =\n        {\n            let mut init =\n                buf{data: 0 as *mut uint8_t,\n                    size: 0 as std::os::raw::c_int as size_t,\n                    asize: 0 as std::os::raw::c_int as size_t,\n                    unit: 0 as std::os::raw::c_int as size_t,};\n            init\n        };\n    let mut numeric: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    let mut hex: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    let mut entity_base: std::os::raw::c_int = 0;\n    let mut entity_val: uint32_t = 0;\n    if end < size && *data.offset(end as isize) as std::os::raw::c_int == '#' as i32 {\n        numeric = 1 as std::os::raw::c_int;\n        end = end.wrapping_add(1)\n    }\n    if end < size && numeric != 0 &&\n           tolower(*data.offset(end as isize) as std::os::raw::c_int) == 'x' as i32 {\n        hex = 1 as std::os::raw::c_int;\n        end = end.wrapping_add(1)\n    }\n    content_start = end;\n    while end < size {\n        let c: std::os::raw::c_char = *data.offset(end as isize) as std::os::raw::c_char;\n        if hex != 0 {\n            if *(*__ctype_b_loc()).offset(c as std::os::raw::c_int as isize) as\n                   std::os::raw::c_int &\n                   _ISxdigit as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int\n                   == 0 {\n                break ;\n            }\n        } else if numeric != 0 {\n            if *(*__ctype_b_loc()).offset(c as std::os::raw::c_int as isize) as\n                   std::os::raw::c_int &\n                   _ISdigit as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int ==\n                   0 {\n                break ;\n            }\n        } else if *(*__ctype_b_loc()).offset(c as std::os::raw::c_int as isize) as\n                      std::os::raw::c_int &\n                      _ISalnum as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int\n                      == 0 {\n            break ;\n        }\n        end = end.wrapping_add(1)\n    }\n    content_end = end;\n    if end > content_start && end < size &&\n           *data.offset(end as isize) as std::os::raw::c_int == ';' as i32 {\n        end = end.wrapping_add(1)\n    } else { return 0 as std::os::raw::c_int as size_t }\n    /* way too long to be a valid numeric entity */\n    if numeric != 0 &&\n           content_end.wrapping_sub(content_start) > MAX_NUM_ENTITY_LEN {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    /* Validate the entity's contents */\n    if numeric != 0 {\n        if hex != 0 {\n            entity_base = 16 as std::os::raw::c_int\n        } else { entity_base = 10 as std::os::raw::c_int }\n        // This is ok because  it'll stop once it hits the ';'\n        entity_val =\n            strtol((data as *mut std::os::raw::c_char).offset(content_start as isize),\n                   0 as *mut *mut std::os::raw::c_char, entity_base) as uint32_t;\n        if is_valid_numeric_entity(entity_val) == 0 {\n            return 0 as std::os::raw::c_int as size_t\n        }\n    } else if is_allowed_named_entity(data as *const std::os::raw::c_char,\n                                      end).is_null() {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    if (*rndr).cb.entity.is_some() {\n        work.data = data;\n        work.size = end;\n        (*rndr).cb.entity.expect(\"non-null function pointer\")(ob, &mut work,\n                                                              (*rndr).opaque);\n    } else {\n        /* Necessary so we can normalize `&#X3E;` to `&#x3E;` */\n        bufputc(ob, '&' as i32);\n        if numeric != 0 { bufputc(ob, '#' as i32); }\n        if hex != 0 { bufputc(ob, 'x' as i32); }\n        bufput(ob, data.offset(content_start as isize) as *const std::os::raw::c_void,\n               end.wrapping_sub(content_start));\n    }\n    return end;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:247 ~ c2rust[26e7]::src::markdown::is_hrule)",
    "span": "src/markdown.rs:3413:1: 3442:2 (#0)",
    "pieces": [
      "src/markdown.rs:3413:1: 3442:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 37,
    "source": "unsafe extern \"C\" fn is_hrule(mut data: *mut uint8_t, mut size: size_t)\n -> std::os::raw::c_int {\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut n: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut c: uint8_t = 0;\n    /* skipping initial spaces */\n    if size < 3 as std::os::raw::c_int as std::os::raw::c_ulong { return 0 as std::os::raw::c_int }\n    if *data.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1);\n        if *data.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n               ' ' as i32 {\n            i = i.wrapping_add(1);\n            if *data.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n                   ' ' as i32 {\n                i = i.wrapping_add(1)\n            }\n        }\n    }\n    /* looking at the hrule uint8_t */\n    if i.wrapping_add(2 as std::os::raw::c_int as std::os::raw::c_ulong) >= size ||\n           *data.offset(i as isize) as std::os::raw::c_int != '*' as i32 &&\n               *data.offset(i as isize) as std::os::raw::c_int != '-' as i32 &&\n               *data.offset(i as isize) as std::os::raw::c_int != '_' as i32 {\n        return 0 as std::os::raw::c_int\n    }\n    c = *data.offset(i as isize);\n    /* the whole line must be the char or whitespace */\n    while i < size && *data.offset(i as isize) as std::os::raw::c_int != '\\n' as i32 {\n        if *data.offset(i as isize) as std::os::raw::c_int == c as std::os::raw::c_int {\n            n = n.wrapping_add(1)\n        } else if *data.offset(i as isize) as std::os::raw::c_int != ' ' as i32 {\n            return 0 as std::os::raw::c_int\n        }\n        i = i.wrapping_add(1)\n    }\n    return (n >= 3 as std::os::raw::c_int as std::os::raw::c_ulong) as std::os::raw::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:227 ~ c2rust[26e7]::src::markdown::find_emph_char)",
    "span": "src/markdown.rs:2199:1: 2296:2 (#0)",
    "pieces": [
      "src/markdown.rs:2199:1: 2296:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 98,
    "source": "unsafe extern \"C\" fn find_emph_char(mut data: *mut uint8_t, mut size: size_t,\n                                    mut c: uint8_t) -> size_t {\n    let mut i: size_t = 1 as std::os::raw::c_int as size_t;\n    while i < size {\n        while i < size &&\n                  *data.offset(i as isize) as std::os::raw::c_int != c as std::os::raw::c_int\n                  && *data.offset(i as isize) as std::os::raw::c_int != '`' as i32 &&\n                  *data.offset(i as isize) as std::os::raw::c_int != '[' as i32 {\n            i = i.wrapping_add(1)\n        }\n        if i == size { return 0 as std::os::raw::c_int as size_t }\n        if i < size && c as std::os::raw::c_int == '<' as i32 &&\n               *data.offset(i as isize) as std::os::raw::c_int == c as std::os::raw::c_int &&\n               *data.offset(i.wrapping_sub(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n                                as isize) as std::os::raw::c_int == '!' as i32 {\n            return i\n        }\n        if *data.offset(i as isize) as std::os::raw::c_int == c as std::os::raw::c_int {\n            return i\n        }\n        /* not counting escaped chars */\n        if i != 0 &&\n               *data.offset(i.wrapping_sub(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n                                as isize) as std::os::raw::c_int == '\\\\' as i32 {\n            i = i.wrapping_add(1)\n        } else if *data.offset(i as isize) as std::os::raw::c_int == '`' as i32 {\n            let mut span_nb: size_t = 0 as std::os::raw::c_int as size_t;\n            let mut bt: size_t = 0;\n            let mut tmp_i: size_t = 0 as std::os::raw::c_int as size_t;\n            /* counting the number of opening backticks */\n            while i < size &&\n                      *data.offset(i as isize) as std::os::raw::c_int == '`' as i32 {\n                i = i.wrapping_add(1);\n                span_nb = span_nb.wrapping_add(1)\n            }\n            if i >= size { return 0 as std::os::raw::c_int as size_t }\n            /* finding the matching closing sequence */\n            bt = 0 as std::os::raw::c_int as size_t;\n            while i < size && bt < span_nb {\n                if tmp_i == 0 &&\n                       *data.offset(i as isize) as std::os::raw::c_int ==\n                           c as std::os::raw::c_int {\n                    tmp_i = i\n                }\n                if *data.offset(i as isize) as std::os::raw::c_int == '`' as i32 {\n                    bt = bt.wrapping_add(1)\n                } else { bt = 0 as std::os::raw::c_int as size_t }\n                i = i.wrapping_add(1)\n            }\n            if i >= size { return tmp_i }\n        } else {\n            /* skipping a link */\n            if !(*data.offset(i as isize) as std::os::raw::c_int == '[' as i32) {\n                continue ;\n            }\n            let mut tmp_i_0: size_t = 0 as std::os::raw::c_int as size_t;\n            let mut cc: uint8_t = 0;\n            i = i.wrapping_add(1);\n            while i < size &&\n                      *data.offset(i as isize) as std::os::raw::c_int != ']' as i32 {\n                if tmp_i_0 == 0 &&\n                       *data.offset(i as isize) as std::os::raw::c_int ==\n                           c as std::os::raw::c_int {\n                    tmp_i_0 = i\n                }\n                i = i.wrapping_add(1)\n            }\n            i = i.wrapping_add(1);\n            while i < size &&\n                      (*data.offset(i as isize) as std::os::raw::c_int == ' ' as i32\n                           ||\n                           *data.offset(i as isize) as std::os::raw::c_int ==\n                               '\\n' as i32) {\n                i = i.wrapping_add(1)\n            }\n            if i >= size { return tmp_i_0 }\n            match *data.offset(i as isize) as std::os::raw::c_int {\n                91 => { cc = ']' as i32 as uint8_t }\n                40 => { cc = ')' as i32 as uint8_t }\n                _ => { if !(tmp_i_0 != 0) { continue ; } return tmp_i_0 }\n            }\n            i = i.wrapping_add(1);\n            while i < size &&\n                      *data.offset(i as isize) as std::os::raw::c_int !=\n                          cc as std::os::raw::c_int {\n                if tmp_i_0 == 0 &&\n                       *data.offset(i as isize) as std::os::raw::c_int ==\n                           c as std::os::raw::c_int {\n                    tmp_i_0 = i\n                }\n                i = i.wrapping_add(1)\n            }\n            if i >= size { return tmp_i_0 }\n            i = i.wrapping_add(1)\n        }\n    }\n    return 0 as std::os::raw::c_int as size_t;\n}",
    "calls": [
      {
        "caller": "DefId(0:281 ~ c2rust[26e7]::src::markdown::prefix_blockspoiler)",
        "span": "src/markdown.rs:3659:9: 3666:51 (#0)",
        "source": "let mut spoilerspan: size_t =\n            find_emph_char(data.offset(i as\n                                           isize).offset(1 as std::os::raw::c_int as\n                                                             isize),\n                           size.wrapping_sub(i).wrapping_sub(1 as std::os::raw::c_int\n                                                                 as\n                                                                 std::os::raw::c_ulong),\n                           '<' as i32 as uint8_t);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:254 ~ c2rust[26e7]::src::markdown::prefix_blockspoiler)",
    "span": "src/markdown.rs:3643:1: 3681:2 (#0)",
    "pieces": [
      "src/markdown.rs:3643:1: 3681:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 39,
    "source": "unsafe extern \"C\" fn prefix_blockspoiler(mut data: *mut uint8_t,\n                                         mut size: size_t) -> size_t {\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    if i < size && *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i < size && *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i < size && *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) < size &&\n           *data.offset(i as isize) as std::os::raw::c_int == '>' as i32 &&\n           *data.offset(i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) as\n                            isize) as std::os::raw::c_int == '!' as i32 {\n        let mut spoilerspan: size_t =\n            find_emph_char(data.offset(i as\n                                           isize).offset(1 as std::os::raw::c_int as\n                                                             isize),\n                           size.wrapping_sub(i).wrapping_sub(1 as std::os::raw::c_int\n                                                                 as\n                                                                 std::os::raw::c_ulong),\n                           '<' as i32 as uint8_t);\n        if i.wrapping_add(spoilerspan) < size &&\n               spoilerspan > 0 as std::os::raw::c_int as std::os::raw::c_ulong &&\n               *data.offset(i.wrapping_add(spoilerspan) as isize) as\n                   std::os::raw::c_int == '!' as i32 {\n            return 0 as std::os::raw::c_int as size_t\n        }\n        if i.wrapping_add(2 as std::os::raw::c_int as std::os::raw::c_ulong) < size &&\n               *data.offset(i.wrapping_add(2 as std::os::raw::c_int as std::os::raw::c_ulong)\n                                as isize) as std::os::raw::c_int == ' ' as i32 {\n            return i.wrapping_add(3 as std::os::raw::c_int as std::os::raw::c_ulong)\n        }\n        return i.wrapping_add(2 as std::os::raw::c_int as std::os::raw::c_ulong)\n    }\n    return 0 as std::os::raw::c_int as size_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:209 ~ c2rust[26e7]::src::markdown::is_allowed_named_entity)",
    "span": "src/markdown.rs:1028:1: 1819:2 (#0)",
    "pieces": [
      "src/markdown.rs:1028:1: 1031:4 (#0)",
      "src/markdown.rs:1803:1: 1803:4 (#0)",
      "src/markdown.rs:1819:1: 1819:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn is_allowed_named_entity(mut str: *const std::os::raw::c_char,\n                                                 mut len: size_t)\n -> *const std::os::raw::c_char {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/markdown.rs:1031:5: 1802:71 (#0)",
        "pieces": [
          "src/markdown.rs:1031:5: 1802:71 (#0)"
        ],
        "num_lines": 772,
        "source": "static mut wordlist: [*const std::os::raw::c_char; 771] =\n        [b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&or;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&not;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&int;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&psi;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&isin;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&notin;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Rho;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&phi;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&prop;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&rho;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&nbsp;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&thorn;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&thinsp;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&chi;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&prod;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&amp;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Psi;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&iota;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&omicron;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Phi;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&and;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&sdot;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&nu;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Chi;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&emsp;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Mu;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&ensp;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&ocirc;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&lt;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&uml;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&icirc;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&sup;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&sup1;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Scaron;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&cap;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&part;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&pound;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&scaron;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&ni;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&lowast;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Omicron;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&cup;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Xi;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&crarr;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Nu;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&pi;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&theta;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&tau;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&nsub;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&acirc;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&thetasym;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Ocirc;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&rarr;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&ucirc;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&loz;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&darr;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&trade;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&para;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&ecirc;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&larr;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&radic;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&sub;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Pi;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&kappa;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&iquest;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&eta;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&supe;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&rceil;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&there4;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&rArr;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&uarr;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Kappa;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&dArr;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&euro;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Theta;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&circ;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Tau;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&lceil;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&lArr;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&ordm;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&lrm;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&xi;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&acute;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&ccedil;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&sup3;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&ntilde;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&uArr;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&sup2;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&piv;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&otilde;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&shy;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Acirc;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&curren;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Ucirc;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&oacute;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&sube;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&nabla;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&iacute;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&mu;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&bull;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&oline;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Ccedil;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&sum;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&copy;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&equiv;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Ntilde;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&prime;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&atilde;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&tilde;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Ecirc;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Otilde;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&apos;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&aacute;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&ne;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Eta;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&macr;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&sim;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Oacute;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Iota;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&empty;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&uacute;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&ouml;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&exist;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&iuml;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Prime;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&eacute;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&rsquo;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&cent;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&zwj;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&zwnj;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&quot;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&sbquo;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&sect;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&infin;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&otimes;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&cong;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Icirc;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&brvbar;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&le;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&lsquo;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&ordf;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&clubs;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&oplus;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&perp;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Yacute;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&micro;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&ang;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&auml;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&gt;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&rlm;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Ouml;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&upsilon;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&minus;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&middot;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&uuml;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&aring;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Atilde;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&divide;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&rsaquo;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&epsilon;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&times;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&ETH;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&euml;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&szlig;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&frac14;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&diams;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&oslash;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Aacute;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&lsaquo;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Delta;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&rdquo;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&spades;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Uacute;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&raquo;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&rang;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&frasl;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&rfloor;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&harr;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&ndash;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Yuml;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&cedil;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&eth;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&ldquo;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&real;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&THORN;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&plusmn;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&laquo;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&lang;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&delta;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&lfloor;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&beta;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&omega;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Eacute;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Oslash;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&image;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&weierp;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Zeta;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&OElig;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&hArr;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Auml;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&asymp;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Lambda;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&bdquo;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&zeta;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Upsilon;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&lambda;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Uuml;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Aring;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&yacute;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Beta;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Gamma;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&iexcl;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&forall;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Omega;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Epsilon;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Iacute;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Euml;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&frac34;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&frac12;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&yen;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&yuml;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&ograve;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&AElig;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&igrave;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Iuml;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&alpha;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&permil;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&agrave;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&mdash;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Ograve;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&ugrave;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&upsih;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&ge;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&egrave;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&fnof;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&reg;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&deg;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Sigma;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&sigma;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Alpha;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&hearts;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&oelig;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Agrave;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Ugrave;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&hellip;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&aelig;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Egrave;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Igrave;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&gamma;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&Dagger;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&dagger;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&alefsym;\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"\\x00\" as *const u8 as *const std::os::raw::c_char,\n         b\"&sigmaf;\\x00\" as *const u8 as *const std::os::raw::c_char];",
        "sub_chunks": [],
        "live_in": [],
        "live_out": []
      },
      {
        "chunk_id": 1,
        "span": "src/markdown.rs:1803:5: 1817:25 (#0)",
        "pieces": [
          "src/markdown.rs:1803:5: 1817:25 (#0)"
        ],
        "num_lines": 16,
        "source": "if len <= MAX_WORD_LENGTH as std::os::raw::c_int as std::os::raw::c_ulong &&\n           len >= MIN_WORD_LENGTH as std::os::raw::c_int as std::os::raw::c_ulong {\n        let mut key: std::os::raw::c_uint = hash_html_entity(str, len);\n        if key <= MAX_HASH_VALUE as std::os::raw::c_int as std::os::raw::c_uint {\n            let mut s: *const std::os::raw::c_char = wordlist[key as usize];\n            if *str as std::os::raw::c_int == *s as std::os::raw::c_int &&\n                   strncmp(str.offset(1 as std::os::raw::c_int as isize),\n                           s.offset(1 as std::os::raw::c_int as isize),\n                           len.wrapping_sub(1 as std::os::raw::c_int as\n                                                std::os::raw::c_ulong)) == 0 &&\n                   *s.offset(len as isize) as std::os::raw::c_int == '\\u{0}' as i32 {\n                return s\n            }\n        }\n    }\n    return 0 as *const std::os::raw::c_char;",
        "sub_chunks": [],
        "live_in": [
          "mut str: *const i8",
          "mut len: u64"
        ],
        "live_out": [
          "mut str: *const i8",
          "mut len: u64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:248 ~ c2rust[26e7]::src::markdown::prefix_codefence)",
    "span": "src/markdown.rs:3446:1: 3483:2 (#0)",
    "pieces": [
      "src/markdown.rs:3446:1: 3483:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 38,
    "source": "unsafe extern \"C\" fn prefix_codefence(mut data: *mut uint8_t,\n                                      mut size: size_t) -> size_t {\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut n: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut c: uint8_t = 0;\n    /* skipping initial spaces */\n    if size < 3 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    if *data.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1);\n        if *data.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n               ' ' as i32 {\n            i = i.wrapping_add(1);\n            if *data.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int ==\n                   ' ' as i32 {\n                i = i.wrapping_add(1)\n            }\n        }\n    }\n    /* looking at the hrule uint8_t */\n    if i.wrapping_add(2 as std::os::raw::c_int as std::os::raw::c_ulong) >= size ||\n           !(*data.offset(i as isize) as std::os::raw::c_int == '~' as i32 ||\n                 *data.offset(i as isize) as std::os::raw::c_int == '`' as i32) {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    c = *data.offset(i as isize);\n    /* the whole line must be the uint8_t or whitespace */\n    while i < size &&\n              *data.offset(i as isize) as std::os::raw::c_int == c as std::os::raw::c_int {\n        n = n.wrapping_add(1);\n        i = i.wrapping_add(1)\n    }\n    if n < 3 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    return i;\n}",
    "calls": [
      {
        "caller": "DefId(0:276 ~ c2rust[26e7]::src::markdown::is_codefence)",
        "span": "src/markdown.rs:3490:5: 3490:38 (#0)",
        "source": "i = prefix_codefence(data, size);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:249 ~ c2rust[26e7]::src::markdown::is_codefence)",
    "span": "src/markdown.rs:3485:1: 3547:2 (#0)",
    "pieces": [
      "src/markdown.rs:3485:1: 3547:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 63,
    "source": "unsafe extern \"C\" fn is_codefence(mut data: *mut uint8_t, mut size: size_t,\n                                  mut syntax: *mut buf) -> size_t {\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut syn_len: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut syn_start: *mut uint8_t = 0 as *mut uint8_t;\n    i = prefix_codefence(data, size);\n    if i == 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    while i < size && *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1)\n    }\n    syn_start = data.offset(i as isize);\n    if i < size && *data.offset(i as isize) as std::os::raw::c_int == '{' as i32 {\n        i = i.wrapping_add(1);\n        syn_start = syn_start.offset(1);\n        while i < size &&\n                  *data.offset(i as isize) as std::os::raw::c_int != '}' as i32 &&\n                  *data.offset(i as isize) as std::os::raw::c_int != '\\n' as i32 {\n            syn_len = syn_len.wrapping_add(1);\n            i = i.wrapping_add(1)\n        }\n        if i == size || *data.offset(i as isize) as std::os::raw::c_int != '}' as i32\n           {\n            return 0 as std::os::raw::c_int as size_t\n        }\n        /* strip all whitespace at the beginning and the end\n\t\t * of the {} block */\n        while syn_len > 0 as std::os::raw::c_int as std::os::raw::c_ulong &&\n                  _isspace(*syn_start.offset(0 as std::os::raw::c_int as isize) as\n                               std::os::raw::c_int) != 0 {\n            syn_start = syn_start.offset(1);\n            syn_len = syn_len.wrapping_sub(1)\n        }\n        while syn_len > 0 as std::os::raw::c_int as std::os::raw::c_ulong &&\n                  _isspace(*syn_start.offset(syn_len.wrapping_sub(1 as\n                                                                      std::os::raw::c_int\n                                                                      as\n                                                                      std::os::raw::c_ulong)\n                                                 as isize) as std::os::raw::c_int) !=\n                      0 {\n            syn_len = syn_len.wrapping_sub(1)\n        }\n        i = i.wrapping_add(1)\n    } else {\n        while i < size &&\n                  _isspace(*data.offset(i as isize) as std::os::raw::c_int) == 0 {\n            syn_len = syn_len.wrapping_add(1);\n            i = i.wrapping_add(1)\n        }\n    }\n    if !syntax.is_null() {\n        (*syntax).data = syn_start;\n        (*syntax).size = syn_len\n    }\n    while i < size && *data.offset(i as isize) as std::os::raw::c_int != '\\n' as i32 {\n        if _isspace(*data.offset(i as isize) as std::os::raw::c_int) == 0 {\n            return 0 as std::os::raw::c_int as size_t\n        }\n        i = i.wrapping_add(1)\n    }\n    return i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:288 ~ c2rust[26e7]::src::markdown::parse_fencedcode)",
        "span": "src/markdown.rs:4054:5: 4054:47 (#0)",
        "source": "beg = is_codefence(data, size, &mut lang);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:60 ~ c2rust[26e7]::src::buffer::bufprefix)",
    "span": "src/buffer.rs:42:1: 58:2 (#0)",
    "pieces": [
      "src/buffer.rs:42:1: 58:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 18,
    "source": "pub unsafe extern \"C\" fn bufprefix(mut buf: *const buf,\n                                   mut prefix: *const std::os::raw::c_char)\n -> std::os::raw::c_int {\n    let mut i: size_t = 0;\n    i = 0 as std::os::raw::c_int as size_t;\n    while i < (*buf).size {\n        if *prefix.offset(i as isize) as std::os::raw::c_int == 0 as std::os::raw::c_int {\n            return 0 as std::os::raw::c_int\n        }\n        if *(*buf).data.offset(i as isize) as std::os::raw::c_int !=\n               *prefix.offset(i as isize) as std::os::raw::c_int {\n            return *(*buf).data.offset(i as isize) as std::os::raw::c_int -\n                       *prefix.offset(i as isize) as std::os::raw::c_int\n        }\n        i = i.wrapping_add(1)\n    }\n    return 0 as std::os::raw::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/buffer.rs:6:1: 6:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/buffer.rs:8:1: 8:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/buffer.rs:12:1: 12:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/buffer.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/buffer.rs:11:1: 11:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:261 ~ c2rust[26e7]::src::markdown::parse_fencedcode)",
    "span": "src/markdown.rs:4038:1: 4121:2 (#0)",
    "pieces": [
      "src/markdown.rs:4038:1: 4121:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 84,
    "source": "unsafe extern \"C\" fn parse_fencedcode(mut ob: *mut buf,\n                                      mut rndr: *mut sd_markdown,\n                                      mut data: *mut uint8_t,\n                                      mut size: size_t) -> size_t {\n    let mut beg: size_t = 0;\n    let mut end: size_t = 0;\n    let mut work: *mut buf = 0 as *mut buf;\n    let mut lang: buf =\n        {\n            let mut init =\n                buf{data: 0 as *mut uint8_t,\n                    size: 0 as std::os::raw::c_int as size_t,\n                    asize: 0 as std::os::raw::c_int as size_t,\n                    unit: 0 as std::os::raw::c_int as size_t,};\n            init\n        };\n    beg = is_codefence(data, size, &mut lang);\n    if beg == 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    work = rndr_newbuf(rndr, 0 as std::os::raw::c_int);\n    while beg < size {\n        let mut fence_end: size_t = 0;\n        let mut fence_trail: buf =\n            {\n                let mut init =\n                    buf{data: 0 as *mut uint8_t,\n                        size: 0 as std::os::raw::c_int as size_t,\n                        asize: 0 as std::os::raw::c_int as size_t,\n                        unit: 0 as std::os::raw::c_int as size_t,};\n                init\n            };\n        fence_end =\n            is_codefence(data.offset(beg as isize), size.wrapping_sub(beg),\n                         &mut fence_trail);\n        if fence_end != 0 as std::os::raw::c_int as std::os::raw::c_ulong &&\n               fence_trail.size == 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n            beg =\n                (beg as std::os::raw::c_ulong).wrapping_add(fence_end) as size_t as\n                    size_t;\n            break ;\n        } else {\n            end = beg.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong);\n            while end < size &&\n                      *data.offset(end.wrapping_sub(1 as std::os::raw::c_int as\n                                                        std::os::raw::c_ulong) as\n                                       isize) as std::os::raw::c_int != '\\n' as i32 {\n                end = end.wrapping_add(1)\n            }\n            if beg < end {\n                /* verbatim copy to the working buffer,\n\t\t\t\tescaping entities */\n                if is_empty(data.offset(beg as isize), end.wrapping_sub(beg))\n                       != 0 {\n                    bufputc(work, '\\n' as i32); /* skipping prefix */\n                } else {\n                    bufput(work,\n                           data.offset(beg as isize) as *const std::os::raw::c_void,\n                           end.wrapping_sub(beg));\n                }\n            }\n            beg = end\n        }\n    }\n    if (*work).size != 0 &&\n           *(*work).data.offset((*work).size.wrapping_sub(1 as std::os::raw::c_int as\n                                                              std::os::raw::c_ulong)\n                                    as isize) as std::os::raw::c_int != '\\n' as i32 {\n        bufputc(work, '\\n' as i32);\n    }\n    if (*rndr).cb.blockcode.is_some() {\n        (*rndr).cb.blockcode.expect(\"non-null function pointer\")(ob, work,\n                                                                 if lang.size\n                                                                        != 0 {\n                                                                     &mut lang\n                                                                 } else {\n                                                                     0 as\n                                                                         *mut buf\n                                                                 },\n                                                                 (*rndr).opaque);\n    }\n    rndr_popbuf(rndr, 0 as std::os::raw::c_int);\n    return beg;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:256 ~ c2rust[26e7]::src::markdown::prefix_oli)",
    "span": "src/markdown.rs:3699:1: 3730:2 (#0)",
    "pieces": [
      "src/markdown.rs:3699:1: 3730:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 32,
    "source": "unsafe extern \"C\" fn prefix_oli(mut data: *mut uint8_t, mut size: size_t)\n -> size_t {\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    if i < size && *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i < size && *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i < size && *data.offset(i as isize) as std::os::raw::c_int == ' ' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i >= size || (*data.offset(i as isize) as std::os::raw::c_int) < '0' as i32 ||\n           *data.offset(i as isize) as std::os::raw::c_int > '9' as i32 {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    while i < size && *data.offset(i as isize) as std::os::raw::c_int >= '0' as i32 &&\n              *data.offset(i as isize) as std::os::raw::c_int <= '9' as i32 {\n        i = i.wrapping_add(1)\n    }\n    if i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) >= size ||\n           *data.offset(i as isize) as std::os::raw::c_int != '.' as i32 ||\n           *data.offset(i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) as\n                            isize) as std::os::raw::c_int != ' ' as i32 {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    if is_next_headerline(data.offset(i as isize), size.wrapping_sub(i)) != 0\n       {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    return i.wrapping_add(2 as std::os::raw::c_int as std::os::raw::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:290 ~ c2rust[26e7]::src::markdown::parse_listitem)",
        "span": "src/markdown.rs:4205:17: 4205:49 (#0)",
        "source": "{ beg = prefix_oli(data, size) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:263 ~ c2rust[26e7]::src::markdown::parse_listitem)",
    "span": "src/markdown.rs:4184:1: 4328:2 (#0)",
    "pieces": [
      "src/markdown.rs:4184:1: 4328:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 145,
    "source": "unsafe extern \"C\" fn parse_listitem(mut ob: *mut buf,\n                                    mut rndr: *mut sd_markdown,\n                                    mut data: *mut uint8_t, mut size: size_t,\n                                    mut flags: *mut std::os::raw::c_int) -> size_t {\n    let mut work: *mut buf = 0 as *mut buf;\n    let mut inter: *mut buf = 0 as *mut buf;\n    let mut beg: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut end: size_t = 0;\n    let mut pre: size_t = 0;\n    let mut sublist: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut orgpre: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut i: size_t = 0;\n    let mut in_empty: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    let mut has_inside_empty: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    let mut in_fence: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    /* keeping track of the first indentation prefix */\n    while orgpre < 3 as std::os::raw::c_int as std::os::raw::c_ulong && orgpre < size &&\n              *data.offset(orgpre as isize) as std::os::raw::c_int == ' ' as i32 {\n        orgpre = orgpre.wrapping_add(1)\n    }\n    beg = prefix_uli(data, size);\n    if beg == 0 { beg = prefix_oli(data, size) }\n    if beg == 0 { return 0 as std::os::raw::c_int as size_t }\n    /* skipping to the beginning of the following line */\n    end = beg;\n    while end < size &&\n              *data.offset(end.wrapping_sub(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n                               as isize) as std::os::raw::c_int != '\\n' as i32 {\n        end = end.wrapping_add(1)\n    }\n    /* getting working buffers */\n    work = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n    inter = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n    /* putting the first line into the working buffer */\n    bufput(work, data.offset(beg as isize) as *const std::os::raw::c_void,\n           end.wrapping_sub(beg));\n    beg = end;\n    /* process the following lines */\n    while beg < size {\n        let mut has_next_uli: size_t = 0 as std::os::raw::c_int as size_t;\n        let mut has_next_oli: size_t = 0 as std::os::raw::c_int as size_t;\n        end = end.wrapping_add(1);\n        while end < size &&\n                  *data.offset(end.wrapping_sub(1 as std::os::raw::c_int as\n                                                    std::os::raw::c_ulong) as isize)\n                      as std::os::raw::c_int != '\\n' as i32 {\n            end = end.wrapping_add(1)\n        }\n        /* process an empty line */\n        if is_empty(data.offset(beg as isize), end.wrapping_sub(beg)) != 0 {\n            in_empty = 1 as std::os::raw::c_int;\n            beg = end\n        } else {\n            /* calculating the indentation */\n            i = 0 as std::os::raw::c_int as size_t;\n            while i < 4 as std::os::raw::c_int as std::os::raw::c_ulong &&\n                      beg.wrapping_add(i) < end &&\n                      *data.offset(beg.wrapping_add(i) as isize) as\n                          std::os::raw::c_int == ' ' as i32 {\n                i = i.wrapping_add(1)\n            }\n            pre = i;\n            if (*rndr).ext_flags &\n                   MKDEXT_FENCED_CODE as std::os::raw::c_int as std::os::raw::c_uint != 0 {\n                if is_codefence(data.offset(beg as isize).offset(i as isize),\n                                end.wrapping_sub(beg).wrapping_sub(i),\n                                0 as *mut buf) !=\n                       0 as std::os::raw::c_int as std::os::raw::c_ulong {\n                    in_fence = (in_fence == 0) as std::os::raw::c_int\n                }\n            }\n            /* Only check for new list items if we are **not** inside\n\t\t * a fenced code block */\n            if in_fence == 0 {\n                has_next_uli =\n                    prefix_uli(data.offset(beg as isize).offset(i as isize),\n                               end.wrapping_sub(beg).wrapping_sub(i));\n                has_next_oli =\n                    prefix_oli(data.offset(beg as isize).offset(i as isize),\n                               end.wrapping_sub(beg).wrapping_sub(i))\n            }\n            /* checking for ul/ol switch */\n            if in_empty != 0 &&\n                   (*flags & 1 as std::os::raw::c_int != 0 && has_next_uli != 0 ||\n                        *flags & 1 as std::os::raw::c_int == 0 && has_next_oli != 0) {\n                *flags |= 8 as std::os::raw::c_int;\n                break ;\n                /* the following item must have same list type */\n            } else {\n                /* checking for a new item */\n                if has_next_uli != 0 &&\n                       is_hrule(data.offset(beg as isize).offset(i as isize),\n                                end.wrapping_sub(beg).wrapping_sub(i)) == 0 ||\n                       has_next_oli != 0 {\n                    if in_empty != 0 {\n                        has_inside_empty = 1 as std::os::raw::c_int\n                    } /* the same indentation */\n                    if pre == orgpre { break ; }\n                    if sublist == 0 { sublist = (*work).size }\n                } else if in_empty != 0 &&\n                              pre == 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n                    *flags |= 8 as std::os::raw::c_int;\n                    break ;\n                } else if in_empty != 0 {\n                    bufputc(work, '\\n' as i32);\n                    has_inside_empty = 1 as std::os::raw::c_int\n                }\n                in_empty = 0 as std::os::raw::c_int;\n                /* joining only indented stuff after empty lines;\n\t\t * note that now we only require 1 space of indentation\n\t\t * to continue a list */\n                /* adding the line without prefix into the working buffer */\n                bufput(work,\n                       data.offset(beg as isize).offset(i as isize) as\n                           *const std::os::raw::c_void,\n                       end.wrapping_sub(beg).wrapping_sub(i));\n                beg = end\n            }\n        }\n    }\n    /* render of li contents */\n    if has_inside_empty != 0 { *flags |= 2 as std::os::raw::c_int }\n    if *flags & 2 as std::os::raw::c_int != 0 {\n        /* intermediate render of block li */\n        if sublist != 0 && sublist < (*work).size {\n            parse_block(inter, rndr, (*work).data, sublist);\n            parse_block(inter, rndr, (*work).data.offset(sublist as isize),\n                        (*work).size.wrapping_sub(sublist));\n        } else { parse_block(inter, rndr, (*work).data, (*work).size); }\n    } else if sublist != 0 && sublist < (*work).size {\n        parse_inline(inter, rndr, (*work).data, sublist);\n        parse_block(inter, rndr, (*work).data.offset(sublist as isize),\n                    (*work).size.wrapping_sub(sublist));\n    } else { parse_inline(inter, rndr, (*work).data, (*work).size); }\n    /* intermediate render of inline li */\n    /* render of li itself */\n    if (*rndr).cb.listitem.is_some() {\n        (*rndr).cb.listitem.expect(\"non-null function pointer\")(ob, inter,\n                                                                *flags,\n                                                                (*rndr).opaque);\n    }\n    rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n    rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n    return beg;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:290 ~ c2rust[26e7]::src::stack::stack_free)",
    "span": "src/stack.rs:41:1: 62:2 (#0)",
    "pieces": [
      "src/stack.rs:41:1: 62:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn stack_free(mut st: *mut stack) {\n    if st.is_null() { return }\n    free((*st).item as *mut std::os::raw::c_void);\n    (*st).item = 0 as *mut *mut std::os::raw::c_void;\n    (*st).size = 0 as std::os::raw::c_int as size_t;\n    (*st).asize = 0 as std::os::raw::c_int as size_t;\n}",
    "calls": [
      {
        "caller": "DefId(0:307 ~ c2rust[26e7]::src::markdown::sd_markdown_free)",
        "span": "src/markdown.rs:5380:5: 5380:38 (#0)",
        "source": "stack_free(&mut md.work_bufs[1]);"
      },
      {
        "caller": "DefId(0:307 ~ c2rust[26e7]::src::markdown::sd_markdown_free)",
        "span": "src/markdown.rs:5381:5: 5381:38 (#0)",
        "source": "stack_free(&mut md.work_bufs[0]);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/stack.rs:4:1: 4:26 (#0)",
        "source": "use std::os::raw::c_void;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:280 ~ c2rust[26e7]::src::markdown::sd_markdown_free)",
    "span": "src/markdown.rs:5369:1: 5382:2 (#0)",
    "pieces": [
      "src/markdown.rs:5369:1: 5382:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 22,
    "source": "pub unsafe extern \"C\" fn sd_markdown_free(mut md: *mut sd_markdown) {\n    let mut i: size_t = 0;\n    i = 0 as std::os::raw::c_int as size_t;\n    while i < (*md).work_bufs[1 as std::os::raw::c_int as usize].asize {\n        bufrelease(*(*md).work_bufs[1 as std::os::raw::c_int as\n                                        usize].item.offset(i as isize) as\n                       *mut buf);\n        i = i.wrapping_add(1)\n    }\n    i = 0 as std::os::raw::c_int as size_t;\n    while i < (*md).work_bufs[0 as std::os::raw::c_int as usize].asize {\n        bufrelease(*(*md).work_bufs[0 as std::os::raw::c_int as\n                                        usize].item.offset(i as isize) as\n                       *mut buf);\n        i = i.wrapping_add(1)\n    }\n    stack_free(&mut *(*md).work_bufs.as_mut_ptr().offset(1 as std::os::raw::c_int as\n                                                             isize));\n    stack_free(&mut *(*md).work_bufs.as_mut_ptr().offset(0 as std::os::raw::c_int as\n                                                             isize));\n    free(md as *mut std::os::raw::c_void);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:231 ~ c2rust[26e7]::src::markdown::parse_spoilerspan)",
    "span": "src/markdown.rs:2473:1: 2510:2 (#0)",
    "pieces": [
      "src/markdown.rs:2473:1: 2510:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 38,
    "source": "unsafe extern \"C\" fn parse_spoilerspan(mut ob: *mut buf,\n                                       mut rndr: *mut sd_markdown,\n                                       mut data: *mut uint8_t,\n                                       mut size: size_t) -> size_t {\n    let mut render_method:\n            Option<unsafe extern \"C\" fn(_: *mut buf, _: *const buf,\n                                        _: *mut std::os::raw::c_void)\n                       -> std::os::raw::c_int> = None;\n    let mut len: size_t = 0;\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut work: *mut buf = 0 as *mut buf;\n    let mut r: std::os::raw::c_int = 0;\n    render_method = (*rndr).cb.spoilerspan;\n    if render_method.is_none() { return 0 as std::os::raw::c_int as size_t }\n    while i < size {\n        len =\n            find_emph_char(data.offset(i as isize), size.wrapping_sub(i),\n                           '<' as i32 as uint8_t);\n        if len == 0 { return 0 as std::os::raw::c_int as size_t }\n        i = (i as std::os::raw::c_ulong).wrapping_add(len) as size_t as size_t;\n        if i < size && *data.offset(i as isize) as std::os::raw::c_int == '<' as i32\n               &&\n               *data.offset(i.wrapping_sub(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n                                as isize) as std::os::raw::c_int == '!' as i32 {\n            work = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n            parse_inline(work, rndr, data,\n                         i.wrapping_sub(1 as std::os::raw::c_int as std::os::raw::c_ulong));\n            r =\n                render_method.expect(\"non-null function pointer\")(ob, work,\n                                                                  (*rndr).opaque);\n            rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n            if r == 0 { return 0 as std::os::raw::c_int as size_t }\n            return i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n        }\n        i = i.wrapping_add(1)\n    }\n    return 0 as std::os::raw::c_int as size_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:40 ~ c2rust[26e7]::src::autolink::sd_autolink__email)",
    "span": "src/autolink.rs:357:1: 423:2 (#0)",
    "pieces": [
      "src/autolink.rs:357:1: 423:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 67,
    "source": "pub unsafe extern \"C\" fn sd_autolink__email(mut rewind_p: *mut size_t,\n                                            mut link: *mut buf,\n                                            mut data: *mut uint8_t,\n                                            mut max_rewind: size_t,\n                                            mut size: size_t,\n                                            mut flags: std::os::raw::c_uint)\n -> size_t {\n    let mut link_end: size_t = 0;\n    let mut rewind: size_t = 0;\n    let mut nb: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    let mut np: std::os::raw::c_int = 0 as std::os::raw::c_int;\n    rewind = 0 as std::os::raw::c_int as size_t;\n    while rewind < max_rewind {\n        let mut c: uint8_t =\n            *data.offset(rewind.wrapping_neg().wrapping_sub(1 as std::os::raw::c_int\n                                                                as\n                                                                std::os::raw::c_ulong)\n                             as isize);\n        if c as std::os::raw::c_int == 0 as std::os::raw::c_int { break ; }\n        if !(*(*__ctype_b_loc()).offset(c as std::os::raw::c_int as isize) as\n                 std::os::raw::c_int &\n                 _ISalnum as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int !=\n                 0) {\n            if strchr(b\".+-_\\x00\" as *const u8 as *const std::os::raw::c_char,\n                      c as std::os::raw::c_int).is_null() {\n                break ;\n            }\n        }\n        rewind = rewind.wrapping_add(1)\n    }\n    if rewind == 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    link_end = 0 as std::os::raw::c_int as size_t;\n    while link_end < size {\n        let mut c_0: uint8_t = *data.offset(link_end as isize);\n        if !(*(*__ctype_b_loc()).offset(c_0 as std::os::raw::c_int as isize) as\n                 std::os::raw::c_int &\n                 _ISalnum as std::os::raw::c_int as std::os::raw::c_ushort as std::os::raw::c_int !=\n                 0) {\n            if c_0 as std::os::raw::c_int == '@' as i32 {\n                nb += 1\n            } else if c_0 as std::os::raw::c_int == '.' as i32 &&\n                          link_end <\n                              size.wrapping_sub(1 as std::os::raw::c_int as\n                                                    std::os::raw::c_ulong) {\n                np += 1\n            } else if c_0 as std::os::raw::c_int != '-' as i32 &&\n                          c_0 as std::os::raw::c_int != '_' as i32 {\n                break ;\n            }\n        }\n        link_end = link_end.wrapping_add(1)\n    }\n    if link_end < 2 as std::os::raw::c_int as std::os::raw::c_ulong || nb != 1 as std::os::raw::c_int\n           || np == 0 as std::os::raw::c_int {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    link_end = autolink_delim(data, link_end, max_rewind, size);\n    if link_end == 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    bufput(link, data.offset(-(rewind as isize)) as *const std::os::raw::c_void,\n           link_end.wrapping_add(rewind));\n    *rewind_p = rewind;\n    return link_end;\n}",
    "calls": [
      {
        "caller": "DefId(0:269 ~ c2rust[26e7]::src::markdown::char_autolink_email)",
        "span": "src/markdown.rs:2996:5: 2998:78 (#0)",
        "source": "link_len =\n        sd_autolink__email(&mut rewind, link, data, max_rewind, size,\n                           0 as std::os::raw::c_int as std::os::raw::c_uint);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/autolink.rs:19:1: 19:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:245 ~ c2rust[26e7]::src::markdown::char_superscript)",
    "span": "src/markdown.rs:3347:1: 3395:2 (#0)",
    "pieces": [
      "src/markdown.rs:3347:1: 3395:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 49,
    "source": "unsafe extern \"C\" fn char_superscript(mut ob: *mut buf,\n                                      mut rndr: *mut sd_markdown,\n                                      mut data: *mut uint8_t,\n                                      mut max_rewind: size_t,\n                                      mut max_lookbehind: size_t,\n                                      mut size: size_t) -> size_t {\n    let mut sup_start: size_t = 0;\n    let mut sup_len: size_t = 0;\n    let mut sup: *mut buf = 0 as *mut buf;\n    if (*rndr).cb.superscript.is_none() { return 0 as std::os::raw::c_int as size_t }\n    if size < 2 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    if *data.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int == '(' as i32 {\n        sup_len = 2 as std::os::raw::c_int as size_t;\n        sup_start = sup_len;\n        while sup_len < size &&\n                  *data.offset(sup_len as isize) as std::os::raw::c_int != ')' as i32\n                  &&\n                  *data.offset(sup_len.wrapping_sub(1 as std::os::raw::c_int as\n                                                        std::os::raw::c_ulong) as\n                                   isize) as std::os::raw::c_int != '\\\\' as i32 {\n            sup_len = sup_len.wrapping_add(1)\n        }\n        if sup_len == size { return 0 as std::os::raw::c_int as size_t }\n    } else {\n        sup_len = 1 as std::os::raw::c_int as size_t;\n        sup_start = sup_len;\n        while sup_len < size &&\n                  _isspace(*data.offset(sup_len as isize) as std::os::raw::c_int) == 0\n              {\n            sup_len = sup_len.wrapping_add(1)\n        }\n    }\n    if sup_len.wrapping_sub(sup_start) == 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        return if sup_start == 2 as std::os::raw::c_int as std::os::raw::c_ulong {\n                   3 as std::os::raw::c_int\n               } else { 0 as std::os::raw::c_int } as size_t\n    }\n    sup = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n    parse_inline(sup, rndr, data.offset(sup_start as isize),\n                 sup_len.wrapping_sub(sup_start));\n    (*rndr).cb.superscript.expect(\"non-null function pointer\")(ob, sup,\n                                                               (*rndr).opaque);\n    rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n    return if sup_start == 2 as std::os::raw::c_int as std::os::raw::c_ulong {\n               sup_len.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n           } else { sup_len };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:230 ~ c2rust[26e7]::src::markdown::parse_emph3)",
    "span": "src/markdown.rs:2406:1: 2472:2 (#0)",
    "pieces": [
      "src/markdown.rs:2406:1: 2472:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 67,
    "source": "unsafe extern \"C\" fn parse_emph3(mut ob: *mut buf, mut rndr: *mut sd_markdown,\n                                 mut data: *mut uint8_t, mut size: size_t,\n                                 mut c: uint8_t) -> size_t {\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut len: size_t = 0;\n    let mut r: std::os::raw::c_int = 0;\n    while i < size {\n        len =\n            find_emph_char(data.offset(i as isize), size.wrapping_sub(i), c);\n        if len == 0 { return 0 as std::os::raw::c_int as size_t }\n        i = (i as std::os::raw::c_ulong).wrapping_add(len) as size_t as size_t;\n        /* skip whitespace preceded symbols */\n        if *data.offset(i as isize) as std::os::raw::c_int != c as std::os::raw::c_int ||\n               _isspace(*data.offset(i.wrapping_sub(1 as std::os::raw::c_int as\n                                                        std::os::raw::c_ulong) as\n                                         isize) as std::os::raw::c_int) != 0 {\n            continue ;\n        }\n        if i.wrapping_add(2 as std::os::raw::c_int as std::os::raw::c_ulong) < size &&\n               *data.offset(i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n                                as isize) as std::os::raw::c_int == c as std::os::raw::c_int\n               &&\n               *data.offset(i.wrapping_add(2 as std::os::raw::c_int as std::os::raw::c_ulong)\n                                as isize) as std::os::raw::c_int == c as std::os::raw::c_int\n               && (*rndr).cb.triple_emphasis.is_some() {\n            /* triple symbol found */\n            let mut work: *mut buf = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n            parse_inline(work, rndr, data, i);\n            r =\n                (*rndr).cb.triple_emphasis.expect(\"non-null function pointer\")(ob,\n                                                                               work,\n                                                                               (*rndr).opaque);\n            rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n            return if r != 0 {\n                       i.wrapping_add(3 as std::os::raw::c_int as std::os::raw::c_ulong)\n                   } else { 0 as std::os::raw::c_int as std::os::raw::c_ulong }\n        } else if i.wrapping_add(1 as std::os::raw::c_int as std::os::raw::c_ulong) < size &&\n                      *data.offset(i.wrapping_add(1 as std::os::raw::c_int as\n                                                      std::os::raw::c_ulong) as isize)\n                          as std::os::raw::c_int == c as std::os::raw::c_int {\n            /* double symbol found, handing over to emph1 */\n            len =\n                parse_emph1(ob, rndr,\n                            data.offset(-(2 as std::os::raw::c_int as isize)),\n                            size.wrapping_add(2 as std::os::raw::c_int as\n                                                  std::os::raw::c_ulong), c);\n            if len == 0 {\n                return 0 as std::os::raw::c_int as size_t\n            } else {\n                return len.wrapping_sub(2 as std::os::raw::c_int as std::os::raw::c_ulong)\n            }\n        } else {\n            /* single symbol found, handing over to emph2 */\n            len =\n                parse_emph2(ob, rndr,\n                            data.offset(-(1 as std::os::raw::c_int as isize)),\n                            size.wrapping_add(1 as std::os::raw::c_int as\n                                                  std::os::raw::c_ulong), c);\n            if len == 0 {\n                return 0 as std::os::raw::c_int as size_t\n            } else {\n                return len.wrapping_sub(1 as std::os::raw::c_int as std::os::raw::c_ulong)\n            }\n        }\n    }\n    return 0 as std::os::raw::c_int as size_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:68 ~ c2rust[26e7]::src::buffer::bufreset)",
    "span": "src/buffer.rs:173:1: 182:2 (#0)",
    "pieces": [
      "src/buffer.rs:173:1: 182:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn bufreset(mut buf: *mut buf) {\n    if buf.is_null() { return }\n    free((*buf).data as *mut std::os::raw::c_void);\n    (*buf).data = 0 as *mut uint8_t;\n    (*buf).asize = 0 as std::os::raw::c_int as size_t;\n    (*buf).size = (*buf).asize;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/buffer.rs:8:1: 8:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/buffer.rs:6:1: 6:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/buffer.rs:11:1: 11:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/buffer.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/buffer.rs:12:1: 12:16 (#0)",
        "source": "use std::alloc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:235 ~ c2rust[26e7]::src::markdown::char_escape)",
    "span": "src/markdown.rs:2696:1: 2732:2 (#0)",
    "pieces": [
      "src/markdown.rs:2696:1: 2732:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 37,
    "source": "unsafe extern \"C\" fn char_escape(mut ob: *mut buf, mut rndr: *mut sd_markdown,\n                                 mut data: *mut uint8_t,\n                                 mut max_rewind: size_t,\n                                 mut max_lookbehind: size_t, mut size: size_t)\n -> size_t {\n    static mut escape_chars: *const std::os::raw::c_char =\n        b\"\\\\`*_{}[]()#+-.!:|&<>/^~\\x00\" as *const u8 as *const std::os::raw::c_char;\n    let mut work: buf =\n        {\n            let mut init =\n                buf{data: 0 as *mut uint8_t,\n                    size: 0 as std::os::raw::c_int as size_t,\n                    asize: 0 as std::os::raw::c_int as size_t,\n                    unit: 0 as std::os::raw::c_int as size_t,};\n            init\n        };\n    if size > 1 as std::os::raw::c_int as std::os::raw::c_ulong {\n        if strchr(escape_chars,\n                  *data.offset(1 as std::os::raw::c_int as isize) as\n                      std::os::raw::c_int).is_null() {\n            return 0 as std::os::raw::c_int as size_t\n        }\n        if (*rndr).cb.normal_text.is_some() {\n            work.data = data.offset(1 as std::os::raw::c_int as isize);\n            work.size = 1 as std::os::raw::c_int as size_t;\n            (*rndr).cb.normal_text.expect(\"non-null function pointer\")(ob,\n                                                                       &mut work,\n                                                                       (*rndr).opaque);\n        } else {\n            bufputc(ob,\n                    *data.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int);\n        }\n    } else if size == 1 as std::os::raw::c_int as std::os::raw::c_ulong {\n        bufputc(ob, *data.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int);\n    }\n    return 2 as std::os::raw::c_int as size_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:274 ~ c2rust[26e7]::src::markdown::expand_tabs)",
    "span": "src/markdown.rs:5149:1: 5174:2 (#0)",
    "pieces": [
      "src/markdown.rs:5149:1: 5174:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 26,
    "source": "unsafe extern \"C\" fn expand_tabs(mut ob: *mut buf, mut line: *const uint8_t,\n                                 mut size: size_t) {\n    let mut i: size_t = 0 as std::os::raw::c_int as size_t;\n    let mut tab: size_t = 0 as std::os::raw::c_int as size_t;\n    while i < size {\n        let mut org: size_t = i;\n        while i < size &&\n                  *line.offset(i as isize) as std::os::raw::c_int != '\\t' as i32 {\n            i = i.wrapping_add(1);\n            tab = tab.wrapping_add(1)\n        }\n        if i > org {\n            bufput(ob, line.offset(org as isize) as *const std::os::raw::c_void,\n                   i.wrapping_sub(org));\n        }\n        if i >= size { break ; }\n        loop  {\n            bufputc(ob, ' ' as i32);\n            tab = tab.wrapping_add(1);\n            if !(tab.wrapping_rem(4 as std::os::raw::c_int as std::os::raw::c_ulong) != 0) {\n                break ;\n            }\n        }\n        i = i.wrapping_add(1)\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:242 ~ c2rust[26e7]::src::markdown::char_autolink_email)",
    "span": "src/markdown.rs:2983:1: 3008:2 (#0)",
    "pieces": [
      "src/markdown.rs:2983:1: 3008:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 25,
    "source": "unsafe extern \"C\" fn char_autolink_email(mut ob: *mut buf,\n                                         mut rndr: *mut sd_markdown,\n                                         mut data: *mut uint8_t,\n                                         mut max_rewind: size_t,\n                                         mut max_lookbehind: size_t,\n                                         mut size: size_t) -> size_t {\n    let mut link: *mut buf = 0 as *mut buf;\n    let mut link_len: size_t = 0;\n    let mut rewind: size_t = 0;\n    if (*rndr).cb.autolink.is_none() || (*rndr).in_link_body != 0 {\n        return 0 as std::os::raw::c_int as size_t\n    }\n    link = rndr_newbuf(rndr, 1 as std::os::raw::c_int);\n    link_len =\n        sd_autolink__email(&mut rewind, link, data, max_rewind, size,\n                           0 as std::os::raw::c_int as std::os::raw::c_uint);\n    if link_len > 0 as std::os::raw::c_int as std::os::raw::c_ulong {\n        buftruncate(ob, (*ob).size.wrapping_sub(rewind));\n        (*rndr).cb.autolink.expect(\"non-null function pointer\")(ob, link,\n                                                                MKDA_EMAIL,\n                                                                (*rndr).opaque);\n    }\n    rndr_popbuf(rndr, 1 as std::os::raw::c_int);\n    return link_len;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/markdown.rs:164:1: 164:40 (#0)",
        "source": "pub const MKDA_EMAIL: mkd_autolink = 2;"
      }
    ],
    "imports": [
      {
        "span": "src/markdown.rs:151:1: 151:41 (#0)",
        "source": "pub use crate::src::buffer::buftruncate;"
      },
      {
        "span": "src/markdown.rs:152:1: 152:39 (#0)",
        "source": "pub use crate::src::stack::stack_free;"
      },
      {
        "span": "src/markdown.rs:153:1: 153:39 (#0)",
        "source": "pub use crate::src::stack::stack_init;"
      },
      {
        "span": "src/markdown.rs:154:1: 154:39 (#0)",
        "source": "pub use crate::src::stack::stack_push;"
      },
      {
        "span": "src/markdown.rs:19:1: 19:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/markdown.rs:142:1: 142:54 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__subreddit;"
      },
      {
        "span": "src/markdown.rs:143:1: 143:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__url;"
      },
      {
        "span": "src/markdown.rs:146:1: 146:37 (#0)",
        "source": "pub use crate::src::buffer::bufgrow;"
      },
      {
        "span": "src/markdown.rs:141:1: 141:50 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__email;"
      },
      {
        "span": "src/markdown.rs:21:1: 21:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/markdown.rs:147:1: 147:36 (#0)",
        "source": "pub use crate::src::buffer::bufnew;"
      },
      {
        "span": "src/markdown.rs:145:1: 145:48 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__www;"
      },
      {
        "span": "src/markdown.rs:149:1: 149:37 (#0)",
        "source": "pub use crate::src::buffer::bufputc;"
      },
      {
        "span": "src/markdown.rs:144:1: 144:53 (#0)",
        "source": "pub use crate::src::autolink::sd_autolink__username;"
      },
      {
        "span": "src/markdown.rs:148:1: 148:36 (#0)",
        "source": "pub use crate::src::buffer::bufput;"
      },
      {
        "span": "src/markdown.rs:17:1: 17:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/markdown.rs:150:1: 150:40 (#0)",
        "source": "pub use crate::src::buffer::bufrelease;"
      }
    ],
    "chunks": []
  }
]