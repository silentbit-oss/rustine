{
    "special_type": [
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.FuncDecl'>",
            "definition": "typedef void mi_deferred_free_fun(bool force, unsigned long long heartbeat, void *arg)",
            "name": "mi_deferred_free_fun",
            "names": []
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.FuncDecl'>",
            "definition": "typedef void mi_output_fun(const char *msg, void *arg)",
            "name": "mi_output_fun",
            "names": []
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.FuncDecl'>",
            "definition": "typedef void mi_error_fun(int err, void *arg)",
            "name": "mi_error_fun",
            "names": []
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "struct mi_heap_s\n{\n  mi_tld_t *tld;\n  mi_block_t * _Atomic thread_delayed_free;\n  mi_threadid_t thread_id;\n  mi_arena_id_t arena_id;\n  uintptr_t cookie;\n  uintptr_t keys[2];\n  mi_random_ctx_t random;\n  size_t page_count;\n  size_t page_retired_min;\n  size_t page_retired_max;\n  long generic_count;\n  long generic_collect_count;\n  mi_heap_t *next;\n  bool no_reclaim;\n  uint8_t tag;\n  mi_page_t *pages_free_direct[(128 + ((((sizeof(mi_padding_t)) + (1 << 3)) - 1) / (1 << 3))) + 1];\n  mi_page_queue_t pages[(73U + 1) + 1];\n}",
            "name": "mi_heap_s",
            "names": [
                "struct mi_heap_s",
                "typedef struct mi_heap_s mi_heap_t"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_tld_t *",
                        "definition": [
                            "mi_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "thread_delayed_free",
                        "type": "mi_block_t * _Atomic",
                        "definition": [
                            "mi_block_t * _Atomic thread_delayed_free"
                        ]
                    },
                    {
                        "path": null,
                        "name": "thread_id",
                        "type": "mi_threadid_t",
                        "definition": [
                            "mi_threadid_t thread_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "cookie",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t cookie"
                        ]
                    },
                    {
                        "path": null,
                        "name": "keys",
                        "type": "uintptr_t [2]",
                        "definition": [
                            "uintptr_t keys[2]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "random",
                        "type": "mi_random_ctx_t",
                        "definition": [
                            "mi_random_ctx_t random"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_count",
                        "type": "size_t",
                        "definition": [
                            "size_t page_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_retired_min",
                        "type": "size_t",
                        "definition": [
                            "size_t page_retired_min"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_retired_max",
                        "type": "size_t",
                        "definition": [
                            "size_t page_retired_max"
                        ]
                    },
                    {
                        "path": null,
                        "name": "generic_count",
                        "type": "long",
                        "definition": [
                            "long generic_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "generic_collect_count",
                        "type": "long",
                        "definition": [
                            "long generic_collect_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *next"
                        ]
                    },
                    {
                        "path": null,
                        "name": "no_reclaim",
                        "type": "bool",
                        "definition": [
                            "bool no_reclaim"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tag",
                        "type": "uint8_t",
                        "definition": [
                            "uint8_t tag"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pages_free_direct",
                        "type": "mi_page_t *[(128 + ((((sizeof(mi_padding_t)) + (1 << 3)) - 1) / (1 << 3))) + 1]",
                        "definition": [
                            "mi_page_t *pages_free_direct[(128 + ((((sizeof(mi_padding_t)) + (1 << 3)) - 1) / (1 << 3))) + 1]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pages",
                        "type": "mi_page_queue_t [(73U + 1) + 1]",
                        "definition": [
                            "mi_page_queue_t pages[(73U + 1) + 1]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_heap_s mi_heap_t",
            "name": "mi_heap_t",
            "names": [],
            "inner": {
                "special_type": [
                    {
                        "path": null,
                        "type": "<class 'pycparser.c_ast.Struct'>",
                        "definition": "struct mi_heap_s\n{\n  mi_tld_t *tld;\n  mi_block_t * _Atomic thread_delayed_free;\n  mi_threadid_t thread_id;\n  mi_arena_id_t arena_id;\n  uintptr_t cookie;\n  uintptr_t keys[2];\n  mi_random_ctx_t random;\n  size_t page_count;\n  size_t page_retired_min;\n  size_t page_retired_max;\n  long generic_count;\n  long generic_collect_count;\n  mi_heap_t *next;\n  bool no_reclaim;\n  uint8_t tag;\n  mi_page_t *pages_free_direct[(128 + ((((sizeof(mi_padding_t)) + (1 << 3)) - 1) / (1 << 3))) + 1];\n  mi_page_queue_t pages[(73U + 1) + 1];\n}",
                        "name": "mi_heap_s",
                        "names": [
                            "struct mi_heap_s",
                            "typedef struct mi_heap_s mi_heap_t"
                        ],
                        "inner": {
                            "special_type": [],
                            "global_variable": [
                                {
                                    "path": null,
                                    "name": "tld",
                                    "type": "mi_tld_t *",
                                    "definition": [
                                        "mi_tld_t *tld"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "thread_delayed_free",
                                    "type": "mi_block_t * _Atomic",
                                    "definition": [
                                        "mi_block_t * _Atomic thread_delayed_free"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "thread_id",
                                    "type": "mi_threadid_t",
                                    "definition": [
                                        "mi_threadid_t thread_id"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "arena_id",
                                    "type": "mi_arena_id_t",
                                    "definition": [
                                        "mi_arena_id_t arena_id"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "cookie",
                                    "type": "uintptr_t",
                                    "definition": [
                                        "uintptr_t cookie"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "keys",
                                    "type": "uintptr_t [2]",
                                    "definition": [
                                        "uintptr_t keys[2]"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "random",
                                    "type": "mi_random_ctx_t",
                                    "definition": [
                                        "mi_random_ctx_t random"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "page_count",
                                    "type": "size_t",
                                    "definition": [
                                        "size_t page_count"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "page_retired_min",
                                    "type": "size_t",
                                    "definition": [
                                        "size_t page_retired_min"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "page_retired_max",
                                    "type": "size_t",
                                    "definition": [
                                        "size_t page_retired_max"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "generic_count",
                                    "type": "long",
                                    "definition": [
                                        "long generic_count"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "generic_collect_count",
                                    "type": "long",
                                    "definition": [
                                        "long generic_collect_count"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "next",
                                    "type": "mi_heap_t *",
                                    "definition": [
                                        "mi_heap_t *next"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "no_reclaim",
                                    "type": "bool",
                                    "definition": [
                                        "bool no_reclaim"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "tag",
                                    "type": "uint8_t",
                                    "definition": [
                                        "uint8_t tag"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "pages_free_direct",
                                    "type": "mi_page_t *[(128 + ((((sizeof(mi_padding_t)) + (1 << 3)) - 1) / (1 << 3))) + 1]",
                                    "definition": [
                                        "mi_page_t *pages_free_direct[(128 + ((((sizeof(mi_padding_t)) + (1 << 3)) - 1) / (1 << 3))) + 1]"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "pages",
                                    "type": "mi_page_queue_t [(73U + 1) + 1]",
                                    "definition": [
                                        "mi_page_queue_t pages[(73U + 1) + 1]"
                                    ]
                                }
                            ],
                            "function": [],
                            "typedefs": []
                        }
                    }
                ],
                "global_variable": [],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_heap_area_s\n{\n  void *blocks;\n  size_t reserved;\n  size_t committed;\n  size_t used;\n  size_t block_size;\n  size_t full_block_size;\n  int heap_tag;\n} mi_heap_area_t",
            "name": "mi_heap_area_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "blocks",
                        "type": "void *",
                        "definition": [
                            "void *blocks"
                        ]
                    },
                    {
                        "path": null,
                        "name": "reserved",
                        "type": "size_t",
                        "definition": [
                            "size_t reserved"
                        ]
                    },
                    {
                        "path": null,
                        "name": "committed",
                        "type": "size_t",
                        "definition": [
                            "size_t committed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "used",
                        "type": "size_t",
                        "definition": [
                            "size_t used"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_size",
                        "type": "size_t",
                        "definition": [
                            "size_t block_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "full_block_size",
                        "type": "size_t",
                        "definition": [
                            "size_t full_block_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap_tag",
                        "type": "int",
                        "definition": [
                            "int heap_tag"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.FuncDecl'>",
            "definition": "typedef bool mi_block_visit_fun(const mi_heap_t *heap, const mi_heap_area_t *area, void *block, size_t block_size, void *arg)",
            "name": "mi_block_visit_fun",
            "names": []
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Enum'>",
            "definition": "typedef enum mi_option_e\n{\n  mi_option_show_errors,\n  mi_option_show_stats,\n  mi_option_verbose,\n  mi_option_eager_commit,\n  mi_option_arena_eager_commit,\n  mi_option_purge_decommits,\n  mi_option_allow_large_os_pages,\n  mi_option_reserve_huge_os_pages,\n  mi_option_reserve_huge_os_pages_at,\n  mi_option_reserve_os_memory,\n  mi_option_deprecated_segment_cache,\n  mi_option_deprecated_page_reset,\n  mi_option_abandoned_page_purge,\n  mi_option_deprecated_segment_reset,\n  mi_option_eager_commit_delay,\n  mi_option_purge_delay,\n  mi_option_use_numa_nodes,\n  mi_option_disallow_os_alloc,\n  mi_option_os_tag,\n  mi_option_max_errors,\n  mi_option_max_warnings,\n  mi_option_max_segment_reclaim,\n  mi_option_destroy_on_exit,\n  mi_option_arena_reserve,\n  mi_option_arena_purge_mult,\n  mi_option_purge_extend_delay,\n  mi_option_abandoned_reclaim_on_free,\n  mi_option_disallow_arena_alloc,\n  mi_option_retry_on_oom,\n  mi_option_visit_abandoned,\n  mi_option_guarded_min,\n  mi_option_guarded_max,\n  mi_option_guarded_precise,\n  mi_option_guarded_sample_rate,\n  mi_option_guarded_sample_seed,\n  mi_option_target_segments_per_thread,\n  mi_option_generic_collect,\n  _mi_option_last,\n  mi_option_large_os_pages = mi_option_allow_large_os_pages,\n  mi_option_eager_region_commit = mi_option_arena_eager_commit,\n  mi_option_reset_decommits = mi_option_purge_decommits,\n  mi_option_reset_delay = mi_option_purge_delay,\n  mi_option_abandoned_page_reset = mi_option_abandoned_page_purge,\n  mi_option_limit_os_alloc = mi_option_disallow_os_alloc\n} mi_option_t",
            "name": "mi_option_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_stat_count_s\n{\n  int64_t total;\n  int64_t peak;\n  int64_t current;\n} mi_stat_count_t",
            "name": "mi_stat_count_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "total",
                        "type": "int64_t",
                        "definition": [
                            "int64_t total"
                        ]
                    },
                    {
                        "path": null,
                        "name": "peak",
                        "type": "int64_t",
                        "definition": [
                            "int64_t peak"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current",
                        "type": "int64_t",
                        "definition": [
                            "int64_t current"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_stat_counter_s\n{\n  int64_t total;\n} mi_stat_counter_t",
            "name": "mi_stat_counter_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "total",
                        "type": "int64_t",
                        "definition": [
                            "int64_t total"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_stats_s\n{\n  int version;\n  mi_stat_count_t pages;\n  mi_stat_count_t reserved;\n  mi_stat_count_t committed;\n  mi_stat_count_t reset;\n  mi_stat_count_t purged;\n  mi_stat_count_t page_committed;\n  mi_stat_count_t pages_abandoned;\n  mi_stat_count_t threads;\n  mi_stat_count_t malloc_normal;\n  mi_stat_count_t malloc_huge;\n  mi_stat_count_t malloc_requested;\n  mi_stat_counter_t mmap_calls;\n  mi_stat_counter_t commit_calls;\n  mi_stat_counter_t reset_calls;\n  mi_stat_counter_t purge_calls;\n  mi_stat_counter_t arena_count;\n  mi_stat_counter_t malloc_normal_count;\n  mi_stat_counter_t malloc_huge_count;\n  mi_stat_counter_t malloc_guarded_count;\n  mi_stat_counter_t arena_rollback_count;\n  mi_stat_counter_t arena_purges;\n  mi_stat_counter_t pages_extended;\n  mi_stat_counter_t pages_retire;\n  mi_stat_counter_t page_searches;\n  mi_stat_count_t segments;\n  mi_stat_count_t segments_abandoned;\n  mi_stat_count_t segments_cache;\n  mi_stat_count_t _segments_reserved;\n  mi_stat_counter_t pages_reclaim_on_alloc;\n  mi_stat_counter_t pages_reclaim_on_free;\n  mi_stat_counter_t pages_reabandon_full;\n  mi_stat_counter_t pages_unabandon_busy_wait;\n  mi_stat_count_t _stat_reserved[4];\n  mi_stat_counter_t _stat_counter_reserved[4];\n  mi_stat_count_t malloc_bins[73U + 1];\n  mi_stat_count_t page_bins[73U + 1];\n} mi_stats_t",
            "name": "mi_stats_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "version",
                        "type": "int",
                        "definition": [
                            "int version"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pages",
                        "type": "mi_stat_count_t",
                        "definition": [
                            "mi_stat_count_t pages"
                        ]
                    },
                    {
                        "path": null,
                        "name": "reserved",
                        "type": "mi_stat_count_t",
                        "definition": [
                            "mi_stat_count_t reserved"
                        ]
                    },
                    {
                        "path": null,
                        "name": "committed",
                        "type": "mi_stat_count_t",
                        "definition": [
                            "mi_stat_count_t committed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "reset",
                        "type": "mi_stat_count_t",
                        "definition": [
                            "mi_stat_count_t reset"
                        ]
                    },
                    {
                        "path": null,
                        "name": "purged",
                        "type": "mi_stat_count_t",
                        "definition": [
                            "mi_stat_count_t purged"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_committed",
                        "type": "mi_stat_count_t",
                        "definition": [
                            "mi_stat_count_t page_committed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pages_abandoned",
                        "type": "mi_stat_count_t",
                        "definition": [
                            "mi_stat_count_t pages_abandoned"
                        ]
                    },
                    {
                        "path": null,
                        "name": "threads",
                        "type": "mi_stat_count_t",
                        "definition": [
                            "mi_stat_count_t threads"
                        ]
                    },
                    {
                        "path": null,
                        "name": "malloc_normal",
                        "type": "mi_stat_count_t",
                        "definition": [
                            "mi_stat_count_t malloc_normal"
                        ]
                    },
                    {
                        "path": null,
                        "name": "malloc_huge",
                        "type": "mi_stat_count_t",
                        "definition": [
                            "mi_stat_count_t malloc_huge"
                        ]
                    },
                    {
                        "path": null,
                        "name": "malloc_requested",
                        "type": "mi_stat_count_t",
                        "definition": [
                            "mi_stat_count_t malloc_requested"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mmap_calls",
                        "type": "mi_stat_counter_t",
                        "definition": [
                            "mi_stat_counter_t mmap_calls"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit_calls",
                        "type": "mi_stat_counter_t",
                        "definition": [
                            "mi_stat_counter_t commit_calls"
                        ]
                    },
                    {
                        "path": null,
                        "name": "reset_calls",
                        "type": "mi_stat_counter_t",
                        "definition": [
                            "mi_stat_counter_t reset_calls"
                        ]
                    },
                    {
                        "path": null,
                        "name": "purge_calls",
                        "type": "mi_stat_counter_t",
                        "definition": [
                            "mi_stat_counter_t purge_calls"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_count",
                        "type": "mi_stat_counter_t",
                        "definition": [
                            "mi_stat_counter_t arena_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "malloc_normal_count",
                        "type": "mi_stat_counter_t",
                        "definition": [
                            "mi_stat_counter_t malloc_normal_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "malloc_huge_count",
                        "type": "mi_stat_counter_t",
                        "definition": [
                            "mi_stat_counter_t malloc_huge_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "malloc_guarded_count",
                        "type": "mi_stat_counter_t",
                        "definition": [
                            "mi_stat_counter_t malloc_guarded_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_rollback_count",
                        "type": "mi_stat_counter_t",
                        "definition": [
                            "mi_stat_counter_t arena_rollback_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_purges",
                        "type": "mi_stat_counter_t",
                        "definition": [
                            "mi_stat_counter_t arena_purges"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pages_extended",
                        "type": "mi_stat_counter_t",
                        "definition": [
                            "mi_stat_counter_t pages_extended"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pages_retire",
                        "type": "mi_stat_counter_t",
                        "definition": [
                            "mi_stat_counter_t pages_retire"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_searches",
                        "type": "mi_stat_counter_t",
                        "definition": [
                            "mi_stat_counter_t page_searches"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segments",
                        "type": "mi_stat_count_t",
                        "definition": [
                            "mi_stat_count_t segments"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segments_abandoned",
                        "type": "mi_stat_count_t",
                        "definition": [
                            "mi_stat_count_t segments_abandoned"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segments_cache",
                        "type": "mi_stat_count_t",
                        "definition": [
                            "mi_stat_count_t segments_cache"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_segments_reserved",
                        "type": "mi_stat_count_t",
                        "definition": [
                            "mi_stat_count_t _segments_reserved"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pages_reclaim_on_alloc",
                        "type": "mi_stat_counter_t",
                        "definition": [
                            "mi_stat_counter_t pages_reclaim_on_alloc"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pages_reclaim_on_free",
                        "type": "mi_stat_counter_t",
                        "definition": [
                            "mi_stat_counter_t pages_reclaim_on_free"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pages_reabandon_full",
                        "type": "mi_stat_counter_t",
                        "definition": [
                            "mi_stat_counter_t pages_reabandon_full"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pages_unabandon_busy_wait",
                        "type": "mi_stat_counter_t",
                        "definition": [
                            "mi_stat_counter_t pages_unabandon_busy_wait"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_stat_reserved",
                        "type": "mi_stat_count_t [4]",
                        "definition": [
                            "mi_stat_count_t _stat_reserved[4]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_stat_counter_reserved",
                        "type": "mi_stat_counter_t [4]",
                        "definition": [
                            "mi_stat_counter_t _stat_counter_reserved[4]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "malloc_bins",
                        "type": "mi_stat_count_t [73U + 1]",
                        "definition": [
                            "mi_stat_count_t malloc_bins[73U + 1]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_bins",
                        "type": "mi_stat_count_t [73U + 1]",
                        "definition": [
                            "mi_stat_count_t page_bins[73U + 1]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_block_s\n{\n  mi_encoded_t next;\n} mi_block_t",
            "name": "mi_block_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "next",
                        "type": "mi_encoded_t",
                        "definition": [
                            "mi_encoded_t next"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Enum'>",
            "definition": "typedef enum mi_delayed_e\n{\n  MI_USE_DELAYED_FREE = 0,\n  MI_DELAYED_FREEING = 1,\n  MI_NO_DELAYED_FREE = 2,\n  MI_NEVER_DELAYED_FREE = 3\n} mi_delayed_t",
            "name": "mi_delayed_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Union'>",
            "definition": "typedef union mi_page_flags_s\n{\n  uint8_t full_aligned;\n  struct \n  {\n    uint8_t in_full : 1;\n    uint8_t has_aligned : 1;\n  } x;\n} mi_page_flags_t",
            "name": "mi_page_flags_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "full_aligned",
                        "type": "uint8_t",
                        "definition": [
                            "uint8_t full_aligned"
                        ]
                    },
                    {
                        "path": null,
                        "name": "x",
                        "type": "struct \n{\n  uint8_t in_full : 1;\n  uint8_t has_aligned : 1;\n}",
                        "definition": [
                            "struct \n{\n  uint8_t in_full : 1;\n  uint8_t has_aligned : 1;\n} x"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_page_s\n{\n  uint32_t slice_count;\n  uint32_t slice_offset;\n  uint8_t is_committed : 1;\n  uint8_t is_zero_init : 1;\n  uint8_t is_huge : 1;\n  uint16_t capacity;\n  uint16_t reserved;\n  mi_page_flags_t flags;\n  uint8_t free_is_zero : 1;\n  uint8_t retire_expire : 7;\n  mi_block_t *free;\n  mi_block_t *local_free;\n  uint16_t used;\n  uint8_t block_size_shift;\n  uint8_t heap_tag;\n  size_t block_size;\n  uint8_t *page_start;\n  uintptr_t keys[2];\n  _Atomic mi_thread_free_t xthread_free;\n  _Atomic uintptr_t xheap;\n  struct mi_page_s *next;\n  struct mi_page_s *prev;\n  void *padding[1];\n} mi_page_t",
            "name": "mi_page_t",
            "names": [
                "typedef mi_page_t mi_slice_t"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "slice_count",
                        "type": "uint32_t",
                        "definition": [
                            "uint32_t slice_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_offset",
                        "type": "uint32_t",
                        "definition": [
                            "uint32_t slice_offset"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_committed",
                        "type": "uint8_t",
                        "definition": [
                            "uint8_t is_committed : 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_zero_init",
                        "type": "uint8_t",
                        "definition": [
                            "uint8_t is_zero_init : 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_huge",
                        "type": "uint8_t",
                        "definition": [
                            "uint8_t is_huge : 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "capacity",
                        "type": "uint16_t",
                        "definition": [
                            "uint16_t capacity"
                        ]
                    },
                    {
                        "path": null,
                        "name": "reserved",
                        "type": "uint16_t",
                        "definition": [
                            "uint16_t reserved"
                        ]
                    },
                    {
                        "path": null,
                        "name": "flags",
                        "type": "mi_page_flags_t",
                        "definition": [
                            "mi_page_flags_t flags"
                        ]
                    },
                    {
                        "path": null,
                        "name": "free_is_zero",
                        "type": "uint8_t",
                        "definition": [
                            "uint8_t free_is_zero : 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "retire_expire",
                        "type": "uint8_t",
                        "definition": [
                            "uint8_t retire_expire : 7"
                        ]
                    },
                    {
                        "path": null,
                        "name": "free",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *free"
                        ]
                    },
                    {
                        "path": null,
                        "name": "local_free",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *local_free"
                        ]
                    },
                    {
                        "path": null,
                        "name": "used",
                        "type": "uint16_t",
                        "definition": [
                            "uint16_t used"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_size_shift",
                        "type": "uint8_t",
                        "definition": [
                            "uint8_t block_size_shift"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap_tag",
                        "type": "uint8_t",
                        "definition": [
                            "uint8_t heap_tag"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_size",
                        "type": "size_t",
                        "definition": [
                            "size_t block_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_start",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *page_start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "keys",
                        "type": "uintptr_t [2]",
                        "definition": [
                            "uintptr_t keys[2]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "xthread_free",
                        "type": "_Atomic mi_thread_free_t",
                        "definition": [
                            "_Atomic mi_thread_free_t xthread_free"
                        ]
                    },
                    {
                        "path": null,
                        "name": "xheap",
                        "type": "_Atomic uintptr_t",
                        "definition": [
                            "_Atomic uintptr_t xheap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "struct mi_page_s",
                        "type": "struct mi_page_s *",
                        "definition": [
                            "struct mi_page_s *next"
                        ]
                    },
                    {
                        "path": null,
                        "name": "struct mi_page_s",
                        "type": "struct mi_page_s *",
                        "definition": [
                            "struct mi_page_s *prev"
                        ]
                    },
                    {
                        "path": null,
                        "name": "padding",
                        "type": "void *[1]",
                        "definition": [
                            "void *padding[1]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef mi_page_t mi_slice_t",
            "name": "mi_slice_t",
            "names": [],
            "inner": {
                "special_type": [
                    {
                        "path": null,
                        "type": "<class 'pycparser.c_ast.Struct'>",
                        "definition": "typedef struct mi_page_s\n{\n  uint32_t slice_count;\n  uint32_t slice_offset;\n  uint8_t is_committed : 1;\n  uint8_t is_zero_init : 1;\n  uint8_t is_huge : 1;\n  uint16_t capacity;\n  uint16_t reserved;\n  mi_page_flags_t flags;\n  uint8_t free_is_zero : 1;\n  uint8_t retire_expire : 7;\n  mi_block_t *free;\n  mi_block_t *local_free;\n  uint16_t used;\n  uint8_t block_size_shift;\n  uint8_t heap_tag;\n  size_t block_size;\n  uint8_t *page_start;\n  uintptr_t keys[2];\n  _Atomic mi_thread_free_t xthread_free;\n  _Atomic uintptr_t xheap;\n  struct mi_page_s *next;\n  struct mi_page_s *prev;\n  void *padding[1];\n} mi_page_t",
                        "name": "mi_page_t",
                        "names": [
                            "typedef mi_page_t mi_slice_t"
                        ],
                        "inner": {
                            "special_type": [],
                            "global_variable": [
                                {
                                    "path": null,
                                    "name": "slice_count",
                                    "type": "uint32_t",
                                    "definition": [
                                        "uint32_t slice_count"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "slice_offset",
                                    "type": "uint32_t",
                                    "definition": [
                                        "uint32_t slice_offset"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "is_committed",
                                    "type": "uint8_t",
                                    "definition": [
                                        "uint8_t is_committed : 1"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "is_zero_init",
                                    "type": "uint8_t",
                                    "definition": [
                                        "uint8_t is_zero_init : 1"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "is_huge",
                                    "type": "uint8_t",
                                    "definition": [
                                        "uint8_t is_huge : 1"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "capacity",
                                    "type": "uint16_t",
                                    "definition": [
                                        "uint16_t capacity"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "reserved",
                                    "type": "uint16_t",
                                    "definition": [
                                        "uint16_t reserved"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "flags",
                                    "type": "mi_page_flags_t",
                                    "definition": [
                                        "mi_page_flags_t flags"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "free_is_zero",
                                    "type": "uint8_t",
                                    "definition": [
                                        "uint8_t free_is_zero : 1"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "retire_expire",
                                    "type": "uint8_t",
                                    "definition": [
                                        "uint8_t retire_expire : 7"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "free",
                                    "type": "mi_block_t *",
                                    "definition": [
                                        "mi_block_t *free"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "local_free",
                                    "type": "mi_block_t *",
                                    "definition": [
                                        "mi_block_t *local_free"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "used",
                                    "type": "uint16_t",
                                    "definition": [
                                        "uint16_t used"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "block_size_shift",
                                    "type": "uint8_t",
                                    "definition": [
                                        "uint8_t block_size_shift"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "heap_tag",
                                    "type": "uint8_t",
                                    "definition": [
                                        "uint8_t heap_tag"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "block_size",
                                    "type": "size_t",
                                    "definition": [
                                        "size_t block_size"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "page_start",
                                    "type": "uint8_t *",
                                    "definition": [
                                        "uint8_t *page_start"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "keys",
                                    "type": "uintptr_t [2]",
                                    "definition": [
                                        "uintptr_t keys[2]"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "xthread_free",
                                    "type": "_Atomic mi_thread_free_t",
                                    "definition": [
                                        "_Atomic mi_thread_free_t xthread_free"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "xheap",
                                    "type": "_Atomic uintptr_t",
                                    "definition": [
                                        "_Atomic uintptr_t xheap"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "struct mi_page_s",
                                    "type": "struct mi_page_s *",
                                    "definition": [
                                        "struct mi_page_s *next"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "struct mi_page_s",
                                    "type": "struct mi_page_s *",
                                    "definition": [
                                        "struct mi_page_s *prev"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "padding",
                                    "type": "void *[1]",
                                    "definition": [
                                        "void *padding[1]"
                                    ]
                                }
                            ],
                            "function": [],
                            "typedefs": []
                        }
                    }
                ],
                "global_variable": [],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Enum'>",
            "definition": "typedef enum mi_page_kind_e\n{\n  MI_PAGE_SMALL,\n  MI_PAGE_MEDIUM,\n  MI_PAGE_LARGE,\n  MI_PAGE_HUGE\n} mi_page_kind_t",
            "name": "mi_page_kind_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Enum'>",
            "definition": "typedef enum mi_segment_kind_e\n{\n  MI_SEGMENT_NORMAL,\n  MI_SEGMENT_HUGE\n} mi_segment_kind_t",
            "name": "mi_segment_kind_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_commit_mask_s\n{\n  size_t mask[((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) / ((1 << 3) * 8)];\n} mi_commit_mask_t",
            "name": "mi_commit_mask_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "mask",
                        "type": "size_t [((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) / ((1 << 3) * 8)]",
                        "definition": [
                            "size_t mask[((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) / ((1 << 3) * 8)]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Enum'>",
            "definition": "typedef enum mi_memkind_e\n{\n  MI_MEM_NONE,\n  MI_MEM_EXTERNAL,\n  MI_MEM_STATIC,\n  MI_MEM_OS,\n  MI_MEM_OS_HUGE,\n  MI_MEM_OS_REMAP,\n  MI_MEM_ARENA\n} mi_memkind_t",
            "name": "mi_memkind_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_memid_os_info\n{\n  void *base;\n  size_t size;\n} mi_memid_os_info_t",
            "name": "mi_memid_os_info_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "base",
                        "type": "void *",
                        "definition": [
                            "void *base"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_memid_arena_info\n{\n  size_t block_index;\n  mi_arena_id_t id;\n  bool is_exclusive;\n} mi_memid_arena_info_t",
            "name": "mi_memid_arena_info_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "block_index",
                        "type": "size_t",
                        "definition": [
                            "size_t block_index"
                        ]
                    },
                    {
                        "path": null,
                        "name": "id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_exclusive",
                        "type": "bool",
                        "definition": [
                            "bool is_exclusive"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_memid_s\n{\n  union \n  {\n    mi_memid_os_info_t os;\n    mi_memid_arena_info_t arena;\n  } mem;\n  bool is_pinned;\n  bool initially_committed;\n  bool initially_zero;\n  mi_memkind_t memkind;\n} mi_memid_t",
            "name": "mi_memid_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "mem",
                        "type": "union \n{\n  mi_memid_os_info_t os;\n  mi_memid_arena_info_t arena;\n}",
                        "definition": [
                            "union \n{\n  mi_memid_os_info_t os;\n  mi_memid_arena_info_t arena;\n} mem"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_pinned",
                        "type": "bool",
                        "definition": [
                            "bool is_pinned"
                        ]
                    },
                    {
                        "path": null,
                        "name": "initially_committed",
                        "type": "bool",
                        "definition": [
                            "bool initially_committed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "initially_zero",
                        "type": "bool",
                        "definition": [
                            "bool initially_zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memkind",
                        "type": "mi_memkind_t",
                        "definition": [
                            "mi_memkind_t memkind"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "struct mi_subproc_s\n{\n  _Atomic size_t abandoned_count;\n  _Atomic size_t abandoned_os_list_count;\n  pthread_mutex_t abandoned_os_lock;\n  pthread_mutex_t abandoned_os_visit_lock;\n  mi_segment_t *abandoned_os_list;\n  mi_segment_t *abandoned_os_list_tail;\n  mi_memid_t memid;\n}",
            "name": "mi_subproc_s",
            "names": [
                "typedef struct mi_subproc_s mi_subproc_t"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "abandoned_count",
                        "type": "_Atomic size_t",
                        "definition": [
                            "_Atomic size_t abandoned_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "abandoned_os_list_count",
                        "type": "_Atomic size_t",
                        "definition": [
                            "_Atomic size_t abandoned_os_list_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "abandoned_os_lock",
                        "type": "pthread_mutex_t",
                        "definition": [
                            "pthread_mutex_t abandoned_os_lock"
                        ]
                    },
                    {
                        "path": null,
                        "name": "abandoned_os_visit_lock",
                        "type": "pthread_mutex_t",
                        "definition": [
                            "pthread_mutex_t abandoned_os_visit_lock"
                        ]
                    },
                    {
                        "path": null,
                        "name": "abandoned_os_list",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *abandoned_os_list"
                        ]
                    },
                    {
                        "path": null,
                        "name": "abandoned_os_list_tail",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *abandoned_os_list_tail"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_subproc_s mi_subproc_t",
            "name": "mi_subproc_t",
            "names": [],
            "inner": {
                "special_type": [
                    {
                        "path": null,
                        "type": "<class 'pycparser.c_ast.Struct'>",
                        "definition": "struct mi_subproc_s\n{\n  _Atomic size_t abandoned_count;\n  _Atomic size_t abandoned_os_list_count;\n  pthread_mutex_t abandoned_os_lock;\n  pthread_mutex_t abandoned_os_visit_lock;\n  mi_segment_t *abandoned_os_list;\n  mi_segment_t *abandoned_os_list_tail;\n  mi_memid_t memid;\n}",
                        "name": "mi_subproc_s",
                        "names": [
                            "typedef struct mi_subproc_s mi_subproc_t"
                        ],
                        "inner": {
                            "special_type": [],
                            "global_variable": [
                                {
                                    "path": null,
                                    "name": "abandoned_count",
                                    "type": "_Atomic size_t",
                                    "definition": [
                                        "_Atomic size_t abandoned_count"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "abandoned_os_list_count",
                                    "type": "_Atomic size_t",
                                    "definition": [
                                        "_Atomic size_t abandoned_os_list_count"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "abandoned_os_lock",
                                    "type": "pthread_mutex_t",
                                    "definition": [
                                        "pthread_mutex_t abandoned_os_lock"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "abandoned_os_visit_lock",
                                    "type": "pthread_mutex_t",
                                    "definition": [
                                        "pthread_mutex_t abandoned_os_visit_lock"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "abandoned_os_list",
                                    "type": "mi_segment_t *",
                                    "definition": [
                                        "mi_segment_t *abandoned_os_list"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "abandoned_os_list_tail",
                                    "type": "mi_segment_t *",
                                    "definition": [
                                        "mi_segment_t *abandoned_os_list_tail"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "memid",
                                    "type": "mi_memid_t",
                                    "definition": [
                                        "mi_memid_t memid"
                                    ]
                                }
                            ],
                            "function": [],
                            "typedefs": []
                        }
                    }
                ],
                "global_variable": [],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_segment_s\n{\n  mi_memid_t memid;\n  bool allow_decommit;\n  bool allow_purge;\n  size_t segment_size;\n  mi_subproc_t *subproc;\n  mi_msecs_t purge_expire;\n  mi_commit_mask_t purge_mask;\n  mi_commit_mask_t commit_mask;\n  struct mi_segment_s *next;\n  bool was_reclaimed;\n  bool dont_free;\n  size_t abandoned;\n  size_t abandoned_visits;\n  size_t used;\n  uintptr_t cookie;\n  struct mi_segment_s *abandoned_os_next;\n  struct mi_segment_s *abandoned_os_prev;\n  size_t segment_slices;\n  size_t segment_info_slices;\n  mi_segment_kind_t kind;\n  size_t slice_entries;\n  _Atomic mi_threadid_t thread_id;\n  mi_slice_t slices[((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) + 1];\n} mi_segment_t",
            "name": "mi_segment_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_decommit",
                        "type": "bool",
                        "definition": [
                            "bool allow_decommit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_purge",
                        "type": "bool",
                        "definition": [
                            "bool allow_purge"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment_size",
                        "type": "size_t",
                        "definition": [
                            "size_t segment_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "subproc",
                        "type": "mi_subproc_t *",
                        "definition": [
                            "mi_subproc_t *subproc"
                        ]
                    },
                    {
                        "path": null,
                        "name": "purge_expire",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t purge_expire"
                        ]
                    },
                    {
                        "path": null,
                        "name": "purge_mask",
                        "type": "mi_commit_mask_t",
                        "definition": [
                            "mi_commit_mask_t purge_mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit_mask",
                        "type": "mi_commit_mask_t",
                        "definition": [
                            "mi_commit_mask_t commit_mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "struct mi_segment_s",
                        "type": "struct mi_segment_s *",
                        "definition": [
                            "struct mi_segment_s *next"
                        ]
                    },
                    {
                        "path": null,
                        "name": "was_reclaimed",
                        "type": "bool",
                        "definition": [
                            "bool was_reclaimed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "dont_free",
                        "type": "bool",
                        "definition": [
                            "bool dont_free"
                        ]
                    },
                    {
                        "path": null,
                        "name": "abandoned",
                        "type": "size_t",
                        "definition": [
                            "size_t abandoned"
                        ]
                    },
                    {
                        "path": null,
                        "name": "abandoned_visits",
                        "type": "size_t",
                        "definition": [
                            "size_t abandoned_visits"
                        ]
                    },
                    {
                        "path": null,
                        "name": "used",
                        "type": "size_t",
                        "definition": [
                            "size_t used"
                        ]
                    },
                    {
                        "path": null,
                        "name": "cookie",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t cookie"
                        ]
                    },
                    {
                        "path": null,
                        "name": "struct mi_segment_s",
                        "type": "struct mi_segment_s *",
                        "definition": [
                            "struct mi_segment_s *abandoned_os_next"
                        ]
                    },
                    {
                        "path": null,
                        "name": "struct mi_segment_s",
                        "type": "struct mi_segment_s *",
                        "definition": [
                            "struct mi_segment_s *abandoned_os_prev"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment_slices",
                        "type": "size_t",
                        "definition": [
                            "size_t segment_slices"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment_info_slices",
                        "type": "size_t",
                        "definition": [
                            "size_t segment_info_slices"
                        ]
                    },
                    {
                        "path": null,
                        "name": "kind",
                        "type": "mi_segment_kind_t",
                        "definition": [
                            "mi_segment_kind_t kind"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_entries",
                        "type": "size_t",
                        "definition": [
                            "size_t slice_entries"
                        ]
                    },
                    {
                        "path": null,
                        "name": "thread_id",
                        "type": "_Atomic mi_threadid_t",
                        "definition": [
                            "_Atomic mi_threadid_t thread_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slices",
                        "type": "mi_slice_t [((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) + 1]",
                        "definition": [
                            "mi_slice_t slices[((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) + 1]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "struct mi_tld_s\n{\n  unsigned long long heartbeat;\n  bool recurse;\n  mi_heap_t *heap_backing;\n  mi_heap_t *heaps;\n  mi_segments_tld_t segments;\n  mi_stats_t stats;\n}",
            "name": "mi_tld_s",
            "names": [
                "typedef struct mi_tld_s mi_tld_t"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heartbeat",
                        "type": "unsigned long long",
                        "definition": [
                            "unsigned long long heartbeat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "recurse",
                        "type": "bool",
                        "definition": [
                            "bool recurse"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap_backing",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap_backing"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heaps",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heaps"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segments",
                        "type": "mi_segments_tld_t",
                        "definition": [
                            "mi_segments_tld_t segments"
                        ]
                    },
                    {
                        "path": null,
                        "name": "stats",
                        "type": "mi_stats_t",
                        "definition": [
                            "mi_stats_t stats"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_tld_s mi_tld_t",
            "name": "mi_tld_t",
            "names": [],
            "inner": {
                "special_type": [
                    {
                        "path": null,
                        "type": "<class 'pycparser.c_ast.Struct'>",
                        "definition": "struct mi_tld_s\n{\n  unsigned long long heartbeat;\n  bool recurse;\n  mi_heap_t *heap_backing;\n  mi_heap_t *heaps;\n  mi_segments_tld_t segments;\n  mi_stats_t stats;\n}",
                        "name": "mi_tld_s",
                        "names": [
                            "typedef struct mi_tld_s mi_tld_t"
                        ],
                        "inner": {
                            "special_type": [],
                            "global_variable": [
                                {
                                    "path": null,
                                    "name": "heartbeat",
                                    "type": "unsigned long long",
                                    "definition": [
                                        "unsigned long long heartbeat"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "recurse",
                                    "type": "bool",
                                    "definition": [
                                        "bool recurse"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "heap_backing",
                                    "type": "mi_heap_t *",
                                    "definition": [
                                        "mi_heap_t *heap_backing"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "heaps",
                                    "type": "mi_heap_t *",
                                    "definition": [
                                        "mi_heap_t *heaps"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "segments",
                                    "type": "mi_segments_tld_t",
                                    "definition": [
                                        "mi_segments_tld_t segments"
                                    ]
                                },
                                {
                                    "path": null,
                                    "name": "stats",
                                    "type": "mi_stats_t",
                                    "definition": [
                                        "mi_stats_t stats"
                                    ]
                                }
                            ],
                            "function": [],
                            "typedefs": []
                        }
                    }
                ],
                "global_variable": [],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_page_queue_s\n{\n  mi_page_t *first;\n  mi_page_t *last;\n  size_t block_size;\n} mi_page_queue_t",
            "name": "mi_page_queue_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "first",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *first"
                        ]
                    },
                    {
                        "path": null,
                        "name": "last",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *last"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_size",
                        "type": "size_t",
                        "definition": [
                            "size_t block_size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_random_cxt_s\n{\n  uint32_t input[16];\n  uint32_t output[16];\n  int output_available;\n  bool weak;\n} mi_random_ctx_t",
            "name": "mi_random_ctx_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "input",
                        "type": "uint32_t [16]",
                        "definition": [
                            "uint32_t input[16]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "output",
                        "type": "uint32_t [16]",
                        "definition": [
                            "uint32_t output[16]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "output_available",
                        "type": "int",
                        "definition": [
                            "int output_available"
                        ]
                    },
                    {
                        "path": null,
                        "name": "weak",
                        "type": "bool",
                        "definition": [
                            "bool weak"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_padding_s\n{\n  uint32_t canary;\n  uint32_t delta;\n} mi_padding_t",
            "name": "mi_padding_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "canary",
                        "type": "uint32_t",
                        "definition": [
                            "uint32_t canary"
                        ]
                    },
                    {
                        "path": null,
                        "name": "delta",
                        "type": "uint32_t",
                        "definition": [
                            "uint32_t delta"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_span_queue_s\n{\n  mi_slice_t *first;\n  mi_slice_t *last;\n  size_t slice_count;\n} mi_span_queue_t",
            "name": "mi_span_queue_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "first",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *first"
                        ]
                    },
                    {
                        "path": null,
                        "name": "last",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *last"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_count",
                        "type": "size_t",
                        "definition": [
                            "size_t slice_count"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_segments_tld_s\n{\n  mi_span_queue_t spans[35 + 1];\n  size_t count;\n  size_t peak_count;\n  size_t current_size;\n  size_t peak_size;\n  size_t reclaim_count;\n  mi_subproc_t *subproc;\n  mi_stats_t *stats;\n} mi_segments_tld_t",
            "name": "mi_segments_tld_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "spans",
                        "type": "mi_span_queue_t [35 + 1]",
                        "definition": [
                            "mi_span_queue_t spans[35 + 1]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "peak_count",
                        "type": "size_t",
                        "definition": [
                            "size_t peak_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current_size",
                        "type": "size_t",
                        "definition": [
                            "size_t current_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "peak_size",
                        "type": "size_t",
                        "definition": [
                            "size_t peak_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "reclaim_count",
                        "type": "size_t",
                        "definition": [
                            "size_t reclaim_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "subproc",
                        "type": "mi_subproc_t *",
                        "definition": [
                            "mi_subproc_t *subproc"
                        ]
                    },
                    {
                        "path": null,
                        "name": "stats",
                        "type": "mi_stats_t *",
                        "definition": [
                            "mi_stats_t *stats"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_arena_field_cursor_s\n{\n  size_t os_list_count;\n  size_t start;\n  size_t end;\n  size_t bitmap_idx;\n  mi_subproc_t *subproc;\n  bool visit_all;\n  bool hold_visit_lock;\n} mi_arena_field_cursor_t",
            "name": "mi_arena_field_cursor_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "os_list_count",
                        "type": "size_t",
                        "definition": [
                            "size_t os_list_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "size_t",
                        "definition": [
                            "size_t start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "size_t",
                        "definition": [
                            "size_t end"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "subproc",
                        "type": "mi_subproc_t *",
                        "definition": [
                            "mi_subproc_t *subproc"
                        ]
                    },
                    {
                        "path": null,
                        "name": "visit_all",
                        "type": "bool",
                        "definition": [
                            "bool visit_all"
                        ]
                    },
                    {
                        "path": null,
                        "name": "hold_visit_lock",
                        "type": "bool",
                        "definition": [
                            "bool hold_visit_lock"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_os_mem_config_s\n{\n  size_t page_size;\n  size_t large_page_size;\n  size_t alloc_granularity;\n  size_t physical_memory_in_kib;\n  size_t virtual_address_bits;\n  bool has_overcommit;\n  bool has_partial_free;\n  bool has_virtual_reserve;\n} mi_os_mem_config_t",
            "name": "mi_os_mem_config_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page_size",
                        "type": "size_t",
                        "definition": [
                            "size_t page_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "large_page_size",
                        "type": "size_t",
                        "definition": [
                            "size_t large_page_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alloc_granularity",
                        "type": "size_t",
                        "definition": [
                            "size_t alloc_granularity"
                        ]
                    },
                    {
                        "path": null,
                        "name": "physical_memory_in_kib",
                        "type": "size_t",
                        "definition": [
                            "size_t physical_memory_in_kib"
                        ]
                    },
                    {
                        "path": null,
                        "name": "virtual_address_bits",
                        "type": "size_t",
                        "definition": [
                            "size_t virtual_address_bits"
                        ]
                    },
                    {
                        "path": null,
                        "name": "has_overcommit",
                        "type": "bool",
                        "definition": [
                            "bool has_overcommit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "has_partial_free",
                        "type": "bool",
                        "definition": [
                            "bool has_partial_free"
                        ]
                    },
                    {
                        "path": null,
                        "name": "has_virtual_reserve",
                        "type": "bool",
                        "definition": [
                            "bool has_virtual_reserve"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_process_info_s\n{\n  mi_msecs_t elapsed;\n  mi_msecs_t utime;\n  mi_msecs_t stime;\n  size_t current_rss;\n  size_t peak_rss;\n  size_t current_commit;\n  size_t peak_commit;\n  size_t page_faults;\n} mi_process_info_t",
            "name": "mi_process_info_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "elapsed",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t elapsed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "utime",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t utime"
                        ]
                    },
                    {
                        "path": null,
                        "name": "stime",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t stime"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current_rss",
                        "type": "size_t",
                        "definition": [
                            "size_t current_rss"
                        ]
                    },
                    {
                        "path": null,
                        "name": "peak_rss",
                        "type": "size_t",
                        "definition": [
                            "size_t peak_rss"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current_commit",
                        "type": "size_t",
                        "definition": [
                            "size_t current_commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "peak_commit",
                        "type": "size_t",
                        "definition": [
                            "size_t peak_commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_faults",
                        "type": "size_t",
                        "definition": [
                            "size_t page_faults"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.FuncDecl'>",
            "definition": "typedef void (*std_new_handler_t)(void)",
            "name": "std_new_handler_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.FuncDecl'>",
            "definition": "typedef bool (*mi_bitmap_pred_fun_t)(mi_bitmap_index_t bitmap_idx, void *pred_arg)",
            "name": "mi_bitmap_pred_fun_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pred_arg",
                        "type": "void *",
                        "definition": [
                            "void *pred_arg"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_arena_s\n{\n  mi_arena_id_t id;\n  mi_memid_t memid;\n  uint8_t * _Atomic start;\n  size_t block_count;\n  size_t field_count;\n  size_t meta_size;\n  mi_memid_t meta_memid;\n  int numa_node;\n  bool exclusive;\n  bool is_large;\n  pthread_mutex_t abandoned_visit_lock;\n  _Atomic size_t search_idx;\n  _Atomic mi_msecs_t purge_expire;\n  mi_bitmap_field_t *blocks_dirty;\n  mi_bitmap_field_t *blocks_committed;\n  mi_bitmap_field_t *blocks_purge;\n  mi_bitmap_field_t *blocks_abandoned;\n  mi_bitmap_field_t blocks_inuse[1];\n} mi_arena_t",
            "name": "mi_arena_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "uint8_t * _Atomic",
                        "definition": [
                            "uint8_t * _Atomic start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_count",
                        "type": "size_t",
                        "definition": [
                            "size_t block_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "field_count",
                        "type": "size_t",
                        "definition": [
                            "size_t field_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "meta_size",
                        "type": "size_t",
                        "definition": [
                            "size_t meta_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "meta_memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t meta_memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numa_node",
                        "type": "int",
                        "definition": [
                            "int numa_node"
                        ]
                    },
                    {
                        "path": null,
                        "name": "exclusive",
                        "type": "bool",
                        "definition": [
                            "bool exclusive"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_large",
                        "type": "bool",
                        "definition": [
                            "bool is_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "abandoned_visit_lock",
                        "type": "pthread_mutex_t",
                        "definition": [
                            "pthread_mutex_t abandoned_visit_lock"
                        ]
                    },
                    {
                        "path": null,
                        "name": "search_idx",
                        "type": "_Atomic size_t",
                        "definition": [
                            "_Atomic size_t search_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "purge_expire",
                        "type": "_Atomic mi_msecs_t",
                        "definition": [
                            "_Atomic mi_msecs_t purge_expire"
                        ]
                    },
                    {
                        "path": null,
                        "name": "blocks_dirty",
                        "type": "mi_bitmap_field_t *",
                        "definition": [
                            "mi_bitmap_field_t *blocks_dirty"
                        ]
                    },
                    {
                        "path": null,
                        "name": "blocks_committed",
                        "type": "mi_bitmap_field_t *",
                        "definition": [
                            "mi_bitmap_field_t *blocks_committed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "blocks_purge",
                        "type": "mi_bitmap_field_t *",
                        "definition": [
                            "mi_bitmap_field_t *blocks_purge"
                        ]
                    },
                    {
                        "path": null,
                        "name": "blocks_abandoned",
                        "type": "mi_bitmap_field_t *",
                        "definition": [
                            "mi_bitmap_field_t *blocks_abandoned"
                        ]
                    },
                    {
                        "path": null,
                        "name": "blocks_inuse",
                        "type": "mi_bitmap_field_t [1]",
                        "definition": [
                            "mi_bitmap_field_t blocks_inuse[1]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.FuncDecl'>",
            "definition": "typedef bool heap_page_visitor_fun(mi_heap_t *heap, mi_page_queue_t *pq, mi_page_t *page, void *arg1, void *arg2)",
            "name": "heap_page_visitor_fun",
            "names": []
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Enum'>",
            "definition": "typedef enum mi_collect_e\n{\n  MI_NORMAL,\n  MI_FORCE,\n  MI_ABANDON\n} mi_collect_t",
            "name": "mi_collect_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_heap_area_ex_s\n{\n  mi_heap_area_t area;\n  mi_page_t *page;\n} mi_heap_area_ex_t",
            "name": "mi_heap_area_ex_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "area",
                        "type": "mi_heap_area_t",
                        "definition": [
                            "mi_heap_area_t area"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.FuncDecl'>",
            "definition": "typedef bool mi_heap_area_visit_fun(const mi_heap_t *heap, const mi_heap_area_ex_t *area, void *arg)",
            "name": "mi_heap_area_visit_fun",
            "names": []
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_visit_blocks_args_s\n{\n  bool visit_blocks;\n  mi_block_visit_fun *visitor;\n  void *arg;\n} mi_visit_blocks_args_t",
            "name": "mi_visit_blocks_args_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "visit_blocks",
                        "type": "bool",
                        "definition": [
                            "bool visit_blocks"
                        ]
                    },
                    {
                        "path": null,
                        "name": "visitor",
                        "type": "mi_block_visit_fun *",
                        "definition": [
                            "mi_block_visit_fun *visitor"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_thread_data_s\n{\n  mi_heap_t heap;\n  mi_tld_t tld;\n  mi_memid_t memid;\n} mi_thread_data_t",
            "name": "mi_thread_data_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t",
                        "definition": [
                            "mi_heap_t heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_tld_t",
                        "definition": [
                            "mi_tld_t tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Enum'>",
            "definition": "typedef enum mi_init_e\n{\n  UNINIT,\n  DEFAULTED,\n  INITIALIZED\n} mi_init_t",
            "name": "mi_init_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_option_desc_s\n{\n  long value;\n  mi_init_t init;\n  mi_option_t option;\n  const char *name;\n  const char *legacy_name;\n} mi_option_desc_t",
            "name": "mi_option_desc_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "value",
                        "type": "long",
                        "definition": [
                            "long value"
                        ]
                    },
                    {
                        "path": null,
                        "name": "init",
                        "type": "mi_init_t",
                        "definition": [
                            "mi_init_t init"
                        ]
                    },
                    {
                        "path": null,
                        "name": "option",
                        "type": "mi_option_t",
                        "definition": [
                            "mi_option_t option"
                        ]
                    },
                    {
                        "path": null,
                        "name": "name",
                        "type": "const char *",
                        "definition": [
                            "const char *name"
                        ]
                    },
                    {
                        "path": null,
                        "name": "legacy_name",
                        "type": "const char *",
                        "definition": [
                            "const char *legacy_name"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_segmap_part_s\n{\n  mi_memid_t memid;\n  _Atomic uintptr_t map[(((1 << 3) * 1024UL) - 128) / (1 << 3)];\n} mi_segmap_part_t",
            "name": "mi_segmap_part_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "map",
                        "type": "_Atomic uintptr_t [(((1 << 3) * 1024UL) - 128) / (1 << 3)]",
                        "definition": [
                            "_Atomic uintptr_t map[(((1 << 3) * 1024UL) - 128) / (1 << 3)]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct buffered_s\n{\n  mi_output_fun *out;\n  void *arg;\n  char *buf;\n  size_t used;\n  size_t count;\n} buffered_t",
            "name": "buffered_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char *",
                        "definition": [
                            "char *buf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "used",
                        "type": "size_t",
                        "definition": [
                            "size_t used"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "type": "<class 'pycparser.c_ast.Struct'>",
            "definition": "typedef struct mi_heap_buf_s\n{\n  char *buf;\n  size_t size;\n  size_t used;\n  bool can_realloc;\n} mi_heap_buf_t",
            "name": "mi_heap_buf_t",
            "names": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char *",
                        "definition": [
                            "char *buf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "used",
                        "type": "size_t",
                        "definition": [
                            "size_t used"
                        ]
                    },
                    {
                        "path": null,
                        "name": "can_realloc",
                        "type": "bool",
                        "definition": [
                            "bool can_realloc"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        }
    ],
    "global_variable": [
        {
            "path": null,
            "name": "_mi_stats_main",
            "type": "mi_stats_t",
            "definition": [
                "extern mi_stats_t _mi_stats_main"
            ]
        },
        {
            "path": null,
            "name": "_mi_page_empty",
            "type": "const mi_page_t",
            "definition": [
                "extern const mi_page_t _mi_page_empty"
            ]
        },
        {
            "path": null,
            "name": "_mi_heap_empty",
            "type": "const mi_heap_t",
            "definition": [
                "extern const mi_heap_t _mi_heap_empty"
            ]
        },
        {
            "path": null,
            "name": "_mi_heap_default",
            "type": "mi_heap_t *",
            "definition": [
                "extern mi_heap_t *_mi_heap_default"
            ]
        },
        {
            "path": null,
            "name": "_mi_process_is_initialized",
            "type": "bool",
            "definition": [
                "extern bool _mi_process_is_initialized"
            ]
        },
        {
            "path": null,
            "name": "mi_arenas",
            "type": "mi_arena_t * _Atomic [132]",
            "definition": [
                "static mi_arena_t * _Atomic mi_arenas[132]"
            ]
        },
        {
            "path": null,
            "name": "mi_arena_count",
            "type": "_Atomic size_t",
            "definition": [
                "static _Atomic size_t mi_arena_count"
            ]
        },
        {
            "path": null,
            "name": "mi_arenas_purge_expire",
            "type": "_Atomic int64_t",
            "definition": [
                "static _Atomic int64_t mi_arenas_purge_expire"
            ]
        },
        {
            "path": null,
            "name": "mi_arena_static",
            "type": "uint8_t [((1 << 3) / 2) * 1024UL]",
            "definition": [
                "static uint8_t mi_arena_static[((1 << 3) / 2) * 1024UL]"
            ]
        },
        {
            "path": null,
            "name": "mi_arena_static_top",
            "type": "_Atomic size_t",
            "definition": [
                "static _Atomic size_t mi_arena_static_top"
            ]
        },
        {
            "path": null,
            "name": "mi_subproc_default",
            "type": "mi_subproc_t",
            "definition": [
                "static mi_subproc_t mi_subproc_default"
            ]
        },
        {
            "path": null,
            "name": "tld_empty",
            "type": "const mi_tld_t",
            "definition": [
                "static const mi_tld_t tld_empty = {0, 0, 0, 0, {{{0, 0, 1}, {0, 0, 1}, {0, 0, 2}, {0, 0, 3}, {0, 0, 4}, {0, 0, 5}, {0, 0, 6}, {0, 0, 7}, {0, 0, 10}, {0, 0, 12}, {0, 0, 14}, {0, 0, 16}, {0, 0, 20}, {0, 0, 24}, {0, 0, 28}, {0, 0, 32}, {0, 0, 40}, {0, 0, 48}, {0, 0, 56}, {0, 0, 64}, {0, 0, 80}, {0, 0, 96}, {0, 0, 112}, {0, 0, 128}, {0, 0, 160}, {0, 0, 192}, {0, 0, 224}, {0, 0, 256}, {0, 0, 320}, {0, 0, 384}, {0, 0, 448}, {0, 0, 512}, {0, 0, 640}, {0, 0, 768}, {0, 0, 896}, {0, 0, 1024}}, 0, 0, 0, 0, 0, &mi_subproc_default, (mi_stats_t *) (((uint8_t *) (&tld_empty)) + offsetof(mi_tld_t, stats))}, {1, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0}, {0}, {0}, {0}, {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}}, {{0}, {0}, {0}, {0}}, {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}}, {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}}}}"
            ]
        },
        {
            "path": null,
            "name": "_mi_heap_main",
            "type": "mi_heap_t",
            "definition": [
                "extern mi_heap_t _mi_heap_main",
                "mi_heap_t _mi_heap_main = {&tld_main, 0, 0, 0, 0, {0, 0}, {{0x846ca68b}, {0}, 0, 1}, 0, 73U + 1, 0, 0, 0, 0, 0, 0, {(mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty), (mi_page_t *) (&_mi_page_empty)}, {{0, 0, 1 * (sizeof(uintptr_t))}, {0, 0, 1 * (sizeof(uintptr_t))}, {0, 0, 2 * (sizeof(uintptr_t))}, {0, 0, 3 * (sizeof(uintptr_t))}, {0, 0, 4 * (sizeof(uintptr_t))}, {0, 0, 5 * (sizeof(uintptr_t))}, {0, 0, 6 * (sizeof(uintptr_t))}, {0, 0, 7 * (sizeof(uintptr_t))}, {0, 0, 8 * (sizeof(uintptr_t))}, {0, 0, 10 * (sizeof(uintptr_t))}, {0, 0, 12 * (sizeof(uintptr_t))}, {0, 0, 14 * (sizeof(uintptr_t))}, {0, 0, 16 * (sizeof(uintptr_t))}, {0, 0, 20 * (sizeof(uintptr_t))}, {0, 0, 24 * (sizeof(uintptr_t))}, {0, 0, 28 * (sizeof(uintptr_t))}, {0, 0, 32 * (sizeof(uintptr_t))}, {0, 0, 40 * (sizeof(uintptr_t))}, {0, 0, 48 * (sizeof(uintptr_t))}, {0, 0, 56 * (sizeof(uintptr_t))}, {0, 0, 64 * (sizeof(uintptr_t))}, {0, 0, 80 * (sizeof(uintptr_t))}, {0, 0, 96 * (sizeof(uintptr_t))}, {0, 0, 112 * (sizeof(uintptr_t))}, {0, 0, 128 * (sizeof(uintptr_t))}, {0, 0, 160 * (sizeof(uintptr_t))}, {0, 0, 192 * (sizeof(uintptr_t))}, {0, 0, 224 * (sizeof(uintptr_t))}, {0, 0, 256 * (sizeof(uintptr_t))}, {0, 0, 320 * (sizeof(uintptr_t))}, {0, 0, 384 * (sizeof(uintptr_t))}, {0, 0, 448 * (sizeof(uintptr_t))}, {0, 0, 512 * (sizeof(uintptr_t))}, {0, 0, 640 * (sizeof(uintptr_t))}, {0, 0, 768 * (sizeof(uintptr_t))}, {0, 0, 896 * (sizeof(uintptr_t))}, {0, 0, 1024 * (sizeof(uintptr_t))}, {0, 0, 1280 * (sizeof(uintptr_t))}, {0, 0, 1536 * (sizeof(uintptr_t))}, {0, 0, 1792 * (sizeof(uintptr_t))}, {0, 0, 2048 * (sizeof(uintptr_t))}, {0, 0, 2560 * (sizeof(uintptr_t))}, {0, 0, 3072 * (sizeof(uintptr_t))}, {0, 0, 3584 * (sizeof(uintptr_t))}, {0, 0, 4096 * (sizeof(uintptr_t))}, {0, 0, 5120 * (sizeof(uintptr_t))}, {0, 0, 6144 * (sizeof(uintptr_t))}, {0, 0, 7168 * (sizeof(uintptr_t))}, {0, 0, 8192 * (sizeof(uintptr_t))}, {0, 0, 10240 * (sizeof(uintptr_t))}, {0, 0, 12288 * (sizeof(uintptr_t))}, {0, 0, 14336 * (sizeof(uintptr_t))}, {0, 0, 16384 * (sizeof(uintptr_t))}, {0, 0, 20480 * (sizeof(uintptr_t))}, {0, 0, 24576 * (sizeof(uintptr_t))}, {0, 0, 28672 * (sizeof(uintptr_t))}, {0, 0, 32768 * (sizeof(uintptr_t))}, {0, 0, 40960 * (sizeof(uintptr_t))}, {0, 0, 49152 * (sizeof(uintptr_t))}, {0, 0, 57344 * (sizeof(uintptr_t))}, {0, 0, 65536 * (sizeof(uintptr_t))}, {0, 0, 81920 * (sizeof(uintptr_t))}, {0, 0, 98304 * (sizeof(uintptr_t))}, {0, 0, 114688 * (sizeof(uintptr_t))}, {0, 0, 131072 * (sizeof(uintptr_t))}, {0, 0, 163840 * (sizeof(uintptr_t))}, {0, 0, 196608 * (sizeof(uintptr_t))}, {0, 0, 229376 * (sizeof(uintptr_t))}, {0, 0, 262144 * (sizeof(uintptr_t))}, {0, 0, 327680 * (sizeof(uintptr_t))}, {0, 0, 393216 * (sizeof(uintptr_t))}, {0, 0, 458752 * (sizeof(uintptr_t))}, {0, 0, 524288 * (sizeof(uintptr_t))}, {0, 0, ((((1UL << (3 + (13 + 3))) / 8) / (1 << 3)) + 1) * (sizeof(uintptr_t))}, {0, 0, ((((1UL << (3 + (13 + 3))) / 8) / (1 << 3)) + 2) * (sizeof(uintptr_t))}}}"
            ]
        },
        {
            "path": null,
            "name": "tld_main",
            "type": "mi_tld_t",
            "definition": [
                "static mi_tld_t tld_main = {0, 0, &_mi_heap_main, &_mi_heap_main, {{{0, 0, 1}, {0, 0, 1}, {0, 0, 2}, {0, 0, 3}, {0, 0, 4}, {0, 0, 5}, {0, 0, 6}, {0, 0, 7}, {0, 0, 10}, {0, 0, 12}, {0, 0, 14}, {0, 0, 16}, {0, 0, 20}, {0, 0, 24}, {0, 0, 28}, {0, 0, 32}, {0, 0, 40}, {0, 0, 48}, {0, 0, 56}, {0, 0, 64}, {0, 0, 80}, {0, 0, 96}, {0, 0, 112}, {0, 0, 128}, {0, 0, 160}, {0, 0, 192}, {0, 0, 224}, {0, 0, 256}, {0, 0, 320}, {0, 0, 384}, {0, 0, 448}, {0, 0, 512}, {0, 0, 640}, {0, 0, 768}, {0, 0, 896}, {0, 0, 1024}}, 0, 0, 0, 0, 0, &mi_subproc_default, &tld_main.stats}, {1, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0}, {0}, {0}, {0}, {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}}, {{0}, {0}, {0}, {0}}, {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}}, {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}}}}"
            ]
        },
        {
            "path": null,
            "name": "td_cache",
            "type": "mi_thread_data_t * _Atomic [32]",
            "definition": [
                "static mi_thread_data_t * _Atomic td_cache[32]"
            ]
        },
        {
            "path": null,
            "name": "thread_count",
            "type": "_Atomic size_t",
            "definition": [
                "static _Atomic size_t thread_count = 1"
            ]
        },
        {
            "path": null,
            "name": "os_preloading",
            "type": "bool",
            "definition": [
                "static bool os_preloading = 1"
            ]
        },
        {
            "path": null,
            "name": "mi_max_error_count",
            "type": "long",
            "definition": [
                "static long mi_max_error_count = 16"
            ]
        },
        {
            "path": null,
            "name": "mi_max_warning_count",
            "type": "long",
            "definition": [
                "static long mi_max_warning_count = 16"
            ]
        },
        {
            "path": null,
            "name": "options",
            "type": "mi_option_desc_t [_mi_option_last]",
            "definition": [
                "static mi_option_desc_t options[_mi_option_last] = {{1, UNINIT, mi_option_show_errors, \"show_errors\", 0}, {0, UNINIT, mi_option_show_stats, \"show_stats\", 0}, {0, UNINIT, mi_option_verbose, \"verbose\", 0}, {1, UNINIT, mi_option_eager_commit, \"eager_commit\", 0}, {2, UNINIT, mi_option_arena_eager_commit, \"arena_eager_commit\", \"eager_region_commit\"}, {1, UNINIT, mi_option_purge_decommits, \"purge_decommits\", \"reset_decommits\"}, {2, UNINIT, mi_option_allow_large_os_pages, \"allow_large_os_pages\", \"large_os_pages\"}, {0, UNINIT, mi_option_reserve_huge_os_pages, \"reserve_huge_os_pages\", 0}, {-1, UNINIT, mi_option_reserve_huge_os_pages_at, \"reserve_huge_os_pages_at\", 0}, {0, UNINIT, mi_option_reserve_os_memory, \"reserve_os_memory\", 0}, {0, UNINIT, mi_option_deprecated_segment_cache, \"deprecated_segment_cache\", 0}, {0, UNINIT, mi_option_deprecated_page_reset, \"deprecated_page_reset\", 0}, {0, UNINIT, mi_option_abandoned_page_purge, \"abandoned_page_purge\", \"abandoned_page_reset\"}, {0, UNINIT, mi_option_deprecated_segment_reset, \"deprecated_segment_reset\", 0}, {1, UNINIT, mi_option_eager_commit_delay, \"eager_commit_delay\", 0}, {10, UNINIT, mi_option_purge_delay, \"purge_delay\", \"reset_delay\"}, {0, UNINIT, mi_option_use_numa_nodes, \"use_numa_nodes\", 0}, {0, UNINIT, mi_option_disallow_os_alloc, \"disallow_os_alloc\", \"limit_os_alloc\"}, {100, UNINIT, mi_option_os_tag, \"os_tag\", 0}, {32, UNINIT, mi_option_max_errors, \"max_errors\", 0}, {32, UNINIT, mi_option_max_warnings, \"max_warnings\", 0}, {10, UNINIT, mi_option_max_segment_reclaim, \"max_segment_reclaim\", 0}, {0, UNINIT, mi_option_destroy_on_exit, \"destroy_on_exit\", 0}, {1024L * 1024L, UNINIT, mi_option_arena_reserve, \"arena_reserve\", 0}, {10, UNINIT, mi_option_arena_purge_mult, \"arena_purge_mult\", 0}, {1, UNINIT, mi_option_purge_extend_delay, \"purge_extend_delay\", \"decommit_extend_delay\"}, {0, UNINIT, mi_option_abandoned_reclaim_on_free, \"abandoned_reclaim_on_free\", 0}, {0, UNINIT, mi_option_disallow_arena_alloc, \"disallow_arena_alloc\", 0}, {400, UNINIT, mi_option_retry_on_oom, \"retry_on_oom\", 0}, {0, UNINIT, mi_option_visit_abandoned, \"visit_abandoned\", 0}, {0, UNINIT, mi_option_guarded_min, \"guarded_min\", 0}, {(1024UL * 1024UL) * 1024UL, UNINIT, mi_option_guarded_max, \"guarded_max\", 0}, {0, UNINIT, mi_option_guarded_precise, \"guarded_precise\", 0}, {0, UNINIT, mi_option_guarded_sample_rate, \"guarded_sample_rate\", 0}, {0, UNINIT, mi_option_guarded_sample_seed, \"guarded_sample_seed\", 0}, {0, UNINIT, mi_option_target_segments_per_thread, \"target_segments_per_thread\", 0}, {10000, UNINIT, mi_option_generic_collect, \"generic_collect\", 0}}"
            ]
        },
        {
            "path": null,
            "name": "out_buf",
            "type": "char [((size_t) (16 * 1024)) + 1]",
            "definition": [
                "static char out_buf[((size_t) (16 * 1024)) + 1]"
            ]
        },
        {
            "path": null,
            "name": "out_len",
            "type": "_Atomic size_t",
            "definition": [
                "static _Atomic size_t out_len"
            ]
        },
        {
            "path": null,
            "name": "mi_out_default",
            "type": "mi_output_fun * volatile",
            "definition": [
                "static mi_output_fun * volatile mi_out_default"
            ]
        },
        {
            "path": null,
            "name": "mi_out_arg",
            "type": "void * _Atomic",
            "definition": [
                "static void * _Atomic mi_out_arg"
            ]
        },
        {
            "path": null,
            "name": "error_count",
            "type": "_Atomic size_t",
            "definition": [
                "static _Atomic size_t error_count"
            ]
        },
        {
            "path": null,
            "name": "warning_count",
            "type": "_Atomic size_t",
            "definition": [
                "static _Atomic size_t warning_count"
            ]
        },
        {
            "path": null,
            "name": "recurse",
            "type": "bool",
            "definition": [
                "static bool recurse = 0"
            ]
        },
        {
            "path": null,
            "name": "mi_error_handler",
            "type": "mi_error_fun * volatile",
            "definition": [
                "static mi_error_fun * volatile mi_error_handler"
            ]
        },
        {
            "path": null,
            "name": "mi_error_arg",
            "type": "void * _Atomic",
            "definition": [
                "static void * _Atomic mi_error_arg"
            ]
        },
        {
            "path": null,
            "name": "mi_os_mem_config",
            "type": "mi_os_mem_config_t",
            "definition": [
                "static mi_os_mem_config_t mi_os_mem_config = {4096, 0, 4096, 32 * (1024UL * 1024UL), 48, 1, 0, 1}"
            ]
        },
        {
            "path": null,
            "name": "aligned_base",
            "type": "_Atomic uintptr_t",
            "definition": [
                "static _Atomic uintptr_t aligned_base"
            ]
        },
        {
            "path": null,
            "name": "mi_huge_start",
            "type": "_Atomic uintptr_t",
            "definition": [
                "static _Atomic uintptr_t mi_huge_start"
            ]
        },
        {
            "path": null,
            "name": "mi_numa_node_count",
            "type": "_Atomic size_t",
            "definition": [
                "static _Atomic size_t mi_numa_node_count"
            ]
        },
        {
            "path": null,
            "name": "deferred_free",
            "type": "mi_deferred_free_fun * volatile",
            "definition": [
                "static mi_deferred_free_fun * volatile deferred_free = 0"
            ]
        },
        {
            "path": null,
            "name": "deferred_arg",
            "type": "void * _Atomic",
            "definition": [
                "static void * _Atomic deferred_arg"
            ]
        },
        {
            "path": null,
            "name": "mi_segment_map",
            "type": "mi_segmap_part_t * _Atomic [(((48 * 1024ULL) * ((1024UL * 1024UL) * 1024UL)) / ((8 * (((1 << 3) * 1024UL) - 128)) * (1UL << (9 + (13 + 3))))) + 1]",
            "definition": [
                "static mi_segmap_part_t * _Atomic mi_segment_map[(((48 * 1024ULL) * ((1024UL * 1024UL) * 1024UL)) / ((8 * (((1 << 3) * 1024UL) - 128)) * (1UL << (9 + (13 + 3))))) + 1]"
            ]
        },
        {
            "path": null,
            "name": "mi_process_start",
            "type": "mi_msecs_t",
            "definition": [
                "static mi_msecs_t mi_process_start"
            ]
        },
        {
            "path": null,
            "name": "mi_clock_diff",
            "type": "mi_msecs_t",
            "definition": [
                "static mi_msecs_t mi_clock_diff"
            ]
        },
        {
            "path": null,
            "name": "environ",
            "type": "char **",
            "definition": [
                "extern char **environ"
            ]
        },
        {
            "path": null,
            "name": "_mi_heap_default_key",
            "type": "pthread_key_t",
            "definition": [
                "pthread_key_t _mi_heap_default_key = (pthread_key_t) (-1)"
            ]
        }
    ],
    "function": [
        {
            "path": null,
            "name": "mi_malloc",
            "header": "void *mi_malloc(size_t size)",
            "params": [
                "size_t size"
            ],
            "definition": "inline extern void *mi_malloc(size_t size)\n{\n  return mi_heap_malloc(mi_prim_get_default_heap(), size);\n}\n\n",
            "calle": [
                "mi_heap_malloc",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_calloc",
            "header": "void *mi_calloc(size_t count, size_t size)",
            "params": [
                "size_t count",
                "size_t size"
            ],
            "definition": "void *mi_calloc(size_t count, size_t size)\n{\n  return mi_heap_calloc(mi_prim_get_default_heap(), count, size);\n}\n\n",
            "calle": [
                "mi_heap_calloc",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_realloc",
            "header": "void *mi_realloc(void *p, size_t newsize)",
            "params": [
                "void *p",
                "size_t newsize"
            ],
            "definition": "void *mi_realloc(void *p, size_t newsize)\n{\n  return mi_heap_realloc(mi_prim_get_default_heap(), p, newsize);\n}\n\n",
            "calle": [
                "mi_heap_realloc",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_expand",
            "header": "void *mi_expand(void *p, size_t newsize)",
            "params": [
                "void *p",
                "size_t newsize"
            ],
            "definition": "void *mi_expand(void *p, size_t newsize)\n{\n  (void) p;\n  (void) newsize;\n  return 0;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_free",
            "header": "void mi_free(void *p)",
            "params": [
                "void *p"
            ],
            "definition": "void mi_free(void *p)\n{\n  mi_segment_t * const segment = mi_checked_ptr_segment(p, \"mi_free\");\n  if (__builtin_expect(!(!(segment == 0)), 0))\n  {\n    return;\n  }\n  const bool is_local = _mi_prim_thread_id() == atomic_load_explicit(&segment->thread_id, memory_order_relaxed);\n  mi_page_t * const page = _mi_segment_page_of(segment, p);\n  if (__builtin_expect(!(!is_local), 1))\n  {\n    if (__builtin_expect(!(!(page->flags.full_aligned == 0)), 1))\n    {\n      mi_block_t * const block = (mi_block_t *) p;\n      mi_free_block_local(page, block, 1, 0);\n    }\n    else\n    {\n      mi_free_generic_local(page, segment, p);\n    }\n  }\n  else\n  {\n    mi_free_generic_mt(page, segment, p);\n  }\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_prim_thread_id",
                "_mi_segment_page_of",
                "atomic_load_explicit",
                "mi_checked_ptr_segment",
                "mi_free_block_local",
                "mi_free_generic_local",
                "mi_free_generic_mt"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t * const",
                        "definition": [
                            "mi_segment_t * const segment = mi_checked_ptr_segment(p, \"mi_free\")"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_local",
                        "type": "const bool",
                        "definition": [
                            "const bool is_local = _mi_prim_thread_id() == atomic_load_explicit(&segment->thread_id, memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t * const",
                        "definition": [
                            "mi_page_t * const page = _mi_segment_page_of(segment, p)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "mi_block_t * const",
                        "definition": [
                            "mi_block_t * const block = (mi_block_t *) p"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_strdup",
            "header": "char *mi_strdup(const char *s)",
            "params": [
                "const char *s"
            ],
            "definition": "char *mi_strdup(const char *s)\n{\n  return mi_heap_strdup(mi_prim_get_default_heap(), s);\n}\n\n",
            "calle": [
                "mi_heap_strdup",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "s",
                        "type": "const char *",
                        "definition": [
                            "const char *s"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_strndup",
            "header": "char *mi_strndup(const char *s, size_t n)",
            "params": [
                "const char *s",
                "size_t n"
            ],
            "definition": "char *mi_strndup(const char *s, size_t n)\n{\n  return mi_heap_strndup(mi_prim_get_default_heap(), s, n);\n}\n\n",
            "calle": [
                "mi_heap_strndup",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "s",
                        "type": "const char *",
                        "definition": [
                            "const char *s"
                        ]
                    },
                    {
                        "path": null,
                        "name": "n",
                        "type": "size_t",
                        "definition": [
                            "size_t n"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_realpath",
            "header": "char *mi_realpath(const char *fname, char *resolved_name)",
            "params": [
                "const char *fname",
                "char *resolved_name"
            ],
            "definition": "char *mi_realpath(const char *fname, char *resolved_name)\n{\n  return mi_heap_realpath(mi_prim_get_default_heap(), fname, resolved_name);\n}\n\n",
            "calle": [
                "mi_heap_realpath",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "fname",
                        "type": "const char *",
                        "definition": [
                            "const char *fname"
                        ]
                    },
                    {
                        "path": null,
                        "name": "resolved_name",
                        "type": "char *",
                        "definition": [
                            "char *resolved_name"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_malloc_small",
            "header": "void *mi_malloc_small(size_t size)",
            "params": [
                "size_t size"
            ],
            "definition": "inline extern void *mi_malloc_small(size_t size)\n{\n  return mi_heap_malloc_small(mi_prim_get_default_heap(), size);\n}\n\n",
            "calle": [
                "mi_heap_malloc_small",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_zalloc_small",
            "header": "void *mi_zalloc_small(size_t size)",
            "params": [
                "size_t size"
            ],
            "definition": "void *mi_zalloc_small(size_t size)\n{\n  return mi_heap_malloc_small_zero(mi_prim_get_default_heap(), size, 1);\n}\n\n",
            "calle": [
                "mi_heap_malloc_small_zero",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_zalloc",
            "header": "void *mi_zalloc(size_t size)",
            "params": [
                "size_t size"
            ],
            "definition": "void *mi_zalloc(size_t size)\n{\n  return mi_heap_zalloc(mi_prim_get_default_heap(), size);\n}\n\n",
            "calle": [
                "mi_heap_zalloc",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_mallocn",
            "header": "void *mi_mallocn(size_t count, size_t size)",
            "params": [
                "size_t count",
                "size_t size"
            ],
            "definition": "void *mi_mallocn(size_t count, size_t size)\n{\n  return mi_heap_mallocn(mi_prim_get_default_heap(), count, size);\n}\n\n",
            "calle": [
                "mi_heap_mallocn",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_reallocn",
            "header": "void *mi_reallocn(void *p, size_t count, size_t size)",
            "params": [
                "void *p",
                "size_t count",
                "size_t size"
            ],
            "definition": "void *mi_reallocn(void *p, size_t count, size_t size)\n{\n  return mi_heap_reallocn(mi_prim_get_default_heap(), p, count, size);\n}\n\n",
            "calle": [
                "mi_heap_reallocn",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_reallocf",
            "header": "void *mi_reallocf(void *p, size_t newsize)",
            "params": [
                "void *p",
                "size_t newsize"
            ],
            "definition": "void *mi_reallocf(void *p, size_t newsize)\n{\n  return mi_heap_reallocf(mi_prim_get_default_heap(), p, newsize);\n}\n\n",
            "calle": [
                "mi_heap_reallocf",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_usable_size",
            "header": "size_t mi_usable_size(const void *p)",
            "params": [
                "const void *p"
            ],
            "definition": "size_t mi_usable_size(const void *p)\n{\n  return _mi_usable_size(p, \"mi_usable_size\");\n}\n\n",
            "calle": [
                "_mi_usable_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_malloc",
            "header": "void *mi_heap_malloc(mi_heap_t *heap, size_t size)",
            "params": [
                "mi_heap_t *heap",
                "size_t size"
            ],
            "definition": "inline extern void *mi_heap_malloc(mi_heap_t *heap, size_t size)\n{\n  return _mi_heap_malloc_zero(heap, size, 0);\n}\n\n",
            "calle": [
                "_mi_heap_malloc_zero"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_zalloc",
            "header": "void *mi_heap_zalloc(mi_heap_t *heap, size_t size)",
            "params": [
                "mi_heap_t *heap",
                "size_t size"
            ],
            "definition": "inline extern void *mi_heap_zalloc(mi_heap_t *heap, size_t size)\n{\n  return _mi_heap_malloc_zero(heap, size, 1);\n}\n\n",
            "calle": [
                "_mi_heap_malloc_zero"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_calloc",
            "header": "void *mi_heap_calloc(mi_heap_t *heap, size_t count, size_t size)",
            "params": [
                "mi_heap_t *heap",
                "size_t count",
                "size_t size"
            ],
            "definition": "inline extern void *mi_heap_calloc(mi_heap_t *heap, size_t count, size_t size)\n{\n  size_t total;\n  if (mi_count_size_overflow(count, size, &total))\n  {\n    return 0;\n  }\n  return mi_heap_zalloc(heap, total);\n}\n\n",
            "calle": [
                "mi_count_size_overflow",
                "mi_heap_zalloc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "total",
                        "type": "size_t",
                        "definition": [
                            "size_t total"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_mallocn",
            "header": "void *mi_heap_mallocn(mi_heap_t *heap, size_t count, size_t size)",
            "params": [
                "mi_heap_t *heap",
                "size_t count",
                "size_t size"
            ],
            "definition": "extern void *mi_heap_mallocn(mi_heap_t *heap, size_t count, size_t size)\n{\n  size_t total;\n  if (mi_count_size_overflow(count, size, &total))\n  {\n    return 0;\n  }\n  return mi_heap_malloc(heap, total);\n}\n\n",
            "calle": [
                "mi_count_size_overflow",
                "mi_heap_malloc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "total",
                        "type": "size_t",
                        "definition": [
                            "size_t total"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_malloc_small",
            "header": "void *mi_heap_malloc_small(mi_heap_t *heap, size_t size)",
            "params": [
                "mi_heap_t *heap",
                "size_t size"
            ],
            "definition": "inline extern void *mi_heap_malloc_small(mi_heap_t *heap, size_t size)\n{\n  return mi_heap_malloc_small_zero(heap, size, 0);\n}\n\n",
            "calle": [
                "mi_heap_malloc_small_zero"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_realloc",
            "header": "void *mi_heap_realloc(mi_heap_t *heap, void *p, size_t newsize)",
            "params": [
                "mi_heap_t *heap",
                "void *p",
                "size_t newsize"
            ],
            "definition": "void *mi_heap_realloc(mi_heap_t *heap, void *p, size_t newsize)\n{\n  return _mi_heap_realloc_zero(heap, p, newsize, 0);\n}\n\n",
            "calle": [
                "_mi_heap_realloc_zero"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_reallocn",
            "header": "void *mi_heap_reallocn(mi_heap_t *heap, void *p, size_t count, size_t size)",
            "params": [
                "mi_heap_t *heap",
                "void *p",
                "size_t count",
                "size_t size"
            ],
            "definition": "void *mi_heap_reallocn(mi_heap_t *heap, void *p, size_t count, size_t size)\n{\n  size_t total;\n  if (mi_count_size_overflow(count, size, &total))\n  {\n    return 0;\n  }\n  return mi_heap_realloc(heap, p, total);\n}\n\n",
            "calle": [
                "mi_count_size_overflow",
                "mi_heap_realloc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "total",
                        "type": "size_t",
                        "definition": [
                            "size_t total"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_reallocf",
            "header": "void *mi_heap_reallocf(mi_heap_t *heap, void *p, size_t newsize)",
            "params": [
                "mi_heap_t *heap",
                "void *p",
                "size_t newsize"
            ],
            "definition": "void *mi_heap_reallocf(mi_heap_t *heap, void *p, size_t newsize)\n{\n  void *newp = mi_heap_realloc(heap, p, newsize);\n  if ((newp == 0) && (p != 0))\n  {\n    mi_free(p);\n  }\n  return newp;\n}\n\n",
            "calle": [
                "mi_free",
                "mi_heap_realloc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newp",
                        "type": "void *",
                        "definition": [
                            "void *newp = mi_heap_realloc(heap, p, newsize)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_strdup",
            "header": "char *mi_heap_strdup(mi_heap_t *heap, const char *s)",
            "params": [
                "mi_heap_t *heap",
                "const char *s"
            ],
            "definition": "char *mi_heap_strdup(mi_heap_t *heap, const char *s)\n{\n  if (s == 0)\n  {\n    return 0;\n  }\n  size_t len = _mi_strlen(s);\n  char *t = (char *) mi_heap_malloc(heap, len + 1);\n  if (t == 0)\n  {\n    return 0;\n  }\n  _mi_memcpy(t, s, len);\n  t[len] = 0;\n  return t;\n}\n\n",
            "calle": [
                "_mi_memcpy",
                "_mi_strlen",
                "mi_heap_malloc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "s",
                        "type": "const char *",
                        "definition": [
                            "const char *s"
                        ]
                    },
                    {
                        "path": null,
                        "name": "len",
                        "type": "size_t",
                        "definition": [
                            "size_t len = _mi_strlen(s)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "t",
                        "type": "char *",
                        "definition": [
                            "char *t = (char *) mi_heap_malloc(heap, len + 1)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_strndup",
            "header": "char *mi_heap_strndup(mi_heap_t *heap, const char *s, size_t n)",
            "params": [
                "mi_heap_t *heap",
                "const char *s",
                "size_t n"
            ],
            "definition": "char *mi_heap_strndup(mi_heap_t *heap, const char *s, size_t n)\n{\n  if (s == 0)\n  {\n    return 0;\n  }\n  const size_t len = _mi_strnlen(s, n);\n  char *t = (char *) mi_heap_malloc(heap, len + 1);\n  if (t == 0)\n  {\n    return 0;\n  }\n  _mi_memcpy(t, s, len);\n  t[len] = 0;\n  return t;\n}\n\n",
            "calle": [
                "_mi_memcpy",
                "_mi_strnlen",
                "mi_heap_malloc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "s",
                        "type": "const char *",
                        "definition": [
                            "const char *s"
                        ]
                    },
                    {
                        "path": null,
                        "name": "n",
                        "type": "size_t",
                        "definition": [
                            "size_t n"
                        ]
                    },
                    {
                        "path": null,
                        "name": "len",
                        "type": "const size_t",
                        "definition": [
                            "const size_t len = _mi_strnlen(s, n)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "t",
                        "type": "char *",
                        "definition": [
                            "char *t = (char *) mi_heap_malloc(heap, len + 1)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_realpath",
            "header": "char *mi_heap_realpath(mi_heap_t *heap, const char *fname, char *resolved_name)",
            "params": [
                "mi_heap_t *heap",
                "const char *fname",
                "char *resolved_name"
            ],
            "definition": "char *mi_heap_realpath(mi_heap_t *heap, const char *fname, char *resolved_name)\n{\n  if (resolved_name != 0)\n  {\n    return realpath(fname, resolved_name);\n  }\n  else\n  {\n    char *rname = realpath(fname, 0);\n    if (rname == 0)\n    {\n      return 0;\n    }\n    char *result = mi_heap_strdup(heap, rname);\n    mi_cfree(rname);\n    return result;\n  }\n}\n\n",
            "calle": [
                "mi_cfree",
                "mi_heap_strdup",
                "realpath"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fname",
                        "type": "const char *",
                        "definition": [
                            "const char *fname"
                        ]
                    },
                    {
                        "path": null,
                        "name": "resolved_name",
                        "type": "char *",
                        "definition": [
                            "char *resolved_name"
                        ]
                    },
                    {
                        "path": null,
                        "name": "rname",
                        "type": "char *",
                        "definition": [
                            "char *rname = realpath(fname, 0)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "result",
                        "type": "char *",
                        "definition": [
                            "char *result = mi_heap_strdup(heap, rname)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_rezalloc",
            "header": "void *mi_rezalloc(void *p, size_t newsize)",
            "params": [
                "void *p",
                "size_t newsize"
            ],
            "definition": "void *mi_rezalloc(void *p, size_t newsize)\n{\n  return mi_heap_rezalloc(mi_prim_get_default_heap(), p, newsize);\n}\n\n",
            "calle": [
                "mi_heap_rezalloc",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_recalloc",
            "header": "void *mi_recalloc(void *p, size_t newcount, size_t size)",
            "params": [
                "void *p",
                "size_t count",
                "size_t size"
            ],
            "definition": "void *mi_recalloc(void *p, size_t count, size_t size)\n{\n  return mi_heap_recalloc(mi_prim_get_default_heap(), p, count, size);\n}\n\n",
            "calle": [
                "mi_heap_recalloc",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_rezalloc",
            "header": "void *mi_heap_rezalloc(mi_heap_t *heap, void *p, size_t newsize)",
            "params": [
                "mi_heap_t *heap",
                "void *p",
                "size_t newsize"
            ],
            "definition": "void *mi_heap_rezalloc(mi_heap_t *heap, void *p, size_t newsize)\n{\n  return _mi_heap_realloc_zero(heap, p, newsize, 1);\n}\n\n",
            "calle": [
                "_mi_heap_realloc_zero"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_recalloc",
            "header": "void *mi_heap_recalloc(mi_heap_t *heap, void *p, size_t newcount, size_t size)",
            "params": [
                "mi_heap_t *heap",
                "void *p",
                "size_t count",
                "size_t size"
            ],
            "definition": "void *mi_heap_recalloc(mi_heap_t *heap, void *p, size_t count, size_t size)\n{\n  size_t total;\n  if (mi_count_size_overflow(count, size, &total))\n  {\n    return 0;\n  }\n  return mi_heap_rezalloc(heap, p, total);\n}\n\n",
            "calle": [
                "mi_count_size_overflow",
                "mi_heap_rezalloc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "total",
                        "type": "size_t",
                        "definition": [
                            "size_t total"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_free_size",
            "header": "void mi_free_size(void *p, size_t size)",
            "params": [
                "void *p",
                "size_t size"
            ],
            "definition": "void mi_free_size(void *p, size_t size)\n{\n  ;\n  const size_t available = _mi_usable_size(p, \"mi_free_size\");\n  (((p == 0) || (size <= available)) || (available == 0)) ? ((void) 0) : (_mi_assert_fail(\"p == NULL || size <= available || available == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/free.c\", 352, __func__));\n  mi_free(p);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_usable_size",
                "mi_free"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "available",
                        "type": "const size_t",
                        "definition": [
                            "const size_t available = _mi_usable_size(p, \"mi_free_size\")"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_free_size_aligned",
            "header": "void mi_free_size_aligned(void *p, size_t size, size_t alignment)",
            "params": [
                "void *p",
                "size_t size",
                "size_t alignment"
            ],
            "definition": "void mi_free_size_aligned(void *p, size_t size, size_t alignment)\n{\n  ;\n  ((((uintptr_t) p) % alignment) == 0) ? ((void) 0) : (_mi_assert_fail(\"((uintptr_t)p % alignment) == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/free.c\", 359, __func__));\n  mi_free_size(p, size);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_free_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_free_aligned",
            "header": "void mi_free_aligned(void *p, size_t alignment)",
            "params": [
                "void *p",
                "size_t alignment"
            ],
            "definition": "void mi_free_aligned(void *p, size_t alignment)\n{\n  ;\n  ((((uintptr_t) p) % alignment) == 0) ? ((void) 0) : (_mi_assert_fail(\"((uintptr_t)p % alignment) == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/free.c\", 365, __func__));\n  mi_free(p);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_free"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_new",
            "header": "void *mi_new(size_t size)",
            "params": [
                "size_t size"
            ],
            "definition": "void *mi_new(size_t size)\n{\n  return mi_heap_alloc_new(mi_prim_get_default_heap(), size);\n}\n\n",
            "calle": [
                "mi_heap_alloc_new",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_new_aligned",
            "header": "void *mi_new_aligned(size_t size, size_t alignment)",
            "params": [
                "size_t size",
                "size_t alignment"
            ],
            "definition": "void *mi_new_aligned(size_t size, size_t alignment)\n{\n  void *p;\n  unsigned int p_idx = 0;\n  do\n  {\n    p_idx = mi_malloc_aligned(size, alignment);\n  }\n  while (((&p[p_idx]) == 0) && mi_try_new_handler(0));\n  return p;\n}\n\n",
            "calle": [
                "mi_malloc_aligned",
                "mi_try_new_handler"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int p_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_new_nothrow",
            "header": "void *mi_new_nothrow(size_t size)",
            "params": [
                "size_t size"
            ],
            "definition": "void *mi_new_nothrow(size_t size)\n{\n  void *p = mi_malloc(size);\n  if (__builtin_expect(!(!(p == 0)), 0))\n  {\n    return mi_try_new(size, 1);\n  }\n  return p;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "mi_malloc",
                "mi_try_new"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = mi_malloc(size)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_new_aligned_nothrow",
            "header": "void *mi_new_aligned_nothrow(size_t size, size_t alignment)",
            "params": [
                "size_t size",
                "size_t alignment"
            ],
            "definition": "void *mi_new_aligned_nothrow(size_t size, size_t alignment)\n{\n  void *p;\n  unsigned int p_idx = 0;\n  do\n  {\n    p_idx = mi_malloc_aligned(size, alignment);\n  }\n  while (((&p[p_idx]) == 0) && mi_try_new_handler(1));\n  return p;\n}\n\n",
            "calle": [
                "mi_malloc_aligned",
                "mi_try_new_handler"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int p_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_new_n",
            "header": "void *mi_new_n(size_t count, size_t size)",
            "params": [
                "size_t count",
                "size_t size"
            ],
            "definition": "void *mi_new_n(size_t count, size_t size)\n{\n  return mi_heap_alloc_new_n(mi_prim_get_default_heap(), count, size);\n}\n\n",
            "calle": [
                "mi_heap_alloc_new_n",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_new_realloc",
            "header": "void *mi_new_realloc(void *p, size_t newsize)",
            "params": [
                "void *p",
                "size_t newsize"
            ],
            "definition": "void *mi_new_realloc(void *p, size_t newsize)\n{\n  void *q;\n  unsigned int q_idx = 0;\n  do\n  {\n    q_idx = mi_realloc(p, newsize);\n  }\n  while (((&q[q_idx]) == 0) && mi_try_new_handler(0));\n  return q;\n}\n\n",
            "calle": [
                "mi_realloc",
                "mi_try_new_handler"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "q",
                        "type": "void *",
                        "definition": [
                            "void *q"
                        ]
                    },
                    {
                        "path": null,
                        "name": "q_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int q_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_new_reallocn",
            "header": "void *mi_new_reallocn(void *p, size_t newcount, size_t size)",
            "params": [
                "void *p",
                "size_t newcount",
                "size_t size"
            ],
            "definition": "void *mi_new_reallocn(void *p, size_t newcount, size_t size)\n{\n  size_t total;\n  if (__builtin_expect(!(!mi_count_size_overflow(newcount, size, &total)), 0))\n  {\n    mi_try_new_handler(0);\n    return 0;\n  }\n  else\n  {\n    return mi_new_realloc(p, total);\n  }\n}\n\n",
            "calle": [
                "__builtin_expect",
                "mi_count_size_overflow",
                "mi_new_realloc",
                "mi_try_new_handler"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newcount",
                        "type": "size_t",
                        "definition": [
                            "size_t newcount"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "total",
                        "type": "size_t",
                        "definition": [
                            "size_t total"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_alloc_new",
            "header": "void *mi_heap_alloc_new(mi_heap_t *heap, size_t size)",
            "params": [
                "mi_heap_t *heap",
                "size_t size"
            ],
            "definition": "void *mi_heap_alloc_new(mi_heap_t *heap, size_t size)\n{\n  void *p = mi_heap_malloc(heap, size);\n  if (__builtin_expect(!(!(p == 0)), 0))\n  {\n    return mi_heap_try_new(heap, size, 0);\n  }\n  return p;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "mi_heap_malloc",
                "mi_heap_try_new"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = mi_heap_malloc(heap, size)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_alloc_new_n",
            "header": "void *mi_heap_alloc_new_n(mi_heap_t *heap, size_t count, size_t size)",
            "params": [
                "mi_heap_t *heap",
                "size_t count",
                "size_t size"
            ],
            "definition": "void *mi_heap_alloc_new_n(mi_heap_t *heap, size_t count, size_t size)\n{\n  size_t total;\n  if (__builtin_expect(!(!mi_count_size_overflow(count, size, &total)), 0))\n  {\n    mi_try_new_handler(0);\n    return 0;\n  }\n  else\n  {\n    return mi_heap_alloc_new(heap, total);\n  }\n}\n\n",
            "calle": [
                "__builtin_expect",
                "mi_count_size_overflow",
                "mi_heap_alloc_new",
                "mi_try_new_handler"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "total",
                        "type": "size_t",
                        "definition": [
                            "size_t total"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_atomic_yield",
            "header": "inline static void mi_atomic_yield(void)",
            "params": [
                "void"
            ],
            "definition": "inline static void mi_atomic_yield(void)\n{\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_atomic_addi",
            "header": "inline static intptr_t mi_atomic_addi(_Atomic intptr_t *p, intptr_t add)",
            "params": [
                "_Atomic intptr_t *p",
                "intptr_t add"
            ],
            "definition": "inline static intptr_t mi_atomic_addi(_Atomic intptr_t *p, intptr_t add)\n{\n  return (intptr_t) atomic_fetch_add_explicit((uintptr_t *) p, (uintptr_t) add, memory_order_acq_rel);\n}\n\n",
            "calle": [
                "atomic_fetch_add_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "_Atomic intptr_t *",
                        "definition": [
                            "_Atomic intptr_t *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "add",
                        "type": "intptr_t",
                        "definition": [
                            "intptr_t add"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_atomic_subi",
            "header": "inline static intptr_t mi_atomic_subi(_Atomic intptr_t *p, intptr_t sub)",
            "params": [
                "_Atomic intptr_t *p",
                "intptr_t sub"
            ],
            "definition": "inline static intptr_t mi_atomic_subi(_Atomic intptr_t *p, intptr_t sub)\n{\n  return (intptr_t) mi_atomic_addi(p, -sub);\n}\n\n",
            "calle": [
                "mi_atomic_addi"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "_Atomic intptr_t *",
                        "definition": [
                            "_Atomic intptr_t *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "sub",
                        "type": "intptr_t",
                        "definition": [
                            "intptr_t sub"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_atomic_addi64_relaxed",
            "header": "",
            "params": [
                "volatile int64_t *p",
                "int64_t add"
            ],
            "definition": "inline static int64_t mi_atomic_addi64_relaxed(volatile int64_t *p, int64_t add)\n{\n  return atomic_fetch_add_explicit((int64_t *) p, add, memory_order_relaxed);\n}\n\n",
            "calle": [
                "atomic_fetch_add_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "volatile int64_t *",
                        "definition": [
                            "volatile int64_t *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "add",
                        "type": "int64_t",
                        "definition": [
                            "int64_t add"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_atomic_void_addi64_relaxed",
            "header": "",
            "params": [
                "volatile int64_t *p",
                "const volatile int64_t *padd"
            ],
            "definition": "inline static void mi_atomic_void_addi64_relaxed(volatile int64_t *p, const volatile int64_t *padd)\n{\n  const int64_t add = atomic_load_explicit((int64_t *) padd, memory_order_relaxed);\n  if (add != 0)\n  {\n    atomic_fetch_add_explicit((int64_t *) p, add, memory_order_relaxed);\n  }\n}\n\n",
            "calle": [
                "atomic_fetch_add_explicit",
                "atomic_load_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "volatile int64_t *",
                        "definition": [
                            "volatile int64_t *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "padd",
                        "type": "const volatile int64_t *",
                        "definition": [
                            "const volatile int64_t *padd"
                        ]
                    },
                    {
                        "path": null,
                        "name": "add",
                        "type": "const int64_t",
                        "definition": [
                            "const int64_t add = atomic_load_explicit((int64_t *) padd, memory_order_relaxed)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_atomic_maxi64_relaxed",
            "header": "",
            "params": [
                "volatile int64_t *p",
                "int64_t x"
            ],
            "definition": "inline static void mi_atomic_maxi64_relaxed(volatile int64_t *p, int64_t x)\n{\n  int64_t current = atomic_load_explicit((int64_t *) p, memory_order_relaxed);\n  while ((current < x) && (!atomic_compare_exchange_weak_explicit((int64_t *) p, &current, x, memory_order_release, memory_order_relaxed)))\n  {\n  }\n\n  ;\n}\n\n",
            "calle": [
                "atomic_compare_exchange_weak_explicit",
                "atomic_load_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "volatile int64_t *",
                        "definition": [
                            "volatile int64_t *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "x",
                        "type": "int64_t",
                        "definition": [
                            "int64_t x"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current",
                        "type": "int64_t",
                        "definition": [
                            "int64_t current = atomic_load_explicit((int64_t *) p, memory_order_relaxed)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_atomic_once",
            "header": "",
            "params": [
                "mi_atomic_once_t *once"
            ],
            "definition": "inline static bool mi_atomic_once(mi_atomic_once_t *once)\n{\n  if (atomic_load_explicit(once, memory_order_relaxed) != 0)\n  {\n    return 0;\n  }\n  uintptr_t expected = 0;\n  return atomic_compare_exchange_strong_explicit(once, &expected, (uintptr_t) 1, memory_order_acq_rel, memory_order_acquire);\n}\n\n",
            "calle": [
                "atomic_compare_exchange_strong_explicit",
                "atomic_load_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "once",
                        "type": "mi_atomic_once_t *",
                        "definition": [
                            "mi_atomic_once_t *once"
                        ]
                    },
                    {
                        "path": null,
                        "name": "expected",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t expected = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_lock_try_acquire",
            "header": "",
            "params": [
                "pthread_mutex_t *lock"
            ],
            "definition": "inline static bool mi_lock_try_acquire(pthread_mutex_t *lock)\n{\n  return pthread_mutex_trylock(lock) == 0;\n}\n\n",
            "calle": [
                "pthread_mutex_trylock"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "lock",
                        "type": "pthread_mutex_t *",
                        "definition": [
                            "pthread_mutex_t *lock"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_lock_acquire",
            "header": "",
            "params": [
                "pthread_mutex_t *lock"
            ],
            "definition": "inline static void mi_lock_acquire(pthread_mutex_t *lock)\n{\n  const int err = pthread_mutex_lock(lock);\n  if (err != 0)\n  {\n    _mi_error_message(err, \"internal error: lock cannot be acquired\\n\");\n  }\n}\n\n",
            "calle": [
                "_mi_error_message",
                "pthread_mutex_lock"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "lock",
                        "type": "pthread_mutex_t *",
                        "definition": [
                            "pthread_mutex_t *lock"
                        ]
                    },
                    {
                        "path": null,
                        "name": "err",
                        "type": "const int",
                        "definition": [
                            "const int err = pthread_mutex_lock(lock)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_lock_release",
            "header": "",
            "params": [
                "pthread_mutex_t *lock"
            ],
            "definition": "inline static void mi_lock_release(pthread_mutex_t *lock)\n{\n  pthread_mutex_unlock(lock);\n}\n\n",
            "calle": [
                "pthread_mutex_unlock"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "lock",
                        "type": "pthread_mutex_t *",
                        "definition": [
                            "pthread_mutex_t *lock"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_lock_init",
            "header": "",
            "params": [
                "pthread_mutex_t *lock"
            ],
            "definition": "inline static void mi_lock_init(pthread_mutex_t *lock)\n{\n  pthread_mutex_init(lock, 0);\n}\n\n",
            "calle": [
                "pthread_mutex_init"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "lock",
                        "type": "pthread_mutex_t *",
                        "definition": [
                            "pthread_mutex_t *lock"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_lock_done",
            "header": "",
            "params": [
                "pthread_mutex_t *lock"
            ],
            "definition": "inline static void mi_lock_done(pthread_mutex_t *lock)\n{\n  pthread_mutex_destroy(lock);\n}\n\n",
            "calle": [
                "pthread_mutex_destroy"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "lock",
                        "type": "pthread_mutex_t *",
                        "definition": [
                            "pthread_mutex_t *lock"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_memkind_is_os",
            "header": "",
            "params": [
                "mi_memkind_t memkind"
            ],
            "definition": "inline static bool mi_memkind_is_os(mi_memkind_t memkind)\n{\n  return (memkind >= MI_MEM_OS) && (memkind <= MI_MEM_OS_REMAP);\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "memkind",
                        "type": "mi_memkind_t",
                        "definition": [
                            "mi_memkind_t memkind"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_random_shuffle",
            "header": "inline static uintptr_t _mi_random_shuffle(uintptr_t x)",
            "params": [
                "uintptr_t x"
            ],
            "definition": "inline static uintptr_t _mi_random_shuffle(uintptr_t x)\n{\n  if (x == 0)\n  {\n    x = 17;\n  }\n  x ^= x >> 30;\n  x *= 0xbf58476d1ce4e5b9UL;\n  x ^= x >> 27;\n  x *= 0x94d049bb133111ebUL;\n  x ^= x >> 31;\n  return x;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "x",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t x"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_page_malloc_zero",
            "header": "void *_mi_page_malloc_zero(mi_heap_t *heap, mi_page_t *page, size_t size, bool zero)",
            "params": [
                "mi_heap_t *heap",
                "mi_page_t *page",
                "size_t size",
                "bool zero"
            ],
            "definition": "inline extern void *_mi_page_malloc_zero(mi_heap_t *heap, mi_page_t *page, size_t size, bool zero)\n{\n  (size >= (sizeof(mi_padding_t))) ? ((void) 0) : (_mi_assert_fail(\"size >= MI_PADDING_SIZE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc.c\", 33, __func__));\n  ((page->block_size == 0) || (mi_page_block_size(page) >= size)) ? ((void) 0) : (_mi_assert_fail(\"page->block_size == 0 || mi_page_block_size(page) >= size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc.c\", 34, __func__));\n  mi_block_t * const block = page->free;\n  if (__builtin_expect(!(!(block == 0)), 0))\n  {\n    return _mi_malloc_generic(heap, size, zero, 0);\n  }\n  ((block != 0) && (_mi_ptr_page(block) == page)) ? ((void) 0) : (_mi_assert_fail(\"block != NULL && _mi_ptr_page(block) == page\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc.c\", 41, __func__));\n  page->free = mi_block_next(page, block);\n  page->used += 1;\n  ((page->free == 0) || (_mi_ptr_page(page->free) == page)) ? ((void) 0) : (_mi_assert_fail(\"page->free == NULL || _mi_ptr_page(page->free) == page\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc.c\", 46, __func__));\n  ((page->block_size < 16) || _mi_is_aligned(block, 16)) ? ((void) 0) : (_mi_assert_fail(\"page->block_size < MI_MAX_ALIGN_SIZE || _mi_is_aligned(block, MI_MAX_ALIGN_SIZE)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc.c\", 47, __func__));\n  ;\n  if (__builtin_expect(!(!zero), 0))\n  {\n    (page->block_size != 0) ? ((void) 0) : (_mi_assert_fail(\"page->block_size != 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc.c\", 62, __func__));\n    (!mi_page_is_huge(page)) ? ((void) 0) : (_mi_assert_fail(\"!mi_page_is_huge(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc.c\", 63, __func__));\n    (page->block_size >= (sizeof(mi_padding_t))) ? ((void) 0) : (_mi_assert_fail(\"page->block_size >= MI_PADDING_SIZE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc.c\", 65, __func__));\n    if (page->free_is_zero)\n    {\n      block->next = 0;\n      ;\n    }\n    else\n    {\n      _mi_memzero_aligned(block, page->block_size - (sizeof(mi_padding_t)));\n    }\n  }\n  if ((!zero) && (!mi_page_is_huge(page)))\n  {\n    memset(block, 0xD0, mi_page_usable_block_size(page));\n  }\n  const size_t bsize = mi_page_usable_block_size(page);\n  if (bsize <= ((1UL << (3 + (13 + 3))) / 8))\n  {\n    _mi_stat_increase(&heap->tld->stats.malloc_normal, bsize);\n    _mi_stat_counter_increase(&heap->tld->stats.malloc_normal_count, 1);\n    const size_t bin = _mi_bin(bsize);\n    _mi_stat_increase(&heap->tld->stats.malloc_bins[bin], 1);\n    _mi_stat_increase(&heap->tld->stats.malloc_requested, size - (sizeof(mi_padding_t)));\n  }\n  mi_padding_t * const padding = (mi_padding_t *) (((uint8_t *) block) + mi_page_usable_block_size(page));\n  ptrdiff_t delta = (((uint8_t *) padding) - ((uint8_t *) block)) - (size - (sizeof(mi_padding_t)));\n  ((delta >= 0) && (mi_page_usable_block_size(page) >= ((size - (sizeof(mi_padding_t))) + delta))) ? ((void) 0) : (_mi_assert_fail(\"delta >= 0 && mi_page_usable_block_size(page) >= (size - MI_PADDING_SIZE + delta)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc.c\", 101, __func__));\n  ;\n  padding->canary = mi_ptr_encode_canary(page, block, page->keys);\n  padding->delta = (uint32_t) delta;\n  if (!mi_page_is_huge(page))\n  {\n    uint8_t *fill = ((uint8_t *) padding) - delta;\n    const size_t maxpad = (delta > 16) ? (16) : (delta);\n    for (size_t i = 0; i < maxpad; i += 1)\n    {\n      fill[i] = 0xDE;\n    }\n\n  }\n  return block;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_bin",
                "_mi_is_aligned",
                "_mi_malloc_generic",
                "_mi_memzero_aligned",
                "_mi_ptr_page",
                "_mi_stat_counter_increase",
                "_mi_stat_increase",
                "memset",
                "mi_block_next",
                "mi_page_block_size",
                "mi_page_is_huge",
                "mi_page_usable_block_size",
                "mi_ptr_encode_canary"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "zero",
                        "type": "bool",
                        "definition": [
                            "bool zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "mi_block_t * const",
                        "definition": [
                            "mi_block_t * const block = page->free"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bsize = mi_page_usable_block_size(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bin",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bin = _mi_bin(bsize)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "padding",
                        "type": "mi_padding_t * const",
                        "definition": [
                            "mi_padding_t * const padding = (mi_padding_t *) (((uint8_t *) block) + mi_page_usable_block_size(page))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "delta",
                        "type": "ptrdiff_t",
                        "definition": [
                            "ptrdiff_t delta = (((uint8_t *) padding) - ((uint8_t *) block)) - (size - (sizeof(mi_padding_t)))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fill",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *fill = ((uint8_t *) padding) - delta"
                        ]
                    },
                    {
                        "path": null,
                        "name": "maxpad",
                        "type": "const size_t",
                        "definition": [
                            "const size_t maxpad = (delta > 16) ? (16) : (delta)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_page_malloc",
            "header": "void *_mi_page_malloc(mi_heap_t *heap, mi_page_t *page, size_t size)",
            "params": [
                "mi_heap_t *heap",
                "mi_page_t *page",
                "size_t size"
            ],
            "definition": "extern void *_mi_page_malloc(mi_heap_t *heap, mi_page_t *page, size_t size)\n{\n  return _mi_page_malloc_zero(heap, page, size, 0);\n}\n\n",
            "calle": [
                "_mi_page_malloc_zero"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_page_malloc_zeroed",
            "header": "void *_mi_page_malloc_zeroed(mi_heap_t *heap, mi_page_t *page, size_t size)",
            "params": [
                "mi_heap_t *heap",
                "mi_page_t *page",
                "size_t size"
            ],
            "definition": "extern void *_mi_page_malloc_zeroed(mi_heap_t *heap, mi_page_t *page, size_t size)\n{\n  return _mi_page_malloc_zero(heap, page, size, 1);\n}\n\n",
            "calle": [
                "_mi_page_malloc_zero"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_malloc_zero",
            "header": "void *_mi_heap_malloc_zero(mi_heap_t *heap, size_t size, bool zero)",
            "params": [
                "mi_heap_t *heap",
                "size_t size",
                "bool zero"
            ],
            "definition": "inline extern void *_mi_heap_malloc_zero(mi_heap_t *heap, size_t size, bool zero)\n{\n  return _mi_heap_malloc_zero_ex(heap, size, zero, 0);\n}\n\n",
            "calle": [
                "_mi_heap_malloc_zero_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "zero",
                        "type": "bool",
                        "definition": [
                            "bool zero"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_malloc_zero_ex",
            "header": "void *_mi_heap_malloc_zero_ex(mi_heap_t *heap, size_t size, bool zero, size_t huge_alignment)",
            "params": [
                "mi_heap_t *heap",
                "size_t size",
                "bool zero",
                "size_t huge_alignment"
            ],
            "definition": "inline extern void *_mi_heap_malloc_zero_ex(mi_heap_t *heap, size_t size, bool zero, size_t huge_alignment)\n{\n  if (__builtin_expect(!(!(size <= (128 * (sizeof(void *))))), 1))\n  {\n    (huge_alignment == 0) ? ((void) 0) : (_mi_assert_fail(\"huge_alignment == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc.c\", 172, __func__));\n    return mi_heap_malloc_small_zero(heap, size, zero);\n  }\n  else\n  {\n    (heap != 0) ? ((void) 0) : (_mi_assert_fail(\"heap!=NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc.c\", 182, __func__));\n    ((heap->thread_id == 0) || (heap->thread_id == _mi_thread_id())) ? ((void) 0) : (_mi_assert_fail(\"heap->thread_id == 0 || heap->thread_id == _mi_thread_id()\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc.c\", 183, __func__));\n    void * const p = _mi_malloc_generic(heap, size + (sizeof(mi_padding_t)), zero, huge_alignment);\n    if (p != 0)\n    {\n      (mi_usable_size(p) == size) ? ((void) 0) : (_mi_assert_fail(\"mi_usable_size(p)==(size)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc.c\", 185, __func__));\n      ;\n    }\n    ;\n    return p;\n  }\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_malloc_generic",
                "_mi_thread_id",
                "mi_heap_malloc_small_zero",
                "mi_usable_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "zero",
                        "type": "bool",
                        "definition": [
                            "bool zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "huge_alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t huge_alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void * const",
                        "definition": [
                            "void * const p = _mi_malloc_generic(heap, size + (sizeof(mi_padding_t)), zero, huge_alignment)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_realloc_zero",
            "header": "void *_mi_heap_realloc_zero(mi_heap_t *heap, void *p, size_t newsize, bool zero)",
            "params": [
                "mi_heap_t *heap",
                "void *p",
                "size_t newsize",
                "bool zero"
            ],
            "definition": "void *_mi_heap_realloc_zero(mi_heap_t *heap, void *p, size_t newsize, bool zero)\n{\n  const size_t size = _mi_usable_size(p, \"mi_realloc\");\n  if (__builtin_expect(!(!(((newsize <= size) && (newsize >= (size / 2))) && (newsize > 0))), 0))\n  {\n    (p != 0) ? ((void) 0) : (_mi_assert_fail(\"p!=NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc.c\", 263, __func__));\n    return p;\n  }\n  void *newp = mi_heap_malloc(heap, newsize);\n  if (__builtin_expect(!(!(newp != 0)), 1))\n  {\n    if (zero && (newsize > size))\n    {\n      const size_t start = (size >= (sizeof(intptr_t))) ? (size - (sizeof(intptr_t))) : (0);\n      _mi_memzero(((uint8_t *) newp) + start, newsize - start);\n    }\n    else\n      if (newsize == 0)\n    {\n      ((uint8_t *) newp)[0] = 0;\n    }\n    if (__builtin_expect(!(!(p != 0)), 1))\n    {\n      const size_t copysize = (newsize > size) ? (size) : (newsize);\n      ;\n      _mi_memcpy(newp, p, copysize);\n      mi_free(p);\n    }\n  }\n  return newp;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_memcpy",
                "_mi_memzero",
                "_mi_usable_size",
                "mi_free",
                "mi_heap_malloc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "zero",
                        "type": "bool",
                        "definition": [
                            "bool zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t size = _mi_usable_size(p, \"mi_realloc\")"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newp",
                        "type": "void *",
                        "definition": [
                            "void *newp = mi_heap_malloc(heap, newsize)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "const size_t",
                        "definition": [
                            "const size_t start = (size >= (sizeof(intptr_t))) ? (size - (sizeof(intptr_t))) : (0)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "copysize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t copysize = (newsize > size) ? (size) : (newsize)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_page_ptr_unalign",
            "header": "mi_block_t *_mi_page_ptr_unalign(const mi_page_t *page, const void *p)",
            "params": [
                "const mi_page_t *page",
                "const void *p"
            ],
            "definition": "mi_block_t *_mi_page_ptr_unalign(const mi_page_t *page, const void *p)\n{\n  ((page != 0) && (p != 0)) ? ((void) 0) : (_mi_assert_fail(\"page!=NULL && p!=NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/free.c\", 59, __func__));\n  size_t diff = ((uint8_t *) p) - page->page_start;\n  size_t adjust;\n  if (__builtin_expect(!(!(page->block_size_shift != 0)), 1))\n  {\n    adjust = diff & ((((size_t) 1) << page->block_size_shift) - 1);\n  }\n  else\n  {\n    adjust = diff % mi_page_block_size(page);\n  }\n  return (mi_block_t *) (((uintptr_t) p) - adjust);\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "mi_page_block_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "diff",
                        "type": "size_t",
                        "definition": [
                            "size_t diff = ((uint8_t *) p) - page->page_start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "adjust",
                        "type": "size_t",
                        "definition": [
                            "size_t adjust"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_free_delayed_block",
            "header": "bool _mi_free_delayed_block(mi_block_t *block)",
            "params": [
                "mi_block_t *block"
            ],
            "definition": "bool _mi_free_delayed_block(mi_block_t *block)\n{\n  (block != 0) ? ((void) 0) : (_mi_assert_fail(\"block!=NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/free.c\", 178, __func__));\n  const mi_segment_t * const segment = _mi_ptr_segment(block);\n  (_mi_ptr_cookie(segment) == segment->cookie) ? ((void) 0) : (_mi_assert_fail(\"_mi_ptr_cookie(segment) == segment->cookie\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/free.c\", 180, __func__));\n  (_mi_thread_id() == segment->thread_id) ? ((void) 0) : (_mi_assert_fail(\"_mi_thread_id() == segment->thread_id\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/free.c\", 181, __func__));\n  mi_page_t * const page = _mi_segment_page_of(segment, block);\n  if (!_mi_page_try_use_delayed_free(page, MI_USE_DELAYED_FREE, 0))\n  {\n    return 0;\n  }\n  _mi_page_free_collect(page, 0);\n  mi_free_block_local(page, block, 0, 1);\n  return 1;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_page_free_collect",
                "_mi_page_try_use_delayed_free",
                "_mi_ptr_cookie",
                "_mi_ptr_segment",
                "_mi_segment_page_of",
                "_mi_thread_id",
                "mi_free_block_local"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "block",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "const mi_segment_t * const",
                        "definition": [
                            "const mi_segment_t * const segment = _mi_ptr_segment(block)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t * const",
                        "definition": [
                            "mi_page_t * const page = _mi_segment_page_of(segment, block)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_free_generic",
            "header": "void _mi_free_generic(mi_segment_t *segment, mi_page_t *page, bool is_local, void *p)",
            "params": [
                "mi_segment_t *segment",
                "mi_page_t *page",
                "bool is_local",
                "void *p"
            ],
            "definition": "void _mi_free_generic(mi_segment_t *segment, mi_page_t *page, bool is_local, void *p)\n{\n  if (is_local)\n  {\n    mi_free_generic_local(page, segment, p);\n  }\n  else\n    mi_free_generic_mt(page, segment, p);\n}\n\n",
            "calle": [
                "mi_free_generic_local",
                "mi_free_generic_mt"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_local",
                        "type": "bool",
                        "definition": [
                            "bool is_local"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_padding_shrink",
            "header": "void _mi_padding_shrink(const mi_page_t *page, const mi_block_t *block, const size_t min_size)",
            "params": [
                "const mi_page_t *page",
                "const mi_block_t *block",
                "const size_t min_size"
            ],
            "definition": "void _mi_padding_shrink(const mi_page_t *page, const mi_block_t *block, const size_t min_size)\n{\n  size_t bsize;\n  size_t delta;\n  bool ok = mi_page_decode_padding(page, block, &delta, &bsize);\n  (ok) ? ((void) 0) : (_mi_assert_fail(\"ok\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/free.c\", 457, __func__));\n  if ((!ok) || ((bsize - delta) >= min_size))\n  {\n    return;\n  }\n  (bsize >= min_size) ? ((void) 0) : (_mi_assert_fail(\"bsize >= min_size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/free.c\", 459, __func__));\n  if (bsize < min_size)\n  {\n    return;\n  }\n  size_t new_delta = bsize - min_size;\n  (new_delta < bsize) ? ((void) 0) : (_mi_assert_fail(\"new_delta < bsize\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/free.c\", 462, __func__));\n  mi_padding_t *padding = (mi_padding_t *) (((uint8_t *) block) + bsize);\n  ;\n  padding->delta = (uint32_t) new_delta;\n  ;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_page_decode_padding"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "const mi_block_t *",
                        "definition": [
                            "const mi_block_t *block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "min_size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t min_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "size_t",
                        "definition": [
                            "size_t bsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "delta",
                        "type": "size_t",
                        "definition": [
                            "size_t delta"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ok",
                        "type": "bool",
                        "definition": [
                            "bool ok = mi_page_decode_padding(page, block, &delta, &bsize)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "new_delta",
                        "type": "size_t",
                        "definition": [
                            "size_t new_delta = bsize - min_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "padding",
                        "type": "mi_padding_t *",
                        "definition": [
                            "mi_padding_t *padding = (mi_padding_t *) (((uint8_t *) block) + bsize)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_is_power_of_two",
            "header": "",
            "params": [
                "uintptr_t x"
            ],
            "definition": "inline static bool _mi_is_power_of_two(uintptr_t x)\n{\n  return (x & (x - 1)) == 0;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "x",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t x"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_is_aligned",
            "header": "",
            "params": [
                "void *p",
                "size_t alignment"
            ],
            "definition": "inline static bool _mi_is_aligned(void *p, size_t alignment)\n{\n  (alignment != 0) ? ((void) 0) : (_mi_assert_fail(\"alignment != 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 380, __func__));\n  return (((uintptr_t) p) % alignment) == 0;\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_align_up",
            "header": "",
            "params": [
                "uintptr_t sz",
                "size_t alignment"
            ],
            "definition": "inline static uintptr_t _mi_align_up(uintptr_t sz, size_t alignment)\n{\n  (alignment != 0) ? ((void) 0) : (_mi_assert_fail(\"alignment != 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 386, __func__));\n  uintptr_t mask = alignment - 1;\n  if ((alignment & mask) == 0)\n  {\n    return (sz + mask) & (~mask);\n  }\n  else\n  {\n    return ((sz + mask) / alignment) * alignment;\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "sz",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t sz"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t mask = alignment - 1"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_align_down",
            "header": "",
            "params": [
                "uintptr_t sz",
                "size_t alignment"
            ],
            "definition": "inline static uintptr_t _mi_align_down(uintptr_t sz, size_t alignment)\n{\n  (alignment != 0) ? ((void) 0) : (_mi_assert_fail(\"alignment != 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 398, __func__));\n  uintptr_t mask = alignment - 1;\n  if ((alignment & mask) == 0)\n  {\n    return sz & (~mask);\n  }\n  else\n  {\n    return (sz / alignment) * alignment;\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "sz",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t sz"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t mask = alignment - 1"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_align_up_ptr",
            "header": "",
            "params": [
                "void *p",
                "size_t alignment"
            ],
            "definition": "inline static void *mi_align_up_ptr(void *p, size_t alignment)\n{\n  return (void *) _mi_align_up((uintptr_t) p, alignment);\n}\n\n",
            "calle": [
                "_mi_align_up"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_align_down_ptr",
            "header": "",
            "params": [
                "void *p",
                "size_t alignment"
            ],
            "definition": "inline static void *mi_align_down_ptr(void *p, size_t alignment)\n{\n  return (void *) _mi_align_down((uintptr_t) p, alignment);\n}\n\n",
            "calle": [
                "_mi_align_down"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_divide_up",
            "header": "",
            "params": [
                "uintptr_t size",
                "size_t divider"
            ],
            "definition": "inline static uintptr_t _mi_divide_up(uintptr_t size, size_t divider)\n{\n  (divider != 0) ? ((void) 0) : (_mi_assert_fail(\"divider != 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 421, __func__));\n  return (divider == 0) ? (size) : (((size + divider) - 1) / divider);\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "divider",
                        "type": "size_t",
                        "definition": [
                            "size_t divider"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_clamp",
            "header": "",
            "params": [
                "size_t sz",
                "size_t min",
                "size_t max"
            ],
            "definition": "inline static size_t _mi_clamp(size_t sz, size_t min, size_t max)\n{\n  if (sz < min)\n  {\n    return min;\n  }\n  else\n    if (sz > max)\n  {\n    return max;\n  }\n  else\n    return sz;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "sz",
                        "type": "size_t",
                        "definition": [
                            "size_t sz"
                        ]
                    },
                    {
                        "path": null,
                        "name": "min",
                        "type": "size_t",
                        "definition": [
                            "size_t min"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max",
                        "type": "size_t",
                        "definition": [
                            "size_t max"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_mem_is_zero",
            "header": "",
            "params": [
                "const void *p",
                "size_t size"
            ],
            "definition": "inline static bool mi_mem_is_zero(const void *p, size_t size)\n{\n  for (size_t i = 0; i < size; i += 1)\n  {\n    if (((uint8_t *) p)[i] != 0)\n    {\n      return 0;\n    }\n  }\n\n  return 1;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_wsize_from_size",
            "header": "",
            "params": [
                "size_t size"
            ],
            "definition": "inline static size_t _mi_wsize_from_size(size_t size)\n{\n  (size <= (SIZE_MAX - (sizeof(uintptr_t)))) ? ((void) 0) : (_mi_assert_fail(\"size <= SIZE_MAX - sizeof(uintptr_t)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 445, __func__));\n  return ((size + (sizeof(uintptr_t))) - 1) / (sizeof(uintptr_t));\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_mul_overflow",
            "header": "",
            "params": [
                "size_t count",
                "size_t size",
                "size_t *total"
            ],
            "definition": "inline static bool mi_mul_overflow(size_t count, size_t size, size_t *total)\n{\n  return __builtin_umulll_overflow(count, size, (unsigned long long *) total);\n}\n\n",
            "calle": [
                "__builtin_umulll_overflow"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "total",
                        "type": "size_t *",
                        "definition": [
                            "size_t *total"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_count_size_overflow",
            "header": "",
            "params": [
                "size_t count",
                "size_t size",
                "size_t *total"
            ],
            "definition": "inline static bool mi_count_size_overflow(size_t count, size_t size, size_t *total)\n{\n  if (count == 1)\n  {\n    *total = size;\n    return 0;\n  }\n  else\n    if (__builtin_expect(!(!mi_mul_overflow(count, size, total)), 0))\n  {\n    _mi_error_message(75, \"allocation request is too large (%zu * %zu bytes)\\n\", count, size);\n    *total = SIZE_MAX;\n    return 1;\n  }\n  else\n    return 0;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_error_message",
                "mi_mul_overflow"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "total",
                        "type": "size_t *",
                        "definition": [
                            "size_t *total"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_is_backing",
            "header": "",
            "params": [
                "const mi_heap_t *heap"
            ],
            "definition": "inline static bool mi_heap_is_backing(const mi_heap_t *heap)\n{\n  return heap->tld->heap_backing == heap;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "const mi_heap_t *",
                        "definition": [
                            "const mi_heap_t *heap"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_is_initialized",
            "header": "",
            "params": [
                "mi_heap_t *heap"
            ],
            "definition": "inline static bool mi_heap_is_initialized(mi_heap_t *heap)\n{\n  (heap != 0) ? ((void) 0) : (_mi_assert_fail(\"heap != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 501, __func__));\n  return (heap != 0) && (heap != (&_mi_heap_empty));\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_empty",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_ptr_cookie",
            "header": "",
            "params": [
                "const void *p"
            ],
            "definition": "inline static uintptr_t _mi_ptr_cookie(const void *p)\n{\n  extern mi_heap_t _mi_heap_main;\n  (_mi_heap_main.cookie != 0) ? ((void) 0) : (_mi_assert_fail(\"_mi_heap_main.cookie != 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 507, __func__));\n  return ((uintptr_t) p) ^ _mi_heap_main.cookie;\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_main",
                        "type": "mi_heap_t",
                        "definition": [
                            "extern mi_heap_t _mi_heap_main"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_get_free_small_page",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "size_t size"
            ],
            "definition": "inline static mi_page_t *_mi_heap_get_free_small_page(mi_heap_t *heap, size_t size)\n{\n  (size <= ((128 * (sizeof(void *))) + (sizeof(mi_padding_t)))) ? ((void) 0) : (_mi_assert_fail(\"size <= (MI_SMALL_SIZE_MAX + MI_PADDING_SIZE)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 516, __func__));\n  const size_t idx = _mi_wsize_from_size(size);\n  (idx < ((128 + ((((sizeof(mi_padding_t)) + (1 << 3)) - 1) / (1 << 3))) + 1)) ? ((void) 0) : (_mi_assert_fail(\"idx < MI_PAGES_DIRECT\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 518, __func__));\n  return heap->pages_free_direct[idx];\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_wsize_from_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "const size_t",
                        "definition": [
                            "const size_t idx = _mi_wsize_from_size(size)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_ptr_segment",
            "header": "",
            "params": [
                "const void *p"
            ],
            "definition": "inline static mi_segment_t *_mi_ptr_segment(const void *p)\n{\n  mi_segment_t * const segment = (mi_segment_t *) ((((uintptr_t) p) - 1) & (~((uintptr_t) ((1UL << (9 + (13 + 3))) - 1))));\n  return (((intptr_t) segment) <= 0) ? (0) : (segment);\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t * const",
                        "definition": [
                            "mi_segment_t * const segment = (mi_segment_t *) ((((uintptr_t) p) - 1) & (~((uintptr_t) ((1UL << (9 + (13 + 3))) - 1))))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_slice_to_page",
            "header": "",
            "params": [
                "mi_slice_t *s"
            ],
            "definition": "inline static mi_page_t *mi_slice_to_page(mi_slice_t *s)\n{\n  ((s->slice_offset == 0) && (s->slice_count > 0)) ? ((void) 0) : (_mi_assert_fail(\"s->slice_offset== 0 && s->slice_count > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 537, __func__));\n  return (mi_page_t *) s;\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "s",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *s"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_to_slice",
            "header": "",
            "params": [
                "mi_page_t *p"
            ],
            "definition": "inline static mi_slice_t *mi_page_to_slice(mi_page_t *p)\n{\n  ((p->slice_offset == 0) && (p->slice_count > 0)) ? ((void) 0) : (_mi_assert_fail(\"p->slice_offset== 0 && p->slice_count > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 542, __func__));\n  return (mi_slice_t *) p;\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *p"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_page_segment",
            "header": "",
            "params": [
                "const mi_page_t *page"
            ],
            "definition": "inline static mi_segment_t *_mi_page_segment(const mi_page_t *page)\n{\n  (page != 0) ? ((void) 0) : (_mi_assert_fail(\"page!=NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 548, __func__));\n  mi_segment_t *segment = _mi_ptr_segment(page);\n  ((segment == 0) || ((((mi_slice_t *) page) >= segment->slices) && (((mi_slice_t *) page) < (segment->slices + segment->slice_entries)))) ? ((void) 0) : (_mi_assert_fail(\"segment == NULL || ((mi_slice_t*)page >= segment->slices && (mi_slice_t*)page < segment->slices + segment->slice_entries)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 550, __func__));\n  return segment;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_ptr_segment"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = _mi_ptr_segment(page)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_slice_first",
            "header": "",
            "params": [
                "const mi_slice_t *slice"
            ],
            "definition": "inline static mi_slice_t *mi_slice_first(const mi_slice_t *slice)\n{\n  mi_slice_t *start = (mi_slice_t *) (((uint8_t *) slice) - slice->slice_offset);\n  (start >= _mi_ptr_segment(slice)->slices) ? ((void) 0) : (_mi_assert_fail(\"start >= _mi_ptr_segment(slice)->slices\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 556, __func__));\n  (start->slice_offset == 0) ? ((void) 0) : (_mi_assert_fail(\"start->slice_offset == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 557, __func__));\n  ((start + start->slice_count) > slice) ? ((void) 0) : (_mi_assert_fail(\"start + start->slice_count > slice\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 558, __func__));\n  return start;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_ptr_segment"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "slice",
                        "type": "const mi_slice_t *",
                        "definition": [
                            "const mi_slice_t *slice"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *start = (mi_slice_t *) (((uint8_t *) slice) - slice->slice_offset)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_segment_page_of",
            "header": "",
            "params": [
                "const mi_segment_t *segment",
                "const void *p"
            ],
            "definition": "inline static mi_page_t *_mi_segment_page_of(const mi_segment_t *segment, const void *p)\n{\n  (p > ((void *) segment)) ? ((void) 0) : (_mi_assert_fail(\"p > (void*)segment\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 564, __func__));\n  ptrdiff_t diff = ((uint8_t *) p) - ((uint8_t *) segment);\n  ((diff > 0) && (diff <= ((ptrdiff_t) (1UL << (9 + (13 + 3)))))) ? ((void) 0) : (_mi_assert_fail(\"diff > 0 && diff <= (ptrdiff_t)MI_SEGMENT_SIZE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 566, __func__));\n  size_t idx = ((size_t) diff) >> (13 + 3);\n  (idx <= segment->slice_entries) ? ((void) 0) : (_mi_assert_fail(\"idx <= segment->slice_entries\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 568, __func__));\n  mi_slice_t *slice0 = (mi_slice_t *) (&segment->slices[idx]);\n  mi_slice_t *slice = mi_slice_first(slice0);\n  (slice->slice_offset == 0) ? ((void) 0) : (_mi_assert_fail(\"slice->slice_offset == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 571, __func__));\n  ((slice >= segment->slices) && (slice < (segment->slices + segment->slice_entries))) ? ((void) 0) : (_mi_assert_fail(\"slice >= segment->slices && slice < segment->slices + segment->slice_entries\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 572, __func__));\n  return mi_slice_to_page(slice);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_slice_first",
                "mi_slice_to_page"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "const mi_segment_t *",
                        "definition": [
                            "const mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "diff",
                        "type": "ptrdiff_t",
                        "definition": [
                            "ptrdiff_t diff = ((uint8_t *) p) - ((uint8_t *) segment)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t",
                        "definition": [
                            "size_t idx = ((size_t) diff) >> (13 + 3)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice0",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *slice0 = (mi_slice_t *) (&segment->slices[idx])"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *slice = mi_slice_first(slice0)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_start",
            "header": "",
            "params": [
                "const mi_page_t *page"
            ],
            "definition": "inline static uint8_t *mi_page_start(const mi_page_t *page)\n{\n  (page->page_start != 0) ? ((void) 0) : (_mi_assert_fail(\"page->page_start != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 578, __func__));\n  ;\n  return page->page_start;\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_ptr_page",
            "header": "",
            "params": [
                "void *p"
            ],
            "definition": "inline static mi_page_t *_mi_ptr_page(void *p)\n{\n  (p != 0) ? ((void) 0) : (_mi_assert_fail(\"p!=NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 585, __func__));\n  return _mi_segment_page_of(_mi_ptr_segment(p), p);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_ptr_segment",
                "_mi_segment_page_of"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_block_size",
            "header": "",
            "params": [
                "const mi_page_t *page"
            ],
            "definition": "inline static size_t mi_page_block_size(const mi_page_t *page)\n{\n  (page->block_size > 0) ? ((void) 0) : (_mi_assert_fail(\"page->block_size > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 591, __func__));\n  return page->block_size;\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_is_huge",
            "header": "",
            "params": [
                "const mi_page_t *page"
            ],
            "definition": "inline static bool mi_page_is_huge(const mi_page_t *page)\n{\n  ((page->is_huge && (_mi_page_segment(page)->kind == MI_SEGMENT_HUGE)) || ((!page->is_huge) && (_mi_page_segment(page)->kind != MI_SEGMENT_HUGE))) ? ((void) 0) : (_mi_assert_fail(\"(page->is_huge && _mi_page_segment(page)->kind == MI_SEGMENT_HUGE) || (!page->is_huge && _mi_page_segment(page)->kind != MI_SEGMENT_HUGE)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 596, __func__));\n  return page->is_huge;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_page_segment"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_usable_block_size",
            "header": "",
            "params": [
                "const mi_page_t *page"
            ],
            "definition": "inline static size_t mi_page_usable_block_size(const mi_page_t *page)\n{\n  return mi_page_block_size(page) - (sizeof(mi_padding_t));\n}\n\n",
            "calle": [
                "mi_page_block_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_size",
            "header": "",
            "params": [
                "mi_segment_t *segment"
            ],
            "definition": "inline static size_t mi_segment_size(mi_segment_t *segment)\n{\n  return segment->segment_slices * (1UL << (13 + 3));\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_end",
            "header": "",
            "params": [
                "mi_segment_t *segment"
            ],
            "definition": "inline static uint8_t *mi_segment_end(mi_segment_t *segment)\n{\n  return ((uint8_t *) segment) + mi_segment_size(segment);\n}\n\n",
            "calle": [
                "mi_segment_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_thread_free",
            "header": "",
            "params": [
                "const mi_page_t *page"
            ],
            "definition": "inline static mi_block_t *mi_page_thread_free(const mi_page_t *page)\n{\n  return (mi_block_t *) (atomic_load_explicit(&((mi_page_t *) page)->xthread_free, memory_order_relaxed) & (~3));\n}\n\n",
            "calle": [
                "atomic_load_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_thread_free_flag",
            "header": "",
            "params": [
                "const mi_page_t *page"
            ],
            "definition": "inline static mi_delayed_t mi_page_thread_free_flag(const mi_page_t *page)\n{\n  return (mi_delayed_t) (atomic_load_explicit(&((mi_page_t *) page)->xthread_free, memory_order_relaxed) & 3);\n}\n\n",
            "calle": [
                "atomic_load_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_heap",
            "header": "",
            "params": [
                "const mi_page_t *page"
            ],
            "definition": "inline static mi_heap_t *mi_page_heap(const mi_page_t *page)\n{\n  return (mi_heap_t *) atomic_load_explicit(&((mi_page_t *) page)->xheap, memory_order_relaxed);\n}\n\n",
            "calle": [
                "atomic_load_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_set_heap",
            "header": "",
            "params": [
                "mi_page_t *page",
                "mi_heap_t *heap"
            ],
            "definition": "inline static void mi_page_set_heap(mi_page_t *page, mi_heap_t *heap)\n{\n  (mi_page_thread_free_flag(page) != MI_DELAYED_FREEING) ? ((void) 0) : (_mi_assert_fail(\"mi_page_thread_free_flag(page) != MI_DELAYED_FREEING\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 631, __func__));\n  atomic_store_explicit(&page->xheap, (uintptr_t) heap, memory_order_release);\n  if (heap != 0)\n  {\n    page->heap_tag = heap->tag;\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "atomic_store_explicit",
                "mi_page_thread_free_flag"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_tf_block",
            "header": "",
            "params": [
                "mi_thread_free_t tf"
            ],
            "definition": "inline static mi_block_t *mi_tf_block(mi_thread_free_t tf)\n{\n  return (mi_block_t *) (tf & (~0x03));\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "tf",
                        "type": "mi_thread_free_t",
                        "definition": [
                            "mi_thread_free_t tf"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_tf_delayed",
            "header": "",
            "params": [
                "mi_thread_free_t tf"
            ],
            "definition": "inline static mi_delayed_t mi_tf_delayed(mi_thread_free_t tf)\n{\n  return (mi_delayed_t) (tf & 0x03);\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "tf",
                        "type": "mi_thread_free_t",
                        "definition": [
                            "mi_thread_free_t tf"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_tf_make",
            "header": "",
            "params": [
                "mi_block_t *block",
                "mi_delayed_t delayed"
            ],
            "definition": "inline static mi_thread_free_t mi_tf_make(mi_block_t *block, mi_delayed_t delayed)\n{\n  return (mi_thread_free_t) (((uintptr_t) block) | ((uintptr_t) delayed));\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "block",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "delayed",
                        "type": "mi_delayed_t",
                        "definition": [
                            "mi_delayed_t delayed"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_tf_set_delayed",
            "header": "",
            "params": [
                "mi_thread_free_t tf",
                "mi_delayed_t delayed"
            ],
            "definition": "inline static mi_thread_free_t mi_tf_set_delayed(mi_thread_free_t tf, mi_delayed_t delayed)\n{\n  return mi_tf_make(mi_tf_block(tf), delayed);\n}\n\n",
            "calle": [
                "mi_tf_block",
                "mi_tf_make"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "tf",
                        "type": "mi_thread_free_t",
                        "definition": [
                            "mi_thread_free_t tf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "delayed",
                        "type": "mi_delayed_t",
                        "definition": [
                            "mi_delayed_t delayed"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_tf_set_block",
            "header": "",
            "params": [
                "mi_thread_free_t tf",
                "mi_block_t *block"
            ],
            "definition": "inline static mi_thread_free_t mi_tf_set_block(mi_thread_free_t tf, mi_block_t *block)\n{\n  return mi_tf_make(block, mi_tf_delayed(tf));\n}\n\n",
            "calle": [
                "mi_tf_delayed",
                "mi_tf_make"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "tf",
                        "type": "mi_thread_free_t",
                        "definition": [
                            "mi_thread_free_t tf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *block"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_all_free",
            "header": "",
            "params": [
                "const mi_page_t *page"
            ],
            "definition": "inline static bool mi_page_all_free(const mi_page_t *page)\n{\n  (page != 0) ? ((void) 0) : (_mi_assert_fail(\"page != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 656, __func__));\n  return page->used == 0;\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_has_any_available",
            "header": "",
            "params": [
                "const mi_page_t *page"
            ],
            "definition": "inline static bool mi_page_has_any_available(const mi_page_t *page)\n{\n  ((page != 0) && (page->reserved > 0)) ? ((void) 0) : (_mi_assert_fail(\"page != NULL && page->reserved > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 662, __func__));\n  return (page->used < page->reserved) || (mi_page_thread_free(page) != 0);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_page_thread_free"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_immediate_available",
            "header": "",
            "params": [
                "const mi_page_t *page"
            ],
            "definition": "inline static bool mi_page_immediate_available(const mi_page_t *page)\n{\n  (page != 0) ? ((void) 0) : (_mi_assert_fail(\"page != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 668, __func__));\n  return page->free != 0;\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_is_mostly_used",
            "header": "",
            "params": [
                "const mi_page_t *page"
            ],
            "definition": "inline static bool mi_page_is_mostly_used(const mi_page_t *page)\n{\n  if (page == 0)\n  {\n    return 1;\n  }\n  uint16_t frac = page->reserved / 8U;\n  return (page->reserved - page->used) <= frac;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "frac",
                        "type": "uint16_t",
                        "definition": [
                            "uint16_t frac = page->reserved / 8U"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_queue",
            "header": "",
            "params": [
                "const mi_heap_t *heap",
                "size_t size"
            ],
            "definition": "inline static mi_page_queue_t *mi_page_queue(const mi_heap_t *heap, size_t size)\n{\n  return &((mi_heap_t *) heap)->pages[_mi_bin(size)];\n}\n\n",
            "calle": [
                "_mi_bin"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "const mi_heap_t *",
                        "definition": [
                            "const mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_is_in_full",
            "header": "",
            "params": [
                "const mi_page_t *page"
            ],
            "definition": "inline static bool mi_page_is_in_full(const mi_page_t *page)\n{\n  return page->flags.x.in_full;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_set_in_full",
            "header": "",
            "params": [
                "mi_page_t *page",
                "bool in_full"
            ],
            "definition": "inline static void mi_page_set_in_full(mi_page_t *page, bool in_full)\n{\n  page->flags.x.in_full = in_full;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "in_full",
                        "type": "bool",
                        "definition": [
                            "bool in_full"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_has_aligned",
            "header": "",
            "params": [
                "const mi_page_t *page"
            ],
            "definition": "inline static bool mi_page_has_aligned(const mi_page_t *page)\n{\n  return page->flags.x.has_aligned;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_set_has_aligned",
            "header": "",
            "params": [
                "mi_page_t *page",
                "bool has_aligned"
            ],
            "definition": "inline static void mi_page_set_has_aligned(mi_page_t *page, bool has_aligned)\n{\n  page->flags.x.has_aligned = has_aligned;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "has_aligned",
                        "type": "bool",
                        "definition": [
                            "bool has_aligned"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_is_in_same_segment",
            "header": "",
            "params": [
                "const void *p",
                "const void *q"
            ],
            "definition": "inline static bool mi_is_in_same_segment(const void *p, const void *q)\n{\n  return _mi_ptr_segment(p) == _mi_ptr_segment(q);\n}\n\n",
            "calle": [
                "_mi_ptr_segment"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "q",
                        "type": "const void *",
                        "definition": [
                            "const void *q"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_is_in_same_page",
            "header": "",
            "params": [
                "const void *p",
                "const void *q"
            ],
            "definition": "inline static bool mi_is_in_same_page(const void *p, const void *q)\n{\n  mi_segment_t *segment = _mi_ptr_segment(p);\n  if (_mi_ptr_segment(q) != segment)\n  {\n    return 0;\n  }\n  mi_page_t *page = _mi_segment_page_of(segment, p);\n  size_t psize;\n  uint8_t *start = _mi_segment_page_start(segment, page, &psize);\n  return (start <= ((uint8_t *) q)) && (((uint8_t *) q) < (start + psize));\n}\n\n",
            "calle": [
                "_mi_ptr_segment",
                "_mi_segment_page_of",
                "_mi_segment_page_start"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "q",
                        "type": "const void *",
                        "definition": [
                            "const void *q"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = _mi_ptr_segment(p)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = _mi_segment_page_of(segment, p)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "psize",
                        "type": "size_t",
                        "definition": [
                            "size_t psize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *start = _mi_segment_page_start(segment, page, &psize)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_rotl",
            "header": "",
            "params": [
                "uintptr_t x",
                "uintptr_t shift"
            ],
            "definition": "inline static uintptr_t mi_rotl(uintptr_t x, uintptr_t shift)\n{\n  shift %= (1 << 3) * 8;\n  return (shift == 0) ? (x) : ((x << shift) | (x >> (((1 << 3) * 8) - shift)));\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "x",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t x"
                        ]
                    },
                    {
                        "path": null,
                        "name": "shift",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t shift"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_rotr",
            "header": "",
            "params": [
                "uintptr_t x",
                "uintptr_t shift"
            ],
            "definition": "inline static uintptr_t mi_rotr(uintptr_t x, uintptr_t shift)\n{\n  shift %= (1 << 3) * 8;\n  return (shift == 0) ? (x) : ((x >> shift) | (x << (((1 << 3) * 8) - shift)));\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "x",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t x"
                        ]
                    },
                    {
                        "path": null,
                        "name": "shift",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t shift"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_ptr_decode",
            "header": "",
            "params": [
                "const void *null",
                "const mi_encoded_t x",
                "const uintptr_t *keys"
            ],
            "definition": "inline static void *mi_ptr_decode(const void *null, const mi_encoded_t x, const uintptr_t *keys)\n{\n  void *p = (void *) (mi_rotr(x - keys[0], keys[0]) ^ keys[1]);\n  return (p == null) ? (0) : (p);\n}\n\n",
            "calle": [
                "mi_rotr"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "null",
                        "type": "const void *",
                        "definition": [
                            "const void *null"
                        ]
                    },
                    {
                        "path": null,
                        "name": "x",
                        "type": "const mi_encoded_t",
                        "definition": [
                            "const mi_encoded_t x"
                        ]
                    },
                    {
                        "path": null,
                        "name": "keys",
                        "type": "const uintptr_t *",
                        "definition": [
                            "const uintptr_t *keys"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = (void *) (mi_rotr(x - keys[0], keys[0]) ^ keys[1])"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_ptr_encode",
            "header": "",
            "params": [
                "const void *null",
                "const void *p",
                "const uintptr_t *keys"
            ],
            "definition": "inline static mi_encoded_t mi_ptr_encode(const void *null, const void *p, const uintptr_t *keys)\n{\n  uintptr_t x = (uintptr_t) ((p == 0) ? (null) : (p));\n  return mi_rotl(x ^ keys[1], keys[0]) + keys[0];\n}\n\n",
            "calle": [
                "mi_rotl"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "null",
                        "type": "const void *",
                        "definition": [
                            "const void *null"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "keys",
                        "type": "const uintptr_t *",
                        "definition": [
                            "const uintptr_t *keys"
                        ]
                    },
                    {
                        "path": null,
                        "name": "x",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t x = (uintptr_t) ((p == 0) ? (null) : (p))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_ptr_encode_canary",
            "header": "",
            "params": [
                "const void *null",
                "const void *p",
                "const uintptr_t *keys"
            ],
            "definition": "inline static uint32_t mi_ptr_encode_canary(const void *null, const void *p, const uintptr_t *keys)\n{\n  const uint32_t x = (uint32_t) mi_ptr_encode(null, p, keys);\n  return x & 0xFFFFFF00;\n}\n\n",
            "calle": [
                "mi_ptr_encode"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "null",
                        "type": "const void *",
                        "definition": [
                            "const void *null"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "keys",
                        "type": "const uintptr_t *",
                        "definition": [
                            "const uintptr_t *keys"
                        ]
                    },
                    {
                        "path": null,
                        "name": "x",
                        "type": "const uint32_t",
                        "definition": [
                            "const uint32_t x = (uint32_t) mi_ptr_encode(null, p, keys)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_block_nextx",
            "header": "",
            "params": [
                "const void *null",
                "const mi_block_t *block",
                "const uintptr_t *keys"
            ],
            "definition": "inline static mi_block_t *mi_block_nextx(const void *null, const mi_block_t *block, const uintptr_t *keys)\n{\n  ;\n  mi_block_t *next;\n  unsigned int next_idx = 0;\n  next_idx = (mi_block_t *) mi_ptr_decode(null, block->next_idx, keys);\n  ;\n  return next;\n}\n\n",
            "calle": [
                "mi_ptr_decode"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "null",
                        "type": "const void *",
                        "definition": [
                            "const void *null"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "const mi_block_t *",
                        "definition": [
                            "const mi_block_t *block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "keys",
                        "type": "const uintptr_t *",
                        "definition": [
                            "const uintptr_t *keys"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *next"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int next_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_block_set_nextx",
            "header": "",
            "params": [
                "const void *null",
                "mi_block_t *block",
                "const mi_block_t *next",
                "const uintptr_t *keys"
            ],
            "definition": "inline static void mi_block_set_nextx(const void *null, mi_block_t *block, const mi_block_t *next, const uintptr_t *keys)\n{\n  ;\n  block->next = mi_ptr_encode(null, next, keys);\n  ;\n}\n\n",
            "calle": [
                "mi_ptr_encode"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "null",
                        "type": "const void *",
                        "definition": [
                            "const void *null"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next",
                        "type": "const mi_block_t *",
                        "definition": [
                            "const mi_block_t *next"
                        ]
                    },
                    {
                        "path": null,
                        "name": "keys",
                        "type": "const uintptr_t *",
                        "definition": [
                            "const uintptr_t *keys"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_block_next",
            "header": "",
            "params": [
                "const mi_page_t *page",
                "const mi_block_t *block"
            ],
            "definition": "inline static mi_block_t *mi_block_next(const mi_page_t *page, const mi_block_t *block)\n{\n  mi_block_t *next = mi_block_nextx(page, block, page->keys);\n  unsigned int next_idx = 0;\n  if (__builtin_expect(!(!(((&next[next_idx]) != 0) && (!mi_is_in_same_page(block, next)))), 0))\n  {\n    _mi_error_message(14, \"corrupted free list entry of size %zub at %p: value 0x%zx\\n\", mi_page_block_size(page), block, (uintptr_t) next);\n    next_idx = 0;\n  }\n  return next;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_error_message",
                "mi_block_nextx",
                "mi_is_in_same_page",
                "mi_page_block_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "const mi_block_t *",
                        "definition": [
                            "const mi_block_t *block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *next = mi_block_nextx(page, block, page->keys)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int next_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_block_set_next",
            "header": "",
            "params": [
                "const mi_page_t *page",
                "mi_block_t *block",
                "const mi_block_t *next"
            ],
            "definition": "inline static void mi_block_set_next(const mi_page_t *page, mi_block_t *block, const mi_block_t *next)\n{\n  mi_block_set_nextx(page, block, next, page->keys);\n}\n\n",
            "calle": [
                "mi_block_set_nextx"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next",
                        "type": "const mi_block_t *",
                        "definition": [
                            "const mi_block_t *next"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_commit_mask_create_empty",
            "header": "",
            "params": [
                "mi_commit_mask_t *cm"
            ],
            "definition": "inline static void mi_commit_mask_create_empty(mi_commit_mask_t *cm)\n{\n  for (size_t i = 0; i < (((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) / ((1 << 3) * 8)); i += 1)\n  {\n    cm->mask[i] = 0;\n  }\n\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "cm",
                        "type": "mi_commit_mask_t *",
                        "definition": [
                            "mi_commit_mask_t *cm"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_commit_mask_create_full",
            "header": "",
            "params": [
                "mi_commit_mask_t *cm"
            ],
            "definition": "inline static void mi_commit_mask_create_full(mi_commit_mask_t *cm)\n{\n  for (size_t i = 0; i < (((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) / ((1 << 3) * 8)); i += 1)\n  {\n    cm->mask[i] = ~((size_t) 0);\n  }\n\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "cm",
                        "type": "mi_commit_mask_t *",
                        "definition": [
                            "mi_commit_mask_t *cm"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_commit_mask_is_empty",
            "header": "",
            "params": [
                "const mi_commit_mask_t *cm"
            ],
            "definition": "inline static bool mi_commit_mask_is_empty(const mi_commit_mask_t *cm)\n{\n  for (size_t i = 0; i < (((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) / ((1 << 3) * 8)); i += 1)\n  {\n    if (cm->mask[i] != 0)\n    {\n      return 0;\n    }\n  }\n\n  return 1;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "cm",
                        "type": "const mi_commit_mask_t *",
                        "definition": [
                            "const mi_commit_mask_t *cm"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_commit_mask_is_full",
            "header": "",
            "params": [
                "const mi_commit_mask_t *cm"
            ],
            "definition": "inline static bool mi_commit_mask_is_full(const mi_commit_mask_t *cm)\n{\n  for (size_t i = 0; i < (((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) / ((1 << 3) * 8)); i += 1)\n  {\n    if (cm->mask[i] != (~((size_t) 0)))\n    {\n      return 0;\n    }\n  }\n\n  return 1;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "cm",
                        "type": "const mi_commit_mask_t *",
                        "definition": [
                            "const mi_commit_mask_t *cm"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_memid_create",
            "header": "",
            "params": [
                "mi_memkind_t memkind"
            ],
            "definition": "inline static mi_memid_t _mi_memid_create(mi_memkind_t memkind)\n{\n  mi_memid_t memid;\n  memset(&memid, 0, sizeof(memid));\n  memid.memkind = memkind;\n  return memid;\n}\n\n",
            "calle": [
                "memset"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "memkind",
                        "type": "mi_memkind_t",
                        "definition": [
                            "mi_memkind_t memkind"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_memid_none",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "inline static mi_memid_t _mi_memid_none(void)\n{\n  return _mi_memid_create(MI_MEM_NONE);\n}\n\n",
            "calle": [
                "_mi_memid_create"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_memid_create_os",
            "header": "",
            "params": [
                "void *base",
                "size_t size",
                "bool committed",
                "bool is_zero",
                "bool is_large"
            ],
            "definition": "inline static mi_memid_t _mi_memid_create_os(void *base, size_t size, bool committed, bool is_zero, bool is_large)\n{\n  mi_memid_t memid = _mi_memid_create(MI_MEM_OS);\n  memid.mem.os.base = base;\n  memid.mem.os.size = size;\n  memid.initially_committed = committed;\n  memid.initially_zero = is_zero;\n  memid.is_pinned = is_large;\n  return memid;\n}\n\n",
            "calle": [
                "_mi_memid_create"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "base",
                        "type": "void *",
                        "definition": [
                            "void *base"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "committed",
                        "type": "bool",
                        "definition": [
                            "bool committed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_zero",
                        "type": "bool",
                        "definition": [
                            "bool is_zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_large",
                        "type": "bool",
                        "definition": [
                            "bool is_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid = _mi_memid_create(MI_MEM_OS)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_clz",
            "header": "",
            "params": [
                "size_t x"
            ],
            "definition": "inline static size_t mi_clz(size_t x)\n{\n  if (x == 0)\n  {\n    return (1 << 3) * 8;\n  }\n  return __builtin_clzll(x);\n}\n\n",
            "calle": [
                "__builtin_clzll"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "x",
                        "type": "size_t",
                        "definition": [
                            "size_t x"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_ctz",
            "header": "",
            "params": [
                "size_t x"
            ],
            "definition": "inline static size_t mi_ctz(size_t x)\n{\n  if (x == 0)\n  {\n    return (1 << 3) * 8;\n  }\n  return __builtin_ctzll(x);\n}\n\n",
            "calle": [
                "__builtin_ctzll"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "x",
                        "type": "size_t",
                        "definition": [
                            "size_t x"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_bsr",
            "header": "",
            "params": [
                "size_t x"
            ],
            "definition": "inline static size_t mi_bsr(size_t x)\n{\n  return (x == 0) ? ((1 << 3) * 8) : ((((1 << 3) * 8) - 1) - mi_clz(x));\n}\n\n",
            "calle": [
                "mi_clz"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "x",
                        "type": "size_t",
                        "definition": [
                            "size_t x"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_popcount",
            "header": "",
            "params": [
                "size_t x"
            ],
            "definition": "inline static size_t mi_popcount(size_t x)\n{\n  if (x <= 1)\n  {\n    return x;\n  }\n  if (x == SIZE_MAX)\n  {\n    return (1 << 3) * 8;\n  }\n  return __builtin_popcountll(x);\n}\n\n",
            "calle": [
                "__builtin_popcountll"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "x",
                        "type": "size_t",
                        "definition": [
                            "size_t x"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_memcpy",
            "header": "",
            "params": [
                "void *dst",
                "const void *src",
                "size_t n"
            ],
            "definition": "inline static void _mi_memcpy(void *dst, const void *src, size_t n)\n{\n  memcpy(dst, src, n);\n}\n\n",
            "calle": [
                "memcpy"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "dst",
                        "type": "void *",
                        "definition": [
                            "void *dst"
                        ]
                    },
                    {
                        "path": null,
                        "name": "src",
                        "type": "const void *",
                        "definition": [
                            "const void *src"
                        ]
                    },
                    {
                        "path": null,
                        "name": "n",
                        "type": "size_t",
                        "definition": [
                            "size_t n"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_memzero",
            "header": "",
            "params": [
                "void *dst",
                "size_t n"
            ],
            "definition": "inline static void _mi_memzero(void *dst, size_t n)\n{\n  memset(dst, 0, n);\n}\n\n",
            "calle": [
                "memset"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "dst",
                        "type": "void *",
                        "definition": [
                            "void *dst"
                        ]
                    },
                    {
                        "path": null,
                        "name": "n",
                        "type": "size_t",
                        "definition": [
                            "size_t n"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_memcpy_aligned",
            "header": "",
            "params": [
                "void *dst",
                "const void *src",
                "size_t n"
            ],
            "definition": "inline static void _mi_memcpy_aligned(void *dst, const void *src, size_t n)\n{\n  (((((uintptr_t) dst) % (1 << 3)) == 0) && ((((uintptr_t) src) % (1 << 3)) == 0)) ? ((void) 0) : (_mi_assert_fail(\"((uintptr_t)dst % MI_INTPTR_SIZE == 0) && ((uintptr_t)src % MI_INTPTR_SIZE == 0)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 1128, __func__));\n  void *adst = __builtin_assume_aligned(dst, 1 << 3);\n  const void *asrc = __builtin_assume_aligned(src, 1 << 3);\n  _mi_memcpy(adst, asrc, n);\n}\n\n",
            "calle": [
                "__builtin_assume_aligned",
                "_mi_assert_fail",
                "_mi_memcpy"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "dst",
                        "type": "void *",
                        "definition": [
                            "void *dst"
                        ]
                    },
                    {
                        "path": null,
                        "name": "src",
                        "type": "const void *",
                        "definition": [
                            "const void *src"
                        ]
                    },
                    {
                        "path": null,
                        "name": "n",
                        "type": "size_t",
                        "definition": [
                            "size_t n"
                        ]
                    },
                    {
                        "path": null,
                        "name": "adst",
                        "type": "void *",
                        "definition": [
                            "void *adst = __builtin_assume_aligned(dst, 1 << 3)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "asrc",
                        "type": "const void *",
                        "definition": [
                            "const void *asrc = __builtin_assume_aligned(src, 1 << 3)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_memzero_aligned",
            "header": "",
            "params": [
                "void *dst",
                "size_t n"
            ],
            "definition": "inline static void _mi_memzero_aligned(void *dst, size_t n)\n{\n  ((((uintptr_t) dst) % (1 << 3)) == 0) ? ((void) 0) : (_mi_assert_fail(\"(uintptr_t)dst % MI_INTPTR_SIZE == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/include/mimalloc/internal.h\", 1135, __func__));\n  void *adst = __builtin_assume_aligned(dst, 1 << 3);\n  _mi_memzero(adst, n);\n}\n\n",
            "calle": [
                "__builtin_assume_aligned",
                "_mi_assert_fail",
                "_mi_memzero"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "dst",
                        "type": "void *",
                        "definition": [
                            "void *dst"
                        ]
                    },
                    {
                        "path": null,
                        "name": "n",
                        "type": "size_t",
                        "definition": [
                            "size_t n"
                        ]
                    },
                    {
                        "path": null,
                        "name": "adst",
                        "type": "void *",
                        "definition": [
                            "void *adst = __builtin_assume_aligned(dst, 1 << 3)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_thread_id",
            "header": "inline static mi_threadid_t _mi_prim_thread_id(void)",
            "params": [
                "void"
            ],
            "definition": "inline static mi_threadid_t _mi_prim_thread_id(void)\n{\n  return (uintptr_t) __builtin_thread_pointer();\n}\n\n",
            "calle": [
                "__builtin_thread_pointer"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_prim_get_default_heap",
            "header": "inline static mi_heap_t *mi_prim_get_default_heap(void)",
            "params": [
                "void"
            ],
            "definition": "inline static mi_heap_t *mi_prim_get_default_heap(void)\n{\n  return _mi_heap_default;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_default",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_check_padding",
            "header": "static void mi_check_padding(const mi_page_t *page, const mi_block_t *block)",
            "params": [
                "const mi_page_t *page",
                "const mi_block_t *block"
            ],
            "definition": "static void mi_check_padding(const mi_page_t *page, const mi_block_t *block)\n{\n  size_t size;\n  size_t wrong;\n  if (!mi_verify_padding(page, block, &size, &wrong))\n  {\n    _mi_error_message(14, \"buffer overflow in heap block %p of size %zu: write after %zu bytes\\n\", block, size, wrong);\n  }\n}\n\n",
            "calle": [
                "_mi_error_message",
                "mi_verify_padding"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "const mi_block_t *",
                        "definition": [
                            "const mi_block_t *block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "wrong",
                        "type": "size_t",
                        "definition": [
                            "size_t wrong"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_check_is_double_free",
            "header": "static bool mi_check_is_double_free(const mi_page_t *page, const mi_block_t *block)",
            "params": [
                "const mi_page_t *page",
                "const mi_block_t *block"
            ],
            "definition": "inline static bool mi_check_is_double_free(const mi_page_t *page, const mi_block_t *block)\n{\n  bool is_double_free = 0;\n  mi_block_t *n = mi_block_nextx(page, block, page->keys);\n  if (((((uintptr_t) n) & ((1 << 3) - 1)) == 0) && ((n == 0) || mi_is_in_same_page(block, n)))\n  {\n    is_double_free = mi_check_is_double_freex(page, block);\n  }\n  return is_double_free;\n}\n\n",
            "calle": [
                "mi_block_nextx",
                "mi_check_is_double_freex",
                "mi_is_in_same_page"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "const mi_block_t *",
                        "definition": [
                            "const mi_block_t *block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_double_free",
                        "type": "bool",
                        "definition": [
                            "bool is_double_free = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "n",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *n = mi_block_nextx(page, block, page->keys)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_usable_size_of",
            "header": "static size_t mi_page_usable_size_of(const mi_page_t *page, const mi_block_t *block)",
            "params": [
                "const mi_page_t *page",
                "const mi_block_t *block"
            ],
            "definition": "static size_t mi_page_usable_size_of(const mi_page_t *page, const mi_block_t *block)\n{\n  size_t bsize;\n  size_t delta;\n  bool ok = mi_page_decode_padding(page, block, &delta, &bsize);\n  (ok) ? ((void) 0) : (_mi_assert_fail(\"ok\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/free.c\", 445, __func__));\n  (delta <= bsize) ? ((void) 0) : (_mi_assert_fail(\"delta <= bsize\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/free.c\", 445, __func__));\n  return (ok) ? (bsize - delta) : (0);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_page_decode_padding"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "const mi_block_t *",
                        "definition": [
                            "const mi_block_t *block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "size_t",
                        "definition": [
                            "size_t bsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "delta",
                        "type": "size_t",
                        "definition": [
                            "size_t delta"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ok",
                        "type": "bool",
                        "definition": [
                            "bool ok = mi_page_decode_padding(page, block, &delta, &bsize)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stat_free",
            "header": "static void mi_stat_free(const mi_page_t *page, const mi_block_t *block)",
            "params": [
                "const mi_page_t *page",
                "const mi_block_t *block"
            ],
            "definition": "static void mi_stat_free(const mi_page_t *page, const mi_block_t *block)\n{\n  (void) block;\n  mi_heap_t * const heap = mi_heap_get_default();\n  const size_t bsize = mi_page_usable_block_size(page);\n  if (bsize <= ((1UL << (3 + (13 + 3))) / 8))\n  {\n    _mi_stat_decrease(&heap->tld->stats.malloc_normal, bsize);\n    _mi_stat_decrease(&heap->tld->stats.malloc_bins[_mi_bin(bsize)], 1);\n  }\n  else\n  {\n    _mi_stat_decrease(&heap->tld->stats.malloc_huge, bsize);\n  }\n}\n\n",
            "calle": [
                "_mi_bin",
                "_mi_stat_decrease",
                "mi_heap_get_default",
                "mi_page_usable_block_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "const mi_block_t *",
                        "definition": [
                            "const mi_block_t *block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t * const",
                        "definition": [
                            "mi_heap_t * const heap = mi_heap_get_default()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bsize = mi_page_usable_block_size(page)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_free_block_mt",
            "header": "static void mi_free_block_mt(mi_page_t *page, mi_segment_t *segment, mi_block_t *block)",
            "params": [
                "mi_page_t *page",
                "mi_segment_t *segment",
                "mi_block_t *block"
            ],
            "definition": "static void mi_free_block_mt(mi_page_t *page, mi_segment_t *segment, mi_block_t *block)\n{\n  if (((_mi_option_get_fast(mi_option_abandoned_reclaim_on_free) != 0) && (atomic_load_explicit(&segment->thread_id, memory_order_relaxed) == 0)) && (mi_prim_get_default_heap() != ((mi_heap_t *) (&_mi_heap_empty))))\n  {\n    if (_mi_segment_attempt_reclaim(mi_heap_get_default(), segment))\n    {\n      (_mi_thread_id() == atomic_load_explicit(&segment->thread_id, memory_order_relaxed)) ? ((void) 0) : (_mi_assert_fail(\"_mi_thread_id() == mi_atomic_load_relaxed(&segment->thread_id)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/free.c\", 264, __func__));\n      (mi_heap_get_default()->tld->segments.subproc == segment->subproc) ? ((void) 0) : (_mi_assert_fail(\"mi_heap_get_default()->tld->segments.subproc == segment->subproc\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/free.c\", 265, __func__));\n      mi_free(block);\n      return;\n    }\n  }\n  mi_check_padding(page, block);\n  mi_stat_free(page, block);\n  ;\n  _mi_padding_shrink(page, block, sizeof(mi_block_t));\n  if (segment->kind == MI_SEGMENT_HUGE)\n  {\n    _mi_segment_huge_page_reset(segment, page, block);\n  }\n  else\n  {\n    memset(block, 0xDF, mi_usable_size(block));\n  }\n  mi_free_block_delayed_mt(page, block);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_option_get_fast",
                "_mi_padding_shrink",
                "_mi_segment_attempt_reclaim",
                "_mi_segment_huge_page_reset",
                "_mi_thread_id",
                "atomic_load_explicit",
                "memset",
                "mi_check_padding",
                "mi_free",
                "mi_free_block_delayed_mt",
                "mi_heap_get_default",
                "mi_prim_get_default_heap",
                "mi_stat_free",
                "mi_usable_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_empty",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_free_block_local",
            "header": "",
            "params": [
                "mi_page_t *page",
                "mi_block_t *block",
                "bool track_stats",
                "bool check_full"
            ],
            "definition": "inline static void mi_free_block_local(mi_page_t *page, mi_block_t *block, bool track_stats, bool check_full)\n{\n  if (__builtin_expect(!(!mi_check_is_double_free(page, block)), 0))\n  {\n    return;\n  }\n  mi_check_padding(page, block);\n  if (track_stats)\n  {\n    mi_stat_free(page, block);\n  }\n  if (!mi_page_is_huge(page))\n  {\n    memset(block, 0xDF, mi_page_block_size(page));\n  }\n  if (track_stats)\n  {\n    ;\n  }\n  mi_block_set_next(page, block, page->local_free);\n  page->local_free = block;\n  if (__builtin_expect(!(!((--page->used) == 0)), 0))\n  {\n    _mi_page_retire(page);\n  }\n  else\n    if (__builtin_expect(!(!(check_full && mi_page_is_in_full(page))), 0))\n  {\n    _mi_page_unfull(page);\n  }\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_page_retire",
                "_mi_page_unfull",
                "memset",
                "mi_block_set_next",
                "mi_check_is_double_free",
                "mi_check_padding",
                "mi_page_block_size",
                "mi_page_is_huge",
                "mi_page_is_in_full",
                "mi_stat_free"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "track_stats",
                        "type": "bool",
                        "definition": [
                            "bool track_stats"
                        ]
                    },
                    {
                        "path": null,
                        "name": "check_full",
                        "type": "bool",
                        "definition": [
                            "bool check_full"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_block_check_unguard",
            "header": "",
            "params": [
                "mi_page_t *page",
                "mi_block_t *block",
                "void *p"
            ],
            "definition": "inline static void mi_block_check_unguard(mi_page_t *page, mi_block_t *block, void *p)\n{\n  (void) page;\n  (void) block;\n  (void) p;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_free_generic_local",
            "header": "",
            "params": [
                "mi_page_t *page",
                "mi_segment_t *segment",
                "void *p"
            ],
            "definition": "static void mi_free_generic_local(mi_page_t *page, mi_segment_t *segment, void *p)\n{\n  (void) segment;\n  mi_block_t * const block = (mi_page_has_aligned(page)) ? (_mi_page_ptr_unalign(page, p)) : ((mi_block_t *) p);\n  mi_block_check_unguard(page, block, p);\n  mi_free_block_local(page, block, 1, 1);\n}\n\n",
            "calle": [
                "_mi_page_ptr_unalign",
                "mi_block_check_unguard",
                "mi_free_block_local",
                "mi_page_has_aligned"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "mi_block_t * const",
                        "definition": [
                            "mi_block_t * const block = (mi_page_has_aligned(page)) ? (_mi_page_ptr_unalign(page, p)) : ((mi_block_t *) p)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_free_generic_mt",
            "header": "",
            "params": [
                "mi_page_t *page",
                "mi_segment_t *segment",
                "void *p"
            ],
            "definition": "static void mi_free_generic_mt(mi_page_t *page, mi_segment_t *segment, void *p)\n{\n  mi_block_t * const block = _mi_page_ptr_unalign(page, p);\n  mi_block_check_unguard(page, block, p);\n  mi_free_block_mt(page, segment, block);\n}\n\n",
            "calle": [
                "_mi_page_ptr_unalign",
                "mi_block_check_unguard",
                "mi_free_block_mt"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "mi_block_t * const",
                        "definition": [
                            "mi_block_t * const block = _mi_page_ptr_unalign(page, p)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_checked_ptr_segment",
            "header": "",
            "params": [
                "const void *p",
                "const char *msg"
            ],
            "definition": "inline static mi_segment_t *mi_checked_ptr_segment(const void *p, const char *msg)\n{\n  (void) msg;\n  if (__builtin_expect(!(!(((((uintptr_t) p) & ((1 << 3) - 1)) != 0) && (!mi_option_is_enabled(mi_option_guarded_precise)))), 0))\n  {\n    _mi_error_message(22, \"%s: invalid (unaligned) pointer: %p\\n\", msg, p);\n    return 0;\n  }\n  mi_segment_t * const segment = _mi_ptr_segment(p);\n  if (__builtin_expect(!(!(segment == 0)), 0))\n  {\n    return segment;\n  }\n  if (__builtin_expect(!(!(!mi_is_in_heap_region(p))), 0))\n  {\n    if ((((uintptr_t) p) >> 40) != 0x7F)\n    {\n      _mi_warning_message(\"%s: pointer might not point to a valid heap region: %p\\n(this may still be a valid very large allocation (over 64MiB))\\n\", msg, p);\n      if (__builtin_expect(!(!(_mi_ptr_cookie(segment) == segment->cookie)), 1))\n      {\n        _mi_warning_message(\"(yes, the previous pointer %p was valid after all)\\n\", p);\n      }\n    }\n  }\n  if (__builtin_expect(!(!(_mi_ptr_cookie(segment) != segment->cookie)), 0))\n  {\n    _mi_error_message(22, \"%s: pointer does not point to a valid heap space: %p\\n\", msg, p);\n    return 0;\n  }\n  return segment;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_error_message",
                "_mi_ptr_cookie",
                "_mi_ptr_segment",
                "_mi_warning_message",
                "mi_is_in_heap_region",
                "mi_option_is_enabled"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "msg",
                        "type": "const char *",
                        "definition": [
                            "const char *msg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t * const",
                        "definition": [
                            "mi_segment_t * const segment = _mi_ptr_segment(p)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_free_block_delayed_mt",
            "header": "",
            "params": [
                "mi_page_t *page",
                "mi_block_t *block"
            ],
            "definition": "static void mi_free_block_delayed_mt(mi_page_t *page, mi_block_t *block)\n{\n  mi_thread_free_t tfreex;\n  bool use_delayed;\n  mi_thread_free_t tfree = atomic_load_explicit(&page->xthread_free, memory_order_relaxed);\n  do\n  {\n    use_delayed = mi_tf_delayed(tfree) == MI_USE_DELAYED_FREE;\n    if (__builtin_expect(!(!use_delayed), 0))\n    {\n      tfreex = mi_tf_set_delayed(tfree, MI_DELAYED_FREEING);\n    }\n    else\n    {\n      mi_block_set_next(page, block, mi_tf_block(tfree));\n      tfreex = mi_tf_set_block(tfree, block);\n    }\n  }\n  while (!atomic_compare_exchange_weak_explicit(&page->xthread_free, &tfree, tfreex, memory_order_release, memory_order_relaxed));\n  if (__builtin_expect(!(!use_delayed), 0))\n  {\n    mi_heap_t * const heap = (mi_heap_t *) atomic_load_explicit(&page->xheap, memory_order_acquire);\n    (heap != 0) ? ((void) 0) : (_mi_assert_fail(\"heap != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/free.c\", 232, __func__));\n    if (heap != 0)\n    {\n      mi_block_t *dfree = atomic_load_explicit(&heap->thread_delayed_free, memory_order_relaxed);\n      do\n      {\n        mi_block_set_nextx(heap, block, dfree, heap->keys);\n      }\n      while (!atomic_compare_exchange_weak_explicit(&heap->thread_delayed_free, &dfree, block, memory_order_release, memory_order_relaxed));\n    }\n    tfree = atomic_load_explicit(&page->xthread_free, memory_order_relaxed);\n    do\n    {\n      tfreex = tfree;\n      (mi_tf_delayed(tfree) == MI_DELAYED_FREEING) ? ((void) 0) : (_mi_assert_fail(\"mi_tf_delayed(tfree) == MI_DELAYED_FREEING\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/free.c\", 245, __func__));\n      tfreex = mi_tf_set_delayed(tfree, MI_NO_DELAYED_FREE);\n    }\n    while (!atomic_compare_exchange_weak_explicit(&page->xthread_free, &tfree, tfreex, memory_order_release, memory_order_relaxed));\n  }\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "atomic_compare_exchange_weak_explicit",
                "atomic_load_explicit",
                "mi_block_set_next",
                "mi_block_set_nextx",
                "mi_tf_block",
                "mi_tf_delayed",
                "mi_tf_set_block",
                "mi_tf_set_delayed"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tfreex",
                        "type": "mi_thread_free_t",
                        "definition": [
                            "mi_thread_free_t tfreex"
                        ]
                    },
                    {
                        "path": null,
                        "name": "use_delayed",
                        "type": "bool",
                        "definition": [
                            "bool use_delayed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tfree",
                        "type": "mi_thread_free_t",
                        "definition": [
                            "mi_thread_free_t tfree = atomic_load_explicit(&page->xthread_free, memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t * const",
                        "definition": [
                            "mi_heap_t * const heap = (mi_heap_t *) atomic_load_explicit(&page->xheap, memory_order_acquire)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "dfree",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *dfree = atomic_load_explicit(&heap->thread_delayed_free, memory_order_relaxed)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_usable_aligned_size_of",
            "header": "",
            "params": [
                "const mi_page_t *page",
                "const void *p"
            ],
            "definition": "static size_t mi_page_usable_aligned_size_of(const mi_page_t *page, const void *p)\n{\n  const mi_block_t *block = _mi_page_ptr_unalign(page, p);\n  const size_t size = mi_page_usable_size_of(page, block);\n  const ptrdiff_t adjust = ((uint8_t *) p) - ((uint8_t *) block);\n  ((adjust >= 0) && (((size_t) adjust) <= size)) ? ((void) 0) : (_mi_assert_fail(\"adjust >= 0 && (size_t)adjust <= size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/free.c\", 315, __func__));\n  const size_t aligned_size = size - adjust;\n  return aligned_size;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_page_ptr_unalign",
                "mi_page_usable_size_of"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "const mi_block_t *",
                        "definition": [
                            "const mi_block_t *block = _mi_page_ptr_unalign(page, p)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t size = mi_page_usable_size_of(page, block)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "adjust",
                        "type": "const ptrdiff_t",
                        "definition": [
                            "const ptrdiff_t adjust = ((uint8_t *) p) - ((uint8_t *) block)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "aligned_size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t aligned_size = size - adjust"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_usable_size",
            "header": "",
            "params": [
                "const void *p",
                "const char *msg"
            ],
            "definition": "inline static size_t _mi_usable_size(const void *p, const char *msg)\n{\n  const mi_segment_t * const segment = mi_checked_ptr_segment(p, msg);\n  if (__builtin_expect(!(!(segment == 0)), 0))\n  {\n    return 0;\n  }\n  const mi_page_t * const page = _mi_segment_page_of(segment, p);\n  if (__builtin_expect(!(!(!mi_page_has_aligned(page))), 1))\n  {\n    const mi_block_t *block = (const mi_block_t *) p;\n    return mi_page_usable_size_of(page, block);\n  }\n  else\n  {\n    return mi_page_usable_aligned_size_of(page, p);\n  }\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_segment_page_of",
                "mi_checked_ptr_segment",
                "mi_page_has_aligned",
                "mi_page_usable_aligned_size_of",
                "mi_page_usable_size_of"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "msg",
                        "type": "const char *",
                        "definition": [
                            "const char *msg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "const mi_segment_t * const",
                        "definition": [
                            "const mi_segment_t * const segment = mi_checked_ptr_segment(p, msg)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t * const",
                        "definition": [
                            "const mi_page_t * const page = _mi_segment_page_of(segment, p)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "const mi_block_t *",
                        "definition": [
                            "const mi_block_t *block = (const mi_block_t *) p"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_list_contains",
            "header": "",
            "params": [
                "const mi_page_t *page",
                "const mi_block_t *list",
                "const mi_block_t *elem"
            ],
            "definition": "static bool mi_list_contains(const mi_page_t *page, const mi_block_t *list, const mi_block_t *elem)\n{\n  unsigned int list_idx = 0;\n  while ((&list[list_idx]) != 0)\n  {\n    if (elem == (&list[list_idx]))\n    {\n      return 1;\n    }\n    list_idx = mi_block_next(page, list_idx);\n  }\n\n  return 0;\n}\n\n",
            "calle": [
                "mi_block_next"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "list",
                        "type": "const mi_block_t *",
                        "definition": [
                            "const mi_block_t *list"
                        ]
                    },
                    {
                        "path": null,
                        "name": "elem",
                        "type": "const mi_block_t *",
                        "definition": [
                            "const mi_block_t *elem"
                        ]
                    },
                    {
                        "path": null,
                        "name": "list_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int list_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_check_is_double_freex",
            "header": "",
            "params": [
                "const mi_page_t *page",
                "const mi_block_t *block"
            ],
            "definition": "static bool mi_check_is_double_freex(const mi_page_t *page, const mi_block_t *block)\n{\n  if ((mi_list_contains(page, page->free, block) || mi_list_contains(page, page->local_free, block)) || mi_list_contains(page, mi_page_thread_free(page), block))\n  {\n    _mi_error_message(11, \"double free detected of block %p with size %zu\\n\", block, mi_page_block_size(page));\n    return 1;\n  }\n  return 0;\n}\n\n",
            "calle": [
                "_mi_error_message",
                "mi_list_contains",
                "mi_page_block_size",
                "mi_page_thread_free"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "const mi_block_t *",
                        "definition": [
                            "const mi_block_t *block"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_decode_padding",
            "header": "",
            "params": [
                "const mi_page_t *page",
                "const mi_block_t *block",
                "size_t *delta",
                "size_t *bsize"
            ],
            "definition": "static bool mi_page_decode_padding(const mi_page_t *page, const mi_block_t *block, size_t *delta, size_t *bsize)\n{\n  *bsize = mi_page_usable_block_size(page);\n  const mi_padding_t * const padding = (mi_padding_t *) (((uint8_t *) block) + (*bsize));\n  ;\n  *delta = padding->delta;\n  uint32_t canary = padding->canary;\n  uintptr_t keys[2];\n  keys[0] = page->keys[0];\n  keys[1] = page->keys[1];\n  bool ok = (mi_ptr_encode_canary(page, block, keys) == canary) && ((*delta) <= (*bsize));\n  ;\n  return ok;\n}\n\n",
            "calle": [
                "mi_page_usable_block_size",
                "mi_ptr_encode_canary"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "const mi_block_t *",
                        "definition": [
                            "const mi_block_t *block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "delta",
                        "type": "size_t *",
                        "definition": [
                            "size_t *delta"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "size_t *",
                        "definition": [
                            "size_t *bsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "padding",
                        "type": "const mi_padding_t * const",
                        "definition": [
                            "const mi_padding_t * const padding = (mi_padding_t *) (((uint8_t *) block) + (*bsize))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "canary",
                        "type": "uint32_t",
                        "definition": [
                            "uint32_t canary = padding->canary"
                        ]
                    },
                    {
                        "path": null,
                        "name": "keys",
                        "type": "uintptr_t [2]",
                        "definition": [
                            "uintptr_t keys[2]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ok",
                        "type": "bool",
                        "definition": [
                            "bool ok = (mi_ptr_encode_canary(page, block, keys) == canary) && ((*delta) <= (*bsize))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_verify_padding",
            "header": "",
            "params": [
                "const mi_page_t *page",
                "const mi_block_t *block",
                "size_t *size",
                "size_t *wrong"
            ],
            "definition": "static bool mi_verify_padding(const mi_page_t *page, const mi_block_t *block, size_t *size, size_t *wrong)\n{\n  size_t bsize;\n  size_t delta;\n  bool ok = mi_page_decode_padding(page, block, &delta, &bsize);\n  *size = (*wrong = bsize);\n  if (!ok)\n  {\n    return 0;\n  }\n  (bsize >= delta) ? ((void) 0) : (_mi_assert_fail(\"bsize >= delta\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/free.c\", 489, __func__));\n  *size = bsize - delta;\n  if (!mi_page_is_huge(page))\n  {\n    uint8_t *fill = (((uint8_t *) block) + bsize) - delta;\n    const size_t maxpad = (delta > 16) ? (16) : (delta);\n    ;\n    for (size_t i = 0; i < maxpad; i += 1)\n    {\n      if (fill[i] != 0xDE)\n      {\n        *wrong = (bsize - delta) + i;\n        ok = 0;\n        break;\n      }\n    }\n\n    ;\n  }\n  return ok;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_page_decode_padding",
                "mi_page_is_huge"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "const mi_block_t *",
                        "definition": [
                            "const mi_block_t *block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t *",
                        "definition": [
                            "size_t *size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "wrong",
                        "type": "size_t *",
                        "definition": [
                            "size_t *wrong"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "size_t",
                        "definition": [
                            "size_t bsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "delta",
                        "type": "size_t",
                        "definition": [
                            "size_t delta"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ok",
                        "type": "bool",
                        "definition": [
                            "bool ok = mi_page_decode_padding(page, block, &delta, &bsize)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fill",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *fill = (((uint8_t *) block) + bsize) - delta"
                        ]
                    },
                    {
                        "path": null,
                        "name": "maxpad",
                        "type": "const size_t",
                        "definition": [
                            "const size_t maxpad = (delta > 16) ? (16) : (delta)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_malloc_small_zero",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "size_t size",
                "bool zero"
            ],
            "definition": "inline static void *mi_heap_malloc_small_zero(mi_heap_t *heap, size_t size, bool zero)\n{\n  (heap != 0) ? ((void) 0) : (_mi_assert_fail(\"heap != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc.c\", 131, __func__));\n  (size <= (128 * (sizeof(void *)))) ? ((void) 0) : (_mi_assert_fail(\"size <= MI_SMALL_SIZE_MAX\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc.c\", 132, __func__));\n  const uintptr_t tid = _mi_thread_id();\n  ((heap->thread_id == 0) || (heap->thread_id == tid)) ? ((void) 0) : (_mi_assert_fail(\"heap->thread_id == 0 || heap->thread_id == tid\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc.c\", 135, __func__));\n  if (size == 0)\n  {\n    size = sizeof(void *);\n  }\n  mi_page_t *page = _mi_heap_get_free_small_page(heap, size + (sizeof(mi_padding_t)));\n  void * const p = _mi_page_malloc_zero(heap, page, size + (sizeof(mi_padding_t)), zero);\n  if (p != 0)\n  {\n    (mi_usable_size(p) == size) ? ((void) 0) : (_mi_assert_fail(\"mi_usable_size(p)==(size)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc.c\", 149, __func__));\n    ;\n  }\n  ;\n  return p;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_heap_get_free_small_page",
                "_mi_page_malloc_zero",
                "_mi_thread_id",
                "mi_usable_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "zero",
                        "type": "bool",
                        "definition": [
                            "bool zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tid",
                        "type": "const uintptr_t",
                        "definition": [
                            "const uintptr_t tid = _mi_thread_id()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = _mi_heap_get_free_small_page(heap, size + (sizeof(mi_padding_t)))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void * const",
                        "definition": [
                            "void * const p = _mi_page_malloc_zero(heap, page, size + (sizeof(mi_padding_t)), zero)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_ZSt15get_new_handlerv",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "std_new_handler_t _ZSt15get_new_handlerv(void)\n{\n  return 0;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_get_new_handler",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static std_new_handler_t mi_get_new_handler(void)\n{\n  return _ZSt15get_new_handlerv();\n}\n\n",
            "calle": [
                "_ZSt15get_new_handlerv"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_try_new_handler",
            "header": "",
            "params": [
                "bool nothrow"
            ],
            "definition": "static bool mi_try_new_handler(bool nothrow)\n{\n  std_new_handler_t h = mi_get_new_handler();\n  if (h == 0)\n  {\n    _mi_error_message(12, \"out of memory in 'new'\");\n    if (!nothrow)\n    {\n      abort();\n    }\n    return 0;\n  }\n  else\n  {\n    h();\n    return 1;\n  }\n}\n\n",
            "calle": [
                "_mi_error_message",
                "abort",
                "h",
                "mi_get_new_handler"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "nothrow",
                        "type": "bool",
                        "definition": [
                            "bool nothrow"
                        ]
                    },
                    {
                        "path": null,
                        "name": "h",
                        "type": "std_new_handler_t",
                        "definition": [
                            "std_new_handler_t h = mi_get_new_handler()"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_try_new",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "size_t size",
                "bool nothrow"
            ],
            "definition": "void *mi_heap_try_new(mi_heap_t *heap, size_t size, bool nothrow)\n{\n  void *p = 0;\n  unsigned int p_idx = 0;\n  while (((&p[p_idx]) == 0) && mi_try_new_handler(nothrow))\n  {\n    p_idx = mi_heap_malloc(heap, size);\n  }\n\n  return p;\n}\n\n",
            "calle": [
                "mi_heap_malloc",
                "mi_try_new_handler"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "nothrow",
                        "type": "bool",
                        "definition": [
                            "bool nothrow"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int p_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_try_new",
            "header": "",
            "params": [
                "size_t size",
                "bool nothrow"
            ],
            "definition": "static void *mi_try_new(size_t size, bool nothrow)\n{\n  return mi_heap_try_new(mi_prim_get_default_heap(), size, nothrow);\n}\n\n",
            "calle": [
                "mi_heap_try_new",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "nothrow",
                        "type": "bool",
                        "definition": [
                            "bool nothrow"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_malloc_aligned",
            "header": "void *mi_malloc_aligned(size_t size, size_t alignment)",
            "params": [
                "size_t size",
                "size_t alignment"
            ],
            "definition": "void *mi_malloc_aligned(size_t size, size_t alignment)\n{\n  return mi_heap_malloc_aligned(mi_prim_get_default_heap(), size, alignment);\n}\n\n",
            "calle": [
                "mi_heap_malloc_aligned",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_malloc_aligned_at",
            "header": "void *mi_malloc_aligned_at(size_t size, size_t alignment, size_t offset)",
            "params": [
                "size_t size",
                "size_t alignment",
                "size_t offset"
            ],
            "definition": "void *mi_malloc_aligned_at(size_t size, size_t alignment, size_t offset)\n{\n  return mi_heap_malloc_aligned_at(mi_prim_get_default_heap(), size, alignment, offset);\n}\n\n",
            "calle": [
                "mi_heap_malloc_aligned_at",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "size_t",
                        "definition": [
                            "size_t offset"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_zalloc_aligned",
            "header": "void *mi_zalloc_aligned(size_t size, size_t alignment)",
            "params": [
                "size_t size",
                "size_t alignment"
            ],
            "definition": "void *mi_zalloc_aligned(size_t size, size_t alignment)\n{\n  return mi_heap_zalloc_aligned(mi_prim_get_default_heap(), size, alignment);\n}\n\n",
            "calle": [
                "mi_heap_zalloc_aligned",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_zalloc_aligned_at",
            "header": "void *mi_zalloc_aligned_at(size_t size, size_t alignment, size_t offset)",
            "params": [
                "size_t size",
                "size_t alignment",
                "size_t offset"
            ],
            "definition": "void *mi_zalloc_aligned_at(size_t size, size_t alignment, size_t offset)\n{\n  return mi_heap_zalloc_aligned_at(mi_prim_get_default_heap(), size, alignment, offset);\n}\n\n",
            "calle": [
                "mi_heap_zalloc_aligned_at",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "size_t",
                        "definition": [
                            "size_t offset"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_calloc_aligned",
            "header": "void *mi_calloc_aligned(size_t count, size_t size, size_t alignment)",
            "params": [
                "size_t count",
                "size_t size",
                "size_t alignment"
            ],
            "definition": "void *mi_calloc_aligned(size_t count, size_t size, size_t alignment)\n{\n  return mi_heap_calloc_aligned(mi_prim_get_default_heap(), count, size, alignment);\n}\n\n",
            "calle": [
                "mi_heap_calloc_aligned",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_calloc_aligned_at",
            "header": "void *mi_calloc_aligned_at(size_t count, size_t size, size_t alignment, size_t offset)",
            "params": [
                "size_t count",
                "size_t size",
                "size_t alignment",
                "size_t offset"
            ],
            "definition": "void *mi_calloc_aligned_at(size_t count, size_t size, size_t alignment, size_t offset)\n{\n  return mi_heap_calloc_aligned_at(mi_prim_get_default_heap(), count, size, alignment, offset);\n}\n\n",
            "calle": [
                "mi_heap_calloc_aligned_at",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "size_t",
                        "definition": [
                            "size_t offset"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_realloc_aligned",
            "header": "void *mi_realloc_aligned(void *p, size_t newsize, size_t alignment)",
            "params": [
                "void *p",
                "size_t newsize",
                "size_t alignment"
            ],
            "definition": "void *mi_realloc_aligned(void *p, size_t newsize, size_t alignment)\n{\n  return mi_heap_realloc_aligned(mi_prim_get_default_heap(), p, newsize, alignment);\n}\n\n",
            "calle": [
                "mi_heap_realloc_aligned",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_realloc_aligned_at",
            "header": "void *mi_realloc_aligned_at(void *p, size_t newsize, size_t alignment, size_t offset)",
            "params": [
                "void *p",
                "size_t newsize",
                "size_t alignment",
                "size_t offset"
            ],
            "definition": "void *mi_realloc_aligned_at(void *p, size_t newsize, size_t alignment, size_t offset)\n{\n  return mi_heap_realloc_aligned_at(mi_prim_get_default_heap(), p, newsize, alignment, offset);\n}\n\n",
            "calle": [
                "mi_heap_realloc_aligned_at",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "size_t",
                        "definition": [
                            "size_t offset"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_malloc_aligned",
            "header": "void *mi_heap_malloc_aligned(mi_heap_t *heap, size_t size, size_t alignment)",
            "params": [
                "mi_heap_t *heap",
                "size_t size",
                "size_t alignment"
            ],
            "definition": "void *mi_heap_malloc_aligned(mi_heap_t *heap, size_t size, size_t alignment)\n{\n  return mi_heap_malloc_aligned_at(heap, size, alignment, 0);\n}\n\n",
            "calle": [
                "mi_heap_malloc_aligned_at"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_malloc_aligned_at",
            "header": "void *mi_heap_malloc_aligned_at(mi_heap_t *heap, size_t size, size_t alignment, size_t offset)",
            "params": [
                "mi_heap_t *heap",
                "size_t size",
                "size_t alignment",
                "size_t offset"
            ],
            "definition": "void *mi_heap_malloc_aligned_at(mi_heap_t *heap, size_t size, size_t alignment, size_t offset)\n{\n  return mi_heap_malloc_zero_aligned_at(heap, size, alignment, offset, 0);\n}\n\n",
            "calle": [
                "mi_heap_malloc_zero_aligned_at"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "size_t",
                        "definition": [
                            "size_t offset"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_zalloc_aligned",
            "header": "void *mi_heap_zalloc_aligned(mi_heap_t *heap, size_t size, size_t alignment)",
            "params": [
                "mi_heap_t *heap",
                "size_t size",
                "size_t alignment"
            ],
            "definition": "void *mi_heap_zalloc_aligned(mi_heap_t *heap, size_t size, size_t alignment)\n{\n  return mi_heap_zalloc_aligned_at(heap, size, alignment, 0);\n}\n\n",
            "calle": [
                "mi_heap_zalloc_aligned_at"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_zalloc_aligned_at",
            "header": "void *mi_heap_zalloc_aligned_at(mi_heap_t *heap, size_t size, size_t alignment, size_t offset)",
            "params": [
                "mi_heap_t *heap",
                "size_t size",
                "size_t alignment",
                "size_t offset"
            ],
            "definition": "void *mi_heap_zalloc_aligned_at(mi_heap_t *heap, size_t size, size_t alignment, size_t offset)\n{\n  return mi_heap_malloc_zero_aligned_at(heap, size, alignment, offset, 1);\n}\n\n",
            "calle": [
                "mi_heap_malloc_zero_aligned_at"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "size_t",
                        "definition": [
                            "size_t offset"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_calloc_aligned",
            "header": "void *mi_heap_calloc_aligned(mi_heap_t *heap, size_t count, size_t size, size_t alignment)",
            "params": [
                "mi_heap_t *heap",
                "size_t count",
                "size_t size",
                "size_t alignment"
            ],
            "definition": "void *mi_heap_calloc_aligned(mi_heap_t *heap, size_t count, size_t size, size_t alignment)\n{\n  return mi_heap_calloc_aligned_at(heap, count, size, alignment, 0);\n}\n\n",
            "calle": [
                "mi_heap_calloc_aligned_at"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_calloc_aligned_at",
            "header": "void *mi_heap_calloc_aligned_at(mi_heap_t *heap, size_t count, size_t size, size_t alignment, size_t offset)",
            "params": [
                "mi_heap_t *heap",
                "size_t count",
                "size_t size",
                "size_t alignment",
                "size_t offset"
            ],
            "definition": "void *mi_heap_calloc_aligned_at(mi_heap_t *heap, size_t count, size_t size, size_t alignment, size_t offset)\n{\n  size_t total;\n  if (mi_count_size_overflow(count, size, &total))\n  {\n    return 0;\n  }\n  return mi_heap_zalloc_aligned_at(heap, total, alignment, offset);\n}\n\n",
            "calle": [
                "mi_count_size_overflow",
                "mi_heap_zalloc_aligned_at"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "size_t",
                        "definition": [
                            "size_t offset"
                        ]
                    },
                    {
                        "path": null,
                        "name": "total",
                        "type": "size_t",
                        "definition": [
                            "size_t total"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_realloc_aligned",
            "header": "void *mi_heap_realloc_aligned(mi_heap_t *heap, void *p, size_t newsize, size_t alignment)",
            "params": [
                "mi_heap_t *heap",
                "void *p",
                "size_t newsize",
                "size_t alignment"
            ],
            "definition": "void *mi_heap_realloc_aligned(mi_heap_t *heap, void *p, size_t newsize, size_t alignment)\n{\n  return mi_heap_realloc_zero_aligned(heap, p, newsize, alignment, 0);\n}\n\n",
            "calle": [
                "mi_heap_realloc_zero_aligned"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_realloc_aligned_at",
            "header": "void *mi_heap_realloc_aligned_at(mi_heap_t *heap, void *p, size_t newsize, size_t alignment, size_t offset)",
            "params": [
                "mi_heap_t *heap",
                "void *p",
                "size_t newsize",
                "size_t alignment",
                "size_t offset"
            ],
            "definition": "void *mi_heap_realloc_aligned_at(mi_heap_t *heap, void *p, size_t newsize, size_t alignment, size_t offset)\n{\n  return mi_heap_realloc_zero_aligned_at(heap, p, newsize, alignment, offset, 0);\n}\n\n",
            "calle": [
                "mi_heap_realloc_zero_aligned_at"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "size_t",
                        "definition": [
                            "size_t offset"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_rezalloc_aligned",
            "header": "void *mi_rezalloc_aligned(void *p, size_t newsize, size_t alignment)",
            "params": [
                "void *p",
                "size_t newsize",
                "size_t alignment"
            ],
            "definition": "void *mi_rezalloc_aligned(void *p, size_t newsize, size_t alignment)\n{\n  return mi_heap_rezalloc_aligned(mi_prim_get_default_heap(), p, newsize, alignment);\n}\n\n",
            "calle": [
                "mi_heap_rezalloc_aligned",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_rezalloc_aligned_at",
            "header": "void *mi_rezalloc_aligned_at(void *p, size_t newsize, size_t alignment, size_t offset)",
            "params": [
                "void *p",
                "size_t newsize",
                "size_t alignment",
                "size_t offset"
            ],
            "definition": "void *mi_rezalloc_aligned_at(void *p, size_t newsize, size_t alignment, size_t offset)\n{\n  return mi_heap_rezalloc_aligned_at(mi_prim_get_default_heap(), p, newsize, alignment, offset);\n}\n\n",
            "calle": [
                "mi_heap_rezalloc_aligned_at",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "size_t",
                        "definition": [
                            "size_t offset"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_recalloc_aligned",
            "header": "void *mi_recalloc_aligned(void *p, size_t newcount, size_t size, size_t alignment)",
            "params": [
                "void *p",
                "size_t newcount",
                "size_t size",
                "size_t alignment"
            ],
            "definition": "void *mi_recalloc_aligned(void *p, size_t newcount, size_t size, size_t alignment)\n{\n  return mi_heap_recalloc_aligned(mi_prim_get_default_heap(), p, newcount, size, alignment);\n}\n\n",
            "calle": [
                "mi_heap_recalloc_aligned",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newcount",
                        "type": "size_t",
                        "definition": [
                            "size_t newcount"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_recalloc_aligned_at",
            "header": "void *mi_recalloc_aligned_at(void *p, size_t newcount, size_t size, size_t alignment, size_t offset)",
            "params": [
                "void *p",
                "size_t newcount",
                "size_t size",
                "size_t alignment",
                "size_t offset"
            ],
            "definition": "void *mi_recalloc_aligned_at(void *p, size_t newcount, size_t size, size_t alignment, size_t offset)\n{\n  return mi_heap_recalloc_aligned_at(mi_prim_get_default_heap(), p, newcount, size, alignment, offset);\n}\n\n",
            "calle": [
                "mi_heap_recalloc_aligned_at",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newcount",
                        "type": "size_t",
                        "definition": [
                            "size_t newcount"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "size_t",
                        "definition": [
                            "size_t offset"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_rezalloc_aligned",
            "header": "void *mi_heap_rezalloc_aligned(mi_heap_t *heap, void *p, size_t newsize, size_t alignment)",
            "params": [
                "mi_heap_t *heap",
                "void *p",
                "size_t newsize",
                "size_t alignment"
            ],
            "definition": "void *mi_heap_rezalloc_aligned(mi_heap_t *heap, void *p, size_t newsize, size_t alignment)\n{\n  return mi_heap_realloc_zero_aligned(heap, p, newsize, alignment, 1);\n}\n\n",
            "calle": [
                "mi_heap_realloc_zero_aligned"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_rezalloc_aligned_at",
            "header": "void *mi_heap_rezalloc_aligned_at(mi_heap_t *heap, void *p, size_t newsize, size_t alignment, size_t offset)",
            "params": [
                "mi_heap_t *heap",
                "void *p",
                "size_t newsize",
                "size_t alignment",
                "size_t offset"
            ],
            "definition": "void *mi_heap_rezalloc_aligned_at(mi_heap_t *heap, void *p, size_t newsize, size_t alignment, size_t offset)\n{\n  return mi_heap_realloc_zero_aligned_at(heap, p, newsize, alignment, offset, 1);\n}\n\n",
            "calle": [
                "mi_heap_realloc_zero_aligned_at"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "size_t",
                        "definition": [
                            "size_t offset"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_recalloc_aligned",
            "header": "void *mi_heap_recalloc_aligned(mi_heap_t *heap, void *p, size_t newcount, size_t size, size_t alignment)",
            "params": [
                "mi_heap_t *heap",
                "void *p",
                "size_t newcount",
                "size_t size",
                "size_t alignment"
            ],
            "definition": "void *mi_heap_recalloc_aligned(mi_heap_t *heap, void *p, size_t newcount, size_t size, size_t alignment)\n{\n  size_t total;\n  if (mi_count_size_overflow(newcount, size, &total))\n  {\n    return 0;\n  }\n  return mi_heap_rezalloc_aligned(heap, p, total, alignment);\n}\n\n",
            "calle": [
                "mi_count_size_overflow",
                "mi_heap_rezalloc_aligned"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newcount",
                        "type": "size_t",
                        "definition": [
                            "size_t newcount"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "total",
                        "type": "size_t",
                        "definition": [
                            "size_t total"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_recalloc_aligned_at",
            "header": "void *mi_heap_recalloc_aligned_at(mi_heap_t *heap, void *p, size_t newcount, size_t size, size_t alignment, size_t offset)",
            "params": [
                "mi_heap_t *heap",
                "void *p",
                "size_t newcount",
                "size_t size",
                "size_t alignment",
                "size_t offset"
            ],
            "definition": "void *mi_heap_recalloc_aligned_at(mi_heap_t *heap, void *p, size_t newcount, size_t size, size_t alignment, size_t offset)\n{\n  size_t total;\n  if (mi_count_size_overflow(newcount, size, &total))\n  {\n    return 0;\n  }\n  return mi_heap_rezalloc_aligned_at(heap, p, total, alignment, offset);\n}\n\n",
            "calle": [
                "mi_count_size_overflow",
                "mi_heap_rezalloc_aligned_at"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newcount",
                        "type": "size_t",
                        "definition": [
                            "size_t newcount"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "size_t",
                        "definition": [
                            "size_t offset"
                        ]
                    },
                    {
                        "path": null,
                        "name": "total",
                        "type": "size_t",
                        "definition": [
                            "size_t total"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_malloc_is_naturally_aligned",
            "header": "",
            "params": [
                "size_t size",
                "size_t alignment"
            ],
            "definition": "static bool mi_malloc_is_naturally_aligned(size_t size, size_t alignment)\n{\n  (_mi_is_power_of_two(alignment) && (alignment > 0)) ? ((void) 0) : (_mi_assert_fail(\"_mi_is_power_of_two(alignment) && (alignment > 0)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-aligned.c\", 20, __func__));\n  if (alignment > size)\n  {\n    return 0;\n  }\n  if (alignment <= 16)\n  {\n    return 1;\n  }\n  const size_t bsize = mi_good_size(size);\n  return (bsize <= ((1UL << (3 + (13 + 3))) / 8)) && ((bsize & (alignment - 1)) == 0);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_is_power_of_two",
                "mi_good_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bsize = mi_good_size(size)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_malloc_zero_no_guarded",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "size_t size",
                "bool zero"
            ],
            "definition": "static void *mi_heap_malloc_zero_no_guarded(mi_heap_t *heap, size_t size, bool zero)\n{\n  return _mi_heap_malloc_zero(heap, size, zero);\n}\n\n",
            "calle": [
                "_mi_heap_malloc_zero"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "zero",
                        "type": "bool",
                        "definition": [
                            "bool zero"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_malloc_zero_aligned_at_overalloc",
            "header": "",
            "params": [
                "mi_heap_t * const heap",
                "const size_t size",
                "const size_t alignment",
                "const size_t offset",
                "const bool zero"
            ],
            "definition": "static void *mi_heap_malloc_zero_aligned_at_overalloc(mi_heap_t * const heap, const size_t size, const size_t alignment, const size_t offset, const bool zero)\n{\n  (size <= (PTRDIFF_MAX - (sizeof(mi_padding_t)))) ? ((void) 0) : (_mi_assert_fail(\"size <= (MI_MAX_ALLOC_SIZE - MI_PADDING_SIZE)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-aligned.c\", 57, __func__));\n  ((alignment != 0) && _mi_is_power_of_two(alignment)) ? ((void) 0) : (_mi_assert_fail(\"alignment != 0 && _mi_is_power_of_two(alignment)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-aligned.c\", 58, __func__));\n  void *p;\n  unsigned int p_idx = 0;\n  size_t oversize;\n  if (__builtin_expect(!(!(alignment > ((1UL << (9 + (13 + 3))) >> 1))), 0))\n  {\n    if (__builtin_expect(!(!(offset != 0)), 0))\n    {\n      _mi_error_message(75, \"aligned allocation with a very large alignment cannot be used with an alignment offset (size %zu, alignment %zu, offset %zu)\\n\", size, alignment, offset);\n      return 0;\n    }\n    oversize = (size <= (128 * (sizeof(void *)))) ? ((128 * (sizeof(void *))) + 1) : (size);\n    p_idx = _mi_heap_malloc_zero_ex(heap, oversize, 0, alignment);\n    if ((&p[p_idx]) == 0)\n    {\n      return 0;\n    }\n  }\n  else\n  {\n    oversize = (((size < 16) ? (16) : (size)) + alignment) - 1;\n    p_idx = mi_heap_malloc_zero_no_guarded(heap, oversize, zero);\n    if ((&p[p_idx]) == 0)\n    {\n      return 0;\n    }\n  }\n  mi_page_t *page = _mi_ptr_page(p);\n  const uintptr_t align_mask = alignment - 1;\n  const uintptr_t poffset = (((uintptr_t) p) + offset) & align_mask;\n  const uintptr_t adjust = (poffset == 0) ? (0) : (alignment - poffset);\n  (adjust < alignment) ? ((void) 0) : (_mi_assert_fail(\"adjust < alignment\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-aligned.c\", 91, __func__));\n  void *aligned_p = (void *) (((uintptr_t) p) + adjust);\n  if (aligned_p != (&p[p_idx]))\n  {\n    mi_page_set_has_aligned(page, 1);\n    _mi_padding_shrink(page, (mi_block_t *) p, adjust + size);\n  }\n  (mi_page_usable_block_size(page) >= (adjust + size)) ? ((void) 0) : (_mi_assert_fail(\"mi_page_usable_block_size(page) >= adjust + size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-aligned.c\", 106, __func__));\n  (((((uintptr_t) aligned_p) + offset) % alignment) == 0) ? ((void) 0) : (_mi_assert_fail(\"((uintptr_t)aligned_p + offset) % alignment == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-aligned.c\", 107, __func__));\n  (mi_usable_size(aligned_p) >= size) ? ((void) 0) : (_mi_assert_fail(\"mi_usable_size(aligned_p)>=size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-aligned.c\", 108, __func__));\n  (mi_usable_size(p) == (mi_usable_size(aligned_p) + adjust)) ? ((void) 0) : (_mi_assert_fail(\"mi_usable_size(p) == mi_usable_size(aligned_p)+adjust\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-aligned.c\", 109, __func__));\n  mi_page_t * const apage = _mi_ptr_page(aligned_p);\n  void *unalign_p = _mi_page_ptr_unalign(apage, aligned_p);\n  ((&p[p_idx]) == unalign_p) ? ((void) 0) : (_mi_assert_fail(\"p == unalign_p\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-aligned.c\", 113, __func__));\n  if (alignment > ((1UL << (9 + (13 + 3))) >> 1))\n  {\n    ;\n    if (zero)\n    {\n      _mi_memzero_aligned(aligned_p, mi_usable_size(aligned_p));\n    }\n  }\n  if ((&p[p_idx]) != aligned_p)\n  {\n    ;\n  }\n  return aligned_p;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_error_message",
                "_mi_heap_malloc_zero_ex",
                "_mi_is_power_of_two",
                "_mi_memzero_aligned",
                "_mi_padding_shrink",
                "_mi_page_ptr_unalign",
                "_mi_ptr_page",
                "mi_heap_malloc_zero_no_guarded",
                "mi_page_set_has_aligned",
                "mi_page_usable_block_size",
                "mi_usable_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t * const",
                        "definition": [
                            "mi_heap_t * const heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "const size_t",
                        "definition": [
                            "const size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "const size_t",
                        "definition": [
                            "const size_t offset"
                        ]
                    },
                    {
                        "path": null,
                        "name": "zero",
                        "type": "const bool",
                        "definition": [
                            "const bool zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int p_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "oversize",
                        "type": "size_t",
                        "definition": [
                            "size_t oversize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = _mi_ptr_page(p)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "align_mask",
                        "type": "const uintptr_t",
                        "definition": [
                            "const uintptr_t align_mask = alignment - 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "poffset",
                        "type": "const uintptr_t",
                        "definition": [
                            "const uintptr_t poffset = (((uintptr_t) p) + offset) & align_mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "adjust",
                        "type": "const uintptr_t",
                        "definition": [
                            "const uintptr_t adjust = (poffset == 0) ? (0) : (alignment - poffset)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "aligned_p",
                        "type": "void *",
                        "definition": [
                            "void *aligned_p = (void *) (((uintptr_t) p) + adjust)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "apage",
                        "type": "mi_page_t * const",
                        "definition": [
                            "mi_page_t * const apage = _mi_ptr_page(aligned_p)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "unalign_p",
                        "type": "void *",
                        "definition": [
                            "void *unalign_p = _mi_page_ptr_unalign(apage, aligned_p)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_malloc_zero_aligned_at_generic",
            "header": "",
            "params": [
                "mi_heap_t * const heap",
                "const size_t size",
                "const size_t alignment",
                "const size_t offset",
                "const bool zero"
            ],
            "definition": "static void *mi_heap_malloc_zero_aligned_at_generic(mi_heap_t * const heap, const size_t size, const size_t alignment, const size_t offset, const bool zero)\n{\n  ((alignment != 0) && _mi_is_power_of_two(alignment)) ? ((void) 0) : (_mi_assert_fail(\"alignment != 0 && _mi_is_power_of_two(alignment)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-aligned.c\", 137, __func__));\n  if (__builtin_expect(!(!(size > (PTRDIFF_MAX - (sizeof(mi_padding_t))))), 0))\n  {\n    _mi_error_message(75, \"aligned allocation request is too large (size %zu, alignment %zu)\\n\", size, alignment);\n    return 0;\n  }\n  if ((offset == 0) && mi_malloc_is_naturally_aligned(size, alignment))\n  {\n    void *p = mi_heap_malloc_zero_no_guarded(heap, size, zero);\n    ((p == 0) || ((((uintptr_t) p) % alignment) == 0)) ? ((void) 0) : (_mi_assert_fail(\"p == NULL || ((uintptr_t)p % alignment) == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-aligned.c\", 151, __func__));\n    const bool is_aligned_or_null = (((uintptr_t) p) & (alignment - 1)) == 0;\n    if (__builtin_expect(!(!is_aligned_or_null), 1))\n    {\n      return p;\n    }\n    else\n    {\n      (0) ? ((void) 0) : (_mi_assert_fail(\"false\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-aligned.c\", 158, __func__));\n      mi_free(p);\n    }\n  }\n  return mi_heap_malloc_zero_aligned_at_overalloc(heap, size, alignment, offset, zero);\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_error_message",
                "_mi_is_power_of_two",
                "mi_free",
                "mi_heap_malloc_zero_aligned_at_overalloc",
                "mi_heap_malloc_zero_no_guarded",
                "mi_malloc_is_naturally_aligned"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t * const",
                        "definition": [
                            "mi_heap_t * const heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "const size_t",
                        "definition": [
                            "const size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "const size_t",
                        "definition": [
                            "const size_t offset"
                        ]
                    },
                    {
                        "path": null,
                        "name": "zero",
                        "type": "const bool",
                        "definition": [
                            "const bool zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = mi_heap_malloc_zero_no_guarded(heap, size, zero)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_aligned_or_null",
                        "type": "const bool",
                        "definition": [
                            "const bool is_aligned_or_null = (((uintptr_t) p) & (alignment - 1)) == 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_malloc_zero_aligned_at",
            "header": "",
            "params": [
                "mi_heap_t * const heap",
                "const size_t size",
                "const size_t alignment",
                "const size_t offset",
                "const bool zero"
            ],
            "definition": "static void *mi_heap_malloc_zero_aligned_at(mi_heap_t * const heap, const size_t size, const size_t alignment, const size_t offset, const bool zero)\n{\n  if (__builtin_expect(!(!((alignment == 0) || (!_mi_is_power_of_two(alignment)))), 0))\n  {\n    _mi_error_message(75, \"aligned allocation requires the alignment to be a power-of-two (size %zu, alignment %zu)\\n\", size, alignment);\n    return 0;\n  }\n  if (__builtin_expect(!(!((size <= (128 * (sizeof(void *)))) && (alignment <= size))), 1))\n  {\n    const uintptr_t align_mask = alignment - 1;\n    const size_t padsize = size + (sizeof(mi_padding_t));\n    mi_page_t *page = _mi_heap_get_free_small_page(heap, padsize);\n    if (__builtin_expect(!(!(page->free != 0)), 1))\n    {\n      const bool is_aligned = ((((uintptr_t) page->free) + offset) & align_mask) == 0;\n      if (__builtin_expect(!(!is_aligned), 1))\n      {\n        void *p = (zero) ? (_mi_page_malloc_zeroed(heap, page, padsize)) : (_mi_page_malloc(heap, page, padsize));\n        (p != 0) ? ((void) 0) : (_mi_assert_fail(\"p != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-aligned.c\", 195, __func__));\n        (((((uintptr_t) p) + offset) % alignment) == 0) ? ((void) 0) : (_mi_assert_fail(\"((uintptr_t)p + offset) % alignment == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-aligned.c\", 196, __func__));\n        if (p != 0)\n        {\n          (mi_usable_size(p) == size) ? ((void) 0) : (_mi_assert_fail(\"mi_usable_size(p)==(size)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-aligned.c\", 197, __func__));\n          ;\n        }\n        ;\n        return p;\n      }\n    }\n  }\n  return mi_heap_malloc_zero_aligned_at_generic(heap, size, alignment, offset, zero);\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_error_message",
                "_mi_heap_get_free_small_page",
                "_mi_is_power_of_two",
                "_mi_page_malloc",
                "_mi_page_malloc_zeroed",
                "mi_heap_malloc_zero_aligned_at_generic",
                "mi_usable_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t * const",
                        "definition": [
                            "mi_heap_t * const heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "const size_t",
                        "definition": [
                            "const size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "const size_t",
                        "definition": [
                            "const size_t offset"
                        ]
                    },
                    {
                        "path": null,
                        "name": "zero",
                        "type": "const bool",
                        "definition": [
                            "const bool zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "align_mask",
                        "type": "const uintptr_t",
                        "definition": [
                            "const uintptr_t align_mask = alignment - 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "padsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t padsize = size + (sizeof(mi_padding_t))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = _mi_heap_get_free_small_page(heap, padsize)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_aligned",
                        "type": "const bool",
                        "definition": [
                            "const bool is_aligned = ((((uintptr_t) page->free) + offset) & align_mask) == 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = (zero) ? (_mi_page_malloc_zeroed(heap, page, padsize)) : (_mi_page_malloc(heap, page, padsize))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_realloc_zero_aligned_at",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "void *p",
                "size_t newsize",
                "size_t alignment",
                "size_t offset",
                "bool zero"
            ],
            "definition": "static void *mi_heap_realloc_zero_aligned_at(mi_heap_t *heap, void *p, size_t newsize, size_t alignment, size_t offset, bool zero)\n{\n  (alignment > 0) ? ((void) 0) : (_mi_assert_fail(\"alignment > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-aligned.c\", 277, __func__));\n  if (alignment <= (sizeof(uintptr_t)))\n  {\n    return _mi_heap_realloc_zero(heap, p, newsize, zero);\n  }\n  if (p == 0)\n  {\n    return mi_heap_malloc_zero_aligned_at(heap, newsize, alignment, offset, zero);\n  }\n  size_t size = mi_usable_size(p);\n  if (((newsize <= size) && (newsize >= (size - (size / 2)))) && (((((uintptr_t) p) + offset) % alignment) == 0))\n  {\n    return p;\n  }\n  else\n  {\n    void *newp = mi_heap_malloc_aligned_at(heap, newsize, alignment, offset);\n    if (newp != 0)\n    {\n      if (zero && (newsize > size))\n      {\n        size_t start = (size >= (sizeof(intptr_t))) ? (size - (sizeof(intptr_t))) : (0);\n        _mi_memzero(((uint8_t *) newp) + start, newsize - start);\n      }\n      _mi_memcpy_aligned(newp, p, (newsize > size) ? (size) : (newsize));\n      mi_free(p);\n    }\n    return newp;\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_heap_realloc_zero",
                "_mi_memcpy_aligned",
                "_mi_memzero",
                "mi_free",
                "mi_heap_malloc_aligned_at",
                "mi_heap_malloc_zero_aligned_at",
                "mi_usable_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "size_t",
                        "definition": [
                            "size_t offset"
                        ]
                    },
                    {
                        "path": null,
                        "name": "zero",
                        "type": "bool",
                        "definition": [
                            "bool zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size = mi_usable_size(p)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newp",
                        "type": "void *",
                        "definition": [
                            "void *newp = mi_heap_malloc_aligned_at(heap, newsize, alignment, offset)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "size_t",
                        "definition": [
                            "size_t start = (size >= (sizeof(intptr_t))) ? (size - (sizeof(intptr_t))) : (0)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_realloc_zero_aligned",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "void *p",
                "size_t newsize",
                "size_t alignment",
                "bool zero"
            ],
            "definition": "static void *mi_heap_realloc_zero_aligned(mi_heap_t *heap, void *p, size_t newsize, size_t alignment, bool zero)\n{\n  (alignment > 0) ? ((void) 0) : (_mi_assert_fail(\"alignment > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-aligned.c\", 302, __func__));\n  if (alignment <= (sizeof(uintptr_t)))\n  {\n    return _mi_heap_realloc_zero(heap, p, newsize, zero);\n  }\n  size_t offset = ((uintptr_t) p) % alignment;\n  return mi_heap_realloc_zero_aligned_at(heap, p, newsize, alignment, offset, zero);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_heap_realloc_zero",
                "mi_heap_realloc_zero_aligned_at"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "zero",
                        "type": "bool",
                        "definition": [
                            "bool zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "size_t",
                        "definition": [
                            "size_t offset = ((uintptr_t) p) % alignment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_cfree",
            "header": "void mi_cfree(void *p)",
            "params": [
                "void *p"
            ],
            "definition": "void mi_cfree(void *p)\n{\n  if (mi_is_in_heap_region(p))\n  {\n    mi_free(p);\n  }\n}\n\n",
            "calle": [
                "mi_free",
                "mi_is_in_heap_region"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi__expand",
            "header": "void *mi__expand(void *p, size_t newsize)",
            "params": [
                "void *p",
                "size_t newsize"
            ],
            "definition": "void *mi__expand(void *p, size_t newsize)\n{\n  void *res = mi_expand(p, newsize);\n  if (res == 0)\n  {\n    errno = 12;\n  }\n  return res;\n}\n\n",
            "calle": [
                "mi_expand"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t",
                        "definition": [
                            "size_t newsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "res",
                        "type": "void *",
                        "definition": [
                            "void *res = mi_expand(p, newsize)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_malloc_size",
            "header": "size_t mi_malloc_size(const void *p)",
            "params": [
                "const void *p"
            ],
            "definition": "size_t mi_malloc_size(const void *p)\n{\n  return mi_usable_size(p);\n}\n\n",
            "calle": [
                "mi_usable_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_malloc_good_size",
            "header": "size_t mi_malloc_good_size(size_t size)",
            "params": [
                "size_t size"
            ],
            "definition": "size_t mi_malloc_good_size(size_t size)\n{\n  return mi_good_size(size);\n}\n\n",
            "calle": [
                "mi_good_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_malloc_usable_size",
            "header": "size_t mi_malloc_usable_size(const void *p)",
            "params": [
                "const void *p"
            ],
            "definition": "size_t mi_malloc_usable_size(const void *p)\n{\n  return mi_usable_size(p);\n}\n\n",
            "calle": [
                "mi_usable_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_posix_memalign",
            "header": "int mi_posix_memalign(void **p, size_t alignment, size_t size)",
            "params": [
                "void **p",
                "size_t alignment",
                "size_t size"
            ],
            "definition": "int mi_posix_memalign(void **p, size_t alignment, size_t size)\n{\n  if (p == 0)\n  {\n    return 22;\n  }\n  if ((alignment % (sizeof(void *))) != 0)\n  {\n    return 22;\n  }\n  if ((alignment == 0) || (!_mi_is_power_of_two(alignment)))\n  {\n    return 22;\n  }\n  void *q = mi_malloc_aligned(size, alignment);\n  if ((q == 0) && (size != 0))\n  {\n    return 12;\n  }\n  ((((uintptr_t) q) % alignment) == 0) ? ((void) 0) : (_mi_assert_fail(\"((uintptr_t)q % alignment) == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-posix.c\", 64, __func__));\n  *p = q;\n  return 0;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_is_power_of_two",
                "mi_malloc_aligned"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void **",
                        "definition": [
                            "void **p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "q",
                        "type": "void *",
                        "definition": [
                            "void *q = mi_malloc_aligned(size, alignment)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_memalign",
            "header": "void *mi_memalign(size_t alignment, size_t size)",
            "params": [
                "size_t alignment",
                "size_t size"
            ],
            "definition": "void *mi_memalign(size_t alignment, size_t size)\n{\n  void *p = mi_malloc_aligned(size, alignment);\n  ((((uintptr_t) p) % alignment) == 0) ? ((void) 0) : (_mi_assert_fail(\"((uintptr_t)p % alignment) == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-posix.c\", 71, __func__));\n  return p;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_malloc_aligned"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = mi_malloc_aligned(size, alignment)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_valloc",
            "header": "void *mi_valloc(size_t size)",
            "params": [
                "size_t size"
            ],
            "definition": "void *mi_valloc(size_t size)\n{\n  return mi_memalign(_mi_os_page_size(), size);\n}\n\n",
            "calle": [
                "_mi_os_page_size",
                "mi_memalign"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_pvalloc",
            "header": "void *mi_pvalloc(size_t size)",
            "params": [
                "size_t size"
            ],
            "definition": "void *mi_pvalloc(size_t size)\n{\n  size_t psize = _mi_os_page_size();\n  if (size >= (SIZE_MAX - psize))\n  {\n    return 0;\n  }\n  size_t asize = _mi_align_up(size, psize);\n  return mi_malloc_aligned(asize, psize);\n}\n\n",
            "calle": [
                "_mi_align_up",
                "_mi_os_page_size",
                "mi_malloc_aligned"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "psize",
                        "type": "size_t",
                        "definition": [
                            "size_t psize = _mi_os_page_size()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "asize",
                        "type": "size_t",
                        "definition": [
                            "size_t asize = _mi_align_up(size, psize)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_aligned_alloc",
            "header": "void *mi_aligned_alloc(size_t alignment, size_t size)",
            "params": [
                "size_t alignment",
                "size_t size"
            ],
            "definition": "void *mi_aligned_alloc(size_t alignment, size_t size)\n{\n  void *p = mi_malloc_aligned(size, alignment);\n  ((((uintptr_t) p) % alignment) == 0) ? ((void) 0) : (_mi_assert_fail(\"((uintptr_t)p % alignment) == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-posix.c\", 98, __func__));\n  return p;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_malloc_aligned"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = mi_malloc_aligned(size, alignment)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_reallocarray",
            "header": "void *mi_reallocarray(void *p, size_t count, size_t size)",
            "params": [
                "void *p",
                "size_t count",
                "size_t size"
            ],
            "definition": "void *mi_reallocarray(void *p, size_t count, size_t size)\n{\n  void *newp = mi_reallocn(p, count, size);\n  if (newp == 0)\n  {\n    errno = 12;\n  }\n  return newp;\n}\n\n",
            "calle": [
                "mi_reallocn"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newp",
                        "type": "void *",
                        "definition": [
                            "void *newp = mi_reallocn(p, count, size)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_reallocarr",
            "header": "int mi_reallocarr(void *p, size_t count, size_t size)",
            "params": [
                "void *p",
                "size_t count",
                "size_t size"
            ],
            "definition": "int mi_reallocarr(void *p, size_t count, size_t size)\n{\n  (p != 0) ? ((void) 0) : (_mi_assert_fail(\"p != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/alloc-posix.c\", 109, __func__));\n  if (p == 0)\n  {\n    errno = 22;\n    return 22;\n  }\n  void **op = (void **) p;\n  void *newp = mi_reallocarray(*op, count, size);\n  if (__builtin_expect(!(!(newp == 0)), 0))\n  {\n    return errno;\n  }\n  *op = newp;\n  return 0;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "mi_reallocarray"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "op",
                        "type": "void **",
                        "definition": [
                            "void **op = (void **) p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newp",
                        "type": "void *",
                        "definition": [
                            "void *newp = mi_reallocarray(*op, count, size)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_aligned_recalloc",
            "header": "void *mi_aligned_recalloc(void *p, size_t newcount, size_t size, size_t alignment)",
            "params": [
                "void *p",
                "size_t newcount",
                "size_t size",
                "size_t alignment"
            ],
            "definition": "void *mi_aligned_recalloc(void *p, size_t newcount, size_t size, size_t alignment)\n{\n  return mi_recalloc_aligned(p, newcount, size, alignment);\n}\n\n",
            "calle": [
                "mi_recalloc_aligned"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newcount",
                        "type": "size_t",
                        "definition": [
                            "size_t newcount"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_aligned_offset_recalloc",
            "header": "void *mi_aligned_offset_recalloc(void *p, size_t newcount, size_t size, size_t alignment, size_t offset)",
            "params": [
                "void *p",
                "size_t newcount",
                "size_t size",
                "size_t alignment",
                "size_t offset"
            ],
            "definition": "void *mi_aligned_offset_recalloc(void *p, size_t newcount, size_t size, size_t alignment, size_t offset)\n{\n  return mi_recalloc_aligned_at(p, newcount, size, alignment, offset);\n}\n\n",
            "calle": [
                "mi_recalloc_aligned_at"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newcount",
                        "type": "size_t",
                        "definition": [
                            "size_t newcount"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "size_t",
                        "definition": [
                            "size_t offset"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_wcsdup",
            "header": "unsigned short *mi_wcsdup(const unsigned short *s)",
            "params": [
                "const unsigned short *s"
            ],
            "definition": "unsigned short *mi_wcsdup(const unsigned short *s)\n{\n  if (s == 0)\n  {\n    return 0;\n  }\n  size_t len;\n  for (len = 0; s[len] != 0; len += 1)\n  {\n  }\n\n  size_t size = (len + 1) * (sizeof(unsigned short));\n  unsigned short *p = (unsigned short *) mi_malloc(size);\n  if (p != 0)\n  {\n    _mi_memcpy(p, s, size);\n  }\n  return p;\n}\n\n",
            "calle": [
                "_mi_memcpy",
                "mi_malloc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "s",
                        "type": "const unsigned short *",
                        "definition": [
                            "const unsigned short *s"
                        ]
                    },
                    {
                        "path": null,
                        "name": "len",
                        "type": "size_t",
                        "definition": [
                            "size_t len"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size = (len + 1) * (sizeof(unsigned short))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "unsigned short *",
                        "definition": [
                            "unsigned short *p = (unsigned short *) mi_malloc(size)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_mbsdup",
            "header": "unsigned char *mi_mbsdup(const unsigned char *s)",
            "params": [
                "const unsigned char *s"
            ],
            "definition": "unsigned char *mi_mbsdup(const unsigned char *s)\n{\n  return (unsigned char *) mi_strdup((const char *) s);\n}\n\n",
            "calle": [
                "mi_strdup"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "s",
                        "type": "const unsigned char *",
                        "definition": [
                            "const unsigned char *s"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_dupenv_s",
            "header": "int mi_dupenv_s(char **buf, size_t *size, const char *name)",
            "params": [
                "char **buf",
                "size_t *size",
                "const char *name"
            ],
            "definition": "int mi_dupenv_s(char **buf, size_t *size, const char *name)\n{\n  if ((buf == 0) || (name == 0))\n  {\n    return 22;\n  }\n  if (size != 0)\n  {\n    *size = 0;\n  }\n  char *p = getenv(name);\n  if (p == 0)\n  {\n    *buf = 0;\n  }\n  else\n  {\n    *buf = mi_strdup(p);\n    if ((*buf) == 0)\n    {\n      return 12;\n    }\n    if (size != 0)\n    {\n      *size = _mi_strlen(p);\n    }\n  }\n  return 0;\n}\n\n",
            "calle": [
                "_mi_strlen",
                "getenv",
                "mi_strdup"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char **",
                        "definition": [
                            "char **buf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t *",
                        "definition": [
                            "size_t *size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "name",
                        "type": "const char *",
                        "definition": [
                            "const char *name"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "char *",
                        "definition": [
                            "char *p = getenv(name)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_wdupenv_s",
            "header": "int mi_wdupenv_s(unsigned short **buf, size_t *size, const unsigned short *name)",
            "params": [
                "unsigned short **buf",
                "size_t *size",
                "const unsigned short *name"
            ],
            "definition": "int mi_wdupenv_s(unsigned short **buf, size_t *size, const unsigned short *name)\n{\n  if ((buf == 0) || (name == 0))\n  {\n    return 22;\n  }\n  if (size != 0)\n  {\n    *size = 0;\n  }\n  *buf = 0;\n  return 22;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "buf",
                        "type": "unsigned short **",
                        "definition": [
                            "unsigned short **buf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t *",
                        "definition": [
                            "size_t *size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "name",
                        "type": "const unsigned short *",
                        "definition": [
                            "const unsigned short *name"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_reserve_huge_os_pages_interleave",
            "header": "int mi_reserve_huge_os_pages_interleave(size_t pages, size_t numa_nodes, size_t timeout_msecs)",
            "params": [
                "size_t pages",
                "size_t numa_nodes",
                "size_t timeout_msecs"
            ],
            "definition": "int mi_reserve_huge_os_pages_interleave(size_t pages, size_t numa_nodes, size_t timeout_msecs)\n{\n  if (pages == 0)\n  {\n    return 0;\n  }\n  int numa_count = ((numa_nodes > 0) && (numa_nodes <= 2147483647)) ? ((int) numa_nodes) : (_mi_os_numa_node_count());\n  if (numa_count == 0)\n  {\n    numa_count = 1;\n  }\n  const size_t pages_per = pages / numa_count;\n  const size_t pages_mod = pages % numa_count;\n  const size_t timeout_per = (timeout_msecs == 0) ? (0) : ((timeout_msecs / numa_count) + 50);\n  for (int numa_node = 0; (numa_node < numa_count) && (pages > 0); numa_node += 1)\n  {\n    size_t node_pages = pages_per;\n    if (((size_t) numa_node) < pages_mod)\n    {\n      node_pages += 1;\n    }\n    int err = mi_reserve_huge_os_pages_at(node_pages, numa_node, timeout_per);\n    if (err)\n    {\n      return err;\n    }\n    if (pages < node_pages)\n    {\n      pages = 0;\n    }\n    else\n    {\n      pages -= node_pages;\n    }\n  }\n\n  return 0;\n}\n\n",
            "calle": [
                "_mi_os_numa_node_count",
                "mi_reserve_huge_os_pages_at"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "pages",
                        "type": "size_t",
                        "definition": [
                            "size_t pages"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numa_nodes",
                        "type": "size_t",
                        "definition": [
                            "size_t numa_nodes"
                        ]
                    },
                    {
                        "path": null,
                        "name": "timeout_msecs",
                        "type": "size_t",
                        "definition": [
                            "size_t timeout_msecs"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numa_count",
                        "type": "int",
                        "definition": [
                            "int numa_count = ((numa_nodes > 0) && (numa_nodes <= 2147483647)) ? ((int) numa_nodes) : (_mi_os_numa_node_count())"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pages_per",
                        "type": "const size_t",
                        "definition": [
                            "const size_t pages_per = pages / numa_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pages_mod",
                        "type": "const size_t",
                        "definition": [
                            "const size_t pages_mod = pages % numa_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "timeout_per",
                        "type": "const size_t",
                        "definition": [
                            "const size_t timeout_per = (timeout_msecs == 0) ? (0) : ((timeout_msecs / numa_count) + 50)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numa_node",
                        "type": "int",
                        "definition": [
                            "int numa_node = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "node_pages",
                        "type": "size_t",
                        "definition": [
                            "size_t node_pages = pages_per"
                        ]
                    },
                    {
                        "path": null,
                        "name": "err",
                        "type": "int",
                        "definition": [
                            "int err = mi_reserve_huge_os_pages_at(node_pages, numa_node, timeout_per)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_reserve_huge_os_pages_at",
            "header": "int mi_reserve_huge_os_pages_at(size_t pages, int numa_node, size_t timeout_msecs)",
            "params": [
                "size_t pages",
                "int numa_node",
                "size_t timeout_msecs"
            ],
            "definition": "int mi_reserve_huge_os_pages_at(size_t pages, int numa_node, size_t timeout_msecs)\n{\n  return mi_reserve_huge_os_pages_at_ex(pages, numa_node, timeout_msecs, 0, 0);\n}\n\n",
            "calle": [
                "mi_reserve_huge_os_pages_at_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "pages",
                        "type": "size_t",
                        "definition": [
                            "size_t pages"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numa_node",
                        "type": "int",
                        "definition": [
                            "int numa_node"
                        ]
                    },
                    {
                        "path": null,
                        "name": "timeout_msecs",
                        "type": "size_t",
                        "definition": [
                            "size_t timeout_msecs"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_reserve_os_memory",
            "header": "int mi_reserve_os_memory(size_t size, bool commit, bool allow_large)",
            "params": [
                "size_t size",
                "bool commit",
                "bool allow_large"
            ],
            "definition": "int mi_reserve_os_memory(size_t size, bool commit, bool allow_large)\n{\n  return mi_reserve_os_memory_ex(size, commit, allow_large, 0, 0);\n}\n\n",
            "calle": [
                "mi_reserve_os_memory_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit",
                        "type": "bool",
                        "definition": [
                            "bool commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_large",
                        "type": "bool",
                        "definition": [
                            "bool allow_large"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_manage_os_memory",
            "header": "bool mi_manage_os_memory(void *start, size_t size, bool is_committed, bool is_large, bool is_zero, int numa_node)",
            "params": [
                "void *start",
                "size_t size",
                "bool is_committed",
                "bool is_large",
                "bool is_zero",
                "int numa_node"
            ],
            "definition": "bool mi_manage_os_memory(void *start, size_t size, bool is_committed, bool is_large, bool is_zero, int numa_node)\n{\n  return mi_manage_os_memory_ex(start, size, is_committed, is_large, is_zero, numa_node, 0, 0);\n}\n\n",
            "calle": [
                "mi_manage_os_memory_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "start",
                        "type": "void *",
                        "definition": [
                            "void *start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_committed",
                        "type": "bool",
                        "definition": [
                            "bool is_committed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_large",
                        "type": "bool",
                        "definition": [
                            "bool is_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_zero",
                        "type": "bool",
                        "definition": [
                            "bool is_zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numa_node",
                        "type": "int",
                        "definition": [
                            "int numa_node"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_debug_show_arenas",
            "header": "void mi_debug_show_arenas(void)",
            "params": [
                "void"
            ],
            "definition": "void mi_debug_show_arenas(void)\n{\n  const bool show_inuse = 1;\n  size_t max_arenas = atomic_load_explicit(&mi_arena_count, memory_order_relaxed);\n  size_t inuse_total = 0;\n  for (size_t i = 0; i < max_arenas; i += 1)\n  {\n    mi_arena_t *arena = atomic_load_explicit(&mi_arenas[i], memory_order_relaxed);\n    if (arena == 0)\n    {\n      break;\n    }\n    _mi_message(\"arena %zu: %zu blocks of size %zuMiB (in %zu fields) %s\\n\", i, arena->block_count, (size_t) ((1UL << (9 + (13 + 3))) / (1024UL * 1024UL)), arena->field_count, (arena->memid.is_pinned) ? (\", pinned\") : (\"\"));\n    if (show_inuse)\n    {\n      inuse_total += mi_debug_show_bitmap(\"  \", \"inuse blocks\", arena->block_count, arena->blocks_inuse, arena->field_count);\n    }\n    if (arena->blocks_committed != 0)\n    {\n      mi_debug_show_bitmap(\"  \", \"committed blocks\", arena->block_count, arena->blocks_committed, arena->field_count);\n    }\n  }\n\n  if (show_inuse)\n  {\n    _mi_message(\"total inuse blocks    : %zu\\n\", inuse_total);\n  }\n}\n\n",
            "calle": [
                "_mi_message",
                "atomic_load_explicit",
                "mi_debug_show_bitmap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "show_inuse",
                        "type": "const bool",
                        "definition": [
                            "const bool show_inuse = 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max_arenas",
                        "type": "size_t",
                        "definition": [
                            "size_t max_arenas = atomic_load_explicit(&mi_arena_count, memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "inuse_total",
                        "type": "size_t",
                        "definition": [
                            "size_t inuse_total = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena = atomic_load_explicit(&mi_arenas[i], memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_arena_count",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "mi_arenas",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arenas_print",
            "header": "void mi_arenas_print(void)",
            "params": [
                "void"
            ],
            "definition": "void mi_arenas_print(void)\n{\n  mi_debug_show_arenas();\n}\n\n",
            "calle": [
                "mi_debug_show_arenas"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_area",
            "header": "void *mi_arena_area(mi_arena_id_t arena_id, size_t *size)",
            "params": [
                "mi_arena_id_t arena_id",
                "size_t *size"
            ],
            "definition": "void *mi_arena_area(mi_arena_id_t arena_id, size_t *size)\n{\n  if (size != 0)\n  {\n    *size = 0;\n  }\n  size_t arena_index = mi_arena_id_index(arena_id);\n  if (arena_index >= 132)\n  {\n    return 0;\n  }\n  mi_arena_t *arena = atomic_load_explicit(&mi_arenas[arena_index], memory_order_acquire);\n  if (arena == 0)\n  {\n    return 0;\n  }\n  if (size != 0)\n  {\n    *size = mi_arena_block_size(arena->block_count);\n  }\n  return arena->start;\n}\n\n",
            "calle": [
                "atomic_load_explicit",
                "mi_arena_block_size",
                "mi_arena_id_index"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "arena_id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t *",
                        "definition": [
                            "size_t *size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_index",
                        "type": "size_t",
                        "definition": [
                            "size_t arena_index = mi_arena_id_index(arena_id)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena = atomic_load_explicit(&mi_arenas[arena_index], memory_order_acquire)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_arenas",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_reserve_huge_os_pages_at_ex",
            "header": "int mi_reserve_huge_os_pages_at_ex(size_t pages, int numa_node, size_t timeout_msecs, bool exclusive, mi_arena_id_t *arena_id)",
            "params": [
                "size_t pages",
                "int numa_node",
                "size_t timeout_msecs",
                "bool exclusive",
                "mi_arena_id_t *arena_id"
            ],
            "definition": "int mi_reserve_huge_os_pages_at_ex(size_t pages, int numa_node, size_t timeout_msecs, bool exclusive, mi_arena_id_t *arena_id)\n{\n  if (arena_id != 0)\n  {\n    *arena_id = -1;\n  }\n  if (pages == 0)\n  {\n    return 0;\n  }\n  if (numa_node < (-1))\n  {\n    numa_node = -1;\n  }\n  if (numa_node >= 0)\n  {\n    numa_node = numa_node % _mi_os_numa_node_count();\n  }\n  size_t hsize = 0;\n  size_t pages_reserved = 0;\n  mi_memid_t memid;\n  void *p = _mi_os_alloc_huge_os_pages(pages, numa_node, timeout_msecs, &pages_reserved, &hsize, &memid);\n  if ((p == 0) || (pages_reserved == 0))\n  {\n    _mi_warning_message(\"failed to reserve %zu GiB huge pages\\n\", pages);\n    return 12;\n  }\n  _mi_verbose_message(\"numa node %i: reserved %zu GiB huge pages (of the %zu GiB requested)\\n\", numa_node, pages_reserved, pages);\n  if (!mi_manage_os_memory_ex2(p, hsize, 1, numa_node, exclusive, memid, arena_id))\n  {\n    _mi_os_free(p, hsize, memid);\n    return 12;\n  }\n  return 0;\n}\n\n",
            "calle": [
                "_mi_os_alloc_huge_os_pages",
                "_mi_os_free",
                "_mi_os_numa_node_count",
                "_mi_verbose_message",
                "_mi_warning_message",
                "mi_manage_os_memory_ex2"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "pages",
                        "type": "size_t",
                        "definition": [
                            "size_t pages"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numa_node",
                        "type": "int",
                        "definition": [
                            "int numa_node"
                        ]
                    },
                    {
                        "path": null,
                        "name": "timeout_msecs",
                        "type": "size_t",
                        "definition": [
                            "size_t timeout_msecs"
                        ]
                    },
                    {
                        "path": null,
                        "name": "exclusive",
                        "type": "bool",
                        "definition": [
                            "bool exclusive"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_id",
                        "type": "mi_arena_id_t *",
                        "definition": [
                            "mi_arena_id_t *arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "hsize",
                        "type": "size_t",
                        "definition": [
                            "size_t hsize = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pages_reserved",
                        "type": "size_t",
                        "definition": [
                            "size_t pages_reserved = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = _mi_os_alloc_huge_os_pages(pages, numa_node, timeout_msecs, &pages_reserved, &hsize, &memid)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_reserve_os_memory_ex",
            "header": "int mi_reserve_os_memory_ex(size_t size, bool commit, bool allow_large, bool exclusive, mi_arena_id_t *arena_id)",
            "params": [
                "size_t size",
                "bool commit",
                "bool allow_large",
                "bool exclusive",
                "mi_arena_id_t *arena_id"
            ],
            "definition": "int mi_reserve_os_memory_ex(size_t size, bool commit, bool allow_large, bool exclusive, mi_arena_id_t *arena_id)\n{\n  if (arena_id != 0)\n  {\n    *arena_id = _mi_arena_id_none();\n  }\n  size = _mi_align_up(size, 1UL << (9 + (13 + 3)));\n  mi_memid_t memid;\n  void *start = _mi_os_alloc_aligned(size, 1UL << (9 + (13 + 3)), commit, allow_large, &memid);\n  if (start == 0)\n  {\n    return 12;\n  }\n  const bool is_large = memid.is_pinned;\n  if (!mi_manage_os_memory_ex2(start, size, is_large, -1, exclusive, memid, arena_id))\n  {\n    _mi_os_free_ex(start, size, commit, memid);\n    _mi_verbose_message(\"failed to reserve %zu KiB memory\\n\", _mi_divide_up(size, 1024));\n    return 12;\n  }\n  _mi_verbose_message(\"reserved %zu KiB memory%s\\n\", _mi_divide_up(size, 1024), (is_large) ? (\" (in large os pages)\") : (\"\"));\n  return 0;\n}\n\n",
            "calle": [
                "_mi_align_up",
                "_mi_arena_id_none",
                "_mi_divide_up",
                "_mi_os_alloc_aligned",
                "_mi_os_free_ex",
                "_mi_verbose_message",
                "mi_manage_os_memory_ex2"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit",
                        "type": "bool",
                        "definition": [
                            "bool commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_large",
                        "type": "bool",
                        "definition": [
                            "bool allow_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "exclusive",
                        "type": "bool",
                        "definition": [
                            "bool exclusive"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_id",
                        "type": "mi_arena_id_t *",
                        "definition": [
                            "mi_arena_id_t *arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "void *",
                        "definition": [
                            "void *start = _mi_os_alloc_aligned(size, 1UL << (9 + (13 + 3)), commit, allow_large, &memid)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_large",
                        "type": "const bool",
                        "definition": [
                            "const bool is_large = memid.is_pinned"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_manage_os_memory_ex",
            "header": "bool mi_manage_os_memory_ex(void *start, size_t size, bool is_committed, bool is_large, bool is_zero, int numa_node, bool exclusive, mi_arena_id_t *arena_id)",
            "params": [
                "void *start",
                "size_t size",
                "bool is_committed",
                "bool is_large",
                "bool is_zero",
                "int numa_node",
                "bool exclusive",
                "mi_arena_id_t *arena_id"
            ],
            "definition": "bool mi_manage_os_memory_ex(void *start, size_t size, bool is_committed, bool is_large, bool is_zero, int numa_node, bool exclusive, mi_arena_id_t *arena_id)\n{\n  mi_memid_t memid = _mi_memid_create(MI_MEM_EXTERNAL);\n  memid.initially_committed = is_committed;\n  memid.initially_zero = is_zero;\n  memid.is_pinned = is_large;\n  return mi_manage_os_memory_ex2(start, size, is_large, numa_node, exclusive, memid, arena_id);\n}\n\n",
            "calle": [
                "_mi_memid_create",
                "mi_manage_os_memory_ex2"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "start",
                        "type": "void *",
                        "definition": [
                            "void *start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_committed",
                        "type": "bool",
                        "definition": [
                            "bool is_committed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_large",
                        "type": "bool",
                        "definition": [
                            "bool is_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_zero",
                        "type": "bool",
                        "definition": [
                            "bool is_zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numa_node",
                        "type": "int",
                        "definition": [
                            "int numa_node"
                        ]
                    },
                    {
                        "path": null,
                        "name": "exclusive",
                        "type": "bool",
                        "definition": [
                            "bool exclusive"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_id",
                        "type": "mi_arena_id_t *",
                        "definition": [
                            "mi_arena_id_t *arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid = _mi_memid_create(MI_MEM_EXTERNAL)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_abandoned_visit_blocks",
            "header": "bool mi_abandoned_visit_blocks(mi_subproc_id_t subproc_id, int heap_tag, bool visit_blocks, mi_block_visit_fun *visitor, void *arg)",
            "params": [
                "mi_subproc_id_t subproc_id",
                "int heap_tag",
                "bool visit_blocks",
                "mi_block_visit_fun *visitor",
                "void *arg"
            ],
            "definition": "bool mi_abandoned_visit_blocks(mi_subproc_id_t subproc_id, int heap_tag, bool visit_blocks, mi_block_visit_fun *visitor, void *arg)\n{\n  if (!mi_option_is_enabled(mi_option_visit_abandoned))\n  {\n    _mi_error_message(14, \"internal error: can only visit abandoned blocks when MIMALLOC_VISIT_ABANDONED=ON\");\n    return 0;\n  }\n  mi_arena_field_cursor_t current;\n  _mi_arena_field_cursor_init(0, _mi_subproc_from_id(subproc_id), 1, &current);\n  mi_segment_t *segment;\n  unsigned int segment_idx = 0;\n  bool ok = 1;\n  while (ok && ((segment_idx = _mi_arena_segment_clear_abandoned_next(&current)) != 0))\n  {\n    ok = _mi_segment_visit_blocks(segment, heap_tag, visit_blocks, visitor, arg);\n    _mi_arena_segment_mark_abandoned(segment);\n  }\n\n  _mi_arena_field_cursor_done(&current);\n  return ok;\n}\n\n",
            "calle": [
                "_mi_arena_field_cursor_done",
                "_mi_arena_field_cursor_init",
                "_mi_arena_segment_clear_abandoned_next",
                "_mi_arena_segment_mark_abandoned",
                "_mi_error_message",
                "_mi_segment_visit_blocks",
                "_mi_subproc_from_id",
                "mi_option_is_enabled"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "subproc_id",
                        "type": "mi_subproc_id_t",
                        "definition": [
                            "mi_subproc_id_t subproc_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap_tag",
                        "type": "int",
                        "definition": [
                            "int heap_tag"
                        ]
                    },
                    {
                        "path": null,
                        "name": "visit_blocks",
                        "type": "bool",
                        "definition": [
                            "bool visit_blocks"
                        ]
                    },
                    {
                        "path": null,
                        "name": "visitor",
                        "type": "mi_block_visit_fun *",
                        "definition": [
                            "mi_block_visit_fun *visitor"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current",
                        "type": "mi_arena_field_cursor_t",
                        "definition": [
                            "mi_arena_field_cursor_t current"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int segment_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ok",
                        "type": "bool",
                        "definition": [
                            "bool ok = 1"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_reserve_huge_os_pages",
            "header": "int mi_reserve_huge_os_pages(size_t pages, double max_secs, size_t *pages_reserved)",
            "params": [
                "size_t pages",
                "double max_secs",
                "size_t *pages_reserved"
            ],
            "definition": "int mi_reserve_huge_os_pages(size_t pages, double max_secs, size_t *pages_reserved)\n{\n  (void) max_secs;\n  _mi_warning_message(\"mi_reserve_huge_os_pages is deprecated: use mi_reserve_huge_os_pages_interleave/at instead\\n\");\n  if (pages_reserved != 0)\n  {\n    *pages_reserved = 0;\n  }\n  int err = mi_reserve_huge_os_pages_interleave(pages, 0, (size_t) (max_secs * 1000.0));\n  if ((err == 0) && (pages_reserved != 0))\n  {\n    *pages_reserved = pages;\n  }\n  return err;\n}\n\n",
            "calle": [
                "_mi_warning_message",
                "mi_reserve_huge_os_pages_interleave"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "pages",
                        "type": "size_t",
                        "definition": [
                            "size_t pages"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max_secs",
                        "type": "double",
                        "definition": [
                            "double max_secs"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pages_reserved",
                        "type": "size_t *",
                        "definition": [
                            "size_t *pages_reserved"
                        ]
                    },
                    {
                        "path": null,
                        "name": "err",
                        "type": "int",
                        "definition": [
                            "int err = mi_reserve_huge_os_pages_interleave(pages, 0, (size_t) (max_secs * 1000.0))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_arena_id_none",
            "header": "mi_arena_id_t _mi_arena_id_none(void)",
            "params": [
                "void"
            ],
            "definition": "mi_arena_id_t _mi_arena_id_none(void)\n{\n  return 0;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_arena_free",
            "header": "void _mi_arena_free(void *p, size_t size, size_t still_committed_size, mi_memid_t memid)",
            "params": [
                "void *p",
                "size_t size",
                "size_t committed_size",
                "mi_memid_t memid"
            ],
            "definition": "void _mi_arena_free(void *p, size_t size, size_t committed_size, mi_memid_t memid)\n{\n  (size > 0) ? ((void) 0) : (_mi_assert_fail(\"size > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 662, __func__));\n  (committed_size <= size) ? ((void) 0) : (_mi_assert_fail(\"committed_size <= size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 663, __func__));\n  if (p == 0)\n  {\n    return;\n  }\n  if (size == 0)\n  {\n    return;\n  }\n  const bool all_committed = committed_size == size;\n  const size_t decommitted_size = (committed_size <= size) ? (size - committed_size) : (0);\n  ;\n  if (mi_memkind_is_os(memid.memkind))\n  {\n    if ((!all_committed) && (decommitted_size > 0))\n    {\n      _mi_stat_increase(&_mi_stats_main.committed, decommitted_size);\n    }\n    _mi_os_free(p, size, memid);\n  }\n  else\n    if (memid.memkind == MI_MEM_ARENA)\n  {\n    helper__mi_arena_free_1(p, size, committed_size, memid, all_committed);\n  }\n  else\n  {\n    (memid.memkind < MI_MEM_OS) ? ((void) 0) : (_mi_assert_fail(\"memid.memkind < MI_MEM_OS\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 735, __func__));\n  }\n  mi_arenas_try_purge(0, 0);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_os_free",
                "_mi_stat_increase",
                "helper__mi_arena_free_1",
                "mi_arenas_try_purge",
                "mi_memkind_is_os"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "committed_size",
                        "type": "size_t",
                        "definition": [
                            "size_t committed_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "all_committed",
                        "type": "const bool",
                        "definition": [
                            "const bool all_committed = committed_size == size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "decommitted_size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t decommitted_size = (committed_size <= size) ? (size - committed_size) : (0)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_arena_alloc",
            "header": "void *_mi_arena_alloc(size_t size, bool commit, bool allow_large, mi_arena_id_t req_arena_id, mi_memid_t *memid)",
            "params": [
                "size_t size",
                "bool commit",
                "bool allow_large",
                "mi_arena_id_t req_arena_id",
                "mi_memid_t *memid"
            ],
            "definition": "void *_mi_arena_alloc(size_t size, bool commit, bool allow_large, mi_arena_id_t req_arena_id, mi_memid_t *memid)\n{\n  return _mi_arena_alloc_aligned(size, 1UL << (9 + (13 + 3)), 0, commit, allow_large, req_arena_id, memid);\n}\n\n",
            "calle": [
                "_mi_arena_alloc_aligned"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit",
                        "type": "bool",
                        "definition": [
                            "bool commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_large",
                        "type": "bool",
                        "definition": [
                            "bool allow_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "req_arena_id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t req_arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t *",
                        "definition": [
                            "mi_memid_t *memid"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_arena_alloc_aligned",
            "header": "void *_mi_arena_alloc_aligned(size_t size, size_t alignment, size_t align_offset, bool commit, bool allow_large, mi_arena_id_t req_arena_id, mi_memid_t *memid)",
            "params": [
                "size_t size",
                "size_t alignment",
                "size_t align_offset",
                "bool commit",
                "bool allow_large",
                "mi_arena_id_t req_arena_id",
                "mi_memid_t *memid"
            ],
            "definition": "void *_mi_arena_alloc_aligned(size_t size, size_t alignment, size_t align_offset, bool commit, bool allow_large, mi_arena_id_t req_arena_id, mi_memid_t *memid)\n{\n  (memid != 0) ? ((void) 0) : (_mi_assert_fail(\"memid != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 405, __func__));\n  (size > 0) ? ((void) 0) : (_mi_assert_fail(\"size > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 406, __func__));\n  *memid = _mi_memid_none();\n  const int numa_node = _mi_os_numa_node();\n  if (!mi_option_is_enabled(mi_option_disallow_arena_alloc))\n  {\n    if (((size >= ((1UL << (9 + (13 + 3))) / 2)) && (alignment <= (1UL << (9 + (13 + 3))))) && (align_offset == 0))\n    {\n      void *p = mi_arena_try_alloc(numa_node, size, alignment, commit, allow_large, req_arena_id, memid);\n      unsigned int p_idx = 0;\n      if ((&p[p_idx]) != 0)\n      {\n        return p;\n      }\n      if (req_arena_id == _mi_arena_id_none())\n      {\n        mi_arena_id_t arena_id = 0;\n        if (mi_arena_reserve(size, allow_large, &arena_id))\n        {\n          (req_arena_id == _mi_arena_id_none()) ? ((void) 0) : (_mi_assert_fail(\"req_arena_id == _mi_arena_id_none()\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 423, __func__));\n          p_idx = mi_arena_try_alloc_at_id(arena_id, 1, numa_node, size, alignment, commit, allow_large, req_arena_id, memid);\n          if ((&p[p_idx]) != 0)\n          {\n            return p;\n          }\n        }\n      }\n    }\n  }\n  if (mi_option_is_enabled(mi_option_disallow_os_alloc) || (req_arena_id != _mi_arena_id_none()))\n  {\n    errno = 12;\n    return 0;\n  }\n  if (align_offset > 0)\n  {\n    return _mi_os_alloc_aligned_at_offset(size, alignment, align_offset, commit, allow_large, memid);\n  }\n  else\n  {\n    return _mi_os_alloc_aligned(size, alignment, commit, allow_large, memid);\n  }\n}\n\n",
            "calle": [
                "_mi_arena_id_none",
                "_mi_assert_fail",
                "_mi_memid_none",
                "_mi_os_alloc_aligned",
                "_mi_os_alloc_aligned_at_offset",
                "_mi_os_numa_node",
                "mi_arena_reserve",
                "mi_arena_try_alloc",
                "mi_arena_try_alloc_at_id",
                "mi_option_is_enabled"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "align_offset",
                        "type": "size_t",
                        "definition": [
                            "size_t align_offset"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit",
                        "type": "bool",
                        "definition": [
                            "bool commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_large",
                        "type": "bool",
                        "definition": [
                            "bool allow_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "req_arena_id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t req_arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t *",
                        "definition": [
                            "mi_memid_t *memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numa_node",
                        "type": "const int",
                        "definition": [
                            "const int numa_node = _mi_os_numa_node()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = mi_arena_try_alloc(numa_node, size, alignment, commit, allow_large, req_arena_id, memid)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int p_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t arena_id = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_arena_memid_is_suitable",
            "header": "bool _mi_arena_memid_is_suitable(mi_memid_t memid, mi_arena_id_t request_arena_id)",
            "params": [
                "mi_memid_t memid",
                "mi_arena_id_t request_arena_id"
            ],
            "definition": "bool _mi_arena_memid_is_suitable(mi_memid_t memid, mi_arena_id_t request_arena_id)\n{\n  if (memid.memkind == MI_MEM_ARENA)\n  {\n    return mi_arena_id_is_suitable(memid.mem.arena.id, memid.mem.arena.is_exclusive, request_arena_id);\n  }\n  else\n  {\n    return mi_arena_id_is_suitable(_mi_arena_id_none(), 0, request_arena_id);\n  }\n}\n\n",
            "calle": [
                "_mi_arena_id_none",
                "mi_arena_id_is_suitable"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "request_arena_id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t request_arena_id"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_arena_contains",
            "header": "bool _mi_arena_contains(const void *p)",
            "params": [
                "const void *p"
            ],
            "definition": "bool _mi_arena_contains(const void *p)\n{\n  const size_t max_arena = atomic_load_explicit(&mi_arena_count, memory_order_relaxed);\n  for (size_t i = 0; i < max_arena; i += 1)\n  {\n    mi_arena_t *arena = atomic_load_explicit(&mi_arenas[i], memory_order_relaxed);\n    if (((arena != 0) && (arena->start <= ((const uint8_t *) p))) && ((arena->start + mi_arena_block_size(arena->block_count)) > ((const uint8_t *) p)))\n    {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\n",
            "calle": [
                "atomic_load_explicit",
                "mi_arena_block_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max_arena",
                        "type": "const size_t",
                        "definition": [
                            "const size_t max_arena = atomic_load_explicit(&mi_arena_count, memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena = atomic_load_explicit(&mi_arenas[i], memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_arena_count",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "mi_arenas",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_arenas_collect",
            "header": "void _mi_arenas_collect(bool force_purge)",
            "params": [
                "bool force_purge"
            ],
            "definition": "void _mi_arenas_collect(bool force_purge)\n{\n  mi_arenas_try_purge(force_purge, force_purge);\n}\n\n",
            "calle": [
                "mi_arenas_try_purge"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "force_purge",
                        "type": "bool",
                        "definition": [
                            "bool force_purge"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_arena_unsafe_destroy_all",
            "header": "void _mi_arena_unsafe_destroy_all(void)",
            "params": [
                "void"
            ],
            "definition": "void _mi_arena_unsafe_destroy_all(void)\n{\n  mi_arenas_unsafe_destroy();\n  _mi_arenas_collect(1);\n}\n\n",
            "calle": [
                "_mi_arenas_collect",
                "mi_arenas_unsafe_destroy"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_arena_segment_clear_abandoned",
            "header": "bool _mi_arena_segment_clear_abandoned(mi_segment_t *segment)",
            "params": [
                "mi_segment_t *segment"
            ],
            "definition": "bool _mi_arena_segment_clear_abandoned(mi_segment_t *segment)\n{\n  if (__builtin_expect(!(!(segment->memid.memkind != MI_MEM_ARENA)), 0))\n  {\n    return mi_arena_segment_os_clear_abandoned(segment, 1);\n  }\n  size_t arena_idx;\n  size_t bitmap_idx;\n  mi_arena_memid_indices(segment->memid, &arena_idx, &bitmap_idx);\n  mi_arena_t *arena = mi_arena_from_index(arena_idx);\n  (arena != 0) ? ((void) 0) : (_mi_assert_fail(\"arena != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 102, __func__));\n  bool was_marked = _mi_bitmap_unclaim(arena->blocks_abandoned, arena->field_count, 1, bitmap_idx);\n  if (was_marked)\n  {\n    (atomic_load_explicit(&segment->thread_id, memory_order_acquire) == 0) ? ((void) 0) : (_mi_assert_fail(\"mi_atomic_load_acquire(&segment->thread_id) == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 106, __func__));\n    atomic_fetch_sub_explicit(&segment->subproc->abandoned_count, (uintptr_t) 1, memory_order_relaxed);\n    atomic_store_explicit(&segment->thread_id, _mi_thread_id(), memory_order_release);\n  }\n  ((!was_marked) || _mi_bitmap_is_claimed(arena->blocks_inuse, arena->field_count, 1, bitmap_idx)) ? ((void) 0) : (_mi_assert_fail(\"!was_marked || _mi_bitmap_is_claimed(arena->blocks_inuse, arena->field_count, 1, bitmap_idx)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 111, __func__));\n  return was_marked;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_bitmap_is_claimed",
                "_mi_bitmap_unclaim",
                "_mi_thread_id",
                "atomic_fetch_sub_explicit",
                "atomic_load_explicit",
                "atomic_store_explicit",
                "mi_arena_from_index",
                "mi_arena_memid_indices",
                "mi_arena_segment_os_clear_abandoned"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_idx",
                        "type": "size_t",
                        "definition": [
                            "size_t arena_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena = mi_arena_from_index(arena_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "was_marked",
                        "type": "bool",
                        "definition": [
                            "bool was_marked = _mi_bitmap_unclaim(arena->blocks_abandoned, arena->field_count, 1, bitmap_idx)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_arena_segment_mark_abandoned",
            "header": "void _mi_arena_segment_mark_abandoned(mi_segment_t *segment)",
            "params": [
                "mi_segment_t *segment"
            ],
            "definition": "void _mi_arena_segment_mark_abandoned(mi_segment_t *segment)\n{\n  (segment->used == segment->abandoned) ? ((void) 0) : (_mi_assert_fail(\"segment->used == segment->abandoned\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 144, __func__));\n  atomic_store_explicit(&segment->thread_id, (uintptr_t) 0, memory_order_release);\n  if (__builtin_expect(!(!(segment->memid.memkind != MI_MEM_ARENA)), 0))\n  {\n    mi_arena_segment_os_mark_abandoned(segment);\n    return;\n  }\n  size_t arena_idx;\n  size_t bitmap_idx;\n  mi_arena_memid_indices(segment->memid, &arena_idx, &bitmap_idx);\n  mi_arena_t *arena = mi_arena_from_index(arena_idx);\n  (arena != 0) ? ((void) 0) : (_mi_assert_fail(\"arena != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 155, __func__));\n  mi_subproc_t * const subproc = segment->subproc;\n  const bool was_unmarked = _mi_bitmap_claim(arena->blocks_abandoned, arena->field_count, 1, bitmap_idx, 0);\n  if (was_unmarked)\n  {\n    atomic_fetch_add_explicit(&subproc->abandoned_count, (uintptr_t) 1, memory_order_relaxed);\n  }\n  (was_unmarked) ? ((void) 0) : (_mi_assert_fail(\"was_unmarked\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 160, __func__));\n  (_mi_bitmap_is_claimed(arena->blocks_inuse, arena->field_count, 1, bitmap_idx)) ? ((void) 0) : (_mi_assert_fail(\"_mi_bitmap_is_claimed(arena->blocks_inuse, arena->field_count, 1, bitmap_idx)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 161, __func__));\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_bitmap_claim",
                "_mi_bitmap_is_claimed",
                "atomic_fetch_add_explicit",
                "atomic_store_explicit",
                "mi_arena_from_index",
                "mi_arena_memid_indices",
                "mi_arena_segment_os_mark_abandoned"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_idx",
                        "type": "size_t",
                        "definition": [
                            "size_t arena_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena = mi_arena_from_index(arena_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "subproc",
                        "type": "mi_subproc_t * const",
                        "definition": [
                            "mi_subproc_t * const subproc = segment->subproc"
                        ]
                    },
                    {
                        "path": null,
                        "name": "was_unmarked",
                        "type": "const bool",
                        "definition": [
                            "const bool was_unmarked = _mi_bitmap_claim(arena->blocks_abandoned, arena->field_count, 1, bitmap_idx, 0)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_arena_meta_zalloc",
            "header": "void *_mi_arena_meta_zalloc(size_t size, mi_memid_t *memid)",
            "params": [
                "size_t size",
                "mi_memid_t *memid"
            ],
            "definition": "void *_mi_arena_meta_zalloc(size_t size, mi_memid_t *memid)\n{\n  *memid = _mi_memid_none();\n  void *p = mi_arena_static_zalloc(size, 16, memid);\n  unsigned int p_idx = 0;\n  if ((&p[p_idx]) != 0)\n  {\n    return p;\n  }\n  p_idx = _mi_os_zalloc(size, memid);\n  if ((&p[p_idx]) == 0)\n  {\n    return 0;\n  }\n  return p;\n}\n\n",
            "calle": [
                "_mi_memid_none",
                "_mi_os_zalloc",
                "mi_arena_static_zalloc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t *",
                        "definition": [
                            "mi_memid_t *memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = mi_arena_static_zalloc(size, 16, memid)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int p_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_arena_meta_free",
            "header": "void _mi_arena_meta_free(void *p, mi_memid_t memid, size_t size)",
            "params": [
                "void *p",
                "mi_memid_t memid",
                "size_t size"
            ],
            "definition": "void _mi_arena_meta_free(void *p, mi_memid_t memid, size_t size)\n{\n  if (mi_memkind_is_os(memid.memkind))\n  {\n    _mi_os_free(p, size, memid);\n  }\n  else\n  {\n    (memid.memkind == MI_MEM_STATIC) ? ((void) 0) : (_mi_assert_fail(\"memid.memkind == MI_MEM_STATIC\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 206, __func__));\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_os_free",
                "mi_memkind_is_os"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_arena_field_cursor_init",
            "header": "void _mi_arena_field_cursor_init(mi_heap_t *heap, mi_subproc_t *subproc, bool visit_all, mi_arena_field_cursor_t *current)",
            "params": [
                "mi_heap_t *heap",
                "mi_subproc_t *subproc",
                "bool visit_all",
                "mi_arena_field_cursor_t *current"
            ],
            "definition": "void _mi_arena_field_cursor_init(mi_heap_t *heap, mi_subproc_t *subproc, bool visit_all, mi_arena_field_cursor_t *current)\n{\n  ((heap == 0) || (heap->tld->segments.subproc == subproc)) ? ((void) 0) : (_mi_assert_fail(\"heap == NULL || heap->tld->segments.subproc == subproc\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 172, __func__));\n  current->bitmap_idx = 0;\n  current->subproc = subproc;\n  current->visit_all = visit_all;\n  current->hold_visit_lock = 0;\n  const size_t abandoned_count = atomic_load_explicit(&subproc->abandoned_count, memory_order_relaxed);\n  const size_t abandoned_list_count = atomic_load_explicit(&subproc->abandoned_os_list_count, memory_order_relaxed);\n  const size_t max_arena = mi_arena_get_count();\n  if ((heap != 0) && (heap->arena_id != _mi_arena_id_none()))\n  {\n    current->start = mi_arena_id_index(heap->arena_id);\n    current->end = current->start + 1;\n    current->os_list_count = 0;\n  }\n  else\n  {\n    if ((abandoned_count > abandoned_list_count) && (max_arena > 0))\n    {\n      current->start = ((heap == 0) || (max_arena == 0)) ? (0) : ((mi_arena_id_t) (_mi_heap_random_next(heap) % max_arena));\n      current->end = current->start + max_arena;\n    }\n    else\n    {\n      current->start = 0;\n      current->end = 0;\n    }\n    current->os_list_count = abandoned_list_count;\n  }\n  (current->start <= max_arena) ? ((void) 0) : (_mi_assert_fail(\"current->start <= max_arena\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 198, __func__));\n}\n\n",
            "calle": [
                "_mi_arena_id_none",
                "_mi_assert_fail",
                "_mi_heap_random_next",
                "atomic_load_explicit",
                "mi_arena_get_count",
                "mi_arena_id_index"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "subproc",
                        "type": "mi_subproc_t *",
                        "definition": [
                            "mi_subproc_t *subproc"
                        ]
                    },
                    {
                        "path": null,
                        "name": "visit_all",
                        "type": "bool",
                        "definition": [
                            "bool visit_all"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current",
                        "type": "mi_arena_field_cursor_t *",
                        "definition": [
                            "mi_arena_field_cursor_t *current"
                        ]
                    },
                    {
                        "path": null,
                        "name": "abandoned_count",
                        "type": "const size_t",
                        "definition": [
                            "const size_t abandoned_count = atomic_load_explicit(&subproc->abandoned_count, memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "abandoned_list_count",
                        "type": "const size_t",
                        "definition": [
                            "const size_t abandoned_list_count = atomic_load_explicit(&subproc->abandoned_os_list_count, memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max_arena",
                        "type": "const size_t",
                        "definition": [
                            "const size_t max_arena = mi_arena_get_count()"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_arena_segment_clear_abandoned_next",
            "header": "mi_segment_t *_mi_arena_segment_clear_abandoned_next(mi_arena_field_cursor_t *previous)",
            "params": [
                "mi_arena_field_cursor_t *previous"
            ],
            "definition": "mi_segment_t *_mi_arena_segment_clear_abandoned_next(mi_arena_field_cursor_t *previous)\n{\n  if (previous->start < previous->end)\n  {\n    mi_segment_t *segment = mi_arena_segment_clear_abandoned_next_field(previous);\n    if (segment != 0)\n    {\n      return segment;\n    }\n  }\n  (previous->start == previous->end) ? ((void) 0) : (_mi_assert_fail(\"previous->start == previous->end\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 323, __func__));\n  return mi_arena_segment_clear_abandoned_next_list(previous);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_arena_segment_clear_abandoned_next_field",
                "mi_arena_segment_clear_abandoned_next_list"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "previous",
                        "type": "mi_arena_field_cursor_t *",
                        "definition": [
                            "mi_arena_field_cursor_t *previous"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = mi_arena_segment_clear_abandoned_next_field(previous)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_arena_field_cursor_done",
            "header": "void _mi_arena_field_cursor_done(mi_arena_field_cursor_t *current)",
            "params": [
                "mi_arena_field_cursor_t *current"
            ],
            "definition": "void _mi_arena_field_cursor_done(mi_arena_field_cursor_t *current)\n{\n  if (current->hold_visit_lock)\n  {\n    mi_lock_release(&current->subproc->abandoned_os_visit_lock);\n    current->hold_visit_lock = 0;\n  }\n}\n\n",
            "calle": [
                "mi_lock_release"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "current",
                        "type": "mi_arena_field_cursor_t *",
                        "definition": [
                            "mi_arena_field_cursor_t *current"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_bitmap_index_create_ex",
            "header": "",
            "params": [
                "size_t idx",
                "size_t bitidx"
            ],
            "definition": "inline static mi_bitmap_index_t mi_bitmap_index_create_ex(size_t idx, size_t bitidx)\n{\n  (bitidx <= (8 * (1 << 3))) ? ((void) 0) : (_mi_assert_fail(\"bitidx <= MI_BITMAP_FIELD_BITS\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.h\", 39, __func__));\n  return (idx * (8 * (1 << 3))) + bitidx;\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t",
                        "definition": [
                            "size_t idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitidx"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_bitmap_index_create",
            "header": "",
            "params": [
                "size_t idx",
                "size_t bitidx"
            ],
            "definition": "inline static mi_bitmap_index_t mi_bitmap_index_create(size_t idx, size_t bitidx)\n{\n  (bitidx < (8 * (1 << 3))) ? ((void) 0) : (_mi_assert_fail(\"bitidx < MI_BITMAP_FIELD_BITS\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.h\", 43, __func__));\n  return mi_bitmap_index_create_ex(idx, bitidx);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_bitmap_index_create_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t",
                        "definition": [
                            "size_t idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitidx"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_bitmap_index_create_from_bit",
            "header": "",
            "params": [
                "size_t full_bitidx"
            ],
            "definition": "inline static mi_bitmap_index_t mi_bitmap_index_create_from_bit(size_t full_bitidx)\n{\n  return mi_bitmap_index_create(full_bitidx / (8 * (1 << 3)), full_bitidx % (8 * (1 << 3)));\n}\n\n",
            "calle": [
                "mi_bitmap_index_create"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "full_bitidx",
                        "type": "size_t",
                        "definition": [
                            "size_t full_bitidx"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_bitmap_index_field",
            "header": "",
            "params": [
                "mi_bitmap_index_t bitmap_idx"
            ],
            "definition": "inline static size_t mi_bitmap_index_field(mi_bitmap_index_t bitmap_idx)\n{\n  return bitmap_idx / (8 * (1 << 3));\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_idx"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_bitmap_index_bit_in_field",
            "header": "",
            "params": [
                "mi_bitmap_index_t bitmap_idx"
            ],
            "definition": "inline static size_t mi_bitmap_index_bit_in_field(mi_bitmap_index_t bitmap_idx)\n{\n  return bitmap_idx % (8 * (1 << 3));\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_idx"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_bitmap_index_bit",
            "header": "",
            "params": [
                "mi_bitmap_index_t bitmap_idx"
            ],
            "definition": "inline static size_t mi_bitmap_index_bit(mi_bitmap_index_t bitmap_idx)\n{\n  return bitmap_idx;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_idx"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_id_index",
            "header": "size_t mi_arena_id_index(mi_arena_id_t id)",
            "params": [
                "mi_arena_id_t id"
            ],
            "definition": "size_t mi_arena_id_index(mi_arena_id_t id)\n{\n  return (size_t) ((id <= 0) ? (132) : (id - 1));\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t id"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_from_index",
            "header": "mi_arena_t *mi_arena_from_index(size_t idx)",
            "params": [
                "size_t idx"
            ],
            "definition": "mi_arena_t *mi_arena_from_index(size_t idx)\n{\n  (idx < mi_arena_get_count()) ? ((void) 0) : (_mi_assert_fail(\"idx < mi_arena_get_count()\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 111, __func__));\n  return atomic_load_explicit(&mi_arenas[idx], memory_order_acquire);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "atomic_load_explicit",
                "mi_arena_get_count"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t",
                        "definition": [
                            "size_t idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_arenas",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_get_count",
            "header": "size_t mi_arena_get_count(void)",
            "params": [
                "void"
            ],
            "definition": "size_t mi_arena_get_count(void)\n{\n  return atomic_load_explicit(&mi_arena_count, memory_order_relaxed);\n}\n\n",
            "calle": [
                "atomic_load_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_arena_count",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_block_start",
            "header": "void *mi_arena_block_start(mi_arena_t *arena, mi_bitmap_index_t bindex)",
            "params": [
                "mi_arena_t *arena",
                "mi_bitmap_index_t bindex"
            ],
            "definition": "void *mi_arena_block_start(mi_arena_t *arena, mi_bitmap_index_t bindex)\n{\n  return arena->start + mi_arena_block_size(mi_bitmap_index_bit(bindex));\n}\n\n",
            "calle": [
                "mi_arena_block_size",
                "mi_bitmap_index_bit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bindex",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bindex"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_memid_indices",
            "header": "bool mi_arena_memid_indices(mi_memid_t memid, size_t *arena_index, mi_bitmap_index_t *bitmap_index)",
            "params": [
                "mi_memid_t memid",
                "size_t *arena_index",
                "mi_bitmap_index_t *bitmap_index"
            ],
            "definition": "bool mi_arena_memid_indices(mi_memid_t memid, size_t *arena_index, mi_bitmap_index_t *bitmap_index)\n{\n  (memid.memkind == MI_MEM_ARENA) ? ((void) 0) : (_mi_assert_fail(\"memid.memkind == MI_MEM_ARENA\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 142, __func__));\n  *arena_index = mi_arena_id_index(memid.mem.arena.id);\n  *bitmap_index = memid.mem.arena.block_index;\n  return memid.mem.arena.is_exclusive;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_arena_id_index"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_index",
                        "type": "size_t *",
                        "definition": [
                            "size_t *arena_index"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_index",
                        "type": "mi_bitmap_index_t *",
                        "definition": [
                            "mi_bitmap_index_t *bitmap_index"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_segment_os_clear_abandoned",
            "header": "",
            "params": [
                "mi_segment_t *segment",
                "bool take_lock"
            ],
            "definition": "static bool mi_arena_segment_os_clear_abandoned(mi_segment_t *segment, bool take_lock)\n{\n  (segment->memid.memkind != MI_MEM_ARENA) ? ((void) 0) : (_mi_assert_fail(\"segment->memid.memkind != MI_MEM_ARENA\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 51, __func__));\n  mi_subproc_t * const subproc = segment->subproc;\n  if (take_lock && (!mi_lock_try_acquire(&subproc->abandoned_os_lock)))\n  {\n    return 0;\n  }\n  bool reclaimed = 0;\n  mi_segment_t * const next = segment->abandoned_os_next;\n  mi_segment_t * const prev = segment->abandoned_os_prev;\n  if (((next != 0) || (prev != 0)) || (subproc->abandoned_os_list == segment))\n  {\n    if (prev != 0)\n    {\n      prev->abandoned_os_next = next;\n    }\n    else\n    {\n      subproc->abandoned_os_list = next;\n    }\n    if (next != 0)\n    {\n      next->abandoned_os_prev = prev;\n    }\n    else\n    {\n      subproc->abandoned_os_list_tail = prev;\n    }\n    segment->abandoned_os_next = 0;\n    segment->abandoned_os_prev = 0;\n    atomic_fetch_sub_explicit(&subproc->abandoned_count, (uintptr_t) 1, memory_order_relaxed);\n    atomic_fetch_sub_explicit(&subproc->abandoned_os_list_count, (uintptr_t) 1, memory_order_relaxed);\n    if (take_lock)\n    {\n      atomic_store_explicit(&segment->thread_id, _mi_thread_id(), memory_order_release);\n    }\n    reclaimed = 1;\n  }\n  if (take_lock)\n  {\n    mi_lock_release(&segment->subproc->abandoned_os_lock);\n  }\n  return reclaimed;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_thread_id",
                "atomic_fetch_sub_explicit",
                "atomic_store_explicit",
                "mi_lock_release",
                "mi_lock_try_acquire"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "take_lock",
                        "type": "bool",
                        "definition": [
                            "bool take_lock"
                        ]
                    },
                    {
                        "path": null,
                        "name": "subproc",
                        "type": "mi_subproc_t * const",
                        "definition": [
                            "mi_subproc_t * const subproc = segment->subproc"
                        ]
                    },
                    {
                        "path": null,
                        "name": "reclaimed",
                        "type": "bool",
                        "definition": [
                            "bool reclaimed = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next",
                        "type": "mi_segment_t * const",
                        "definition": [
                            "mi_segment_t * const next = segment->abandoned_os_next"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prev",
                        "type": "mi_segment_t * const",
                        "definition": [
                            "mi_segment_t * const prev = segment->abandoned_os_prev"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_segment_os_mark_abandoned",
            "header": "",
            "params": [
                "mi_segment_t *segment"
            ],
            "definition": "static void mi_arena_segment_os_mark_abandoned(mi_segment_t *segment)\n{\n  (segment->memid.memkind != MI_MEM_ARENA) ? ((void) 0) : (_mi_assert_fail(\"segment->memid.memkind != MI_MEM_ARENA\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 119, __func__));\n  mi_subproc_t * const subproc = segment->subproc;\n  for (bool _go = (mi_lock_acquire(&subproc->abandoned_os_lock), 1); _go; mi_lock_release(&subproc->abandoned_os_lock), _go = 0)\n  {\n    mi_segment_t *prev = subproc->abandoned_os_list_tail;\n    ((prev == 0) || (prev->abandoned_os_next == 0)) ? ((void) 0) : (_mi_assert_fail(\"prev == NULL || prev->abandoned_os_next == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 125, __func__));\n    (segment->abandoned_os_prev == 0) ? ((void) 0) : (_mi_assert_fail(\"segment->abandoned_os_prev == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 126, __func__));\n    (segment->abandoned_os_next == 0) ? ((void) 0) : (_mi_assert_fail(\"segment->abandoned_os_next == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 127, __func__));\n    if (prev != 0)\n    {\n      prev->abandoned_os_next = segment;\n    }\n    else\n    {\n      subproc->abandoned_os_list = segment;\n    }\n    subproc->abandoned_os_list_tail = segment;\n    segment->abandoned_os_prev = prev;\n    segment->abandoned_os_next = 0;\n    atomic_fetch_add_explicit(&subproc->abandoned_os_list_count, (uintptr_t) 1, memory_order_relaxed);\n    atomic_fetch_add_explicit(&subproc->abandoned_count, (uintptr_t) 1, memory_order_relaxed);\n  }\n\n  return;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "atomic_fetch_add_explicit",
                "mi_lock_acquire",
                "mi_lock_release"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "subproc",
                        "type": "mi_subproc_t * const",
                        "definition": [
                            "mi_subproc_t * const subproc = segment->subproc"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_go",
                        "type": "bool",
                        "definition": [
                            "bool _go = (mi_lock_acquire(&subproc->abandoned_os_lock), 1)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prev",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *prev = subproc->abandoned_os_list_tail"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_segment_clear_abandoned_at",
            "header": "",
            "params": [
                "mi_arena_t *arena",
                "mi_subproc_t *subproc",
                "mi_bitmap_index_t bitmap_idx"
            ],
            "definition": "static mi_segment_t *mi_arena_segment_clear_abandoned_at(mi_arena_t *arena, mi_subproc_t *subproc, mi_bitmap_index_t bitmap_idx)\n{\n  if (!_mi_bitmap_unclaim(arena->blocks_abandoned, arena->field_count, 1, bitmap_idx))\n  {\n    return 0;\n  }\n  (_mi_bitmap_is_claimed(arena->blocks_inuse, arena->field_count, 1, bitmap_idx)) ? ((void) 0) : (_mi_assert_fail(\"_mi_bitmap_is_claimed(arena->blocks_inuse, arena->field_count, 1, bitmap_idx)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 211, __func__));\n  mi_segment_t *segment = (mi_segment_t *) mi_arena_block_start(arena, bitmap_idx);\n  (atomic_load_explicit(&segment->thread_id, memory_order_relaxed) == 0) ? ((void) 0) : (_mi_assert_fail(\"mi_atomic_load_relaxed(&segment->thread_id) == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 213, __func__));\n  if (segment->subproc != subproc)\n  {\n    const bool was_zero = _mi_bitmap_claim(arena->blocks_abandoned, arena->field_count, 1, bitmap_idx, 0);\n    (was_zero) ? ((void) 0) : (_mi_assert_fail(\"was_zero\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 221, __func__));\n    (void) was_zero;\n    return 0;\n  }\n  else\n  {\n    atomic_fetch_sub_explicit(&subproc->abandoned_count, (uintptr_t) 1, memory_order_relaxed);\n    return segment;\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_bitmap_claim",
                "_mi_bitmap_is_claimed",
                "_mi_bitmap_unclaim",
                "atomic_fetch_sub_explicit",
                "atomic_load_explicit",
                "mi_arena_block_start"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena"
                        ]
                    },
                    {
                        "path": null,
                        "name": "subproc",
                        "type": "mi_subproc_t *",
                        "definition": [
                            "mi_subproc_t *subproc"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = (mi_segment_t *) mi_arena_block_start(arena, bitmap_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "was_zero",
                        "type": "const bool",
                        "definition": [
                            "const bool was_zero = _mi_bitmap_claim(arena->blocks_abandoned, arena->field_count, 1, bitmap_idx, 0)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_segment_clear_abandoned_next_field",
            "header": "",
            "params": [
                "mi_arena_field_cursor_t *previous"
            ],
            "definition": "static mi_segment_t *mi_arena_segment_clear_abandoned_next_field(mi_arena_field_cursor_t *previous)\n{\n  const size_t max_arena = mi_arena_get_count();\n  size_t field_idx = mi_bitmap_index_field(previous->bitmap_idx);\n  size_t bit_idx = mi_bitmap_index_bit_in_field(previous->bitmap_idx);\n  for (; previous->start < previous->end; previous->start += 1, field_idx = 0, bit_idx = 0)\n  {\n    helper_mi_arena_segment_clear_abandoned_next_field_1(&field_idx, &bit_idx, previous, max_arena);\n  }\n\n  return 0;\n}\n\n",
            "calle": [
                "helper_mi_arena_segment_clear_abandoned_next_field_1",
                "mi_arena_get_count",
                "mi_bitmap_index_bit_in_field",
                "mi_bitmap_index_field"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "previous",
                        "type": "mi_arena_field_cursor_t *",
                        "definition": [
                            "mi_arena_field_cursor_t *previous"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max_arena",
                        "type": "const size_t",
                        "definition": [
                            "const size_t max_arena = mi_arena_get_count()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "field_idx",
                        "type": "size_t",
                        "definition": [
                            "size_t field_idx = mi_bitmap_index_field(previous->bitmap_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bit_idx",
                        "type": "size_t",
                        "definition": [
                            "size_t bit_idx = mi_bitmap_index_bit_in_field(previous->bitmap_idx)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_segment_clear_abandoned_next_list",
            "header": "",
            "params": [
                "mi_arena_field_cursor_t *previous"
            ],
            "definition": "static mi_segment_t *mi_arena_segment_clear_abandoned_next_list(mi_arena_field_cursor_t *previous)\n{\n  if (!previous->hold_visit_lock)\n  {\n    previous->hold_visit_lock = (previous->visit_all) ? ((mi_lock_acquire(&previous->subproc->abandoned_os_visit_lock), 1)) : (mi_lock_try_acquire(&previous->subproc->abandoned_os_visit_lock));\n    if (!previous->hold_visit_lock)\n    {\n      if (previous->visit_all)\n      {\n        _mi_error_message(14, \"internal error: failed to visit all abandoned segments due to failure to acquire the OS visitor lock\");\n      }\n      return 0;\n    }\n  }\n  while (previous->os_list_count > 0)\n  {\n    previous->os_list_count -= 1;\n    mi_lock_acquire(&previous->subproc->abandoned_os_lock);\n    mi_segment_t *segment = previous->subproc->abandoned_os_list;\n    if ((segment == 0) || mi_arena_segment_os_clear_abandoned(segment, 0))\n    {\n      mi_lock_release(&previous->subproc->abandoned_os_lock);\n      return segment;\n    }\n    mi_lock_release(&previous->subproc->abandoned_os_lock);\n  }\n\n  (previous->os_list_count == 0) ? ((void) 0) : (_mi_assert_fail(\"previous->os_list_count == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 309, __func__));\n  return 0;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_error_message",
                "mi_arena_segment_os_clear_abandoned",
                "mi_lock_acquire",
                "mi_lock_release",
                "mi_lock_try_acquire"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "previous",
                        "type": "mi_arena_field_cursor_t *",
                        "definition": [
                            "mi_arena_field_cursor_t *previous"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = previous->subproc->abandoned_os_list"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_id_create",
            "header": "",
            "params": [
                "size_t arena_index"
            ],
            "definition": "static mi_arena_id_t mi_arena_id_create(size_t arena_index)\n{\n  (arena_index < 132) ? ((void) 0) : (_mi_assert_fail(\"arena_index < MI_MAX_ARENAS\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 80, __func__));\n  return ((int) arena_index) + 1;\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "arena_index",
                        "type": "size_t",
                        "definition": [
                            "size_t arena_index"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_id_is_suitable",
            "header": "",
            "params": [
                "mi_arena_id_t arena_id",
                "bool arena_is_exclusive",
                "mi_arena_id_t req_arena_id"
            ],
            "definition": "static bool mi_arena_id_is_suitable(mi_arena_id_t arena_id, bool arena_is_exclusive, mi_arena_id_t req_arena_id)\n{\n  return ((!arena_is_exclusive) && (req_arena_id == _mi_arena_id_none())) || (arena_id == req_arena_id);\n}\n\n",
            "calle": [
                "_mi_arena_id_none"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "arena_id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_is_exclusive",
                        "type": "bool",
                        "definition": [
                            "bool arena_is_exclusive"
                        ]
                    },
                    {
                        "path": null,
                        "name": "req_arena_id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t req_arena_id"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_arena_memid_is_os_allocated",
            "header": "",
            "params": [
                "mi_memid_t memid"
            ],
            "definition": "bool _mi_arena_memid_is_os_allocated(mi_memid_t memid)\n{\n  return memid.memkind == MI_MEM_OS;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_block_count_of_size",
            "header": "",
            "params": [
                "size_t size"
            ],
            "definition": "static size_t mi_block_count_of_size(size_t size)\n{\n  return _mi_divide_up(size, 1UL << (9 + (13 + 3)));\n}\n\n",
            "calle": [
                "_mi_divide_up"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_block_size",
            "header": "",
            "params": [
                "size_t bcount"
            ],
            "definition": "static size_t mi_arena_block_size(size_t bcount)\n{\n  return bcount * (1UL << (9 + (13 + 3)));\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bcount",
                        "type": "size_t",
                        "definition": [
                            "size_t bcount"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_size",
            "header": "",
            "params": [
                "mi_arena_t *arena"
            ],
            "definition": "static size_t mi_arena_size(mi_arena_t *arena)\n{\n  return mi_arena_block_size(arena->block_count);\n}\n\n",
            "calle": [
                "mi_arena_block_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_memid_create_arena",
            "header": "",
            "params": [
                "mi_arena_id_t id",
                "bool is_exclusive",
                "mi_bitmap_index_t bitmap_index"
            ],
            "definition": "static mi_memid_t mi_memid_create_arena(mi_arena_id_t id, bool is_exclusive, mi_bitmap_index_t bitmap_index)\n{\n  mi_memid_t memid = _mi_memid_create(MI_MEM_ARENA);\n  memid.mem.arena.id = id;\n  memid.mem.arena.block_index = bitmap_index;\n  memid.mem.arena.is_exclusive = is_exclusive;\n  return memid;\n}\n\n",
            "calle": [
                "_mi_memid_create"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_exclusive",
                        "type": "bool",
                        "definition": [
                            "bool is_exclusive"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_index",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_index"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid = _mi_memid_create(MI_MEM_ARENA)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_static_zalloc",
            "header": "",
            "params": [
                "size_t size",
                "size_t alignment",
                "mi_memid_t *memid"
            ],
            "definition": "static void *mi_arena_static_zalloc(size_t size, size_t alignment, mi_memid_t *memid)\n{\n  *memid = _mi_memid_none();\n  if ((size == 0) || (size > (((1 << 3) / 2) * 1024UL)))\n  {\n    return 0;\n  }\n  const size_t toplow = atomic_load_explicit(&mi_arena_static_top, memory_order_relaxed);\n  if ((toplow + size) > (((1 << 3) / 2) * 1024UL))\n  {\n    return 0;\n  }\n  if (alignment < 16)\n  {\n    alignment = 16;\n  }\n  const size_t oversize = (size + alignment) - 1;\n  if ((toplow + oversize) > (((1 << 3) / 2) * 1024UL))\n  {\n    return 0;\n  }\n  const size_t oldtop = atomic_fetch_add_explicit(&mi_arena_static_top, oversize, memory_order_acq_rel);\n  size_t top = oldtop + oversize;\n  if (top > (((1 << 3) / 2) * 1024UL))\n  {\n    atomic_compare_exchange_strong_explicit(&mi_arena_static_top, &top, oldtop, memory_order_acq_rel, memory_order_acquire);\n    return 0;\n  }\n  *memid = _mi_memid_create(MI_MEM_STATIC);\n  memid->initially_zero = 1;\n  const size_t start = _mi_align_up(oldtop, alignment);\n  uint8_t * const p = &mi_arena_static[start];\n  _mi_memzero_aligned(p, size);\n  return p;\n}\n\n",
            "calle": [
                "_mi_align_up",
                "_mi_memid_create",
                "_mi_memid_none",
                "_mi_memzero_aligned",
                "atomic_compare_exchange_strong_explicit",
                "atomic_fetch_add_explicit",
                "atomic_load_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t *",
                        "definition": [
                            "mi_memid_t *memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "toplow",
                        "type": "const size_t",
                        "definition": [
                            "const size_t toplow = atomic_load_explicit(&mi_arena_static_top, memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "oversize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t oversize = (size + alignment) - 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "oldtop",
                        "type": "const size_t",
                        "definition": [
                            "const size_t oldtop = atomic_fetch_add_explicit(&mi_arena_static_top, oversize, memory_order_acq_rel)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "top",
                        "type": "size_t",
                        "definition": [
                            "size_t top = oldtop + oversize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "const size_t",
                        "definition": [
                            "const size_t start = _mi_align_up(oldtop, alignment)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "uint8_t * const",
                        "definition": [
                            "uint8_t * const p = &mi_arena_static[start]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_arena_static_top",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "mi_arena_static",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_try_claim",
            "header": "",
            "params": [
                "mi_arena_t *arena",
                "size_t blocks",
                "mi_bitmap_index_t *bitmap_idx"
            ],
            "definition": "static bool mi_arena_try_claim(mi_arena_t *arena, size_t blocks, mi_bitmap_index_t *bitmap_idx)\n{\n  size_t idx = 0;\n  if (_mi_bitmap_try_find_from_claim_across(arena->blocks_inuse, arena->field_count, idx, blocks, bitmap_idx))\n  {\n    atomic_store_explicit(&arena->search_idx, mi_bitmap_index_field(*bitmap_idx), memory_order_relaxed);\n    return 1;\n  }\n  ;\n  return 0;\n}\n\n",
            "calle": [
                "_mi_bitmap_try_find_from_claim_across",
                "atomic_store_explicit",
                "mi_bitmap_index_field"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena"
                        ]
                    },
                    {
                        "path": null,
                        "name": "blocks",
                        "type": "size_t",
                        "definition": [
                            "size_t blocks"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t *",
                        "definition": [
                            "mi_bitmap_index_t *bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t",
                        "definition": [
                            "size_t idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_try_alloc_at",
            "header": "",
            "params": [
                "mi_arena_t *arena",
                "size_t arena_index",
                "size_t needed_bcount",
                "bool commit",
                "mi_memid_t *memid"
            ],
            "definition": "static void *mi_arena_try_alloc_at(mi_arena_t *arena, size_t arena_index, size_t needed_bcount, bool commit, mi_memid_t *memid)\n{\n  (void) arena_index;\n  (mi_arena_id_index(arena->id) == arena_index) ? ((void) 0) : (_mi_assert_fail(\"mi_arena_id_index(arena->id) == arena_index\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 239, __func__));\n  mi_bitmap_index_t bitmap_index;\n  if (!mi_arena_try_claim(arena, needed_bcount, &bitmap_index))\n  {\n    return 0;\n  }\n  void *p = mi_arena_block_start(arena, bitmap_index);\n  *memid = mi_memid_create_arena(arena->id, arena->exclusive, bitmap_index);\n  memid->is_pinned = arena->memid.is_pinned;\n  if (arena->blocks_purge != 0)\n  {\n    _mi_bitmap_unclaim_across(arena->blocks_purge, arena->field_count, needed_bcount, bitmap_index);\n  }\n  if (arena->memid.initially_zero && (arena->blocks_dirty != 0))\n  {\n    memid->initially_zero = _mi_bitmap_claim_across(arena->blocks_dirty, arena->field_count, needed_bcount, bitmap_index, 0, 0);\n  }\n  if (arena->blocks_committed == 0)\n  {\n    memid->initially_committed = 1;\n  }\n  else\n    if (commit)\n  {\n    helper_mi_arena_try_alloc_at_1(arena, needed_bcount, memid, bitmap_index, p);\n  }\n  else\n  {\n    size_t already_committed = 0;\n    memid->initially_committed = _mi_bitmap_is_claimed_across(arena->blocks_committed, arena->field_count, needed_bcount, bitmap_index, &already_committed);\n    if ((!memid->initially_committed) && (already_committed > 0))\n    {\n      (already_committed < needed_bcount) ? ((void) 0) : (_mi_assert_fail(\"already_committed < needed_bcount\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 294, __func__));\n      _mi_stat_decrease(&_mi_stats_main.committed, mi_arena_block_size(already_committed));\n      _mi_bitmap_unclaim_across(arena->blocks_committed, arena->field_count, needed_bcount, bitmap_index);\n    }\n  }\n  return p;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_bitmap_claim_across",
                "_mi_bitmap_is_claimed_across",
                "_mi_bitmap_unclaim_across",
                "_mi_stat_decrease",
                "helper_mi_arena_try_alloc_at_1",
                "mi_arena_block_size",
                "mi_arena_block_start",
                "mi_arena_id_index",
                "mi_arena_try_claim",
                "mi_memid_create_arena"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_index",
                        "type": "size_t",
                        "definition": [
                            "size_t arena_index"
                        ]
                    },
                    {
                        "path": null,
                        "name": "needed_bcount",
                        "type": "size_t",
                        "definition": [
                            "size_t needed_bcount"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit",
                        "type": "bool",
                        "definition": [
                            "bool commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t *",
                        "definition": [
                            "mi_memid_t *memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_index",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_index"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = mi_arena_block_start(arena, bitmap_index)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "already_committed",
                        "type": "size_t",
                        "definition": [
                            "size_t already_committed = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_try_alloc_at_id",
            "header": "",
            "params": [
                "mi_arena_id_t arena_id",
                "bool match_numa_node",
                "int numa_node",
                "size_t size",
                "size_t alignment",
                "bool commit",
                "bool allow_large",
                "mi_arena_id_t req_arena_id",
                "mi_memid_t *memid"
            ],
            "definition": "static void *mi_arena_try_alloc_at_id(mi_arena_id_t arena_id, bool match_numa_node, int numa_node, size_t size, size_t alignment, bool commit, bool allow_large, mi_arena_id_t req_arena_id, mi_memid_t *memid)\n{\n  ;\n  (alignment <= (1UL << (9 + (13 + 3)))) ? ((void) 0) : (_mi_assert_fail(\"alignment <= MI_SEGMENT_ALIGN\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 308, __func__));\n  const size_t bcount = mi_block_count_of_size(size);\n  const size_t arena_index = mi_arena_id_index(arena_id);\n  (arena_index < atomic_load_explicit(&mi_arena_count, memory_order_relaxed)) ? ((void) 0) : (_mi_assert_fail(\"arena_index < mi_atomic_load_relaxed(&mi_arena_count)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 311, __func__));\n  (size <= mi_arena_block_size(bcount)) ? ((void) 0) : (_mi_assert_fail(\"size <= mi_arena_block_size(bcount)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 312, __func__));\n  mi_arena_t *arena = mi_arena_from_index(arena_index);\n  if (arena == 0)\n  {\n    return 0;\n  }\n  if ((!allow_large) && arena->is_large)\n  {\n    return 0;\n  }\n  if (!mi_arena_id_is_suitable(arena->id, arena->exclusive, req_arena_id))\n  {\n    return 0;\n  }\n  if (req_arena_id == _mi_arena_id_none())\n  {\n    const bool numa_suitable = ((numa_node < 0) || (arena->numa_node < 0)) || (arena->numa_node == numa_node);\n    if (match_numa_node)\n    {\n      if (!numa_suitable)\n      {\n        return 0;\n      }\n    }\n    else\n    {\n      if (numa_suitable)\n      {\n        return 0;\n      }\n    }\n  }\n  void *p = mi_arena_try_alloc_at(arena, arena_index, bcount, commit, memid);\n  ((p == 0) || _mi_is_aligned(p, alignment)) ? ((void) 0) : (_mi_assert_fail(\"p == NULL || _mi_is_aligned(p, alignment)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 327, __func__));\n  return p;\n}\n\n",
            "calle": [
                "_mi_arena_id_none",
                "_mi_assert_fail",
                "_mi_is_aligned",
                "atomic_load_explicit",
                "mi_arena_block_size",
                "mi_arena_from_index",
                "mi_arena_id_index",
                "mi_arena_id_is_suitable",
                "mi_arena_try_alloc_at",
                "mi_block_count_of_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "arena_id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "match_numa_node",
                        "type": "bool",
                        "definition": [
                            "bool match_numa_node"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numa_node",
                        "type": "int",
                        "definition": [
                            "int numa_node"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit",
                        "type": "bool",
                        "definition": [
                            "bool commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_large",
                        "type": "bool",
                        "definition": [
                            "bool allow_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "req_arena_id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t req_arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t *",
                        "definition": [
                            "mi_memid_t *memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bcount",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bcount = mi_block_count_of_size(size)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_index",
                        "type": "const size_t",
                        "definition": [
                            "const size_t arena_index = mi_arena_id_index(arena_id)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena = mi_arena_from_index(arena_index)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numa_suitable",
                        "type": "const bool",
                        "definition": [
                            "const bool numa_suitable = ((numa_node < 0) || (arena->numa_node < 0)) || (arena->numa_node == numa_node)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = mi_arena_try_alloc_at(arena, arena_index, bcount, commit, memid)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_arena_count",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_try_alloc",
            "header": "",
            "params": [
                "int numa_node",
                "size_t size",
                "size_t alignment",
                "bool commit",
                "bool allow_large",
                "mi_arena_id_t req_arena_id",
                "mi_memid_t *memid"
            ],
            "definition": "static void *mi_arena_try_alloc(int numa_node, size_t size, size_t alignment, bool commit, bool allow_large, mi_arena_id_t req_arena_id, mi_memid_t *memid)\n{\n  (void) alignment;\n  (alignment <= (1UL << (9 + (13 + 3)))) ? ((void) 0) : (_mi_assert_fail(\"alignment <= MI_SEGMENT_ALIGN\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 338, __func__));\n  const size_t max_arena = atomic_load_explicit(&mi_arena_count, memory_order_relaxed);\n  if (__builtin_expect(!(!(max_arena == 0)), 1))\n  {\n    return 0;\n  }\n  if (req_arena_id != _mi_arena_id_none())\n  {\n    if (mi_arena_id_index(req_arena_id) < max_arena)\n    {\n      void *p = mi_arena_try_alloc_at_id(req_arena_id, 1, numa_node, size, alignment, commit, allow_large, req_arena_id, memid);\n      if (p != 0)\n      {\n        return p;\n      }\n    }\n  }\n  else\n  {\n    for (size_t i = 0; i < max_arena; i += 1)\n    {\n      void *p = mi_arena_try_alloc_at_id(mi_arena_id_create(i), 1, numa_node, size, alignment, commit, allow_large, req_arena_id, memid);\n      if (p != 0)\n      {\n        return p;\n      }\n    }\n\n    if (numa_node >= 0)\n    {\n      for (size_t i = 0; i < max_arena; i += 1)\n      {\n        void *p = mi_arena_try_alloc_at_id(mi_arena_id_create(i), 0, numa_node, size, alignment, commit, allow_large, req_arena_id, memid);\n        if (p != 0)\n        {\n          return p;\n        }\n      }\n\n    }\n  }\n  return 0;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_arena_id_none",
                "_mi_assert_fail",
                "atomic_load_explicit",
                "mi_arena_id_create",
                "mi_arena_id_index",
                "mi_arena_try_alloc_at_id"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "numa_node",
                        "type": "int",
                        "definition": [
                            "int numa_node"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit",
                        "type": "bool",
                        "definition": [
                            "bool commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_large",
                        "type": "bool",
                        "definition": [
                            "bool allow_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "req_arena_id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t req_arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t *",
                        "definition": [
                            "mi_memid_t *memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max_arena",
                        "type": "const size_t",
                        "definition": [
                            "const size_t max_arena = atomic_load_explicit(&mi_arena_count, memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = mi_arena_try_alloc_at_id(mi_arena_id_create(i), 0, numa_node, size, alignment, commit, allow_large, req_arena_id, memid)",
                            "void *p = mi_arena_try_alloc_at_id(mi_arena_id_create(i), 1, numa_node, size, alignment, commit, allow_large, req_arena_id, memid)",
                            "void *p = mi_arena_try_alloc_at_id(req_arena_id, 1, numa_node, size, alignment, commit, allow_large, req_arena_id, memid)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_arena_count",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_reserve",
            "header": "",
            "params": [
                "size_t req_size",
                "bool allow_large",
                "mi_arena_id_t *arena_id"
            ],
            "definition": "static bool mi_arena_reserve(size_t req_size, bool allow_large, mi_arena_id_t *arena_id)\n{\n  if (_mi_preloading())\n  {\n    return 0;\n  }\n  const size_t arena_count = atomic_load_explicit(&mi_arena_count, memory_order_acquire);\n  if (arena_count > (132 - 4))\n  {\n    return 0;\n  }\n  size_t arena_reserve = mi_option_get_size(mi_option_arena_reserve);\n  if (arena_reserve == 0)\n  {\n    return 0;\n  }\n  if (!_mi_os_has_virtual_reserve())\n  {\n    arena_reserve = arena_reserve / 4;\n  }\n  arena_reserve = _mi_align_up(arena_reserve, 1UL << (9 + (13 + 3)));\n  arena_reserve = _mi_align_up(arena_reserve, 1UL << (9 + (13 + 3)));\n  if ((arena_count >= 8) && (arena_count <= 128))\n  {\n    const size_t multiplier = ((size_t) 1) << _mi_clamp(arena_count / 8, 0, 16);\n    size_t reserve = 0;\n    if (!mi_mul_overflow(multiplier, arena_reserve, &reserve))\n    {\n      arena_reserve = reserve;\n    }\n  }\n  if (arena_reserve < req_size)\n  {\n    return 0;\n  }\n  bool arena_commit = 0;\n  if (mi_option_get(mi_option_arena_eager_commit) == 2)\n  {\n    arena_commit = _mi_os_has_overcommit();\n  }\n  else\n    if (mi_option_get(mi_option_arena_eager_commit) == 1)\n  {\n    arena_commit = 1;\n  }\n  return mi_reserve_os_memory_ex(arena_reserve, arena_commit, allow_large, 0, arena_id) == 0;\n}\n\n",
            "calle": [
                "_mi_align_up",
                "_mi_clamp",
                "_mi_os_has_overcommit",
                "_mi_os_has_virtual_reserve",
                "_mi_preloading",
                "atomic_load_explicit",
                "mi_mul_overflow",
                "mi_option_get",
                "mi_option_get_size",
                "mi_reserve_os_memory_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "req_size",
                        "type": "size_t",
                        "definition": [
                            "size_t req_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_large",
                        "type": "bool",
                        "definition": [
                            "bool allow_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_id",
                        "type": "mi_arena_id_t *",
                        "definition": [
                            "mi_arena_id_t *arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_count",
                        "type": "const size_t",
                        "definition": [
                            "const size_t arena_count = atomic_load_explicit(&mi_arena_count, memory_order_acquire)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_reserve",
                        "type": "size_t",
                        "definition": [
                            "size_t arena_reserve = mi_option_get_size(mi_option_arena_reserve)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "multiplier",
                        "type": "const size_t",
                        "definition": [
                            "const size_t multiplier = ((size_t) 1) << _mi_clamp(arena_count / 8, 0, 16)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "reserve",
                        "type": "size_t",
                        "definition": [
                            "size_t reserve = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_commit",
                        "type": "bool",
                        "definition": [
                            "bool arena_commit = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_arena_count",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_purge_delay",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static long mi_arena_purge_delay(void)\n{\n  return mi_option_get(mi_option_purge_delay) * mi_option_get(mi_option_arena_purge_mult);\n}\n\n",
            "calle": [
                "mi_option_get"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_purge",
            "header": "",
            "params": [
                "mi_arena_t *arena",
                "size_t bitmap_idx",
                "size_t blocks"
            ],
            "definition": "static void mi_arena_purge(mi_arena_t *arena, size_t bitmap_idx, size_t blocks)\n{\n  (arena->blocks_committed != 0) ? ((void) 0) : (_mi_assert_fail(\"arena->blocks_committed != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 475, __func__));\n  (arena->blocks_purge != 0) ? ((void) 0) : (_mi_assert_fail(\"arena->blocks_purge != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 476, __func__));\n  (!arena->memid.is_pinned) ? ((void) 0) : (_mi_assert_fail(\"!arena->memid.is_pinned\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 477, __func__));\n  const size_t size = mi_arena_block_size(blocks);\n  void * const p = mi_arena_block_start(arena, bitmap_idx);\n  bool needs_recommit;\n  size_t already_committed = 0;\n  if (_mi_bitmap_is_claimed_across(arena->blocks_committed, arena->field_count, blocks, bitmap_idx, &already_committed))\n  {\n    (already_committed == blocks) ? ((void) 0) : (_mi_assert_fail(\"already_committed == blocks\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 484, __func__));\n    needs_recommit = _mi_os_purge(p, size);\n  }\n  else\n  {\n    (already_committed < blocks) ? ((void) 0) : (_mi_assert_fail(\"already_committed < blocks\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 491, __func__));\n    (mi_option_is_enabled(mi_option_purge_decommits)) ? ((void) 0) : (_mi_assert_fail(\"mi_option_is_enabled(mi_option_purge_decommits)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 492, __func__));\n    needs_recommit = _mi_os_purge_ex(p, size, 0, mi_arena_block_size(already_committed));\n  }\n  _mi_bitmap_unclaim_across(arena->blocks_purge, arena->field_count, blocks, bitmap_idx);\n  if (needs_recommit)\n  {\n    _mi_bitmap_unclaim_across(arena->blocks_committed, arena->field_count, blocks, bitmap_idx);\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_bitmap_is_claimed_across",
                "_mi_bitmap_unclaim_across",
                "_mi_os_purge",
                "_mi_os_purge_ex",
                "mi_arena_block_size",
                "mi_arena_block_start",
                "mi_option_is_enabled"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "blocks",
                        "type": "size_t",
                        "definition": [
                            "size_t blocks"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t size = mi_arena_block_size(blocks)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void * const",
                        "definition": [
                            "void * const p = mi_arena_block_start(arena, bitmap_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "needs_recommit",
                        "type": "bool",
                        "definition": [
                            "bool needs_recommit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "already_committed",
                        "type": "size_t",
                        "definition": [
                            "size_t already_committed = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_schedule_purge",
            "header": "",
            "params": [
                "mi_arena_t *arena",
                "size_t bitmap_idx",
                "size_t blocks"
            ],
            "definition": "static void mi_arena_schedule_purge(mi_arena_t *arena, size_t bitmap_idx, size_t blocks)\n{\n  (arena->blocks_purge != 0) ? ((void) 0) : (_mi_assert_fail(\"arena->blocks_purge != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 507, __func__));\n  const long delay = mi_arena_purge_delay();\n  if (delay < 0)\n  {\n    return;\n  }\n  if (_mi_preloading() || (delay == 0))\n  {\n    mi_arena_purge(arena, bitmap_idx, blocks);\n  }\n  else\n  {\n    const mi_msecs_t expire = _mi_clock_now() + delay;\n    mi_msecs_t expire0 = 0;\n    if (atomic_compare_exchange_strong_explicit(&arena->purge_expire, &expire0, expire, memory_order_acq_rel, memory_order_acquire))\n    {\n      atomic_compare_exchange_strong_explicit(&mi_arenas_purge_expire, &expire0, expire, memory_order_acq_rel, memory_order_acquire);\n    }\n    else\n    {\n    }\n    _mi_bitmap_claim_across(arena->blocks_purge, arena->field_count, blocks, bitmap_idx, 0, 0);\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_bitmap_claim_across",
                "_mi_clock_now",
                "_mi_preloading",
                "atomic_compare_exchange_strong_explicit",
                "mi_arena_purge",
                "mi_arena_purge_delay"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "blocks",
                        "type": "size_t",
                        "definition": [
                            "size_t blocks"
                        ]
                    },
                    {
                        "path": null,
                        "name": "delay",
                        "type": "const long",
                        "definition": [
                            "const long delay = mi_arena_purge_delay()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "expire",
                        "type": "const mi_msecs_t",
                        "definition": [
                            "const mi_msecs_t expire = _mi_clock_now() + delay"
                        ]
                    },
                    {
                        "path": null,
                        "name": "expire0",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t expire0 = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_arenas_purge_expire",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_purge_range",
            "header": "",
            "params": [
                "mi_arena_t *arena",
                "size_t idx",
                "size_t startidx",
                "size_t bitlen",
                "size_t purge"
            ],
            "definition": "static bool mi_arena_purge_range(mi_arena_t *arena, size_t idx, size_t startidx, size_t bitlen, size_t purge)\n{\n  const size_t endidx = startidx + bitlen;\n  size_t bitidx = startidx;\n  bool all_purged = 0;\n  while (bitidx < endidx)\n  {\n    size_t count = 0;\n    while (((bitidx + count) < endidx) && ((purge & (((size_t) 1) << (bitidx + count))) != 0))\n    {\n      count += 1;\n    }\n\n    if (count > 0)\n    {\n      const mi_bitmap_index_t range_idx = mi_bitmap_index_create(idx, bitidx);\n      mi_arena_purge(arena, range_idx, count);\n      if (count == bitlen)\n      {\n        all_purged = 1;\n      }\n    }\n    bitidx += count + 1;\n  }\n\n  return all_purged;\n}\n\n",
            "calle": [
                "mi_arena_purge",
                "mi_bitmap_index_create"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t",
                        "definition": [
                            "size_t idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "startidx",
                        "type": "size_t",
                        "definition": [
                            "size_t startidx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitlen",
                        "type": "size_t",
                        "definition": [
                            "size_t bitlen"
                        ]
                    },
                    {
                        "path": null,
                        "name": "purge",
                        "type": "size_t",
                        "definition": [
                            "size_t purge"
                        ]
                    },
                    {
                        "path": null,
                        "name": "endidx",
                        "type": "const size_t",
                        "definition": [
                            "const size_t endidx = startidx + bitlen"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitidx = startidx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "all_purged",
                        "type": "bool",
                        "definition": [
                            "bool all_purged = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "range_idx",
                        "type": "const mi_bitmap_index_t",
                        "definition": [
                            "const mi_bitmap_index_t range_idx = mi_bitmap_index_create(idx, bitidx)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_try_purge",
            "header": "",
            "params": [
                "mi_arena_t *arena",
                "mi_msecs_t now",
                "bool force"
            ],
            "definition": "static bool mi_arena_try_purge(mi_arena_t *arena, mi_msecs_t now, bool force)\n{\n  if (arena->memid.is_pinned)\n  {\n    return 0;\n  }\n  mi_msecs_t expire = atomic_load_explicit(&arena->purge_expire, memory_order_relaxed);\n  if ((!force) && ((expire == 0) || (expire > now)))\n  {\n    return 0;\n  }\n  atomic_compare_exchange_strong_explicit(&arena->purge_expire, &expire, (mi_msecs_t) 0, memory_order_acq_rel, memory_order_acquire);\n  _mi_stat_counter_increase(&_mi_stats_main.arena_purges, 1);\n  bool any_purged = 0;\n  bool full_purge = 1;\n  for (size_t i = 0; i < arena->field_count; i += 1)\n  {\n    helper_mi_arena_try_purge_1(&any_purged, &full_purge, arena, i);\n  }\n\n  if (!full_purge)\n  {\n    const long delay = mi_arena_purge_delay();\n    mi_msecs_t expected = 0;\n    atomic_compare_exchange_strong_explicit(&arena->purge_expire, &expected, _mi_clock_now() + delay, memory_order_acq_rel, memory_order_acquire);\n  }\n  return any_purged;\n}\n\n",
            "calle": [
                "_mi_clock_now",
                "_mi_stat_counter_increase",
                "atomic_compare_exchange_strong_explicit",
                "atomic_load_explicit",
                "helper_mi_arena_try_purge_1",
                "mi_arena_purge_delay"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena"
                        ]
                    },
                    {
                        "path": null,
                        "name": "now",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t now"
                        ]
                    },
                    {
                        "path": null,
                        "name": "force",
                        "type": "bool",
                        "definition": [
                            "bool force"
                        ]
                    },
                    {
                        "path": null,
                        "name": "expire",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t expire = atomic_load_explicit(&arena->purge_expire, memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "any_purged",
                        "type": "bool",
                        "definition": [
                            "bool any_purged = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "full_purge",
                        "type": "bool",
                        "definition": [
                            "bool full_purge = 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "delay",
                        "type": "const long",
                        "definition": [
                            "const long delay = mi_arena_purge_delay()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "expected",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t expected = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arenas_try_purge",
            "header": "",
            "params": [
                "bool force",
                "bool visit_all"
            ],
            "definition": "static void mi_arenas_try_purge(bool force, bool visit_all)\n{\n  if (_mi_preloading() || (mi_arena_purge_delay() <= 0))\n  {\n    return;\n  }\n  const mi_msecs_t now = _mi_clock_now();\n  mi_msecs_t arenas_expire = atomic_load_explicit(&mi_arenas_purge_expire, memory_order_acquire);\n  if ((!force) && ((arenas_expire == 0) || (arenas_expire < now)))\n  {\n    return;\n  }\n  const size_t max_arena = atomic_load_explicit(&mi_arena_count, memory_order_acquire);\n  if (max_arena == 0)\n  {\n    return;\n  }\n  static mi_atomic_guard_t purge_guard;\n  uintptr_t _mi_guard_expected = 0;\n  for (bool _mi_guard_once = 1; _mi_guard_once && atomic_compare_exchange_strong_explicit(&purge_guard, &_mi_guard_expected, (uintptr_t) 1, memory_order_acq_rel, memory_order_acquire); atomic_store_explicit(&purge_guard, (uintptr_t) 0, memory_order_release), _mi_guard_once = 0)\n  {\n    atomic_store_explicit(&mi_arenas_purge_expire, now + mi_arena_purge_delay(), memory_order_release);\n    size_t max_purge_count = (visit_all) ? (max_arena) : (2);\n    bool all_visited = 1;\n    for (size_t i = 0; i < max_arena; i += 1)\n    {\n      mi_arena_t *arena = atomic_load_explicit(&mi_arenas[i], memory_order_acquire);\n      if (arena != 0)\n      {\n        if (mi_arena_try_purge(arena, now, force))\n        {\n          if (max_purge_count <= 1)\n          {\n            all_visited = 0;\n            break;\n          }\n          max_purge_count -= 1;\n        }\n      }\n    }\n\n    if (all_visited)\n    {\n      atomic_store_explicit(&mi_arenas_purge_expire, 0, memory_order_release);\n    }\n  }\n\n}\n\n",
            "calle": [
                "_mi_clock_now",
                "_mi_preloading",
                "atomic_compare_exchange_strong_explicit",
                "atomic_load_explicit",
                "atomic_store_explicit",
                "mi_arena_purge_delay",
                "mi_arena_try_purge"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "force",
                        "type": "bool",
                        "definition": [
                            "bool force"
                        ]
                    },
                    {
                        "path": null,
                        "name": "visit_all",
                        "type": "bool",
                        "definition": [
                            "bool visit_all"
                        ]
                    },
                    {
                        "path": null,
                        "name": "now",
                        "type": "const mi_msecs_t",
                        "definition": [
                            "const mi_msecs_t now = _mi_clock_now()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arenas_expire",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t arenas_expire = atomic_load_explicit(&mi_arenas_purge_expire, memory_order_acquire)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max_arena",
                        "type": "const size_t",
                        "definition": [
                            "const size_t max_arena = atomic_load_explicit(&mi_arena_count, memory_order_acquire)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "purge_guard",
                        "type": "mi_atomic_guard_t",
                        "definition": [
                            "static mi_atomic_guard_t purge_guard"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_guard_expected",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t _mi_guard_expected = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_guard_once",
                        "type": "bool",
                        "definition": [
                            "bool _mi_guard_once = 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max_purge_count",
                        "type": "size_t",
                        "definition": [
                            "size_t max_purge_count = (visit_all) ? (max_arena) : (2)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "all_visited",
                        "type": "bool",
                        "definition": [
                            "bool all_visited = 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena = atomic_load_explicit(&mi_arenas[i], memory_order_acquire)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_arenas_purge_expire",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "mi_arena_count",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "mi_arenas",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arenas_unsafe_destroy",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static void mi_arenas_unsafe_destroy(void)\n{\n  const size_t max_arena = atomic_load_explicit(&mi_arena_count, memory_order_relaxed);\n  size_t new_max_arena = 0;\n  for (size_t i = 0; i < max_arena; i += 1)\n  {\n    mi_arena_t *arena = atomic_load_explicit(&mi_arenas[i], memory_order_acquire);\n    if (arena != 0)\n    {\n      mi_lock_done(&arena->abandoned_visit_lock);\n      if ((arena->start != 0) && mi_memkind_is_os(arena->memid.memkind))\n      {\n        atomic_store_explicit(&mi_arenas[i], 0, memory_order_release);\n        _mi_os_free(arena->start, mi_arena_size(arena), arena->memid);\n      }\n      else\n      {\n        new_max_arena = i;\n      }\n      _mi_arena_meta_free(arena, arena->meta_memid, arena->meta_size);\n    }\n  }\n\n  size_t expected = max_arena;\n  atomic_compare_exchange_strong_explicit(&mi_arena_count, &expected, new_max_arena, memory_order_acq_rel, memory_order_acquire);\n}\n\n",
            "calle": [
                "_mi_arena_meta_free",
                "_mi_os_free",
                "atomic_compare_exchange_strong_explicit",
                "atomic_load_explicit",
                "atomic_store_explicit",
                "mi_arena_size",
                "mi_lock_done",
                "mi_memkind_is_os"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max_arena",
                        "type": "const size_t",
                        "definition": [
                            "const size_t max_arena = atomic_load_explicit(&mi_arena_count, memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "new_max_arena",
                        "type": "size_t",
                        "definition": [
                            "size_t new_max_arena = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena = atomic_load_explicit(&mi_arenas[i], memory_order_acquire)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "expected",
                        "type": "size_t",
                        "definition": [
                            "size_t expected = max_arena"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_arena_count",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "mi_arenas",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_arena_add",
            "header": "",
            "params": [
                "mi_arena_t *arena",
                "mi_arena_id_t *arena_id",
                "mi_stats_t *stats"
            ],
            "definition": "static bool mi_arena_add(mi_arena_t *arena, mi_arena_id_t *arena_id, mi_stats_t *stats)\n{\n  (arena != 0) ? ((void) 0) : (_mi_assert_fail(\"arena != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 796, __func__));\n  ((((uintptr_t) atomic_load_explicit(&arena->start, memory_order_relaxed)) % (1UL << (9 + (13 + 3)))) == 0) ? ((void) 0) : (_mi_assert_fail(\"(uintptr_t)mi_atomic_load_ptr_relaxed(uint8_t,&arena->start) % MI_SEGMENT_ALIGN == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 797, __func__));\n  (arena->block_count > 0) ? ((void) 0) : (_mi_assert_fail(\"arena->block_count > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 798, __func__));\n  if (arena_id != 0)\n  {\n    *arena_id = -1;\n  }\n  size_t i = atomic_fetch_add_explicit(&mi_arena_count, (uintptr_t) 1, memory_order_acq_rel);\n  if (i >= 132)\n  {\n    atomic_fetch_sub_explicit(&mi_arena_count, (uintptr_t) 1, memory_order_acq_rel);\n    return 0;\n  }\n  _mi_stat_counter_increase(&stats->arena_count, 1);\n  arena->id = mi_arena_id_create(i);\n  atomic_store_explicit(&mi_arenas[i], arena, memory_order_release);\n  if (arena_id != 0)\n  {\n    *arena_id = arena->id;\n  }\n  return 1;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_stat_counter_increase",
                "atomic_fetch_add_explicit",
                "atomic_fetch_sub_explicit",
                "atomic_load_explicit",
                "atomic_store_explicit",
                "mi_arena_id_create"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_id",
                        "type": "mi_arena_id_t *",
                        "definition": [
                            "mi_arena_id_t *arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "stats",
                        "type": "mi_stats_t *",
                        "definition": [
                            "mi_stats_t *stats"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = atomic_fetch_add_explicit(&mi_arena_count, (uintptr_t) 1, memory_order_acq_rel)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_arena_count",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "mi_arenas",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_manage_os_memory_ex2",
            "header": "",
            "params": [
                "void *start",
                "size_t size",
                "bool is_large",
                "int numa_node",
                "bool exclusive",
                "mi_memid_t memid",
                "mi_arena_id_t *arena_id"
            ],
            "definition": "static bool mi_manage_os_memory_ex2(void *start, size_t size, bool is_large, int numa_node, bool exclusive, mi_memid_t memid, mi_arena_id_t *arena_id)\n{\n  unsigned int start_idx = 0;\n  if (arena_id != 0)\n  {\n    *arena_id = _mi_arena_id_none();\n  }\n  if (size < (1UL << (9 + (13 + 3))))\n  {\n    _mi_warning_message(\"the arena size is too small (memory at %p with size %zu)\\n\", start, size);\n    return 0;\n  }\n  if (is_large)\n  {\n    (memid.initially_committed && memid.is_pinned) ? ((void) 0) : (_mi_assert_fail(\"memid.initially_committed && memid.is_pinned\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 821, __func__));\n  }\n  if (!_mi_is_aligned(start, 1UL << (9 + (13 + 3))))\n  {\n    void * const aligned_start = mi_align_up_ptr(start, 1UL << (9 + (13 + 3)));\n    const size_t diff = ((uint8_t *) aligned_start) - ((uint8_t *) start);\n    if ((diff >= size) || ((size - diff) < (1UL << (9 + (13 + 3)))))\n    {\n      _mi_warning_message(\"after alignment, the size of the arena becomes too small (memory at %p with size %zu)\\n\", start, size);\n      return 0;\n    }\n    start_idx = aligned_start;\n    size = size - diff;\n  }\n  const size_t bcount = size / (1UL << (9 + (13 + 3)));\n  const size_t fields = _mi_divide_up(bcount, 8 * (1 << 3));\n  const size_t bitmaps = (memid.is_pinned) ? (3) : (5);\n  const size_t asize = (sizeof(mi_arena_t)) + ((bitmaps * fields) * (sizeof(mi_bitmap_field_t)));\n  mi_memid_t meta_memid;\n  mi_arena_t *arena = (mi_arena_t *) _mi_arena_meta_zalloc(asize, &meta_memid);\n  if (arena == 0)\n  {\n    return 0;\n  }\n  arena->id = _mi_arena_id_none();\n  arena->memid = memid;\n  arena->exclusive = exclusive;\n  arena->meta_size = asize;\n  arena->meta_memid = meta_memid;\n  arena->block_count = bcount;\n  arena->field_count = fields;\n  arena->start = (uint8_t *) start;\n  arena->numa_node = numa_node;\n  arena->is_large = is_large;\n  arena->purge_expire = 0;\n  arena->search_idx = 0;\n  mi_lock_init(&arena->abandoned_visit_lock);\n  arena->blocks_dirty = &arena->blocks_inuse[fields];\n  arena->blocks_abandoned = &arena->blocks_inuse[2 * fields];\n  arena->blocks_committed = (arena->memid.is_pinned) ? (0) : (&arena->blocks_inuse[3 * fields]);\n  arena->blocks_purge = (arena->memid.is_pinned) ? (0) : (&arena->blocks_inuse[4 * fields]);\n  if ((arena->blocks_committed != 0) && arena->memid.initially_committed)\n  {\n    memset((void *) arena->blocks_committed, 0xFF, fields * (sizeof(mi_bitmap_field_t)));\n  }\n  ptrdiff_t post = (fields * (8 * (1 << 3))) - bcount;\n  (post >= 0) ? ((void) 0) : (_mi_assert_fail(\"post >= 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 869, __func__));\n  if (post > 0)\n  {\n    mi_bitmap_index_t postidx = mi_bitmap_index_create(fields - 1, (8 * (1 << 3)) - post);\n    _mi_bitmap_claim(arena->blocks_inuse, fields, post, postidx, 0);\n  }\n  return mi_arena_add(arena, arena_id, &_mi_stats_main);\n}\n\n",
            "calle": [
                "_mi_arena_id_none",
                "_mi_arena_meta_zalloc",
                "_mi_assert_fail",
                "_mi_bitmap_claim",
                "_mi_divide_up",
                "_mi_is_aligned",
                "_mi_warning_message",
                "memset",
                "mi_align_up_ptr",
                "mi_arena_add",
                "mi_bitmap_index_create",
                "mi_lock_init"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "start",
                        "type": "void *",
                        "definition": [
                            "void *start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_large",
                        "type": "bool",
                        "definition": [
                            "bool is_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numa_node",
                        "type": "int",
                        "definition": [
                            "int numa_node"
                        ]
                    },
                    {
                        "path": null,
                        "name": "exclusive",
                        "type": "bool",
                        "definition": [
                            "bool exclusive"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_id",
                        "type": "mi_arena_id_t *",
                        "definition": [
                            "mi_arena_id_t *arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int start_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "aligned_start",
                        "type": "void * const",
                        "definition": [
                            "void * const aligned_start = mi_align_up_ptr(start, 1UL << (9 + (13 + 3)))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "diff",
                        "type": "const size_t",
                        "definition": [
                            "const size_t diff = ((uint8_t *) aligned_start) - ((uint8_t *) start)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bcount",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bcount = size / (1UL << (9 + (13 + 3)))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fields",
                        "type": "const size_t",
                        "definition": [
                            "const size_t fields = _mi_divide_up(bcount, 8 * (1 << 3))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmaps",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bitmaps = (memid.is_pinned) ? (3) : (5)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "asize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t asize = (sizeof(mi_arena_t)) + ((bitmaps * fields) * (sizeof(mi_bitmap_field_t)))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "meta_memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t meta_memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena = (mi_arena_t *) _mi_arena_meta_zalloc(asize, &meta_memid)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "post",
                        "type": "ptrdiff_t",
                        "definition": [
                            "ptrdiff_t post = (fields * (8 * (1 << 3))) - bcount"
                        ]
                    },
                    {
                        "path": null,
                        "name": "postidx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t postidx = mi_bitmap_index_create(fields - 1, (8 * (1 << 3)) - post)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_debug_show_bitmap",
            "header": "",
            "params": [
                "const char *prefix",
                "const char *header",
                "size_t block_count",
                "mi_bitmap_field_t *fields",
                "size_t field_count"
            ],
            "definition": "static size_t mi_debug_show_bitmap(const char *prefix, const char *header, size_t block_count, mi_bitmap_field_t *fields, size_t field_count)\n{\n  _mi_message(\"%s%s:\\n\", prefix, header);\n  size_t bcount = 0;\n  size_t inuse_count = 0;\n  for (size_t i = 0; i < field_count; i += 1)\n  {\n    char buf[(8 * (1 << 3)) + 1];\n    uintptr_t field = atomic_load_explicit(&fields[i], memory_order_relaxed);\n    for (size_t bit = 0; bit < (8 * (1 << 3)); bit += 1, bcount += 1)\n    {\n      if (bcount < block_count)\n      {\n        bool inuse = ((((uintptr_t) 1) << bit) & field) != 0;\n        if (inuse)\n        {\n          inuse_count += 1;\n        }\n        buf[bit] = (inuse) ? ('x') : ('.');\n      }\n      else\n      {\n        buf[bit] = ' ';\n      }\n    }\n\n    buf[8 * (1 << 3)] = 0;\n    _mi_message(\"%s  %s\\n\", prefix, buf);\n  }\n\n  _mi_message(\"%s  total ('x'): %zu\\n\", prefix, inuse_count);\n  return inuse_count;\n}\n\n",
            "calle": [
                "_mi_message",
                "atomic_load_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "prefix",
                        "type": "const char *",
                        "definition": [
                            "const char *prefix"
                        ]
                    },
                    {
                        "path": null,
                        "name": "header",
                        "type": "const char *",
                        "definition": [
                            "const char *header"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_count",
                        "type": "size_t",
                        "definition": [
                            "size_t block_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fields",
                        "type": "mi_bitmap_field_t *",
                        "definition": [
                            "mi_bitmap_field_t *fields"
                        ]
                    },
                    {
                        "path": null,
                        "name": "field_count",
                        "type": "size_t",
                        "definition": [
                            "size_t field_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bcount",
                        "type": "size_t",
                        "definition": [
                            "size_t bcount = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "inuse_count",
                        "type": "size_t",
                        "definition": [
                            "size_t inuse_count = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char [(8 * (1 << 3)) + 1]",
                        "definition": [
                            "char buf[(8 * (1 << 3)) + 1]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "field",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t field = atomic_load_explicit(&fields[i], memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bit",
                        "type": "size_t",
                        "definition": [
                            "size_t bit = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "inuse",
                        "type": "bool",
                        "definition": [
                            "bool inuse = ((((uintptr_t) 1) << bit) & field) != 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper_mi_arena_segment_clear_abandoned_next_field_1",
            "header": "",
            "params": [
                "size_t * const field_idx_ref",
                "size_t * const bit_idx_ref",
                "mi_arena_field_cursor_t * const previous",
                "const size_t max_arena"
            ],
            "definition": "mi_segment_t *helper_mi_arena_segment_clear_abandoned_next_field_1(size_t * const field_idx_ref, size_t * const bit_idx_ref, mi_arena_field_cursor_t * const previous, const size_t max_arena)\n{\n  size_t field_idx = *field_idx_ref;\n  size_t bit_idx = *bit_idx_ref;\n  size_t arena_idx = (previous->start >= max_arena) ? (previous->start % max_arena) : (previous->start);\n  mi_arena_t *arena = mi_arena_from_index(arena_idx);\n  if (arena != 0)\n  {\n    bool has_lock = 0;\n    for (; field_idx < arena->field_count; field_idx += 1, bit_idx = 0)\n    {\n      size_t field = atomic_load_explicit(&arena->blocks_abandoned[field_idx], memory_order_relaxed);\n      if (__builtin_expect(!(!(field != 0)), 0))\n      {\n        if ((!has_lock) && mi_option_is_enabled(mi_option_visit_abandoned))\n        {\n          has_lock = (previous->visit_all) ? ((mi_lock_acquire(&arena->abandoned_visit_lock), 1)) : (mi_lock_try_acquire(&arena->abandoned_visit_lock));\n          if (!has_lock)\n          {\n            if (previous->visit_all)\n            {\n              _mi_error_message(14, \"internal error: failed to visit all abandoned segments due to failure to acquire the visitor lock\");\n            }\n            break;\n          }\n        }\n        (has_lock || (!mi_option_is_enabled(mi_option_visit_abandoned))) ? ((void) 0) : (_mi_assert_fail(\"has_lock || !mi_option_is_enabled(mi_option_visit_abandoned)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena-abandon.c\", 257, __func__));\n        for (; bit_idx < (8 * (1 << 3)); bit_idx += 1)\n        {\n          size_t mask = ((size_t) 1) << bit_idx;\n          if (__builtin_expect(!(!((field & mask) == mask)), 0))\n          {\n            mi_bitmap_index_t bitmap_idx = mi_bitmap_index_create(field_idx, bit_idx);\n            mi_segment_t * const segment = mi_arena_segment_clear_abandoned_at(arena, previous->subproc, bitmap_idx);\n            if (segment != 0)\n            {\n              if (has_lock)\n              {\n                mi_lock_release(&arena->abandoned_visit_lock);\n              }\n              previous->bitmap_idx = mi_bitmap_index_create_ex(field_idx, bit_idx + 1);\n              return segment;\n            }\n          }\n        }\n\n      }\n    }\n\n    if (has_lock)\n    {\n      mi_lock_release(&arena->abandoned_visit_lock);\n    }\n  }\n  *field_idx_ref = field_idx;\n  *bit_idx_ref = bit_idx;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_error_message",
                "atomic_load_explicit",
                "mi_arena_from_index",
                "mi_arena_segment_clear_abandoned_at",
                "mi_bitmap_index_create",
                "mi_bitmap_index_create_ex",
                "mi_lock_acquire",
                "mi_lock_release",
                "mi_lock_try_acquire",
                "mi_option_is_enabled"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "field_idx_ref",
                        "type": "size_t * const",
                        "definition": [
                            "size_t * const field_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bit_idx_ref",
                        "type": "size_t * const",
                        "definition": [
                            "size_t * const bit_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "previous",
                        "type": "mi_arena_field_cursor_t * const",
                        "definition": [
                            "mi_arena_field_cursor_t * const previous"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max_arena",
                        "type": "const size_t",
                        "definition": [
                            "const size_t max_arena"
                        ]
                    },
                    {
                        "path": null,
                        "name": "field_idx",
                        "type": "size_t",
                        "definition": [
                            "size_t field_idx = *field_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bit_idx",
                        "type": "size_t",
                        "definition": [
                            "size_t bit_idx = *bit_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_idx",
                        "type": "size_t",
                        "definition": [
                            "size_t arena_idx = (previous->start >= max_arena) ? (previous->start % max_arena) : (previous->start)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena = mi_arena_from_index(arena_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "has_lock",
                        "type": "bool",
                        "definition": [
                            "bool has_lock = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "field",
                        "type": "size_t",
                        "definition": [
                            "size_t field = atomic_load_explicit(&arena->blocks_abandoned[field_idx], memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "size_t",
                        "definition": [
                            "size_t mask = ((size_t) 1) << bit_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_idx = mi_bitmap_index_create(field_idx, bit_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t * const",
                        "definition": [
                            "mi_segment_t * const segment = mi_arena_segment_clear_abandoned_at(arena, previous->subproc, bitmap_idx)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper_mi_arena_try_alloc_at_1",
            "header": "",
            "params": [
                "mi_arena_t * const arena",
                "size_t needed_bcount",
                "mi_memid_t * const memid",
                "mi_bitmap_index_t bitmap_index",
                "void * const p"
            ],
            "definition": "void helper_mi_arena_try_alloc_at_1(mi_arena_t * const arena, size_t needed_bcount, mi_memid_t * const memid, mi_bitmap_index_t bitmap_index, void * const p)\n{\n  memid->initially_committed = 1;\n  const size_t commit_size = mi_arena_block_size(needed_bcount);\n  bool any_uncommitted;\n  size_t already_committed = 0;\n  _mi_bitmap_claim_across(arena->blocks_committed, arena->field_count, needed_bcount, bitmap_index, &any_uncommitted, &already_committed);\n  if (any_uncommitted)\n  {\n    (already_committed < needed_bcount) ? ((void) 0) : (_mi_assert_fail(\"already_committed < needed_bcount\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 273, __func__));\n    const size_t stat_commit_size = commit_size - mi_arena_block_size(already_committed);\n    bool commit_zero = 0;\n    if (!_mi_os_commit_ex(p, commit_size, &commit_zero, stat_commit_size))\n    {\n      memid->initially_committed = 0;\n    }\n    else\n    {\n      if (commit_zero)\n      {\n        memid->initially_zero = 1;\n      }\n    }\n  }\n  else\n  {\n    _mi_os_reuse(p, commit_size);\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_bitmap_claim_across",
                "_mi_os_commit_ex",
                "_mi_os_reuse",
                "mi_arena_block_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t * const",
                        "definition": [
                            "mi_arena_t * const arena"
                        ]
                    },
                    {
                        "path": null,
                        "name": "needed_bcount",
                        "type": "size_t",
                        "definition": [
                            "size_t needed_bcount"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t * const",
                        "definition": [
                            "mi_memid_t * const memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_index",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_index"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void * const",
                        "definition": [
                            "void * const p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit_size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t commit_size = mi_arena_block_size(needed_bcount)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "any_uncommitted",
                        "type": "bool",
                        "definition": [
                            "bool any_uncommitted"
                        ]
                    },
                    {
                        "path": null,
                        "name": "already_committed",
                        "type": "size_t",
                        "definition": [
                            "size_t already_committed = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "stat_commit_size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t stat_commit_size = commit_size - mi_arena_block_size(already_committed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit_zero",
                        "type": "bool",
                        "definition": [
                            "bool commit_zero = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper_mi_arena_try_purge_1",
            "header": "",
            "params": [
                "bool * const any_purged_ref",
                "bool * const full_purge_ref",
                "mi_arena_t * const arena",
                "size_t i"
            ],
            "definition": "void helper_mi_arena_try_purge_1(bool * const any_purged_ref, bool * const full_purge_ref, mi_arena_t * const arena, size_t i)\n{\n  bool any_purged = *any_purged_ref;\n  bool full_purge = *full_purge_ref;\n  size_t purge = atomic_load_explicit(&arena->blocks_purge[i], memory_order_relaxed);\n  if (purge != 0)\n  {\n    size_t bitidx = 0;\n    while (bitidx < (8 * (1 << 3)))\n    {\n      size_t bitlen = 0;\n      while (((bitidx + bitlen) < (8 * (1 << 3))) && ((purge & (((size_t) 1) << (bitidx + bitlen))) != 0))\n      {\n        bitlen += 1;\n      }\n\n      const mi_bitmap_index_t bitmap_index = mi_bitmap_index_create(i, bitidx);\n      while (bitlen > 0)\n      {\n        if (_mi_bitmap_try_claim(arena->blocks_inuse, arena->field_count, bitlen, bitmap_index))\n        {\n          break;\n        }\n        bitlen -= 1;\n      }\n\n      if (bitlen > 0)\n      {\n        purge = atomic_load_explicit(&arena->blocks_purge[i], memory_order_acquire);\n        if (!mi_arena_purge_range(arena, i, bitidx, bitlen, purge))\n        {\n          full_purge = 0;\n        }\n        any_purged = 1;\n        _mi_bitmap_unclaim(arena->blocks_inuse, arena->field_count, bitlen, bitmap_index);\n      }\n      bitidx += bitlen + 1;\n    }\n\n  }\n  *any_purged_ref = any_purged;\n  *full_purge_ref = full_purge;\n}\n\n",
            "calle": [
                "_mi_bitmap_try_claim",
                "_mi_bitmap_unclaim",
                "atomic_load_explicit",
                "mi_arena_purge_range",
                "mi_bitmap_index_create"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "any_purged_ref",
                        "type": "bool * const",
                        "definition": [
                            "bool * const any_purged_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "full_purge_ref",
                        "type": "bool * const",
                        "definition": [
                            "bool * const full_purge_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t * const",
                        "definition": [
                            "mi_arena_t * const arena"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i"
                        ]
                    },
                    {
                        "path": null,
                        "name": "any_purged",
                        "type": "bool",
                        "definition": [
                            "bool any_purged = *any_purged_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "full_purge",
                        "type": "bool",
                        "definition": [
                            "bool full_purge = *full_purge_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "purge",
                        "type": "size_t",
                        "definition": [
                            "size_t purge = atomic_load_explicit(&arena->blocks_purge[i], memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitidx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitlen",
                        "type": "size_t",
                        "definition": [
                            "size_t bitlen = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_index",
                        "type": "const mi_bitmap_index_t",
                        "definition": [
                            "const mi_bitmap_index_t bitmap_index = mi_bitmap_index_create(i, bitidx)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper__mi_arena_free_1",
            "header": "",
            "params": [
                "void * const p",
                "size_t size",
                "size_t committed_size",
                "mi_memid_t memid",
                "const bool all_committed"
            ],
            "definition": "void helper__mi_arena_free_1(void * const p, size_t size, size_t committed_size, mi_memid_t memid, const bool all_committed)\n{\n  size_t arena_idx;\n  size_t bitmap_idx;\n  mi_arena_memid_indices(memid, &arena_idx, &bitmap_idx);\n  (arena_idx < 132) ? ((void) 0) : (_mi_assert_fail(\"arena_idx < MI_MAX_ARENAS\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 685, __func__));\n  mi_arena_t *arena = atomic_load_explicit(&mi_arenas[arena_idx], memory_order_acquire);\n  (arena != 0) ? ((void) 0) : (_mi_assert_fail(\"arena != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 687, __func__));\n  const size_t blocks = mi_block_count_of_size(size);\n  if (arena == 0)\n  {\n    _mi_error_message(22, \"trying to free from an invalid arena: %p, size %zu, memid: 0x%zx\\n\", p, size, memid);\n    return;\n  }\n  (arena->field_count > mi_bitmap_index_field(bitmap_idx)) ? ((void) 0) : (_mi_assert_fail(\"arena->field_count > mi_bitmap_index_field(bitmap_idx)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 695, __func__));\n  if (arena->field_count <= mi_bitmap_index_field(bitmap_idx))\n  {\n    _mi_error_message(22, \"trying to free from an invalid arena block: %p, size %zu, memid: 0x%zx\\n\", p, size, memid);\n    return;\n  }\n  if (arena->memid.is_pinned || (arena->blocks_committed == 0))\n  {\n    (all_committed) ? ((void) 0) : (_mi_assert_fail(\"all_committed\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 703, __func__));\n  }\n  else\n  {\n    (arena->blocks_committed != 0) ? ((void) 0) : (_mi_assert_fail(\"arena->blocks_committed != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 706, __func__));\n    (arena->blocks_purge != 0) ? ((void) 0) : (_mi_assert_fail(\"arena->blocks_purge != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/arena.c\", 707, __func__));\n    if (!all_committed)\n    {\n      _mi_bitmap_unclaim_across(arena->blocks_committed, arena->field_count, blocks, bitmap_idx);\n      ;\n      _mi_stat_decrease(&_mi_stats_main.committed, committed_size);\n    }\n    mi_arena_schedule_purge(arena, bitmap_idx, blocks);\n  }\n  bool all_inuse = _mi_bitmap_unclaim_across(arena->blocks_inuse, arena->field_count, blocks, bitmap_idx);\n  if (!all_inuse)\n  {\n    _mi_error_message(11, \"trying to free an already freed arena block: %p, size %zu\\n\", p, size);\n    return;\n  }\n  ;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_bitmap_unclaim_across",
                "_mi_error_message",
                "_mi_stat_decrease",
                "atomic_load_explicit",
                "mi_arena_memid_indices",
                "mi_arena_schedule_purge",
                "mi_bitmap_index_field",
                "mi_block_count_of_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void * const",
                        "definition": [
                            "void * const p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "committed_size",
                        "type": "size_t",
                        "definition": [
                            "size_t committed_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "all_committed",
                        "type": "const bool",
                        "definition": [
                            "const bool all_committed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_idx",
                        "type": "size_t",
                        "definition": [
                            "size_t arena_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena",
                        "type": "mi_arena_t *",
                        "definition": [
                            "mi_arena_t *arena = atomic_load_explicit(&mi_arenas[arena_idx], memory_order_acquire)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "blocks",
                        "type": "const size_t",
                        "definition": [
                            "const size_t blocks = mi_block_count_of_size(size)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "all_inuse",
                        "type": "bool",
                        "definition": [
                            "bool all_inuse = _mi_bitmap_unclaim_across(arena->blocks_inuse, arena->field_count, blocks, bitmap_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_arenas",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_bitmap_try_find_claim_field",
            "header": "bool _mi_bitmap_try_find_claim_field(mi_bitmap_t bitmap, size_t idx, const size_t count, mi_bitmap_index_t *bitmap_idx)",
            "params": [
                "mi_bitmap_t bitmap",
                "size_t idx",
                "const size_t count",
                "mi_bitmap_index_t *bitmap_idx"
            ],
            "definition": "inline bool _mi_bitmap_try_find_claim_field(mi_bitmap_t bitmap, size_t idx, const size_t count, mi_bitmap_index_t *bitmap_idx)\n{\n  (bitmap_idx != 0) ? ((void) 0) : (_mi_assert_fail(\"bitmap_idx != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 45, __func__));\n  (count <= (8 * (1 << 3))) ? ((void) 0) : (_mi_assert_fail(\"count <= MI_BITMAP_FIELD_BITS\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 46, __func__));\n  (count > 0) ? ((void) 0) : (_mi_assert_fail(\"count > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 47, __func__));\n  mi_bitmap_field_t *field = &bitmap[idx];\n  size_t map = atomic_load_explicit(field, memory_order_relaxed);\n  if (map == (~((size_t) 0)))\n  {\n    return 0;\n  }\n  const size_t mask = mi_bitmap_mask_(count, 0);\n  const size_t bitidx_max = (8 * (1 << 3)) - count;\n  size_t bitidx = mi_ctz(~map);\n  size_t m = mask << bitidx;\n  while (bitidx <= bitidx_max)\n  {\n    const size_t mapm = map & m;\n    if (mapm == 0)\n    {\n      ((m >> bitidx) == mask) ? ((void) 0) : (_mi_assert_fail(\"(m >> bitidx) == mask\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 67, __func__));\n      const size_t newmap = map | m;\n      (((newmap ^ map) >> bitidx) == mask) ? ((void) 0) : (_mi_assert_fail(\"(newmap^map) >> bitidx == mask\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 69, __func__));\n      if (!atomic_compare_exchange_strong_explicit(field, &map, newmap, memory_order_acq_rel, memory_order_acquire))\n      {\n        continue;\n      }\n      else\n      {\n        *bitmap_idx = mi_bitmap_index_create(idx, bitidx);\n        return 1;\n      }\n    }\n    else\n    {\n      (mapm != 0) ? ((void) 0) : (_mi_assert_fail(\"mapm != 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 83, __func__));\n      const size_t shift = (count == 1) ? (1) : ((((1 << 3) * 8) - mi_clz(mapm)) - bitidx);\n      ((shift > 0) && (shift <= count)) ? ((void) 0) : (_mi_assert_fail(\"shift > 0 && shift <= count\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 85, __func__));\n      bitidx += shift;\n      m <<= shift;\n    }\n  }\n\n  return 0;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "atomic_compare_exchange_strong_explicit",
                "atomic_load_explicit",
                "mi_bitmap_index_create",
                "mi_bitmap_mask_",
                "mi_clz",
                "mi_ctz"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap",
                        "type": "mi_bitmap_t",
                        "definition": [
                            "mi_bitmap_t bitmap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t",
                        "definition": [
                            "size_t idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "const size_t",
                        "definition": [
                            "const size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t *",
                        "definition": [
                            "mi_bitmap_index_t *bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "field",
                        "type": "mi_bitmap_field_t *",
                        "definition": [
                            "mi_bitmap_field_t *field = &bitmap[idx]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "map",
                        "type": "size_t",
                        "definition": [
                            "size_t map = atomic_load_explicit(field, memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "const size_t",
                        "definition": [
                            "const size_t mask = mi_bitmap_mask_(count, 0)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx_max",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bitidx_max = (8 * (1 << 3)) - count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitidx = mi_ctz(~map)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "m",
                        "type": "size_t",
                        "definition": [
                            "size_t m = mask << bitidx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mapm",
                        "type": "const size_t",
                        "definition": [
                            "const size_t mapm = map & m"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newmap",
                        "type": "const size_t",
                        "definition": [
                            "const size_t newmap = map | m"
                        ]
                    },
                    {
                        "path": null,
                        "name": "shift",
                        "type": "const size_t",
                        "definition": [
                            "const size_t shift = (count == 1) ? (1) : ((((1 << 3) * 8) - mi_clz(mapm)) - bitidx)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_bitmap_try_find_from_claim",
            "header": "bool _mi_bitmap_try_find_from_claim(mi_bitmap_t bitmap, const size_t bitmap_fields, const size_t start_field_idx, const size_t count, mi_bitmap_index_t *bitmap_idx)",
            "params": [
                "mi_bitmap_t bitmap",
                "const size_t bitmap_fields",
                "const size_t start_field_idx",
                "const size_t count",
                "mi_bitmap_index_t *bitmap_idx"
            ],
            "definition": "bool _mi_bitmap_try_find_from_claim(mi_bitmap_t bitmap, const size_t bitmap_fields, const size_t start_field_idx, const size_t count, mi_bitmap_index_t *bitmap_idx)\n{\n  size_t idx = start_field_idx;\n  for (size_t visited = 0; visited < bitmap_fields; visited += 1, idx += 1)\n  {\n    if (idx >= bitmap_fields)\n    {\n      idx = 0;\n    }\n    if (_mi_bitmap_try_find_claim_field(bitmap, idx, count, bitmap_idx))\n    {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\n",
            "calle": [
                "_mi_bitmap_try_find_claim_field"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap",
                        "type": "mi_bitmap_t",
                        "definition": [
                            "mi_bitmap_t bitmap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_fields",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bitmap_fields"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start_field_idx",
                        "type": "const size_t",
                        "definition": [
                            "const size_t start_field_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "const size_t",
                        "definition": [
                            "const size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t *",
                        "definition": [
                            "mi_bitmap_index_t *bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t",
                        "definition": [
                            "size_t idx = start_field_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "visited",
                        "type": "size_t",
                        "definition": [
                            "size_t visited = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_bitmap_try_find_from_claim_pred",
            "header": "bool _mi_bitmap_try_find_from_claim_pred(mi_bitmap_t bitmap, const size_t bitmap_fields, const size_t start_field_idx, const size_t count, mi_bitmap_pred_fun_t pred_fun, void *pred_arg, mi_bitmap_index_t *bitmap_idx)",
            "params": [
                "mi_bitmap_t bitmap",
                "const size_t bitmap_fields",
                "const size_t start_field_idx",
                "const size_t count",
                "mi_bitmap_pred_fun_t pred_fun",
                "void *pred_arg",
                "mi_bitmap_index_t *bitmap_idx"
            ],
            "definition": "bool _mi_bitmap_try_find_from_claim_pred(mi_bitmap_t bitmap, const size_t bitmap_fields, const size_t start_field_idx, const size_t count, mi_bitmap_pred_fun_t pred_fun, void *pred_arg, mi_bitmap_index_t *bitmap_idx)\n{\n  size_t idx = start_field_idx;\n  for (size_t visited = 0; visited < bitmap_fields; visited += 1, idx += 1)\n  {\n    if (idx >= bitmap_fields)\n    {\n      idx = 0;\n    }\n    if (_mi_bitmap_try_find_claim_field(bitmap, idx, count, bitmap_idx))\n    {\n      if ((pred_fun == 0) || pred_fun(*bitmap_idx, pred_arg))\n      {\n        return 1;\n      }\n      _mi_bitmap_unclaim(bitmap, bitmap_fields, count, *bitmap_idx);\n    }\n  }\n\n  return 0;\n}\n\n",
            "calle": [
                "_mi_bitmap_try_find_claim_field",
                "_mi_bitmap_unclaim",
                "pred_fun"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap",
                        "type": "mi_bitmap_t",
                        "definition": [
                            "mi_bitmap_t bitmap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_fields",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bitmap_fields"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start_field_idx",
                        "type": "const size_t",
                        "definition": [
                            "const size_t start_field_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "const size_t",
                        "definition": [
                            "const size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pred_fun",
                        "type": "mi_bitmap_pred_fun_t",
                        "definition": [
                            "mi_bitmap_pred_fun_t pred_fun"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pred_arg",
                        "type": "void *",
                        "definition": [
                            "void *pred_arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t *",
                        "definition": [
                            "mi_bitmap_index_t *bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t",
                        "definition": [
                            "size_t idx = start_field_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "visited",
                        "type": "size_t",
                        "definition": [
                            "size_t visited = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_bitmap_unclaim",
            "header": "bool _mi_bitmap_unclaim(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx)",
            "params": [
                "mi_bitmap_t bitmap",
                "size_t bitmap_fields",
                "size_t count",
                "mi_bitmap_index_t bitmap_idx"
            ],
            "definition": "bool _mi_bitmap_unclaim(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx)\n{\n  const size_t idx = mi_bitmap_index_field(bitmap_idx);\n  const size_t bitidx = mi_bitmap_index_bit_in_field(bitmap_idx);\n  const size_t mask = mi_bitmap_mask_(count, bitidx);\n  (bitmap_fields > idx) ? ((void) 0) : (_mi_assert_fail(\"bitmap_fields > idx\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 136, __func__));\n  (void) bitmap_fields;\n  const size_t prev = atomic_fetch_and_explicit(&bitmap[idx], ~mask, memory_order_acq_rel);\n  return (prev & mask) == mask;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "atomic_fetch_and_explicit",
                "mi_bitmap_index_bit_in_field",
                "mi_bitmap_index_field",
                "mi_bitmap_mask_"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap",
                        "type": "mi_bitmap_t",
                        "definition": [
                            "mi_bitmap_t bitmap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_fields",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_fields"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "const size_t",
                        "definition": [
                            "const size_t idx = mi_bitmap_index_field(bitmap_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bitidx = mi_bitmap_index_bit_in_field(bitmap_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "const size_t",
                        "definition": [
                            "const size_t mask = mi_bitmap_mask_(count, bitidx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prev",
                        "type": "const size_t",
                        "definition": [
                            "const size_t prev = atomic_fetch_and_explicit(&bitmap[idx], ~mask, memory_order_acq_rel)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_bitmap_try_claim",
            "header": "bool _mi_bitmap_try_claim(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx)",
            "params": [
                "mi_bitmap_t bitmap",
                "size_t bitmap_fields",
                "size_t count",
                "mi_bitmap_index_t bitmap_idx"
            ],
            "definition": "bool _mi_bitmap_try_claim(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx)\n{\n  const size_t idx = mi_bitmap_index_field(bitmap_idx);\n  const size_t bitidx = mi_bitmap_index_bit_in_field(bitmap_idx);\n  const size_t mask = mi_bitmap_mask_(count, bitidx);\n  (bitmap_fields > idx) ? ((void) 0) : (_mi_assert_fail(\"bitmap_fields > idx\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 173, __func__));\n  (void) bitmap_fields;\n  size_t expected = atomic_load_explicit(&bitmap[idx], memory_order_relaxed);\n  do\n  {\n    if ((expected & mask) != 0)\n    {\n      return 0;\n    }\n  }\n  while (!atomic_compare_exchange_strong_explicit(&bitmap[idx], &expected, expected | mask, memory_order_acq_rel, memory_order_acquire));\n  ((expected & mask) == 0) ? ((void) 0) : (_mi_assert_fail(\"(expected & mask) == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 179, __func__));\n  return 1;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "atomic_compare_exchange_strong_explicit",
                "atomic_load_explicit",
                "mi_bitmap_index_bit_in_field",
                "mi_bitmap_index_field",
                "mi_bitmap_mask_"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap",
                        "type": "mi_bitmap_t",
                        "definition": [
                            "mi_bitmap_t bitmap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_fields",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_fields"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "const size_t",
                        "definition": [
                            "const size_t idx = mi_bitmap_index_field(bitmap_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bitidx = mi_bitmap_index_bit_in_field(bitmap_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "const size_t",
                        "definition": [
                            "const size_t mask = mi_bitmap_mask_(count, bitidx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "expected",
                        "type": "size_t",
                        "definition": [
                            "size_t expected = atomic_load_explicit(&bitmap[idx], memory_order_relaxed)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_bitmap_claim",
            "header": "bool _mi_bitmap_claim(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx, bool *any_zero)",
            "params": [
                "mi_bitmap_t bitmap",
                "size_t bitmap_fields",
                "size_t count",
                "mi_bitmap_index_t bitmap_idx",
                "bool *any_zero"
            ],
            "definition": "bool _mi_bitmap_claim(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx, bool *any_zero)\n{\n  const size_t idx = mi_bitmap_index_field(bitmap_idx);\n  const size_t bitidx = mi_bitmap_index_bit_in_field(bitmap_idx);\n  const size_t mask = mi_bitmap_mask_(count, bitidx);\n  (bitmap_fields > idx) ? ((void) 0) : (_mi_assert_fail(\"bitmap_fields > idx\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 149, __func__));\n  (void) bitmap_fields;\n  size_t prev = atomic_fetch_or_explicit(&bitmap[idx], mask, memory_order_acq_rel);\n  if (any_zero != 0)\n  {\n    *any_zero = (prev & mask) != mask;\n  }\n  return (prev & mask) == 0;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "atomic_fetch_or_explicit",
                "mi_bitmap_index_bit_in_field",
                "mi_bitmap_index_field",
                "mi_bitmap_mask_"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap",
                        "type": "mi_bitmap_t",
                        "definition": [
                            "mi_bitmap_t bitmap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_fields",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_fields"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "any_zero",
                        "type": "bool *",
                        "definition": [
                            "bool *any_zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "const size_t",
                        "definition": [
                            "const size_t idx = mi_bitmap_index_field(bitmap_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bitidx = mi_bitmap_index_bit_in_field(bitmap_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "const size_t",
                        "definition": [
                            "const size_t mask = mi_bitmap_mask_(count, bitidx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prev",
                        "type": "size_t",
                        "definition": [
                            "size_t prev = atomic_fetch_or_explicit(&bitmap[idx], mask, memory_order_acq_rel)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_bitmap_is_claimed",
            "header": "bool _mi_bitmap_is_claimed(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx)",
            "params": [
                "mi_bitmap_t bitmap",
                "size_t bitmap_fields",
                "size_t count",
                "mi_bitmap_index_t bitmap_idx"
            ],
            "definition": "bool _mi_bitmap_is_claimed(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx)\n{\n  return mi_bitmap_is_claimedx(bitmap, bitmap_fields, count, bitmap_idx, 0);\n}\n\n",
            "calle": [
                "mi_bitmap_is_claimedx"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap",
                        "type": "mi_bitmap_t",
                        "definition": [
                            "mi_bitmap_t bitmap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_fields",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_fields"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_idx"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_bitmap_is_any_claimed",
            "header": "bool _mi_bitmap_is_any_claimed(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx)",
            "params": [
                "mi_bitmap_t bitmap",
                "size_t bitmap_fields",
                "size_t count",
                "mi_bitmap_index_t bitmap_idx"
            ],
            "definition": "bool _mi_bitmap_is_any_claimed(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx)\n{\n  bool any_ones;\n  mi_bitmap_is_claimedx(bitmap, bitmap_fields, count, bitmap_idx, &any_ones);\n  return any_ones;\n}\n\n",
            "calle": [
                "mi_bitmap_is_claimedx"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap",
                        "type": "mi_bitmap_t",
                        "definition": [
                            "mi_bitmap_t bitmap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_fields",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_fields"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "any_ones",
                        "type": "bool",
                        "definition": [
                            "bool any_ones"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_bitmap_try_find_from_claim_across",
            "header": "bool _mi_bitmap_try_find_from_claim_across(mi_bitmap_t bitmap, const size_t bitmap_fields, const size_t start_field_idx, const size_t count, mi_bitmap_index_t *bitmap_idx)",
            "params": [
                "mi_bitmap_t bitmap",
                "const size_t bitmap_fields",
                "const size_t start_field_idx",
                "const size_t count",
                "mi_bitmap_index_t *bitmap_idx"
            ],
            "definition": "bool _mi_bitmap_try_find_from_claim_across(mi_bitmap_t bitmap, const size_t bitmap_fields, const size_t start_field_idx, const size_t count, mi_bitmap_index_t *bitmap_idx)\n{\n  (count > 0) ? ((void) 0) : (_mi_assert_fail(\"count > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 296, __func__));\n  if (count <= 2)\n  {\n    return _mi_bitmap_try_find_from_claim(bitmap, bitmap_fields, start_field_idx, count, bitmap_idx);\n  }\n  size_t idx = start_field_idx;\n  for (size_t visited = 0; visited < bitmap_fields; visited += 1, idx += 1)\n  {\n    if (idx >= bitmap_fields)\n    {\n      idx = 0;\n    }\n    if (mi_bitmap_try_find_claim_field_across(bitmap, bitmap_fields, idx, count, 0, bitmap_idx))\n    {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_bitmap_try_find_from_claim",
                "mi_bitmap_try_find_claim_field_across"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap",
                        "type": "mi_bitmap_t",
                        "definition": [
                            "mi_bitmap_t bitmap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_fields",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bitmap_fields"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start_field_idx",
                        "type": "const size_t",
                        "definition": [
                            "const size_t start_field_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "const size_t",
                        "definition": [
                            "const size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t *",
                        "definition": [
                            "mi_bitmap_index_t *bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t",
                        "definition": [
                            "size_t idx = start_field_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "visited",
                        "type": "size_t",
                        "definition": [
                            "size_t visited = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_bitmap_unclaim_across",
            "header": "bool _mi_bitmap_unclaim_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx)",
            "params": [
                "mi_bitmap_t bitmap",
                "size_t bitmap_fields",
                "size_t count",
                "mi_bitmap_index_t bitmap_idx"
            ],
            "definition": "bool _mi_bitmap_unclaim_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx)\n{\n  size_t idx = mi_bitmap_index_field(bitmap_idx);\n  size_t pre_mask;\n  size_t mid_mask;\n  size_t post_mask;\n  size_t mid_count = mi_bitmap_mask_across(bitmap_idx, bitmap_fields, count, &pre_mask, &mid_mask, &post_mask);\n  bool all_one = 1;\n  mi_bitmap_field_t *field = &bitmap[idx];\n  unsigned int field_idx = 0;\n  size_t prev = atomic_fetch_and_explicit(field, ~pre_mask, memory_order_acq_rel);\n  field_idx += 1;\n  if ((prev & pre_mask) != pre_mask)\n  {\n    all_one = 0;\n  }\n  while ((mid_count--) > 0)\n  {\n    prev = atomic_fetch_and_explicit(field, ~mid_mask, memory_order_acq_rel);\n    field_idx += 1;\n    if ((prev & mid_mask) != mid_mask)\n    {\n      all_one = 0;\n    }\n  }\n\n  if (post_mask != 0)\n  {\n    prev = atomic_fetch_and_explicit(field, ~post_mask, memory_order_acq_rel);\n    if ((prev & post_mask) != post_mask)\n    {\n      all_one = 0;\n    }\n  }\n  return all_one;\n}\n\n",
            "calle": [
                "atomic_fetch_and_explicit",
                "mi_bitmap_index_field",
                "mi_bitmap_mask_across"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap",
                        "type": "mi_bitmap_t",
                        "definition": [
                            "mi_bitmap_t bitmap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_fields",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_fields"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t",
                        "definition": [
                            "size_t idx = mi_bitmap_index_field(bitmap_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pre_mask",
                        "type": "size_t",
                        "definition": [
                            "size_t pre_mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mid_mask",
                        "type": "size_t",
                        "definition": [
                            "size_t mid_mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "post_mask",
                        "type": "size_t",
                        "definition": [
                            "size_t post_mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mid_count",
                        "type": "size_t",
                        "definition": [
                            "size_t mid_count = mi_bitmap_mask_across(bitmap_idx, bitmap_fields, count, &pre_mask, &mid_mask, &post_mask)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "all_one",
                        "type": "bool",
                        "definition": [
                            "bool all_one = 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "field",
                        "type": "mi_bitmap_field_t *",
                        "definition": [
                            "mi_bitmap_field_t *field = &bitmap[idx]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "field_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int field_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prev",
                        "type": "size_t",
                        "definition": [
                            "size_t prev = atomic_fetch_and_explicit(field, ~pre_mask, memory_order_acq_rel)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_bitmap_claim_across",
            "header": "bool _mi_bitmap_claim_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx, bool *pany_zero, size_t *already_set)",
            "params": [
                "mi_bitmap_t bitmap",
                "size_t bitmap_fields",
                "size_t count",
                "mi_bitmap_index_t bitmap_idx",
                "bool *pany_zero",
                "size_t *already_set"
            ],
            "definition": "bool _mi_bitmap_claim_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx, bool *pany_zero, size_t *already_set)\n{\n  size_t idx = mi_bitmap_index_field(bitmap_idx);\n  size_t pre_mask;\n  size_t mid_mask;\n  size_t post_mask;\n  size_t mid_count = mi_bitmap_mask_across(bitmap_idx, bitmap_fields, count, &pre_mask, &mid_mask, &post_mask);\n  bool all_zero = 1;\n  bool any_zero = 0;\n  size_t one_count = 0;\n  _Atomic size_t *field = &bitmap[idx];\n  unsigned int field_idx = 0;\n  size_t prev = atomic_fetch_or_explicit(field, pre_mask, memory_order_acq_rel);\n  field_idx += 1;\n  if ((prev & pre_mask) != 0)\n  {\n    all_zero = 0;\n    one_count += mi_popcount(prev & pre_mask);\n  }\n  if ((prev & pre_mask) != pre_mask)\n  {\n    any_zero = 1;\n  }\n  while ((mid_count--) > 0)\n  {\n    prev = atomic_fetch_or_explicit(field, mid_mask, memory_order_acq_rel);\n    field_idx += 1;\n    if ((prev & mid_mask) != 0)\n    {\n      all_zero = 0;\n      one_count += mi_popcount(prev & mid_mask);\n    }\n    if ((prev & mid_mask) != mid_mask)\n    {\n      any_zero = 1;\n    }\n  }\n\n  if (post_mask != 0)\n  {\n    prev = atomic_fetch_or_explicit(field, post_mask, memory_order_acq_rel);\n    if ((prev & post_mask) != 0)\n    {\n      all_zero = 0;\n      one_count += mi_popcount(prev & post_mask);\n    }\n    if ((prev & post_mask) != post_mask)\n    {\n      any_zero = 1;\n    }\n  }\n  if (pany_zero != 0)\n  {\n    *pany_zero = any_zero;\n  }\n  if (already_set != 0)\n  {\n    *already_set = one_count;\n  }\n  ;\n  ((all_zero) ? (one_count == 0) : (one_count <= count)) ? ((void) 0) : (_mi_assert_fail(\"all_zero ? one_count == 0 : one_count <= count\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 397, __func__));\n  return all_zero;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "atomic_fetch_or_explicit",
                "mi_bitmap_index_field",
                "mi_bitmap_mask_across",
                "mi_popcount"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap",
                        "type": "mi_bitmap_t",
                        "definition": [
                            "mi_bitmap_t bitmap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_fields",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_fields"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pany_zero",
                        "type": "bool *",
                        "definition": [
                            "bool *pany_zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "already_set",
                        "type": "size_t *",
                        "definition": [
                            "size_t *already_set"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t",
                        "definition": [
                            "size_t idx = mi_bitmap_index_field(bitmap_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pre_mask",
                        "type": "size_t",
                        "definition": [
                            "size_t pre_mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mid_mask",
                        "type": "size_t",
                        "definition": [
                            "size_t mid_mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "post_mask",
                        "type": "size_t",
                        "definition": [
                            "size_t post_mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mid_count",
                        "type": "size_t",
                        "definition": [
                            "size_t mid_count = mi_bitmap_mask_across(bitmap_idx, bitmap_fields, count, &pre_mask, &mid_mask, &post_mask)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "all_zero",
                        "type": "bool",
                        "definition": [
                            "bool all_zero = 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "any_zero",
                        "type": "bool",
                        "definition": [
                            "bool any_zero = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "one_count",
                        "type": "size_t",
                        "definition": [
                            "size_t one_count = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "field",
                        "type": "_Atomic size_t *",
                        "definition": [
                            "_Atomic size_t *field = &bitmap[idx]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "field_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int field_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prev",
                        "type": "size_t",
                        "definition": [
                            "size_t prev = atomic_fetch_or_explicit(field, pre_mask, memory_order_acq_rel)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_bitmap_is_claimed_across",
            "header": "bool _mi_bitmap_is_claimed_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx, size_t *already_set)",
            "params": [
                "mi_bitmap_t bitmap",
                "size_t bitmap_fields",
                "size_t count",
                "mi_bitmap_index_t bitmap_idx",
                "size_t *already_set"
            ],
            "definition": "bool _mi_bitmap_is_claimed_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx, size_t *already_set)\n{\n  return mi_bitmap_is_claimedx_across(bitmap, bitmap_fields, count, bitmap_idx, 0, already_set);\n}\n\n",
            "calle": [
                "mi_bitmap_is_claimedx_across"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap",
                        "type": "mi_bitmap_t",
                        "definition": [
                            "mi_bitmap_t bitmap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_fields",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_fields"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "already_set",
                        "type": "size_t *",
                        "definition": [
                            "size_t *already_set"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_bitmap_is_any_claimed_across",
            "header": "bool _mi_bitmap_is_any_claimed_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx)",
            "params": [
                "mi_bitmap_t bitmap",
                "size_t bitmap_fields",
                "size_t count",
                "mi_bitmap_index_t bitmap_idx"
            ],
            "definition": "bool _mi_bitmap_is_any_claimed_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx)\n{\n  bool any_ones;\n  mi_bitmap_is_claimedx_across(bitmap, bitmap_fields, count, bitmap_idx, &any_ones, 0);\n  return any_ones;\n}\n\n",
            "calle": [
                "mi_bitmap_is_claimedx_across"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap",
                        "type": "mi_bitmap_t",
                        "definition": [
                            "mi_bitmap_t bitmap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_fields",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_fields"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "any_ones",
                        "type": "bool",
                        "definition": [
                            "bool any_ones"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_bitmap_mask_",
            "header": "",
            "params": [
                "size_t count",
                "size_t bitidx"
            ],
            "definition": "inline static size_t mi_bitmap_mask_(size_t count, size_t bitidx)\n{\n  ((count + bitidx) <= (8 * (1 << 3))) ? ((void) 0) : (_mi_assert_fail(\"count + bitidx <= MI_BITMAP_FIELD_BITS\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 29, __func__));\n  (count > 0) ? ((void) 0) : (_mi_assert_fail(\"count > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 30, __func__));\n  if (count >= (8 * (1 << 3)))\n  {\n    return ~((size_t) 0);\n  }\n  if (count == 0)\n  {\n    return 0;\n  }\n  return ((((size_t) 1) << count) - 1) << bitidx;\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitidx"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_bitmap_is_claimedx",
            "header": "",
            "params": [
                "mi_bitmap_t bitmap",
                "size_t bitmap_fields",
                "size_t count",
                "mi_bitmap_index_t bitmap_idx",
                "bool *any_ones"
            ],
            "definition": "static bool mi_bitmap_is_claimedx(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx, bool *any_ones)\n{\n  const size_t idx = mi_bitmap_index_field(bitmap_idx);\n  const size_t bitidx = mi_bitmap_index_bit_in_field(bitmap_idx);\n  const size_t mask = mi_bitmap_mask_(count, bitidx);\n  (bitmap_fields > idx) ? ((void) 0) : (_mi_assert_fail(\"bitmap_fields > idx\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 161, __func__));\n  (void) bitmap_fields;\n  const size_t field = atomic_load_explicit(&bitmap[idx], memory_order_relaxed);\n  if (any_ones != 0)\n  {\n    *any_ones = (field & mask) != 0;\n  }\n  return (field & mask) == mask;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "atomic_load_explicit",
                "mi_bitmap_index_bit_in_field",
                "mi_bitmap_index_field",
                "mi_bitmap_mask_"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap",
                        "type": "mi_bitmap_t",
                        "definition": [
                            "mi_bitmap_t bitmap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_fields",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_fields"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "any_ones",
                        "type": "bool *",
                        "definition": [
                            "bool *any_ones"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "const size_t",
                        "definition": [
                            "const size_t idx = mi_bitmap_index_field(bitmap_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bitidx = mi_bitmap_index_bit_in_field(bitmap_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "const size_t",
                        "definition": [
                            "const size_t mask = mi_bitmap_mask_(count, bitidx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "field",
                        "type": "const size_t",
                        "definition": [
                            "const size_t field = atomic_load_explicit(&bitmap[idx], memory_order_relaxed)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_bitmap_try_find_claim_field_across",
            "header": "",
            "params": [
                "mi_bitmap_t bitmap",
                "size_t bitmap_fields",
                "size_t idx",
                "const size_t count",
                "const size_t retries",
                "mi_bitmap_index_t *bitmap_idx"
            ],
            "definition": "static bool mi_bitmap_try_find_claim_field_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t idx, const size_t count, const size_t retries, mi_bitmap_index_t *bitmap_idx)\n{\n  (bitmap_idx != 0) ? ((void) 0) : (_mi_assert_fail(\"bitmap_idx != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 205, __func__));\n  mi_bitmap_field_t *field = &bitmap[idx];\n  unsigned int field_idx = 0;\n  size_t map = atomic_load_explicit(field, memory_order_relaxed);\n  const size_t initial = mi_clz(map);\n  (initial <= (8 * (1 << 3))) ? ((void) 0) : (_mi_assert_fail(\"initial <= MI_BITMAP_FIELD_BITS\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 211, __func__));\n  if (initial == 0)\n  {\n    return 0;\n  }\n  if (initial >= count)\n  {\n    return _mi_bitmap_try_find_claim_field(bitmap, idx, count, bitmap_idx);\n  }\n  if (_mi_divide_up(count - initial, 8 * (1 << 3)) >= (bitmap_fields - idx))\n  {\n    return 0;\n  }\n  size_t found = initial;\n  size_t mask = 0;\n  while (found < count)\n  {\n    field_idx += 1;\n    map = atomic_load_explicit(field, memory_order_relaxed);\n    const size_t mask_bits = ((found + (8 * (1 << 3))) <= count) ? (8 * (1 << 3)) : (count - found);\n    ((mask_bits > 0) && (mask_bits <= (8 * (1 << 3)))) ? ((void) 0) : (_mi_assert_fail(\"mask_bits > 0 && mask_bits <= MI_BITMAP_FIELD_BITS\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 223, __func__));\n    mask = mi_bitmap_mask_(mask_bits, 0);\n    if ((map & mask) != 0)\n    {\n      return 0;\n    }\n    found += mask_bits;\n  }\n\n  ((&field[field_idx]) < (&bitmap[bitmap_fields])) ? ((void) 0) : (_mi_assert_fail(\"field < &bitmap[bitmap_fields]\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 228, __func__));\n  mi_bitmap_field_t * const final_field = field;\n  const size_t final_mask = mask;\n  mi_bitmap_field_t * const initial_field = &bitmap[idx];\n  const size_t initial_idx = (8 * (1 << 3)) - initial;\n  const size_t initial_mask = mi_bitmap_mask_(initial, initial_idx);\n  size_t newmap;\n  field_idx = initial_field;\n  map = atomic_load_explicit(field, memory_order_relaxed);\n  do\n  {\n    newmap = map | initial_mask;\n    if ((map & initial_mask) != 0)\n    {\n      goto rollback;\n    }\n    ;\n  }\n  while (!atomic_compare_exchange_strong_explicit(field, &map, newmap, memory_order_acq_rel, memory_order_acquire));\n  while ((++(&field[field_idx])) < final_field)\n  {\n    newmap = ~((size_t) 0);\n    map = 0;\n    if (!atomic_compare_exchange_strong_explicit(field, &map, newmap, memory_order_acq_rel, memory_order_acquire))\n    {\n      goto rollback;\n    }\n  }\n\n  ((&field[field_idx]) == final_field) ? ((void) 0) : (_mi_assert_fail(\"field == final_field\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 255, __func__));\n  map = atomic_load_explicit(field, memory_order_relaxed);\n  do\n  {\n    newmap = map | final_mask;\n    if ((map & final_mask) != 0)\n    {\n      goto rollback;\n    }\n  }\n  while (!atomic_compare_exchange_strong_explicit(field, &map, newmap, memory_order_acq_rel, memory_order_acquire));\n  *bitmap_idx = mi_bitmap_index_create(idx, initial_idx);\n  return 1;\n  rollback:\n  while ((--(&field[field_idx])) > initial_field)\n  {\n    newmap = 0;\n    map = ~((size_t) 0);\n    (atomic_load_explicit(field, memory_order_relaxed) == map) ? ((void) 0) : (_mi_assert_fail(\"mi_atomic_load_relaxed(field) == map\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 272, __func__));\n    atomic_store_explicit(field, newmap, memory_order_release);\n  }\n\n\n  if ((&field[field_idx]) == initial_field)\n  {\n    map = atomic_load_explicit(field, memory_order_relaxed);\n    do\n    {\n      ((map & initial_mask) == initial_mask) ? ((void) 0) : (_mi_assert_fail(\"(map & initial_mask) == initial_mask\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 278, __func__));\n      newmap = map & (~initial_mask);\n    }\n    while (!atomic_compare_exchange_strong_explicit(field, &map, newmap, memory_order_acq_rel, memory_order_acquire));\n  }\n  _mi_stat_counter_increase(&_mi_stats_main.arena_rollback_count, 1);\n  if (retries <= 2)\n  {\n    return mi_bitmap_try_find_claim_field_across(bitmap, bitmap_fields, idx, count, retries + 1, bitmap_idx);\n  }\n  else\n  {\n    return 0;\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_bitmap_try_find_claim_field",
                "_mi_divide_up",
                "_mi_stat_counter_increase",
                "atomic_compare_exchange_strong_explicit",
                "atomic_load_explicit",
                "atomic_store_explicit",
                "mi_bitmap_index_create",
                "mi_bitmap_mask_",
                "mi_bitmap_try_find_claim_field_across",
                "mi_clz"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap",
                        "type": "mi_bitmap_t",
                        "definition": [
                            "mi_bitmap_t bitmap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_fields",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_fields"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t",
                        "definition": [
                            "size_t idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "const size_t",
                        "definition": [
                            "const size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "retries",
                        "type": "const size_t",
                        "definition": [
                            "const size_t retries"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t *",
                        "definition": [
                            "mi_bitmap_index_t *bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "field",
                        "type": "mi_bitmap_field_t *",
                        "definition": [
                            "mi_bitmap_field_t *field = &bitmap[idx]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "field_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int field_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "map",
                        "type": "size_t",
                        "definition": [
                            "size_t map = atomic_load_explicit(field, memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "initial",
                        "type": "const size_t",
                        "definition": [
                            "const size_t initial = mi_clz(map)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "found",
                        "type": "size_t",
                        "definition": [
                            "size_t found = initial"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "size_t",
                        "definition": [
                            "size_t mask = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask_bits",
                        "type": "const size_t",
                        "definition": [
                            "const size_t mask_bits = ((found + (8 * (1 << 3))) <= count) ? (8 * (1 << 3)) : (count - found)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "final_field",
                        "type": "mi_bitmap_field_t * const",
                        "definition": [
                            "mi_bitmap_field_t * const final_field = field"
                        ]
                    },
                    {
                        "path": null,
                        "name": "final_mask",
                        "type": "const size_t",
                        "definition": [
                            "const size_t final_mask = mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "initial_field",
                        "type": "mi_bitmap_field_t * const",
                        "definition": [
                            "mi_bitmap_field_t * const initial_field = &bitmap[idx]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "initial_idx",
                        "type": "const size_t",
                        "definition": [
                            "const size_t initial_idx = (8 * (1 << 3)) - initial"
                        ]
                    },
                    {
                        "path": null,
                        "name": "initial_mask",
                        "type": "const size_t",
                        "definition": [
                            "const size_t initial_mask = mi_bitmap_mask_(initial, initial_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newmap",
                        "type": "size_t",
                        "definition": [
                            "size_t newmap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_bitmap_mask_across",
            "header": "",
            "params": [
                "mi_bitmap_index_t bitmap_idx",
                "size_t bitmap_fields",
                "size_t count",
                "size_t *pre_mask",
                "size_t *mid_mask",
                "size_t *post_mask"
            ],
            "definition": "static size_t mi_bitmap_mask_across(mi_bitmap_index_t bitmap_idx, size_t bitmap_fields, size_t count, size_t *pre_mask, size_t *mid_mask, size_t *post_mask)\n{\n  (void) bitmap_fields;\n  const size_t bitidx = mi_bitmap_index_bit_in_field(bitmap_idx);\n  if (__builtin_expect(!(!((bitidx + count) <= (8 * (1 << 3)))), 1))\n  {\n    *pre_mask = mi_bitmap_mask_(count, bitidx);\n    *mid_mask = 0;\n    *post_mask = 0;\n    (mi_bitmap_index_field(bitmap_idx) < bitmap_fields) ? ((void) 0) : (_mi_assert_fail(\"mi_bitmap_index_field(bitmap_idx) < bitmap_fields\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 330, __func__));\n    return 0;\n  }\n  else\n  {\n    const size_t pre_bits = (8 * (1 << 3)) - bitidx;\n    (pre_bits < count) ? ((void) 0) : (_mi_assert_fail(\"pre_bits < count\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 335, __func__));\n    *pre_mask = mi_bitmap_mask_(pre_bits, bitidx);\n    count -= pre_bits;\n    const size_t mid_count = count / (8 * (1 << 3));\n    *mid_mask = ~((size_t) 0);\n    count %= 8 * (1 << 3);\n    *post_mask = (count == 0) ? (0) : (mi_bitmap_mask_(count, 0));\n    (((mi_bitmap_index_field(bitmap_idx) + mid_count) + ((count == 0) ? (0) : (1))) < bitmap_fields) ? ((void) 0) : (_mi_assert_fail(\"mi_bitmap_index_field(bitmap_idx) + mid_count + (count==0 ? 0 : 1) < bitmap_fields\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 342, __func__));\n    return mid_count;\n  }\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "mi_bitmap_index_bit_in_field",
                "mi_bitmap_index_field",
                "mi_bitmap_mask_"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_fields",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_fields"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pre_mask",
                        "type": "size_t *",
                        "definition": [
                            "size_t *pre_mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mid_mask",
                        "type": "size_t *",
                        "definition": [
                            "size_t *mid_mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "post_mask",
                        "type": "size_t *",
                        "definition": [
                            "size_t *post_mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bitidx = mi_bitmap_index_bit_in_field(bitmap_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pre_bits",
                        "type": "const size_t",
                        "definition": [
                            "const size_t pre_bits = (8 * (1 << 3)) - bitidx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mid_count",
                        "type": "const size_t",
                        "definition": [
                            "const size_t mid_count = count / (8 * (1 << 3))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_bitmap_is_claimedx_across",
            "header": "",
            "params": [
                "mi_bitmap_t bitmap",
                "size_t bitmap_fields",
                "size_t count",
                "mi_bitmap_index_t bitmap_idx",
                "bool *pany_ones",
                "size_t *already_set"
            ],
            "definition": "static bool mi_bitmap_is_claimedx_across(mi_bitmap_t bitmap, size_t bitmap_fields, size_t count, mi_bitmap_index_t bitmap_idx, bool *pany_ones, size_t *already_set)\n{\n  size_t idx = mi_bitmap_index_field(bitmap_idx);\n  size_t pre_mask;\n  size_t mid_mask;\n  size_t post_mask;\n  size_t mid_count = mi_bitmap_mask_across(bitmap_idx, bitmap_fields, count, &pre_mask, &mid_mask, &post_mask);\n  bool all_ones = 1;\n  bool any_ones = 0;\n  size_t one_count = 0;\n  mi_bitmap_field_t *field = &bitmap[idx];\n  unsigned int field_idx = 0;\n  size_t prev = atomic_load_explicit(field, memory_order_relaxed);\n  field_idx += 1;\n  if ((prev & pre_mask) != pre_mask)\n  {\n    all_ones = 0;\n  }\n  if ((prev & pre_mask) != 0)\n  {\n    any_ones = 1;\n    one_count += mi_popcount(prev & pre_mask);\n  }\n  while ((mid_count--) > 0)\n  {\n    prev = atomic_load_explicit(field, memory_order_relaxed);\n    field_idx += 1;\n    if ((prev & mid_mask) != mid_mask)\n    {\n      all_ones = 0;\n    }\n    if ((prev & mid_mask) != 0)\n    {\n      any_ones = 1;\n      one_count += mi_popcount(prev & mid_mask);\n    }\n  }\n\n  if (post_mask != 0)\n  {\n    prev = atomic_load_explicit(field, memory_order_relaxed);\n    if ((prev & post_mask) != post_mask)\n    {\n      all_ones = 0;\n    }\n    if ((prev & post_mask) != 0)\n    {\n      any_ones = 1;\n      one_count += mi_popcount(prev & post_mask);\n    }\n  }\n  if (pany_ones != 0)\n  {\n    *pany_ones = any_ones;\n  }\n  if (already_set != 0)\n  {\n    *already_set = one_count;\n  }\n  ((all_ones) ? (one_count == count) : (one_count < count)) ? ((void) 0) : (_mi_assert_fail(\"all_ones ? one_count == count : one_count < count\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/bitmap.c\", 429, __func__));\n  return all_ones;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "atomic_load_explicit",
                "mi_bitmap_index_field",
                "mi_bitmap_mask_across",
                "mi_popcount"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitmap",
                        "type": "mi_bitmap_t",
                        "definition": [
                            "mi_bitmap_t bitmap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_fields",
                        "type": "size_t",
                        "definition": [
                            "size_t bitmap_fields"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitmap_idx",
                        "type": "mi_bitmap_index_t",
                        "definition": [
                            "mi_bitmap_index_t bitmap_idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pany_ones",
                        "type": "bool *",
                        "definition": [
                            "bool *pany_ones"
                        ]
                    },
                    {
                        "path": null,
                        "name": "already_set",
                        "type": "size_t *",
                        "definition": [
                            "size_t *already_set"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t",
                        "definition": [
                            "size_t idx = mi_bitmap_index_field(bitmap_idx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pre_mask",
                        "type": "size_t",
                        "definition": [
                            "size_t pre_mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mid_mask",
                        "type": "size_t",
                        "definition": [
                            "size_t mid_mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "post_mask",
                        "type": "size_t",
                        "definition": [
                            "size_t post_mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mid_count",
                        "type": "size_t",
                        "definition": [
                            "size_t mid_count = mi_bitmap_mask_across(bitmap_idx, bitmap_fields, count, &pre_mask, &mid_mask, &post_mask)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "all_ones",
                        "type": "bool",
                        "definition": [
                            "bool all_ones = 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "any_ones",
                        "type": "bool",
                        "definition": [
                            "bool any_ones = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "one_count",
                        "type": "size_t",
                        "definition": [
                            "size_t one_count = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "field",
                        "type": "mi_bitmap_field_t *",
                        "definition": [
                            "mi_bitmap_field_t *field = &bitmap[idx]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "field_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int field_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prev",
                        "type": "size_t",
                        "definition": [
                            "size_t prev = atomic_load_explicit(field, memory_order_relaxed)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_collect",
            "header": "void mi_collect(bool force)",
            "params": [
                "bool force"
            ],
            "definition": "void mi_collect(bool force)\n{\n  mi_heap_collect(mi_prim_get_default_heap(), force);\n}\n\n",
            "calle": [
                "mi_heap_collect",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "force",
                        "type": "bool",
                        "definition": [
                            "bool force"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_new",
            "header": "mi_heap_t *mi_heap_new(void)",
            "params": [
                "void"
            ],
            "definition": "mi_heap_t *mi_heap_new(void)\n{\n  return mi_heap_new_ex(0, 1, _mi_arena_id_none());\n}\n\n",
            "calle": [
                "_mi_arena_id_none",
                "mi_heap_new_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_delete",
            "header": "void mi_heap_delete(mi_heap_t *heap)",
            "params": [
                "mi_heap_t *heap"
            ],
            "definition": "void mi_heap_delete(mi_heap_t *heap)\n{\n  (heap != 0) ? ((void) 0) : (_mi_assert_fail(\"heap != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 475, __func__));\n  (mi_heap_is_initialized(heap)) ? ((void) 0) : (_mi_assert_fail(\"mi_heap_is_initialized(heap)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 476, __func__));\n  ;\n  if ((heap == 0) || (!mi_heap_is_initialized(heap)))\n  {\n    return;\n  }\n  mi_heap_t *bheap = heap->tld->heap_backing;\n  if ((bheap != heap) && mi_heaps_are_compatible(bheap, heap))\n  {\n    mi_heap_absorb(bheap, heap);\n  }\n  else\n  {\n    _mi_heap_collect_abandon(heap);\n  }\n  (heap->page_count == 0) ? ((void) 0) : (_mi_assert_fail(\"heap->page_count==0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 489, __func__));\n  mi_heap_free(heap);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_heap_collect_abandon",
                "mi_heap_absorb",
                "mi_heap_free",
                "mi_heap_is_initialized",
                "mi_heaps_are_compatible"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bheap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *bheap = heap->tld->heap_backing"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_destroy",
            "header": "void mi_heap_destroy(mi_heap_t *heap)",
            "params": [
                "mi_heap_t *heap"
            ],
            "definition": "void mi_heap_destroy(mi_heap_t *heap)\n{\n  (heap != 0) ? ((void) 0) : (_mi_assert_fail(\"heap != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 384, __func__));\n  (mi_heap_is_initialized(heap)) ? ((void) 0) : (_mi_assert_fail(\"mi_heap_is_initialized(heap)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 385, __func__));\n  (heap->no_reclaim) ? ((void) 0) : (_mi_assert_fail(\"heap->no_reclaim\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 386, __func__));\n  ;\n  if ((heap == 0) || (!mi_heap_is_initialized(heap)))\n  {\n    return;\n  }\n  if (!heap->no_reclaim)\n  {\n    _mi_warning_message(\"'mi_heap_destroy' called but ignored as the heap was not created with 'allow_destroy' (heap at %p)\\n\", heap);\n    mi_heap_delete(heap);\n  }\n  else\n  {\n    _mi_heap_destroy_pages(heap);\n    mi_heap_free(heap);\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_heap_destroy_pages",
                "_mi_warning_message",
                "mi_heap_delete",
                "mi_heap_free",
                "mi_heap_is_initialized"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_set_default",
            "header": "mi_heap_t *mi_heap_set_default(mi_heap_t *heap)",
            "params": [
                "mi_heap_t *heap"
            ],
            "definition": "mi_heap_t *mi_heap_set_default(mi_heap_t *heap)\n{\n  (heap != 0) ? ((void) 0) : (_mi_assert_fail(\"heap != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 494, __func__));\n  (mi_heap_is_initialized(heap)) ? ((void) 0) : (_mi_assert_fail(\"mi_heap_is_initialized(heap)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 495, __func__));\n  if ((heap == 0) || (!mi_heap_is_initialized(heap)))\n  {\n    return 0;\n  }\n  ;\n  mi_heap_t *old = mi_prim_get_default_heap();\n  _mi_heap_set_default_direct(heap);\n  return old;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_heap_set_default_direct",
                "mi_heap_is_initialized",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "old",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *old = mi_prim_get_default_heap()"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_get_default",
            "header": "mi_heap_t *mi_heap_get_default(void)",
            "params": [
                "void"
            ],
            "definition": "mi_heap_t *mi_heap_get_default(void)\n{\n  mi_thread_init();\n  return mi_prim_get_default_heap();\n}\n\n",
            "calle": [
                "mi_prim_get_default_heap",
                "mi_thread_init"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_get_backing",
            "header": "mi_heap_t *mi_heap_get_backing(void)",
            "params": [
                "void"
            ],
            "definition": "mi_heap_t *mi_heap_get_backing(void)\n{\n  mi_heap_t *heap = mi_heap_get_default();\n  (heap != 0) ? ((void) 0) : (_mi_assert_fail(\"heap!=NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 211, __func__));\n  mi_heap_t *bheap = heap->tld->heap_backing;\n  (bheap != 0) ? ((void) 0) : (_mi_assert_fail(\"bheap!=NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 213, __func__));\n  (bheap->thread_id == _mi_thread_id()) ? ((void) 0) : (_mi_assert_fail(\"bheap->thread_id == _mi_thread_id()\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 214, __func__));\n  return bheap;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_thread_id",
                "mi_heap_get_default"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap = mi_heap_get_default()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bheap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *bheap = heap->tld->heap_backing"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_collect",
            "header": "void mi_heap_collect(mi_heap_t *heap, bool force)",
            "params": [
                "mi_heap_t *heap",
                "bool force"
            ],
            "definition": "void mi_heap_collect(mi_heap_t *heap, bool force)\n{\n  mi_heap_collect_ex(heap, (force) ? (MI_FORCE) : (MI_NORMAL));\n}\n\n",
            "calle": [
                "mi_heap_collect_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "force",
                        "type": "bool",
                        "definition": [
                            "bool force"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_contains_block",
            "header": "bool mi_heap_contains_block(mi_heap_t *heap, const void *p)",
            "params": [
                "mi_heap_t *heap",
                "const void *p"
            ],
            "definition": "bool mi_heap_contains_block(mi_heap_t *heap, const void *p)\n{\n  (heap != 0) ? ((void) 0) : (_mi_assert_fail(\"heap != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 521, __func__));\n  if ((heap == 0) || (!mi_heap_is_initialized(heap)))\n  {\n    return 0;\n  }\n  return heap == mi_heap_of_block(p);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_heap_is_initialized",
                "mi_heap_of_block"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_check_owned",
            "header": "bool mi_heap_check_owned(mi_heap_t *heap, const void *p)",
            "params": [
                "mi_heap_t *heap",
                "const void *p"
            ],
            "definition": "bool mi_heap_check_owned(mi_heap_t *heap, const void *p)\n{\n  (heap != 0) ? ((void) 0) : (_mi_assert_fail(\"heap != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 538, __func__));\n  if ((heap == 0) || (!mi_heap_is_initialized(heap)))\n  {\n    return 0;\n  }\n  if ((((uintptr_t) p) & ((1 << 3) - 1)) != 0)\n  {\n    return 0;\n  }\n  bool found = 0;\n  mi_heap_visit_pages(heap, &mi_heap_page_check_owned, (void *) p, &found);\n  return found;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_heap_is_initialized",
                "mi_heap_page_check_owned",
                "mi_heap_visit_pages"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "found",
                        "type": "bool",
                        "definition": [
                            "bool found = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_check_owned",
            "header": "bool mi_check_owned(const void *p)",
            "params": [
                "const void *p"
            ],
            "definition": "bool mi_check_owned(const void *p)\n{\n  return mi_heap_check_owned(mi_prim_get_default_heap(), p);\n}\n\n",
            "calle": [
                "mi_heap_check_owned",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_visit_blocks",
            "header": "bool mi_heap_visit_blocks(const mi_heap_t *heap, bool visit_blocks, mi_block_visit_fun *visitor, void *arg)",
            "params": [
                "const mi_heap_t *heap",
                "bool visit_blocks",
                "mi_block_visit_fun *visitor",
                "void *arg"
            ],
            "definition": "bool mi_heap_visit_blocks(const mi_heap_t *heap, bool visit_blocks, mi_block_visit_fun *visitor, void *arg)\n{\n  mi_visit_blocks_args_t args = {visit_blocks, visitor, arg};\n  return mi_heap_visit_areas(heap, &mi_heap_area_visitor, &args);\n}\n\n",
            "calle": [
                "mi_heap_area_visitor",
                "mi_heap_visit_areas"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "const mi_heap_t *",
                        "definition": [
                            "const mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "visit_blocks",
                        "type": "bool",
                        "definition": [
                            "bool visit_blocks"
                        ]
                    },
                    {
                        "path": null,
                        "name": "visitor",
                        "type": "mi_block_visit_fun *",
                        "definition": [
                            "mi_block_visit_fun *visitor"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "args",
                        "type": "mi_visit_blocks_args_t",
                        "definition": [
                            "mi_visit_blocks_args_t args = {visit_blocks, visitor, arg}"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_new_in_arena",
            "header": "mi_heap_t *mi_heap_new_in_arena(mi_arena_id_t arena_id)",
            "params": [
                "mi_arena_id_t arena_id"
            ],
            "definition": "mi_heap_t *mi_heap_new_in_arena(mi_arena_id_t arena_id)\n{\n  return mi_heap_new_ex(0, 0, arena_id);\n}\n\n",
            "calle": [
                "mi_heap_new_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "arena_id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t arena_id"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_new_ex",
            "header": "mi_heap_t *mi_heap_new_ex(int heap_tag, bool allow_destroy, mi_arena_id_t arena_id)",
            "params": [
                "int heap_tag",
                "bool allow_destroy",
                "mi_arena_id_t arena_id"
            ],
            "definition": "mi_heap_t *mi_heap_new_ex(int heap_tag, bool allow_destroy, mi_arena_id_t arena_id)\n{\n  mi_heap_t *bheap = mi_heap_get_backing();\n  mi_heap_t *heap = (mi_heap_t *) mi_heap_malloc(bheap, sizeof(mi_heap_t));\n  if (heap == 0)\n  {\n    return 0;\n  }\n  ((heap_tag >= 0) && (heap_tag < 256)) ? ((void) 0) : (_mi_assert_fail(\"heap_tag >= 0 && heap_tag < 256\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 244, __func__));\n  _mi_heap_init(heap, bheap->tld, arena_id, allow_destroy, (uint8_t) heap_tag);\n  return heap;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_heap_init",
                "mi_heap_get_backing",
                "mi_heap_malloc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap_tag",
                        "type": "int",
                        "definition": [
                            "int heap_tag"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_destroy",
                        "type": "bool",
                        "definition": [
                            "bool allow_destroy"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bheap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *bheap = mi_heap_get_backing()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap = (mi_heap_t *) mi_heap_malloc(bheap, sizeof(mi_heap_t))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_random_next",
            "header": "uintptr_t _mi_heap_random_next(mi_heap_t *heap)",
            "params": [
                "mi_heap_t *heap"
            ],
            "definition": "uintptr_t _mi_heap_random_next(mi_heap_t *heap)\n{\n  return _mi_random_next(&heap->random);\n}\n\n",
            "calle": [
                "_mi_random_next"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_init",
            "header": "void _mi_heap_init(mi_heap_t *heap, mi_tld_t *tld, mi_arena_id_t arena_id, bool noreclaim, uint8_t tag)",
            "params": [
                "mi_heap_t *heap",
                "mi_tld_t *tld",
                "mi_arena_id_t arena_id",
                "bool noreclaim",
                "uint8_t tag"
            ],
            "definition": "void _mi_heap_init(mi_heap_t *heap, mi_tld_t *tld, mi_arena_id_t arena_id, bool noreclaim, uint8_t tag)\n{\n  _mi_memcpy_aligned(heap, &_mi_heap_empty, sizeof(mi_heap_t));\n  heap->tld = tld;\n  heap->thread_id = _mi_thread_id();\n  heap->arena_id = arena_id;\n  heap->no_reclaim = noreclaim;\n  heap->tag = tag;\n  if (heap == tld->heap_backing)\n  {\n    _mi_random_init(&heap->random);\n  }\n  else\n  {\n    _mi_random_split(&tld->heap_backing->random, &heap->random);\n  }\n  heap->cookie = _mi_heap_random_next(heap) | 1;\n  heap->keys[0] = _mi_heap_random_next(heap);\n  heap->keys[1] = _mi_heap_random_next(heap);\n  _mi_heap_guarded_init(heap);\n  heap->next = heap->tld->heaps;\n  heap->tld->heaps = heap;\n}\n\n",
            "calle": [
                "_mi_heap_guarded_init",
                "_mi_heap_random_next",
                "_mi_memcpy_aligned",
                "_mi_random_init",
                "_mi_random_split",
                "_mi_thread_id"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_tld_t *",
                        "definition": [
                            "mi_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arena_id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "noreclaim",
                        "type": "bool",
                        "definition": [
                            "bool noreclaim"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tag",
                        "type": "uint8_t",
                        "definition": [
                            "uint8_t tag"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_empty",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_destroy_pages",
            "header": "void _mi_heap_destroy_pages(mi_heap_t *heap)",
            "params": [
                "mi_heap_t *heap"
            ],
            "definition": "void _mi_heap_destroy_pages(mi_heap_t *heap)\n{\n  mi_heap_visit_pages(heap, &_mi_heap_page_destroy, 0, 0);\n  mi_heap_reset_pages(heap);\n}\n\n",
            "calle": [
                "_mi_heap_page_destroy",
                "mi_heap_reset_pages",
                "mi_heap_visit_pages"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_collect_abandon",
            "header": "void _mi_heap_collect_abandon(mi_heap_t *heap)",
            "params": [
                "mi_heap_t *heap"
            ],
            "definition": "void _mi_heap_collect_abandon(mi_heap_t *heap)\n{\n  mi_heap_collect_ex(heap, MI_ABANDON);\n}\n\n",
            "calle": [
                "mi_heap_collect_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_memid_is_suitable",
            "header": "bool _mi_heap_memid_is_suitable(mi_heap_t *heap, mi_memid_t memid)",
            "params": [
                "mi_heap_t *heap",
                "mi_memid_t memid"
            ],
            "definition": "bool _mi_heap_memid_is_suitable(mi_heap_t *heap, mi_memid_t memid)\n{\n  return _mi_arena_memid_is_suitable(memid, heap->arena_id);\n}\n\n",
            "calle": [
                "_mi_arena_memid_is_suitable"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_unsafe_destroy_all",
            "header": "void _mi_heap_unsafe_destroy_all(mi_heap_t *heap)",
            "params": [
                "mi_heap_t *heap"
            ],
            "definition": "void _mi_heap_unsafe_destroy_all(mi_heap_t *heap)\n{\n  (heap != 0) ? ((void) 0) : (_mi_assert_fail(\"heap != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 413, __func__));\n  if (heap == 0)\n  {\n    return;\n  }\n  mi_heap_t *curr = heap->tld->heaps;\n  unsigned int curr_idx = 0;\n  while ((&curr[curr_idx]) != 0)\n  {\n    mi_heap_t *next = curr->next;\n    if (curr->no_reclaim)\n    {\n      mi_heap_destroy(curr);\n    }\n    else\n    {\n      _mi_heap_destroy_pages(curr);\n    }\n    curr_idx = next;\n  }\n\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_heap_destroy_pages",
                "mi_heap_destroy"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "curr",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *curr = heap->tld->heaps"
                        ]
                    },
                    {
                        "path": null,
                        "name": "curr_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int curr_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *next = curr->next"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_by_tag",
            "header": "mi_heap_t *_mi_heap_by_tag(mi_heap_t *heap, uint8_t tag)",
            "params": [
                "mi_heap_t *heap",
                "uint8_t tag"
            ],
            "definition": "mi_heap_t *_mi_heap_by_tag(mi_heap_t *heap, uint8_t tag)\n{\n  if (heap->tag == tag)\n  {\n    return heap;\n  }\n  for (mi_heap_t *curr = heap->tld->heaps; (&curr[curr_idx]) != 0; curr_idx = curr_idx->next)\n  {\n    if (curr->tag == tag)\n    {\n      return curr;\n    }\n  }\n\n  unsigned int curr_idx = 0;\n  return 0;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tag",
                        "type": "uint8_t",
                        "definition": [
                            "uint8_t tag"
                        ]
                    },
                    {
                        "path": null,
                        "name": "curr",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *curr = heap->tld->heaps"
                        ]
                    },
                    {
                        "path": null,
                        "name": "curr_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int curr_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_area_init",
            "header": "void _mi_heap_area_init(mi_heap_area_t *area, mi_page_t *page)",
            "params": [
                "mi_heap_area_t *area",
                "mi_page_t *page"
            ],
            "definition": "void _mi_heap_area_init(mi_heap_area_t *area, mi_page_t *page)\n{\n  const size_t bsize = mi_page_block_size(page);\n  const size_t ubsize = mi_page_usable_block_size(page);\n  area->reserved = page->reserved * bsize;\n  area->committed = page->capacity * bsize;\n  area->blocks = mi_page_start(page);\n  area->used = page->used;\n  area->block_size = ubsize;\n  area->full_block_size = bsize;\n  area->heap_tag = page->heap_tag;\n}\n\n",
            "calle": [
                "mi_page_block_size",
                "mi_page_start",
                "mi_page_usable_block_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "area",
                        "type": "mi_heap_area_t *",
                        "definition": [
                            "mi_heap_area_t *area"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bsize = mi_page_block_size(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ubsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t ubsize = mi_page_usable_block_size(page)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_area_visit_blocks",
            "header": "bool _mi_heap_area_visit_blocks(const mi_heap_area_t *area, mi_page_t *page, mi_block_visit_fun *visitor, void *arg)",
            "params": [
                "const mi_heap_area_t *area",
                "mi_page_t *page",
                "mi_block_visit_fun *visitor",
                "void *arg"
            ],
            "definition": "bool _mi_heap_area_visit_blocks(const mi_heap_area_t *area, mi_page_t *page, mi_block_visit_fun *visitor, void *arg)\n{\n  (area != 0) ? ((void) 0) : (_mi_assert_fail(\"area != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 582, __func__));\n  if (area == 0)\n  {\n    return 1;\n  }\n  (page != 0) ? ((void) 0) : (_mi_assert_fail(\"page != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 584, __func__));\n  if (page == 0)\n  {\n    return 1;\n  }\n  _mi_page_free_collect(page, 1);\n  (page->local_free == 0) ? ((void) 0) : (_mi_assert_fail(\"page->local_free == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 588, __func__));\n  if (page->used == 0)\n  {\n    return 1;\n  }\n  size_t psize;\n  uint8_t * const pstart = _mi_segment_page_start(_mi_page_segment(page), page, &psize);\n  mi_heap_t * const heap = mi_page_heap(page);\n  const size_t bsize = mi_page_block_size(page);\n  const size_t ubsize = mi_page_usable_block_size(page);\n  if (page->capacity == 1)\n  {\n    ((page->used == 1) && (page->free == 0)) ? ((void) 0) : (_mi_assert_fail(\"page->used == 1 && page->free == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 599, __func__));\n    return visitor(mi_page_heap(page), area, pstart, ubsize, arg);\n  }\n  (bsize <= UINT32_MAX) ? ((void) 0) : (_mi_assert_fail(\"bsize <= UINT32_MAX\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 602, __func__));\n  if (page->used == page->capacity)\n  {\n    uint8_t *block = pstart;\n    unsigned int block_idx = 0;\n    for (size_t i = 0; i < page->capacity; i += 1)\n    {\n      if (!visitor(heap, area, block, ubsize, arg))\n      {\n        return 0;\n      }\n      block_idx += bsize;\n    }\n\n    return 1;\n  }\n  uintptr_t free_map[((1UL << (13 + 3)) / (sizeof(void *))) / ((1 << 3) * 8)];\n  const uintptr_t bmapsize = _mi_divide_up(page->capacity, (1 << 3) * 8);\n  memset(free_map, 0, bmapsize * (sizeof(intptr_t)));\n  if ((page->capacity % ((1 << 3) * 8)) != 0)\n  {\n    size_t shift = page->capacity % ((1 << 3) * 8);\n    uintptr_t mask = UINTPTR_MAX << shift;\n    free_map[bmapsize - 1] = mask;\n  }\n  uint64_t magic;\n  size_t shift;\n  mi_get_fast_divisor(bsize, &magic, &shift);\n  size_t free_count = 0;\n  for (mi_block_t *block = page->free; (&block[block_idx]) != 0; block_idx = mi_block_next(page, block_idx))\n  {\n    helper__mi_heap_area_visit_blocks_1(&free_count, psize, pstart, bsize, block, free_map, shift, magic, shift, block, block);\n  }\n\n  unsigned int block_idx = 0;\n  (page->capacity == (free_count + page->used)) ? ((void) 0) : (_mi_assert_fail(\"page->capacity == (free_count + page->used)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 649, __func__));\n  size_t used_count = 0;\n  uint8_t *block = pstart;\n  unsigned int block_idx = 0;\n  for (size_t i = 0; i < bmapsize; i += 1)\n  {\n    helper__mi_heap_area_visit_blocks_2(&block_idx, &block_idx, &used_count, &block_idx, area, arg, heap, bsize, ubsize, block, i, free_map, block, block, i);\n  }\n\n  (page->used == used_count) ? ((void) 0) : (_mi_assert_fail(\"page->used == used_count\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 681, __func__));\n  return 1;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_divide_up",
                "_mi_page_free_collect",
                "_mi_page_segment",
                "_mi_segment_page_start",
                "helper__mi_heap_area_visit_blocks_1",
                "helper__mi_heap_area_visit_blocks_2",
                "memset",
                "mi_block_next",
                "mi_get_fast_divisor",
                "mi_page_block_size",
                "mi_page_heap",
                "mi_page_usable_block_size",
                "visitor"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "area",
                        "type": "const mi_heap_area_t *",
                        "definition": [
                            "const mi_heap_area_t *area"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "visitor",
                        "type": "mi_block_visit_fun *",
                        "definition": [
                            "mi_block_visit_fun *visitor"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "psize",
                        "type": "size_t",
                        "definition": [
                            "size_t psize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pstart",
                        "type": "uint8_t * const",
                        "definition": [
                            "uint8_t * const pstart = _mi_segment_page_start(_mi_page_segment(page), page, &psize)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t * const",
                        "definition": [
                            "mi_heap_t * const heap = mi_page_heap(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bsize = mi_page_block_size(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ubsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t ubsize = mi_page_usable_block_size(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "uint8_t *",
                        "definition": [
                            "mi_block_t *block = page->free",
                            "uint8_t *block = pstart"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int block_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "free_map",
                        "type": "uintptr_t [((1UL << (13 + 3)) / (sizeof(void *))) / ((1 << 3) * 8)]",
                        "definition": [
                            "uintptr_t free_map[((1UL << (13 + 3)) / (sizeof(void *))) / ((1 << 3) * 8)]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bmapsize",
                        "type": "const uintptr_t",
                        "definition": [
                            "const uintptr_t bmapsize = _mi_divide_up(page->capacity, (1 << 3) * 8)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "shift",
                        "type": "size_t",
                        "definition": [
                            "size_t shift",
                            "size_t shift = page->capacity % ((1 << 3) * 8)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t mask = UINTPTR_MAX << shift"
                        ]
                    },
                    {
                        "path": null,
                        "name": "magic",
                        "type": "uint64_t",
                        "definition": [
                            "uint64_t magic"
                        ]
                    },
                    {
                        "path": null,
                        "name": "free_count",
                        "type": "size_t",
                        "definition": [
                            "size_t free_count = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "used_count",
                        "type": "size_t",
                        "definition": [
                            "size_t used_count = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_visit_pages",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "heap_page_visitor_fun *fn",
                "void *arg1",
                "void *arg2"
            ],
            "definition": "static bool mi_heap_visit_pages(mi_heap_t *heap, heap_page_visitor_fun *fn, void *arg1, void *arg2)\n{\n  if ((heap == 0) || (heap->page_count == 0))\n  {\n    return 0;\n  }\n  size_t total = heap->page_count;\n  size_t count = 0;\n  for (size_t i = 0; i <= (73U + 1); i += 1)\n  {\n    mi_page_queue_t *pq = &heap->pages[i];\n    mi_page_t *page = pq->first;\n    unsigned int page_idx = 0;\n    while ((&page[page_idx]) != 0)\n    {\n      mi_page_t *next = page->next;\n      (mi_page_heap(page) == heap) ? ((void) 0) : (_mi_assert_fail(\"mi_page_heap(page) == heap\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 42, __func__));\n      count += 1;\n      if (!fn(heap, pq, page, arg1, arg2))\n      {\n        return 0;\n      }\n      page_idx = next;\n    }\n\n  }\n\n  (count == total) ? ((void) 0) : (_mi_assert_fail(\"count == total\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 50, __func__));\n  return 1;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "fn",
                "mi_page_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fn",
                        "type": "heap_page_visitor_fun *",
                        "definition": [
                            "heap_page_visitor_fun *fn"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg1",
                        "type": "void *",
                        "definition": [
                            "void *arg1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg2",
                        "type": "void *",
                        "definition": [
                            "void *arg2"
                        ]
                    },
                    {
                        "path": null,
                        "name": "total",
                        "type": "size_t",
                        "definition": [
                            "size_t total = heap->page_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq = &heap->pages[i]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = pq->first"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int page_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *next = page->next"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_page_is_valid",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "mi_page_queue_t *pq",
                "mi_page_t *page",
                "void *arg1",
                "void *arg2"
            ],
            "definition": "static bool mi_heap_page_is_valid(mi_heap_t *heap, mi_page_queue_t *pq, mi_page_t *page, void *arg1, void *arg2)\n{\n  (void) arg1;\n  (void) arg2;\n  (void) pq;\n  (mi_page_heap(page) == heap) ? ((void) 0) : (_mi_assert_fail(\"mi_page_heap(page) == heap\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 60, __func__));\n  mi_segment_t *segment = _mi_page_segment(page);\n  (atomic_load_explicit(&segment->thread_id, memory_order_relaxed) == heap->thread_id) ? ((void) 0) : (_mi_assert_fail(\"mi_atomic_load_relaxed(&segment->thread_id) == heap->thread_id\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 62, __func__));\n  ;\n  return 1;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_page_segment",
                "atomic_load_explicit",
                "mi_page_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg1",
                        "type": "void *",
                        "definition": [
                            "void *arg1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg2",
                        "type": "void *",
                        "definition": [
                            "void *arg2"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = _mi_page_segment(page)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_page_collect",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "mi_page_queue_t *pq",
                "mi_page_t *page",
                "void *arg_collect",
                "void *arg2"
            ],
            "definition": "static bool mi_heap_page_collect(mi_heap_t *heap, mi_page_queue_t *pq, mi_page_t *page, void *arg_collect, void *arg2)\n{\n  (void) arg2;\n  (void) heap;\n  (mi_heap_page_is_valid(heap, pq, page, 0, 0)) ? ((void) 0) : (_mi_assert_fail(\"mi_heap_page_is_valid(heap, pq, page, NULL, NULL)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 95, __func__));\n  mi_collect_t collect = *((mi_collect_t *) arg_collect);\n  _mi_page_free_collect(page, collect >= MI_FORCE);\n  if (collect == MI_FORCE)\n  {\n    mi_segment_t *segment = _mi_page_segment(page);\n    _mi_segment_collect(segment, 1);\n  }\n  if (mi_page_all_free(page))\n  {\n    _mi_page_free(page, pq, collect >= MI_FORCE);\n  }\n  else\n    if (collect == MI_ABANDON)\n  {\n    _mi_page_abandon(page, pq);\n  }\n  return 1;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_page_abandon",
                "_mi_page_free",
                "_mi_page_free_collect",
                "_mi_page_segment",
                "_mi_segment_collect",
                "mi_heap_page_is_valid",
                "mi_page_all_free"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg_collect",
                        "type": "void *",
                        "definition": [
                            "void *arg_collect"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg2",
                        "type": "void *",
                        "definition": [
                            "void *arg2"
                        ]
                    },
                    {
                        "path": null,
                        "name": "collect",
                        "type": "mi_collect_t",
                        "definition": [
                            "mi_collect_t collect = *((mi_collect_t *) arg_collect)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = _mi_page_segment(page)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_page_never_delayed_free",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "mi_page_queue_t *pq",
                "mi_page_t *page",
                "void *arg1",
                "void *arg2"
            ],
            "definition": "static bool mi_heap_page_never_delayed_free(mi_heap_t *heap, mi_page_queue_t *pq, mi_page_t *page, void *arg1, void *arg2)\n{\n  (void) arg1;\n  (void) arg2;\n  (void) heap;\n  (void) pq;\n  _mi_page_use_delayed_free(page, MI_NEVER_DELAYED_FREE, 0);\n  return 1;\n}\n\n",
            "calle": [
                "_mi_page_use_delayed_free"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg1",
                        "type": "void *",
                        "definition": [
                            "void *arg1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg2",
                        "type": "void *",
                        "definition": [
                            "void *arg2"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_collect_ex",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "mi_collect_t collect"
            ],
            "definition": "static void mi_heap_collect_ex(mi_heap_t *heap, mi_collect_t collect)\n{\n  if ((heap == 0) || (!mi_heap_is_initialized(heap)))\n  {\n    return;\n  }\n  const bool force = collect >= MI_FORCE;\n  _mi_deferred_free(heap, force);\n  const bool is_main_thread = _mi_is_main_thread() && (heap->thread_id == _mi_thread_id());\n  const bool force_main = (((collect >= MI_FORCE) && is_main_thread) && mi_heap_is_backing(heap)) && (!heap->no_reclaim);\n  if (force_main)\n  {\n    _mi_abandoned_reclaim_all(heap, &heap->tld->segments);\n  }\n  if (collect == MI_ABANDON)\n  {\n    mi_heap_visit_pages(heap, &mi_heap_page_never_delayed_free, 0, 0);\n  }\n  _mi_heap_delayed_free_all(heap);\n  _mi_heap_collect_retired(heap, force);\n  mi_heap_visit_pages(heap, &mi_heap_page_collect, &collect, 0);\n  ((collect != MI_ABANDON) || (atomic_load_explicit(&heap->thread_delayed_free, memory_order_acquire) == 0)) ? ((void) 0) : (_mi_assert_fail(\"collect != MI_ABANDON || mi_atomic_load_ptr_acquire(mi_block_t,&heap->thread_delayed_free) == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 164, __func__));\n  _mi_abandoned_collect(heap, collect == MI_FORCE, &heap->tld->segments);\n  if ((force && is_main_thread) && mi_heap_is_backing(heap))\n  {\n    _mi_thread_data_collect();\n  }\n  _mi_arenas_collect(collect == MI_FORCE);\n  if (collect <= MI_FORCE)\n  {\n    _mi_stats_merge_thread(heap->tld);\n  }\n}\n\n",
            "calle": [
                "_mi_abandoned_collect",
                "_mi_abandoned_reclaim_all",
                "_mi_arenas_collect",
                "_mi_assert_fail",
                "_mi_deferred_free",
                "_mi_heap_collect_retired",
                "_mi_heap_delayed_free_all",
                "_mi_is_main_thread",
                "_mi_stats_merge_thread",
                "_mi_thread_data_collect",
                "_mi_thread_id",
                "atomic_load_explicit",
                "mi_heap_is_backing",
                "mi_heap_is_initialized",
                "mi_heap_page_collect",
                "mi_heap_page_never_delayed_free",
                "mi_heap_visit_pages"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "collect",
                        "type": "mi_collect_t",
                        "definition": [
                            "mi_collect_t collect"
                        ]
                    },
                    {
                        "path": null,
                        "name": "force",
                        "type": "const bool",
                        "definition": [
                            "const bool force = collect >= MI_FORCE"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_main_thread",
                        "type": "const bool",
                        "definition": [
                            "const bool is_main_thread = _mi_is_main_thread() && (heap->thread_id == _mi_thread_id())"
                        ]
                    },
                    {
                        "path": null,
                        "name": "force_main",
                        "type": "const bool",
                        "definition": [
                            "const bool force_main = (((collect >= MI_FORCE) && is_main_thread) && mi_heap_is_backing(heap)) && (!heap->no_reclaim)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_is_default",
            "header": "",
            "params": [
                "const mi_heap_t *heap"
            ],
            "definition": "static bool mi_heap_is_default(const mi_heap_t *heap)\n{\n  return heap == mi_prim_get_default_heap();\n}\n\n",
            "calle": [
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "const mi_heap_t *",
                        "definition": [
                            "const mi_heap_t *heap"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_reset_pages",
            "header": "",
            "params": [
                "mi_heap_t *heap"
            ],
            "definition": "static void mi_heap_reset_pages(mi_heap_t *heap)\n{\n  (heap != 0) ? ((void) 0) : (_mi_assert_fail(\"heap != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 268, __func__));\n  (mi_heap_is_initialized(heap)) ? ((void) 0) : (_mi_assert_fail(\"mi_heap_is_initialized(heap)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 269, __func__));\n  memset(&heap->pages_free_direct, 0, sizeof(heap->pages_free_direct));\n  _mi_memcpy_aligned(&heap->pages, &_mi_heap_empty.pages, sizeof(heap->pages));\n  heap->thread_delayed_free = 0;\n  heap->page_count = 0;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_memcpy_aligned",
                "memset",
                "mi_heap_is_initialized"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_empty",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_free",
            "header": "",
            "params": [
                "mi_heap_t *heap"
            ],
            "definition": "static void mi_heap_free(mi_heap_t *heap)\n{\n  (heap != 0) ? ((void) 0) : (_mi_assert_fail(\"heap != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 279, __func__));\n  (mi_heap_is_initialized(heap)) ? ((void) 0) : (_mi_assert_fail(\"mi_heap_is_initialized(heap)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 280, __func__));\n  if ((heap == 0) || (!mi_heap_is_initialized(heap)))\n  {\n    return;\n  }\n  if (mi_heap_is_backing(heap))\n  {\n    return;\n  }\n  if (mi_heap_is_default(heap))\n  {\n    _mi_heap_set_default_direct(heap->tld->heap_backing);\n  }\n  mi_heap_t *prev = 0;\n  unsigned int prev_idx = 0;\n  mi_heap_t *curr = heap->tld->heaps;\n  unsigned int curr_idx = 0;\n  while (((&curr[curr_idx]) != heap) && ((&curr[curr_idx]) != 0))\n  {\n    prev_idx = &curr[curr_idx];\n    curr_idx = curr_idx->next;\n  }\n\n  ((&curr[curr_idx]) == heap) ? ((void) 0) : (_mi_assert_fail(\"curr == heap\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 297, __func__));\n  if ((&curr[curr_idx]) == heap)\n  {\n    if ((&prev[prev_idx]) != 0)\n    {\n      prev->next = heap->next;\n    }\n    else\n    {\n      heap->tld->heaps = heap->next;\n    }\n  }\n  (heap->tld->heaps != 0) ? ((void) 0) : (_mi_assert_fail(\"heap->tld->heaps != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 302, __func__));\n  mi_free(heap);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_heap_set_default_direct",
                "mi_free",
                "mi_heap_is_backing",
                "mi_heap_is_default",
                "mi_heap_is_initialized"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prev",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *prev = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prev_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int prev_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "curr",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *curr = heap->tld->heaps"
                        ]
                    },
                    {
                        "path": null,
                        "name": "curr_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int curr_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_page_destroy",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "mi_page_queue_t *pq",
                "mi_page_t *page",
                "void *arg1",
                "void *arg2"
            ],
            "definition": "static bool _mi_heap_page_destroy(mi_heap_t *heap, mi_page_queue_t *pq, mi_page_t *page, void *arg1, void *arg2)\n{\n  (void) arg1;\n  (void) arg2;\n  (void) heap;\n  (void) pq;\n  _mi_page_use_delayed_free(page, MI_NEVER_DELAYED_FREE, 0);\n  const size_t bsize = mi_page_block_size(page);\n  if (bsize > ((1UL << (3 + (13 + 3))) / 8))\n  {\n    {\n      _mi_stat_decrease(&heap->tld->stats.malloc_huge, bsize);\n    }\n  }\n  _mi_page_free_collect(page, 0);\n  const size_t inuse = page->used;\n  if (bsize <= ((1UL << (9 + (13 + 3))) / 2))\n  {\n    _mi_stat_decrease(&heap->tld->stats.malloc_normal, bsize * inuse);\n    _mi_stat_decrease(&heap->tld->stats.malloc_bins[_mi_bin(bsize)], inuse);\n  }\n  (mi_page_thread_free(page) == 0) ? ((void) 0) : (_mi_assert_fail(\"mi_page_thread_free(page) == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 358, __func__));\n  page->used = 0;\n  page->next = 0;\n  page->prev = 0;\n  _mi_segment_page_free(page, 0, &heap->tld->segments);\n  return 1;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_bin",
                "_mi_page_free_collect",
                "_mi_page_use_delayed_free",
                "_mi_segment_page_free",
                "_mi_stat_decrease",
                "mi_page_block_size",
                "mi_page_thread_free"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg1",
                        "type": "void *",
                        "definition": [
                            "void *arg1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg2",
                        "type": "void *",
                        "definition": [
                            "void *arg2"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bsize = mi_page_block_size(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "inuse",
                        "type": "const size_t",
                        "definition": [
                            "const size_t inuse = page->used"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_absorb",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "mi_heap_t *from"
            ],
            "definition": "static void mi_heap_absorb(mi_heap_t *heap, mi_heap_t *from)\n{\n  (heap != 0) ? ((void) 0) : (_mi_assert_fail(\"heap!=NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 434, __func__));\n  if ((from == 0) || (from->page_count == 0))\n  {\n    return;\n  }\n  _mi_heap_delayed_free_partial(from);\n  for (size_t i = 0; i <= (73U + 1); i += 1)\n  {\n    mi_page_queue_t *pq = &heap->pages[i];\n    mi_page_queue_t *append = &from->pages[i];\n    size_t pcount = _mi_page_queue_append(heap, pq, append);\n    heap->page_count += pcount;\n    from->page_count -= pcount;\n  }\n\n  (from->page_count == 0) ? ((void) 0) : (_mi_assert_fail(\"from->page_count == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 451, __func__));\n  _mi_heap_delayed_free_all(from);\n  (atomic_load_explicit(&from->thread_delayed_free, memory_order_relaxed) == 0) ? ((void) 0) : (_mi_assert_fail(\"mi_atomic_load_ptr_relaxed(mi_block_t,&from->thread_delayed_free) == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 459, __func__));\n  mi_heap_reset_pages(from);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_heap_delayed_free_all",
                "_mi_heap_delayed_free_partial",
                "_mi_page_queue_append",
                "atomic_load_explicit",
                "mi_heap_reset_pages"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "from",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *from"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq = &heap->pages[i]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "append",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *append = &from->pages[i]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pcount",
                        "type": "size_t",
                        "definition": [
                            "size_t pcount = _mi_page_queue_append(heap, pq, append)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heaps_are_compatible",
            "header": "",
            "params": [
                "mi_heap_t *heap1",
                "mi_heap_t *heap2"
            ],
            "definition": "static bool mi_heaps_are_compatible(mi_heap_t *heap1, mi_heap_t *heap2)\n{\n  return (heap1->tag == heap2->tag) && (heap1->arena_id == heap2->arena_id);\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap1",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap2",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap2"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_of_block",
            "header": "",
            "params": [
                "const void *p"
            ],
            "definition": "static mi_heap_t *mi_heap_of_block(const void *p)\n{\n  if (p == 0)\n  {\n    return 0;\n  }\n  mi_segment_t *segment = _mi_ptr_segment(p);\n  bool valid = _mi_ptr_cookie(segment) == segment->cookie;\n  (valid) ? ((void) 0) : (_mi_assert_fail(\"valid\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 515, __func__));\n  if (__builtin_expect(!(!(!valid)), 0))\n  {\n    return 0;\n  }\n  return mi_page_heap(_mi_segment_page_of(segment, p));\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_ptr_cookie",
                "_mi_ptr_segment",
                "_mi_segment_page_of",
                "mi_page_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = _mi_ptr_segment(p)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "valid",
                        "type": "bool",
                        "definition": [
                            "bool valid = _mi_ptr_cookie(segment) == segment->cookie"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_page_check_owned",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "mi_page_queue_t *pq",
                "mi_page_t *page",
                "void *p",
                "void *vfound"
            ],
            "definition": "static bool mi_heap_page_check_owned(mi_heap_t *heap, mi_page_queue_t *pq, mi_page_t *page, void *p, void *vfound)\n{\n  (void) heap;\n  (void) pq;\n  bool *found = (bool *) vfound;\n  void *start = mi_page_start(page);\n  void *end = ((uint8_t *) start) + (page->capacity * mi_page_block_size(page));\n  *found = (p >= start) && (p < end);\n  return !(*found);\n}\n\n",
            "calle": [
                "mi_page_block_size",
                "mi_page_start"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "vfound",
                        "type": "void *",
                        "definition": [
                            "void *vfound"
                        ]
                    },
                    {
                        "path": null,
                        "name": "found",
                        "type": "bool *",
                        "definition": [
                            "bool *found = (bool *) vfound"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "void *",
                        "definition": [
                            "void *start = mi_page_start(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "void *",
                        "definition": [
                            "void *end = ((uint8_t *) start) + (page->capacity * mi_page_block_size(page))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_get_fast_divisor",
            "header": "",
            "params": [
                "size_t divisor",
                "uint64_t *magic",
                "size_t *shift"
            ],
            "definition": "static void mi_get_fast_divisor(size_t divisor, uint64_t *magic, size_t *shift)\n{\n  ((divisor > 0) && (divisor <= UINT32_MAX)) ? ((void) 0) : (_mi_assert_fail(\"divisor > 0 && divisor <= UINT32_MAX\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 570, __func__));\n  *shift = ((1 << 3) * 8) - mi_clz(divisor - 1);\n  *magic = (((((uint64_t) 1) << 32) * ((((uint64_t) 1) << (*shift)) - divisor)) / divisor) + 1;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_clz"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "divisor",
                        "type": "size_t",
                        "definition": [
                            "size_t divisor"
                        ]
                    },
                    {
                        "path": null,
                        "name": "magic",
                        "type": "uint64_t *",
                        "definition": [
                            "uint64_t *magic"
                        ]
                    },
                    {
                        "path": null,
                        "name": "shift",
                        "type": "size_t *",
                        "definition": [
                            "size_t *shift"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_fast_divide",
            "header": "",
            "params": [
                "size_t n",
                "uint64_t magic",
                "size_t shift"
            ],
            "definition": "static size_t mi_fast_divide(size_t n, uint64_t magic, size_t shift)\n{\n  (n <= UINT32_MAX) ? ((void) 0) : (_mi_assert_fail(\"n <= UINT32_MAX\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 576, __func__));\n  const uint64_t hi = (((uint64_t) n) * magic) >> 32;\n  return (size_t) ((hi + n) >> shift);\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "n",
                        "type": "size_t",
                        "definition": [
                            "size_t n"
                        ]
                    },
                    {
                        "path": null,
                        "name": "magic",
                        "type": "uint64_t",
                        "definition": [
                            "uint64_t magic"
                        ]
                    },
                    {
                        "path": null,
                        "name": "shift",
                        "type": "size_t",
                        "definition": [
                            "size_t shift"
                        ]
                    },
                    {
                        "path": null,
                        "name": "hi",
                        "type": "const uint64_t",
                        "definition": [
                            "const uint64_t hi = (((uint64_t) n) * magic) >> 32"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_visit_areas_page",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "mi_page_queue_t *pq",
                "mi_page_t *page",
                "void *vfun",
                "void *arg"
            ],
            "definition": "static bool mi_heap_visit_areas_page(mi_heap_t *heap, mi_page_queue_t *pq, mi_page_t *page, void *vfun, void *arg)\n{\n  (void) heap;\n  (void) pq;\n  mi_heap_area_visit_fun *fun = (mi_heap_area_visit_fun *) vfun;\n  mi_heap_area_ex_t xarea;\n  xarea.page = page;\n  _mi_heap_area_init(&xarea.area, page);\n  return fun(heap, &xarea, arg);\n}\n\n",
            "calle": [
                "_mi_heap_area_init",
                "fun"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "vfun",
                        "type": "void *",
                        "definition": [
                            "void *vfun"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fun",
                        "type": "mi_heap_area_visit_fun *",
                        "definition": [
                            "mi_heap_area_visit_fun *fun = (mi_heap_area_visit_fun *) vfun"
                        ]
                    },
                    {
                        "path": null,
                        "name": "xarea",
                        "type": "mi_heap_area_ex_t",
                        "definition": [
                            "mi_heap_area_ex_t xarea"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_visit_areas",
            "header": "",
            "params": [
                "const mi_heap_t *heap",
                "mi_heap_area_visit_fun *visitor",
                "void *arg"
            ],
            "definition": "static bool mi_heap_visit_areas(const mi_heap_t *heap, mi_heap_area_visit_fun *visitor, void *arg)\n{\n  if (visitor == 0)\n  {\n    return 0;\n  }\n  return mi_heap_visit_pages((mi_heap_t *) heap, &mi_heap_visit_areas_page, (void *) visitor, arg);\n}\n\n",
            "calle": [
                "mi_heap_visit_areas_page",
                "mi_heap_visit_pages"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "const mi_heap_t *",
                        "definition": [
                            "const mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "visitor",
                        "type": "mi_heap_area_visit_fun *",
                        "definition": [
                            "mi_heap_area_visit_fun *visitor"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_area_visitor",
            "header": "",
            "params": [
                "const mi_heap_t *heap",
                "const mi_heap_area_ex_t *xarea",
                "void *arg"
            ],
            "definition": "static bool mi_heap_area_visitor(const mi_heap_t *heap, const mi_heap_area_ex_t *xarea, void *arg)\n{\n  mi_visit_blocks_args_t *args = (mi_visit_blocks_args_t *) arg;\n  if (!args->visitor(heap, &xarea->area, 0, xarea->area.block_size, args->arg))\n  {\n    return 0;\n  }\n  if (args->visit_blocks)\n  {\n    return _mi_heap_area_visit_blocks(&xarea->area, xarea->page, args->visitor, args->arg);\n  }\n  else\n  {\n    return 1;\n  }\n}\n\n",
            "calle": [
                "_mi_heap_area_visit_blocks",
                "args->visitor"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "const mi_heap_t *",
                        "definition": [
                            "const mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "xarea",
                        "type": "const mi_heap_area_ex_t *",
                        "definition": [
                            "const mi_heap_area_ex_t *xarea"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "args",
                        "type": "mi_visit_blocks_args_t *",
                        "definition": [
                            "mi_visit_blocks_args_t *args = (mi_visit_blocks_args_t *) arg"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper__mi_heap_area_visit_blocks_1",
            "header": "",
            "params": [
                "size_t * const free_count_ref",
                "size_t psize",
                "uint8_t * const pstart",
                "const size_t bsize",
                "uint8_t * const block",
                "uintptr_t free_map[((1UL << (13 + 3)) / (sizeof(void *))) / ((1 << 3) * 8)]",
                "size_t shift",
                "uint64_t magic",
                "size_t shift",
                "mi_block_t * const block",
                "uint8_t * const block"
            ],
            "definition": "void helper__mi_heap_area_visit_blocks_1(size_t * const free_count_ref, size_t psize, uint8_t * const pstart, const size_t bsize, uint8_t * const block, uintptr_t free_map[((1UL << (13 + 3)) / (sizeof(void *))) / ((1 << 3) * 8)], size_t shift, uint64_t magic, size_t shift, mi_block_t * const block, uint8_t * const block)\n{\n  size_t free_count = *free_count_ref;\n  free_count += 1;\n  ((((uint8_t *) block) >= pstart) && (((uint8_t *) block) < (pstart + psize))) ? ((void) 0) : (_mi_assert_fail(\"(uint8_t*)block >= pstart && (uint8_t*)block < (pstart + psize)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 638, __func__));\n  size_t offset = ((uint8_t *) block) - pstart;\n  ((offset % bsize) == 0) ? ((void) 0) : (_mi_assert_fail(\"offset % bsize == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 640, __func__));\n  (offset <= UINT32_MAX) ? ((void) 0) : (_mi_assert_fail(\"offset <= UINT32_MAX\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 641, __func__));\n  size_t blockidx = mi_fast_divide(offset, magic, shift);\n  (blockidx == (offset / bsize)) ? ((void) 0) : (_mi_assert_fail(\"blockidx == offset / bsize\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 643, __func__));\n  (blockidx < ((1UL << (13 + 3)) / (sizeof(void *)))) ? ((void) 0) : (_mi_assert_fail(\"blockidx < MI_MAX_BLOCKS\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/heap.c\", 644, __func__));\n  size_t bitidx = blockidx / ((1 << 3) * 8);\n  size_t bit = blockidx - (bitidx * ((1 << 3) * 8));\n  free_map[bitidx] |= ((uintptr_t) 1) << bit;\n  *free_count_ref = free_count;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_fast_divide"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "free_count_ref",
                        "type": "size_t * const",
                        "definition": [
                            "size_t * const free_count_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "psize",
                        "type": "size_t",
                        "definition": [
                            "size_t psize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pstart",
                        "type": "uint8_t * const",
                        "definition": [
                            "uint8_t * const pstart"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "uint8_t * const",
                        "definition": [
                            "mi_block_t * const block",
                            "uint8_t * const block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "free_map",
                        "type": "uintptr_t [((1UL << (13 + 3)) / (sizeof(void *))) / ((1 << 3) * 8)]",
                        "definition": [
                            "uintptr_t free_map[((1UL << (13 + 3)) / (sizeof(void *))) / ((1 << 3) * 8)]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "shift",
                        "type": "size_t",
                        "definition": [
                            "size_t shift"
                        ]
                    },
                    {
                        "path": null,
                        "name": "magic",
                        "type": "uint64_t",
                        "definition": [
                            "uint64_t magic"
                        ]
                    },
                    {
                        "path": null,
                        "name": "free_count",
                        "type": "size_t",
                        "definition": [
                            "size_t free_count = *free_count_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "size_t",
                        "definition": [
                            "size_t offset = ((uint8_t *) block) - pstart"
                        ]
                    },
                    {
                        "path": null,
                        "name": "blockidx",
                        "type": "size_t",
                        "definition": [
                            "size_t blockidx = mi_fast_divide(offset, magic, shift)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitidx = blockidx / ((1 << 3) * 8)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bit",
                        "type": "size_t",
                        "definition": [
                            "size_t bit = blockidx - (bitidx * ((1 << 3) * 8))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper__mi_heap_area_visit_blocks_2",
            "header": "",
            "params": [
                "unsigned int * const block_idx_ref",
                "unsigned int * const block_idx_ref",
                "size_t * const used_count_ref",
                "unsigned int * const block_idx_ref",
                "const mi_heap_area_t * const area",
                "void * const arg",
                "mi_heap_t * const heap",
                "const size_t bsize",
                "const size_t ubsize",
                "uint8_t * const block",
                "size_t i",
                "uintptr_t free_map[((1UL << (13 + 3)) / (sizeof(void *))) / ((1 << 3) * 8)]",
                "mi_block_t * const block",
                "uint8_t * const block",
                "size_t i"
            ],
            "definition": "bool helper__mi_heap_area_visit_blocks_2(unsigned int * const block_idx_ref, unsigned int * const block_idx_ref, size_t * const used_count_ref, unsigned int * const block_idx_ref, const mi_heap_area_t * const area, void * const arg, mi_heap_t * const heap, const size_t bsize, const size_t ubsize, uint8_t * const block, size_t i, uintptr_t free_map[((1UL << (13 + 3)) / (sizeof(void *))) / ((1 << 3) * 8)], mi_block_t * const block, uint8_t * const block, size_t i)\n{\n  unsigned int block_idx = *block_idx_ref;\n  unsigned int block_idx = *block_idx_ref;\n  size_t used_count = *used_count_ref;\n  unsigned int block_idx = *block_idx_ref;\n  if (free_map[i] == 0)\n  {\n    for (size_t j = 0; j < ((1 << 3) * 8); j += 1)\n    {\n      used_count += 1;\n      if (!visitor(heap, area, block, ubsize, arg))\n      {\n        return 0;\n      }\n      block_idx += bsize;\n    }\n\n  }\n  else\n  {\n    uintptr_t m = ~free_map[i];\n    while (m != 0)\n    {\n      used_count += 1;\n      size_t bitidx = mi_ctz(m);\n      if (!visitor(heap, area, (&block[block_idx]) + (bitidx * bsize), ubsize, arg))\n      {\n        return 0;\n      }\n      m &= m - 1;\n    }\n\n    block_idx += bsize * ((1 << 3) * 8);\n  }\n  *block_idx_ref = block_idx;\n  *block_idx_ref = block_idx;\n  *used_count_ref = used_count;\n  *block_idx_ref = block_idx;\n}\n\n",
            "calle": [
                "mi_ctz",
                "visitor"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "block_idx_ref",
                        "type": "unsigned int * const",
                        "definition": [
                            "unsigned int * const block_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "used_count_ref",
                        "type": "size_t * const",
                        "definition": [
                            "size_t * const used_count_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "area",
                        "type": "const mi_heap_area_t * const",
                        "definition": [
                            "const mi_heap_area_t * const area"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void * const",
                        "definition": [
                            "void * const arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t * const",
                        "definition": [
                            "mi_heap_t * const heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ubsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t ubsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "uint8_t * const",
                        "definition": [
                            "mi_block_t * const block",
                            "uint8_t * const block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i"
                        ]
                    },
                    {
                        "path": null,
                        "name": "free_map",
                        "type": "uintptr_t [((1UL << (13 + 3)) / (sizeof(void *))) / ((1 << 3) * 8)]",
                        "definition": [
                            "uintptr_t free_map[((1UL << (13 + 3)) / (sizeof(void *))) / ((1 << 3) * 8)]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int block_idx = *block_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "used_count",
                        "type": "size_t",
                        "definition": [
                            "size_t used_count = *used_count_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "j",
                        "type": "size_t",
                        "definition": [
                            "size_t j = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "m",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t m = ~free_map[i]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitidx = mi_ctz(m)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_process_init",
            "header": "void mi_process_init(void)",
            "params": [
                "void"
            ],
            "definition": "void mi_process_init(void)\n{\n  static mi_atomic_once_t process_init;\n  mi_heap_main_init();\n  if (!mi_atomic_once(&process_init))\n  {\n    return;\n  }\n  _mi_process_is_initialized = 1;\n  _mi_verbose_message(\"process init: 0x%zx\\n\", _mi_thread_id());\n  mi_process_setup_auto_thread_done();\n  mi_detect_cpu_features();\n  _mi_os_init();\n  mi_heap_main_init();\n  mi_thread_init();\n  mi_stats_reset();\n  ;\n  if (mi_option_is_enabled(mi_option_reserve_huge_os_pages))\n  {\n    size_t pages = mi_option_get_clamp(mi_option_reserve_huge_os_pages, 0, 128 * 1024);\n    long reserve_at = mi_option_get(mi_option_reserve_huge_os_pages_at);\n    if (reserve_at != (-1))\n    {\n      mi_reserve_huge_os_pages_at(pages, reserve_at, pages * 500);\n    }\n    else\n    {\n      mi_reserve_huge_os_pages_interleave(pages, 0, pages * 500);\n    }\n  }\n  if (mi_option_is_enabled(mi_option_reserve_os_memory))\n  {\n    long ksize = mi_option_get(mi_option_reserve_os_memory);\n    if (ksize > 0)\n    {\n      mi_reserve_os_memory(((size_t) ksize) * 1024UL, 1, 1);\n    }\n  }\n}\n\n",
            "calle": [
                "_mi_os_init",
                "_mi_thread_id",
                "_mi_verbose_message",
                "mi_atomic_once",
                "mi_detect_cpu_features",
                "mi_heap_main_init",
                "mi_option_get",
                "mi_option_get_clamp",
                "mi_option_is_enabled",
                "mi_process_setup_auto_thread_done",
                "mi_reserve_huge_os_pages_at",
                "mi_reserve_huge_os_pages_interleave",
                "mi_reserve_os_memory",
                "mi_stats_reset",
                "mi_thread_init"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "process_init",
                        "type": "mi_atomic_once_t",
                        "definition": [
                            "static mi_atomic_once_t process_init"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pages",
                        "type": "size_t",
                        "definition": [
                            "size_t pages = mi_option_get_clamp(mi_option_reserve_huge_os_pages, 0, 128 * 1024)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "reserve_at",
                        "type": "long",
                        "definition": [
                            "long reserve_at = mi_option_get(mi_option_reserve_huge_os_pages_at)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ksize",
                        "type": "long",
                        "definition": [
                            "long ksize = mi_option_get(mi_option_reserve_os_memory)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_process_is_initialized",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_process_done",
            "header": "void mi_process_done(void)",
            "params": [
                "void"
            ],
            "definition": "void mi_process_done(void)\n{\n  if (!_mi_process_is_initialized)\n  {\n    return;\n  }\n  static bool process_done = 0;\n  if (process_done)\n  {\n    return;\n  }\n  process_done = 1;\n  mi_heap_t *heap = mi_prim_get_default_heap();\n  (heap != 0) ? ((void) 0) : (_mi_assert_fail(\"heap != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/init.c\", 678, __func__));\n  _mi_prim_thread_done_auto_done();\n  mi_heap_collect(heap, 1);\n  if (mi_option_is_enabled(mi_option_destroy_on_exit))\n  {\n    mi_heap_collect(heap, 1);\n    _mi_heap_unsafe_destroy_all(heap);\n    _mi_arena_unsafe_destroy_all();\n    _mi_segment_map_unsafe_destroy();\n  }\n  if (mi_option_is_enabled(mi_option_show_stats) || mi_option_is_enabled(mi_option_verbose))\n  {\n    mi_stats_print(0);\n  }\n  _mi_allocator_done();\n  _mi_verbose_message(\"process done: 0x%zx\\n\", _mi_heap_main.thread_id);\n  os_preloading = 1;\n}\n\n",
            "calle": [
                "_mi_allocator_done",
                "_mi_arena_unsafe_destroy_all",
                "_mi_assert_fail",
                "_mi_heap_unsafe_destroy_all",
                "_mi_prim_thread_done_auto_done",
                "_mi_segment_map_unsafe_destroy",
                "_mi_verbose_message",
                "mi_heap_collect",
                "mi_option_is_enabled",
                "mi_prim_get_default_heap",
                "mi_stats_print"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "process_done",
                        "type": "bool",
                        "definition": [
                            "static bool process_done = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap = mi_prim_get_default_heap()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_process_is_initialized",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_main",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "os_preloading",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_thread_init",
            "header": "void mi_thread_init(void)",
            "params": [
                "void"
            ],
            "definition": "void mi_thread_init(void)\n{\n  mi_process_init();\n  if (_mi_thread_heap_init())\n  {\n    return;\n  }\n  _mi_stat_increase(&_mi_stats_main.threads, 1);\n  atomic_fetch_add_explicit(&thread_count, (uintptr_t) 1, memory_order_relaxed);\n}\n\n",
            "calle": [
                "_mi_stat_increase",
                "_mi_thread_heap_init",
                "atomic_fetch_add_explicit",
                "mi_process_init"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "thread_count",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_thread_done",
            "header": "void mi_thread_done(void)",
            "params": [
                "void"
            ],
            "definition": "void mi_thread_done(void)\n{\n  _mi_thread_done(0);\n}\n\n",
            "calle": [
                "_mi_thread_done"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_is_redirected",
            "header": "bool mi_is_redirected(void)",
            "params": [
                "void"
            ],
            "definition": "bool mi_is_redirected(void)\n{\n  return _mi_is_redirected();\n}\n\n",
            "calle": [
                "_mi_is_redirected"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_subproc_main",
            "header": "mi_subproc_id_t mi_subproc_main(void)",
            "params": [
                "void"
            ],
            "definition": "mi_subproc_id_t mi_subproc_main(void)\n{\n  return 0;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_subproc_new",
            "header": "mi_subproc_id_t mi_subproc_new(void)",
            "params": [
                "void"
            ],
            "definition": "mi_subproc_id_t mi_subproc_new(void)\n{\n  mi_memid_t memid = _mi_memid_none();\n  mi_subproc_t *subproc = (mi_subproc_t *) _mi_arena_meta_zalloc(sizeof(mi_subproc_t), &memid);\n  if (subproc == 0)\n  {\n    return 0;\n  }\n  subproc->memid = memid;\n  subproc->abandoned_os_list = 0;\n  mi_lock_init(&subproc->abandoned_os_lock);\n  mi_lock_init(&subproc->abandoned_os_visit_lock);\n  return subproc;\n}\n\n",
            "calle": [
                "_mi_arena_meta_zalloc",
                "_mi_memid_none",
                "mi_lock_init"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid = _mi_memid_none()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "subproc",
                        "type": "mi_subproc_t *",
                        "definition": [
                            "mi_subproc_t *subproc = (mi_subproc_t *) _mi_arena_meta_zalloc(sizeof(mi_subproc_t), &memid)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_subproc_delete",
            "header": "void mi_subproc_delete(mi_subproc_id_t subproc)",
            "params": [
                "mi_subproc_id_t subproc_id"
            ],
            "definition": "void mi_subproc_delete(mi_subproc_id_t subproc_id)\n{\n  if (subproc_id == 0)\n  {\n    return;\n  }\n  mi_subproc_t *subproc = _mi_subproc_from_id(subproc_id);\n  bool safe_to_delete = 0;\n  for (bool _go = (mi_lock_acquire(&subproc->abandoned_os_lock), 1); _go; mi_lock_release(&subproc->abandoned_os_lock), _go = 0)\n  {\n    if (subproc->abandoned_os_list == 0)\n    {\n      safe_to_delete = 1;\n    }\n  }\n\n  if (!safe_to_delete)\n  {\n    return;\n  }\n  mi_lock_done(&subproc->abandoned_os_lock);\n  mi_lock_done(&subproc->abandoned_os_visit_lock);\n  _mi_arena_meta_free(subproc, subproc->memid, sizeof(mi_subproc_t));\n}\n\n",
            "calle": [
                "_mi_arena_meta_free",
                "_mi_subproc_from_id",
                "mi_lock_acquire",
                "mi_lock_done",
                "mi_lock_release"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "subproc_id",
                        "type": "mi_subproc_id_t",
                        "definition": [
                            "mi_subproc_id_t subproc_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "subproc",
                        "type": "mi_subproc_t *",
                        "definition": [
                            "mi_subproc_t *subproc = _mi_subproc_from_id(subproc_id)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "safe_to_delete",
                        "type": "bool",
                        "definition": [
                            "bool safe_to_delete = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_go",
                        "type": "bool",
                        "definition": [
                            "bool _go = (mi_lock_acquire(&subproc->abandoned_os_lock), 1)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_subproc_add_current_thread",
            "header": "void mi_subproc_add_current_thread(mi_subproc_id_t subproc)",
            "params": [
                "mi_subproc_id_t subproc_id"
            ],
            "definition": "void mi_subproc_add_current_thread(mi_subproc_id_t subproc_id)\n{\n  mi_heap_t *heap = mi_heap_get_default();\n  if (heap == 0)\n  {\n    return;\n  }\n  (heap->tld->segments.subproc == (&mi_subproc_default)) ? ((void) 0) : (_mi_assert_fail(\"heap->tld->segments.subproc == &mi_subproc_default\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/init.c\", 291, __func__));\n  if (heap->tld->segments.subproc != (&mi_subproc_default))\n  {\n    return;\n  }\n  heap->tld->segments.subproc = _mi_subproc_from_id(subproc_id);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_subproc_from_id",
                "mi_heap_get_default"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "subproc_id",
                        "type": "mi_subproc_id_t",
                        "definition": [
                            "mi_subproc_id_t subproc_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap = mi_heap_get_default()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_subproc_default",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_guarded_set_sample_rate",
            "header": "void mi_heap_guarded_set_sample_rate(mi_heap_t *heap, size_t sample_rate, size_t seed)",
            "params": [
                "mi_heap_t *heap",
                "size_t sample_rate",
                "size_t seed"
            ],
            "definition": "void mi_heap_guarded_set_sample_rate(mi_heap_t *heap, size_t sample_rate, size_t seed)\n{\n  (void) heap;\n  (void) sample_rate;\n  (void) seed;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "sample_rate",
                        "type": "size_t",
                        "definition": [
                            "size_t sample_rate"
                        ]
                    },
                    {
                        "path": null,
                        "name": "seed",
                        "type": "size_t",
                        "definition": [
                            "size_t seed"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_guarded_set_size_bound",
            "header": "void mi_heap_guarded_set_size_bound(mi_heap_t *heap, size_t min, size_t max)",
            "params": [
                "mi_heap_t *heap",
                "size_t min",
                "size_t max"
            ],
            "definition": "void mi_heap_guarded_set_size_bound(mi_heap_t *heap, size_t min, size_t max)\n{\n  (void) heap;\n  (void) min;\n  (void) max;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "min",
                        "type": "size_t",
                        "definition": [
                            "size_t min"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max",
                        "type": "size_t",
                        "definition": [
                            "size_t max"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_thread_set_in_threadpool",
            "header": "void mi_thread_set_in_threadpool(void)",
            "params": [
                "void"
            ],
            "definition": "void mi_thread_set_in_threadpool(void)\n{\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_auto_process_init",
            "header": "void _mi_auto_process_init(void)",
            "params": [
                "void"
            ],
            "definition": "void _mi_auto_process_init(void)\n{\n  mi_heap_main_init();\n  os_preloading = 0;\n  (_mi_is_main_thread()) ? ((void) 0) : (_mi_assert_fail(\"_mi_is_main_thread()\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/init.c\", 587, __func__));\n  _mi_options_init();\n  mi_process_setup_auto_thread_done();\n  mi_process_init();\n  if (_mi_is_redirected())\n  {\n    _mi_verbose_message(\"malloc is redirected.\\n\");\n  }\n  const char *msg = 0;\n  _mi_allocator_init(&msg);\n  if ((msg != 0) && (mi_option_is_enabled(mi_option_verbose) || mi_option_is_enabled(mi_option_show_errors)))\n  {\n    _mi_fputs(0, 0, 0, msg);\n  }\n  _mi_random_reinit_if_weak(&_mi_heap_main.random);\n}\n\n",
            "calle": [
                "_mi_allocator_init",
                "_mi_assert_fail",
                "_mi_fputs",
                "_mi_is_main_thread",
                "_mi_is_redirected",
                "_mi_options_init",
                "_mi_random_reinit_if_weak",
                "_mi_verbose_message",
                "mi_heap_main_init",
                "mi_option_is_enabled",
                "mi_process_init",
                "mi_process_setup_auto_thread_done"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "msg",
                        "type": "const char *",
                        "definition": [
                            "const char *msg = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "os_preloading",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_auto_process_done",
            "header": "void _mi_auto_process_done(void)",
            "params": [
                "void"
            ],
            "definition": "void _mi_auto_process_done(void)\n{\n  if (_mi_option_get_fast(mi_option_destroy_on_exit) > 1)\n  {\n    return;\n  }\n  mi_process_done();\n}\n\n",
            "calle": [
                "_mi_option_get_fast",
                "mi_process_done"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_is_main_thread",
            "header": "bool _mi_is_main_thread(void)",
            "params": [
                "void"
            ],
            "definition": "bool _mi_is_main_thread(void)\n{\n  return (_mi_heap_main.thread_id == 0) || (_mi_heap_main.thread_id == _mi_thread_id());\n}\n\n",
            "calle": [
                "_mi_thread_id"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_current_thread_count",
            "header": "size_t _mi_current_thread_count(void)",
            "params": [
                "void"
            ],
            "definition": "size_t _mi_current_thread_count(void)\n{\n  return atomic_load_explicit(&thread_count, memory_order_relaxed);\n}\n\n",
            "calle": [
                "atomic_load_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "thread_count",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_preloading",
            "header": "bool _mi_preloading(void)",
            "params": [
                "void"
            ],
            "definition": "bool _mi_preloading(void)\n{\n  return os_preloading;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "os_preloading",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_thread_done",
            "header": "void _mi_thread_done(mi_heap_t *heap)",
            "params": [
                "mi_heap_t *heap"
            ],
            "definition": "void _mi_thread_done(mi_heap_t *heap)\n{\n  unsigned int heap_idx = 0;\n  if ((&heap[heap_idx]) == 0)\n  {\n    heap_idx = mi_prim_get_default_heap();\n    if ((&heap[heap_idx]) == 0)\n    {\n      return;\n    }\n  }\n  if (!mi_heap_is_initialized(heap))\n  {\n    return;\n  }\n  atomic_fetch_sub_explicit(&thread_count, (uintptr_t) 1, memory_order_relaxed);\n  _mi_stat_decrease(&_mi_stats_main.threads, 1);\n  if (heap->thread_id != _mi_thread_id())\n  {\n    return;\n  }\n  if (_mi_thread_heap_done(heap))\n  {\n    return;\n  }\n}\n\n",
            "calle": [
                "_mi_stat_decrease",
                "_mi_thread_heap_done",
                "_mi_thread_id",
                "atomic_fetch_sub_explicit",
                "mi_heap_is_initialized",
                "mi_prim_get_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int heap_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "thread_count",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_thread_data_collect",
            "header": "void _mi_thread_data_collect(void)",
            "params": [
                "void"
            ],
            "definition": "void _mi_thread_data_collect(void)\n{\n  for (int i = 0; i < 32; i += 1)\n  {\n    mi_thread_data_t *td = atomic_load_explicit(&td_cache[i], memory_order_relaxed);\n    unsigned int td_idx = 0;\n    if ((&td[td_idx]) != 0)\n    {\n      td_idx = atomic_exchange_explicit(&td_cache[i], 0, memory_order_acq_rel);\n      if ((&td[td_idx]) != 0)\n      {\n        _mi_os_free(td, sizeof(mi_thread_data_t), td->memid);\n      }\n    }\n  }\n\n}\n\n",
            "calle": [
                "_mi_os_free",
                "atomic_exchange_explicit",
                "atomic_load_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "int",
                        "definition": [
                            "int i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "td",
                        "type": "mi_thread_data_t *",
                        "definition": [
                            "mi_thread_data_t *td = atomic_load_explicit(&td_cache[i], memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "td_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int td_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "td_cache",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_tld_init",
            "header": "void _mi_tld_init(mi_tld_t *tld, mi_heap_t *bheap)",
            "params": [
                "mi_tld_t *tld",
                "mi_heap_t *bheap"
            ],
            "definition": "void _mi_tld_init(mi_tld_t *tld, mi_heap_t *bheap)\n{\n  _mi_memcpy_aligned(tld, &tld_empty, sizeof(mi_tld_t));\n  tld->heap_backing = bheap;\n  tld->heaps = 0;\n  tld->segments.subproc = &mi_subproc_default;\n  tld->segments.stats = &tld->stats;\n}\n\n",
            "calle": [
                "_mi_memcpy_aligned"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_tld_t *",
                        "definition": [
                            "mi_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bheap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *bheap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld_empty",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "mi_subproc_default",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_thread_id",
            "header": "mi_threadid_t _mi_thread_id(void)",
            "params": [
                "void"
            ],
            "definition": "mi_threadid_t _mi_thread_id(void)\n{\n  return _mi_prim_thread_id();\n}\n\n",
            "calle": [
                "_mi_prim_thread_id"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_main_get",
            "header": "mi_heap_t *_mi_heap_main_get(void)",
            "params": [
                "void"
            ],
            "definition": "mi_heap_t *_mi_heap_main_get(void)\n{\n  mi_heap_main_init();\n  return &_mi_heap_main;\n}\n\n",
            "calle": [
                "mi_heap_main_init"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_subproc_from_id",
            "header": "mi_subproc_t *_mi_subproc_from_id(mi_subproc_id_t subproc_id)",
            "params": [
                "mi_subproc_id_t subproc_id"
            ],
            "definition": "mi_subproc_t *_mi_subproc_from_id(mi_subproc_id_t subproc_id)\n{\n  return (subproc_id == 0) ? (&mi_subproc_default) : ((mi_subproc_t *) subproc_id);\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "subproc_id",
                        "type": "mi_subproc_id_t",
                        "definition": [
                            "mi_subproc_id_t subproc_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_subproc_default",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_guarded_init",
            "header": "void _mi_heap_guarded_init(mi_heap_t *heap)",
            "params": [
                "mi_heap_t *heap"
            ],
            "definition": "void _mi_heap_guarded_init(mi_heap_t *heap)\n{\n  (void) heap;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_set_default_direct",
            "header": "void _mi_heap_set_default_direct(mi_heap_t *heap)",
            "params": [
                "mi_heap_t *heap"
            ],
            "definition": "void _mi_heap_set_default_direct(mi_heap_t *heap)\n{\n  (heap != 0) ? ((void) 0) : (_mi_assert_fail(\"heap != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/init.c\", 544, __func__));\n  _mi_heap_default = heap;\n  _mi_prim_thread_associate_default_heap(heap);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_prim_thread_associate_default_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_default",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_main_init",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static void mi_heap_main_init(void)\n{\n  if (_mi_heap_main.cookie == 0)\n  {\n    _mi_heap_main.thread_id = _mi_thread_id();\n    _mi_heap_main.cookie = 1;\n    _mi_random_init(&_mi_heap_main.random);\n    _mi_heap_main.cookie = _mi_heap_random_next(&_mi_heap_main);\n    _mi_heap_main.keys[0] = _mi_heap_random_next(&_mi_heap_main);\n    _mi_heap_main.keys[1] = _mi_heap_random_next(&_mi_heap_main);\n    mi_lock_init(&mi_subproc_default.abandoned_os_lock);\n    mi_lock_init(&mi_subproc_default.abandoned_os_visit_lock);\n    _mi_heap_guarded_init(&_mi_heap_main);\n  }\n}\n\n",
            "calle": [
                "_mi_heap_guarded_init",
                "_mi_heap_random_next",
                "_mi_random_init",
                "_mi_thread_id",
                "mi_lock_init"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_main",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "mi_subproc_default",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_thread_data_zalloc",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static mi_thread_data_t *mi_thread_data_zalloc(void)\n{\n  mi_thread_data_t *td = 0;\n  unsigned int td_idx = 0;\n  for (int i = 0; i < 32; i += 1)\n  {\n    td_idx = atomic_load_explicit(&td_cache[i], memory_order_relaxed);\n    if ((&td[td_idx]) != 0)\n    {\n      td_idx = atomic_exchange_explicit(&td_cache[i], 0, memory_order_acq_rel);\n      if ((&td[td_idx]) != 0)\n      {\n        _mi_memzero(td, offsetof(mi_thread_data_t, memid));\n        return td;\n      }\n    }\n  }\n\n  mi_memid_t memid;\n  td_idx = (mi_thread_data_t *) _mi_os_zalloc(sizeof(mi_thread_data_t), &memid);\n  if ((&td[td_idx]) == 0)\n  {\n    td_idx = (mi_thread_data_t *) _mi_os_zalloc(sizeof(mi_thread_data_t), &memid);\n    if ((&td[td_idx]) == 0)\n    {\n      _mi_error_message(12, \"unable to allocate thread local heap metadata (%zu bytes)\\n\", sizeof(mi_thread_data_t));\n      return 0;\n    }\n  }\n  td->memid = memid;\n  return td;\n}\n\n",
            "calle": [
                "_mi_error_message",
                "_mi_memzero",
                "_mi_os_zalloc",
                "atomic_exchange_explicit",
                "atomic_load_explicit",
                "offsetof"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "td",
                        "type": "mi_thread_data_t *",
                        "definition": [
                            "mi_thread_data_t *td = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "td_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int td_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "int",
                        "definition": [
                            "int i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "td_cache",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_thread_data_free",
            "header": "",
            "params": [
                "mi_thread_data_t *tdfree"
            ],
            "definition": "static void mi_thread_data_free(mi_thread_data_t *tdfree)\n{\n  for (int i = 0; i < 32; i += 1)\n  {\n    mi_thread_data_t *td = atomic_load_explicit(&td_cache[i], memory_order_relaxed);\n    if (td == 0)\n    {\n      mi_thread_data_t *expected = 0;\n      if (atomic_compare_exchange_weak_explicit(&td_cache[i], &expected, tdfree, memory_order_acq_rel, memory_order_acquire))\n      {\n        return;\n      }\n    }\n  }\n\n  _mi_os_free(tdfree, sizeof(mi_thread_data_t), tdfree->memid);\n}\n\n",
            "calle": [
                "_mi_os_free",
                "atomic_compare_exchange_weak_explicit",
                "atomic_load_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "tdfree",
                        "type": "mi_thread_data_t *",
                        "definition": [
                            "mi_thread_data_t *tdfree"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "int",
                        "definition": [
                            "int i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "td",
                        "type": "mi_thread_data_t *",
                        "definition": [
                            "mi_thread_data_t *td = atomic_load_explicit(&td_cache[i], memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "expected",
                        "type": "mi_thread_data_t *",
                        "definition": [
                            "mi_thread_data_t *expected = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "td_cache",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_thread_heap_init",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static bool _mi_thread_heap_init(void)\n{\n  if (mi_heap_is_initialized(mi_prim_get_default_heap()))\n  {\n    return 1;\n  }\n  if (_mi_is_main_thread())\n  {\n    mi_heap_main_init();\n    _mi_heap_set_default_direct(&_mi_heap_main);\n  }\n  else\n  {\n    mi_thread_data_t *td = mi_thread_data_zalloc();\n    if (td == 0)\n    {\n      return 0;\n    }\n    mi_tld_t *tld = &td->tld;\n    mi_heap_t *heap = &td->heap;\n    _mi_tld_init(tld, heap);\n    _mi_heap_init(heap, tld, _mi_arena_id_none(), 0, 0);\n    _mi_heap_set_default_direct(heap);\n  }\n  return 0;\n}\n\n",
            "calle": [
                "_mi_arena_id_none",
                "_mi_heap_init",
                "_mi_heap_set_default_direct",
                "_mi_is_main_thread",
                "_mi_tld_init",
                "mi_heap_is_initialized",
                "mi_heap_main_init",
                "mi_prim_get_default_heap",
                "mi_thread_data_zalloc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "td",
                        "type": "mi_thread_data_t *",
                        "definition": [
                            "mi_thread_data_t *td = mi_thread_data_zalloc()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_tld_t *",
                        "definition": [
                            "mi_tld_t *tld = &td->tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap = &td->heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_thread_heap_done",
            "header": "",
            "params": [
                "mi_heap_t *heap"
            ],
            "definition": "static bool _mi_thread_heap_done(mi_heap_t *heap)\n{\n  unsigned int heap_idx = 0;\n  if (!mi_heap_is_initialized(heap))\n  {\n    return 1;\n  }\n  _mi_heap_set_default_direct((_mi_is_main_thread()) ? (&_mi_heap_main) : ((mi_heap_t *) (&_mi_heap_empty)));\n  heap_idx = heap_idx->tld->heap_backing;\n  if (!mi_heap_is_initialized(heap))\n  {\n    return 0;\n  }\n  mi_heap_t *curr = heap->tld->heaps;\n  unsigned int curr_idx = 0;\n  while ((&curr[curr_idx]) != 0)\n  {\n    mi_heap_t *next = curr->next;\n    if ((&curr[curr_idx]) != (&heap[heap_idx]))\n    {\n      (!mi_heap_is_backing(curr)) ? ((void) 0) : (_mi_assert_fail(\"!mi_heap_is_backing(curr)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/init.c\", 426, __func__));\n      mi_heap_delete(curr);\n    }\n    curr_idx = next;\n  }\n\n  ((heap->tld->heaps == (&heap[heap_idx])) && (heap->next == 0)) ? ((void) 0) : (_mi_assert_fail(\"heap->tld->heaps == heap && heap->next == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/init.c\", 431, __func__));\n  (mi_heap_is_backing(heap)) ? ((void) 0) : (_mi_assert_fail(\"mi_heap_is_backing(heap)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/init.c\", 432, __func__));\n  if ((&heap[heap_idx]) != (&_mi_heap_main))\n  {\n    _mi_heap_collect_abandon(heap);\n  }\n  _mi_stats_done(&heap->tld->stats);\n  if ((&heap[heap_idx]) != (&_mi_heap_main))\n  {\n    mi_thread_data_free((mi_thread_data_t *) heap);\n  }\n  else\n  {\n  }\n  return 0;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_heap_collect_abandon",
                "_mi_heap_set_default_direct",
                "_mi_is_main_thread",
                "_mi_stats_done",
                "mi_heap_delete",
                "mi_heap_is_backing",
                "mi_heap_is_initialized",
                "mi_thread_data_free"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int heap_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "curr",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *curr = heap->tld->heaps"
                        ]
                    },
                    {
                        "path": null,
                        "name": "curr_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int curr_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *next = curr->next"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_main",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_empty",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_process_setup_auto_thread_done",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static void mi_process_setup_auto_thread_done(void)\n{\n  static bool tls_initialized = 0;\n  if (tls_initialized)\n  {\n    return;\n  }\n  tls_initialized = 1;\n  _mi_prim_thread_init_auto_done();\n  _mi_heap_set_default_direct(&_mi_heap_main);\n}\n\n",
            "calle": [
                "_mi_heap_set_default_direct",
                "_mi_prim_thread_init_auto_done"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tls_initialized",
                        "type": "bool",
                        "definition": [
                            "static bool tls_initialized = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_detect_cpu_features",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static void mi_detect_cpu_features(void)\n{\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_vsnprintf",
            "header": "int _mi_vsnprintf(char *buf, size_t bufsize, const char *fmt, va_list args)",
            "params": [
                "char *buf",
                "size_t bufsize",
                "const char *fmt",
                "va_list args"
            ],
            "definition": "int _mi_vsnprintf(char *buf, size_t bufsize, const char *fmt, va_list args)\n{\n  if (((buf == 0) || (bufsize == 0)) || (fmt == 0))\n  {\n    return 0;\n  }\n  buf[bufsize - 1] = 0;\n  char * const end = buf + (bufsize - 1);\n  const char *in = fmt;\n  unsigned int in_idx = 0;\n  char *out = buf;\n  while (1)\n  {\n    helper__mi_vsnprintf_1(&in_idx, args, end, in, out);\n  }\n\n  (out <= end) ? ((void) 0) : (_mi_assert_fail(\"out <= end\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/libc.c\", 266, __func__));\n  *out = 0;\n  return (int) (out - buf);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "helper__mi_vsnprintf_1"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char *",
                        "definition": [
                            "char *buf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bufsize",
                        "type": "size_t",
                        "definition": [
                            "size_t bufsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fmt",
                        "type": "const char *",
                        "definition": [
                            "const char *fmt"
                        ]
                    },
                    {
                        "path": null,
                        "name": "args",
                        "type": "va_list",
                        "definition": [
                            "va_list args"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "char * const",
                        "definition": [
                            "char * const end = buf + (bufsize - 1)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "in",
                        "type": "const char *",
                        "definition": [
                            "const char *in = fmt"
                        ]
                    },
                    {
                        "path": null,
                        "name": "in_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int in_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "char *",
                        "definition": [
                            "char *out = buf"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_snprintf",
            "header": "int _mi_snprintf(char *buf, size_t buflen, const char *fmt, ...)",
            "params": [
                "char *buf",
                "size_t buflen",
                "const char *fmt",
                "..."
            ],
            "definition": "int _mi_snprintf(char *buf, size_t buflen, const char *fmt, ...)\n{\n  va_list args;\n  __builtin_va_start(args);\n  const int written = _mi_vsnprintf(buf, buflen, fmt, args);\n  ;\n  return written;\n}\n\n",
            "calle": [
                "__builtin_va_start",
                "_mi_vsnprintf"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char *",
                        "definition": [
                            "char *buf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buflen",
                        "type": "size_t",
                        "definition": [
                            "size_t buflen"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fmt",
                        "type": "const char *",
                        "definition": [
                            "const char *fmt"
                        ]
                    },
                    {
                        "path": null,
                        "name": "args",
                        "type": "va_list",
                        "definition": [
                            "va_list args"
                        ]
                    },
                    {
                        "path": null,
                        "name": "written",
                        "type": "const int",
                        "definition": [
                            "const int written = _mi_vsnprintf(buf, buflen, fmt, args)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_toupper",
            "header": "char _mi_toupper(char c)",
            "params": [
                "char c"
            ],
            "definition": "char _mi_toupper(char c)\n{\n  if ((c >= 'a') && (c <= 'z'))\n  {\n    return (c - 'a') + 'A';\n  }\n  else\n    return c;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "c",
                        "type": "char",
                        "definition": [
                            "char c"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_strnicmp",
            "header": "int _mi_strnicmp(const char *s, const char *t, size_t n)",
            "params": [
                "const char *s",
                "const char *t",
                "size_t n"
            ],
            "definition": "int _mi_strnicmp(const char *s, const char *t, size_t n)\n{\n  unsigned int t_idx = 0;\n  unsigned int s_idx = 0;\n  if (n == 0)\n  {\n    return 0;\n  }\n  for (; ((s[s_idx] != 0) && (t[t_idx] != 0)) && (n > 0); s_idx += 1, t_idx += 1, n -= 1)\n  {\n    if (_mi_toupper(*(&s[s_idx])) != _mi_toupper(*(&t[t_idx])))\n    {\n      break;\n    }\n  }\n\n  return (n == 0) ? (0) : (s[s_idx] - t[t_idx]);\n}\n\n",
            "calle": [
                "_mi_toupper"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "s",
                        "type": "const char *",
                        "definition": [
                            "const char *s"
                        ]
                    },
                    {
                        "path": null,
                        "name": "t",
                        "type": "const char *",
                        "definition": [
                            "const char *t"
                        ]
                    },
                    {
                        "path": null,
                        "name": "n",
                        "type": "size_t",
                        "definition": [
                            "size_t n"
                        ]
                    },
                    {
                        "path": null,
                        "name": "t_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int t_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "s_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int s_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_strlcpy",
            "header": "void _mi_strlcpy(char *dest, const char *src, size_t dest_size)",
            "params": [
                "char *dest",
                "const char *src",
                "size_t dest_size"
            ],
            "definition": "void _mi_strlcpy(char *dest, const char *src, size_t dest_size)\n{\n  unsigned int src_idx = 0;\n  unsigned int dest_idx = 0;\n  if ((((&dest[dest_idx]) == 0) || ((&src[src_idx]) == 0)) || (dest_size == 0))\n  {\n    return;\n  }\n  while ((src[src_idx] != 0) && (dest_size > 1))\n  {\n    dest[dest_idx] = src[src_idx];\n    src_idx += 1;\n    dest_idx += 1;\n    dest_size -= 1;\n  }\n\n  dest[dest_idx] = 0;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "dest",
                        "type": "char *",
                        "definition": [
                            "char *dest"
                        ]
                    },
                    {
                        "path": null,
                        "name": "src",
                        "type": "const char *",
                        "definition": [
                            "const char *src"
                        ]
                    },
                    {
                        "path": null,
                        "name": "dest_size",
                        "type": "size_t",
                        "definition": [
                            "size_t dest_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "src_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int src_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "dest_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int dest_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_strlcat",
            "header": "void _mi_strlcat(char *dest, const char *src, size_t dest_size)",
            "params": [
                "char *dest",
                "const char *src",
                "size_t dest_size"
            ],
            "definition": "void _mi_strlcat(char *dest, const char *src, size_t dest_size)\n{\n  unsigned int dest_idx = 0;\n  if ((((&dest[dest_idx]) == 0) || (src == 0)) || (dest_size == 0))\n  {\n    return;\n  }\n  while ((dest[dest_idx] != 0) && (dest_size > 1))\n  {\n    dest_idx += 1;\n    dest_size -= 1;\n  }\n\n  _mi_strlcpy(dest, src, dest_size);\n}\n\n",
            "calle": [
                "_mi_strlcpy"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "dest",
                        "type": "char *",
                        "definition": [
                            "char *dest"
                        ]
                    },
                    {
                        "path": null,
                        "name": "src",
                        "type": "const char *",
                        "definition": [
                            "const char *src"
                        ]
                    },
                    {
                        "path": null,
                        "name": "dest_size",
                        "type": "size_t",
                        "definition": [
                            "size_t dest_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "dest_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int dest_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_strlen",
            "header": "size_t _mi_strlen(const char *s)",
            "params": [
                "const char *s"
            ],
            "definition": "size_t _mi_strlen(const char *s)\n{\n  if (s == 0)\n  {\n    return 0;\n  }\n  size_t len = 0;\n  while (s[len] != 0)\n  {\n    len += 1;\n  }\n\n  return len;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "s",
                        "type": "const char *",
                        "definition": [
                            "const char *s"
                        ]
                    },
                    {
                        "path": null,
                        "name": "len",
                        "type": "size_t",
                        "definition": [
                            "size_t len = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_strnlen",
            "header": "size_t _mi_strnlen(const char *s, size_t max_len)",
            "params": [
                "const char *s",
                "size_t max_len"
            ],
            "definition": "size_t _mi_strnlen(const char *s, size_t max_len)\n{\n  if (s == 0)\n  {\n    return 0;\n  }\n  size_t len = 0;\n  while ((s[len] != 0) && (len < max_len))\n  {\n    len += 1;\n  }\n\n  return len;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "s",
                        "type": "const char *",
                        "definition": [
                            "const char *s"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max_len",
                        "type": "size_t",
                        "definition": [
                            "size_t max_len"
                        ]
                    },
                    {
                        "path": null,
                        "name": "len",
                        "type": "size_t",
                        "definition": [
                            "size_t len = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_getenv",
            "header": "bool _mi_getenv(const char *name, char *result, size_t result_size)",
            "params": [
                "const char *name",
                "char *result",
                "size_t result_size"
            ],
            "definition": "bool _mi_getenv(const char *name, char *result, size_t result_size)\n{\n  if (((name == 0) || (result == 0)) || (result_size < 64))\n  {\n    return 0;\n  }\n  return _mi_prim_getenv(name, result, result_size);\n}\n\n",
            "calle": [
                "_mi_prim_getenv"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "name",
                        "type": "const char *",
                        "definition": [
                            "const char *name"
                        ]
                    },
                    {
                        "path": null,
                        "name": "result",
                        "type": "char *",
                        "definition": [
                            "char *result"
                        ]
                    },
                    {
                        "path": null,
                        "name": "result_size",
                        "type": "size_t",
                        "definition": [
                            "size_t result_size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_popcount_generic",
            "header": "size_t _mi_popcount_generic(size_t x)",
            "params": [
                "size_t x"
            ],
            "definition": "size_t _mi_popcount_generic(size_t x)\n{\n  return mi_popcount_generic64(x);\n}\n\n",
            "calle": [
                "mi_popcount_generic64"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "x",
                        "type": "size_t",
                        "definition": [
                            "size_t x"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_outc",
            "header": "",
            "params": [
                "char c",
                "char **out",
                "char *end"
            ],
            "definition": "static void mi_outc(char c, char **out, char *end)\n{\n  char *p = *out;\n  if (p >= end)\n  {\n    return;\n  }\n  *p = c;\n  *out = p + 1;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "c",
                        "type": "char",
                        "definition": [
                            "char c"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "char **",
                        "definition": [
                            "char **out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "char *",
                        "definition": [
                            "char *end"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "char *",
                        "definition": [
                            "char *p = *out"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_outs",
            "header": "",
            "params": [
                "const char *s",
                "char **out",
                "char *end"
            ],
            "definition": "static void mi_outs(const char *s, char **out, char *end)\n{\n  unsigned int s_idx = 0;\n  if ((&s[s_idx]) == 0)\n  {\n    return;\n  }\n  char *p = *out;\n  unsigned int p_idx = 0;\n  while ((s[s_idx] != 0) && ((&p[p_idx]) < end))\n  {\n    p[p_idx] = s[s_idx];\n    s_idx += 1;\n    p_idx += 1;\n  }\n\n  *out = &p[p_idx];\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "s",
                        "type": "const char *",
                        "definition": [
                            "const char *s"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "char **",
                        "definition": [
                            "char **out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "char *",
                        "definition": [
                            "char *end"
                        ]
                    },
                    {
                        "path": null,
                        "name": "s_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int s_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "char *",
                        "definition": [
                            "char *p = *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int p_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_out_fill",
            "header": "",
            "params": [
                "char fill",
                "size_t len",
                "char **out",
                "char *end"
            ],
            "definition": "static void mi_out_fill(char fill, size_t len, char **out, char *end)\n{\n  char *p = *out;\n  unsigned int p_idx = 0;\n  for (size_t i = 0; (i < len) && ((&p[p_idx]) < end); i += 1)\n  {\n    p[p_idx] = fill;\n    p_idx += 1;\n  }\n\n  *out = &p[p_idx];\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "fill",
                        "type": "char",
                        "definition": [
                            "char fill"
                        ]
                    },
                    {
                        "path": null,
                        "name": "len",
                        "type": "size_t",
                        "definition": [
                            "size_t len"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "char **",
                        "definition": [
                            "char **out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "char *",
                        "definition": [
                            "char *end"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "char *",
                        "definition": [
                            "char *p = *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int p_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_out_alignright",
            "header": "",
            "params": [
                "char fill",
                "char *start",
                "size_t len",
                "size_t extra",
                "char *end"
            ],
            "definition": "static void mi_out_alignright(char fill, char *start, size_t len, size_t extra, char *end)\n{\n  if ((len == 0) || (extra == 0))\n  {\n    return;\n  }\n  if (((start + len) + extra) >= end)\n  {\n    return;\n  }\n  for (size_t i = 1; i <= len; i += 1)\n  {\n    start[(len + extra) - i] = start[len - i];\n  }\n\n  for (size_t i = 0; i < extra; i += 1)\n  {\n    start[i] = fill;\n  }\n\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "fill",
                        "type": "char",
                        "definition": [
                            "char fill"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "char *",
                        "definition": [
                            "char *start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "len",
                        "type": "size_t",
                        "definition": [
                            "size_t len"
                        ]
                    },
                    {
                        "path": null,
                        "name": "extra",
                        "type": "size_t",
                        "definition": [
                            "size_t extra"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "char *",
                        "definition": [
                            "char *end"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0",
                            "size_t i = 1"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_out_num",
            "header": "",
            "params": [
                "uintmax_t x",
                "size_t base",
                "char prefix",
                "char **out",
                "char *end"
            ],
            "definition": "static void mi_out_num(uintmax_t x, size_t base, char prefix, char **out, char *end)\n{\n  if (((x == 0) || (base == 0)) || (base > 16))\n  {\n    if (prefix != 0)\n    {\n      mi_outc(prefix, out, end);\n    }\n    mi_outc('0', out, end);\n  }\n  else\n  {\n    char *start = *out;\n    while (x > 0)\n    {\n      char digit = (char) (x % base);\n      mi_outc((digit <= 9) ? ('0' + digit) : (('A' + digit) - 10), out, end);\n      x = x / base;\n    }\n\n    if (prefix != 0)\n    {\n      mi_outc(prefix, out, end);\n    }\n    size_t len = (*out) - start;\n    for (size_t i = 0; i < (len / 2); i += 1)\n    {\n      char c = start[(len - i) - 1];\n      start[(len - i) - 1] = start[i];\n      start[i] = c;\n    }\n\n  }\n}\n\n",
            "calle": [
                "mi_outc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "x",
                        "type": "uintmax_t",
                        "definition": [
                            "uintmax_t x"
                        ]
                    },
                    {
                        "path": null,
                        "name": "base",
                        "type": "size_t",
                        "definition": [
                            "size_t base"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prefix",
                        "type": "char",
                        "definition": [
                            "char prefix"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "char **",
                        "definition": [
                            "char **out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "char *",
                        "definition": [
                            "char *end"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "char *",
                        "definition": [
                            "char *start = *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "digit",
                        "type": "char",
                        "definition": [
                            "char digit = (char) (x % base)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "len",
                        "type": "size_t",
                        "definition": [
                            "size_t len = (*out) - start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "c",
                        "type": "char",
                        "definition": [
                            "char c = start[(len - i) - 1]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_byte_sum64",
            "header": "",
            "params": [
                "uint64_t x"
            ],
            "definition": "static size_t mi_byte_sum64(uint64_t x)\n{\n  x += x << 8;\n  x += x << 16;\n  x += x << 32;\n  return (size_t) (x >> 56);\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "x",
                        "type": "uint64_t",
                        "definition": [
                            "uint64_t x"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_popcount_generic64",
            "header": "",
            "params": [
                "uint64_t x"
            ],
            "definition": "static size_t mi_popcount_generic64(uint64_t x)\n{\n  x = x - ((x >> 1) & 0x5555555555555555);\n  x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333);\n  x = (x + (x >> 4)) & 0x0F0F0F0F0F0F0F0F;\n  return mi_byte_sum64(x);\n}\n\n",
            "calle": [
                "mi_byte_sum64"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "x",
                        "type": "uint64_t",
                        "definition": [
                            "uint64_t x"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper__mi_vsnprintf_1",
            "header": "",
            "params": [
                "unsigned int * const in_idx_ref",
                "va_list args",
                "char * const end",
                "const char * const in",
                "char * const out"
            ],
            "definition": "void helper__mi_vsnprintf_1(unsigned int * const in_idx_ref, va_list args, char * const end, const char * const in, char * const out)\n{\n  unsigned int in_idx = *in_idx_ref;\n  if (out >= end)\n  {\n    break;\n  }\n  char c;\n  c = in[in_idx];\n  if (c == 0)\n  {\n    break;\n  }\n  in_idx += 1;\n  ;\n  if (c != '%')\n  {\n    if (((((c >= ' ') && (c <= '~')) || (c == '\\n')) || (c == '\\r')) || (c == '\\t'))\n    {\n      mi_outc(c, &out, end);\n    }\n  }\n  else\n  {\n    helper_helper__mi_vsnprintf_1_1(&in_idx, &c, args, end, in, out);\n  }\n  *in_idx_ref = in_idx;\n}\n\n",
            "calle": [
                "helper_helper__mi_vsnprintf_1_1",
                "mi_outc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "in_idx_ref",
                        "type": "unsigned int * const",
                        "definition": [
                            "unsigned int * const in_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "args",
                        "type": "va_list",
                        "definition": [
                            "va_list args"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "char * const",
                        "definition": [
                            "char * const end"
                        ]
                    },
                    {
                        "path": null,
                        "name": "in",
                        "type": "const char * const",
                        "definition": [
                            "const char * const in"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "char * const",
                        "definition": [
                            "char * const out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "in_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int in_idx = *in_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "c",
                        "type": "char",
                        "definition": [
                            "char c"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper_helper__mi_vsnprintf_1_1",
            "header": "",
            "params": [
                "unsigned int * const in_idx_ref",
                "char * const c_ref",
                "va_list args",
                "char * const end",
                "const char * const in",
                "char * const out"
            ],
            "definition": "void helper_helper__mi_vsnprintf_1_1(unsigned int * const in_idx_ref, char * const c_ref, va_list args, char * const end, const char * const in, char * const out)\n{\n  unsigned int in_idx = *in_idx_ref;\n  char c = *c_ref;\n  c = in[in_idx];\n  if (c == 0)\n  {\n    break;\n  }\n  in_idx += 1;\n  ;\n  char fill = ' ';\n  size_t width = 0;\n  char numtype = 'd';\n  char numplus = 0;\n  bool alignright = 1;\n  if ((c == '+') || (c == ' '))\n  {\n    numplus = c;\n    c = in[in_idx];\n    if (c == 0)\n    {\n      break;\n    }\n    in_idx += 1;\n    ;\n  }\n  if (c == '-')\n  {\n    alignright = 0;\n    c = in[in_idx];\n    if (c == 0)\n    {\n      break;\n    }\n    in_idx += 1;\n    ;\n  }\n  if (c == '0')\n  {\n    fill = '0';\n    c = in[in_idx];\n    if (c == 0)\n    {\n      break;\n    }\n    in_idx += 1;\n    ;\n  }\n  if ((c >= '1') && (c <= '9'))\n  {\n    helper_helper_helper__mi_vsnprintf_1_1_3(&in_idx, &c, &width, in);\n  }\n  if (((c == 'z') || (c == 't')) || (c == 'L'))\n  {\n    numtype = c;\n    c = in[in_idx];\n    if (c == 0)\n    {\n      break;\n    }\n    in_idx += 1;\n    ;\n  }\n  else\n    if (c == 'l')\n  {\n    helper_helper_helper__mi_vsnprintf_1_1_1(&in_idx, &c, &numtype, in);\n  }\n  char *start = out;\n  unsigned int start_idx = 0;\n  if (c == 's')\n  {\n    const char *s = __builtin_va_arg(args);\n    mi_outs(s, &out, end);\n  }\n  else\n    if (((c == 'p') || (c == 'x')) || (c == 'u'))\n  {\n    helper_helper_helper__mi_vsnprintf_1_1_4(&fill, &width, &start_idx, args, end, out, c, numtype, numplus);\n  }\n  else\n    if ((c == 'i') || (c == 'd'))\n  {\n    helper_helper_helper__mi_vsnprintf_1_1_2(args, end, out, numtype, numplus);\n  }\n  else\n    if ((c >= ' ') && (c <= '~'))\n  {\n    mi_outc('%', &out, end);\n    mi_outc(c, &out, end);\n  }\n  (out <= end) ? ((void) 0) : (_mi_assert_fail(\"out <= end\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/libc.c\", 255, __func__));\n  (out >= (&start[start_idx])) ? ((void) 0) : (_mi_assert_fail(\"out >= start\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/libc.c\", 256, __func__));\n  const size_t len = out - (&start[start_idx]);\n  if (len < width)\n  {\n    mi_out_fill(fill, width - len, &out, end);\n    if (alignright && (out <= end))\n    {\n      mi_out_alignright(fill, start, len, width - len, end);\n    }\n  }\n  *in_idx_ref = in_idx;\n  *c_ref = c;\n}\n\n",
            "calle": [
                "__builtin_va_arg",
                "_mi_assert_fail",
                "helper_helper_helper__mi_vsnprintf_1_1_1",
                "helper_helper_helper__mi_vsnprintf_1_1_2",
                "helper_helper_helper__mi_vsnprintf_1_1_3",
                "helper_helper_helper__mi_vsnprintf_1_1_4",
                "mi_out_alignright",
                "mi_out_fill",
                "mi_outc",
                "mi_outs"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "in_idx_ref",
                        "type": "unsigned int * const",
                        "definition": [
                            "unsigned int * const in_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "c_ref",
                        "type": "char * const",
                        "definition": [
                            "char * const c_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "args",
                        "type": "va_list",
                        "definition": [
                            "va_list args"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "char * const",
                        "definition": [
                            "char * const end"
                        ]
                    },
                    {
                        "path": null,
                        "name": "in",
                        "type": "const char * const",
                        "definition": [
                            "const char * const in"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "char * const",
                        "definition": [
                            "char * const out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "in_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int in_idx = *in_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "c",
                        "type": "char",
                        "definition": [
                            "char c = *c_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fill",
                        "type": "char",
                        "definition": [
                            "char fill = ' '"
                        ]
                    },
                    {
                        "path": null,
                        "name": "width",
                        "type": "size_t",
                        "definition": [
                            "size_t width = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numtype",
                        "type": "char",
                        "definition": [
                            "char numtype = 'd'"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numplus",
                        "type": "char",
                        "definition": [
                            "char numplus = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignright",
                        "type": "bool",
                        "definition": [
                            "bool alignright = 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "char *",
                        "definition": [
                            "char *start = out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int start_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "s",
                        "type": "const char *",
                        "definition": [
                            "const char *s = __builtin_va_arg(args)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "len",
                        "type": "const size_t",
                        "definition": [
                            "const size_t len = out - (&start[start_idx])"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper_helper_helper__mi_vsnprintf_1_1_1",
            "header": "",
            "params": [
                "unsigned int * const in_idx_ref",
                "char * const c_ref",
                "char * const numtype_ref",
                "const char * const in"
            ],
            "definition": "void helper_helper_helper__mi_vsnprintf_1_1_1(unsigned int * const in_idx_ref, char * const c_ref, char * const numtype_ref, const char * const in)\n{\n  unsigned int in_idx = *in_idx_ref;\n  char c = *c_ref;\n  char numtype = *numtype_ref;\n  numtype = c;\n  c = in[in_idx];\n  if (c == 0)\n  {\n    break;\n  }\n  in_idx += 1;\n  ;\n  if (c == 'l')\n  {\n    numtype = 'L';\n    c = in[in_idx];\n    if (c == 0)\n    {\n      break;\n    }\n    in_idx += 1;\n    ;\n  }\n  *in_idx_ref = in_idx;\n  *c_ref = c;\n  *numtype_ref = numtype;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "in_idx_ref",
                        "type": "unsigned int * const",
                        "definition": [
                            "unsigned int * const in_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "c_ref",
                        "type": "char * const",
                        "definition": [
                            "char * const c_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numtype_ref",
                        "type": "char * const",
                        "definition": [
                            "char * const numtype_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "in",
                        "type": "const char * const",
                        "definition": [
                            "const char * const in"
                        ]
                    },
                    {
                        "path": null,
                        "name": "in_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int in_idx = *in_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "c",
                        "type": "char",
                        "definition": [
                            "char c = *c_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numtype",
                        "type": "char",
                        "definition": [
                            "char numtype = *numtype_ref"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper_helper_helper__mi_vsnprintf_1_1_2",
            "header": "",
            "params": [
                "va_list args",
                "char * const end",
                "char * const out",
                "char numtype",
                "char numplus"
            ],
            "definition": "void helper_helper_helper__mi_vsnprintf_1_1_2(va_list args, char * const end, char * const out, char numtype, char numplus)\n{\n  intmax_t x = 0;\n  if (numtype == 'z')\n  {\n    x = __builtin_va_arg(args);\n  }\n  else\n    if (numtype == 't')\n  {\n    x = __builtin_va_arg(args);\n  }\n  else\n    if (numtype == 'L')\n  {\n    x = __builtin_va_arg(args);\n  }\n  else\n    if (numtype == 'l')\n  {\n    x = __builtin_va_arg(args);\n  }\n  else\n    x = __builtin_va_arg(args);\n  char pre = 0;\n  if (x < 0)\n  {\n    pre = '-';\n    if (x > INTMAX_MIN)\n    {\n      x = -x;\n    }\n  }\n  else\n    if (numplus != 0)\n  {\n    pre = numplus;\n  }\n  mi_out_num((uintmax_t) x, 10, pre, &out, end);\n}\n\n",
            "calle": [
                "__builtin_va_arg",
                "mi_out_num"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "args",
                        "type": "va_list",
                        "definition": [
                            "va_list args"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "char * const",
                        "definition": [
                            "char * const end"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "char * const",
                        "definition": [
                            "char * const out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numtype",
                        "type": "char",
                        "definition": [
                            "char numtype"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numplus",
                        "type": "char",
                        "definition": [
                            "char numplus"
                        ]
                    },
                    {
                        "path": null,
                        "name": "x",
                        "type": "intmax_t",
                        "definition": [
                            "intmax_t x = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pre",
                        "type": "char",
                        "definition": [
                            "char pre = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper_helper_helper__mi_vsnprintf_1_1_3",
            "header": "",
            "params": [
                "unsigned int * const in_idx_ref",
                "char * const c_ref",
                "size_t * const width_ref",
                "const char * const in"
            ],
            "definition": "void helper_helper_helper__mi_vsnprintf_1_1_3(unsigned int * const in_idx_ref, char * const c_ref, size_t * const width_ref, const char * const in)\n{\n  unsigned int in_idx = *in_idx_ref;\n  char c = *c_ref;\n  size_t width = *width_ref;\n  width = c - '0';\n  c = in[in_idx];\n  if (c == 0)\n  {\n    break;\n  }\n  in_idx += 1;\n  ;\n  while ((c >= '0') && (c <= '9'))\n  {\n    width = (10 * width) + (c - '0');\n    c = in[in_idx];\n    if (c == 0)\n    {\n      break;\n    }\n    in_idx += 1;\n    ;\n  }\n\n  if (c == 0)\n  {\n    break;\n  }\n  *in_idx_ref = in_idx;\n  *c_ref = c;\n  *width_ref = width;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "in_idx_ref",
                        "type": "unsigned int * const",
                        "definition": [
                            "unsigned int * const in_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "c_ref",
                        "type": "char * const",
                        "definition": [
                            "char * const c_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "width_ref",
                        "type": "size_t * const",
                        "definition": [
                            "size_t * const width_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "in",
                        "type": "const char * const",
                        "definition": [
                            "const char * const in"
                        ]
                    },
                    {
                        "path": null,
                        "name": "in_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int in_idx = *in_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "c",
                        "type": "char",
                        "definition": [
                            "char c = *c_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "width",
                        "type": "size_t",
                        "definition": [
                            "size_t width = *width_ref"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper_helper_helper__mi_vsnprintf_1_1_4",
            "header": "",
            "params": [
                "char * const fill_ref",
                "size_t * const width_ref",
                "unsigned int * const start_idx_ref",
                "va_list args",
                "char * const end",
                "char * const out",
                "char c",
                "char numtype",
                "char numplus"
            ],
            "definition": "void helper_helper_helper__mi_vsnprintf_1_1_4(char * const fill_ref, size_t * const width_ref, unsigned int * const start_idx_ref, va_list args, char * const end, char * const out, char c, char numtype, char numplus)\n{\n  char fill = *fill_ref;\n  size_t width = *width_ref;\n  unsigned int start_idx = *start_idx_ref;\n  uintmax_t x = 0;\n  if ((c == 'x') || (c == 'u'))\n  {\n    if (numtype == 'z')\n    {\n      x = __builtin_va_arg(args);\n    }\n    else\n      if (numtype == 't')\n    {\n      x = __builtin_va_arg(args);\n    }\n    else\n      if (numtype == 'L')\n    {\n      x = __builtin_va_arg(args);\n    }\n    else\n      if (numtype == 'l')\n    {\n      x = __builtin_va_arg(args);\n    }\n    else\n      x = __builtin_va_arg(args);\n  }\n  else\n    if (c == 'p')\n  {\n    x = __builtin_va_arg(args);\n    mi_outs(\"0x\", &out, end);\n    start_idx = out;\n    width = (width >= 2) ? (width - 2) : (0);\n  }\n  if ((width == 0) && ((c == 'x') || (c == 'p')))\n  {\n    if (c == 'p')\n    {\n      width = 2 * ((x <= UINT32_MAX) ? (4) : (((x >> 16) <= UINT32_MAX) ? (6) : (sizeof(void *))));\n    }\n    if (width == 0)\n    {\n      width = 2;\n    }\n    fill = '0';\n  }\n  mi_out_num(x, ((c == 'x') || (c == 'p')) ? (16) : (10), numplus, &out, end);\n  *fill_ref = fill;\n  *width_ref = width;\n  *start_idx_ref = start_idx;\n}\n\n",
            "calle": [
                "__builtin_va_arg",
                "mi_out_num",
                "mi_outs"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "fill_ref",
                        "type": "char * const",
                        "definition": [
                            "char * const fill_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "width_ref",
                        "type": "size_t * const",
                        "definition": [
                            "size_t * const width_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start_idx_ref",
                        "type": "unsigned int * const",
                        "definition": [
                            "unsigned int * const start_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "args",
                        "type": "va_list",
                        "definition": [
                            "va_list args"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "char * const",
                        "definition": [
                            "char * const end"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "char * const",
                        "definition": [
                            "char * const out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "c",
                        "type": "char",
                        "definition": [
                            "char c"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numtype",
                        "type": "char",
                        "definition": [
                            "char numtype"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numplus",
                        "type": "char",
                        "definition": [
                            "char numplus"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fill",
                        "type": "char",
                        "definition": [
                            "char fill = *fill_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "width",
                        "type": "size_t",
                        "definition": [
                            "size_t width = *width_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int start_idx = *start_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "x",
                        "type": "uintmax_t",
                        "definition": [
                            "uintmax_t x = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_register_output",
            "header": "void mi_register_output(mi_output_fun *out, void *arg)",
            "params": [
                "mi_output_fun *out",
                "void *arg"
            ],
            "definition": "void mi_register_output(mi_output_fun *out, void *arg)\n{\n  mi_out_default = (out == 0) ? (&mi_out_stderr) : (out);\n  atomic_store_explicit(&mi_out_arg, arg, memory_order_release);\n  if (out != 0)\n  {\n    mi_out_buf_flush(out, 1, arg);\n  }\n}\n\n",
            "calle": [
                "atomic_store_explicit",
                "mi_out_buf_flush",
                "mi_out_stderr"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_out_default",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "mi_out_arg",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_register_error",
            "header": "void mi_register_error(mi_error_fun *fun, void *arg)",
            "params": [
                "mi_error_fun *fun",
                "void *arg"
            ],
            "definition": "void mi_register_error(mi_error_fun *fun, void *arg)\n{\n  mi_error_handler = fun;\n  atomic_store_explicit(&mi_error_arg, arg, memory_order_release);\n}\n\n",
            "calle": [
                "atomic_store_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "fun",
                        "type": "mi_error_fun *",
                        "definition": [
                            "mi_error_fun *fun"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_error_handler",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "mi_error_arg",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_version",
            "header": "int mi_version(void)",
            "params": [
                "void"
            ],
            "definition": "int mi_version(void)\n{\n  return 225;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_options_print",
            "header": "void mi_options_print(void)",
            "params": [
                "void"
            ],
            "definition": "void mi_options_print(void)\n{\n  const int vermajor = 225 / 100;\n  const int verminor = (225 % 100) / 10;\n  const int verpatch = 225 % 10;\n  _mi_message(\"v%i.%i.%i%s%s (built on %s, %s)\\n\", vermajor, verminor, verpatch, \"\", \"\", \"Oct 23 2025\", \"11:20:02\");\n  for (int i = 0; i < _mi_option_last; i += 1)\n  {\n    mi_option_t option = (mi_option_t) i;\n    long l = mi_option_get(option);\n    (void) l;\n    mi_option_desc_t *desc = &options[option];\n    _mi_message(\"option '%s': %ld %s\\n\", desc->name, desc->value, (mi_option_has_size_in_kib(option)) ? (\"KiB\") : (\"\"));\n  }\n\n  _mi_message(\"debug level : %d\\n\", 2);\n  _mi_message(\"secure level: %d\\n\", 0);\n  _mi_message(\"mem tracking: %s\\n\", \"none\");\n}\n\n",
            "calle": [
                "_mi_message",
                "mi_option_get",
                "mi_option_has_size_in_kib"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "vermajor",
                        "type": "const int",
                        "definition": [
                            "const int vermajor = 225 / 100"
                        ]
                    },
                    {
                        "path": null,
                        "name": "verminor",
                        "type": "const int",
                        "definition": [
                            "const int verminor = (225 % 100) / 10"
                        ]
                    },
                    {
                        "path": null,
                        "name": "verpatch",
                        "type": "const int",
                        "definition": [
                            "const int verpatch = 225 % 10"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "int",
                        "definition": [
                            "int i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "option",
                        "type": "mi_option_t",
                        "definition": [
                            "mi_option_t option = (mi_option_t) i"
                        ]
                    },
                    {
                        "path": null,
                        "name": "l",
                        "type": "long",
                        "definition": [
                            "long l = mi_option_get(option)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "desc",
                        "type": "mi_option_desc_t *",
                        "definition": [
                            "mi_option_desc_t *desc = &options[option]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "options",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_option_is_enabled",
            "header": "bool mi_option_is_enabled(mi_option_t option)",
            "params": [
                "mi_option_t option"
            ],
            "definition": "bool mi_option_is_enabled(mi_option_t option)\n{\n  return mi_option_get(option) != 0;\n}\n\n",
            "calle": [
                "mi_option_get"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "option",
                        "type": "mi_option_t",
                        "definition": [
                            "mi_option_t option"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_option_enable",
            "header": "void mi_option_enable(mi_option_t option)",
            "params": [
                "mi_option_t option"
            ],
            "definition": "void mi_option_enable(mi_option_t option)\n{\n  mi_option_set_enabled(option, 1);\n}\n\n",
            "calle": [
                "mi_option_set_enabled"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "option",
                        "type": "mi_option_t",
                        "definition": [
                            "mi_option_t option"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_option_disable",
            "header": "void mi_option_disable(mi_option_t option)",
            "params": [
                "mi_option_t option"
            ],
            "definition": "void mi_option_disable(mi_option_t option)\n{\n  mi_option_set_enabled(option, 0);\n}\n\n",
            "calle": [
                "mi_option_set_enabled"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "option",
                        "type": "mi_option_t",
                        "definition": [
                            "mi_option_t option"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_option_set_enabled",
            "header": "void mi_option_set_enabled(mi_option_t option, bool enable)",
            "params": [
                "mi_option_t option",
                "bool enable"
            ],
            "definition": "void mi_option_set_enabled(mi_option_t option, bool enable)\n{\n  mi_option_set(option, (enable) ? (1) : (0));\n}\n\n",
            "calle": [
                "mi_option_set"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "option",
                        "type": "mi_option_t",
                        "definition": [
                            "mi_option_t option"
                        ]
                    },
                    {
                        "path": null,
                        "name": "enable",
                        "type": "bool",
                        "definition": [
                            "bool enable"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_option_set_enabled_default",
            "header": "void mi_option_set_enabled_default(mi_option_t option, bool enable)",
            "params": [
                "mi_option_t option",
                "bool enable"
            ],
            "definition": "void mi_option_set_enabled_default(mi_option_t option, bool enable)\n{\n  mi_option_set_default(option, (enable) ? (1) : (0));\n}\n\n",
            "calle": [
                "mi_option_set_default"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "option",
                        "type": "mi_option_t",
                        "definition": [
                            "mi_option_t option"
                        ]
                    },
                    {
                        "path": null,
                        "name": "enable",
                        "type": "bool",
                        "definition": [
                            "bool enable"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_option_get",
            "header": "long mi_option_get(mi_option_t option)",
            "params": [
                "mi_option_t option"
            ],
            "definition": "long mi_option_get(mi_option_t option)\n{\n  ((option >= 0) && (option < _mi_option_last)) ? ((void) 0) : (_mi_assert_fail(\"option >= 0 && option < _mi_option_last\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/options.c\", 247, __func__));\n  if ((option < 0) || (option >= _mi_option_last))\n  {\n    return 0;\n  }\n  mi_option_desc_t *desc = &options[option];\n  (desc->option == option) ? ((void) 0) : (_mi_assert_fail(\"desc->option == option\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/options.c\", 250, __func__));\n  if (__builtin_expect(!(!(desc->init == UNINIT)), 0))\n  {\n    mi_option_init(desc);\n  }\n  return desc->value;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "mi_option_init"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "option",
                        "type": "mi_option_t",
                        "definition": [
                            "mi_option_t option"
                        ]
                    },
                    {
                        "path": null,
                        "name": "desc",
                        "type": "mi_option_desc_t *",
                        "definition": [
                            "mi_option_desc_t *desc = &options[option]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "options",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_option_get_clamp",
            "header": "long mi_option_get_clamp(mi_option_t option, long min, long max)",
            "params": [
                "mi_option_t option",
                "long min",
                "long max"
            ],
            "definition": "long mi_option_get_clamp(mi_option_t option, long min, long max)\n{\n  long x = mi_option_get(option);\n  return (x < min) ? (min) : ((x > max) ? (max) : (x));\n}\n\n",
            "calle": [
                "mi_option_get"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "option",
                        "type": "mi_option_t",
                        "definition": [
                            "mi_option_t option"
                        ]
                    },
                    {
                        "path": null,
                        "name": "min",
                        "type": "long",
                        "definition": [
                            "long min"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max",
                        "type": "long",
                        "definition": [
                            "long max"
                        ]
                    },
                    {
                        "path": null,
                        "name": "x",
                        "type": "long",
                        "definition": [
                            "long x = mi_option_get(option)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_option_get_size",
            "header": "size_t mi_option_get_size(mi_option_t option)",
            "params": [
                "mi_option_t option"
            ],
            "definition": "size_t mi_option_get_size(mi_option_t option)\n{\n  const long x = mi_option_get(option);\n  size_t size = (x < 0) ? (0) : ((size_t) x);\n  if (mi_option_has_size_in_kib(option))\n  {\n    size *= 1024UL;\n  }\n  return size;\n}\n\n",
            "calle": [
                "mi_option_get",
                "mi_option_has_size_in_kib"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "option",
                        "type": "mi_option_t",
                        "definition": [
                            "mi_option_t option"
                        ]
                    },
                    {
                        "path": null,
                        "name": "x",
                        "type": "const long",
                        "definition": [
                            "const long x = mi_option_get(option)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size = (x < 0) ? (0) : ((size_t) x)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_option_set",
            "header": "void mi_option_set(mi_option_t option, long value)",
            "params": [
                "mi_option_t option",
                "long value"
            ],
            "definition": "void mi_option_set(mi_option_t option, long value)\n{\n  ((option >= 0) && (option < _mi_option_last)) ? ((void) 0) : (_mi_assert_fail(\"option >= 0 && option < _mi_option_last\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/options.c\", 272, __func__));\n  if ((option < 0) || (option >= _mi_option_last))\n  {\n    return;\n  }\n  mi_option_desc_t *desc = &options[option];\n  (desc->option == option) ? ((void) 0) : (_mi_assert_fail(\"desc->option == option\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/options.c\", 275, __func__));\n  desc->value = value;\n  desc->init = INITIALIZED;\n  if ((desc->option == mi_option_guarded_min) && (_mi_option_get_fast(mi_option_guarded_max) < value))\n  {\n    mi_option_set(mi_option_guarded_max, value);\n  }\n  else\n    if ((desc->option == mi_option_guarded_max) && (_mi_option_get_fast(mi_option_guarded_min) > value))\n  {\n    mi_option_set(mi_option_guarded_min, value);\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_option_get_fast",
                "mi_option_set"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "option",
                        "type": "mi_option_t",
                        "definition": [
                            "mi_option_t option"
                        ]
                    },
                    {
                        "path": null,
                        "name": "value",
                        "type": "long",
                        "definition": [
                            "long value"
                        ]
                    },
                    {
                        "path": null,
                        "name": "desc",
                        "type": "mi_option_desc_t *",
                        "definition": [
                            "mi_option_desc_t *desc = &options[option]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "options",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_option_set_default",
            "header": "void mi_option_set_default(mi_option_t option, long value)",
            "params": [
                "mi_option_t option",
                "long value"
            ],
            "definition": "void mi_option_set_default(mi_option_t option, long value)\n{\n  ((option >= 0) && (option < _mi_option_last)) ? ((void) 0) : (_mi_assert_fail(\"option >= 0 && option < _mi_option_last\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/options.c\", 288, __func__));\n  if ((option < 0) || (option >= _mi_option_last))\n  {\n    return;\n  }\n  mi_option_desc_t *desc = &options[option];\n  if (desc->init != INITIALIZED)\n  {\n    desc->value = value;\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "option",
                        "type": "mi_option_t",
                        "definition": [
                            "mi_option_t option"
                        ]
                    },
                    {
                        "path": null,
                        "name": "value",
                        "type": "long",
                        "definition": [
                            "long value"
                        ]
                    },
                    {
                        "path": null,
                        "name": "desc",
                        "type": "mi_option_desc_t *",
                        "definition": [
                            "mi_option_desc_t *desc = &options[option]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "options",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_error_message",
            "header": "void _mi_error_message(int err, const char *fmt, ...)",
            "params": [
                "int err",
                "const char *fmt",
                "..."
            ],
            "definition": "void _mi_error_message(int err, const char *fmt, ...)\n{\n  va_list args;\n  __builtin_va_start(args);\n  mi_show_error_message(fmt, args);\n  ;\n  if (mi_error_handler != 0)\n  {\n    mi_error_handler(err, atomic_load_explicit(&mi_error_arg, memory_order_acquire));\n  }\n  else\n  {\n    mi_error_default(err);\n  }\n}\n\n",
            "calle": [
                "__builtin_va_start",
                "atomic_load_explicit",
                "mi_error_default",
                "mi_error_handler",
                "mi_show_error_message"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "err",
                        "type": "int",
                        "definition": [
                            "int err"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fmt",
                        "type": "const char *",
                        "definition": [
                            "const char *fmt"
                        ]
                    },
                    {
                        "path": null,
                        "name": "args",
                        "type": "va_list",
                        "definition": [
                            "va_list args"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_error_handler",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "mi_error_arg",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_fputs",
            "header": "void _mi_fputs(mi_output_fun *out, void *arg, const char *prefix, const char *message)",
            "params": [
                "mi_output_fun *out",
                "void *arg",
                "const char *prefix",
                "const char *message"
            ],
            "definition": "void _mi_fputs(mi_output_fun *out, void *arg, const char *prefix, const char *message)\n{\n  unsigned int out_idx = 0;\n  if ((((&out[out_idx]) == 0) || (((void *) out) == ((void *) stdout))) || (((void *) out) == ((void *) stderr)))\n  {\n    if (!mi_recurse_enter())\n    {\n      return;\n    }\n    out_idx = mi_out_get_default(&arg);\n    if (prefix != 0)\n    {\n      out(prefix, arg);\n    }\n    out(message, arg);\n    mi_recurse_exit();\n  }\n  else\n  {\n    if (prefix != 0)\n    {\n      out(prefix, arg);\n    }\n    out(message, arg);\n  }\n}\n\n",
            "calle": [
                "mi_out_get_default",
                "mi_recurse_enter",
                "mi_recurse_exit",
                "out"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prefix",
                        "type": "const char *",
                        "definition": [
                            "const char *prefix"
                        ]
                    },
                    {
                        "path": null,
                        "name": "message",
                        "type": "const char *",
                        "definition": [
                            "const char *message"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int out_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_fprintf",
            "header": "void _mi_fprintf(mi_output_fun *out, void *arg, const char *fmt, ...)",
            "params": [
                "mi_output_fun *out",
                "void *arg",
                "const char *fmt",
                "..."
            ],
            "definition": "void _mi_fprintf(mi_output_fun *out, void *arg, const char *fmt, ...)\n{\n  va_list args;\n  __builtin_va_start(args);\n  mi_vfprintf(out, arg, 0, fmt, args);\n  ;\n}\n\n",
            "calle": [
                "__builtin_va_start",
                "mi_vfprintf"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fmt",
                        "type": "const char *",
                        "definition": [
                            "const char *fmt"
                        ]
                    },
                    {
                        "path": null,
                        "name": "args",
                        "type": "va_list",
                        "definition": [
                            "va_list args"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_message",
            "header": "void _mi_message(const char *fmt, ...)",
            "params": [
                "const char *fmt",
                "..."
            ],
            "definition": "void _mi_message(const char *fmt, ...)\n{\n  va_list args;\n  __builtin_va_start(args);\n  mi_vfprintf_thread(0, 0, \"mimalloc: \", fmt, args);\n  ;\n}\n\n",
            "calle": [
                "__builtin_va_start",
                "mi_vfprintf_thread"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "fmt",
                        "type": "const char *",
                        "definition": [
                            "const char *fmt"
                        ]
                    },
                    {
                        "path": null,
                        "name": "args",
                        "type": "va_list",
                        "definition": [
                            "va_list args"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_warning_message",
            "header": "void _mi_warning_message(const char *fmt, ...)",
            "params": [
                "const char *fmt",
                "..."
            ],
            "definition": "void _mi_warning_message(const char *fmt, ...)\n{\n  if (!mi_option_is_enabled(mi_option_verbose))\n  {\n    if (!mi_option_is_enabled(mi_option_show_errors))\n    {\n      return;\n    }\n    if ((mi_max_warning_count >= 0) && (((long) atomic_fetch_add_explicit(&warning_count, (uintptr_t) 1, memory_order_acq_rel)) > mi_max_warning_count))\n    {\n      return;\n    }\n  }\n  va_list args;\n  __builtin_va_start(args);\n  mi_vfprintf_thread(0, 0, \"mimalloc: warning: \", fmt, args);\n  ;\n}\n\n",
            "calle": [
                "__builtin_va_start",
                "atomic_fetch_add_explicit",
                "mi_option_is_enabled",
                "mi_vfprintf_thread"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "fmt",
                        "type": "const char *",
                        "definition": [
                            "const char *fmt"
                        ]
                    },
                    {
                        "path": null,
                        "name": "args",
                        "type": "va_list",
                        "definition": [
                            "va_list args"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_max_warning_count",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "warning_count",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_verbose_message",
            "header": "void _mi_verbose_message(const char *fmt, ...)",
            "params": [
                "const char *fmt",
                "..."
            ],
            "definition": "void _mi_verbose_message(const char *fmt, ...)\n{\n  if (!mi_option_is_enabled(mi_option_verbose))\n  {\n    return;\n  }\n  va_list args;\n  __builtin_va_start(args);\n  mi_vfprintf(0, 0, \"mimalloc: \", fmt, args);\n  ;\n}\n\n",
            "calle": [
                "__builtin_va_start",
                "mi_option_is_enabled",
                "mi_vfprintf"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "fmt",
                        "type": "const char *",
                        "definition": [
                            "const char *fmt"
                        ]
                    },
                    {
                        "path": null,
                        "name": "args",
                        "type": "va_list",
                        "definition": [
                            "va_list args"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_trace_message",
            "header": "void _mi_trace_message(const char *fmt, ...)",
            "params": [
                "const char *fmt",
                "..."
            ],
            "definition": "void _mi_trace_message(const char *fmt, ...)\n{\n  if (mi_option_get(mi_option_verbose) <= 1)\n  {\n    return;\n  }\n  va_list args;\n  __builtin_va_start(args);\n  mi_vfprintf_thread(0, 0, \"mimalloc: \", fmt, args);\n  ;\n}\n\n",
            "calle": [
                "__builtin_va_start",
                "mi_option_get",
                "mi_vfprintf_thread"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "fmt",
                        "type": "const char *",
                        "definition": [
                            "const char *fmt"
                        ]
                    },
                    {
                        "path": null,
                        "name": "args",
                        "type": "va_list",
                        "definition": [
                            "va_list args"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_options_init",
            "header": "void _mi_options_init(void)",
            "params": [
                "void"
            ],
            "definition": "void _mi_options_init(void)\n{\n  mi_add_stderr_output();\n  for (int i = 0; i < _mi_option_last; i += 1)\n  {\n    mi_option_t option = (mi_option_t) i;\n    long l = mi_option_get(option);\n    (void) l;\n  }\n\n  mi_max_error_count = mi_option_get(mi_option_max_errors);\n  mi_max_warning_count = mi_option_get(mi_option_max_warnings);\n  if (mi_option_is_enabled(mi_option_verbose))\n  {\n    mi_options_print();\n  }\n}\n\n",
            "calle": [
                "mi_add_stderr_output",
                "mi_option_get",
                "mi_option_is_enabled",
                "mi_options_print"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "int",
                        "definition": [
                            "int i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "option",
                        "type": "mi_option_t",
                        "definition": [
                            "mi_option_t option = (mi_option_t) i"
                        ]
                    },
                    {
                        "path": null,
                        "name": "l",
                        "type": "long",
                        "definition": [
                            "long l = mi_option_get(option)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_max_error_count",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "mi_max_warning_count",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_option_get_fast",
            "header": "long _mi_option_get_fast(mi_option_t option)",
            "params": [
                "mi_option_t option"
            ],
            "definition": "long _mi_option_get_fast(mi_option_t option)\n{\n  ((option >= 0) && (option < _mi_option_last)) ? ((void) 0) : (_mi_assert_fail(\"option >= 0 && option < _mi_option_last\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/options.c\", 238, __func__));\n  mi_option_desc_t *desc = &options[option];\n  (desc->option == option) ? ((void) 0) : (_mi_assert_fail(\"desc->option == option\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/options.c\", 240, __func__));\n  return desc->value;\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "option",
                        "type": "mi_option_t",
                        "definition": [
                            "mi_option_t option"
                        ]
                    },
                    {
                        "path": null,
                        "name": "desc",
                        "type": "mi_option_desc_t *",
                        "definition": [
                            "mi_option_desc_t *desc = &options[option]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "options",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_assert_fail",
            "header": "void _mi_assert_fail(const char *assertion, const char *fname, unsigned int line, const char *func)",
            "params": [
                "const char *assertion",
                "const char *fname",
                "unsigned line",
                "const char *func"
            ],
            "definition": "void _mi_assert_fail(const char *assertion, const char *fname, unsigned line, const char *func)\n{\n  _mi_fprintf(0, 0, \"mimalloc: assertion failed: at \\\"%s\\\":%u, %s\\n  assertion: \\\"%s\\\"\\n\", fname, line, (func == 0) ? (\"\") : (func), assertion);\n  abort();\n}\n\n",
            "calle": [
                "_mi_fprintf",
                "abort"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "assertion",
                        "type": "const char *",
                        "definition": [
                            "const char *assertion"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fname",
                        "type": "const char *",
                        "definition": [
                            "const char *fname"
                        ]
                    },
                    {
                        "path": null,
                        "name": "line",
                        "type": "unsigned",
                        "definition": [
                            "unsigned line"
                        ]
                    },
                    {
                        "path": null,
                        "name": "func",
                        "type": "const char *",
                        "definition": [
                            "const char *func"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_add_stderr_output",
            "header": "static void mi_add_stderr_output(void)",
            "params": [
                "void"
            ],
            "definition": "static void mi_add_stderr_output(void)\n{\n  (mi_out_default == 0) ? ((void) 0) : (_mi_assert_fail(\"mi_out_default == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/options.c\", 395, __func__));\n  mi_out_buf_flush(&mi_out_stderr, 0, 0);\n  mi_out_default = &mi_out_buf_stderr;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_out_buf_flush",
                "mi_out_buf_stderr",
                "mi_out_stderr"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_out_default",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_option_init",
            "header": "static void mi_option_init(mi_option_desc_t *desc)",
            "params": [
                "mi_option_desc_t *desc"
            ],
            "definition": "static void mi_option_init(mi_option_desc_t *desc)\n{\n  char s[64 + 1];\n  char buf[64 + 1];\n  _mi_strlcpy(buf, \"mimalloc_\", sizeof(buf));\n  _mi_strlcat(buf, desc->name, sizeof(buf));\n  bool found = _mi_getenv(buf, s, sizeof(s));\n  if ((!found) && (desc->legacy_name != 0))\n  {\n    _mi_strlcpy(buf, \"mimalloc_\", sizeof(buf));\n    _mi_strlcat(buf, desc->legacy_name, sizeof(buf));\n    found = _mi_getenv(buf, s, sizeof(s));\n    if (found)\n    {\n      _mi_warning_message(\"environment option \\\"mimalloc_%s\\\" is deprecated -- use \\\"mimalloc_%s\\\" instead.\\n\", desc->legacy_name, desc->name);\n    }\n  }\n  if (found)\n  {\n    helper_mi_option_init_1(desc, s, buf);\n  }\n  else\n    if (!_mi_preloading())\n  {\n    desc->init = DEFAULTED;\n  }\n}\n\n",
            "calle": [
                "_mi_getenv",
                "_mi_preloading",
                "_mi_strlcat",
                "_mi_strlcpy",
                "_mi_warning_message",
                "helper_mi_option_init_1"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "desc",
                        "type": "mi_option_desc_t *",
                        "definition": [
                            "mi_option_desc_t *desc"
                        ]
                    },
                    {
                        "path": null,
                        "name": "s",
                        "type": "char [64 + 1]",
                        "definition": [
                            "char s[64 + 1]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char [64 + 1]",
                        "definition": [
                            "char buf[64 + 1]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "found",
                        "type": "bool",
                        "definition": [
                            "bool found = _mi_getenv(buf, s, sizeof(s))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_option_has_size_in_kib",
            "header": "",
            "params": [
                "mi_option_t option"
            ],
            "definition": "static bool mi_option_has_size_in_kib(mi_option_t option)\n{\n  return (option == mi_option_reserve_os_memory) || (option == mi_option_arena_reserve);\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "option",
                        "type": "mi_option_t",
                        "definition": [
                            "mi_option_t option"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_out_stderr",
            "header": "",
            "params": [
                "const char *msg",
                "void *arg"
            ],
            "definition": "static void mi_out_stderr(const char *msg, void *arg)\n{\n  (void) arg;\n  if ((msg != 0) && (msg[0] != 0))\n  {\n    _mi_prim_out_stderr(msg);\n  }\n}\n\n",
            "calle": [
                "_mi_prim_out_stderr"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "msg",
                        "type": "const char *",
                        "definition": [
                            "const char *msg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_out_buf",
            "header": "",
            "params": [
                "const char *msg",
                "void *arg"
            ],
            "definition": "static void mi_out_buf(const char *msg, void *arg)\n{\n  (void) arg;\n  if (msg == 0)\n  {\n    return;\n  }\n  if (atomic_load_explicit(&out_len, memory_order_relaxed) >= ((size_t) (16 * 1024)))\n  {\n    return;\n  }\n  size_t n = _mi_strlen(msg);\n  if (n == 0)\n  {\n    return;\n  }\n  size_t start = atomic_fetch_add_explicit(&out_len, n, memory_order_acq_rel);\n  if (start >= ((size_t) (16 * 1024)))\n  {\n    return;\n  }\n  if ((start + n) >= ((size_t) (16 * 1024)))\n  {\n    n = (((size_t) (16 * 1024)) - start) - 1;\n  }\n  _mi_memcpy(&out_buf[start], msg, n);\n}\n\n",
            "calle": [
                "_mi_memcpy",
                "_mi_strlen",
                "atomic_fetch_add_explicit",
                "atomic_load_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "msg",
                        "type": "const char *",
                        "definition": [
                            "const char *msg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "n",
                        "type": "size_t",
                        "definition": [
                            "size_t n = _mi_strlen(msg)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "size_t",
                        "definition": [
                            "size_t start = atomic_fetch_add_explicit(&out_len, n, memory_order_acq_rel)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out_len",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "out_buf",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_out_buf_flush",
            "header": "",
            "params": [
                "mi_output_fun *out",
                "bool no_more_buf",
                "void *arg"
            ],
            "definition": "static void mi_out_buf_flush(mi_output_fun *out, bool no_more_buf, void *arg)\n{\n  if (out == 0)\n  {\n    return;\n  }\n  size_t count = atomic_fetch_add_explicit(&out_len, (no_more_buf) ? ((size_t) (16 * 1024)) : (1), memory_order_acq_rel);\n  if (count > ((size_t) (16 * 1024)))\n  {\n    count = (size_t) (16 * 1024);\n  }\n  out_buf[count] = 0;\n  out(out_buf, arg);\n  if (!no_more_buf)\n  {\n    out_buf[count] = '\\n';\n  }\n}\n\n",
            "calle": [
                "atomic_fetch_add_explicit",
                "out"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "no_more_buf",
                        "type": "bool",
                        "definition": [
                            "bool no_more_buf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count = atomic_fetch_add_explicit(&out_len, (no_more_buf) ? ((size_t) (16 * 1024)) : (1), memory_order_acq_rel)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out_len",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "out_buf",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_out_buf_stderr",
            "header": "",
            "params": [
                "const char *msg",
                "void *arg"
            ],
            "definition": "static void mi_out_buf_stderr(const char *msg, void *arg)\n{\n  mi_out_stderr(msg, arg);\n  mi_out_buf(msg, arg);\n}\n\n",
            "calle": [
                "mi_out_buf",
                "mi_out_stderr"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "msg",
                        "type": "const char *",
                        "definition": [
                            "const char *msg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_out_get_default",
            "header": "",
            "params": [
                "void **parg"
            ],
            "definition": "static mi_output_fun *mi_out_get_default(void **parg)\n{\n  if (parg != 0)\n  {\n    *parg = atomic_load_explicit(&mi_out_arg, memory_order_acquire);\n  }\n  mi_output_fun *out = mi_out_default;\n  return (out == 0) ? (&mi_out_buf) : (out);\n}\n\n",
            "calle": [
                "atomic_load_explicit",
                "mi_out_buf"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "parg",
                        "type": "void **",
                        "definition": [
                            "void **parg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out = mi_out_default"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_out_arg",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "mi_out_default",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_recurse_enter_prim",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static bool mi_recurse_enter_prim(void)\n{\n  if (recurse)\n  {\n    return 0;\n  }\n  recurse = 1;\n  return 1;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "recurse",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_recurse_exit_prim",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static void mi_recurse_exit_prim(void)\n{\n  recurse = 0;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "recurse",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_recurse_enter",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static bool mi_recurse_enter(void)\n{\n  return mi_recurse_enter_prim();\n}\n\n",
            "calle": [
                "mi_recurse_enter_prim"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_recurse_exit",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static void mi_recurse_exit(void)\n{\n  mi_recurse_exit_prim();\n}\n\n",
            "calle": [
                "mi_recurse_exit_prim"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_vfprintf",
            "header": "",
            "params": [
                "mi_output_fun *out",
                "void *arg",
                "const char *prefix",
                "const char *fmt",
                "va_list args"
            ],
            "definition": "static void mi_vfprintf(mi_output_fun *out, void *arg, const char *prefix, const char *fmt, va_list args)\n{\n  char buf[512];\n  if (fmt == 0)\n  {\n    return;\n  }\n  if (!mi_recurse_enter())\n  {\n    return;\n  }\n  _mi_vsnprintf(buf, (sizeof(buf)) - 1, fmt, args);\n  mi_recurse_exit();\n  _mi_fputs(out, arg, prefix, buf);\n}\n\n",
            "calle": [
                "_mi_fputs",
                "_mi_vsnprintf",
                "mi_recurse_enter",
                "mi_recurse_exit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prefix",
                        "type": "const char *",
                        "definition": [
                            "const char *prefix"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fmt",
                        "type": "const char *",
                        "definition": [
                            "const char *fmt"
                        ]
                    },
                    {
                        "path": null,
                        "name": "args",
                        "type": "va_list",
                        "definition": [
                            "va_list args"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char [512]",
                        "definition": [
                            "char buf[512]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_vfprintf_thread",
            "header": "",
            "params": [
                "mi_output_fun *out",
                "void *arg",
                "const char *prefix",
                "const char *fmt",
                "va_list args"
            ],
            "definition": "static void mi_vfprintf_thread(mi_output_fun *out, void *arg, const char *prefix, const char *fmt, va_list args)\n{\n  if (((prefix != 0) && (_mi_strnlen(prefix, 33) <= 32)) && (!_mi_is_main_thread()))\n  {\n    char tprefix[64];\n    _mi_snprintf(tprefix, sizeof(tprefix), \"%sthread 0x%tx: \", prefix, (uintptr_t) _mi_thread_id());\n    mi_vfprintf(out, arg, tprefix, fmt, args);\n  }\n  else\n  {\n    mi_vfprintf(out, arg, prefix, fmt, args);\n  }\n}\n\n",
            "calle": [
                "_mi_is_main_thread",
                "_mi_snprintf",
                "_mi_strnlen",
                "_mi_thread_id",
                "mi_vfprintf"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prefix",
                        "type": "const char *",
                        "definition": [
                            "const char *prefix"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fmt",
                        "type": "const char *",
                        "definition": [
                            "const char *fmt"
                        ]
                    },
                    {
                        "path": null,
                        "name": "args",
                        "type": "va_list",
                        "definition": [
                            "va_list args"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tprefix",
                        "type": "char [64]",
                        "definition": [
                            "char tprefix[64]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_show_error_message",
            "header": "",
            "params": [
                "const char *fmt",
                "va_list args"
            ],
            "definition": "static void mi_show_error_message(const char *fmt, va_list args)\n{\n  if (!mi_option_is_enabled(mi_option_verbose))\n  {\n    if (!mi_option_is_enabled(mi_option_show_errors))\n    {\n      return;\n    }\n    if ((mi_max_error_count >= 0) && (((long) atomic_fetch_add_explicit(&error_count, (uintptr_t) 1, memory_order_acq_rel)) > mi_max_error_count))\n    {\n      return;\n    }\n  }\n  mi_vfprintf_thread(0, 0, \"mimalloc: error: \", fmt, args);\n}\n\n",
            "calle": [
                "atomic_fetch_add_explicit",
                "mi_option_is_enabled",
                "mi_vfprintf_thread"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "fmt",
                        "type": "const char *",
                        "definition": [
                            "const char *fmt"
                        ]
                    },
                    {
                        "path": null,
                        "name": "args",
                        "type": "va_list",
                        "definition": [
                            "va_list args"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_max_error_count",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "error_count",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_error_default",
            "header": "",
            "params": [
                "int err"
            ],
            "definition": "static void mi_error_default(int err)\n{\n  (void) err;\n  if (err == 14)\n  {\n    abort();\n  }\n}\n\n",
            "calle": [
                "abort"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "err",
                        "type": "int",
                        "definition": [
                            "int err"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper_mi_option_init_1",
            "header": "",
            "params": [
                "mi_option_desc_t * const desc",
                "char s[64 + 1]",
                "char buf[64 + 1]"
            ],
            "definition": "void helper_mi_option_init_1(mi_option_desc_t * const desc, char s[64 + 1], char buf[64 + 1])\n{\n  size_t len = _mi_strnlen(s, (sizeof(buf)) - 1);\n  for (size_t i = 0; i < len; i += 1)\n  {\n    buf[i] = _mi_toupper(s[i]);\n  }\n\n  buf[len] = 0;\n  if ((buf[0] == 0) || (strstr(\"1;TRUE;YES;ON\", buf) != 0))\n  {\n    desc->value = 1;\n    desc->init = INITIALIZED;\n  }\n  else\n    if (strstr(\"0;FALSE;NO;OFF\", buf) != 0)\n  {\n    desc->value = 0;\n    desc->init = INITIALIZED;\n  }\n  else\n  {\n    helper_helper_mi_option_init_1_1(desc, buf);\n  }\n  (desc->init != UNINIT) ? ((void) 0) : (_mi_assert_fail(\"desc->init != UNINIT\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/options.c\", 658, __func__));\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_strnlen",
                "_mi_toupper",
                "helper_helper_mi_option_init_1_1",
                "strstr"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "desc",
                        "type": "mi_option_desc_t * const",
                        "definition": [
                            "mi_option_desc_t * const desc"
                        ]
                    },
                    {
                        "path": null,
                        "name": "s",
                        "type": "char [64 + 1]",
                        "definition": [
                            "char s[64 + 1]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char [64 + 1]",
                        "definition": [
                            "char buf[64 + 1]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "len",
                        "type": "size_t",
                        "definition": [
                            "size_t len = _mi_strnlen(s, (sizeof(buf)) - 1)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper_helper_mi_option_init_1_1",
            "header": "",
            "params": [
                "mi_option_desc_t * const desc",
                "char buf[64 + 1]"
            ],
            "definition": "void helper_helper_mi_option_init_1_1(mi_option_desc_t * const desc, char buf[64 + 1])\n{\n  char *end = buf;\n  unsigned int end_idx = 0;\n  long value = strtol(buf, &(&end[end_idx]), 10);\n  if (mi_option_has_size_in_kib(desc->option))\n  {\n    size_t size = (value < 0) ? (0) : ((size_t) value);\n    bool overflow = 0;\n    if (end[end_idx] == 'K')\n    {\n      end_idx += 1;\n    }\n    else\n      if (end[end_idx] == 'M')\n    {\n      overflow = mi_mul_overflow(size, 1024UL, &size);\n      end_idx += 1;\n    }\n    else\n      if (end[end_idx] == 'G')\n    {\n      overflow = mi_mul_overflow(size, 1024UL * 1024UL, &size);\n      end_idx += 1;\n    }\n    else\n      if (end[end_idx] == 'T')\n    {\n      overflow = mi_mul_overflow(size, (1024UL * 1024UL) * 1024UL, &size);\n      end_idx += 1;\n    }\n    else\n    {\n      size = ((size + 1024UL) - 1) / 1024UL;\n    }\n    if ((end[0 + end_idx] == 'I') && (end[1 + end_idx] == 'B'))\n    {\n      end_idx += 2;\n    }\n    else\n      if (end[end_idx] == 'B')\n    {\n      end_idx += 1;\n    }\n    if (overflow || (size > PTRDIFF_MAX))\n    {\n      size = PTRDIFF_MAX / 1024UL;\n    }\n    value = (size > 9223372036854775807L) ? (9223372036854775807L) : ((long) size);\n  }\n  if (end[end_idx] == 0)\n  {\n    mi_option_set(desc->option, value);\n  }\n  else\n  {\n    desc->init = DEFAULTED;\n    if ((desc->option == mi_option_verbose) && (desc->value == 0))\n    {\n      desc->value = 1;\n      _mi_warning_message(\"environment option mimalloc_%s has an invalid value.\\n\", desc->name);\n      desc->value = 0;\n    }\n    else\n    {\n      _mi_warning_message(\"environment option mimalloc_%s has an invalid value.\\n\", desc->name);\n    }\n  }\n}\n\n",
            "calle": [
                "_mi_warning_message",
                "mi_mul_overflow",
                "mi_option_has_size_in_kib",
                "mi_option_set",
                "strtol"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "desc",
                        "type": "mi_option_desc_t * const",
                        "definition": [
                            "mi_option_desc_t * const desc"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char [64 + 1]",
                        "definition": [
                            "char buf[64 + 1]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "char *",
                        "definition": [
                            "char *end = buf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int end_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "value",
                        "type": "long",
                        "definition": [
                            "long value = strtol(buf, &(&end[end_idx]), 10)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size = (value < 0) ? (0) : ((size_t) value)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "overflow",
                        "type": "bool",
                        "definition": [
                            "bool overflow = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_init",
            "header": "void _mi_os_init(void)",
            "params": [
                "void"
            ],
            "definition": "void _mi_os_init(void)\n{\n  _mi_prim_mem_init(&mi_os_mem_config);\n}\n\n",
            "calle": [
                "_mi_prim_mem_init"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_os_mem_config",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_alloc",
            "header": "void *_mi_os_alloc(size_t size, mi_memid_t *memid)",
            "params": [
                "size_t size",
                "mi_memid_t *memid"
            ],
            "definition": "void *_mi_os_alloc(size_t size, mi_memid_t *memid)\n{\n  *memid = _mi_memid_none();\n  if (size == 0)\n  {\n    return 0;\n  }\n  size = _mi_os_good_alloc_size(size);\n  bool os_is_large = 0;\n  bool os_is_zero = 0;\n  void *p = mi_os_prim_alloc(size, 0, 1, 0, &os_is_large, &os_is_zero);\n  if (p == 0)\n  {\n    return 0;\n  }\n  *memid = _mi_memid_create_os(p, size, 1, os_is_zero, os_is_large);\n  (memid->mem.os.size >= size) ? ((void) 0) : (_mi_assert_fail(\"memid->mem.os.size >= size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 333, __func__));\n  (memid->initially_committed) ? ((void) 0) : (_mi_assert_fail(\"memid->initially_committed\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 334, __func__));\n  return p;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_memid_create_os",
                "_mi_memid_none",
                "_mi_os_good_alloc_size",
                "mi_os_prim_alloc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t *",
                        "definition": [
                            "mi_memid_t *memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "os_is_large",
                        "type": "bool",
                        "definition": [
                            "bool os_is_large = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "os_is_zero",
                        "type": "bool",
                        "definition": [
                            "bool os_is_zero = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = mi_os_prim_alloc(size, 0, 1, 0, &os_is_large, &os_is_zero)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_zalloc",
            "header": "void *_mi_os_zalloc(size_t size, mi_memid_t *memid)",
            "params": [
                "size_t size",
                "mi_memid_t *memid"
            ],
            "definition": "void *_mi_os_zalloc(size_t size, mi_memid_t *memid)\n{\n  void *p = _mi_os_alloc(size, memid);\n  return mi_os_ensure_zero(p, size, memid);\n}\n\n",
            "calle": [
                "_mi_os_alloc",
                "mi_os_ensure_zero"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t *",
                        "definition": [
                            "mi_memid_t *memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = _mi_os_alloc(size, memid)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_free",
            "header": "void _mi_os_free(void *p, size_t size, mi_memid_t memid)",
            "params": [
                "void *p",
                "size_t size",
                "mi_memid_t memid"
            ],
            "definition": "void _mi_os_free(void *p, size_t size, mi_memid_t memid)\n{\n  _mi_os_free_ex(p, size, 1, memid);\n}\n\n",
            "calle": [
                "_mi_os_free_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_free_ex",
            "header": "void _mi_os_free_ex(void *p, size_t size, bool still_committed, mi_memid_t memid)",
            "params": [
                "void *addr",
                "size_t size",
                "bool still_committed",
                "mi_memid_t memid"
            ],
            "definition": "void _mi_os_free_ex(void *addr, size_t size, bool still_committed, mi_memid_t memid)\n{\n  if (mi_memkind_is_os(memid.memkind))\n  {\n    size_t csize = memid.mem.os.size;\n    if (csize == 0)\n    {\n      csize = _mi_os_good_alloc_size(size);\n    }\n    (csize >= size) ? ((void) 0) : (_mi_assert_fail(\"csize >= size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 170, __func__));\n    size_t commit_size = (still_committed) ? (csize) : (0);\n    void *base = addr;\n    unsigned int base_idx = 0;\n    if (memid.mem.os.base != (&base[base_idx]))\n    {\n      (memid.mem.os.base <= addr) ? ((void) 0) : (_mi_assert_fail(\"memid.mem.os.base <= addr\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 175, __func__));\n      base_idx = memid.mem.os.base_idx;\n      const size_t diff = ((uint8_t *) addr) - ((uint8_t *) memid.mem.os.base);\n      if (memid.mem.os.size == 0)\n      {\n        csize += diff;\n      }\n      if (still_committed)\n      {\n        commit_size -= diff;\n      }\n    }\n    if (memid.memkind == MI_MEM_OS_HUGE)\n    {\n      (memid.is_pinned) ? ((void) 0) : (_mi_assert_fail(\"memid.is_pinned\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 187, __func__));\n      mi_os_free_huge_os_pages(base, csize);\n    }\n    else\n    {\n      mi_os_prim_free(base, csize, (still_committed) ? (commit_size) : (0));\n    }\n  }\n  else\n  {\n    (memid.memkind < MI_MEM_OS) ? ((void) 0) : (_mi_assert_fail(\"memid.memkind < MI_MEM_OS\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 196, __func__));\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_os_good_alloc_size",
                "mi_memkind_is_os",
                "mi_os_free_huge_os_pages",
                "mi_os_prim_free"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "still_committed",
                        "type": "bool",
                        "definition": [
                            "bool still_committed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "csize",
                        "type": "size_t",
                        "definition": [
                            "size_t csize = memid.mem.os.size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit_size",
                        "type": "size_t",
                        "definition": [
                            "size_t commit_size = (still_committed) ? (csize) : (0)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "base",
                        "type": "void *",
                        "definition": [
                            "void *base = addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "base_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int base_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "diff",
                        "type": "const size_t",
                        "definition": [
                            "const size_t diff = ((uint8_t *) addr) - ((uint8_t *) memid.mem.os.base)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_page_size",
            "header": "size_t _mi_os_page_size(void)",
            "params": [
                "void"
            ],
            "definition": "size_t _mi_os_page_size(void)\n{\n  return mi_os_mem_config.page_size;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_os_mem_config",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_good_alloc_size",
            "header": "size_t _mi_os_good_alloc_size(size_t size)",
            "params": [
                "size_t size"
            ],
            "definition": "size_t _mi_os_good_alloc_size(size_t size)\n{\n  size_t align_size;\n  if (size < (512 * 1024UL))\n  {\n    align_size = _mi_os_page_size();\n  }\n  else\n    if (size < (2 * (1024UL * 1024UL)))\n  {\n    align_size = 64 * 1024UL;\n  }\n  else\n    if (size < (8 * (1024UL * 1024UL)))\n  {\n    align_size = 256 * 1024UL;\n  }\n  else\n    if (size < (32 * (1024UL * 1024UL)))\n  {\n    align_size = 1 * (1024UL * 1024UL);\n  }\n  else\n    align_size = 4 * (1024UL * 1024UL);\n  if (__builtin_expect(!(!(size >= (SIZE_MAX - align_size))), 0))\n  {\n    return size;\n  }\n  return _mi_align_up(size, align_size);\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_align_up",
                "_mi_os_page_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "align_size",
                        "type": "size_t",
                        "definition": [
                            "size_t align_size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_has_overcommit",
            "header": "bool _mi_os_has_overcommit(void)",
            "params": [
                "void"
            ],
            "definition": "bool _mi_os_has_overcommit(void)\n{\n  return mi_os_mem_config.has_overcommit;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_os_mem_config",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_has_virtual_reserve",
            "header": "bool _mi_os_has_virtual_reserve(void)",
            "params": [
                "void"
            ],
            "definition": "bool _mi_os_has_virtual_reserve(void)\n{\n  return mi_os_mem_config.has_virtual_reserve;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_os_mem_config",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_reset",
            "header": "bool _mi_os_reset(void *addr, size_t size)",
            "params": [
                "void *addr",
                "size_t size"
            ],
            "definition": "bool _mi_os_reset(void *addr, size_t size)\n{\n  size_t csize;\n  void *start = mi_os_page_align_area_conservative(addr, size, &csize);\n  if (csize == 0)\n  {\n    return 1;\n  }\n  _mi_stat_increase(&_mi_stats_main.reset, csize);\n  _mi_stat_counter_increase(&_mi_stats_main.reset_calls, 1);\n  memset(start, 0, csize);\n  int err = _mi_prim_reset(start, csize);\n  if (err != 0)\n  {\n    _mi_warning_message(\"cannot reset OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\\n\", err, err, start, csize);\n  }\n  return err == 0;\n}\n\n",
            "calle": [
                "_mi_prim_reset",
                "_mi_stat_counter_increase",
                "_mi_stat_increase",
                "_mi_warning_message",
                "memset",
                "mi_os_page_align_area_conservative"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "csize",
                        "type": "size_t",
                        "definition": [
                            "size_t csize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "void *",
                        "definition": [
                            "void *start = mi_os_page_align_area_conservative(addr, size, &csize)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "err",
                        "type": "int",
                        "definition": [
                            "int err = _mi_prim_reset(start, csize)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_decommit",
            "header": "bool _mi_os_decommit(void *addr, size_t size)",
            "params": [
                "void *addr",
                "size_t size"
            ],
            "definition": "bool _mi_os_decommit(void *addr, size_t size)\n{\n  bool needs_recommit;\n  return mi_os_decommit_ex(addr, size, &needs_recommit, size);\n}\n\n",
            "calle": [
                "mi_os_decommit_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "needs_recommit",
                        "type": "bool",
                        "definition": [
                            "bool needs_recommit"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_unprotect",
            "header": "bool _mi_os_unprotect(void *addr, size_t size)",
            "params": [
                "void *addr",
                "size_t size"
            ],
            "definition": "bool _mi_os_unprotect(void *addr, size_t size)\n{\n  return mi_os_protectx(addr, size, 0);\n}\n\n",
            "calle": [
                "mi_os_protectx"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_purge",
            "header": "bool _mi_os_purge(void *p, size_t size)",
            "params": [
                "void *p",
                "size_t size"
            ],
            "definition": "bool _mi_os_purge(void *p, size_t size)\n{\n  return _mi_os_purge_ex(p, size, 1, size);\n}\n\n",
            "calle": [
                "_mi_os_purge_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_purge_ex",
            "header": "bool _mi_os_purge_ex(void *p, size_t size, bool allow_reset, size_t stat_size)",
            "params": [
                "void *p",
                "size_t size",
                "bool allow_reset",
                "size_t stat_size"
            ],
            "definition": "bool _mi_os_purge_ex(void *p, size_t size, bool allow_reset, size_t stat_size)\n{\n  if (mi_option_get(mi_option_purge_delay) < 0)\n  {\n    return 0;\n  }\n  _mi_stat_counter_increase(&_mi_stats_main.purge_calls, 1);\n  _mi_stat_increase(&_mi_stats_main.purged, size);\n  if (mi_option_is_enabled(mi_option_purge_decommits) && (!_mi_preloading()))\n  {\n    bool needs_recommit = 1;\n    mi_os_decommit_ex(p, size, &needs_recommit, stat_size);\n    return needs_recommit;\n  }\n  else\n  {\n    if (allow_reset)\n    {\n      _mi_os_reset(p, size);\n    }\n    return 0;\n  }\n}\n\n",
            "calle": [
                "_mi_os_reset",
                "_mi_preloading",
                "_mi_stat_counter_increase",
                "_mi_stat_increase",
                "mi_option_get",
                "mi_option_is_enabled",
                "mi_os_decommit_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_reset",
                        "type": "bool",
                        "definition": [
                            "bool allow_reset"
                        ]
                    },
                    {
                        "path": null,
                        "name": "stat_size",
                        "type": "size_t",
                        "definition": [
                            "size_t stat_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "needs_recommit",
                        "type": "bool",
                        "definition": [
                            "bool needs_recommit = 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_reuse",
            "header": "void _mi_os_reuse(void *p, size_t size)",
            "params": [
                "void *addr",
                "size_t size"
            ],
            "definition": "void _mi_os_reuse(void *addr, size_t size)\n{\n  size_t csize = 0;\n  void * const start = mi_os_page_align_area_conservative(addr, size, &csize);\n  if (csize == 0)\n  {\n    return;\n  }\n  const int err = _mi_prim_reuse(start, csize);\n  if (err != 0)\n  {\n    _mi_warning_message(\"cannot reuse OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\\n\", err, err, start, csize);\n  }\n}\n\n",
            "calle": [
                "_mi_prim_reuse",
                "_mi_warning_message",
                "mi_os_page_align_area_conservative"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "csize",
                        "type": "size_t",
                        "definition": [
                            "size_t csize = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "void * const",
                        "definition": [
                            "void * const start = mi_os_page_align_area_conservative(addr, size, &csize)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "err",
                        "type": "const int",
                        "definition": [
                            "const int err = _mi_prim_reuse(start, csize)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_commit",
            "header": "bool _mi_os_commit(void *p, size_t size, bool *is_zero)",
            "params": [
                "void *addr",
                "size_t size",
                "bool *is_zero"
            ],
            "definition": "bool _mi_os_commit(void *addr, size_t size, bool *is_zero)\n{\n  return _mi_os_commit_ex(addr, size, is_zero, size);\n}\n\n",
            "calle": [
                "_mi_os_commit_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_zero",
                        "type": "bool *",
                        "definition": [
                            "bool *is_zero"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_commit_ex",
            "header": "bool _mi_os_commit_ex(void *addr, size_t size, bool *is_zero, size_t stat_size)",
            "params": [
                "void *addr",
                "size_t size",
                "bool *is_zero",
                "size_t stat_size"
            ],
            "definition": "bool _mi_os_commit_ex(void *addr, size_t size, bool *is_zero, size_t stat_size)\n{\n  if (is_zero != 0)\n  {\n    *is_zero = 0;\n  }\n  _mi_stat_increase(&_mi_stats_main.committed, stat_size);\n  _mi_stat_counter_increase(&_mi_stats_main.commit_calls, 1);\n  size_t csize;\n  void *start = mi_os_page_align_areax(0, addr, size, &csize);\n  if (csize == 0)\n  {\n    return 1;\n  }\n  bool os_is_zero = 0;\n  int err = _mi_prim_commit(start, csize, &os_is_zero);\n  if (err != 0)\n  {\n    _mi_warning_message(\"cannot commit OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\\n\", err, err, start, csize);\n    return 0;\n  }\n  if (os_is_zero && (is_zero != 0))\n  {\n    *is_zero = 1;\n    ;\n  }\n  return 1;\n}\n\n",
            "calle": [
                "_mi_prim_commit",
                "_mi_stat_counter_increase",
                "_mi_stat_increase",
                "_mi_warning_message",
                "mi_os_page_align_areax"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_zero",
                        "type": "bool *",
                        "definition": [
                            "bool *is_zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "stat_size",
                        "type": "size_t",
                        "definition": [
                            "size_t stat_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "csize",
                        "type": "size_t",
                        "definition": [
                            "size_t csize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "void *",
                        "definition": [
                            "void *start = mi_os_page_align_areax(0, addr, size, &csize)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "os_is_zero",
                        "type": "bool",
                        "definition": [
                            "bool os_is_zero = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "err",
                        "type": "int",
                        "definition": [
                            "int err = _mi_prim_commit(start, csize, &os_is_zero)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_protect",
            "header": "bool _mi_os_protect(void *addr, size_t size)",
            "params": [
                "void *addr",
                "size_t size"
            ],
            "definition": "bool _mi_os_protect(void *addr, size_t size)\n{\n  return mi_os_protectx(addr, size, 1);\n}\n\n",
            "calle": [
                "mi_os_protectx"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_alloc_aligned",
            "header": "void *_mi_os_alloc_aligned(size_t size, size_t alignment, bool commit, bool allow_large, mi_memid_t *memid)",
            "params": [
                "size_t size",
                "size_t alignment",
                "bool commit",
                "bool allow_large",
                "mi_memid_t *memid"
            ],
            "definition": "void *_mi_os_alloc_aligned(size_t size, size_t alignment, bool commit, bool allow_large, mi_memid_t *memid)\n{\n  (void) (&_mi_os_get_aligned_hint);\n  *memid = _mi_memid_none();\n  if (size == 0)\n  {\n    return 0;\n  }\n  size = _mi_os_good_alloc_size(size);\n  alignment = _mi_align_up(alignment, _mi_os_page_size());\n  bool os_is_large = 0;\n  bool os_is_zero = 0;\n  void *os_base = 0;\n  void *p = mi_os_prim_alloc_aligned(size, alignment, commit, allow_large, &os_is_large, &os_is_zero, &os_base);\n  if (p == 0)\n  {\n    return 0;\n  }\n  *memid = _mi_memid_create_os(p, size, commit, os_is_zero, os_is_large);\n  memid->mem.os.base = os_base;\n  memid->mem.os.size += ((uint8_t *) p) - ((uint8_t *) os_base);\n  (memid->mem.os.size >= size) ? ((void) 0) : (_mi_assert_fail(\"memid->mem.os.size >= size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 356, __func__));\n  (_mi_is_aligned(p, alignment)) ? ((void) 0) : (_mi_assert_fail(\"_mi_is_aligned(p,alignment)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 357, __func__));\n  if (commit)\n  {\n    (memid->initially_committed) ? ((void) 0) : (_mi_assert_fail(\"memid->initially_committed\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 358, __func__));\n  }\n  return p;\n}\n\n",
            "calle": [
                "_mi_align_up",
                "_mi_assert_fail",
                "_mi_is_aligned",
                "_mi_memid_create_os",
                "_mi_memid_none",
                "_mi_os_get_aligned_hint",
                "_mi_os_good_alloc_size",
                "_mi_os_page_size",
                "mi_os_prim_alloc_aligned"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit",
                        "type": "bool",
                        "definition": [
                            "bool commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_large",
                        "type": "bool",
                        "definition": [
                            "bool allow_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t *",
                        "definition": [
                            "mi_memid_t *memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "os_is_large",
                        "type": "bool",
                        "definition": [
                            "bool os_is_large = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "os_is_zero",
                        "type": "bool",
                        "definition": [
                            "bool os_is_zero = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "os_base",
                        "type": "void *",
                        "definition": [
                            "void *os_base = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = mi_os_prim_alloc_aligned(size, alignment, commit, allow_large, &os_is_large, &os_is_zero, &os_base)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_alloc_aligned_at_offset",
            "header": "void *_mi_os_alloc_aligned_at_offset(size_t size, size_t alignment, size_t align_offset, bool commit, bool allow_large, mi_memid_t *memid)",
            "params": [
                "size_t size",
                "size_t alignment",
                "size_t offset",
                "bool commit",
                "bool allow_large",
                "mi_memid_t *memid"
            ],
            "definition": "void *_mi_os_alloc_aligned_at_offset(size_t size, size_t alignment, size_t offset, bool commit, bool allow_large, mi_memid_t *memid)\n{\n  (offset <= (1UL << (9 + (13 + 3)))) ? ((void) 0) : (_mi_assert_fail(\"offset <= MI_SEGMENT_SIZE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 395, __func__));\n  (offset <= size) ? ((void) 0) : (_mi_assert_fail(\"offset <= size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 396, __func__));\n  ((alignment % _mi_os_page_size()) == 0) ? ((void) 0) : (_mi_assert_fail(\"(alignment % _mi_os_page_size()) == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 397, __func__));\n  *memid = _mi_memid_none();\n  if (offset > (1UL << (9 + (13 + 3))))\n  {\n    return 0;\n  }\n  if (offset == 0)\n  {\n    return _mi_os_alloc_aligned(size, alignment, commit, allow_large, memid);\n  }\n  else\n  {\n    const size_t extra = _mi_align_up(offset, alignment) - offset;\n    const size_t oversize = size + extra;\n    void * const start = _mi_os_alloc_aligned(oversize, alignment, commit, allow_large, memid);\n    if (start == 0)\n    {\n      return 0;\n    }\n    void * const p = ((uint8_t *) start) + extra;\n    (_mi_is_aligned(((uint8_t *) p) + offset, alignment)) ? ((void) 0) : (_mi_assert_fail(\"_mi_is_aligned((uint8_t*)p + offset, alignment)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 412, __func__));\n    if (commit && (extra > _mi_os_page_size()))\n    {\n      _mi_os_decommit(start, extra);\n    }\n    return p;\n  }\n}\n\n",
            "calle": [
                "_mi_align_up",
                "_mi_assert_fail",
                "_mi_is_aligned",
                "_mi_memid_none",
                "_mi_os_alloc_aligned",
                "_mi_os_decommit",
                "_mi_os_page_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "size_t",
                        "definition": [
                            "size_t offset"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit",
                        "type": "bool",
                        "definition": [
                            "bool commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_large",
                        "type": "bool",
                        "definition": [
                            "bool allow_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t *",
                        "definition": [
                            "mi_memid_t *memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "extra",
                        "type": "const size_t",
                        "definition": [
                            "const size_t extra = _mi_align_up(offset, alignment) - offset"
                        ]
                    },
                    {
                        "path": null,
                        "name": "oversize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t oversize = size + extra"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "void * const",
                        "definition": [
                            "void * const start = _mi_os_alloc_aligned(oversize, alignment, commit, allow_large, memid)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void * const",
                        "definition": [
                            "void * const p = ((uint8_t *) start) + extra"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_get_aligned_hint",
            "header": "void *_mi_os_get_aligned_hint(size_t try_alignment, size_t size)",
            "params": [
                "size_t try_alignment",
                "size_t size"
            ],
            "definition": "void *_mi_os_get_aligned_hint(size_t try_alignment, size_t size)\n{\n  if ((try_alignment <= 1) || (try_alignment > (1UL << (9 + (13 + 3)))))\n  {\n    return 0;\n  }\n  if (mi_os_mem_config.virtual_address_bits < 46)\n  {\n    return 0;\n  }\n  size = _mi_align_up(size, 1UL << (9 + (13 + 3)));\n  if (size > (1 * ((1024UL * 1024UL) * 1024UL)))\n  {\n    return 0;\n  }\n  uintptr_t hint = atomic_fetch_add_explicit(&aligned_base, size, memory_order_acq_rel);\n  if ((hint == 0) || (hint > (((uintptr_t) 30) << 40)))\n  {\n    uintptr_t init = ((uintptr_t) 2) << 40;\n    uintptr_t expected = hint + size;\n    atomic_compare_exchange_strong_explicit(&aligned_base, &expected, init, memory_order_acq_rel, memory_order_acquire);\n    hint = atomic_fetch_add_explicit(&aligned_base, size, memory_order_acq_rel);\n  }\n  if ((hint % try_alignment) != 0)\n  {\n    return 0;\n  }\n  return (void *) hint;\n}\n\n",
            "calle": [
                "_mi_align_up",
                "atomic_compare_exchange_strong_explicit",
                "atomic_fetch_add_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "try_alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t try_alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "hint",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t hint = atomic_fetch_add_explicit(&aligned_base, size, memory_order_acq_rel)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "init",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t init = ((uintptr_t) 2) << 40"
                        ]
                    },
                    {
                        "path": null,
                        "name": "expected",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t expected = hint + size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_os_mem_config",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "aligned_base",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_use_large_page",
            "header": "bool _mi_os_use_large_page(size_t size, size_t alignment)",
            "params": [
                "size_t size",
                "size_t alignment"
            ],
            "definition": "bool _mi_os_use_large_page(size_t size, size_t alignment)\n{\n  if ((mi_os_mem_config.large_page_size == 0) || (!mi_option_is_enabled(mi_option_allow_large_os_pages)))\n  {\n    return 0;\n  }\n  return ((size % mi_os_mem_config.large_page_size) == 0) && ((alignment % mi_os_mem_config.large_page_size) == 0);\n}\n\n",
            "calle": [
                "mi_option_is_enabled"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_os_mem_config",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_large_page_size",
            "header": "size_t _mi_os_large_page_size(void)",
            "params": [
                "void"
            ],
            "definition": "size_t _mi_os_large_page_size(void)\n{\n  return (mi_os_mem_config.large_page_size != 0) ? (mi_os_mem_config.large_page_size) : (_mi_os_page_size());\n}\n\n",
            "calle": [
                "_mi_os_page_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_os_mem_config",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_alloc_huge_os_pages",
            "header": "void *_mi_os_alloc_huge_os_pages(size_t pages, int numa_node, mi_msecs_t max_secs, size_t *pages_reserved, size_t *psize, mi_memid_t *memid)",
            "params": [
                "size_t pages",
                "int numa_node",
                "mi_msecs_t max_msecs",
                "size_t *pages_reserved",
                "size_t *psize",
                "mi_memid_t *memid"
            ],
            "definition": "void *_mi_os_alloc_huge_os_pages(size_t pages, int numa_node, mi_msecs_t max_msecs, size_t *pages_reserved, size_t *psize, mi_memid_t *memid)\n{\n  *memid = _mi_memid_none();\n  if (psize != 0)\n  {\n    *psize = 0;\n  }\n  if (pages_reserved != 0)\n  {\n    *pages_reserved = 0;\n  }\n  size_t size = 0;\n  uint8_t * const start = mi_os_claim_huge_pages(pages, &size);\n  if (start == 0)\n  {\n    return 0;\n  }\n  mi_msecs_t start_t = _mi_clock_start();\n  size_t page = 0;\n  bool all_zero = 1;\n  while (page < pages)\n  {\n    helper__mi_os_alloc_huge_os_pages_1(&page, &all_zero, pages, numa_node, max_msecs, start, start_t);\n  }\n\n  ((page * ((1024UL * 1024UL) * 1024UL)) <= size) ? ((void) 0) : (_mi_assert_fail(\"page*MI_HUGE_OS_PAGE_SIZE <= size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 700, __func__));\n  if (pages_reserved != 0)\n  {\n    *pages_reserved = page;\n  }\n  if (psize != 0)\n  {\n    *psize = page * ((1024UL * 1024UL) * 1024UL);\n  }\n  if (page != 0)\n  {\n    (start != 0) ? ((void) 0) : (_mi_assert_fail(\"start != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 704, __func__));\n    *memid = _mi_memid_create_os(start, size, 1, all_zero, 1);\n    memid->memkind = MI_MEM_OS_HUGE;\n    (memid->is_pinned) ? ((void) 0) : (_mi_assert_fail(\"memid->is_pinned\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 707, __func__));\n  }\n  return (page == 0) ? (0) : (start);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_clock_start",
                "_mi_memid_create_os",
                "_mi_memid_none",
                "helper__mi_os_alloc_huge_os_pages_1",
                "mi_os_claim_huge_pages"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "pages",
                        "type": "size_t",
                        "definition": [
                            "size_t pages"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numa_node",
                        "type": "int",
                        "definition": [
                            "int numa_node"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max_msecs",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t max_msecs"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pages_reserved",
                        "type": "size_t *",
                        "definition": [
                            "size_t *pages_reserved"
                        ]
                    },
                    {
                        "path": null,
                        "name": "psize",
                        "type": "size_t *",
                        "definition": [
                            "size_t *psize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t *",
                        "definition": [
                            "mi_memid_t *memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "uint8_t * const",
                        "definition": [
                            "uint8_t * const start = mi_os_claim_huge_pages(pages, &size)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start_t",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t start_t = _mi_clock_start()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "size_t",
                        "definition": [
                            "size_t page = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "all_zero",
                        "type": "bool",
                        "definition": [
                            "bool all_zero = 1"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_numa_node_count",
            "header": "int _mi_os_numa_node_count(void)",
            "params": [
                "void"
            ],
            "definition": "int _mi_os_numa_node_count(void)\n{\n  size_t count = atomic_load_explicit(&mi_numa_node_count, memory_order_acquire);\n  if (__builtin_expect(!(!(count == 0)), 0))\n  {\n    long ncount = mi_option_get(mi_option_use_numa_nodes);\n    if ((ncount > 0) && (ncount < 2147483647))\n    {\n      count = (size_t) ncount;\n    }\n    else\n    {\n      const size_t n = _mi_prim_numa_node_count();\n      if ((n == 0) || (n > 2147483647))\n      {\n        count = 1;\n      }\n      else\n      {\n        count = n;\n      }\n    }\n    atomic_store_explicit(&mi_numa_node_count, count, memory_order_release);\n    _mi_verbose_message(\"using %zd numa regions\\n\", count);\n  }\n  ((count > 0) && (count <= 2147483647)) ? ((void) 0) : (_mi_assert_fail(\"count > 0 && count <= INT_MAX\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 749, __func__));\n  return (int) count;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_prim_numa_node_count",
                "_mi_verbose_message",
                "atomic_load_explicit",
                "atomic_store_explicit",
                "mi_option_get"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count = atomic_load_explicit(&mi_numa_node_count, memory_order_acquire)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ncount",
                        "type": "long",
                        "definition": [
                            "long ncount = mi_option_get(mi_option_use_numa_nodes)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "n",
                        "type": "const size_t",
                        "definition": [
                            "const size_t n = _mi_prim_numa_node_count()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_numa_node_count",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_numa_node",
            "header": "int _mi_os_numa_node(void)",
            "params": [
                "void"
            ],
            "definition": "int _mi_os_numa_node(void)\n{\n  if (__builtin_expect(!(!(atomic_load_explicit(&mi_numa_node_count, memory_order_relaxed) == 1)), 1))\n  {\n    return 0;\n  }\n  else\n  {\n    return mi_os_numa_node_get();\n  }\n}\n\n",
            "calle": [
                "__builtin_expect",
                "atomic_load_explicit",
                "mi_os_numa_node_get"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_numa_node_count",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_os_free_huge_os_pages",
            "header": "static void mi_os_free_huge_os_pages(void *p, size_t size)",
            "params": [
                "void *p",
                "size_t size"
            ],
            "definition": "static void mi_os_free_huge_os_pages(void *p, size_t size)\n{\n  if ((p == 0) || (size == 0))\n  {\n    return;\n  }\n  uint8_t *base = (uint8_t *) p;\n  unsigned int base_idx = 0;\n  while (size >= ((1024UL * 1024UL) * 1024UL))\n  {\n    mi_os_prim_free(base, (1024UL * 1024UL) * 1024UL, (1024UL * 1024UL) * 1024UL);\n    size -= (1024UL * 1024UL) * 1024UL;\n    base_idx += (1024UL * 1024UL) * 1024UL;\n  }\n\n}\n\n",
            "calle": [
                "mi_os_prim_free"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "base",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *base = (uint8_t *) p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "base_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int base_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_os_prim_free",
            "header": "",
            "params": [
                "void *addr",
                "size_t size",
                "size_t commit_size"
            ],
            "definition": "static void mi_os_prim_free(void *addr, size_t size, size_t commit_size)\n{\n  ((size % _mi_os_page_size()) == 0) ? ((void) 0) : (_mi_assert_fail(\"(size % _mi_os_page_size()) == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 154, __func__));\n  if (addr == 0)\n  {\n    return;\n  }\n  int err = _mi_prim_free(addr, size);\n  if (err != 0)\n  {\n    _mi_warning_message(\"unable to free OS memory (error: %d (0x%x), size: 0x%zx bytes, address: %p)\\n\", err, err, size, addr);\n  }\n  if (commit_size > 0)\n  {\n    _mi_stat_decrease(&_mi_stats_main.committed, commit_size);\n  }\n  _mi_stat_decrease(&_mi_stats_main.reserved, size);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_os_page_size",
                "_mi_prim_free",
                "_mi_stat_decrease",
                "_mi_warning_message"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit_size",
                        "type": "size_t",
                        "definition": [
                            "size_t commit_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "err",
                        "type": "int",
                        "definition": [
                            "int err = _mi_prim_free(addr, size)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_os_prim_alloc_at",
            "header": "",
            "params": [
                "void *hint_addr",
                "size_t size",
                "size_t try_alignment",
                "bool commit",
                "bool allow_large",
                "bool *is_large",
                "bool *is_zero"
            ],
            "definition": "static void *mi_os_prim_alloc_at(void *hint_addr, size_t size, size_t try_alignment, bool commit, bool allow_large, bool *is_large, bool *is_zero)\n{\n  ((size > 0) && ((size % _mi_os_page_size()) == 0)) ? ((void) 0) : (_mi_assert_fail(\"size > 0 && (size % _mi_os_page_size()) == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 212, __func__));\n  (is_zero != 0) ? ((void) 0) : (_mi_assert_fail(\"is_zero != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 213, __func__));\n  (is_large != 0) ? ((void) 0) : (_mi_assert_fail(\"is_large != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 214, __func__));\n  if (size == 0)\n  {\n    return 0;\n  }\n  if (!commit)\n  {\n    allow_large = 0;\n  }\n  if (try_alignment == 0)\n  {\n    try_alignment = 1;\n  }\n  *is_zero = 0;\n  void *p = 0;\n  int err = _mi_prim_alloc(hint_addr, size, try_alignment, commit, allow_large, is_large, is_zero, &p);\n  if (err != 0)\n  {\n    _mi_warning_message(\"unable to allocate OS memory (error: %d (0x%x), addr: %p, size: 0x%zx bytes, align: 0x%zx, commit: %d, allow large: %d)\\n\", err, err, hint_addr, size, try_alignment, commit, allow_large);\n  }\n  _mi_stat_counter_increase(&_mi_stats_main.mmap_calls, 1);\n  if (p != 0)\n  {\n    _mi_stat_increase(&_mi_stats_main.reserved, size);\n    if (commit)\n    {\n      _mi_stat_increase(&_mi_stats_main.committed, size);\n    }\n  }\n  return p;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_os_page_size",
                "_mi_prim_alloc",
                "_mi_stat_counter_increase",
                "_mi_stat_increase",
                "_mi_warning_message"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "hint_addr",
                        "type": "void *",
                        "definition": [
                            "void *hint_addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "try_alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t try_alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit",
                        "type": "bool",
                        "definition": [
                            "bool commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_large",
                        "type": "bool",
                        "definition": [
                            "bool allow_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_large",
                        "type": "bool *",
                        "definition": [
                            "bool *is_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_zero",
                        "type": "bool *",
                        "definition": [
                            "bool *is_zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "err",
                        "type": "int",
                        "definition": [
                            "int err = _mi_prim_alloc(hint_addr, size, try_alignment, commit, allow_large, is_large, is_zero, &p)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_os_prim_alloc",
            "header": "",
            "params": [
                "size_t size",
                "size_t try_alignment",
                "bool commit",
                "bool allow_large",
                "bool *is_large",
                "bool *is_zero"
            ],
            "definition": "static void *mi_os_prim_alloc(size_t size, size_t try_alignment, bool commit, bool allow_large, bool *is_large, bool *is_zero)\n{\n  return mi_os_prim_alloc_at(0, size, try_alignment, commit, allow_large, is_large, is_zero);\n}\n\n",
            "calle": [
                "mi_os_prim_alloc_at"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "try_alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t try_alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit",
                        "type": "bool",
                        "definition": [
                            "bool commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_large",
                        "type": "bool",
                        "definition": [
                            "bool allow_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_large",
                        "type": "bool *",
                        "definition": [
                            "bool *is_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_zero",
                        "type": "bool *",
                        "definition": [
                            "bool *is_zero"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_os_prim_alloc_aligned",
            "header": "",
            "params": [
                "size_t size",
                "size_t alignment",
                "bool commit",
                "bool allow_large",
                "bool *is_large",
                "bool *is_zero",
                "void **base"
            ],
            "definition": "static void *mi_os_prim_alloc_aligned(size_t size, size_t alignment, bool commit, bool allow_large, bool *is_large, bool *is_zero, void **base)\n{\n  ((alignment >= _mi_os_page_size()) && ((alignment & (alignment - 1)) == 0)) ? ((void) 0) : (_mi_assert_fail(\"alignment >= _mi_os_page_size() && ((alignment & (alignment - 1)) == 0)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 250, __func__));\n  ((size > 0) && ((size % _mi_os_page_size()) == 0)) ? ((void) 0) : (_mi_assert_fail(\"size > 0 && (size % _mi_os_page_size()) == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 251, __func__));\n  (is_large != 0) ? ((void) 0) : (_mi_assert_fail(\"is_large != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 252, __func__));\n  (is_zero != 0) ? ((void) 0) : (_mi_assert_fail(\"is_zero != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 253, __func__));\n  (base != 0) ? ((void) 0) : (_mi_assert_fail(\"base != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 254, __func__));\n  if (!commit)\n  {\n    allow_large = 0;\n  }\n  if (!((alignment >= _mi_os_page_size()) && ((alignment & (alignment - 1)) == 0)))\n  {\n    return 0;\n  }\n  size = _mi_align_up(size, _mi_os_page_size());\n  void *p = mi_os_prim_alloc(size, alignment, commit, allow_large, is_large, is_zero);\n  unsigned int p_idx = 0;\n  if ((&p[p_idx]) == 0)\n  {\n    return 0;\n  }\n  if ((((uintptr_t) p) % alignment) == 0)\n  {\n    *base = &p[p_idx];\n  }\n  else\n  {\n    helper_mi_os_prim_alloc_aligned_1(&p_idx, size, alignment, commit, is_large, is_zero, base, p);\n  }\n  (((&p[p_idx]) == 0) || ((((&p[p_idx]) != 0) && ((*base) != 0)) && ((((uintptr_t) p) % alignment) == 0))) ? ((void) 0) : (_mi_assert_fail(\"p == NULL || (p != NULL && *base != NULL && ((uintptr_t)p % alignment) == 0)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 314, __func__));\n  return p;\n}\n\n",
            "calle": [
                "_mi_align_up",
                "_mi_assert_fail",
                "_mi_os_page_size",
                "helper_mi_os_prim_alloc_aligned_1",
                "mi_os_prim_alloc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit",
                        "type": "bool",
                        "definition": [
                            "bool commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_large",
                        "type": "bool",
                        "definition": [
                            "bool allow_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_large",
                        "type": "bool *",
                        "definition": [
                            "bool *is_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_zero",
                        "type": "bool *",
                        "definition": [
                            "bool *is_zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "base",
                        "type": "void **",
                        "definition": [
                            "void **base"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = mi_os_prim_alloc(size, alignment, commit, allow_large, is_large, is_zero)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int p_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_os_ensure_zero",
            "header": "",
            "params": [
                "void *p",
                "size_t size",
                "mi_memid_t *memid"
            ],
            "definition": "static void *mi_os_ensure_zero(void *p, size_t size, mi_memid_t *memid)\n{\n  if ((p == 0) || (size == 0))\n  {\n    return p;\n  }\n  if (!memid->initially_committed)\n  {\n    bool is_zero = 0;\n    if (!_mi_os_commit(p, size, &is_zero))\n    {\n      _mi_os_free(p, size, *memid);\n      return 0;\n    }\n    memid->initially_committed = 1;\n  }\n  if (memid->initially_zero)\n  {\n    return p;\n  }\n  _mi_memzero_aligned(p, size);\n  memid->initially_zero = 1;\n  return p;\n}\n\n",
            "calle": [
                "_mi_memzero_aligned",
                "_mi_os_commit",
                "_mi_os_free"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t *",
                        "definition": [
                            "mi_memid_t *memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_zero",
                        "type": "bool",
                        "definition": [
                            "bool is_zero = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_os_page_align_areax",
            "header": "",
            "params": [
                "bool conservative",
                "void *addr",
                "size_t size",
                "size_t *newsize"
            ],
            "definition": "static void *mi_os_page_align_areax(bool conservative, void *addr, size_t size, size_t *newsize)\n{\n  ((addr != 0) && (size > 0)) ? ((void) 0) : (_mi_assert_fail(\"addr != NULL && size > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 428, __func__));\n  if (newsize != 0)\n  {\n    *newsize = 0;\n  }\n  if ((size == 0) || (addr == 0))\n  {\n    return 0;\n  }\n  void *start = (conservative) ? (mi_align_up_ptr(addr, _mi_os_page_size())) : (mi_align_down_ptr(addr, _mi_os_page_size()));\n  void *end = (conservative) ? (mi_align_down_ptr(((uint8_t *) addr) + size, _mi_os_page_size())) : (mi_align_up_ptr(((uint8_t *) addr) + size, _mi_os_page_size()));\n  ptrdiff_t diff = ((uint8_t *) end) - ((uint8_t *) start);\n  if (diff <= 0)\n  {\n    return 0;\n  }\n  ((conservative && (((size_t) diff) <= size)) || ((!conservative) && (((size_t) diff) >= size))) ? ((void) 0) : (_mi_assert_fail(\"(conservative && (size_t)diff <= size) || (!conservative && (size_t)diff >= size)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 440, __func__));\n  if (newsize != 0)\n  {\n    *newsize = (size_t) diff;\n  }\n  return start;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_os_page_size",
                "mi_align_down_ptr",
                "mi_align_up_ptr"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "conservative",
                        "type": "bool",
                        "definition": [
                            "bool conservative"
                        ]
                    },
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t *",
                        "definition": [
                            "size_t *newsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "void *",
                        "definition": [
                            "void *start = (conservative) ? (mi_align_up_ptr(addr, _mi_os_page_size())) : (mi_align_down_ptr(addr, _mi_os_page_size()))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "void *",
                        "definition": [
                            "void *end = (conservative) ? (mi_align_down_ptr(((uint8_t *) addr) + size, _mi_os_page_size())) : (mi_align_up_ptr(((uint8_t *) addr) + size, _mi_os_page_size()))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "diff",
                        "type": "ptrdiff_t",
                        "definition": [
                            "ptrdiff_t diff = ((uint8_t *) end) - ((uint8_t *) start)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_os_page_align_area_conservative",
            "header": "",
            "params": [
                "void *addr",
                "size_t size",
                "size_t *newsize"
            ],
            "definition": "static void *mi_os_page_align_area_conservative(void *addr, size_t size, size_t *newsize)\n{\n  return mi_os_page_align_areax(1, addr, size, newsize);\n}\n\n",
            "calle": [
                "mi_os_page_align_areax"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "size_t *",
                        "definition": [
                            "size_t *newsize"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_os_decommit_ex",
            "header": "",
            "params": [
                "void *addr",
                "size_t size",
                "bool *needs_recommit",
                "size_t stat_size"
            ],
            "definition": "static bool mi_os_decommit_ex(void *addr, size_t size, bool *needs_recommit, size_t stat_size)\n{\n  (needs_recommit != 0) ? ((void) 0) : (_mi_assert_fail(\"needs_recommit!=NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 483, __func__));\n  _mi_stat_decrease(&_mi_stats_main.committed, stat_size);\n  size_t csize;\n  void *start = mi_os_page_align_area_conservative(addr, size, &csize);\n  if (csize == 0)\n  {\n    return 1;\n  }\n  *needs_recommit = 1;\n  int err = _mi_prim_decommit(start, csize, needs_recommit);\n  if (err != 0)\n  {\n    _mi_warning_message(\"cannot decommit OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\\n\", err, err, start, csize);\n  }\n  (err == 0) ? ((void) 0) : (_mi_assert_fail(\"err == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 497, __func__));\n  return err == 0;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_prim_decommit",
                "_mi_stat_decrease",
                "_mi_warning_message",
                "mi_os_page_align_area_conservative"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "needs_recommit",
                        "type": "bool *",
                        "definition": [
                            "bool *needs_recommit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "stat_size",
                        "type": "size_t",
                        "definition": [
                            "size_t stat_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "csize",
                        "type": "size_t",
                        "definition": [
                            "size_t csize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "void *",
                        "definition": [
                            "void *start = mi_os_page_align_area_conservative(addr, size, &csize)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "err",
                        "type": "int",
                        "definition": [
                            "int err = _mi_prim_decommit(start, csize, needs_recommit)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_os_protectx",
            "header": "",
            "params": [
                "void *addr",
                "size_t size",
                "bool protect"
            ],
            "definition": "static bool mi_os_protectx(void *addr, size_t size, bool protect)\n{\n  size_t csize = 0;\n  void *start = mi_os_page_align_area_conservative(addr, size, &csize);\n  if (csize == 0)\n  {\n    return 0;\n  }\n  int err = _mi_prim_protect(start, csize, protect);\n  if (err != 0)\n  {\n    _mi_warning_message(\"cannot %s OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\\n\", (protect) ? (\"protect\") : (\"unprotect\"), err, err, start, csize);\n  }\n  return err == 0;\n}\n\n",
            "calle": [
                "_mi_prim_protect",
                "_mi_warning_message",
                "mi_os_page_align_area_conservative"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "protect",
                        "type": "bool",
                        "definition": [
                            "bool protect"
                        ]
                    },
                    {
                        "path": null,
                        "name": "csize",
                        "type": "size_t",
                        "definition": [
                            "size_t csize = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "void *",
                        "definition": [
                            "void *start = mi_os_page_align_area_conservative(addr, size, &csize)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "err",
                        "type": "int",
                        "definition": [
                            "int err = _mi_prim_protect(start, csize, protect)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_os_claim_huge_pages",
            "header": "",
            "params": [
                "size_t pages",
                "size_t *total_size"
            ],
            "definition": "static uint8_t *mi_os_claim_huge_pages(size_t pages, size_t *total_size)\n{\n  if (total_size != 0)\n  {\n    *total_size = 0;\n  }\n  const size_t size = pages * ((1024UL * 1024UL) * 1024UL);\n  uintptr_t start = 0;\n  uintptr_t end = 0;\n  uintptr_t huge_start = atomic_load_explicit(&mi_huge_start, memory_order_relaxed);\n  do\n  {\n    start = huge_start;\n    if (start == 0)\n    {\n      start = ((uintptr_t) 32) << 40;\n    }\n    end = start + size;\n    ((end % (1UL << (9 + (13 + 3)))) == 0) ? ((void) 0) : (_mi_assert_fail(\"end % MI_SEGMENT_SIZE == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 629, __func__));\n  }\n  while (!atomic_compare_exchange_strong_explicit(&mi_huge_start, &huge_start, end, memory_order_acq_rel, memory_order_acquire));\n  if (total_size != 0)\n  {\n    *total_size = size;\n  }\n  return (uint8_t *) start;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "atomic_compare_exchange_strong_explicit",
                "atomic_load_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "pages",
                        "type": "size_t",
                        "definition": [
                            "size_t pages"
                        ]
                    },
                    {
                        "path": null,
                        "name": "total_size",
                        "type": "size_t *",
                        "definition": [
                            "size_t *total_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t size = pages * ((1024UL * 1024UL) * 1024UL)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t start = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t end = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "huge_start",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t huge_start = atomic_load_explicit(&mi_huge_start, memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_huge_start",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_os_numa_node_get",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static int mi_os_numa_node_get(void)\n{\n  int numa_count = _mi_os_numa_node_count();\n  if (numa_count <= 1)\n  {\n    return 0;\n  }\n  const size_t n = _mi_prim_numa_node();\n  int numa_node = (n < 2147483647) ? ((int) n) : (0);\n  if (numa_node >= numa_count)\n  {\n    numa_node = numa_node % numa_count;\n  }\n  return numa_node;\n}\n\n",
            "calle": [
                "_mi_os_numa_node_count",
                "_mi_prim_numa_node"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numa_count",
                        "type": "int",
                        "definition": [
                            "int numa_count = _mi_os_numa_node_count()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "n",
                        "type": "const size_t",
                        "definition": [
                            "const size_t n = _mi_prim_numa_node()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numa_node",
                        "type": "int",
                        "definition": [
                            "int numa_node = (n < 2147483647) ? ((int) n) : (0)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper_mi_os_prim_alloc_aligned_1",
            "header": "",
            "params": [
                "unsigned int * const p_idx_ref",
                "size_t size",
                "size_t alignment",
                "bool commit",
                "bool * const is_large",
                "bool * const is_zero",
                "void ** const base",
                "void * const p"
            ],
            "definition": "void *helper_mi_os_prim_alloc_aligned_1(unsigned int * const p_idx_ref, size_t size, size_t alignment, bool commit, bool * const is_large, bool * const is_zero, void ** const base, void * const p)\n{\n  unsigned int p_idx = *p_idx_ref;\n  _mi_warning_message(\"unable to allocate aligned OS memory directly, fall back to over-allocation (size: 0x%zx bytes, address: %p, alignment: 0x%zx, commit: %d)\\n\", size, p, alignment, commit);\n  if ((&p[p_idx]) != 0)\n  {\n    mi_os_prim_free(p, size, (commit) ? (size) : (0));\n  }\n  if (size >= (SIZE_MAX - alignment))\n  {\n    return 0;\n  }\n  const size_t over_size = size + alignment;\n  if (!mi_os_mem_config.has_partial_free)\n  {\n    p_idx = mi_os_prim_alloc(over_size, 1, 0, 0, is_large, is_zero);\n    if ((&p[p_idx]) == 0)\n    {\n      return 0;\n    }\n    *base = &p[p_idx];\n    p_idx = mi_align_up_ptr(p_idx, alignment);\n    if (commit)\n    {\n      if (!_mi_os_commit(p, size, 0))\n      {\n        mi_os_prim_free(*base, over_size, 0);\n        return 0;\n      }\n    }\n  }\n  else\n  {\n    helper_helper_mi_os_prim_alloc_aligned_1_1(&p_idx, size, alignment, commit, is_large, is_zero, base, p, over_size);\n  }\n  *p_idx_ref = p_idx;\n}\n\n",
            "calle": [
                "_mi_os_commit",
                "_mi_warning_message",
                "helper_helper_mi_os_prim_alloc_aligned_1_1",
                "mi_align_up_ptr",
                "mi_os_prim_alloc",
                "mi_os_prim_free"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p_idx_ref",
                        "type": "unsigned int * const",
                        "definition": [
                            "unsigned int * const p_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit",
                        "type": "bool",
                        "definition": [
                            "bool commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_large",
                        "type": "bool * const",
                        "definition": [
                            "bool * const is_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_zero",
                        "type": "bool * const",
                        "definition": [
                            "bool * const is_zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "base",
                        "type": "void ** const",
                        "definition": [
                            "void ** const base"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void * const",
                        "definition": [
                            "void * const p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int p_idx = *p_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "over_size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t over_size = size + alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_os_mem_config",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper__mi_os_alloc_huge_os_pages_1",
            "header": "",
            "params": [
                "size_t * const page_ref",
                "bool * const all_zero_ref",
                "size_t pages",
                "int numa_node",
                "mi_msecs_t max_msecs",
                "uint8_t * const start",
                "mi_msecs_t start_t"
            ],
            "definition": "void helper__mi_os_alloc_huge_os_pages_1(size_t * const page_ref, bool * const all_zero_ref, size_t pages, int numa_node, mi_msecs_t max_msecs, uint8_t * const start, mi_msecs_t start_t)\n{\n  size_t page = *page_ref;\n  bool all_zero = *all_zero_ref;\n  bool is_zero = 0;\n  void *addr = start + (page * ((1024UL * 1024UL) * 1024UL));\n  void *p = 0;\n  int err = _mi_prim_alloc_huge_os_pages(addr, (1024UL * 1024UL) * 1024UL, numa_node, &is_zero, &p);\n  if (!is_zero)\n  {\n    all_zero = 0;\n  }\n  if (err != 0)\n  {\n    _mi_warning_message(\"unable to allocate huge OS page (error: %d (0x%x), address: %p, size: %zx bytes)\\n\", err, err, addr, (1024UL * 1024UL) * 1024UL);\n    break;\n  }\n  if (p != addr)\n  {\n    if (p != 0)\n    {\n      _mi_warning_message(\"could not allocate contiguous huge OS page %zu at %p\\n\", page, addr);\n      mi_os_prim_free(p, (1024UL * 1024UL) * 1024UL, (1024UL * 1024UL) * 1024UL);\n    }\n    break;\n  }\n  page += 1;\n  _mi_stat_increase(&_mi_stats_main.committed, (1024UL * 1024UL) * 1024UL);\n  _mi_stat_increase(&_mi_stats_main.reserved, (1024UL * 1024UL) * 1024UL);\n  if (max_msecs > 0)\n  {\n    mi_msecs_t elapsed = _mi_clock_end(start_t);\n    if (page >= 1)\n    {\n      mi_msecs_t estimate = (elapsed / (page + 1)) * pages;\n      if (estimate > (2 * max_msecs))\n      {\n        elapsed = max_msecs + 1;\n      }\n    }\n    if (elapsed > max_msecs)\n    {\n      _mi_warning_message(\"huge OS page allocation timed out (after allocating %zu page(s))\\n\", page);\n      break;\n    }\n  }\n  *page_ref = page;\n  *all_zero_ref = all_zero;\n}\n\n",
            "calle": [
                "_mi_clock_end",
                "_mi_prim_alloc_huge_os_pages",
                "_mi_stat_increase",
                "_mi_warning_message",
                "mi_os_prim_free"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page_ref",
                        "type": "size_t * const",
                        "definition": [
                            "size_t * const page_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "all_zero_ref",
                        "type": "bool * const",
                        "definition": [
                            "bool * const all_zero_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pages",
                        "type": "size_t",
                        "definition": [
                            "size_t pages"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numa_node",
                        "type": "int",
                        "definition": [
                            "int numa_node"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max_msecs",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t max_msecs"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "uint8_t * const",
                        "definition": [
                            "uint8_t * const start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start_t",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t start_t"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "size_t",
                        "definition": [
                            "size_t page = *page_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "all_zero",
                        "type": "bool",
                        "definition": [
                            "bool all_zero = *all_zero_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_zero",
                        "type": "bool",
                        "definition": [
                            "bool is_zero = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr = start + (page * ((1024UL * 1024UL) * 1024UL))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "err",
                        "type": "int",
                        "definition": [
                            "int err = _mi_prim_alloc_huge_os_pages(addr, (1024UL * 1024UL) * 1024UL, numa_node, &is_zero, &p)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "elapsed",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t elapsed = _mi_clock_end(start_t)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "estimate",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t estimate = (elapsed / (page + 1)) * pages"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper_helper_mi_os_prim_alloc_aligned_1_1",
            "header": "",
            "params": [
                "unsigned int * const p_idx_ref",
                "size_t size",
                "size_t alignment",
                "bool commit",
                "bool * const is_large",
                "bool * const is_zero",
                "void ** const base",
                "void * const p",
                "const size_t over_size"
            ],
            "definition": "void *helper_helper_mi_os_prim_alloc_aligned_1_1(unsigned int * const p_idx_ref, size_t size, size_t alignment, bool commit, bool * const is_large, bool * const is_zero, void ** const base, void * const p, const size_t over_size)\n{\n  unsigned int p_idx = *p_idx_ref;\n  p_idx = mi_os_prim_alloc(over_size, 1, commit, 0, is_large, is_zero);\n  if ((&p[p_idx]) == 0)\n  {\n    return 0;\n  }\n  void *aligned_p = mi_align_up_ptr(p, alignment);\n  size_t pre_size = ((uint8_t *) aligned_p) - ((uint8_t *) p);\n  size_t mid_size = _mi_align_up(size, _mi_os_page_size());\n  size_t post_size = (over_size - pre_size) - mid_size;\n  (((pre_size < over_size) && (post_size < over_size)) && (mid_size >= size)) ? ((void) 0) : (_mi_assert_fail(\"pre_size < over_size&& post_size < over_size&& mid_size >= size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/os.c\", 305, __func__));\n  if (pre_size > 0)\n  {\n    mi_os_prim_free(p, pre_size, (commit) ? (pre_size) : (0));\n  }\n  if (post_size > 0)\n  {\n    mi_os_prim_free(((uint8_t *) aligned_p) + mid_size, post_size, (commit) ? (post_size) : (0));\n  }\n  p_idx = aligned_p;\n  *base = aligned_p;\n  *p_idx_ref = p_idx;\n}\n\n",
            "calle": [
                "_mi_align_up",
                "_mi_assert_fail",
                "_mi_os_page_size",
                "mi_align_up_ptr",
                "mi_os_prim_alloc",
                "mi_os_prim_free"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p_idx_ref",
                        "type": "unsigned int * const",
                        "definition": [
                            "unsigned int * const p_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit",
                        "type": "bool",
                        "definition": [
                            "bool commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_large",
                        "type": "bool * const",
                        "definition": [
                            "bool * const is_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_zero",
                        "type": "bool * const",
                        "definition": [
                            "bool * const is_zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "base",
                        "type": "void ** const",
                        "definition": [
                            "void ** const base"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void * const",
                        "definition": [
                            "void * const p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "over_size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t over_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int p_idx = *p_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "aligned_p",
                        "type": "void *",
                        "definition": [
                            "void *aligned_p = mi_align_up_ptr(p, alignment)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pre_size",
                        "type": "size_t",
                        "definition": [
                            "size_t pre_size = ((uint8_t *) aligned_p) - ((uint8_t *) p)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mid_size",
                        "type": "size_t",
                        "definition": [
                            "size_t mid_size = _mi_align_up(size, _mi_os_page_size())"
                        ]
                    },
                    {
                        "path": null,
                        "name": "post_size",
                        "type": "size_t",
                        "definition": [
                            "size_t post_size = (over_size - pre_size) - mid_size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_good_size",
            "header": "size_t mi_good_size(size_t size)",
            "params": [
                "size_t size"
            ],
            "definition": "size_t mi_good_size(size_t size)\n{\n  if (size <= ((1UL << (3 + (13 + 3))) / 8))\n  {\n    return _mi_bin_size(mi_bin(size + (sizeof(mi_padding_t))));\n  }\n  else\n  {\n    return _mi_align_up(size + (sizeof(mi_padding_t)), _mi_os_page_size());\n  }\n}\n\n",
            "calle": [
                "_mi_align_up",
                "_mi_bin_size",
                "_mi_os_page_size",
                "mi_bin"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_register_deferred_free",
            "header": "void mi_register_deferred_free(mi_deferred_free_fun *deferred_free, void *arg)",
            "params": [
                "mi_deferred_free_fun *fn",
                "void *arg"
            ],
            "definition": "void mi_register_deferred_free(mi_deferred_free_fun *fn, void *arg)\n{\n  deferred_free = fn;\n  atomic_store_explicit(&deferred_arg, arg, memory_order_release);\n}\n\n",
            "calle": [
                "atomic_store_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "fn",
                        "type": "mi_deferred_free_fun *",
                        "definition": [
                            "mi_deferred_free_fun *fn"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "deferred_free",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "deferred_arg",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_malloc_generic",
            "header": "void *_mi_malloc_generic(mi_heap_t *heap, size_t size, bool zero, size_t huge_alignment)",
            "params": [
                "mi_heap_t *heap",
                "size_t size",
                "bool zero",
                "size_t huge_alignment"
            ],
            "definition": "void *_mi_malloc_generic(mi_heap_t *heap, size_t size, bool zero, size_t huge_alignment)\n{\n  unsigned int heap_idx = 0;\n  ((&heap[heap_idx]) != 0) ? ((void) 0) : (_mi_assert_fail(\"heap != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 989, __func__));\n  if (__builtin_expect(!(!(!mi_heap_is_initialized(heap))), 0))\n  {\n    heap_idx = mi_heap_get_default();\n    if (__builtin_expect(!(!(!mi_heap_is_initialized(heap))), 0))\n    {\n      return 0;\n    }\n  }\n  (mi_heap_is_initialized(heap)) ? ((void) 0) : (_mi_assert_fail(\"mi_heap_is_initialized(heap)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 996, __func__));\n  if (__builtin_expect(!(!((++heap->generic_count) >= 100)), 0))\n  {\n    heap->generic_collect_count += heap->generic_count;\n    heap->generic_count = 0;\n    _mi_deferred_free(heap, 0);\n    _mi_heap_delayed_free_partial(heap);\n    const long generic_collect = mi_option_get_clamp(mi_option_generic_collect, 1, 1000000L);\n    if (heap->generic_collect_count >= generic_collect)\n    {\n      heap->generic_collect_count = 0;\n      mi_heap_collect(heap, 0);\n    }\n  }\n  mi_page_t *page = mi_find_page(heap, size, huge_alignment);\n  unsigned int page_idx = 0;\n  if (__builtin_expect(!(!((&page[page_idx]) == 0)), 0))\n  {\n    mi_heap_collect(heap, 1);\n    page_idx = mi_find_page(heap, size, huge_alignment);\n  }\n  if (__builtin_expect(!(!((&page[page_idx]) == 0)), 0))\n  {\n    const size_t req_size = size - (sizeof(mi_padding_t));\n    _mi_error_message(12, \"unable to allocate memory (%zu bytes)\\n\", req_size);\n    return 0;\n  }\n  (mi_page_immediate_available(page)) ? ((void) 0) : (_mi_assert_fail(\"mi_page_immediate_available(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 1029, __func__));\n  (mi_page_block_size(page) >= size) ? ((void) 0) : (_mi_assert_fail(\"mi_page_block_size(page) >= size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 1030, __func__));\n  void *p;\n  unsigned int p_idx = 0;\n  if (__builtin_expect(!(!(zero && mi_page_is_huge(page))), 0))\n  {\n    p_idx = _mi_page_malloc(heap, page, size);\n    ((&p[p_idx]) != 0) ? ((void) 0) : (_mi_assert_fail(\"p != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 1037, __func__));\n    _mi_memzero_aligned(p, mi_page_usable_block_size(page));\n  }\n  else\n  {\n    p_idx = _mi_page_malloc_zero(heap, page, size, zero);\n    ((&p[p_idx]) != 0) ? ((void) 0) : (_mi_assert_fail(\"p != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 1042, __func__));\n  }\n  if (page->reserved == page->used)\n  {\n    mi_page_to_full(page, mi_page_queue_of(page));\n  }\n  return p;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_deferred_free",
                "_mi_error_message",
                "_mi_heap_delayed_free_partial",
                "_mi_memzero_aligned",
                "_mi_page_malloc",
                "_mi_page_malloc_zero",
                "mi_find_page",
                "mi_heap_collect",
                "mi_heap_get_default",
                "mi_heap_is_initialized",
                "mi_option_get_clamp",
                "mi_page_block_size",
                "mi_page_immediate_available",
                "mi_page_is_huge",
                "mi_page_queue_of",
                "mi_page_to_full",
                "mi_page_usable_block_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "zero",
                        "type": "bool",
                        "definition": [
                            "bool zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "huge_alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t huge_alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int heap_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "generic_collect",
                        "type": "const long",
                        "definition": [
                            "const long generic_collect = mi_option_get_clamp(mi_option_generic_collect, 1, 1000000L)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = mi_find_page(heap, size, huge_alignment)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int page_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "req_size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t req_size = size - (sizeof(mi_padding_t))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int p_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_page_retire",
            "header": "void _mi_page_retire(mi_page_t *page)",
            "params": [
                "mi_page_t *page"
            ],
            "definition": "void _mi_page_retire(mi_page_t *page)\n{\n  (page != 0) ? ((void) 0) : (_mi_assert_fail(\"page != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 463, __func__));\n  ;\n  (mi_page_all_free(page)) ? ((void) 0) : (_mi_assert_fail(\"mi_page_all_free(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 465, __func__));\n  mi_page_set_has_aligned(page, 0);\n  mi_page_queue_t *pq = mi_page_queue_of(page);\n  const size_t bsize = mi_page_block_size(page);\n  if (__builtin_expect(!(!(!mi_page_queue_is_special(pq))), 1))\n  {\n    if ((pq->last == page) && (pq->first == page))\n    {\n      _mi_stat_counter_increase(&_mi_stats_main.pages_retire, 1);\n      page->retire_expire = (bsize <= ((1UL << (13 + 3)) / 8)) ? (16) : (16 / 4);\n      mi_heap_t *heap = mi_page_heap(page);\n      (pq >= heap->pages) ? ((void) 0) : (_mi_assert_fail(\"pq >= heap->pages\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 483, __func__));\n      const size_t index = pq - heap->pages;\n      ((index < (73U + 1)) && (index < 73U)) ? ((void) 0) : (_mi_assert_fail(\"index < MI_BIN_FULL && index < MI_BIN_HUGE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 485, __func__));\n      if (index < heap->page_retired_min)\n      {\n        heap->page_retired_min = index;\n      }\n      if (index > heap->page_retired_max)\n      {\n        heap->page_retired_max = index;\n      }\n      (mi_page_all_free(page)) ? ((void) 0) : (_mi_assert_fail(\"mi_page_all_free(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 488, __func__));\n      return;\n    }\n  }\n  _mi_page_free(page, pq, 0);\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_page_free",
                "_mi_stat_counter_increase",
                "mi_page_all_free",
                "mi_page_block_size",
                "mi_page_heap",
                "mi_page_queue_is_special",
                "mi_page_queue_of",
                "mi_page_set_has_aligned"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq = mi_page_queue_of(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bsize = mi_page_block_size(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap = mi_page_heap(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "index",
                        "type": "const size_t",
                        "definition": [
                            "const size_t index = pq - heap->pages"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_page_unfull",
            "header": "void _mi_page_unfull(mi_page_t *page)",
            "params": [
                "mi_page_t *page"
            ],
            "definition": "void _mi_page_unfull(mi_page_t *page)\n{\n  (page != 0) ? ((void) 0) : (_mi_assert_fail(\"page != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 352, __func__));\n  ;\n  (mi_page_is_in_full(page)) ? ((void) 0) : (_mi_assert_fail(\"mi_page_is_in_full(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 354, __func__));\n  if (!mi_page_is_in_full(page))\n  {\n    return;\n  }\n  mi_heap_t *heap = mi_page_heap(page);\n  mi_page_queue_t *pqfull = &heap->pages[73U + 1];\n  mi_page_set_in_full(page, 0);\n  mi_page_queue_t *pq = mi_heap_page_queue_of(heap, page);\n  mi_page_set_in_full(page, 1);\n  mi_page_queue_enqueue_from_full(pq, pqfull, page);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_heap_page_queue_of",
                "mi_page_heap",
                "mi_page_is_in_full",
                "mi_page_queue_enqueue_from_full",
                "mi_page_set_in_full"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap = mi_page_heap(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pqfull",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pqfull = &heap->pages[73U + 1]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq = mi_heap_page_queue_of(heap, page)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_page_free",
            "header": "void _mi_page_free(mi_page_t *page, mi_page_queue_t *pq, bool force)",
            "params": [
                "mi_page_t *page",
                "mi_page_queue_t *pq",
                "bool force"
            ],
            "definition": "void _mi_page_free(mi_page_t *page, mi_page_queue_t *pq, bool force)\n{\n  (page != 0) ? ((void) 0) : (_mi_assert_fail(\"page != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 433, __func__));\n  ;\n  (pq == mi_page_queue_of(page)) ? ((void) 0) : (_mi_assert_fail(\"pq == mi_page_queue_of(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 435, __func__));\n  (mi_page_all_free(page)) ? ((void) 0) : (_mi_assert_fail(\"mi_page_all_free(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 436, __func__));\n  (mi_page_thread_free_flag(page) != MI_DELAYED_FREEING) ? ((void) 0) : (_mi_assert_fail(\"mi_page_thread_free_flag(page)!=MI_DELAYED_FREEING\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 437, __func__));\n  mi_page_set_has_aligned(page, 0);\n  mi_heap_t *heap = mi_page_heap(page);\n  mi_segments_tld_t *segments_tld = &heap->tld->segments;\n  mi_page_queue_remove(pq, page);\n  mi_page_set_heap(page, 0);\n  _mi_segment_page_free(page, force, segments_tld);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_segment_page_free",
                "mi_page_all_free",
                "mi_page_heap",
                "mi_page_queue_of",
                "mi_page_queue_remove",
                "mi_page_set_has_aligned",
                "mi_page_set_heap",
                "mi_page_thread_free_flag"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq"
                        ]
                    },
                    {
                        "path": null,
                        "name": "force",
                        "type": "bool",
                        "definition": [
                            "bool force"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap = mi_page_heap(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segments_tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *segments_tld = &heap->tld->segments"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_page_abandon",
            "header": "void _mi_page_abandon(mi_page_t *page, mi_page_queue_t *pq)",
            "params": [
                "mi_page_t *page",
                "mi_page_queue_t *pq"
            ],
            "definition": "void _mi_page_abandon(mi_page_t *page, mi_page_queue_t *pq)\n{\n  (page != 0) ? ((void) 0) : (_mi_assert_fail(\"page != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 381, __func__));\n  ;\n  (pq == mi_page_queue_of(page)) ? ((void) 0) : (_mi_assert_fail(\"pq == mi_page_queue_of(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 383, __func__));\n  (mi_page_heap(page) != 0) ? ((void) 0) : (_mi_assert_fail(\"mi_page_heap(page) != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 384, __func__));\n  mi_heap_t *pheap = mi_page_heap(page);\n  mi_segments_tld_t *segments_tld = &pheap->tld->segments;\n  mi_page_queue_remove(pq, page);\n  (mi_page_thread_free_flag(page) == MI_NEVER_DELAYED_FREE) ? ((void) 0) : (_mi_assert_fail(\"mi_page_thread_free_flag(page)==MI_NEVER_DELAYED_FREE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 393, __func__));\n  mi_page_set_heap(page, 0);\n  for (mi_block_t *block = (mi_block_t *) pheap->thread_delayed_free; (&block[block_idx]) != 0; block_idx = mi_block_nextx(pheap, block_idx, pheap->keys))\n  {\n    (_mi_ptr_page(block) != page) ? ((void) 0) : (_mi_assert_fail(\"_mi_ptr_page(block) != page\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 399, __func__));\n  }\n\n  unsigned int block_idx = 0;\n  (mi_page_heap(page) == 0) ? ((void) 0) : (_mi_assert_fail(\"mi_page_heap(page) == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 404, __func__));\n  _mi_segment_page_abandon(page, segments_tld);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_ptr_page",
                "_mi_segment_page_abandon",
                "mi_block_nextx",
                "mi_page_heap",
                "mi_page_queue_of",
                "mi_page_queue_remove",
                "mi_page_set_heap",
                "mi_page_thread_free_flag"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pheap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *pheap = mi_page_heap(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segments_tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *segments_tld = &pheap->tld->segments"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *block = (mi_block_t *) pheap->thread_delayed_free"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int block_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_page_force_abandon",
            "header": "void _mi_page_force_abandon(mi_page_t *page)",
            "params": [
                "mi_page_t *page"
            ],
            "definition": "void _mi_page_force_abandon(mi_page_t *page)\n{\n  mi_heap_t *heap = mi_page_heap(page);\n  _mi_page_use_delayed_free(page, MI_NEVER_DELAYED_FREE, 0);\n  _mi_heap_delayed_free_all(heap);\n  if (page->capacity == 0)\n  {\n    return;\n  }\n  mi_page_queue_t *pq = mi_heap_page_queue_of(heap, page);\n  if (mi_page_all_free(page))\n  {\n    _mi_page_free(page, pq, 0);\n  }\n  else\n  {\n    _mi_page_abandon(page, pq);\n  }\n}\n\n",
            "calle": [
                "_mi_heap_delayed_free_all",
                "_mi_page_abandon",
                "_mi_page_free",
                "_mi_page_use_delayed_free",
                "mi_heap_page_queue_of",
                "mi_page_all_free",
                "mi_page_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap = mi_page_heap(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq = mi_heap_page_queue_of(heap, page)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_delayed_free_all",
            "header": "void _mi_heap_delayed_free_all(mi_heap_t *heap)",
            "params": [
                "mi_heap_t *heap"
            ],
            "definition": "void _mi_heap_delayed_free_all(mi_heap_t *heap)\n{\n  while (!_mi_heap_delayed_free_partial(heap))\n  {\n    mi_atomic_yield();\n  }\n\n}\n\n",
            "calle": [
                "_mi_heap_delayed_free_partial",
                "mi_atomic_yield"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_delayed_free_partial",
            "header": "bool _mi_heap_delayed_free_partial(mi_heap_t *heap)",
            "params": [
                "mi_heap_t *heap"
            ],
            "definition": "bool _mi_heap_delayed_free_partial(mi_heap_t *heap)\n{\n  mi_block_t *block = atomic_load_explicit(&heap->thread_delayed_free, memory_order_relaxed);\n  unsigned int block_idx = 0;\n  while (((&block[block_idx]) != 0) && (!atomic_compare_exchange_weak_explicit(&heap->thread_delayed_free, &(&block[block_idx]), 0, memory_order_acq_rel, memory_order_acquire)))\n  {\n  }\n\n  ;\n  bool all_freed = 1;\n  while ((&block[block_idx]) != 0)\n  {\n    mi_block_t *next = mi_block_nextx(heap, block, heap->keys);\n    if (!_mi_free_delayed_block(block))\n    {\n      all_freed = 0;\n      mi_block_t *dfree = atomic_load_explicit(&heap->thread_delayed_free, memory_order_relaxed);\n      do\n      {\n        mi_block_set_nextx(heap, block, dfree, heap->keys);\n      }\n      while (!atomic_compare_exchange_weak_explicit(&heap->thread_delayed_free, &dfree, block, memory_order_release, memory_order_relaxed));\n    }\n    block_idx = next;\n  }\n\n  return all_freed;\n}\n\n",
            "calle": [
                "_mi_free_delayed_block",
                "atomic_compare_exchange_weak_explicit",
                "atomic_load_explicit",
                "mi_block_nextx",
                "mi_block_set_nextx"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *block = atomic_load_explicit(&heap->thread_delayed_free, memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int block_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "all_freed",
                        "type": "bool",
                        "definition": [
                            "bool all_freed = 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *next = mi_block_nextx(heap, block, heap->keys)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "dfree",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *dfree = atomic_load_explicit(&heap->thread_delayed_free, memory_order_relaxed)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_heap_collect_retired",
            "header": "void _mi_heap_collect_retired(mi_heap_t *heap, bool force)",
            "params": [
                "mi_heap_t *heap",
                "bool force"
            ],
            "definition": "void _mi_heap_collect_retired(mi_heap_t *heap, bool force)\n{\n  size_t min = 73U + 1;\n  size_t max = 0;\n  for (size_t bin = heap->page_retired_min; bin <= heap->page_retired_max; bin += 1)\n  {\n    mi_page_queue_t *pq = &heap->pages[bin];\n    mi_page_t *page = pq->first;\n    if ((page != 0) && (page->retire_expire != 0))\n    {\n      if (mi_page_all_free(page))\n      {\n        page->retire_expire -= 1;\n        if (force || (page->retire_expire == 0))\n        {\n          _mi_page_free(pq->first, pq, force);\n        }\n        else\n        {\n          if (bin < min)\n          {\n            min = bin;\n          }\n          if (bin > max)\n          {\n            max = bin;\n          }\n        }\n      }\n      else\n      {\n        page->retire_expire = 0;\n      }\n    }\n  }\n\n  heap->page_retired_min = min;\n  heap->page_retired_max = max;\n}\n\n",
            "calle": [
                "_mi_page_free",
                "mi_page_all_free"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "force",
                        "type": "bool",
                        "definition": [
                            "bool force"
                        ]
                    },
                    {
                        "path": null,
                        "name": "min",
                        "type": "size_t",
                        "definition": [
                            "size_t min = 73U + 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max",
                        "type": "size_t",
                        "definition": [
                            "size_t max = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bin",
                        "type": "size_t",
                        "definition": [
                            "size_t bin = heap->page_retired_min"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq = &heap->pages[bin]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = pq->first"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_page_use_delayed_free",
            "header": "void _mi_page_use_delayed_free(mi_page_t *page, mi_delayed_t delay, bool override_never)",
            "params": [
                "mi_page_t *page",
                "mi_delayed_t delay",
                "bool override_never"
            ],
            "definition": "void _mi_page_use_delayed_free(mi_page_t *page, mi_delayed_t delay, bool override_never)\n{\n  while (!_mi_page_try_use_delayed_free(page, delay, override_never))\n  {\n    mi_atomic_yield();\n  }\n\n}\n\n",
            "calle": [
                "_mi_page_try_use_delayed_free",
                "mi_atomic_yield"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "delay",
                        "type": "mi_delayed_t",
                        "definition": [
                            "mi_delayed_t delay"
                        ]
                    },
                    {
                        "path": null,
                        "name": "override_never",
                        "type": "bool",
                        "definition": [
                            "bool override_never"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_page_try_use_delayed_free",
            "header": "bool _mi_page_try_use_delayed_free(mi_page_t *page, mi_delayed_t delay, bool override_never)",
            "params": [
                "mi_page_t *page",
                "mi_delayed_t delay",
                "bool override_never"
            ],
            "definition": "bool _mi_page_try_use_delayed_free(mi_page_t *page, mi_delayed_t delay, bool override_never)\n{\n  mi_thread_free_t tfreex;\n  mi_delayed_t old_delay;\n  mi_thread_free_t tfree;\n  size_t yield_count = 0;\n  do\n  {\n    tfree = atomic_load_explicit(&page->xthread_free, memory_order_acquire);\n    tfreex = mi_tf_set_delayed(tfree, delay);\n    old_delay = mi_tf_delayed(tfree);\n    if (__builtin_expect(!(!(old_delay == MI_DELAYED_FREEING)), 0))\n    {\n      if (yield_count >= 4)\n      {\n        return 0;\n      }\n      yield_count += 1;\n      mi_atomic_yield();\n    }\n    else\n      if (delay == old_delay)\n    {\n      break;\n    }\n    else\n      if ((!override_never) && (old_delay == MI_NEVER_DELAYED_FREE))\n    {\n      break;\n    }\n  }\n  while ((old_delay == MI_DELAYED_FREEING) || (!atomic_compare_exchange_weak_explicit(&page->xthread_free, &tfree, tfreex, memory_order_release, memory_order_relaxed)));\n  return 1;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "atomic_compare_exchange_weak_explicit",
                "atomic_load_explicit",
                "mi_atomic_yield",
                "mi_tf_delayed",
                "mi_tf_set_delayed"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "delay",
                        "type": "mi_delayed_t",
                        "definition": [
                            "mi_delayed_t delay"
                        ]
                    },
                    {
                        "path": null,
                        "name": "override_never",
                        "type": "bool",
                        "definition": [
                            "bool override_never"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tfreex",
                        "type": "mi_thread_free_t",
                        "definition": [
                            "mi_thread_free_t tfreex"
                        ]
                    },
                    {
                        "path": null,
                        "name": "old_delay",
                        "type": "mi_delayed_t",
                        "definition": [
                            "mi_delayed_t old_delay"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tfree",
                        "type": "mi_thread_free_t",
                        "definition": [
                            "mi_thread_free_t tfree"
                        ]
                    },
                    {
                        "path": null,
                        "name": "yield_count",
                        "type": "size_t",
                        "definition": [
                            "size_t yield_count = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_page_queue_append",
            "header": "size_t _mi_page_queue_append(mi_heap_t *heap, mi_page_queue_t *pq, mi_page_queue_t *append)",
            "params": [
                "mi_heap_t *heap",
                "mi_page_queue_t *pq",
                "mi_page_queue_t *append"
            ],
            "definition": "size_t _mi_page_queue_append(mi_heap_t *heap, mi_page_queue_t *pq, mi_page_queue_t *append)\n{\n  (mi_heap_contains_queue(heap, pq)) ? ((void) 0) : (_mi_assert_fail(\"mi_heap_contains_queue(heap,pq)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 355, __func__));\n  (pq->block_size == append->block_size) ? ((void) 0) : (_mi_assert_fail(\"pq->block_size == append->block_size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 356, __func__));\n  if (append->first == 0)\n  {\n    return 0;\n  }\n  size_t count = 0;\n  for (mi_page_t *page = append->first; (&page[page_idx]) != 0; page_idx = page_idx->next)\n  {\n    atomic_store_explicit(&page->xheap, (uintptr_t) heap, memory_order_release);\n    _mi_page_use_delayed_free(page, MI_USE_DELAYED_FREE, 0);\n    count += 1;\n  }\n\n  unsigned int page_idx = 0;\n  if (pq->last == 0)\n  {\n    (pq->first == 0) ? ((void) 0) : (_mi_assert_fail(\"pq->first==NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 375, __func__));\n    pq->first = append->first;\n    pq->last = append->last;\n    mi_heap_queue_first_update(heap, pq);\n  }\n  else\n  {\n    (pq->last != 0) ? ((void) 0) : (_mi_assert_fail(\"pq->last!=NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 382, __func__));\n    (append->first != 0) ? ((void) 0) : (_mi_assert_fail(\"append->first!=NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 383, __func__));\n    pq->last->next = append->first;\n    append->first->prev = pq->last;\n    pq->last = append->last;\n  }\n  return count;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_page_use_delayed_free",
                "atomic_store_explicit",
                "mi_heap_contains_queue",
                "mi_heap_queue_first_update"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq"
                        ]
                    },
                    {
                        "path": null,
                        "name": "append",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *append"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = append->first"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int page_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_deferred_free",
            "header": "void _mi_deferred_free(mi_heap_t *heap, bool force)",
            "params": [
                "mi_heap_t *heap",
                "bool force"
            ],
            "definition": "void _mi_deferred_free(mi_heap_t *heap, bool force)\n{\n  heap->tld->heartbeat += 1;\n  if ((deferred_free != 0) && (!heap->tld->recurse))\n  {\n    heap->tld->recurse = 1;\n    deferred_free(force, heap->tld->heartbeat, atomic_load_explicit(&deferred_arg, memory_order_relaxed));\n    heap->tld->recurse = 0;\n  }\n}\n\n",
            "calle": [
                "atomic_load_explicit",
                "deferred_free"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "force",
                        "type": "bool",
                        "definition": [
                            "bool force"
                        ]
                    },
                    {
                        "path": null,
                        "name": "deferred_free",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "deferred_arg",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_page_free_collect",
            "header": "void _mi_page_free_collect(mi_page_t *page, bool force)",
            "params": [
                "mi_page_t *page",
                "bool force"
            ],
            "definition": "void _mi_page_free_collect(mi_page_t *page, bool force)\n{\n  (page != 0) ? ((void) 0) : (_mi_assert_fail(\"page!=NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 218, __func__));\n  if (force || (mi_page_thread_free(page) != 0))\n  {\n    _mi_page_thread_free_collect(page);\n  }\n  if (page->local_free != 0)\n  {\n    if (__builtin_expect(!(!(page->free == 0)), 1))\n    {\n      page->free = page->local_free;\n      page->local_free = 0;\n      page->free_is_zero = 0;\n    }\n    else\n      if (force)\n    {\n      mi_block_t *tail = page->local_free;\n      unsigned int tail_idx = 0;\n      mi_block_t *next;\n      unsigned int next_idx = 0;\n      while ((next_idx = mi_block_next(page, tail)) != 0)\n      {\n        tail_idx = &next[next_idx];\n      }\n\n      mi_block_set_next(page, tail, page->free);\n      page->free = page->local_free;\n      page->local_free = 0;\n      page->free_is_zero = 0;\n    }\n  }\n  ((!force) || (page->local_free == 0)) ? ((void) 0) : (_mi_assert_fail(\"!force || page->local_free == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 247, __func__));\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_page_thread_free_collect",
                "mi_block_next",
                "mi_block_set_next",
                "mi_page_thread_free"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "force",
                        "type": "bool",
                        "definition": [
                            "bool force"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tail",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *tail = page->local_free"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tail_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int tail_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *next"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int next_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_page_reclaim",
            "header": "void _mi_page_reclaim(mi_heap_t *heap, mi_page_t *page)",
            "params": [
                "mi_heap_t *heap",
                "mi_page_t *page"
            ],
            "definition": "void _mi_page_reclaim(mi_heap_t *heap, mi_page_t *page)\n{\n  ;\n  (mi_page_heap(page) == heap) ? ((void) 0) : (_mi_assert_fail(\"mi_page_heap(page) == heap\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 260, __func__));\n  (mi_page_thread_free_flag(page) != MI_NEVER_DELAYED_FREE) ? ((void) 0) : (_mi_assert_fail(\"mi_page_thread_free_flag(page) != MI_NEVER_DELAYED_FREE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 261, __func__));\n  mi_page_queue_t *pq = mi_page_queue(heap, mi_page_block_size(page));\n  mi_page_queue_push(heap, pq, page);\n  ;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_page_block_size",
                "mi_page_heap",
                "mi_page_queue",
                "mi_page_queue_push",
                "mi_page_thread_free_flag"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq = mi_page_queue(heap, mi_page_block_size(page))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_page_bin",
            "header": "size_t _mi_page_bin(const mi_page_t *page)",
            "params": [
                "const mi_page_t *page"
            ],
            "definition": "size_t _mi_page_bin(const mi_page_t *page)\n{\n  const size_t bin = (mi_page_is_in_full(page)) ? (73U + 1) : ((mi_page_is_huge(page)) ? (73U) : (mi_bin(mi_page_block_size(page))));\n  (bin <= (73U + 1)) ? ((void) 0) : (_mi_assert_fail(\"bin <= MI_BIN_FULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 144, __func__));\n  return bin;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_bin",
                "mi_page_block_size",
                "mi_page_is_huge",
                "mi_page_is_in_full"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bin",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bin = (mi_page_is_in_full(page)) ? (73U + 1) : ((mi_page_is_huge(page)) ? (73U) : (mi_bin(mi_page_block_size(page))))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_bin_size",
            "header": "size_t _mi_bin_size(size_t bin)",
            "params": [
                "size_t bin"
            ],
            "definition": "size_t _mi_bin_size(size_t bin)\n{\n  return _mi_heap_empty.pages[bin].block_size;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bin",
                        "type": "size_t",
                        "definition": [
                            "size_t bin"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_empty",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_bin",
            "header": "size_t _mi_bin(size_t size)",
            "params": [
                "size_t size"
            ],
            "definition": "size_t _mi_bin(size_t size)\n{\n  return mi_bin(size);\n}\n\n",
            "calle": [
                "mi_bin"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_queue_is_huge",
            "header": "",
            "params": [
                "const mi_page_queue_t *pq"
            ],
            "definition": "inline static bool mi_page_queue_is_huge(const mi_page_queue_t *pq)\n{\n  return pq->block_size == (((1UL << (3 + (13 + 3))) / 8) + (sizeof(uintptr_t)));\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "pq",
                        "type": "const mi_page_queue_t *",
                        "definition": [
                            "const mi_page_queue_t *pq"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_queue_is_full",
            "header": "",
            "params": [
                "const mi_page_queue_t *pq"
            ],
            "definition": "inline static bool mi_page_queue_is_full(const mi_page_queue_t *pq)\n{\n  return pq->block_size == (((1UL << (3 + (13 + 3))) / 8) + (2 * (sizeof(uintptr_t))));\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "pq",
                        "type": "const mi_page_queue_t *",
                        "definition": [
                            "const mi_page_queue_t *pq"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_queue_is_special",
            "header": "",
            "params": [
                "const mi_page_queue_t *pq"
            ],
            "definition": "inline static bool mi_page_queue_is_special(const mi_page_queue_t *pq)\n{\n  return pq->block_size > ((1UL << (3 + (13 + 3))) / 8);\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "pq",
                        "type": "const mi_page_queue_t *",
                        "definition": [
                            "const mi_page_queue_t *pq"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_bin",
            "header": "",
            "params": [
                "size_t size"
            ],
            "definition": "inline static size_t mi_bin(size_t size)\n{\n  size_t wsize = _mi_wsize_from_size(size);\n  if (__builtin_expect(!(!(wsize <= 8)), 1))\n  {\n    return (wsize <= 1) ? (1) : ((wsize + 1) & (~1));\n  }\n  else\n    if (__builtin_expect(!(!(wsize > (((1UL << (3 + (13 + 3))) / 8) / (1 << 3)))), 0))\n  {\n    return 73U;\n  }\n  else\n  {\n    wsize -= 1;\n    const size_t b = (((1 << 3) * 8) - 1) - mi_clz(wsize);\n    const size_t bin = ((b << 2) + ((wsize >> (b - 2)) & 0x03)) - 3;\n    ((bin > 0) && (bin < 73U)) ? ((void) 0) : (_mi_assert_fail(\"bin > 0 && bin < MI_BIN_HUGE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 88, __func__));\n    return bin;\n  }\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_wsize_from_size",
                "mi_clz"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "wsize",
                        "type": "size_t",
                        "definition": [
                            "size_t wsize = _mi_wsize_from_size(size)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "b",
                        "type": "const size_t",
                        "definition": [
                            "const size_t b = (((1 << 3) * 8) - 1) - mi_clz(wsize)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bin",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bin = ((b << 2) + ((wsize >> (b - 2)) & 0x03)) - 3"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_queue_contains",
            "header": "",
            "params": [
                "mi_page_queue_t *queue",
                "const mi_page_t *page"
            ],
            "definition": "static bool mi_page_queue_contains(mi_page_queue_t *queue, const mi_page_t *page)\n{\n  (page != 0) ? ((void) 0) : (_mi_assert_fail(\"page != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 119, __func__));\n  mi_page_t *list = queue->first;\n  unsigned int list_idx = 0;\n  while ((&list[list_idx]) != 0)\n  {\n    ((list->next == 0) || (list->next->prev == (&list[list_idx]))) ? ((void) 0) : (_mi_assert_fail(\"list->next == NULL || list->next->prev == list\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 122, __func__));\n    ((list->prev == 0) || (list->prev->next == (&list[list_idx]))) ? ((void) 0) : (_mi_assert_fail(\"list->prev == NULL || list->prev->next == list\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 123, __func__));\n    if ((&list[list_idx]) == page)\n    {\n      break;\n    }\n    list_idx = list_idx->next;\n  }\n\n  return (&list[list_idx]) == page;\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "queue",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *queue"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "list",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *list = queue->first"
                        ]
                    },
                    {
                        "path": null,
                        "name": "list_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int list_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_contains_queue",
            "header": "",
            "params": [
                "const mi_heap_t *heap",
                "const mi_page_queue_t *pq"
            ],
            "definition": "static bool mi_heap_contains_queue(const mi_heap_t *heap, const mi_page_queue_t *pq)\n{\n  return (pq >= (&heap->pages[0])) && (pq <= (&heap->pages[73U + 1]));\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "const mi_heap_t *",
                        "definition": [
                            "const mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "const mi_page_queue_t *",
                        "definition": [
                            "const mi_page_queue_t *pq"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_is_large_or_huge",
            "header": "",
            "params": [
                "const mi_page_t *page"
            ],
            "definition": "inline static bool mi_page_is_large_or_huge(const mi_page_t *page)\n{\n  return (mi_page_block_size(page) > ((1UL << (3 + (13 + 3))) / 8)) || mi_page_is_huge(page);\n}\n\n",
            "calle": [
                "mi_page_block_size",
                "mi_page_is_huge"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_page_queue_of",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "const mi_page_t *page"
            ],
            "definition": "static mi_page_queue_t *mi_heap_page_queue_of(mi_heap_t *heap, const mi_page_t *page)\n{\n  (heap != 0) ? ((void) 0) : (_mi_assert_fail(\"heap!=NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 149, __func__));\n  const size_t bin = _mi_page_bin(page);\n  mi_page_queue_t *pq = &heap->pages[bin];\n  (((mi_page_block_size(page) == pq->block_size) || (mi_page_is_large_or_huge(page) && mi_page_queue_is_huge(pq))) || (mi_page_is_in_full(page) && mi_page_queue_is_full(pq))) ? ((void) 0) : (_mi_assert_fail(\"(mi_page_block_size(page) == pq->block_size) || (mi_page_is_large_or_huge(page) && mi_page_queue_is_huge(pq)) || (mi_page_is_in_full(page) && mi_page_queue_is_full(pq))\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 152, __func__));\n  return pq;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_page_bin",
                "mi_page_block_size",
                "mi_page_is_in_full",
                "mi_page_is_large_or_huge",
                "mi_page_queue_is_full",
                "mi_page_queue_is_huge"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bin",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bin = _mi_page_bin(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq = &heap->pages[bin]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_queue_of",
            "header": "",
            "params": [
                "const mi_page_t *page"
            ],
            "definition": "static mi_page_queue_t *mi_page_queue_of(const mi_page_t *page)\n{\n  mi_heap_t *heap = mi_page_heap(page);\n  mi_page_queue_t *pq = mi_heap_page_queue_of(heap, page);\n  ;\n  return pq;\n}\n\n",
            "calle": [
                "mi_heap_page_queue_of",
                "mi_page_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap = mi_page_heap(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq = mi_heap_page_queue_of(heap, page)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_queue_first_update",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "const mi_page_queue_t *pq"
            ],
            "definition": "inline static void mi_heap_queue_first_update(mi_heap_t *heap, const mi_page_queue_t *pq)\n{\n  (mi_heap_contains_queue(heap, pq)) ? ((void) 0) : (_mi_assert_fail(\"mi_heap_contains_queue(heap,pq)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 171, __func__));\n  size_t size = pq->block_size;\n  if (size > (128 * (sizeof(void *))))\n  {\n    return;\n  }\n  mi_page_t *page = pq->first;\n  unsigned int page_idx = 0;\n  if (pq->first == 0)\n  {\n    page_idx = (mi_page_t *) (&_mi_page_empty);\n  }\n  size_t start;\n  size_t idx = _mi_wsize_from_size(size);\n  mi_page_t **pages_free = heap->pages_free_direct;\n  if (pages_free[idx] == (&page[page_idx]))\n  {\n    return;\n  }\n  if (idx <= 1)\n  {\n    start = 0;\n  }\n  else\n  {\n    size_t bin = mi_bin(size);\n    const mi_page_queue_t *prev = pq - 1;\n    unsigned int prev_idx = 0;\n    while ((bin == mi_bin(prev->block_size)) && ((&prev[prev_idx]) > (&heap->pages[0])))\n    {\n      prev_idx -= 1;\n    }\n\n    start = 1 + _mi_wsize_from_size(prev->block_size);\n    if (start > idx)\n    {\n      start = idx;\n    }\n  }\n  (start <= idx) ? ((void) 0) : (_mi_assert_fail(\"start <= idx\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 201, __func__));\n  for (size_t sz = start; sz <= idx; sz += 1)\n  {\n    pages_free[sz] = &page[page_idx];\n  }\n\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_wsize_from_size",
                "mi_bin",
                "mi_heap_contains_queue"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "const mi_page_queue_t *",
                        "definition": [
                            "const mi_page_queue_t *pq"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size = pq->block_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = pq->first"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int page_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "size_t",
                        "definition": [
                            "size_t start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t",
                        "definition": [
                            "size_t idx = _mi_wsize_from_size(size)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pages_free",
                        "type": "mi_page_t **",
                        "definition": [
                            "mi_page_t **pages_free = heap->pages_free_direct"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bin",
                        "type": "size_t",
                        "definition": [
                            "size_t bin = mi_bin(size)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prev",
                        "type": "const mi_page_queue_t *",
                        "definition": [
                            "const mi_page_queue_t *prev = pq - 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prev_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int prev_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "sz",
                        "type": "size_t",
                        "definition": [
                            "size_t sz = start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_page_empty",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_queue_remove",
            "header": "",
            "params": [
                "mi_page_queue_t *queue",
                "mi_page_t *page"
            ],
            "definition": "static void mi_page_queue_remove(mi_page_queue_t *queue, mi_page_t *page)\n{\n  (page != 0) ? ((void) 0) : (_mi_assert_fail(\"page != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 214, __func__));\n  ;\n  (((mi_page_block_size(page) == queue->block_size) || (mi_page_is_large_or_huge(page) && mi_page_queue_is_huge(queue))) || (mi_page_is_in_full(page) && mi_page_queue_is_full(queue))) ? ((void) 0) : (_mi_assert_fail(\"mi_page_block_size(page) == queue->block_size || (mi_page_is_large_or_huge(page) && mi_page_queue_is_huge(queue)) || (mi_page_is_in_full(page) && mi_page_queue_is_full(queue))\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 216, __func__));\n  mi_heap_t *heap = mi_page_heap(page);\n  if (page->prev != 0)\n  {\n    page->prev->next = page->next;\n  }\n  if (page->next != 0)\n  {\n    page->next->prev = page->prev;\n  }\n  if (page == queue->last)\n  {\n    queue->last = page->prev;\n  }\n  if (page == queue->first)\n  {\n    queue->first = page->next;\n    (mi_heap_contains_queue(heap, queue)) ? ((void) 0) : (_mi_assert_fail(\"mi_heap_contains_queue(heap, queue)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 227, __func__));\n    mi_heap_queue_first_update(heap, queue);\n  }\n  heap->page_count -= 1;\n  page->next = 0;\n  page->prev = 0;\n  mi_page_set_in_full(page, 0);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_heap_contains_queue",
                "mi_heap_queue_first_update",
                "mi_page_block_size",
                "mi_page_heap",
                "mi_page_is_in_full",
                "mi_page_is_large_or_huge",
                "mi_page_queue_is_full",
                "mi_page_queue_is_huge",
                "mi_page_set_in_full"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "queue",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *queue"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap = mi_page_heap(page)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_queue_push",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "mi_page_queue_t *queue",
                "mi_page_t *page"
            ],
            "definition": "static void mi_page_queue_push(mi_heap_t *heap, mi_page_queue_t *queue, mi_page_t *page)\n{\n  (mi_page_heap(page) == heap) ? ((void) 0) : (_mi_assert_fail(\"mi_page_heap(page) == heap\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 239, __func__));\n  (!mi_page_queue_contains(queue, page)) ? ((void) 0) : (_mi_assert_fail(\"!mi_page_queue_contains(queue, page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 240, __func__));\n  (((mi_page_block_size(page) == queue->block_size) || (mi_page_is_large_or_huge(page) && mi_page_queue_is_huge(queue))) || (mi_page_is_in_full(page) && mi_page_queue_is_full(queue))) ? ((void) 0) : (_mi_assert_fail(\"mi_page_block_size(page) == queue->block_size || (mi_page_is_large_or_huge(page) && mi_page_queue_is_huge(queue)) || (mi_page_is_in_full(page) && mi_page_queue_is_full(queue))\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 244, __func__));\n  mi_page_set_in_full(page, mi_page_queue_is_full(queue));\n  page->next = queue->first;\n  page->prev = 0;\n  if (queue->first != 0)\n  {\n    (queue->first->prev == 0) ? ((void) 0) : (_mi_assert_fail(\"queue->first->prev == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 253, __func__));\n    queue->first->prev = page;\n    queue->first = page;\n  }\n  else\n  {\n    queue->first = (queue->last = page);\n  }\n  mi_heap_queue_first_update(heap, queue);\n  heap->page_count += 1;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_heap_queue_first_update",
                "mi_page_block_size",
                "mi_page_heap",
                "mi_page_is_in_full",
                "mi_page_is_large_or_huge",
                "mi_page_queue_contains",
                "mi_page_queue_is_full",
                "mi_page_queue_is_huge",
                "mi_page_set_in_full"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "queue",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *queue"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_queue_move_to_front",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "mi_page_queue_t *queue",
                "mi_page_t *page"
            ],
            "definition": "static void mi_page_queue_move_to_front(mi_heap_t *heap, mi_page_queue_t *queue, mi_page_t *page)\n{\n  (mi_page_heap(page) == heap) ? ((void) 0) : (_mi_assert_fail(\"mi_page_heap(page) == heap\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 267, __func__));\n  (mi_page_queue_contains(queue, page)) ? ((void) 0) : (_mi_assert_fail(\"mi_page_queue_contains(queue, page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 268, __func__));\n  if (queue->first == page)\n  {\n    return;\n  }\n  mi_page_queue_remove(queue, page);\n  mi_page_queue_push(heap, queue, page);\n  (queue->first == page) ? ((void) 0) : (_mi_assert_fail(\"queue->first == page\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 272, __func__));\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_page_heap",
                "mi_page_queue_contains",
                "mi_page_queue_push",
                "mi_page_queue_remove"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "queue",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *queue"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_queue_enqueue_from_ex",
            "header": "",
            "params": [
                "mi_page_queue_t *to",
                "mi_page_queue_t *from",
                "bool enqueue_at_end",
                "mi_page_t *page"
            ],
            "definition": "static void mi_page_queue_enqueue_from_ex(mi_page_queue_t *to, mi_page_queue_t *from, bool enqueue_at_end, mi_page_t *page)\n{\n  (page != 0) ? ((void) 0) : (_mi_assert_fail(\"page != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 276, __func__));\n  ;\n  ;\n  const size_t bsize = mi_page_block_size(page);\n  (void) bsize;\n  ((((((bsize == to->block_size) && (bsize == from->block_size)) || ((bsize == to->block_size) && mi_page_queue_is_full(from))) || ((bsize == from->block_size) && mi_page_queue_is_full(to))) || (mi_page_is_large_or_huge(page) && mi_page_queue_is_huge(to))) || (mi_page_is_large_or_huge(page) && mi_page_queue_is_full(to))) ? ((void) 0) : (_mi_assert_fail(\"(bsize == to->block_size && bsize == from->block_size) || (bsize == to->block_size && mi_page_queue_is_full(from)) || (bsize == from->block_size && mi_page_queue_is_full(to)) || (mi_page_is_large_or_huge(page) && mi_page_queue_is_huge(to)) || (mi_page_is_large_or_huge(page) && mi_page_queue_is_full(to))\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 281, __func__));\n  mi_heap_t *heap = mi_page_heap(page);\n  if (page->prev != 0)\n  {\n    page->prev->next = page->next;\n  }\n  if (page->next != 0)\n  {\n    page->next->prev = page->prev;\n  }\n  if (page == from->last)\n  {\n    from->last = page->prev;\n  }\n  if (page == from->first)\n  {\n    from->first = page->next;\n    (mi_heap_contains_queue(heap, from)) ? ((void) 0) : (_mi_assert_fail(\"mi_heap_contains_queue(heap, from)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 296, __func__));\n    mi_heap_queue_first_update(heap, from);\n  }\n  if (enqueue_at_end)\n  {\n    page->prev = to->last;\n    page->next = 0;\n    if (to->last != 0)\n    {\n      (heap == mi_page_heap(to->last)) ? ((void) 0) : (_mi_assert_fail(\"heap == mi_page_heap(to->last)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 306, __func__));\n      to->last->next = page;\n      to->last = page;\n    }\n    else\n    {\n      to->first = page;\n      to->last = page;\n      mi_heap_queue_first_update(heap, to);\n    }\n  }\n  else\n  {\n    helper_mi_page_queue_enqueue_from_ex_1(to, page, heap);\n  }\n  mi_page_set_in_full(page, mi_page_queue_is_full(to));\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "helper_mi_page_queue_enqueue_from_ex_1",
                "mi_heap_contains_queue",
                "mi_heap_queue_first_update",
                "mi_page_block_size",
                "mi_page_heap",
                "mi_page_is_large_or_huge",
                "mi_page_queue_is_full",
                "mi_page_queue_is_huge",
                "mi_page_set_in_full"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "to",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *to"
                        ]
                    },
                    {
                        "path": null,
                        "name": "from",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *from"
                        ]
                    },
                    {
                        "path": null,
                        "name": "enqueue_at_end",
                        "type": "bool",
                        "definition": [
                            "bool enqueue_at_end"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bsize = mi_page_block_size(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap = mi_page_heap(page)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_queue_enqueue_from",
            "header": "",
            "params": [
                "mi_page_queue_t *to",
                "mi_page_queue_t *from",
                "mi_page_t *page"
            ],
            "definition": "static void mi_page_queue_enqueue_from(mi_page_queue_t *to, mi_page_queue_t *from, mi_page_t *page)\n{\n  mi_page_queue_enqueue_from_ex(to, from, 1, page);\n}\n\n",
            "calle": [
                "mi_page_queue_enqueue_from_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "to",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *to"
                        ]
                    },
                    {
                        "path": null,
                        "name": "from",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *from"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_queue_enqueue_from_full",
            "header": "",
            "params": [
                "mi_page_queue_t *to",
                "mi_page_queue_t *from",
                "mi_page_t *page"
            ],
            "definition": "static void mi_page_queue_enqueue_from_full(mi_page_queue_t *to, mi_page_queue_t *from, mi_page_t *page)\n{\n  mi_page_queue_enqueue_from_ex(to, from, 1, page);\n}\n\n",
            "calle": [
                "mi_page_queue_enqueue_from_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "to",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *to"
                        ]
                    },
                    {
                        "path": null,
                        "name": "from",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *from"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_block_at",
            "header": "",
            "params": [
                "const mi_page_t *page",
                "void *page_start",
                "size_t block_size",
                "size_t i"
            ],
            "definition": "inline static mi_block_t *mi_page_block_at(const mi_page_t *page, void *page_start, size_t block_size, size_t i)\n{\n  (void) page;\n  (page != 0) ? ((void) 0) : (_mi_assert_fail(\"page != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 34, __func__));\n  (i <= page->reserved) ? ((void) 0) : (_mi_assert_fail(\"i <= page->reserved\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 35, __func__));\n  return (mi_block_t *) (((uint8_t *) page_start) + (i * block_size));\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_start",
                        "type": "void *",
                        "definition": [
                            "void *page_start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_size",
                        "type": "size_t",
                        "definition": [
                            "size_t block_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_init",
            "header": "static void mi_page_init(mi_heap_t *heap, mi_page_t *page, size_t size, mi_tld_t *tld)",
            "params": [
                "mi_heap_t *heap",
                "mi_page_t *page",
                "size_t block_size",
                "mi_tld_t *tld"
            ],
            "definition": "static void mi_page_init(mi_heap_t *heap, mi_page_t *page, size_t block_size, mi_tld_t *tld)\n{\n  (page != 0) ? ((void) 0) : (_mi_assert_fail(\"page != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 680, __func__));\n  mi_segment_t *segment = _mi_page_segment(page);\n  (segment != 0) ? ((void) 0) : (_mi_assert_fail(\"segment != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 682, __func__));\n  (block_size > 0) ? ((void) 0) : (_mi_assert_fail(\"block_size > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 683, __func__));\n  mi_page_set_heap(page, heap);\n  page->block_size = block_size;\n  size_t page_size;\n  page->page_start = _mi_segment_page_start(segment, page, &page_size);\n  ;\n  (mi_page_block_size(page) <= page_size) ? ((void) 0) : (_mi_assert_fail(\"mi_page_block_size(page) <= page_size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 690, __func__));\n  (page_size <= (page->slice_count * (1UL << (13 + 3)))) ? ((void) 0) : (_mi_assert_fail(\"page_size <= page->slice_count*MI_SEGMENT_SLICE_SIZE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 691, __func__));\n  ((page_size / block_size) < (1L << 16)) ? ((void) 0) : (_mi_assert_fail(\"page_size / block_size < (1L<<16)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 692, __func__));\n  page->reserved = (uint16_t) (page_size / block_size);\n  (page->reserved > 0) ? ((void) 0) : (_mi_assert_fail(\"page->reserved > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 694, __func__));\n  page->keys[0] = _mi_heap_random_next(heap);\n  page->keys[1] = _mi_heap_random_next(heap);\n  page->free_is_zero = page->is_zero_init;\n  (page->is_committed) ? ((void) 0) : (_mi_assert_fail(\"page->is_committed\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 706, __func__));\n  if ((block_size > 0) && _mi_is_power_of_two(block_size))\n  {\n    page->block_size_shift = (uint8_t) mi_ctz((uintptr_t) block_size);\n  }\n  else\n  {\n    page->block_size_shift = 0;\n  }\n  (page->capacity == 0) ? ((void) 0) : (_mi_assert_fail(\"page->capacity == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 714, __func__));\n  (page->free == 0) ? ((void) 0) : (_mi_assert_fail(\"page->free == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 715, __func__));\n  (page->used == 0) ? ((void) 0) : (_mi_assert_fail(\"page->used == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 716, __func__));\n  (page->xthread_free == 0) ? ((void) 0) : (_mi_assert_fail(\"page->xthread_free == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 717, __func__));\n  (page->next == 0) ? ((void) 0) : (_mi_assert_fail(\"page->next == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 718, __func__));\n  (page->prev == 0) ? ((void) 0) : (_mi_assert_fail(\"page->prev == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 719, __func__));\n  (page->retire_expire == 0) ? ((void) 0) : (_mi_assert_fail(\"page->retire_expire == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 720, __func__));\n  (!mi_page_has_aligned(page)) ? ((void) 0) : (_mi_assert_fail(\"!mi_page_has_aligned(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 721, __func__));\n  (page->keys[0] != 0) ? ((void) 0) : (_mi_assert_fail(\"page->keys[0] != 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 723, __func__));\n  (page->keys[1] != 0) ? ((void) 0) : (_mi_assert_fail(\"page->keys[1] != 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 724, __func__));\n  ((page->block_size_shift == 0) || (block_size == (((size_t) 1) << page->block_size_shift))) ? ((void) 0) : (_mi_assert_fail(\"page->block_size_shift == 0 || (block_size == ((size_t)1 << page->block_size_shift))\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 726, __func__));\n  ;\n  if (mi_page_extend_free(heap, page, tld))\n  {\n    (mi_page_immediate_available(page)) ? ((void) 0) : (_mi_assert_fail(\"mi_page_immediate_available(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 731, __func__));\n  }\n  return;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_heap_random_next",
                "_mi_is_power_of_two",
                "_mi_page_segment",
                "_mi_segment_page_start",
                "mi_ctz",
                "mi_page_block_size",
                "mi_page_extend_free",
                "mi_page_has_aligned",
                "mi_page_immediate_available",
                "mi_page_set_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_size",
                        "type": "size_t",
                        "definition": [
                            "size_t block_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_tld_t *",
                        "definition": [
                            "mi_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = _mi_page_segment(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_size",
                        "type": "size_t",
                        "definition": [
                            "size_t page_size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_extend_free",
            "header": "static bool mi_page_extend_free(mi_heap_t *heap, mi_page_t *page, mi_tld_t *tld)",
            "params": [
                "mi_heap_t *heap",
                "mi_page_t *page",
                "mi_tld_t *tld"
            ],
            "definition": "static bool mi_page_extend_free(mi_heap_t *heap, mi_page_t *page, mi_tld_t *tld)\n{\n  ;\n  (page->free == 0) ? ((void) 0) : (_mi_assert_fail(\"page->free == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 638, __func__));\n  (page->local_free == 0) ? ((void) 0) : (_mi_assert_fail(\"page->local_free == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 639, __func__));\n  if (page->free != 0)\n  {\n    return 1;\n  }\n  if (page->capacity >= page->reserved)\n  {\n    return 1;\n  }\n  _mi_stat_counter_increase(&tld->stats.pages_extended, 1);\n  const size_t bsize = mi_page_block_size(page);\n  size_t extend = page->reserved - page->capacity;\n  (extend > 0) ? ((void) 0) : (_mi_assert_fail(\"extend > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 649, __func__));\n  size_t max_extend = (bsize >= (4 * 1024)) ? (4) : ((4 * 1024) / bsize);\n  if (max_extend < 4)\n  {\n    max_extend = 4;\n  }\n  (max_extend > 0) ? ((void) 0) : (_mi_assert_fail(\"max_extend > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 653, __func__));\n  if (extend > max_extend)\n  {\n    extend = max_extend;\n  }\n  ((extend > 0) && ((extend + page->capacity) <= page->reserved)) ? ((void) 0) : (_mi_assert_fail(\"extend > 0 && extend + page->capacity <= page->reserved\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 661, __func__));\n  (extend < (1UL << 16)) ? ((void) 0) : (_mi_assert_fail(\"extend < (1UL<<16)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 662, __func__));\n  if ((extend < 2) || (0 == 0))\n  {\n    mi_page_free_list_extend(page, bsize, extend, &tld->stats);\n  }\n  else\n  {\n    mi_page_free_list_extend_secure(heap, page, bsize, extend, &tld->stats);\n  }\n  page->capacity += (uint16_t) extend;\n  _mi_stat_increase(&tld->stats.page_committed, extend * bsize);\n  ;\n  return 1;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_stat_counter_increase",
                "_mi_stat_increase",
                "mi_page_block_size",
                "mi_page_free_list_extend",
                "mi_page_free_list_extend_secure"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_tld_t *",
                        "definition": [
                            "mi_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bsize = mi_page_block_size(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "extend",
                        "type": "size_t",
                        "definition": [
                            "size_t extend = page->reserved - page->capacity"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max_extend",
                        "type": "size_t",
                        "definition": [
                            "size_t max_extend = (bsize >= (4 * 1024)) ? (4) : ((4 * 1024) / bsize)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_page_thread_free_collect",
            "header": "",
            "params": [
                "mi_page_t *page"
            ],
            "definition": "static void _mi_page_thread_free_collect(mi_page_t *page)\n{\n  mi_block_t *head;\n  unsigned int head_idx = 0;\n  mi_thread_free_t tfreex;\n  mi_thread_free_t tfree = atomic_load_explicit(&page->xthread_free, memory_order_relaxed);\n  do\n  {\n    head_idx = mi_tf_block(tfree);\n    tfreex = mi_tf_set_block(tfree, 0);\n  }\n  while (!atomic_compare_exchange_weak_explicit(&page->xthread_free, &tfree, tfreex, memory_order_acq_rel, memory_order_acquire));\n  if ((&head[head_idx]) == 0)\n  {\n    return;\n  }\n  size_t max_count = page->capacity;\n  size_t count = 1;\n  mi_block_t *tail = head;\n  unsigned int tail_idx = 0;\n  mi_block_t *next;\n  unsigned int next_idx = 0;\n  while (((next_idx = mi_block_next(page, tail)) != 0) && (count <= max_count))\n  {\n    count += 1;\n    tail_idx = &next[next_idx];\n  }\n\n  if (count > max_count)\n  {\n    _mi_error_message(14, \"corrupted thread-free list\\n\");\n    return;\n  }\n  mi_block_set_next(page, tail, page->local_free);\n  page->local_free = &head[head_idx];\n  page->used -= (uint16_t) count;\n}\n\n",
            "calle": [
                "_mi_error_message",
                "atomic_compare_exchange_weak_explicit",
                "atomic_load_explicit",
                "mi_block_next",
                "mi_block_set_next",
                "mi_tf_block",
                "mi_tf_set_block"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "head",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *head"
                        ]
                    },
                    {
                        "path": null,
                        "name": "head_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int head_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tfreex",
                        "type": "mi_thread_free_t",
                        "definition": [
                            "mi_thread_free_t tfreex"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tfree",
                        "type": "mi_thread_free_t",
                        "definition": [
                            "mi_thread_free_t tfree = atomic_load_explicit(&page->xthread_free, memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max_count",
                        "type": "size_t",
                        "definition": [
                            "size_t max_count = page->capacity"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count = 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tail",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *tail = head"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tail_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int tail_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *next"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int next_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_fresh_alloc",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "mi_page_queue_t *pq",
                "size_t block_size",
                "size_t page_alignment"
            ],
            "definition": "static mi_page_t *mi_page_fresh_alloc(mi_heap_t *heap, mi_page_queue_t *pq, size_t block_size, size_t page_alignment)\n{\n  (pq != 0) ? ((void) 0) : (_mi_assert_fail(\"pq != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 275, __func__));\n  (mi_heap_contains_queue(heap, pq)) ? ((void) 0) : (_mi_assert_fail(\"mi_heap_contains_queue(heap, pq)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 276, __func__));\n  (((page_alignment > 0) || (block_size > ((1UL << (3 + (13 + 3))) / 8))) || (block_size == pq->block_size)) ? ((void) 0) : (_mi_assert_fail(\"page_alignment > 0 || block_size > MI_MEDIUM_OBJ_SIZE_MAX || block_size == pq->block_size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 277, __func__));\n  mi_page_t *page = _mi_segment_page_alloc(heap, block_size, page_alignment, &heap->tld->segments);\n  if (page == 0)\n  {\n    return 0;\n  }\n  (((page_alignment > 0) || (block_size > ((1UL << (3 + (13 + 3))) / 8))) || (_mi_page_segment(page)->kind != MI_SEGMENT_HUGE)) ? ((void) 0) : (_mi_assert_fail(\"page_alignment >0 || block_size > MI_MEDIUM_OBJ_SIZE_MAX || _mi_page_segment(page)->kind != MI_SEGMENT_HUGE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 287, __func__));\n  ((pq != 0) || (mi_page_block_size(page) >= block_size)) ? ((void) 0) : (_mi_assert_fail(\"pq!=NULL || mi_page_block_size(page) >= block_size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 288, __func__));\n  const size_t full_block_size = ((pq == 0) || mi_page_is_huge(page)) ? (mi_page_block_size(page)) : (block_size);\n  (full_block_size >= block_size) ? ((void) 0) : (_mi_assert_fail(\"full_block_size >= block_size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 291, __func__));\n  mi_page_init(heap, page, full_block_size, heap->tld);\n  _mi_stat_increase(&heap->tld->stats.pages, 1);\n  _mi_stat_increase(&heap->tld->stats.page_bins[_mi_page_bin(page)], 1);\n  if (pq != 0)\n  {\n    mi_page_queue_push(heap, pq, page);\n  }\n  ;\n  return page;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_page_bin",
                "_mi_page_segment",
                "_mi_segment_page_alloc",
                "_mi_stat_increase",
                "mi_heap_contains_queue",
                "mi_page_block_size",
                "mi_page_init",
                "mi_page_is_huge",
                "mi_page_queue_push"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_size",
                        "type": "size_t",
                        "definition": [
                            "size_t block_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t page_alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = _mi_segment_page_alloc(heap, block_size, page_alignment, &heap->tld->segments)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "full_block_size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t full_block_size = ((pq == 0) || mi_page_is_huge(page)) ? (mi_page_block_size(page)) : (block_size)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_fresh",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "mi_page_queue_t *pq"
            ],
            "definition": "static mi_page_t *mi_page_fresh(mi_heap_t *heap, mi_page_queue_t *pq)\n{\n  (mi_heap_contains_queue(heap, pq)) ? ((void) 0) : (_mi_assert_fail(\"mi_heap_contains_queue(heap, pq)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 302, __func__));\n  mi_page_t *page = mi_page_fresh_alloc(heap, pq, pq->block_size, 0);\n  if (page == 0)\n  {\n    return 0;\n  }\n  (pq->block_size == mi_page_block_size(page)) ? ((void) 0) : (_mi_assert_fail(\"pq->block_size==mi_page_block_size(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 305, __func__));\n  (pq == mi_page_queue(heap, mi_page_block_size(page))) ? ((void) 0) : (_mi_assert_fail(\"pq==mi_page_queue(heap, mi_page_block_size(page))\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 306, __func__));\n  return page;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_heap_contains_queue",
                "mi_page_block_size",
                "mi_page_fresh_alloc",
                "mi_page_queue"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = mi_page_fresh_alloc(heap, pq, pq->block_size, 0)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_to_full",
            "header": "",
            "params": [
                "mi_page_t *page",
                "mi_page_queue_t *pq"
            ],
            "definition": "static void mi_page_to_full(mi_page_t *page, mi_page_queue_t *pq)\n{\n  (pq == mi_page_queue_of(page)) ? ((void) 0) : (_mi_assert_fail(\"pq == mi_page_queue_of(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 366, __func__));\n  (!mi_page_immediate_available(page)) ? ((void) 0) : (_mi_assert_fail(\"!mi_page_immediate_available(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 367, __func__));\n  (!mi_page_is_in_full(page)) ? ((void) 0) : (_mi_assert_fail(\"!mi_page_is_in_full(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 368, __func__));\n  if (mi_page_is_in_full(page))\n  {\n    return;\n  }\n  mi_page_queue_enqueue_from(&mi_page_heap(page)->pages[73U + 1], pq, page);\n  _mi_page_free_collect(page, 0);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_page_free_collect",
                "mi_page_heap",
                "mi_page_immediate_available",
                "mi_page_is_in_full",
                "mi_page_queue_enqueue_from",
                "mi_page_queue_of"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_free_list_extend_secure",
            "header": "",
            "params": [
                "mi_heap_t * const heap",
                "mi_page_t * const page",
                "const size_t bsize",
                "const size_t extend",
                "mi_stats_t * const stats"
            ],
            "definition": "static void mi_page_free_list_extend_secure(mi_heap_t * const heap, mi_page_t * const page, const size_t bsize, const size_t extend, mi_stats_t * const stats)\n{\n  (void) stats;\n  (page->free == 0) ? ((void) 0) : (_mi_assert_fail(\"page->free == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 539, __func__));\n  (page->local_free == 0) ? ((void) 0) : (_mi_assert_fail(\"page->local_free == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 540, __func__));\n  ((page->capacity + extend) <= page->reserved) ? ((void) 0) : (_mi_assert_fail(\"page->capacity + extend <= page->reserved\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 542, __func__));\n  (bsize == mi_page_block_size(page)) ? ((void) 0) : (_mi_assert_fail(\"bsize == mi_page_block_size(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 543, __func__));\n  void * const page_area = mi_page_start(page);\n  size_t shift = 6;\n  while ((extend >> shift) == 0)\n  {\n    shift -= 1;\n  }\n\n  const size_t slice_count = ((size_t) 1U) << shift;\n  const size_t slice_extend = extend / slice_count;\n  (slice_extend >= 1) ? ((void) 0) : (_mi_assert_fail(\"slice_extend >= 1\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 554, __func__));\n  mi_block_t *blocks[1UL << 6];\n  size_t counts[1UL << 6];\n  for (size_t i = 0; i < slice_count; i += 1)\n  {\n    blocks[i] = mi_page_block_at(page, page_area, bsize, page->capacity + (i * slice_extend));\n    counts[i] = slice_extend;\n  }\n\n  counts[slice_count - 1] += extend % slice_count;\n  const uintptr_t r = _mi_heap_random_next(heap);\n  size_t current = r % slice_count;\n  counts[current] -= 1;\n  mi_block_t * const free_start = blocks[current];\n  uintptr_t rnd = _mi_random_shuffle(r | 1);\n  for (size_t i = 1; i < extend; i += 1)\n  {\n    helper_mi_page_free_list_extend_secure_1(&current, &rnd, page, bsize, slice_count, blocks, counts, i, i);\n  }\n\n  mi_block_set_next(page, blocks[current], page->free);\n  page->free = free_start;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_heap_random_next",
                "_mi_random_shuffle",
                "helper_mi_page_free_list_extend_secure_1",
                "mi_block_set_next",
                "mi_page_block_at",
                "mi_page_block_size",
                "mi_page_start"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t * const",
                        "definition": [
                            "mi_heap_t * const heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t * const",
                        "definition": [
                            "mi_page_t * const page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "extend",
                        "type": "const size_t",
                        "definition": [
                            "const size_t extend"
                        ]
                    },
                    {
                        "path": null,
                        "name": "stats",
                        "type": "mi_stats_t * const",
                        "definition": [
                            "mi_stats_t * const stats"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_area",
                        "type": "void * const",
                        "definition": [
                            "void * const page_area = mi_page_start(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "shift",
                        "type": "size_t",
                        "definition": [
                            "size_t shift = 6"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_count",
                        "type": "const size_t",
                        "definition": [
                            "const size_t slice_count = ((size_t) 1U) << shift"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_extend",
                        "type": "const size_t",
                        "definition": [
                            "const size_t slice_extend = extend / slice_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "blocks",
                        "type": "mi_block_t *[1UL << 6]",
                        "definition": [
                            "mi_block_t *blocks[1UL << 6]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "counts",
                        "type": "size_t [1UL << 6]",
                        "definition": [
                            "size_t counts[1UL << 6]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0",
                            "size_t i = 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "r",
                        "type": "const uintptr_t",
                        "definition": [
                            "const uintptr_t r = _mi_heap_random_next(heap)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current",
                        "type": "size_t",
                        "definition": [
                            "size_t current = r % slice_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "free_start",
                        "type": "mi_block_t * const",
                        "definition": [
                            "mi_block_t * const free_start = blocks[current]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "rnd",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t rnd = _mi_random_shuffle(r | 1)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_free_list_extend",
            "header": "",
            "params": [
                "mi_page_t * const page",
                "const size_t bsize",
                "const size_t extend",
                "mi_stats_t * const stats"
            ],
            "definition": "static void mi_page_free_list_extend(mi_page_t * const page, const size_t bsize, const size_t extend, mi_stats_t * const stats)\n{\n  (void) stats;\n  (page->free == 0) ? ((void) 0) : (_mi_assert_fail(\"page->free == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 597, __func__));\n  (page->local_free == 0) ? ((void) 0) : (_mi_assert_fail(\"page->local_free == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 598, __func__));\n  ((page->capacity + extend) <= page->reserved) ? ((void) 0) : (_mi_assert_fail(\"page->capacity + extend <= page->reserved\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 600, __func__));\n  (bsize == mi_page_block_size(page)) ? ((void) 0) : (_mi_assert_fail(\"bsize == mi_page_block_size(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 601, __func__));\n  void * const page_area = mi_page_start(page);\n  mi_block_t * const start = mi_page_block_at(page, page_area, bsize, page->capacity);\n  mi_block_t * const last = mi_page_block_at(page, page_area, bsize, (page->capacity + extend) - 1);\n  mi_block_t *block = start;\n  unsigned int block_idx = 0;\n  while ((&block[block_idx]) <= last)\n  {\n    mi_block_t *next = (mi_block_t *) (((uint8_t *) block) + bsize);\n    mi_block_set_next(page, block, next);\n    block_idx = next;\n  }\n\n  mi_block_set_next(page, last, page->free);\n  page->free = start;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_block_set_next",
                "mi_page_block_at",
                "mi_page_block_size",
                "mi_page_start"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t * const",
                        "definition": [
                            "mi_page_t * const page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "extend",
                        "type": "const size_t",
                        "definition": [
                            "const size_t extend"
                        ]
                    },
                    {
                        "path": null,
                        "name": "stats",
                        "type": "mi_stats_t * const",
                        "definition": [
                            "mi_stats_t * const stats"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_area",
                        "type": "void * const",
                        "definition": [
                            "void * const page_area = mi_page_start(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "mi_block_t * const",
                        "definition": [
                            "mi_block_t * const start = mi_page_block_at(page, page_area, bsize, page->capacity)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "last",
                        "type": "mi_block_t * const",
                        "definition": [
                            "mi_block_t * const last = mi_page_block_at(page, page_area, bsize, (page->capacity + extend) - 1)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *block = start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int block_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *next = (mi_block_t *) (((uint8_t *) block) + bsize)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_is_expandable",
            "header": "",
            "params": [
                "const mi_page_t *page"
            ],
            "definition": "static bool mi_page_is_expandable(const mi_page_t *page)\n{\n  (page != 0) ? ((void) 0) : (_mi_assert_fail(\"page != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 746, __func__));\n  (page->capacity <= page->reserved) ? ((void) 0) : (_mi_assert_fail(\"page->capacity <= page->reserved\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 747, __func__));\n  return page->capacity < page->reserved;\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_page_queue_find_free_ex",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "mi_page_queue_t *pq",
                "bool first_try"
            ],
            "definition": "static mi_page_t *mi_page_queue_find_free_ex(mi_heap_t *heap, mi_page_queue_t *pq, bool first_try)\n{\n  size_t count = 0;\n  size_t candidate_count = 0;\n  mi_page_t *page_candidate = 0;\n  unsigned int page_candidate_idx = 0;\n  mi_page_t *page = pq->first;\n  unsigned int page_idx = 0;\n  while ((&page[page_idx]) != 0)\n  {\n    helper_mi_page_queue_find_free_ex_1(&count, &candidate_count, &page_candidate_idx, &page_idx, pq, page_candidate, page);\n  }\n\n  _mi_stat_counter_increase(&heap->tld->stats.page_searches, count);\n  if ((&page_candidate[page_candidate_idx]) != 0)\n  {\n    page_idx = &page_candidate[page_candidate_idx];\n  }\n  if ((&page[page_idx]) != 0)\n  {\n    if (!mi_page_immediate_available(page))\n    {\n      (mi_page_is_expandable(page)) ? ((void) 0) : (_mi_assert_fail(\"mi_page_is_expandable(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 827, __func__));\n      if (!mi_page_extend_free(heap, page, heap->tld))\n      {\n        page_idx = 0;\n      }\n    }\n    (((&page[page_idx]) == 0) || mi_page_immediate_available(page)) ? ((void) 0) : (_mi_assert_fail(\"page == NULL || mi_page_immediate_available(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 832, __func__));\n  }\n  if ((&page[page_idx]) == 0)\n  {\n    _mi_heap_collect_retired(heap, 0);\n    page_idx = mi_page_fresh(heap, pq);\n    if (((&page[page_idx]) == 0) && first_try)\n    {\n      page_idx = mi_page_queue_find_free_ex(heap, pq, 0);\n    }\n  }\n  else\n  {\n    mi_page_queue_move_to_front(heap, pq, page);\n    page->retire_expire = 0;\n  }\n  (((&page[page_idx]) == 0) || mi_page_immediate_available(page)) ? ((void) 0) : (_mi_assert_fail(\"page == NULL || mi_page_immediate_available(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 849, __func__));\n  return page;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_heap_collect_retired",
                "_mi_stat_counter_increase",
                "helper_mi_page_queue_find_free_ex_1",
                "mi_page_extend_free",
                "mi_page_fresh",
                "mi_page_immediate_available",
                "mi_page_is_expandable",
                "mi_page_queue_find_free_ex",
                "mi_page_queue_move_to_front"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq"
                        ]
                    },
                    {
                        "path": null,
                        "name": "first_try",
                        "type": "bool",
                        "definition": [
                            "bool first_try"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "candidate_count",
                        "type": "size_t",
                        "definition": [
                            "size_t candidate_count = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_candidate",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page_candidate = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_candidate_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int page_candidate_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = pq->first"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int page_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_find_free_page",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "size_t size"
            ],
            "definition": "inline static mi_page_t *mi_find_free_page(mi_heap_t *heap, size_t size)\n{\n  mi_page_queue_t *pq = mi_page_queue(heap, size);\n  mi_page_t *page = pq->first;\n  if (page != 0)\n  {\n    {\n      _mi_page_free_collect(page, 0);\n    }\n    if (mi_page_immediate_available(page))\n    {\n      page->retire_expire = 0;\n      return page;\n    }\n  }\n  return mi_page_queue_find_free_ex(heap, pq, 1);\n}\n\n",
            "calle": [
                "_mi_page_free_collect",
                "mi_page_immediate_available",
                "mi_page_queue",
                "mi_page_queue_find_free_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq = mi_page_queue(heap, size)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = pq->first"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_large_huge_page_alloc",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "size_t size",
                "size_t page_alignment"
            ],
            "definition": "static mi_page_t *mi_large_huge_page_alloc(mi_heap_t *heap, size_t size, size_t page_alignment)\n{\n  size_t block_size = _mi_os_good_alloc_size(size);\n  ((mi_bin(block_size) == 73U) || (page_alignment > 0)) ? ((void) 0) : (_mi_assert_fail(\"mi_bin(block_size) == MI_BIN_HUGE || page_alignment > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 920, __func__));\n  bool is_huge = (block_size > ((1UL << (9 + (13 + 3))) / 2)) || (page_alignment > 0);\n  mi_page_queue_t *pq = mi_page_queue(heap, (is_huge) ? (((1UL << (9 + (13 + 3))) / 2) + 1) : (block_size));\n  ((!is_huge) || mi_page_queue_is_huge(pq)) ? ((void) 0) : (_mi_assert_fail(\"!is_huge || mi_page_queue_is_huge(pq)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 926, __func__));\n  mi_page_t *page = mi_page_fresh_alloc(heap, pq, block_size, page_alignment);\n  if (page != 0)\n  {\n    (mi_page_immediate_available(page)) ? ((void) 0) : (_mi_assert_fail(\"mi_page_immediate_available(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 930, __func__));\n    if (is_huge)\n    {\n      (mi_page_is_huge(page)) ? ((void) 0) : (_mi_assert_fail(\"mi_page_is_huge(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 933, __func__));\n      (_mi_page_segment(page)->kind == MI_SEGMENT_HUGE) ? ((void) 0) : (_mi_assert_fail(\"_mi_page_segment(page)->kind == MI_SEGMENT_HUGE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 934, __func__));\n      (_mi_page_segment(page)->used == 1) ? ((void) 0) : (_mi_assert_fail(\"_mi_page_segment(page)->used==1\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 935, __func__));\n    }\n    else\n    {\n      (!mi_page_is_huge(page)) ? ((void) 0) : (_mi_assert_fail(\"!mi_page_is_huge(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 942, __func__));\n    }\n    const size_t bsize = mi_page_usable_block_size(page);\n    {\n      _mi_stat_increase(&heap->tld->stats.malloc_huge, bsize);\n      _mi_stat_counter_increase(&heap->tld->stats.malloc_huge_count, 1);\n    }\n  }\n  return page;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_os_good_alloc_size",
                "_mi_page_segment",
                "_mi_stat_counter_increase",
                "_mi_stat_increase",
                "mi_bin",
                "mi_page_fresh_alloc",
                "mi_page_immediate_available",
                "mi_page_is_huge",
                "mi_page_queue",
                "mi_page_queue_is_huge",
                "mi_page_usable_block_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t page_alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_size",
                        "type": "size_t",
                        "definition": [
                            "size_t block_size = _mi_os_good_alloc_size(size)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_huge",
                        "type": "bool",
                        "definition": [
                            "bool is_huge = (block_size > ((1UL << (9 + (13 + 3))) / 2)) || (page_alignment > 0)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t *",
                        "definition": [
                            "mi_page_queue_t *pq = mi_page_queue(heap, (is_huge) ? (((1UL << (9 + (13 + 3))) / 2) + 1) : (block_size))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = mi_page_fresh_alloc(heap, pq, block_size, page_alignment)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bsize = mi_page_usable_block_size(page)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_find_page",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "size_t size",
                "size_t huge_alignment"
            ],
            "definition": "static mi_page_t *mi_find_page(mi_heap_t *heap, size_t size, size_t huge_alignment)\n{\n  const size_t req_size = size - (sizeof(mi_padding_t));\n  if (__builtin_expect(!(!((req_size > (((1UL << (3 + (13 + 3))) / 8) - (sizeof(mi_padding_t)))) || (huge_alignment > 0))), 0))\n  {\n    if (__builtin_expect(!(!(req_size > PTRDIFF_MAX)), 0))\n    {\n      _mi_error_message(75, \"allocation request is too large (%zu bytes)\\n\", req_size);\n      return 0;\n    }\n    else\n    {\n      return mi_large_huge_page_alloc(heap, size, huge_alignment);\n    }\n  }\n  else\n  {\n    (size >= (sizeof(mi_padding_t))) ? ((void) 0) : (_mi_assert_fail(\"size >= MI_PADDING_SIZE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 977, __func__));\n    return mi_find_free_page(heap, size);\n  }\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_error_message",
                "mi_find_free_page",
                "mi_large_huge_page_alloc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "huge_alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t huge_alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "req_size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t req_size = size - (sizeof(mi_padding_t))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper_mi_page_queue_enqueue_from_ex_1",
            "header": "",
            "params": [
                "mi_page_queue_t * const to",
                "mi_page_t * const page",
                "mi_heap_t * const heap"
            ],
            "definition": "void helper_mi_page_queue_enqueue_from_ex_1(mi_page_queue_t * const to, mi_page_t * const page, mi_heap_t * const heap)\n{\n  if (to->first != 0)\n  {\n    (heap == mi_page_heap(to->first)) ? ((void) 0) : (_mi_assert_fail(\"heap == mi_page_heap(to->first)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page-queue.c\", 319, __func__));\n    mi_page_t *next = to->first->next;\n    page->prev = to->first;\n    page->next = next;\n    to->first->next = page;\n    if (next != 0)\n    {\n      next->prev = page;\n    }\n    else\n    {\n      to->last = page;\n    }\n  }\n  else\n  {\n    page->prev = 0;\n    page->next = 0;\n    to->first = page;\n    to->last = page;\n    mi_heap_queue_first_update(heap, to);\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_heap_queue_first_update",
                "mi_page_heap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "to",
                        "type": "mi_page_queue_t * const",
                        "definition": [
                            "mi_page_queue_t * const to"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t * const",
                        "definition": [
                            "mi_page_t * const page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t * const",
                        "definition": [
                            "mi_heap_t * const heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *next = to->first->next"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper_mi_page_free_list_extend_secure_1",
            "header": "",
            "params": [
                "size_t * const current_ref",
                "uintptr_t * const rnd_ref",
                "mi_page_t * const page",
                "const size_t bsize",
                "const size_t slice_count",
                "mi_block_t *blocks[1UL << 6]",
                "size_t counts[1UL << 6]",
                "size_t i",
                "size_t i"
            ],
            "definition": "void helper_mi_page_free_list_extend_secure_1(size_t * const current_ref, uintptr_t * const rnd_ref, mi_page_t * const page, const size_t bsize, const size_t slice_count, mi_block_t *blocks[1UL << 6], size_t counts[1UL << 6], size_t i, size_t i)\n{\n  size_t current = *current_ref;\n  uintptr_t rnd = *rnd_ref;\n  const size_t round = i % (1 << 3);\n  if (round == 0)\n  {\n    rnd = _mi_random_shuffle(rnd);\n  }\n  size_t next = (rnd >> (8 * round)) & (slice_count - 1);\n  while (counts[next] == 0)\n  {\n    next += 1;\n    if (next == slice_count)\n    {\n      next = 0;\n    }\n  }\n\n  counts[next] -= 1;\n  mi_block_t * const block = blocks[current];\n  blocks[current] = (mi_block_t *) (((uint8_t *) block) + bsize);\n  mi_block_set_next(page, block, blocks[next]);\n  current = next;\n  *current_ref = current;\n  *rnd_ref = rnd;\n}\n\n",
            "calle": [
                "_mi_random_shuffle",
                "mi_block_set_next"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "current_ref",
                        "type": "size_t * const",
                        "definition": [
                            "size_t * const current_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "rnd_ref",
                        "type": "uintptr_t * const",
                        "definition": [
                            "uintptr_t * const rnd_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t * const",
                        "definition": [
                            "mi_page_t * const page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bsize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_count",
                        "type": "const size_t",
                        "definition": [
                            "const size_t slice_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "blocks",
                        "type": "mi_block_t *[1UL << 6]",
                        "definition": [
                            "mi_block_t *blocks[1UL << 6]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "counts",
                        "type": "size_t [1UL << 6]",
                        "definition": [
                            "size_t counts[1UL << 6]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current",
                        "type": "size_t",
                        "definition": [
                            "size_t current = *current_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "rnd",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t rnd = *rnd_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "round",
                        "type": "const size_t",
                        "definition": [
                            "const size_t round = i % (1 << 3)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next",
                        "type": "size_t",
                        "definition": [
                            "size_t next = (rnd >> (8 * round)) & (slice_count - 1)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "mi_block_t * const",
                        "definition": [
                            "mi_block_t * const block = blocks[current]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper_mi_page_queue_find_free_ex_1",
            "header": "",
            "params": [
                "size_t * const count_ref",
                "size_t * const candidate_count_ref",
                "unsigned int * const page_candidate_idx_ref",
                "unsigned int * const page_idx_ref",
                "mi_page_queue_t * const pq",
                "mi_page_t * const page_candidate",
                "mi_page_t * const page"
            ],
            "definition": "void helper_mi_page_queue_find_free_ex_1(size_t * const count_ref, size_t * const candidate_count_ref, unsigned int * const page_candidate_idx_ref, unsigned int * const page_idx_ref, mi_page_queue_t * const pq, mi_page_t * const page_candidate, mi_page_t * const page)\n{\n  size_t count = *count_ref;\n  size_t candidate_count = *candidate_count_ref;\n  unsigned int page_candidate_idx = *page_candidate_idx_ref;\n  unsigned int page_idx = *page_idx_ref;\n  mi_page_t *next = page->next;\n  count += 1;\n  candidate_count += 1;\n  _mi_page_free_collect(page, 0);\n  const bool immediate_available = mi_page_immediate_available(page);\n  if ((!immediate_available) && (!mi_page_is_expandable(page)))\n  {\n    ((!mi_page_is_in_full(page)) && (!mi_page_immediate_available(page))) ? ((void) 0) : (_mi_assert_fail(\"!mi_page_is_in_full(page) && !mi_page_immediate_available(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 783, __func__));\n    mi_page_to_full(page, pq);\n  }\n  else\n  {\n    if ((&page_candidate[page_candidate_idx]) == 0)\n    {\n      page_candidate_idx = &page[page_idx];\n      candidate_count = 0;\n    }\n    else\n      if (((page->used >= page_candidate->used) && (!mi_page_is_mostly_used(page))) && (!mi_page_is_expandable(page)))\n    {\n      page_candidate_idx = &page[page_idx];\n    }\n    if (immediate_available || (candidate_count > 4))\n    {\n      ((&page_candidate[page_candidate_idx]) != 0) ? ((void) 0) : (_mi_assert_fail(\"page_candidate!=NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/page.c\", 799, __func__));\n      break;\n    }\n  }\n  page_idx = next;\n  *count_ref = count;\n  *candidate_count_ref = candidate_count;\n  *page_candidate_idx_ref = page_candidate_idx;\n  *page_idx_ref = page_idx;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_page_free_collect",
                "mi_page_immediate_available",
                "mi_page_is_expandable",
                "mi_page_is_in_full",
                "mi_page_is_mostly_used",
                "mi_page_to_full"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "count_ref",
                        "type": "size_t * const",
                        "definition": [
                            "size_t * const count_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "candidate_count_ref",
                        "type": "size_t * const",
                        "definition": [
                            "size_t * const candidate_count_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_candidate_idx_ref",
                        "type": "unsigned int * const",
                        "definition": [
                            "unsigned int * const page_candidate_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_idx_ref",
                        "type": "unsigned int * const",
                        "definition": [
                            "unsigned int * const page_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pq",
                        "type": "mi_page_queue_t * const",
                        "definition": [
                            "mi_page_queue_t * const pq"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_candidate",
                        "type": "mi_page_t * const",
                        "definition": [
                            "mi_page_t * const page_candidate"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t * const",
                        "definition": [
                            "mi_page_t * const page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count = *count_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "candidate_count",
                        "type": "size_t",
                        "definition": [
                            "size_t candidate_count = *candidate_count_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_candidate_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int page_candidate_idx = *page_candidate_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int page_idx = *page_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *next = page->next"
                        ]
                    },
                    {
                        "path": null,
                        "name": "immediate_available",
                        "type": "const bool",
                        "definition": [
                            "const bool immediate_available = mi_page_immediate_available(page)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_random_init",
            "header": "void _mi_random_init(mi_random_ctx_t *ctx)",
            "params": [
                "mi_random_ctx_t *ctx"
            ],
            "definition": "void _mi_random_init(mi_random_ctx_t *ctx)\n{\n  mi_random_init_ex(ctx, 0);\n}\n\n",
            "calle": [
                "mi_random_init_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "ctx",
                        "type": "mi_random_ctx_t *",
                        "definition": [
                            "mi_random_ctx_t *ctx"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_random_init_weak",
            "header": "void _mi_random_init_weak(mi_random_ctx_t *ctx)",
            "params": [
                "mi_random_ctx_t *ctx"
            ],
            "definition": "void _mi_random_init_weak(mi_random_ctx_t *ctx)\n{\n  mi_random_init_ex(ctx, 1);\n}\n\n",
            "calle": [
                "mi_random_init_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "ctx",
                        "type": "mi_random_ctx_t *",
                        "definition": [
                            "mi_random_ctx_t *ctx"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_random_reinit_if_weak",
            "header": "void _mi_random_reinit_if_weak(mi_random_ctx_t *ctx)",
            "params": [
                "mi_random_ctx_t *ctx"
            ],
            "definition": "void _mi_random_reinit_if_weak(mi_random_ctx_t *ctx)\n{\n  if (ctx->weak)\n  {\n    _mi_random_init(ctx);\n  }\n}\n\n",
            "calle": [
                "_mi_random_init"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "ctx",
                        "type": "mi_random_ctx_t *",
                        "definition": [
                            "mi_random_ctx_t *ctx"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_random_split",
            "header": "void _mi_random_split(mi_random_ctx_t *ctx, mi_random_ctx_t *new_ctx)",
            "params": [
                "mi_random_ctx_t *ctx",
                "mi_random_ctx_t *ctx_new"
            ],
            "definition": "void _mi_random_split(mi_random_ctx_t *ctx, mi_random_ctx_t *ctx_new)\n{\n  (mi_random_is_initialized(ctx)) ? ((void) 0) : (_mi_assert_fail(\"mi_random_is_initialized(ctx)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/random.c\", 139, __func__));\n  (ctx != ctx_new) ? ((void) 0) : (_mi_assert_fail(\"ctx != ctx_new\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/random.c\", 140, __func__));\n  chacha_split(ctx, (uintptr_t) ctx_new, ctx_new);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "chacha_split",
                "mi_random_is_initialized"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "ctx",
                        "type": "mi_random_ctx_t *",
                        "definition": [
                            "mi_random_ctx_t *ctx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ctx_new",
                        "type": "mi_random_ctx_t *",
                        "definition": [
                            "mi_random_ctx_t *ctx_new"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_random_next",
            "header": "uintptr_t _mi_random_next(mi_random_ctx_t *ctx)",
            "params": [
                "mi_random_ctx_t *ctx"
            ],
            "definition": "uintptr_t _mi_random_next(mi_random_ctx_t *ctx)\n{\n  (mi_random_is_initialized(ctx)) ? ((void) 0) : (_mi_assert_fail(\"mi_random_is_initialized(ctx)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/random.c\", 145, __func__));\n  uintptr_t r;\n  do\n  {\n    r = (((uintptr_t) chacha_next32(ctx)) << 32) | chacha_next32(ctx);\n  }\n  while (r == 0);\n  return r;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "chacha_next32",
                "mi_random_is_initialized"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "ctx",
                        "type": "mi_random_ctx_t *",
                        "definition": [
                            "mi_random_ctx_t *ctx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "r",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t r"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_os_random_weak",
            "header": "uintptr_t _mi_os_random_weak(uintptr_t extra_seed)",
            "params": [
                "uintptr_t extra_seed"
            ],
            "definition": "uintptr_t _mi_os_random_weak(uintptr_t extra_seed)\n{\n  uintptr_t x = ((uintptr_t) (&_mi_os_random_weak)) ^ extra_seed;\n  x ^= _mi_prim_clock_now();\n  uintptr_t max = ((x ^ (x >> 17)) & 0x0F) + 1;\n  for (uintptr_t i = 0; (i < max) || (x == 0); i += 1, x += 1)\n  {\n    x = _mi_random_shuffle(x);\n  }\n\n  (x != 0) ? ((void) 0) : (_mi_assert_fail(\"x != 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/random.c\", 173, __func__));\n  return x;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_os_random_weak",
                "_mi_prim_clock_now",
                "_mi_random_shuffle"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "extra_seed",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t extra_seed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "x",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t x = ((uintptr_t) (&_mi_os_random_weak)) ^ extra_seed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t max = ((x ^ (x >> 17)) & 0x0F) + 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t i = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "rotl",
            "header": "",
            "params": [
                "uint32_t x",
                "uint32_t shift"
            ],
            "definition": "inline static uint32_t rotl(uint32_t x, uint32_t shift)\n{\n  return (x << shift) | (x >> (32 - shift));\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "x",
                        "type": "uint32_t",
                        "definition": [
                            "uint32_t x"
                        ]
                    },
                    {
                        "path": null,
                        "name": "shift",
                        "type": "uint32_t",
                        "definition": [
                            "uint32_t shift"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "qround",
            "header": "",
            "params": [
                "uint32_t x[16]",
                "size_t a",
                "size_t b",
                "size_t c",
                "size_t d"
            ],
            "definition": "inline static void qround(uint32_t x[16], size_t a, size_t b, size_t c, size_t d)\n{\n  x[a] += x[b];\n  x[d] = rotl(x[d] ^ x[a], 16);\n  x[c] += x[d];\n  x[b] = rotl(x[b] ^ x[c], 12);\n  x[a] += x[b];\n  x[d] = rotl(x[d] ^ x[a], 8);\n  x[c] += x[d];\n  x[b] = rotl(x[b] ^ x[c], 7);\n}\n\n",
            "calle": [
                "rotl"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "x",
                        "type": "uint32_t [16]",
                        "definition": [
                            "uint32_t x[16]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "a",
                        "type": "size_t",
                        "definition": [
                            "size_t a"
                        ]
                    },
                    {
                        "path": null,
                        "name": "b",
                        "type": "size_t",
                        "definition": [
                            "size_t b"
                        ]
                    },
                    {
                        "path": null,
                        "name": "c",
                        "type": "size_t",
                        "definition": [
                            "size_t c"
                        ]
                    },
                    {
                        "path": null,
                        "name": "d",
                        "type": "size_t",
                        "definition": [
                            "size_t d"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "chacha_block",
            "header": "",
            "params": [
                "mi_random_ctx_t *ctx"
            ],
            "definition": "static void chacha_block(mi_random_ctx_t *ctx)\n{\n  uint32_t x[16];\n  for (size_t i = 0; i < 16; i += 1)\n  {\n    x[i] = ctx->input[i];\n  }\n\n  for (size_t i = 0; i < 20; i += 2)\n  {\n    qround(x, 0, 4, 8, 12);\n    qround(x, 1, 5, 9, 13);\n    qround(x, 2, 6, 10, 14);\n    qround(x, 3, 7, 11, 15);\n    qround(x, 0, 5, 10, 15);\n    qround(x, 1, 6, 11, 12);\n    qround(x, 2, 7, 8, 13);\n    qround(x, 3, 4, 9, 14);\n  }\n\n  for (size_t i = 0; i < 16; i += 1)\n  {\n    ctx->output[i] = x[i] + ctx->input[i];\n  }\n\n  ctx->output_available = 16;\n  ctx->input[12] += 1;\n  if (ctx->input[12] == 0)\n  {\n    ctx->input[13] += 1;\n    if (ctx->input[13] == 0)\n    {\n      ctx->input[14] += 1;\n    }\n  }\n}\n\n",
            "calle": [
                "qround"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "ctx",
                        "type": "mi_random_ctx_t *",
                        "definition": [
                            "mi_random_ctx_t *ctx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "x",
                        "type": "uint32_t [16]",
                        "definition": [
                            "uint32_t x[16]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "chacha_next32",
            "header": "",
            "params": [
                "mi_random_ctx_t *ctx"
            ],
            "definition": "static uint32_t chacha_next32(mi_random_ctx_t *ctx)\n{\n  if (ctx->output_available <= 0)\n  {\n    chacha_block(ctx);\n    ctx->output_available = 16;\n  }\n  const uint32_t x = ctx->output[16 - ctx->output_available];\n  ctx->output[16 - ctx->output_available] = 0;\n  ctx->output_available -= 1;\n  return x;\n}\n\n",
            "calle": [
                "chacha_block"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "ctx",
                        "type": "mi_random_ctx_t *",
                        "definition": [
                            "mi_random_ctx_t *ctx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "x",
                        "type": "const uint32_t",
                        "definition": [
                            "const uint32_t x = ctx->output[16 - ctx->output_available]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "read32",
            "header": "",
            "params": [
                "const uint8_t *p",
                "size_t idx32"
            ],
            "definition": "inline static uint32_t read32(const uint8_t *p, size_t idx32)\n{\n  const size_t i = 4 * idx32;\n  return ((((uint32_t) p[i + 0]) | (((uint32_t) p[i + 1]) << 8)) | (((uint32_t) p[i + 2]) << 16)) | (((uint32_t) p[i + 3]) << 24);\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "const uint8_t *",
                        "definition": [
                            "const uint8_t *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx32",
                        "type": "size_t",
                        "definition": [
                            "size_t idx32"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "const size_t",
                        "definition": [
                            "const size_t i = 4 * idx32"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "chacha_init",
            "header": "",
            "params": [
                "mi_random_ctx_t *ctx",
                "const uint8_t key[32]",
                "uint64_t nonce"
            ],
            "definition": "static void chacha_init(mi_random_ctx_t *ctx, const uint8_t key[32], uint64_t nonce)\n{\n  memset(ctx, 0, sizeof(*ctx));\n  for (size_t i = 0; i < 4; i += 1)\n  {\n    const uint8_t *sigma = (uint8_t *) \"expand 32-byte k\";\n    ctx->input[i] = read32(sigma, i);\n  }\n\n  for (size_t i = 0; i < 8; i += 1)\n  {\n    ctx->input[i + 4] = read32(key, i);\n  }\n\n  ctx->input[12] = 0;\n  ctx->input[13] = 0;\n  ctx->input[14] = (uint32_t) nonce;\n  ctx->input[15] = (uint32_t) (nonce >> 32);\n}\n\n",
            "calle": [
                "memset",
                "read32"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "ctx",
                        "type": "mi_random_ctx_t *",
                        "definition": [
                            "mi_random_ctx_t *ctx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "key",
                        "type": "const uint8_t [32]",
                        "definition": [
                            "const uint8_t key[32]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "nonce",
                        "type": "uint64_t",
                        "definition": [
                            "uint64_t nonce"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "sigma",
                        "type": "const uint8_t *",
                        "definition": [
                            "const uint8_t *sigma = (uint8_t *) \"expand 32-byte k\""
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "chacha_split",
            "header": "",
            "params": [
                "mi_random_ctx_t *ctx",
                "uint64_t nonce",
                "mi_random_ctx_t *ctx_new"
            ],
            "definition": "static void chacha_split(mi_random_ctx_t *ctx, uint64_t nonce, mi_random_ctx_t *ctx_new)\n{\n  memset(ctx_new, 0, sizeof(*ctx_new));\n  _mi_memcpy(ctx_new->input, ctx->input, sizeof(ctx_new->input));\n  ctx_new->input[12] = 0;\n  ctx_new->input[13] = 0;\n  ctx_new->input[14] = (uint32_t) nonce;\n  ctx_new->input[15] = (uint32_t) (nonce >> 32);\n  ((ctx->input[14] != ctx_new->input[14]) || (ctx->input[15] != ctx_new->input[15])) ? ((void) 0) : (_mi_assert_fail(\"ctx->input[14] != ctx_new->input[14] || ctx->input[15] != ctx_new->input[15]\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/random.c\", 123, __func__));\n  chacha_block(ctx_new);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_memcpy",
                "chacha_block",
                "memset"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "ctx",
                        "type": "mi_random_ctx_t *",
                        "definition": [
                            "mi_random_ctx_t *ctx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "nonce",
                        "type": "uint64_t",
                        "definition": [
                            "uint64_t nonce"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ctx_new",
                        "type": "mi_random_ctx_t *",
                        "definition": [
                            "mi_random_ctx_t *ctx_new"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_random_is_initialized",
            "header": "",
            "params": [
                "mi_random_ctx_t *ctx"
            ],
            "definition": "static bool mi_random_is_initialized(mi_random_ctx_t *ctx)\n{\n  return (ctx != 0) && (ctx->input[0] != 0);\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "ctx",
                        "type": "mi_random_ctx_t *",
                        "definition": [
                            "mi_random_ctx_t *ctx"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_random_init_ex",
            "header": "",
            "params": [
                "mi_random_ctx_t *ctx",
                "bool use_weak"
            ],
            "definition": "static void mi_random_init_ex(mi_random_ctx_t *ctx, bool use_weak)\n{\n  uint8_t key[32];\n  if (use_weak || (!_mi_prim_random_buf(key, sizeof(key))))\n  {\n    if (!use_weak)\n    {\n      _mi_warning_message(\"unable to use secure randomness\\n\");\n    }\n    uintptr_t x = _mi_os_random_weak(0);\n    for (size_t i = 0; i < 8; i += 1, x += 1)\n    {\n      x = _mi_random_shuffle(x);\n      ((uint32_t *) key)[i] = (uint32_t) x;\n    }\n\n    ctx->weak = 1;\n  }\n  else\n  {\n    ctx->weak = 0;\n  }\n  chacha_init(ctx, key, (uintptr_t) ctx);\n}\n\n",
            "calle": [
                "_mi_os_random_weak",
                "_mi_prim_random_buf",
                "_mi_random_shuffle",
                "_mi_warning_message",
                "chacha_init"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "ctx",
                        "type": "mi_random_ctx_t *",
                        "definition": [
                            "mi_random_ctx_t *ctx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "use_weak",
                        "type": "bool",
                        "definition": [
                            "bool use_weak"
                        ]
                    },
                    {
                        "path": null,
                        "name": "key",
                        "type": "uint8_t [32]",
                        "definition": [
                            "uint8_t key[32]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "x",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t x = _mi_os_random_weak(0)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_collect_reduce",
            "header": "void mi_collect_reduce(size_t target_thread_owned)",
            "params": [
                "size_t target_size"
            ],
            "definition": "void mi_collect_reduce(size_t target_size)\n{\n  mi_collect(1);\n  mi_heap_t *heap = mi_heap_get_default();\n  mi_segments_tld_t *tld = &heap->tld->segments;\n  size_t target = target_size / (1UL << (9 + (13 + 3)));\n  if (target == 0)\n  {\n    target = (size_t) mi_option_get_clamp(mi_option_target_segments_per_thread, 1, 1024);\n  }\n  mi_segments_try_abandon_to_target(heap, target, tld);\n}\n\n",
            "calle": [
                "mi_collect",
                "mi_heap_get_default",
                "mi_option_get_clamp",
                "mi_segments_try_abandon_to_target"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "target_size",
                        "type": "size_t",
                        "definition": [
                            "size_t target_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap = mi_heap_get_default()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld = &heap->tld->segments"
                        ]
                    },
                    {
                        "path": null,
                        "name": "target",
                        "type": "size_t",
                        "definition": [
                            "size_t target = target_size / (1UL << (9 + (13 + 3)))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_segment_page_alloc",
            "header": "mi_page_t *_mi_segment_page_alloc(mi_heap_t *heap, size_t block_size, size_t page_alignment, mi_segments_tld_t *tld)",
            "params": [
                "mi_heap_t *heap",
                "size_t block_size",
                "size_t page_alignment",
                "mi_segments_tld_t *tld"
            ],
            "definition": "mi_page_t *_mi_segment_page_alloc(mi_heap_t *heap, size_t block_size, size_t page_alignment, mi_segments_tld_t *tld)\n{\n  mi_page_t *page;\n  unsigned int page_idx = 0;\n  if (__builtin_expect(!(!(page_alignment > ((1UL << (9 + (13 + 3))) >> 1))), 0))\n  {\n    (_mi_is_power_of_two(page_alignment)) ? ((void) 0) : (_mi_assert_fail(\"_mi_is_power_of_two(page_alignment)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1649, __func__));\n    (page_alignment >= (1UL << (9 + (13 + 3)))) ? ((void) 0) : (_mi_assert_fail(\"page_alignment >= MI_SEGMENT_SIZE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1650, __func__));\n    if (page_alignment < (1UL << (9 + (13 + 3))))\n    {\n      page_alignment = 1UL << (9 + (13 + 3));\n    }\n    page_idx = mi_segment_huge_page_alloc(block_size, page_alignment, heap->arena_id, tld);\n  }\n  else\n    if (block_size <= ((1UL << (13 + 3)) / 8))\n  {\n    page_idx = mi_segments_page_alloc(heap, MI_PAGE_SMALL, block_size, block_size, tld);\n  }\n  else\n    if (block_size <= ((1UL << (3 + (13 + 3))) / 8))\n  {\n    page_idx = mi_segments_page_alloc(heap, MI_PAGE_MEDIUM, 1UL << (3 + (13 + 3)), block_size, tld);\n  }\n  else\n    if (block_size <= ((1UL << (9 + (13 + 3))) / 2))\n  {\n    page_idx = mi_segments_page_alloc(heap, MI_PAGE_LARGE, block_size, block_size, tld);\n  }\n  else\n  {\n    page_idx = mi_segment_huge_page_alloc(block_size, page_alignment, heap->arena_id, tld);\n  }\n  (((&page[page_idx]) == 0) || _mi_heap_memid_is_suitable(heap, _mi_page_segment(page)->memid)) ? ((void) 0) : (_mi_assert_fail(\"page == NULL || _mi_heap_memid_is_suitable(heap, _mi_page_segment(page)->memid)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1666, __func__));\n  ;\n  (((&page[page_idx]) == 0) || (_mi_page_segment(page)->subproc == tld->subproc)) ? ((void) 0) : (_mi_assert_fail(\"page == NULL || _mi_page_segment(page)->subproc == tld->subproc\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1668, __func__));\n  return page;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_heap_memid_is_suitable",
                "_mi_is_power_of_two",
                "_mi_page_segment",
                "mi_segment_huge_page_alloc",
                "mi_segments_page_alloc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_size",
                        "type": "size_t",
                        "definition": [
                            "size_t block_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t page_alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int page_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_segment_page_free",
            "header": "void _mi_segment_page_free(mi_page_t *page, bool force, mi_segments_tld_t *tld)",
            "params": [
                "mi_page_t *page",
                "bool force",
                "mi_segments_tld_t *tld"
            ],
            "definition": "void _mi_segment_page_free(mi_page_t *page, bool force, mi_segments_tld_t *tld)\n{\n  (page != 0) ? ((void) 0) : (_mi_assert_fail(\"page != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1053, __func__));\n  mi_segment_t *segment = _mi_page_segment(page);\n  ;\n  mi_segment_page_clear(page, tld);\n  ;\n  if (segment->used == 0)\n  {\n    mi_segment_free(segment, force, tld);\n  }\n  else\n    if (segment->used == segment->abandoned)\n  {\n    mi_segment_abandon(segment, tld);\n  }\n  else\n  {\n    mi_segment_try_purge(segment, 0);\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_page_segment",
                "mi_segment_abandon",
                "mi_segment_free",
                "mi_segment_page_clear",
                "mi_segment_try_purge"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "force",
                        "type": "bool",
                        "definition": [
                            "bool force"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = _mi_page_segment(page)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_segment_page_abandon",
            "header": "void _mi_segment_page_abandon(mi_page_t *page, mi_segments_tld_t *tld)",
            "params": [
                "mi_page_t *page",
                "mi_segments_tld_t *tld"
            ],
            "definition": "void _mi_segment_page_abandon(mi_page_t *page, mi_segments_tld_t *tld)\n{\n  (page != 0) ? ((void) 0) : (_mi_assert_fail(\"page != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1136, __func__));\n  (mi_page_thread_free_flag(page) == MI_NEVER_DELAYED_FREE) ? ((void) 0) : (_mi_assert_fail(\"mi_page_thread_free_flag(page)==MI_NEVER_DELAYED_FREE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1137, __func__));\n  (mi_page_heap(page) == 0) ? ((void) 0) : (_mi_assert_fail(\"mi_page_heap(page) == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1138, __func__));\n  mi_segment_t *segment = _mi_page_segment(page);\n  ;\n  segment->abandoned += 1;\n  _mi_stat_increase(&tld->stats->pages_abandoned, 1);\n  (segment->abandoned <= segment->used) ? ((void) 0) : (_mi_assert_fail(\"segment->abandoned <= segment->used\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1145, __func__));\n  if (segment->used == segment->abandoned)\n  {\n    mi_segment_abandon(segment, tld);\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_page_segment",
                "_mi_stat_increase",
                "mi_page_heap",
                "mi_page_thread_free_flag",
                "mi_segment_abandon"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = _mi_page_segment(page)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_segment_collect",
            "header": "void _mi_segment_collect(mi_segment_t *segment, bool force)",
            "params": [
                "mi_segment_t *segment",
                "bool force"
            ],
            "definition": "void _mi_segment_collect(mi_segment_t *segment, bool force)\n{\n  mi_segment_try_purge(segment, force);\n}\n\n",
            "calle": [
                "mi_segment_try_purge"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "force",
                        "type": "bool",
                        "definition": [
                            "bool force"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_segment_huge_page_reset",
            "header": "void _mi_segment_huge_page_reset(mi_segment_t *segment, mi_page_t *page, mi_block_t *block)",
            "params": [
                "mi_segment_t *segment",
                "mi_page_t *page",
                "mi_block_t *block"
            ],
            "definition": "void _mi_segment_huge_page_reset(mi_segment_t *segment, mi_page_t *page, mi_block_t *block)\n{\n  (void) page;\n  (segment->kind == MI_SEGMENT_HUGE) ? ((void) 0) : (_mi_assert_fail(\"segment->kind == MI_SEGMENT_HUGE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1628, __func__));\n  (segment == _mi_page_segment(page)) ? ((void) 0) : (_mi_assert_fail(\"segment == _mi_page_segment(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1629, __func__));\n  (page->used == 1) ? ((void) 0) : (_mi_assert_fail(\"page->used == 1\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1630, __func__));\n  (page->free == 0) ? ((void) 0) : (_mi_assert_fail(\"page->free == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1631, __func__));\n  if (segment->allow_decommit)\n  {\n    size_t csize = mi_usable_size(block);\n    if (csize > (sizeof(mi_block_t)))\n    {\n      csize = csize - (sizeof(mi_block_t));\n      uint8_t *p = ((uint8_t *) block) + (sizeof(mi_block_t));\n      _mi_os_reset(p, csize);\n    }\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_os_reset",
                "_mi_page_segment",
                "mi_usable_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block",
                        "type": "mi_block_t *",
                        "definition": [
                            "mi_block_t *block"
                        ]
                    },
                    {
                        "path": null,
                        "name": "csize",
                        "type": "size_t",
                        "definition": [
                            "size_t csize = mi_usable_size(block)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *p = ((uint8_t *) block) + (sizeof(mi_block_t))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_segment_page_start",
            "header": "uint8_t *_mi_segment_page_start(const mi_segment_t *segment, const mi_page_t *page, size_t *page_size)",
            "params": [
                "const mi_segment_t *segment",
                "const mi_page_t *page",
                "size_t *page_size"
            ],
            "definition": "uint8_t *_mi_segment_page_start(const mi_segment_t *segment, const mi_page_t *page, size_t *page_size)\n{\n  const mi_slice_t *slice = mi_page_to_slice((mi_page_t *) page);\n  uint8_t *p = _mi_segment_page_start_from_slice(segment, slice, mi_page_block_size(page), page_size);\n  ((mi_page_block_size(page) > 0) || (_mi_ptr_page(p) == page)) ? ((void) 0) : (_mi_assert_fail(\"mi_page_block_size(page) > 0 || _mi_ptr_page(p) == page\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 364, __func__));\n  (_mi_ptr_segment(p) == segment) ? ((void) 0) : (_mi_assert_fail(\"_mi_ptr_segment(p) == segment\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 365, __func__));\n  return p;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_ptr_page",
                "_mi_ptr_segment",
                "_mi_segment_page_start_from_slice",
                "mi_page_block_size",
                "mi_page_to_slice"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "const mi_segment_t *",
                        "definition": [
                            "const mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "const mi_page_t *",
                        "definition": [
                            "const mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_size",
                        "type": "size_t *",
                        "definition": [
                            "size_t *page_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice",
                        "type": "const mi_slice_t *",
                        "definition": [
                            "const mi_slice_t *slice = mi_page_to_slice((mi_page_t *) page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *p = _mi_segment_page_start_from_slice(segment, slice, mi_page_block_size(page), page_size)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_abandoned_reclaim_all",
            "header": "void _mi_abandoned_reclaim_all(mi_heap_t *heap, mi_segments_tld_t *tld)",
            "params": [
                "mi_heap_t *heap",
                "mi_segments_tld_t *tld"
            ],
            "definition": "void _mi_abandoned_reclaim_all(mi_heap_t *heap, mi_segments_tld_t *tld)\n{\n  mi_segment_t *segment;\n  unsigned int segment_idx = 0;\n  mi_arena_field_cursor_t current;\n  _mi_arena_field_cursor_init(heap, tld->subproc, 1, &current);\n  while ((segment_idx = _mi_arena_segment_clear_abandoned_next(&current)) != 0)\n  {\n    mi_segment_reclaim(segment, heap, 0, 0, tld);\n  }\n\n  _mi_arena_field_cursor_done(&current);\n}\n\n",
            "calle": [
                "_mi_arena_field_cursor_done",
                "_mi_arena_field_cursor_init",
                "_mi_arena_segment_clear_abandoned_next",
                "mi_segment_reclaim"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int segment_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current",
                        "type": "mi_arena_field_cursor_t",
                        "definition": [
                            "mi_arena_field_cursor_t current"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_abandoned_collect",
            "header": "void _mi_abandoned_collect(mi_heap_t *heap, bool force, mi_segments_tld_t *tld)",
            "params": [
                "mi_heap_t *heap",
                "bool force",
                "mi_segments_tld_t *tld"
            ],
            "definition": "void _mi_abandoned_collect(mi_heap_t *heap, bool force, mi_segments_tld_t *tld)\n{\n  mi_segment_t *segment;\n  unsigned int segment_idx = 0;\n  mi_arena_field_cursor_t current;\n  _mi_arena_field_cursor_init(heap, tld->subproc, force, &current);\n  long max_tries = (force) ? ((long) atomic_load_explicit(&tld->subproc->abandoned_count, memory_order_relaxed)) : (1024);\n  while (((max_tries--) > 0) && ((segment_idx = _mi_arena_segment_clear_abandoned_next(&current)) != 0))\n  {\n    mi_segment_check_free(segment, 0, 0, tld);\n    if (segment->used == 0)\n    {\n      mi_segment_reclaim(segment, heap, 0, 0, tld);\n    }\n    else\n    {\n      mi_segment_try_purge(segment, force);\n      _mi_arena_segment_mark_abandoned(segment);\n    }\n  }\n\n  _mi_arena_field_cursor_done(&current);\n}\n\n",
            "calle": [
                "_mi_arena_field_cursor_done",
                "_mi_arena_field_cursor_init",
                "_mi_arena_segment_clear_abandoned_next",
                "_mi_arena_segment_mark_abandoned",
                "atomic_load_explicit",
                "mi_segment_check_free",
                "mi_segment_reclaim",
                "mi_segment_try_purge"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "force",
                        "type": "bool",
                        "definition": [
                            "bool force"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int segment_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current",
                        "type": "mi_arena_field_cursor_t",
                        "definition": [
                            "mi_arena_field_cursor_t current"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max_tries",
                        "type": "long",
                        "definition": [
                            "long max_tries = (force) ? ((long) atomic_load_explicit(&tld->subproc->abandoned_count, memory_order_relaxed)) : (1024)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_segment_attempt_reclaim",
            "header": "bool _mi_segment_attempt_reclaim(mi_heap_t *heap, mi_segment_t *segment)",
            "params": [
                "mi_heap_t *heap",
                "mi_segment_t *segment"
            ],
            "definition": "bool _mi_segment_attempt_reclaim(mi_heap_t *heap, mi_segment_t *segment)\n{\n  if (atomic_load_explicit(&segment->thread_id, memory_order_relaxed) != 0)\n  {\n    return 0;\n  }\n  if (segment->subproc != heap->tld->segments.subproc)\n  {\n    return 0;\n  }\n  if (!_mi_heap_memid_is_suitable(heap, segment->memid))\n  {\n    return 0;\n  }\n  const long target = _mi_option_get_fast(mi_option_target_segments_per_thread);\n  if ((target > 0) && (((size_t) target) <= heap->tld->segments.count))\n  {\n    return 0;\n  }\n  if ((segment->memid.memkind == MI_MEM_ARENA) && ((heap->tld->segments.reclaim_count * 2) > heap->tld->segments.count))\n  {\n    return 0;\n  }\n  if (_mi_arena_segment_clear_abandoned(segment))\n  {\n    mi_segment_t *res = mi_segment_reclaim(segment, heap, 0, 0, &heap->tld->segments);\n    (res == segment) ? ((void) 0) : (_mi_assert_fail(\"res == segment\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1296, __func__));\n    return res != 0;\n  }\n  return 0;\n}\n\n",
            "calle": [
                "_mi_arena_segment_clear_abandoned",
                "_mi_assert_fail",
                "_mi_heap_memid_is_suitable",
                "_mi_option_get_fast",
                "atomic_load_explicit",
                "mi_segment_reclaim"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "target",
                        "type": "const long",
                        "definition": [
                            "const long target = _mi_option_get_fast(mi_option_target_segments_per_thread)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "res",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *res = mi_segment_reclaim(segment, heap, 0, 0, &heap->tld->segments)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_segment_visit_blocks",
            "header": "bool _mi_segment_visit_blocks(mi_segment_t *segment, int heap_tag, bool visit_blocks, mi_block_visit_fun *visitor, void *arg)",
            "params": [
                "mi_segment_t *segment",
                "int heap_tag",
                "bool visit_blocks",
                "mi_block_visit_fun *visitor",
                "void *arg"
            ],
            "definition": "bool _mi_segment_visit_blocks(mi_segment_t *segment, int heap_tag, bool visit_blocks, mi_block_visit_fun *visitor, void *arg)\n{\n  const mi_slice_t *end;\n  mi_slice_t *slice = mi_slices_start_iterate(segment, &end);\n  unsigned int slice_idx = 0;\n  while ((&slice[slice_idx]) < end)\n  {\n    if (mi_slice_is_used(slice))\n    {\n      mi_page_t * const page = mi_slice_to_page(slice);\n      if ((heap_tag < 0) || (((int) page->heap_tag) == heap_tag))\n      {\n        if (!mi_segment_visit_page(page, visit_blocks, visitor, arg))\n        {\n          return 0;\n        }\n      }\n    }\n    slice_idx = slice_idx + slice_idx->slice_count;\n  }\n\n  return 1;\n}\n\n",
            "calle": [
                "mi_segment_visit_page",
                "mi_slice_is_used",
                "mi_slice_to_page",
                "mi_slices_start_iterate"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap_tag",
                        "type": "int",
                        "definition": [
                            "int heap_tag"
                        ]
                    },
                    {
                        "path": null,
                        "name": "visit_blocks",
                        "type": "bool",
                        "definition": [
                            "bool visit_blocks"
                        ]
                    },
                    {
                        "path": null,
                        "name": "visitor",
                        "type": "mi_block_visit_fun *",
                        "definition": [
                            "mi_block_visit_fun *visitor"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "const mi_slice_t *",
                        "definition": [
                            "const mi_slice_t *end"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *slice = mi_slices_start_iterate(segment, &end)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int slice_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t * const",
                        "definition": [
                            "mi_page_t * const page = mi_slice_to_page(slice)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_commit_mask_committed_size",
            "header": "size_t _mi_commit_mask_committed_size(const mi_commit_mask_t *cm, size_t total)",
            "params": [
                "const mi_commit_mask_t *cm",
                "size_t total"
            ],
            "definition": "size_t _mi_commit_mask_committed_size(const mi_commit_mask_t *cm, size_t total)\n{\n  ((total % ((1UL << (9 + (13 + 3))) / (1UL << (13 + 3)))) == 0) ? ((void) 0) : (_mi_assert_fail(\"(total%MI_COMMIT_MASK_BITS)==0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 87, __func__));\n  size_t count = 0;\n  for (size_t i = 0; i < (((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) / ((1 << 3) * 8)); i += 1)\n  {\n    size_t mask = cm->mask[i];\n    if ((~mask) == 0)\n    {\n      count += (1 << 3) * 8;\n    }\n    else\n    {\n      for (; mask != 0; mask >>= 1)\n      {\n        if ((mask & 1) != 0)\n        {\n          count += 1;\n        }\n      }\n\n    }\n  }\n\n  return (total / ((1UL << (9 + (13 + 3))) / (1UL << (13 + 3)))) * count;\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "cm",
                        "type": "const mi_commit_mask_t *",
                        "definition": [
                            "const mi_commit_mask_t *cm"
                        ]
                    },
                    {
                        "path": null,
                        "name": "total",
                        "type": "size_t",
                        "definition": [
                            "size_t total"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "size_t",
                        "definition": [
                            "size_t mask = cm->mask[i]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_commit_mask_next_run",
            "header": "size_t _mi_commit_mask_next_run(const mi_commit_mask_t *cm, size_t *idx)",
            "params": [
                "const mi_commit_mask_t *cm",
                "size_t *idx"
            ],
            "definition": "size_t _mi_commit_mask_next_run(const mi_commit_mask_t *cm, size_t *idx)\n{\n  size_t i = (*idx) / ((1 << 3) * 8);\n  size_t ofs = (*idx) % ((1 << 3) * 8);\n  size_t mask = 0;\n  while (i < (((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) / ((1 << 3) * 8)))\n  {\n    mask = cm->mask[i];\n    mask >>= ofs;\n    if (mask != 0)\n    {\n      while ((mask & 1) == 0)\n      {\n        mask >>= 1;\n        ofs += 1;\n      }\n\n      break;\n    }\n    i += 1;\n    ofs = 0;\n  }\n\n  if (i >= (((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) / ((1 << 3) * 8)))\n  {\n    *idx = (1UL << (9 + (13 + 3))) / (1UL << (13 + 3));\n    return 0;\n  }\n  else\n  {\n    helper__mi_commit_mask_next_run_1(&i, &ofs, &mask, cm, idx);\n  }\n}\n\n",
            "calle": [
                "helper__mi_commit_mask_next_run_1"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "cm",
                        "type": "const mi_commit_mask_t *",
                        "definition": [
                            "const mi_commit_mask_t *cm"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t *",
                        "definition": [
                            "size_t *idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = (*idx) / ((1 << 3) * 8)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ofs",
                        "type": "size_t",
                        "definition": [
                            "size_t ofs = (*idx) % ((1 << 3) * 8)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "size_t",
                        "definition": [
                            "size_t mask = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_try_purge",
            "header": "static void mi_segment_try_purge(mi_segment_t *segment, bool force)",
            "params": [
                "mi_segment_t *segment",
                "bool force"
            ],
            "definition": "static void mi_segment_try_purge(mi_segment_t *segment, bool force)\n{\n  if (((!segment->allow_purge) || (segment->purge_expire == 0)) || mi_commit_mask_is_empty(&segment->purge_mask))\n  {\n    return;\n  }\n  mi_msecs_t now = _mi_clock_now();\n  if ((!force) && (now < segment->purge_expire))\n  {\n    return;\n  }\n  mi_commit_mask_t mask = segment->purge_mask;\n  segment->purge_expire = 0;\n  mi_commit_mask_create_empty(&segment->purge_mask);\n  size_t idx;\n  size_t count;\n  idx = 0;\n  while ((count = _mi_commit_mask_next_run(&mask, &idx)) > 0)\n  {\n    {\n      if (count > 0)\n      {\n        uint8_t *p = ((uint8_t *) segment) + (idx * (1UL << (13 + 3)));\n        size_t size = count * (1UL << (13 + 3));\n        mi_segment_purge(segment, p, size);\n      }\n    }\n    idx += count;\n  }\n\n  (mi_commit_mask_is_empty(&segment->purge_mask)) ? ((void) 0) : (_mi_assert_fail(\"mi_commit_mask_is_empty(&segment->purge_mask)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 614, __func__));\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_clock_now",
                "_mi_commit_mask_next_run",
                "mi_commit_mask_create_empty",
                "mi_commit_mask_is_empty",
                "mi_segment_purge"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "force",
                        "type": "bool",
                        "definition": [
                            "bool force"
                        ]
                    },
                    {
                        "path": null,
                        "name": "now",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t now = _mi_clock_now()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "mi_commit_mask_t",
                        "definition": [
                            "mi_commit_mask_t mask = segment->purge_mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t",
                        "definition": [
                            "size_t idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *p = ((uint8_t *) segment) + (idx * (1UL << (13 + 3)))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size = count * (1UL << (13 + 3))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_commit_mask_all_set",
            "header": "",
            "params": [
                "const mi_commit_mask_t *commit",
                "const mi_commit_mask_t *cm"
            ],
            "definition": "static bool mi_commit_mask_all_set(const mi_commit_mask_t *commit, const mi_commit_mask_t *cm)\n{\n  for (size_t i = 0; i < (((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) / ((1 << 3) * 8)); i += 1)\n  {\n    if ((commit->mask[i] & cm->mask[i]) != cm->mask[i])\n    {\n      return 0;\n    }\n  }\n\n  return 1;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "commit",
                        "type": "const mi_commit_mask_t *",
                        "definition": [
                            "const mi_commit_mask_t *commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "cm",
                        "type": "const mi_commit_mask_t *",
                        "definition": [
                            "const mi_commit_mask_t *cm"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_commit_mask_any_set",
            "header": "",
            "params": [
                "const mi_commit_mask_t *commit",
                "const mi_commit_mask_t *cm"
            ],
            "definition": "static bool mi_commit_mask_any_set(const mi_commit_mask_t *commit, const mi_commit_mask_t *cm)\n{\n  for (size_t i = 0; i < (((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) / ((1 << 3) * 8)); i += 1)\n  {\n    if ((commit->mask[i] & cm->mask[i]) != 0)\n    {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "commit",
                        "type": "const mi_commit_mask_t *",
                        "definition": [
                            "const mi_commit_mask_t *commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "cm",
                        "type": "const mi_commit_mask_t *",
                        "definition": [
                            "const mi_commit_mask_t *cm"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_commit_mask_create_intersect",
            "header": "",
            "params": [
                "const mi_commit_mask_t *commit",
                "const mi_commit_mask_t *cm",
                "mi_commit_mask_t *res"
            ],
            "definition": "static void mi_commit_mask_create_intersect(const mi_commit_mask_t *commit, const mi_commit_mask_t *cm, mi_commit_mask_t *res)\n{\n  for (size_t i = 0; i < (((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) / ((1 << 3) * 8)); i += 1)\n  {\n    res->mask[i] = commit->mask[i] & cm->mask[i];\n  }\n\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "commit",
                        "type": "const mi_commit_mask_t *",
                        "definition": [
                            "const mi_commit_mask_t *commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "cm",
                        "type": "const mi_commit_mask_t *",
                        "definition": [
                            "const mi_commit_mask_t *cm"
                        ]
                    },
                    {
                        "path": null,
                        "name": "res",
                        "type": "mi_commit_mask_t *",
                        "definition": [
                            "mi_commit_mask_t *res"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_commit_mask_clear",
            "header": "",
            "params": [
                "mi_commit_mask_t *res",
                "const mi_commit_mask_t *cm"
            ],
            "definition": "static void mi_commit_mask_clear(mi_commit_mask_t *res, const mi_commit_mask_t *cm)\n{\n  for (size_t i = 0; i < (((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) / ((1 << 3) * 8)); i += 1)\n  {\n    res->mask[i] &= ~cm->mask[i];\n  }\n\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "res",
                        "type": "mi_commit_mask_t *",
                        "definition": [
                            "mi_commit_mask_t *res"
                        ]
                    },
                    {
                        "path": null,
                        "name": "cm",
                        "type": "const mi_commit_mask_t *",
                        "definition": [
                            "const mi_commit_mask_t *cm"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_commit_mask_set",
            "header": "",
            "params": [
                "mi_commit_mask_t *res",
                "const mi_commit_mask_t *cm"
            ],
            "definition": "static void mi_commit_mask_set(mi_commit_mask_t *res, const mi_commit_mask_t *cm)\n{\n  for (size_t i = 0; i < (((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) / ((1 << 3) * 8)); i += 1)\n  {\n    res->mask[i] |= cm->mask[i];\n  }\n\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "res",
                        "type": "mi_commit_mask_t *",
                        "definition": [
                            "mi_commit_mask_t *res"
                        ]
                    },
                    {
                        "path": null,
                        "name": "cm",
                        "type": "const mi_commit_mask_t *",
                        "definition": [
                            "const mi_commit_mask_t *cm"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_commit_mask_create",
            "header": "",
            "params": [
                "size_t bitidx",
                "size_t bitcount",
                "mi_commit_mask_t *cm"
            ],
            "definition": "static void mi_commit_mask_create(size_t bitidx, size_t bitcount, mi_commit_mask_t *cm)\n{\n  (bitidx < ((1UL << (9 + (13 + 3))) / (1UL << (13 + 3)))) ? ((void) 0) : (_mi_assert_fail(\"bitidx < MI_COMMIT_MASK_BITS\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 60, __func__));\n  ((bitidx + bitcount) <= ((1UL << (9 + (13 + 3))) / (1UL << (13 + 3)))) ? ((void) 0) : (_mi_assert_fail(\"(bitidx + bitcount) <= MI_COMMIT_MASK_BITS\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 61, __func__));\n  if (bitcount == ((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))))\n  {\n    (bitidx == 0) ? ((void) 0) : (_mi_assert_fail(\"bitidx==0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 63, __func__));\n    mi_commit_mask_create_full(cm);\n  }\n  else\n    if (bitcount == 0)\n  {\n    mi_commit_mask_create_empty(cm);\n  }\n  else\n  {\n    mi_commit_mask_create_empty(cm);\n    size_t i = bitidx / ((1 << 3) * 8);\n    size_t ofs = bitidx % ((1 << 3) * 8);\n    while (bitcount > 0)\n    {\n      (i < (((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) / ((1 << 3) * 8))) ? ((void) 0) : (_mi_assert_fail(\"i < MI_COMMIT_MASK_FIELD_COUNT\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 74, __func__));\n      size_t avail = ((1 << 3) * 8) - ofs;\n      size_t count = (bitcount > avail) ? (avail) : (bitcount);\n      size_t mask = (count >= ((1 << 3) * 8)) ? (~((size_t) 0)) : (((((size_t) 1) << count) - 1) << ofs);\n      cm->mask[i] = mask;\n      bitcount -= count;\n      ofs = 0;\n      i += 1;\n    }\n\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_commit_mask_create_empty",
                "mi_commit_mask_create_full"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitidx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitcount",
                        "type": "size_t",
                        "definition": [
                            "size_t bitcount"
                        ]
                    },
                    {
                        "path": null,
                        "name": "cm",
                        "type": "mi_commit_mask_t *",
                        "definition": [
                            "mi_commit_mask_t *cm"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = bitidx / ((1 << 3) * 8)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ofs",
                        "type": "size_t",
                        "definition": [
                            "size_t ofs = bitidx % ((1 << 3) * 8)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "avail",
                        "type": "size_t",
                        "definition": [
                            "size_t avail = ((1 << 3) * 8) - ofs"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count = (bitcount > avail) ? (avail) : (bitcount)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "size_t",
                        "definition": [
                            "size_t mask = (count >= ((1 << 3) * 8)) ? (~((size_t) 0)) : (((((size_t) 1) << count) - 1) << ofs)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_slices_end",
            "header": "",
            "params": [
                "const mi_segment_t *segment"
            ],
            "definition": "static const mi_slice_t *mi_segment_slices_end(const mi_segment_t *segment)\n{\n  return &segment->slices[segment->slice_entries];\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "const mi_segment_t *",
                        "definition": [
                            "const mi_segment_t *segment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_slice_start",
            "header": "",
            "params": [
                "const mi_slice_t *slice"
            ],
            "definition": "static uint8_t *mi_slice_start(const mi_slice_t *slice)\n{\n  mi_segment_t *segment = _mi_ptr_segment(slice);\n  ((slice >= segment->slices) && (slice < mi_segment_slices_end(segment))) ? ((void) 0) : (_mi_assert_fail(\"slice >= segment->slices && slice < mi_segment_slices_end(segment)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 184, __func__));\n  return ((uint8_t *) segment) + ((slice - segment->slices) * (1UL << (13 + 3)));\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_ptr_segment",
                "mi_segment_slices_end"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "slice",
                        "type": "const mi_slice_t *",
                        "definition": [
                            "const mi_slice_t *slice"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = _mi_ptr_segment(slice)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_slice_bin8",
            "header": "",
            "params": [
                "size_t slice_count"
            ],
            "definition": "inline static size_t mi_slice_bin8(size_t slice_count)\n{\n  if (slice_count <= 1)\n  {\n    return slice_count;\n  }\n  (slice_count <= ((1UL << (9 + (13 + 3))) / (1UL << (13 + 3)))) ? ((void) 0) : (_mi_assert_fail(\"slice_count <= MI_SLICES_PER_SEGMENT\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 196, __func__));\n  slice_count -= 1;\n  size_t s = mi_bsr(slice_count);\n  if (s <= 2)\n  {\n    return slice_count + 1;\n  }\n  size_t bin = ((s << 2) | ((slice_count >> (s - 2)) & 0x03)) - 4;\n  return bin;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_bsr"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "slice_count",
                        "type": "size_t",
                        "definition": [
                            "size_t slice_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "s",
                        "type": "size_t",
                        "definition": [
                            "size_t s = mi_bsr(slice_count)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bin",
                        "type": "size_t",
                        "definition": [
                            "size_t bin = ((s << 2) | ((slice_count >> (s - 2)) & 0x03)) - 4"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_slice_bin",
            "header": "",
            "params": [
                "size_t slice_count"
            ],
            "definition": "inline static size_t mi_slice_bin(size_t slice_count)\n{\n  ((slice_count * (1UL << (13 + 3))) <= (1UL << (9 + (13 + 3)))) ? ((void) 0) : (_mi_assert_fail(\"slice_count*MI_SEGMENT_SLICE_SIZE <= MI_SEGMENT_SIZE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 205, __func__));\n  (mi_slice_bin8((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) <= 35) ? ((void) 0) : (_mi_assert_fail(\"mi_slice_bin8(MI_SLICES_PER_SEGMENT) <= MI_SEGMENT_BIN_MAX\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 206, __func__));\n  size_t bin = mi_slice_bin8(slice_count);\n  (bin <= 35) ? ((void) 0) : (_mi_assert_fail(\"bin <= MI_SEGMENT_BIN_MAX\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 208, __func__));\n  return bin;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_slice_bin8"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "slice_count",
                        "type": "size_t",
                        "definition": [
                            "size_t slice_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bin",
                        "type": "size_t",
                        "definition": [
                            "size_t bin = mi_slice_bin8(slice_count)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_slice_index",
            "header": "",
            "params": [
                "const mi_slice_t *slice"
            ],
            "definition": "inline static size_t mi_slice_index(const mi_slice_t *slice)\n{\n  mi_segment_t *segment = _mi_ptr_segment(slice);\n  ptrdiff_t index = slice - segment->slices;\n  ((index >= 0) && (index < ((ptrdiff_t) segment->slice_entries))) ? ((void) 0) : (_mi_assert_fail(\"index >= 0 && index < (ptrdiff_t)segment->slice_entries\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 215, __func__));\n  return index;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_ptr_segment"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "slice",
                        "type": "const mi_slice_t *",
                        "definition": [
                            "const mi_slice_t *slice"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = _mi_ptr_segment(slice)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "index",
                        "type": "ptrdiff_t",
                        "definition": [
                            "ptrdiff_t index = slice - segment->slices"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_span_queue_push",
            "header": "",
            "params": [
                "mi_span_queue_t *sq",
                "mi_slice_t *slice"
            ],
            "definition": "static void mi_span_queue_push(mi_span_queue_t *sq, mi_slice_t *slice)\n{\n  ((slice->prev == 0) && (slice->next == 0)) ? ((void) 0) : (_mi_assert_fail(\"slice->prev == NULL && slice->next==NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 226, __func__));\n  slice->prev = 0;\n  slice->next = sq->first;\n  sq->first = slice;\n  if (slice->next != 0)\n  {\n    slice->next->prev = slice;\n  }\n  else\n    sq->last = slice;\n  slice->block_size = 0;\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "sq",
                        "type": "mi_span_queue_t *",
                        "definition": [
                            "mi_span_queue_t *sq"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *slice"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_span_queue_for",
            "header": "",
            "params": [
                "size_t slice_count",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static mi_span_queue_t *mi_span_queue_for(size_t slice_count, mi_segments_tld_t *tld)\n{\n  size_t bin = mi_slice_bin(slice_count);\n  mi_span_queue_t *sq = &tld->spans[bin];\n  (sq->slice_count >= slice_count) ? ((void) 0) : (_mi_assert_fail(\"sq->slice_count >= slice_count\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 238, __func__));\n  return sq;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_slice_bin"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "slice_count",
                        "type": "size_t",
                        "definition": [
                            "size_t slice_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bin",
                        "type": "size_t",
                        "definition": [
                            "size_t bin = mi_slice_bin(slice_count)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "sq",
                        "type": "mi_span_queue_t *",
                        "definition": [
                            "mi_span_queue_t *sq = &tld->spans[bin]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_span_queue_delete",
            "header": "",
            "params": [
                "mi_span_queue_t *sq",
                "mi_slice_t *slice"
            ],
            "definition": "static void mi_span_queue_delete(mi_span_queue_t *sq, mi_slice_t *slice)\n{\n  (((slice->block_size == 0) && (slice->slice_count > 0)) && (slice->slice_offset == 0)) ? ((void) 0) : (_mi_assert_fail(\"slice->block_size==0 && slice->slice_count>0 && slice->slice_offset==0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 243, __func__));\n  if (slice->prev != 0)\n  {\n    slice->prev->next = slice->next;\n  }\n  if (slice == sq->first)\n  {\n    sq->first = slice->next;\n  }\n  if (slice->next != 0)\n  {\n    slice->next->prev = slice->prev;\n  }\n  if (slice == sq->last)\n  {\n    sq->last = slice->prev;\n  }\n  slice->prev = 0;\n  slice->next = 0;\n  slice->block_size = 1;\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "sq",
                        "type": "mi_span_queue_t *",
                        "definition": [
                            "mi_span_queue_t *sq"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *slice"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_slice_is_used",
            "header": "",
            "params": [
                "const mi_slice_t *slice"
            ],
            "definition": "static bool mi_slice_is_used(const mi_slice_t *slice)\n{\n  return slice->block_size > 0;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "slice",
                        "type": "const mi_slice_t *",
                        "definition": [
                            "const mi_slice_t *slice"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_info_size",
            "header": "",
            "params": [
                "mi_segment_t *segment"
            ],
            "definition": "static size_t mi_segment_info_size(mi_segment_t *segment)\n{\n  return segment->segment_info_slices * (1UL << (13 + 3));\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_segment_page_start_from_slice",
            "header": "",
            "params": [
                "const mi_segment_t *segment",
                "const mi_slice_t *slice",
                "size_t block_size",
                "size_t *page_size"
            ],
            "definition": "static uint8_t *_mi_segment_page_start_from_slice(const mi_segment_t *segment, const mi_slice_t *slice, size_t block_size, size_t *page_size)\n{\n  const ptrdiff_t idx = slice - segment->slices;\n  const size_t psize = ((size_t) slice->slice_count) * (1UL << (13 + 3));\n  uint8_t * const pstart = ((uint8_t *) segment) + (idx * (1UL << (13 + 3)));\n  size_t start_offset = 0;\n  if ((block_size > 0) && (block_size <= ((1UL << (3 + (13 + 3))) / 8)))\n  {\n    const size_t adjust = block_size - (((uintptr_t) pstart) % block_size);\n    if ((adjust < block_size) && (psize >= (block_size + adjust)))\n    {\n      start_offset += adjust;\n    }\n  }\n  if (block_size >= (1 << 3))\n  {\n    if (block_size <= 64)\n    {\n      start_offset += 3 * block_size;\n    }\n    else\n      if (block_size <= 512)\n    {\n      start_offset += block_size;\n    }\n  }\n  start_offset = _mi_align_up(start_offset, 16);\n  (_mi_is_aligned(pstart + start_offset, 16)) ? ((void) 0) : (_mi_assert_fail(\"_mi_is_aligned(pstart + start_offset, MI_MAX_ALIGN_SIZE)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 353, __func__));\n  (((block_size == 0) || (block_size > ((1UL << (3 + (13 + 3))) / 8))) || _mi_is_aligned(pstart + start_offset, block_size)) ? ((void) 0) : (_mi_assert_fail(\"block_size == 0 || block_size > MI_MAX_ALIGN_GUARANTEE || _mi_is_aligned(pstart + start_offset,block_size)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 354, __func__));\n  if (page_size != 0)\n  {\n    *page_size = psize - start_offset;\n  }\n  return pstart + start_offset;\n}\n\n",
            "calle": [
                "_mi_align_up",
                "_mi_assert_fail",
                "_mi_is_aligned"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "const mi_segment_t *",
                        "definition": [
                            "const mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice",
                        "type": "const mi_slice_t *",
                        "definition": [
                            "const mi_slice_t *slice"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_size",
                        "type": "size_t",
                        "definition": [
                            "size_t block_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_size",
                        "type": "size_t *",
                        "definition": [
                            "size_t *page_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "const ptrdiff_t",
                        "definition": [
                            "const ptrdiff_t idx = slice - segment->slices"
                        ]
                    },
                    {
                        "path": null,
                        "name": "psize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t psize = ((size_t) slice->slice_count) * (1UL << (13 + 3))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pstart",
                        "type": "uint8_t * const",
                        "definition": [
                            "uint8_t * const pstart = ((uint8_t *) segment) + (idx * (1UL << (13 + 3)))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start_offset",
                        "type": "size_t",
                        "definition": [
                            "size_t start_offset = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "adjust",
                        "type": "const size_t",
                        "definition": [
                            "const size_t adjust = block_size - (((uintptr_t) pstart) % block_size)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_calculate_slices",
            "header": "",
            "params": [
                "size_t required",
                "size_t *info_slices"
            ],
            "definition": "static size_t mi_segment_calculate_slices(size_t required, size_t *info_slices)\n{\n  size_t page_size = _mi_os_page_size();\n  size_t isize = _mi_align_up(sizeof(mi_segment_t), page_size);\n  size_t guardsize = 0;\n  if (0 > 0)\n  {\n    guardsize = page_size;\n    if (required > 0)\n    {\n      required = _mi_align_up(required, 1UL << (13 + 3)) + page_size;\n    }\n  }\n  isize = _mi_align_up(isize + guardsize, 1UL << (13 + 3));\n  if (info_slices != 0)\n  {\n    *info_slices = isize / (1UL << (13 + 3));\n  }\n  size_t segment_size = (required == 0) ? (1UL << (9 + (13 + 3))) : (_mi_align_up((required + isize) + guardsize, 1UL << (13 + 3)));\n  ((segment_size % (1UL << (13 + 3))) == 0) ? ((void) 0) : (_mi_assert_fail(\"segment_size % MI_SEGMENT_SLICE_SIZE == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 387, __func__));\n  return segment_size / (1UL << (13 + 3));\n}\n\n",
            "calle": [
                "_mi_align_up",
                "_mi_assert_fail",
                "_mi_os_page_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "required",
                        "type": "size_t",
                        "definition": [
                            "size_t required"
                        ]
                    },
                    {
                        "path": null,
                        "name": "info_slices",
                        "type": "size_t *",
                        "definition": [
                            "size_t *info_slices"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_size",
                        "type": "size_t",
                        "definition": [
                            "size_t page_size = _mi_os_page_size()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "isize",
                        "type": "size_t",
                        "definition": [
                            "size_t isize = _mi_align_up(sizeof(mi_segment_t), page_size)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "guardsize",
                        "type": "size_t",
                        "definition": [
                            "size_t guardsize = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment_size",
                        "type": "size_t",
                        "definition": [
                            "size_t segment_size = (required == 0) ? (1UL << (9 + (13 + 3))) : (_mi_align_up((required + isize) + guardsize, 1UL << (13 + 3)))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segments_track_size",
            "header": "",
            "params": [
                "long segment_size",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static void mi_segments_track_size(long segment_size, mi_segments_tld_t *tld)\n{\n  if (segment_size >= 0)\n  {\n    _mi_stat_increase(&tld->stats->segments, 1);\n  }\n  else\n    _mi_stat_decrease(&tld->stats->segments, 1);\n  tld->count += (segment_size >= 0) ? (1) : (-1);\n  if (tld->count > tld->peak_count)\n  {\n    tld->peak_count = tld->count;\n  }\n  tld->current_size += segment_size;\n  if (tld->current_size > tld->peak_size)\n  {\n    tld->peak_size = tld->current_size;\n  }\n}\n\n",
            "calle": [
                "_mi_stat_decrease",
                "_mi_stat_increase"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment_size",
                        "type": "long",
                        "definition": [
                            "long segment_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_os_free",
            "header": "",
            "params": [
                "mi_segment_t *segment",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static void mi_segment_os_free(mi_segment_t *segment, mi_segments_tld_t *tld)\n{\n  segment->thread_id = 0;\n  _mi_segment_map_freed_at(segment);\n  mi_segments_track_size(-((long) mi_segment_size(segment)), tld);\n  if (segment->was_reclaimed)\n  {\n    tld->reclaim_count -= 1;\n    segment->was_reclaimed = 0;\n  }\n  if (0 > 0)\n  {\n    size_t os_pagesize = _mi_os_page_size();\n    _mi_os_unprotect((((uint8_t *) segment) + mi_segment_info_size(segment)) - os_pagesize, os_pagesize);\n    uint8_t *end = (((uint8_t *) segment) + mi_segment_size(segment)) - os_pagesize;\n    _mi_os_unprotect(end, os_pagesize);\n  }\n  const size_t size = mi_segment_size(segment);\n  const size_t csize = _mi_commit_mask_committed_size(&segment->commit_mask, size);\n  _mi_arena_free(segment, mi_segment_size(segment), csize, segment->memid);\n}\n\n",
            "calle": [
                "_mi_arena_free",
                "_mi_commit_mask_committed_size",
                "_mi_os_page_size",
                "_mi_os_unprotect",
                "_mi_segment_map_freed_at",
                "mi_segment_info_size",
                "mi_segment_size",
                "mi_segments_track_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "os_pagesize",
                        "type": "size_t",
                        "definition": [
                            "size_t os_pagesize = _mi_os_page_size()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *end = (((uint8_t *) segment) + mi_segment_size(segment)) - os_pagesize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t size = mi_segment_size(segment)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "csize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t csize = _mi_commit_mask_committed_size(&segment->commit_mask, size)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_commit_mask",
            "header": "",
            "params": [
                "mi_segment_t *segment",
                "bool conservative",
                "uint8_t *p",
                "size_t size",
                "uint8_t **start_p",
                "size_t *full_size",
                "mi_commit_mask_t *cm"
            ],
            "definition": "static void mi_segment_commit_mask(mi_segment_t *segment, bool conservative, uint8_t *p, size_t size, uint8_t **start_p, size_t *full_size, mi_commit_mask_t *cm)\n{\n  (_mi_ptr_segment(p + 1) == segment) ? ((void) 0) : (_mi_assert_fail(\"_mi_ptr_segment(p + 1) == segment\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 438, __func__));\n  (segment->kind != MI_SEGMENT_HUGE) ? ((void) 0) : (_mi_assert_fail(\"segment->kind != MI_SEGMENT_HUGE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 439, __func__));\n  mi_commit_mask_create_empty(cm);\n  if (((size == 0) || (size > (1UL << (9 + (13 + 3))))) || (segment->kind == MI_SEGMENT_HUGE))\n  {\n    return;\n  }\n  const size_t segstart = mi_segment_info_size(segment);\n  const size_t segsize = mi_segment_size(segment);\n  if (p >= (((uint8_t *) segment) + segsize))\n  {\n    return;\n  }\n  size_t pstart = p - ((uint8_t *) segment);\n  ((pstart + size) <= segsize) ? ((void) 0) : (_mi_assert_fail(\"pstart + size <= segsize\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 447, __func__));\n  size_t start;\n  size_t end;\n  if (conservative)\n  {\n    start = _mi_align_up(pstart, 1UL << (13 + 3));\n    end = _mi_align_down(pstart + size, 1UL << (13 + 3));\n    (start >= segstart) ? ((void) 0) : (_mi_assert_fail(\"start >= segstart\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 455, __func__));\n    (end <= segsize) ? ((void) 0) : (_mi_assert_fail(\"end <= segsize\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 456, __func__));\n  }\n  else\n  {\n    start = _mi_align_down(pstart, 1 * (1UL << (13 + 3)));\n    end = _mi_align_up(pstart + size, 1 * (1UL << (13 + 3)));\n  }\n  if ((pstart >= segstart) && (start < segstart))\n  {\n    start = segstart;\n  }\n  if (end > segsize)\n  {\n    end = segsize;\n  }\n  ((start <= pstart) && ((pstart + size) <= end)) ? ((void) 0) : (_mi_assert_fail(\"start <= pstart && (pstart + size) <= end\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 470, __func__));\n  (((start % (1UL << (13 + 3))) == 0) && ((end % (1UL << (13 + 3))) == 0)) ? ((void) 0) : (_mi_assert_fail(\"start % MI_COMMIT_SIZE==0 && end % MI_COMMIT_SIZE == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 471, __func__));\n  *start_p = ((uint8_t *) segment) + start;\n  *full_size = (end > start) ? (end - start) : (0);\n  if ((*full_size) == 0)\n  {\n    return;\n  }\n  size_t bitidx = start / (1UL << (13 + 3));\n  (bitidx < ((1UL << (9 + (13 + 3))) / (1UL << (13 + 3)))) ? ((void) 0) : (_mi_assert_fail(\"bitidx < MI_COMMIT_MASK_BITS\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 477, __func__));\n  size_t bitcount = (*full_size) / (1UL << (13 + 3));\n  if ((bitidx + bitcount) > ((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))))\n  {\n    _mi_warning_message(\"commit mask overflow: idx=%zu count=%zu start=%zx end=%zx p=0x%p size=%zu fullsize=%zu\\n\", bitidx, bitcount, start, end, p, size, *full_size);\n  }\n  ((bitidx + bitcount) <= ((1UL << (9 + (13 + 3))) / (1UL << (13 + 3)))) ? ((void) 0) : (_mi_assert_fail(\"(bitidx + bitcount) <= MI_COMMIT_MASK_BITS\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 483, __func__));\n  mi_commit_mask_create(bitidx, bitcount, cm);\n}\n\n",
            "calle": [
                "_mi_align_down",
                "_mi_align_up",
                "_mi_assert_fail",
                "_mi_ptr_segment",
                "_mi_warning_message",
                "mi_commit_mask_create",
                "mi_commit_mask_create_empty",
                "mi_segment_info_size",
                "mi_segment_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "conservative",
                        "type": "bool",
                        "definition": [
                            "bool conservative"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start_p",
                        "type": "uint8_t **",
                        "definition": [
                            "uint8_t **start_p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "full_size",
                        "type": "size_t *",
                        "definition": [
                            "size_t *full_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "cm",
                        "type": "mi_commit_mask_t *",
                        "definition": [
                            "mi_commit_mask_t *cm"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segstart",
                        "type": "const size_t",
                        "definition": [
                            "const size_t segstart = mi_segment_info_size(segment)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t segsize = mi_segment_size(segment)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pstart",
                        "type": "size_t",
                        "definition": [
                            "size_t pstart = p - ((uint8_t *) segment)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "size_t",
                        "definition": [
                            "size_t start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "size_t",
                        "definition": [
                            "size_t end"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitidx = start / (1UL << (13 + 3))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitcount",
                        "type": "size_t",
                        "definition": [
                            "size_t bitcount = (*full_size) / (1UL << (13 + 3))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_commit",
            "header": "",
            "params": [
                "mi_segment_t *segment",
                "uint8_t *p",
                "size_t size"
            ],
            "definition": "static bool mi_segment_commit(mi_segment_t *segment, uint8_t *p, size_t size)\n{\n  (mi_commit_mask_all_set(&segment->commit_mask, &segment->purge_mask)) ? ((void) 0) : (_mi_assert_fail(\"mi_commit_mask_all_set(&segment->commit_mask, &segment->purge_mask)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 488, __func__));\n  uint8_t *start = 0;\n  size_t full_size = 0;\n  mi_commit_mask_t mask;\n  mi_segment_commit_mask(segment, 0, p, size, &start, &full_size, &mask);\n  if (mi_commit_mask_is_empty(&mask) || (full_size == 0))\n  {\n    return 1;\n  }\n  if (!mi_commit_mask_all_set(&segment->commit_mask, &mask))\n  {\n    bool is_zero = 0;\n    mi_commit_mask_t cmask;\n    mi_commit_mask_create_intersect(&segment->commit_mask, &mask, &cmask);\n    _mi_stat_decrease(&_mi_stats_main.committed, _mi_commit_mask_committed_size(&cmask, 1UL << (9 + (13 + 3))));\n    if (!_mi_os_commit(start, full_size, &is_zero))\n    {\n      return 0;\n    }\n    mi_commit_mask_set(&segment->commit_mask, &mask);\n  }\n  if (mi_commit_mask_any_set(&segment->purge_mask, &mask))\n  {\n    segment->purge_expire = _mi_clock_now() + mi_option_get(mi_option_purge_delay);\n  }\n  mi_commit_mask_clear(&segment->purge_mask, &mask);\n  return 1;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_clock_now",
                "_mi_commit_mask_committed_size",
                "_mi_os_commit",
                "_mi_stat_decrease",
                "mi_commit_mask_all_set",
                "mi_commit_mask_any_set",
                "mi_commit_mask_clear",
                "mi_commit_mask_create_intersect",
                "mi_commit_mask_is_empty",
                "mi_commit_mask_set",
                "mi_option_get",
                "mi_segment_commit_mask"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *start = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "full_size",
                        "type": "size_t",
                        "definition": [
                            "size_t full_size = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "mi_commit_mask_t",
                        "definition": [
                            "mi_commit_mask_t mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_zero",
                        "type": "bool",
                        "definition": [
                            "bool is_zero = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "cmask",
                        "type": "mi_commit_mask_t",
                        "definition": [
                            "mi_commit_mask_t cmask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_ensure_committed",
            "header": "",
            "params": [
                "mi_segment_t *segment",
                "uint8_t *p",
                "size_t size"
            ],
            "definition": "static bool mi_segment_ensure_committed(mi_segment_t *segment, uint8_t *p, size_t size)\n{\n  (mi_commit_mask_all_set(&segment->commit_mask, &segment->purge_mask)) ? ((void) 0) : (_mi_assert_fail(\"mi_commit_mask_all_set(&segment->commit_mask, &segment->purge_mask)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 518, __func__));\n  if (mi_commit_mask_is_full(&segment->commit_mask) && mi_commit_mask_is_empty(&segment->purge_mask))\n  {\n    return 1;\n  }\n  (segment->kind != MI_SEGMENT_HUGE) ? ((void) 0) : (_mi_assert_fail(\"segment->kind != MI_SEGMENT_HUGE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 521, __func__));\n  return mi_segment_commit(segment, p, size);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_commit_mask_all_set",
                "mi_commit_mask_is_empty",
                "mi_commit_mask_is_full",
                "mi_segment_commit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_purge",
            "header": "",
            "params": [
                "mi_segment_t *segment",
                "uint8_t *p",
                "size_t size"
            ],
            "definition": "static bool mi_segment_purge(mi_segment_t *segment, uint8_t *p, size_t size)\n{\n  (mi_commit_mask_all_set(&segment->commit_mask, &segment->purge_mask)) ? ((void) 0) : (_mi_assert_fail(\"mi_commit_mask_all_set(&segment->commit_mask, &segment->purge_mask)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 526, __func__));\n  if (!segment->allow_purge)\n  {\n    return 1;\n  }\n  uint8_t *start = 0;\n  size_t full_size = 0;\n  mi_commit_mask_t mask;\n  mi_segment_commit_mask(segment, 1, p, size, &start, &full_size, &mask);\n  if (mi_commit_mask_is_empty(&mask) || (full_size == 0))\n  {\n    return 1;\n  }\n  if (mi_commit_mask_any_set(&segment->commit_mask, &mask))\n  {\n    (((void *) start) != ((void *) segment)) ? ((void) 0) : (_mi_assert_fail(\"(void*)start != (void*)segment\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 538, __func__));\n    (segment->allow_decommit) ? ((void) 0) : (_mi_assert_fail(\"segment->allow_decommit\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 539, __func__));\n    const bool decommitted = _mi_os_purge(start, full_size);\n    if (decommitted)\n    {\n      mi_commit_mask_t cmask;\n      mi_commit_mask_create_intersect(&segment->commit_mask, &mask, &cmask);\n      _mi_stat_increase(&_mi_stats_main.committed, full_size - _mi_commit_mask_committed_size(&cmask, 1UL << (9 + (13 + 3))));\n      mi_commit_mask_clear(&segment->commit_mask, &mask);\n    }\n  }\n  mi_commit_mask_clear(&segment->purge_mask, &mask);\n  return 1;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_commit_mask_committed_size",
                "_mi_os_purge",
                "_mi_stat_increase",
                "mi_commit_mask_all_set",
                "mi_commit_mask_any_set",
                "mi_commit_mask_clear",
                "mi_commit_mask_create_intersect",
                "mi_commit_mask_is_empty",
                "mi_segment_commit_mask"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *start = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "full_size",
                        "type": "size_t",
                        "definition": [
                            "size_t full_size = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "mi_commit_mask_t",
                        "definition": [
                            "mi_commit_mask_t mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "decommitted",
                        "type": "const bool",
                        "definition": [
                            "const bool decommitted = _mi_os_purge(start, full_size)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "cmask",
                        "type": "mi_commit_mask_t",
                        "definition": [
                            "mi_commit_mask_t cmask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_schedule_purge",
            "header": "",
            "params": [
                "mi_segment_t *segment",
                "uint8_t *p",
                "size_t size"
            ],
            "definition": "static void mi_segment_schedule_purge(mi_segment_t *segment, uint8_t *p, size_t size)\n{\n  if (!segment->allow_purge)\n  {\n    return;\n  }\n  if (mi_option_get(mi_option_purge_delay) == 0)\n  {\n    mi_segment_purge(segment, p, size);\n  }\n  else\n  {\n    uint8_t *start = 0;\n    size_t full_size = 0;\n    mi_commit_mask_t mask;\n    mi_segment_commit_mask(segment, 1, p, size, &start, &full_size, &mask);\n    if (mi_commit_mask_is_empty(&mask) || (full_size == 0))\n    {\n      return;\n    }\n    ((segment->purge_expire > 0) || mi_commit_mask_is_empty(&segment->purge_mask)) ? ((void) 0) : (_mi_assert_fail(\"segment->purge_expire > 0 || mi_commit_mask_is_empty(&segment->purge_mask)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 569, __func__));\n    mi_commit_mask_t cmask;\n    mi_commit_mask_create_intersect(&segment->commit_mask, &mask, &cmask);\n    mi_commit_mask_set(&segment->purge_mask, &cmask);\n    mi_msecs_t now = _mi_clock_now();\n    if (segment->purge_expire == 0)\n    {\n      segment->purge_expire = now + mi_option_get(mi_option_purge_delay);\n    }\n    else\n      if (segment->purge_expire <= now)\n    {\n      if ((segment->purge_expire + mi_option_get(mi_option_purge_extend_delay)) <= now)\n      {\n        mi_segment_try_purge(segment, 1);\n      }\n      else\n      {\n        segment->purge_expire = now + mi_option_get(mi_option_purge_extend_delay);\n      }\n    }\n    else\n    {\n      segment->purge_expire += mi_option_get(mi_option_purge_extend_delay);\n    }\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_clock_now",
                "mi_commit_mask_create_intersect",
                "mi_commit_mask_is_empty",
                "mi_commit_mask_set",
                "mi_option_get",
                "mi_segment_commit_mask",
                "mi_segment_purge",
                "mi_segment_try_purge"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *start = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "full_size",
                        "type": "size_t",
                        "definition": [
                            "size_t full_size = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "mi_commit_mask_t",
                        "definition": [
                            "mi_commit_mask_t mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "cmask",
                        "type": "mi_commit_mask_t",
                        "definition": [
                            "mi_commit_mask_t cmask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "now",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t now = _mi_clock_now()"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_is_abandoned",
            "header": "",
            "params": [
                "mi_segment_t *segment"
            ],
            "definition": "static bool mi_segment_is_abandoned(mi_segment_t *segment)\n{\n  return atomic_load_explicit(&segment->thread_id, memory_order_relaxed) == 0;\n}\n\n",
            "calle": [
                "atomic_load_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_span_free",
            "header": "",
            "params": [
                "mi_segment_t *segment",
                "size_t slice_index",
                "size_t slice_count",
                "bool allow_purge",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static void mi_segment_span_free(mi_segment_t *segment, size_t slice_index, size_t slice_count, bool allow_purge, mi_segments_tld_t *tld)\n{\n  (slice_index < segment->slice_entries) ? ((void) 0) : (_mi_assert_fail(\"slice_index < segment->slice_entries\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 633, __func__));\n  mi_span_queue_t *sq = ((segment->kind == MI_SEGMENT_HUGE) || mi_segment_is_abandoned(segment)) ? (0) : (mi_span_queue_for(slice_count, tld));\n  if (slice_count == 0)\n  {\n    slice_count = 1;\n  }\n  (((slice_index + slice_count) - 1) < segment->slice_entries) ? ((void) 0) : (_mi_assert_fail(\"slice_index + slice_count - 1 < segment->slice_entries\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 637, __func__));\n  mi_slice_t *slice = &segment->slices[slice_index];\n  slice->slice_count = (uint32_t) slice_count;\n  (slice->slice_count == slice_count) ? ((void) 0) : (_mi_assert_fail(\"slice->slice_count == slice_count\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 642, __func__));\n  slice->slice_offset = 0;\n  if (slice_count > 1)\n  {\n    mi_slice_t *last = (slice + slice_count) - 1;\n    unsigned int last_idx = 0;\n    mi_slice_t *end = (mi_slice_t *) mi_segment_slices_end(segment);\n    if ((&last[last_idx]) > end)\n    {\n      last_idx = end;\n    }\n    last->slice_count = 0;\n    last->slice_offset = (uint32_t) ((sizeof(mi_page_t)) * (slice_count - 1));\n    last->block_size = 0;\n  }\n  if (allow_purge)\n  {\n    mi_segment_schedule_purge(segment, mi_slice_start(slice), slice_count * (1UL << (13 + 3)));\n  }\n  if (sq != 0)\n  {\n    mi_span_queue_push(sq, slice);\n  }\n  else\n    slice->block_size = 0;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_segment_is_abandoned",
                "mi_segment_schedule_purge",
                "mi_segment_slices_end",
                "mi_slice_start",
                "mi_span_queue_for",
                "mi_span_queue_push"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_index",
                        "type": "size_t",
                        "definition": [
                            "size_t slice_index"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_count",
                        "type": "size_t",
                        "definition": [
                            "size_t slice_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_purge",
                        "type": "bool",
                        "definition": [
                            "bool allow_purge"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "sq",
                        "type": "mi_span_queue_t *",
                        "definition": [
                            "mi_span_queue_t *sq = ((segment->kind == MI_SEGMENT_HUGE) || mi_segment_is_abandoned(segment)) ? (0) : (mi_span_queue_for(slice_count, tld))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *slice = &segment->slices[slice_index]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "last",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *last = (slice + slice_count) - 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "last_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int last_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *end = (mi_slice_t *) mi_segment_slices_end(segment)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_span_remove_from_queue",
            "header": "",
            "params": [
                "mi_slice_t *slice",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static void mi_segment_span_remove_from_queue(mi_slice_t *slice, mi_segments_tld_t *tld)\n{\n  (((slice->slice_count > 0) && (slice->slice_offset == 0)) && (slice->block_size == 0)) ? ((void) 0) : (_mi_assert_fail(\"slice->slice_count > 0 && slice->slice_offset==0 && slice->block_size==0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 674, __func__));\n  (_mi_ptr_segment(slice)->kind != MI_SEGMENT_HUGE) ? ((void) 0) : (_mi_assert_fail(\"_mi_ptr_segment(slice)->kind != MI_SEGMENT_HUGE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 675, __func__));\n  mi_span_queue_t *sq = mi_span_queue_for(slice->slice_count, tld);\n  mi_span_queue_delete(sq, slice);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_ptr_segment",
                "mi_span_queue_delete",
                "mi_span_queue_for"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "slice",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *slice"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "sq",
                        "type": "mi_span_queue_t *",
                        "definition": [
                            "mi_span_queue_t *sq = mi_span_queue_for(slice->slice_count, tld)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_span_free_coalesce",
            "header": "",
            "params": [
                "mi_slice_t *slice",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static mi_slice_t *mi_segment_span_free_coalesce(mi_slice_t *slice, mi_segments_tld_t *tld)\n{\n  unsigned int slice_idx = 0;\n  ((((&slice[slice_idx]) != 0) && (slice->slice_count > 0)) && (slice->slice_offset == 0)) ? ((void) 0) : (_mi_assert_fail(\"slice != NULL && slice->slice_count > 0 && slice->slice_offset == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 682, __func__));\n  mi_segment_t * const segment = _mi_ptr_segment(slice);\n  if (segment->kind == MI_SEGMENT_HUGE)\n  {\n    (((segment->used == 0) && (slice->block_size == 0)) || (segment->used == 1)) ? ((void) 0) : (_mi_assert_fail(\"(segment->used==0 && slice->block_size==0) || segment->used == 1\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 688, __func__));\n    slice->block_size = 0;\n    return slice;\n  }\n  const bool is_abandoned = segment->thread_id == 0;\n  size_t slice_count = slice->slice_count;\n  mi_slice_t *next = (&slice[slice_idx]) + slice->slice_count;\n  (next <= mi_segment_slices_end(segment)) ? ((void) 0) : (_mi_assert_fail(\"next <= mi_segment_slices_end(segment)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 699, __func__));\n  if ((next < mi_segment_slices_end(segment)) && (next->block_size == 0))\n  {\n    ((next->slice_count > 0) && (next->slice_offset == 0)) ? ((void) 0) : (_mi_assert_fail(\"next->slice_count > 0 && next->slice_offset==0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 702, __func__));\n    slice_count += next->slice_count;\n    if (!is_abandoned)\n    {\n      mi_segment_span_remove_from_queue(next, tld);\n    }\n  }\n  if ((&slice[slice_idx]) > segment->slices)\n  {\n    mi_slice_t *prev = mi_slice_first((&slice[slice_idx]) - 1);\n    (prev >= segment->slices) ? ((void) 0) : (_mi_assert_fail(\"prev >= segment->slices\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 708, __func__));\n    if (prev->block_size == 0)\n    {\n      ((prev->slice_count > 0) && (prev->slice_offset == 0)) ? ((void) 0) : (_mi_assert_fail(\"prev->slice_count > 0 && prev->slice_offset==0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 711, __func__));\n      slice_count += prev->slice_count;\n      slice->slice_count = 0;\n      slice->slice_offset = (uint32_t) (((uint8_t *) slice) - ((uint8_t *) prev));\n      if (!is_abandoned)\n      {\n        mi_segment_span_remove_from_queue(prev, tld);\n      }\n      slice_idx = prev;\n    }\n  }\n  mi_segment_span_free(segment, mi_slice_index(slice), slice_count, 1, tld);\n  return slice;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_ptr_segment",
                "mi_segment_slices_end",
                "mi_segment_span_free",
                "mi_segment_span_remove_from_queue",
                "mi_slice_first",
                "mi_slice_index"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "slice",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *slice"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int slice_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t * const",
                        "definition": [
                            "mi_segment_t * const segment = _mi_ptr_segment(slice)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_abandoned",
                        "type": "const bool",
                        "definition": [
                            "const bool is_abandoned = segment->thread_id == 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_count",
                        "type": "size_t",
                        "definition": [
                            "size_t slice_count = slice->slice_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *next = (&slice[slice_idx]) + slice->slice_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prev",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *prev = mi_slice_first((&slice[slice_idx]) - 1)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_span_allocate",
            "header": "",
            "params": [
                "mi_segment_t *segment",
                "size_t slice_index",
                "size_t slice_count"
            ],
            "definition": "static mi_page_t *mi_segment_span_allocate(mi_segment_t *segment, size_t slice_index, size_t slice_count)\n{\n  (slice_index < segment->slice_entries) ? ((void) 0) : (_mi_assert_fail(\"slice_index < segment->slice_entries\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 733, __func__));\n  mi_slice_t * const slice = &segment->slices[slice_index];\n  ((slice->block_size == 0) || (slice->block_size == 1)) ? ((void) 0) : (_mi_assert_fail(\"slice->block_size==0 || slice->block_size==1\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 735, __func__));\n  if (!mi_segment_ensure_committed(segment, _mi_segment_page_start_from_slice(segment, slice, 0, 0), slice_count * (1UL << (13 + 3))))\n  {\n    return 0;\n  }\n  slice->slice_offset = 0;\n  slice->slice_count = (uint32_t) slice_count;\n  (slice->slice_count == slice_count) ? ((void) 0) : (_mi_assert_fail(\"slice->slice_count == slice_count\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 745, __func__));\n  const size_t bsize = slice_count * (1UL << (13 + 3));\n  slice->block_size = bsize;\n  mi_page_t *page = mi_slice_to_page(slice);\n  (mi_page_block_size(page) == bsize) ? ((void) 0) : (_mi_assert_fail(\"mi_page_block_size(page) == bsize\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 749, __func__));\n  size_t extra = slice_count - 1;\n  if (extra > ((((1UL << (9 + (13 + 3))) >> 1) / (1UL << (13 + 3))) - 1))\n  {\n    extra = (((1UL << (9 + (13 + 3))) >> 1) / (1UL << (13 + 3))) - 1;\n  }\n  if ((slice_index + extra) >= segment->slice_entries)\n  {\n    extra = (segment->slice_entries - slice_index) - 1;\n  }\n  mi_slice_t *slice_next = slice + 1;\n  unsigned int slice_next_idx = 0;\n  for (size_t i = 1; i <= extra; i += 1, slice_next_idx += 1)\n  {\n    slice_next->slice_offset = (uint32_t) ((sizeof(mi_slice_t)) * i);\n    slice_next->slice_count = 0;\n    slice_next->block_size = 1;\n  }\n\n  mi_slice_t *last = (slice + slice_count) - 1;\n  unsigned int last_idx = 0;\n  mi_slice_t *end = (mi_slice_t *) mi_segment_slices_end(segment);\n  if ((&last[last_idx]) > end)\n  {\n    last_idx = end;\n  }\n  if ((&last[last_idx]) > slice)\n  {\n    last->slice_offset = (uint32_t) ((sizeof(mi_slice_t)) * ((&last[last_idx]) - slice));\n    last->slice_count = 0;\n    last->block_size = 1;\n  }\n  page->is_committed = 1;\n  page->is_huge = segment->kind == MI_SEGMENT_HUGE;\n  segment->used += 1;\n  return page;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_segment_page_start_from_slice",
                "mi_page_block_size",
                "mi_segment_ensure_committed",
                "mi_segment_slices_end",
                "mi_slice_to_page"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_index",
                        "type": "size_t",
                        "definition": [
                            "size_t slice_index"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_count",
                        "type": "size_t",
                        "definition": [
                            "size_t slice_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice",
                        "type": "mi_slice_t * const",
                        "definition": [
                            "mi_slice_t * const slice = &segment->slices[slice_index]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t bsize = slice_count * (1UL << (13 + 3))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = mi_slice_to_page(slice)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "extra",
                        "type": "size_t",
                        "definition": [
                            "size_t extra = slice_count - 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_next",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *slice_next = slice + 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_next_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int slice_next_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "last",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *last = (slice + slice_count) - 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "last_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int last_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *end = (mi_slice_t *) mi_segment_slices_end(segment)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_slice_split",
            "header": "",
            "params": [
                "mi_segment_t *segment",
                "mi_slice_t *slice",
                "size_t slice_count",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static void mi_segment_slice_split(mi_segment_t *segment, mi_slice_t *slice, size_t slice_count, mi_segments_tld_t *tld)\n{\n  (_mi_ptr_segment(slice) == segment) ? ((void) 0) : (_mi_assert_fail(\"_mi_ptr_segment(slice) == segment\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 782, __func__));\n  (slice->slice_count >= slice_count) ? ((void) 0) : (_mi_assert_fail(\"slice->slice_count >= slice_count\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 783, __func__));\n  (slice->block_size > 0) ? ((void) 0) : (_mi_assert_fail(\"slice->block_size > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 784, __func__));\n  if (slice->slice_count <= slice_count)\n  {\n    return;\n  }\n  (segment->kind != MI_SEGMENT_HUGE) ? ((void) 0) : (_mi_assert_fail(\"segment->kind != MI_SEGMENT_HUGE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 786, __func__));\n  size_t next_index = mi_slice_index(slice) + slice_count;\n  size_t next_count = slice->slice_count - slice_count;\n  mi_segment_span_free(segment, next_index, next_count, 0, tld);\n  slice->slice_count = (uint32_t) slice_count;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_ptr_segment",
                "mi_segment_span_free",
                "mi_slice_index"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *slice"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_count",
                        "type": "size_t",
                        "definition": [
                            "size_t slice_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next_index",
                        "type": "size_t",
                        "definition": [
                            "size_t next_index = mi_slice_index(slice) + slice_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "next_count",
                        "type": "size_t",
                        "definition": [
                            "size_t next_count = slice->slice_count - slice_count"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segments_page_find_and_allocate",
            "header": "",
            "params": [
                "size_t slice_count",
                "mi_arena_id_t req_arena_id",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static mi_page_t *mi_segments_page_find_and_allocate(size_t slice_count, mi_arena_id_t req_arena_id, mi_segments_tld_t *tld)\n{\n  ((slice_count * (1UL << (13 + 3))) <= ((1UL << (9 + (13 + 3))) / 2)) ? ((void) 0) : (_mi_assert_fail(\"slice_count*MI_SEGMENT_SLICE_SIZE <= MI_LARGE_OBJ_SIZE_MAX\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 794, __func__));\n  mi_span_queue_t *sq = mi_span_queue_for(slice_count, tld);\n  unsigned int sq_idx = 0;\n  if (slice_count == 0)\n  {\n    slice_count = 1;\n  }\n  while ((&sq[sq_idx]) <= (&tld->spans[35]))\n  {\n    for (mi_slice_t *slice = sq->first; (&slice[slice_idx]) != 0; slice_idx = slice_idx->next)\n    {\n      if (slice->slice_count >= slice_count)\n      {\n        mi_segment_t *segment = _mi_ptr_segment(slice);\n        if (_mi_arena_memid_is_suitable(segment->memid, req_arena_id))\n        {\n          mi_span_queue_delete(sq, slice);\n          if (slice->slice_count > slice_count)\n          {\n            mi_segment_slice_split(segment, slice, slice_count, tld);\n          }\n          ((((&slice[slice_idx]) != 0) && (slice->slice_count == slice_count)) && (slice->block_size > 0)) ? ((void) 0) : (_mi_assert_fail(\"slice != NULL && slice->slice_count == slice_count && slice->block_size > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 810, __func__));\n          mi_page_t *page = mi_segment_span_allocate(segment, mi_slice_index(slice), slice->slice_count);\n          if (page == 0)\n          {\n            mi_segment_span_free_coalesce(slice, tld);\n            return 0;\n          }\n          return page;\n        }\n      }\n    }\n\n    unsigned int slice_idx = 0;\n    sq_idx += 1;\n  }\n\n  return 0;\n}\n\n",
            "calle": [
                "_mi_arena_memid_is_suitable",
                "_mi_assert_fail",
                "_mi_ptr_segment",
                "mi_segment_slice_split",
                "mi_segment_span_allocate",
                "mi_segment_span_free_coalesce",
                "mi_slice_index",
                "mi_span_queue_delete",
                "mi_span_queue_for"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "slice_count",
                        "type": "size_t",
                        "definition": [
                            "size_t slice_count"
                        ]
                    },
                    {
                        "path": null,
                        "name": "req_arena_id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t req_arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "sq",
                        "type": "mi_span_queue_t *",
                        "definition": [
                            "mi_span_queue_t *sq = mi_span_queue_for(slice_count, tld)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "sq_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int sq_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *slice = sq->first"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = _mi_ptr_segment(slice)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = mi_segment_span_allocate(segment, mi_slice_index(slice), slice->slice_count)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int slice_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_os_alloc",
            "header": "",
            "params": [
                "size_t required",
                "size_t page_alignment",
                "bool eager_delayed",
                "mi_arena_id_t req_arena_id",
                "size_t *psegment_slices",
                "size_t *pinfo_slices",
                "bool commit",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static mi_segment_t *mi_segment_os_alloc(size_t required, size_t page_alignment, bool eager_delayed, mi_arena_id_t req_arena_id, size_t *psegment_slices, size_t *pinfo_slices, bool commit, mi_segments_tld_t *tld)\n{\n  mi_memid_t memid;\n  bool allow_large = (!eager_delayed) && (0 == 0);\n  size_t align_offset = 0;\n  size_t alignment = 1UL << (9 + (13 + 3));\n  if (page_alignment > 0)\n  {\n    (page_alignment >= (1UL << (9 + (13 + 3)))) ? ((void) 0) : (_mi_assert_fail(\"page_alignment >= MI_SEGMENT_ALIGN\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 844, __func__));\n    alignment = page_alignment;\n    const size_t info_size = (*pinfo_slices) * (1UL << (13 + 3));\n    align_offset = _mi_align_up(info_size, 1UL << (9 + (13 + 3)));\n    const size_t extra = align_offset - info_size;\n    *psegment_slices = mi_segment_calculate_slices(required + extra, pinfo_slices);\n    (((*psegment_slices) > 0) && ((*psegment_slices) <= UINT32_MAX)) ? ((void) 0) : (_mi_assert_fail(\"*psegment_slices > 0 && *psegment_slices <= UINT32_MAX\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 851, __func__));\n  }\n  const size_t segment_size = (*psegment_slices) * (1UL << (13 + 3));\n  mi_segment_t *segment = (mi_segment_t *) _mi_arena_alloc_aligned(segment_size, alignment, align_offset, commit, allow_large, req_arena_id, &memid);\n  if (segment == 0)\n  {\n    return 0;\n  }\n  mi_commit_mask_t commit_mask;\n  if (memid.initially_committed)\n  {\n    mi_commit_mask_create_full(&commit_mask);\n  }\n  else\n  {\n    const size_t commit_needed = _mi_divide_up((*pinfo_slices) * (1UL << (13 + 3)), 1UL << (13 + 3));\n    (commit_needed > 0) ? ((void) 0) : (_mi_assert_fail(\"commit_needed>0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 868, __func__));\n    mi_commit_mask_create(0, commit_needed, &commit_mask);\n    ((commit_needed * (1UL << (13 + 3))) >= ((*pinfo_slices) * (1UL << (13 + 3)))) ? ((void) 0) : (_mi_assert_fail(\"commit_needed*MI_COMMIT_SIZE >= (*pinfo_slices)*MI_SEGMENT_SLICE_SIZE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 870, __func__));\n    if (!_mi_os_commit(segment, commit_needed * (1UL << (13 + 3)), 0))\n    {\n      _mi_arena_free(segment, segment_size, 0, memid);\n      return 0;\n    }\n  }\n  ((segment != 0) && ((((uintptr_t) segment) % (1UL << (9 + (13 + 3)))) == 0)) ? ((void) 0) : (_mi_assert_fail(\"segment != NULL && (uintptr_t)segment % MI_SEGMENT_SIZE == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 876, __func__));\n  segment->memid = memid;\n  segment->allow_decommit = !memid.is_pinned;\n  segment->allow_purge = segment->allow_decommit && (mi_option_get(mi_option_purge_delay) >= 0);\n  segment->segment_size = segment_size;\n  segment->subproc = tld->subproc;\n  segment->commit_mask = commit_mask;\n  segment->purge_expire = 0;\n  mi_commit_mask_create_empty(&segment->purge_mask);\n  mi_segments_track_size((long) segment_size, tld);\n  _mi_segment_map_allocated_at(segment);\n  return segment;\n}\n\n",
            "calle": [
                "_mi_align_up",
                "_mi_arena_alloc_aligned",
                "_mi_arena_free",
                "_mi_assert_fail",
                "_mi_divide_up",
                "_mi_os_commit",
                "_mi_segment_map_allocated_at",
                "mi_commit_mask_create",
                "mi_commit_mask_create_empty",
                "mi_commit_mask_create_full",
                "mi_option_get",
                "mi_segment_calculate_slices",
                "mi_segments_track_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "required",
                        "type": "size_t",
                        "definition": [
                            "size_t required"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t page_alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "eager_delayed",
                        "type": "bool",
                        "definition": [
                            "bool eager_delayed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "req_arena_id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t req_arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "psegment_slices",
                        "type": "size_t *",
                        "definition": [
                            "size_t *psegment_slices"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pinfo_slices",
                        "type": "size_t *",
                        "definition": [
                            "size_t *pinfo_slices"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit",
                        "type": "bool",
                        "definition": [
                            "bool commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_large",
                        "type": "bool",
                        "definition": [
                            "bool allow_large = (!eager_delayed) && (0 == 0)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "align_offset",
                        "type": "size_t",
                        "definition": [
                            "size_t align_offset = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t alignment = 1UL << (9 + (13 + 3))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "info_size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t info_size = (*pinfo_slices) * (1UL << (13 + 3))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "extra",
                        "type": "const size_t",
                        "definition": [
                            "const size_t extra = align_offset - info_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment_size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t segment_size = (*psegment_slices) * (1UL << (13 + 3))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = (mi_segment_t *) _mi_arena_alloc_aligned(segment_size, alignment, align_offset, commit, allow_large, req_arena_id, &memid)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit_mask",
                        "type": "mi_commit_mask_t",
                        "definition": [
                            "mi_commit_mask_t commit_mask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit_needed",
                        "type": "const size_t",
                        "definition": [
                            "const size_t commit_needed = _mi_divide_up((*pinfo_slices) * (1UL << (13 + 3)), 1UL << (13 + 3))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_alloc",
            "header": "",
            "params": [
                "size_t required",
                "size_t page_alignment",
                "mi_arena_id_t req_arena_id",
                "mi_segments_tld_t *tld",
                "mi_page_t **huge_page"
            ],
            "definition": "static mi_segment_t *mi_segment_alloc(size_t required, size_t page_alignment, mi_arena_id_t req_arena_id, mi_segments_tld_t *tld, mi_page_t **huge_page)\n{\n  (((required == 0) && (huge_page == 0)) || ((required > 0) && (huge_page != 0))) ? ((void) 0) : (_mi_assert_fail(\"(required==0 && huge_page==NULL) || (required>0 && huge_page != NULL)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 896, __func__));\n  size_t info_slices;\n  size_t segment_slices = mi_segment_calculate_slices(required, &info_slices);\n  ((segment_slices > 0) && (segment_slices <= UINT32_MAX)) ? ((void) 0) : (_mi_assert_fail(\"segment_slices > 0 && segment_slices <= UINT32_MAX\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 901, __func__));\n  const bool eager_delay = (_mi_current_thread_count() > 1) && (tld->peak_count < ((size_t) mi_option_get(mi_option_eager_commit_delay)));\n  const bool eager = (!eager_delay) && mi_option_is_enabled(mi_option_eager_commit);\n  bool commit = eager || (required > 0);\n  mi_segment_t *segment = mi_segment_os_alloc(required, page_alignment, eager_delay, req_arena_id, &segment_slices, &info_slices, commit, tld);\n  if (segment == 0)\n  {\n    return 0;\n  }\n  if (!segment->memid.initially_zero)\n  {\n    ptrdiff_t ofs = offsetof(mi_segment_t, next);\n    size_t prefix = offsetof(mi_segment_t, slices) - ofs;\n    size_t zsize = prefix + ((sizeof(mi_slice_t)) * (segment_slices + 1));\n    _mi_memzero(((uint8_t *) segment) + ofs, zsize);\n  }\n  const size_t slice_entries = (segment_slices > ((1UL << (9 + (13 + 3))) / (1UL << (13 + 3)))) ? ((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) : (segment_slices);\n  segment->segment_slices = segment_slices;\n  segment->segment_info_slices = info_slices;\n  segment->thread_id = _mi_thread_id();\n  segment->cookie = _mi_ptr_cookie(segment);\n  segment->slice_entries = slice_entries;\n  segment->kind = (required == 0) ? (MI_SEGMENT_NORMAL) : (MI_SEGMENT_HUGE);\n  _mi_stat_increase(&tld->stats->page_committed, mi_segment_info_size(segment));\n  size_t guard_slices = 0;\n  if (0 > 0)\n  {\n    size_t os_pagesize = _mi_os_page_size();\n    _mi_os_protect((((uint8_t *) segment) + mi_segment_info_size(segment)) - os_pagesize, os_pagesize);\n    uint8_t *end = (((uint8_t *) segment) + mi_segment_size(segment)) - os_pagesize;\n    mi_segment_ensure_committed(segment, end, os_pagesize);\n    _mi_os_protect(end, os_pagesize);\n    if (slice_entries == segment_slices)\n    {\n      segment->slice_entries -= 1;\n    }\n    guard_slices = 1;\n  }\n  mi_page_t *page0 = mi_segment_span_allocate(segment, 0, info_slices);\n  (page0 != 0) ? ((void) 0) : (_mi_assert_fail(\"page0!=NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 951, __func__));\n  if (page0 == 0)\n  {\n    return 0;\n  }\n  (segment->used == 1) ? ((void) 0) : (_mi_assert_fail(\"segment->used == 1\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 952, __func__));\n  segment->used = 0;\n  if (segment->kind == MI_SEGMENT_NORMAL)\n  {\n    (huge_page == 0) ? ((void) 0) : (_mi_assert_fail(\"huge_page==NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 957, __func__));\n    mi_segment_span_free(segment, info_slices, segment->slice_entries - info_slices, 0, tld);\n  }\n  else\n  {\n    (huge_page != 0) ? ((void) 0) : (_mi_assert_fail(\"huge_page!=NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 961, __func__));\n    (mi_commit_mask_is_empty(&segment->purge_mask)) ? ((void) 0) : (_mi_assert_fail(\"mi_commit_mask_is_empty(&segment->purge_mask)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 962, __func__));\n    (mi_commit_mask_is_full(&segment->commit_mask)) ? ((void) 0) : (_mi_assert_fail(\"mi_commit_mask_is_full(&segment->commit_mask)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 963, __func__));\n    *huge_page = mi_segment_span_allocate(segment, info_slices, (segment_slices - info_slices) - guard_slices);\n    ((*huge_page) != 0) ? ((void) 0) : (_mi_assert_fail(\"*huge_page != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 965, __func__));\n  }\n  ;\n  return segment;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_current_thread_count",
                "_mi_memzero",
                "_mi_os_page_size",
                "_mi_os_protect",
                "_mi_ptr_cookie",
                "_mi_stat_increase",
                "_mi_thread_id",
                "mi_commit_mask_is_empty",
                "mi_commit_mask_is_full",
                "mi_option_get",
                "mi_option_is_enabled",
                "mi_segment_calculate_slices",
                "mi_segment_ensure_committed",
                "mi_segment_info_size",
                "mi_segment_os_alloc",
                "mi_segment_size",
                "mi_segment_span_allocate",
                "mi_segment_span_free",
                "offsetof"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "required",
                        "type": "size_t",
                        "definition": [
                            "size_t required"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t page_alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "req_arena_id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t req_arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "huge_page",
                        "type": "mi_page_t **",
                        "definition": [
                            "mi_page_t **huge_page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "info_slices",
                        "type": "size_t",
                        "definition": [
                            "size_t info_slices"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment_slices",
                        "type": "size_t",
                        "definition": [
                            "size_t segment_slices = mi_segment_calculate_slices(required, &info_slices)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "eager_delay",
                        "type": "const bool",
                        "definition": [
                            "const bool eager_delay = (_mi_current_thread_count() > 1) && (tld->peak_count < ((size_t) mi_option_get(mi_option_eager_commit_delay)))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "eager",
                        "type": "const bool",
                        "definition": [
                            "const bool eager = (!eager_delay) && mi_option_is_enabled(mi_option_eager_commit)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit",
                        "type": "bool",
                        "definition": [
                            "bool commit = eager || (required > 0)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = mi_segment_os_alloc(required, page_alignment, eager_delay, req_arena_id, &segment_slices, &info_slices, commit, tld)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ofs",
                        "type": "ptrdiff_t",
                        "definition": [
                            "ptrdiff_t ofs = offsetof(mi_segment_t, next)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prefix",
                        "type": "size_t",
                        "definition": [
                            "size_t prefix = offsetof(mi_segment_t, slices) - ofs"
                        ]
                    },
                    {
                        "path": null,
                        "name": "zsize",
                        "type": "size_t",
                        "definition": [
                            "size_t zsize = prefix + ((sizeof(mi_slice_t)) * (segment_slices + 1))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_entries",
                        "type": "const size_t",
                        "definition": [
                            "const size_t slice_entries = (segment_slices > ((1UL << (9 + (13 + 3))) / (1UL << (13 + 3)))) ? ((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) : (segment_slices)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "guard_slices",
                        "type": "size_t",
                        "definition": [
                            "size_t guard_slices = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "os_pagesize",
                        "type": "size_t",
                        "definition": [
                            "size_t os_pagesize = _mi_os_page_size()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *end = (((uint8_t *) segment) + mi_segment_size(segment)) - os_pagesize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page0",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page0 = mi_segment_span_allocate(segment, 0, info_slices)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_free",
            "header": "",
            "params": [
                "mi_segment_t *segment",
                "bool force",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static void mi_segment_free(mi_segment_t *segment, bool force, mi_segments_tld_t *tld)\n{\n  (void) force;\n  (segment != 0) ? ((void) 0) : (_mi_assert_fail(\"segment != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 975, __func__));\n  (segment->next == 0) ? ((void) 0) : (_mi_assert_fail(\"segment->next == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 976, __func__));\n  (segment->used == 0) ? ((void) 0) : (_mi_assert_fail(\"segment->used == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 977, __func__));\n  if (segment->dont_free)\n  {\n    return;\n  }\n  mi_slice_t *slice = &segment->slices[0];\n  unsigned int slice_idx = 0;\n  const mi_slice_t *end = mi_segment_slices_end(segment);\n  size_t page_count = 0;\n  while ((&slice[slice_idx]) < end)\n  {\n    (slice->slice_count > 0) ? ((void) 0) : (_mi_assert_fail(\"slice->slice_count > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 989, __func__));\n    (slice->slice_offset == 0) ? ((void) 0) : (_mi_assert_fail(\"slice->slice_offset == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 990, __func__));\n    ((mi_slice_index(slice) == 0) || (slice->block_size == 0)) ? ((void) 0) : (_mi_assert_fail(\"mi_slice_index(slice)==0 || slice->block_size == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 991, __func__));\n    if ((slice->block_size == 0) && (segment->kind != MI_SEGMENT_HUGE))\n    {\n      mi_segment_span_remove_from_queue(slice, tld);\n    }\n    page_count += 1;\n    slice_idx = slice_idx + slice_idx->slice_count;\n  }\n\n  (page_count == 2) ? ((void) 0) : (_mi_assert_fail(\"page_count == 2\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1000, __func__));\n  mi_segment_os_free(segment, tld);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_segment_os_free",
                "mi_segment_slices_end",
                "mi_segment_span_remove_from_queue",
                "mi_slice_index"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "force",
                        "type": "bool",
                        "definition": [
                            "bool force"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *slice = &segment->slices[0]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int slice_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "const mi_slice_t *",
                        "definition": [
                            "const mi_slice_t *end = mi_segment_slices_end(segment)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_count",
                        "type": "size_t",
                        "definition": [
                            "size_t page_count = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_abandon",
            "header": "static void mi_segment_abandon(mi_segment_t *segment, mi_segments_tld_t *tld)",
            "params": [
                "mi_segment_t *segment",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static void mi_segment_abandon(mi_segment_t *segment, mi_segments_tld_t *tld)\n{\n  (segment->used == segment->abandoned) ? ((void) 0) : (_mi_assert_fail(\"segment->used == segment->abandoned\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1099, __func__));\n  (segment->used > 0) ? ((void) 0) : (_mi_assert_fail(\"segment->used > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1100, __func__));\n  (segment->abandoned_visits == 0) ? ((void) 0) : (_mi_assert_fail(\"segment->abandoned_visits == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1101, __func__));\n  ;\n  mi_slice_t *slice = &segment->slices[0];\n  unsigned int slice_idx = 0;\n  const mi_slice_t *end = mi_segment_slices_end(segment);\n  while ((&slice[slice_idx]) < end)\n  {\n    (slice->slice_count > 0) ? ((void) 0) : (_mi_assert_fail(\"slice->slice_count > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1108, __func__));\n    (slice->slice_offset == 0) ? ((void) 0) : (_mi_assert_fail(\"slice->slice_offset == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1109, __func__));\n    if (slice->block_size == 0)\n    {\n      mi_segment_span_remove_from_queue(slice, tld);\n      slice->block_size = 0;\n    }\n    slice_idx = slice_idx + slice_idx->slice_count;\n  }\n\n  const bool force_purge = (segment->memid.memkind != MI_MEM_ARENA) || mi_option_is_enabled(mi_option_abandoned_page_purge);\n  mi_segment_try_purge(segment, force_purge);\n  _mi_stat_increase(&tld->stats->segments_abandoned, 1);\n  mi_segments_track_size(-((long) mi_segment_size(segment)), tld);\n  segment->thread_id = 0;\n  segment->abandoned_visits = 1;\n  if (segment->was_reclaimed)\n  {\n    tld->reclaim_count -= 1;\n    segment->was_reclaimed = 0;\n  }\n  _mi_arena_segment_mark_abandoned(segment);\n}\n\n",
            "calle": [
                "_mi_arena_segment_mark_abandoned",
                "_mi_assert_fail",
                "_mi_stat_increase",
                "mi_option_is_enabled",
                "mi_segment_size",
                "mi_segment_slices_end",
                "mi_segment_span_remove_from_queue",
                "mi_segment_try_purge",
                "mi_segments_track_size"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *slice = &segment->slices[0]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int slice_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "const mi_slice_t *",
                        "definition": [
                            "const mi_slice_t *end = mi_segment_slices_end(segment)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "force_purge",
                        "type": "const bool",
                        "definition": [
                            "const bool force_purge = (segment->memid.memkind != MI_MEM_ARENA) || mi_option_is_enabled(mi_option_abandoned_page_purge)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_page_clear",
            "header": "",
            "params": [
                "mi_page_t *page",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static mi_slice_t *mi_segment_page_clear(mi_page_t *page, mi_segments_tld_t *tld)\n{\n  (page->block_size > 0) ? ((void) 0) : (_mi_assert_fail(\"page->block_size > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1018, __func__));\n  (mi_page_all_free(page)) ? ((void) 0) : (_mi_assert_fail(\"mi_page_all_free(page)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1019, __func__));\n  mi_segment_t *segment = _mi_ptr_segment(page);\n  (segment->used > 0) ? ((void) 0) : (_mi_assert_fail(\"segment->used > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1021, __func__));\n  size_t inuse = page->capacity * mi_page_block_size(page);\n  _mi_stat_decrease(&tld->stats->page_committed, inuse);\n  _mi_stat_decrease(&tld->stats->pages, 1);\n  _mi_stat_decrease(&tld->stats->page_bins[_mi_page_bin(page)], 1);\n  if (segment->allow_decommit && mi_option_is_enabled(mi_option_deprecated_page_reset))\n  {\n    size_t psize;\n    uint8_t *start = _mi_segment_page_start(segment, page, &psize);\n    _mi_os_reset(start, psize);\n  }\n  page->is_zero_init = 0;\n  uint8_t heap_tag = page->heap_tag;\n  ptrdiff_t ofs = offsetof(mi_page_t, capacity);\n  _mi_memzero(((uint8_t *) page) + ofs, (sizeof(*page)) - ofs);\n  page->block_size = 1;\n  page->heap_tag = heap_tag;\n  mi_slice_t *slice = mi_segment_span_free_coalesce(mi_page_to_slice(page), tld);\n  segment->used -= 1;\n  return slice;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_memzero",
                "_mi_os_reset",
                "_mi_page_bin",
                "_mi_ptr_segment",
                "_mi_segment_page_start",
                "_mi_stat_decrease",
                "mi_option_is_enabled",
                "mi_page_all_free",
                "mi_page_block_size",
                "mi_page_to_slice",
                "mi_segment_span_free_coalesce",
                "offsetof"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = _mi_ptr_segment(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "inuse",
                        "type": "size_t",
                        "definition": [
                            "size_t inuse = page->capacity * mi_page_block_size(page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "psize",
                        "type": "size_t",
                        "definition": [
                            "size_t psize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *start = _mi_segment_page_start(segment, page, &psize)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap_tag",
                        "type": "uint8_t",
                        "definition": [
                            "uint8_t heap_tag = page->heap_tag"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ofs",
                        "type": "ptrdiff_t",
                        "definition": [
                            "ptrdiff_t ofs = offsetof(mi_page_t, capacity)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *slice = mi_segment_span_free_coalesce(mi_page_to_slice(page), tld)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_slices_start_iterate",
            "header": "",
            "params": [
                "mi_segment_t *segment",
                "const mi_slice_t **end"
            ],
            "definition": "static mi_slice_t *mi_slices_start_iterate(mi_segment_t *segment, const mi_slice_t **end)\n{\n  mi_slice_t *slice = &segment->slices[0];\n  unsigned int slice_idx = 0;\n  *end = mi_segment_slices_end(segment);\n  ((slice->slice_count > 0) && (slice->block_size > 0)) ? ((void) 0) : (_mi_assert_fail(\"slice->slice_count>0 && slice->block_size>0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1159, __func__));\n  slice_idx = slice_idx + slice_idx->slice_count;\n  return slice;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_segment_slices_end"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "const mi_slice_t **",
                        "definition": [
                            "const mi_slice_t **end"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *slice = &segment->slices[0]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int slice_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_check_free",
            "header": "",
            "params": [
                "mi_segment_t *segment",
                "size_t slices_needed",
                "size_t block_size",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static bool mi_segment_check_free(mi_segment_t *segment, size_t slices_needed, size_t block_size, mi_segments_tld_t *tld)\n{\n  (mi_segment_is_abandoned(segment)) ? ((void) 0) : (_mi_assert_fail(\"mi_segment_is_abandoned(segment)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1167, __func__));\n  bool has_page = 0;\n  const mi_slice_t *end;\n  mi_slice_t *slice = mi_slices_start_iterate(segment, &end);\n  unsigned int slice_idx = 0;\n  while ((&slice[slice_idx]) < end)\n  {\n    (slice->slice_count > 0) ? ((void) 0) : (_mi_assert_fail(\"slice->slice_count > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1174, __func__));\n    (slice->slice_offset == 0) ? ((void) 0) : (_mi_assert_fail(\"slice->slice_offset == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1175, __func__));\n    if (mi_slice_is_used(slice))\n    {\n      mi_page_t * const page = mi_slice_to_page(slice);\n      _mi_page_free_collect(page, 0);\n      if (mi_page_all_free(page))\n      {\n        ((page->next == 0) && (page->prev == 0)) ? ((void) 0) : (_mi_assert_fail(\"page->next == NULL && page->prev==NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1182, __func__));\n        _mi_stat_decrease(&tld->stats->pages_abandoned, 1);\n        segment->abandoned -= 1;\n        slice_idx = mi_segment_page_clear(page, tld);\n        (!mi_slice_is_used(slice)) ? ((void) 0) : (_mi_assert_fail(\"!mi_slice_is_used(slice)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1186, __func__));\n        if (slice->slice_count >= slices_needed)\n        {\n          has_page = 1;\n        }\n      }\n      else\n        if ((mi_page_block_size(page) == block_size) && mi_page_has_any_available(page))\n      {\n        has_page = 1;\n      }\n    }\n    else\n    {\n      if (slice->slice_count >= slices_needed)\n      {\n        has_page = 1;\n      }\n    }\n    slice_idx = slice_idx + slice_idx->slice_count;\n  }\n\n  return has_page;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_page_free_collect",
                "_mi_stat_decrease",
                "mi_page_all_free",
                "mi_page_block_size",
                "mi_page_has_any_available",
                "mi_segment_is_abandoned",
                "mi_segment_page_clear",
                "mi_slice_is_used",
                "mi_slice_to_page",
                "mi_slices_start_iterate"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slices_needed",
                        "type": "size_t",
                        "definition": [
                            "size_t slices_needed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_size",
                        "type": "size_t",
                        "definition": [
                            "size_t block_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "has_page",
                        "type": "bool",
                        "definition": [
                            "bool has_page = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "const mi_slice_t *",
                        "definition": [
                            "const mi_slice_t *end"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *slice = mi_slices_start_iterate(segment, &end)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int slice_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t * const",
                        "definition": [
                            "mi_page_t * const page = mi_slice_to_page(slice)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_reclaim",
            "header": "",
            "params": [
                "mi_segment_t *segment",
                "mi_heap_t *heap",
                "size_t requested_block_size",
                "bool *right_page_reclaimed",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static mi_segment_t *mi_segment_reclaim(mi_segment_t *segment, mi_heap_t *heap, size_t requested_block_size, bool *right_page_reclaimed, mi_segments_tld_t *tld)\n{\n  if (right_page_reclaimed != 0)\n  {\n    *right_page_reclaimed = 0;\n  }\n  ((atomic_load_explicit(&segment->thread_id, memory_order_relaxed) == 0) || (atomic_load_explicit(&segment->thread_id, memory_order_relaxed) == _mi_thread_id())) ? ((void) 0) : (_mi_assert_fail(\"mi_atomic_load_relaxed(&segment->thread_id) == 0 || mi_atomic_load_relaxed(&segment->thread_id) == _mi_thread_id()\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1212, __func__));\n  (segment->subproc == heap->tld->segments.subproc) ? ((void) 0) : (_mi_assert_fail(\"segment->subproc == heap->tld->segments.subproc\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1213, __func__));\n  atomic_store_explicit(&segment->thread_id, _mi_thread_id(), memory_order_release);\n  segment->abandoned_visits = 0;\n  segment->was_reclaimed = 1;\n  tld->reclaim_count += 1;\n  mi_segments_track_size((long) mi_segment_size(segment), tld);\n  (segment->next == 0) ? ((void) 0) : (_mi_assert_fail(\"segment->next == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1219, __func__));\n  _mi_stat_decrease(&tld->stats->segments_abandoned, 1);\n  const mi_slice_t *end;\n  mi_slice_t *slice = mi_slices_start_iterate(segment, &end);\n  unsigned int slice_idx = 0;\n  while ((&slice[slice_idx]) < end)\n  {\n    helper_mi_segment_reclaim_1(&slice_idx, segment, heap, requested_block_size, right_page_reclaimed, tld, slice);\n  }\n\n  (segment->abandoned == 0) ? ((void) 0) : (_mi_assert_fail(\"segment->abandoned == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1267, __func__));\n  ;\n  if (segment->used == 0)\n  {\n    ((right_page_reclaimed == 0) || (!(*right_page_reclaimed))) ? ((void) 0) : (_mi_assert_fail(\"right_page_reclaimed == NULL || !(*right_page_reclaimed)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1270, __func__));\n    mi_segment_free(segment, 0, tld);\n    return 0;\n  }\n  else\n  {\n    return segment;\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_stat_decrease",
                "_mi_thread_id",
                "atomic_load_explicit",
                "atomic_store_explicit",
                "helper_mi_segment_reclaim_1",
                "mi_segment_free",
                "mi_segment_size",
                "mi_segments_track_size",
                "mi_slices_start_iterate"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "requested_block_size",
                        "type": "size_t",
                        "definition": [
                            "size_t requested_block_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "right_page_reclaimed",
                        "type": "bool *",
                        "definition": [
                            "bool *right_page_reclaimed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "const mi_slice_t *",
                        "definition": [
                            "const mi_slice_t *end"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *slice = mi_slices_start_iterate(segment, &end)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int slice_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "segment_count_is_within_target",
            "header": "",
            "params": [
                "mi_segments_tld_t *tld",
                "size_t *ptarget"
            ],
            "definition": "static bool segment_count_is_within_target(mi_segments_tld_t *tld, size_t *ptarget)\n{\n  const size_t target = (size_t) mi_option_get_clamp(mi_option_target_segments_per_thread, 0, 1024);\n  if (ptarget != 0)\n  {\n    *ptarget = target;\n  }\n  return (target == 0) || (tld->count < target);\n}\n\n",
            "calle": [
                "mi_option_get_clamp"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ptarget",
                        "type": "size_t *",
                        "definition": [
                            "size_t *ptarget"
                        ]
                    },
                    {
                        "path": null,
                        "name": "target",
                        "type": "const size_t",
                        "definition": [
                            "const size_t target = (size_t) mi_option_get_clamp(mi_option_target_segments_per_thread, 0, 1024)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_get_reclaim_tries",
            "header": "",
            "params": [
                "mi_segments_tld_t *tld"
            ],
            "definition": "static long mi_segment_get_reclaim_tries(mi_segments_tld_t *tld)\n{\n  const size_t perc = (size_t) mi_option_get_clamp(mi_option_max_segment_reclaim, 0, 100);\n  if (perc <= 0)\n  {\n    return 0;\n  }\n  const size_t total_count = atomic_load_explicit(&tld->subproc->abandoned_count, memory_order_relaxed);\n  if (total_count == 0)\n  {\n    return 0;\n  }\n  const size_t relative_count = (total_count > 10000) ? ((total_count / 100) * perc) : ((total_count * perc) / 100);\n  long max_tries = (long) ((relative_count <= 1) ? (1) : ((relative_count > 1024) ? (1024) : (relative_count)));\n  if ((max_tries < 8) && (total_count > 8))\n  {\n    max_tries = 8;\n  }\n  return max_tries;\n}\n\n",
            "calle": [
                "atomic_load_explicit",
                "mi_option_get_clamp"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "perc",
                        "type": "const size_t",
                        "definition": [
                            "const size_t perc = (size_t) mi_option_get_clamp(mi_option_max_segment_reclaim, 0, 100)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "total_count",
                        "type": "const size_t",
                        "definition": [
                            "const size_t total_count = atomic_load_explicit(&tld->subproc->abandoned_count, memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "relative_count",
                        "type": "const size_t",
                        "definition": [
                            "const size_t relative_count = (total_count > 10000) ? ((total_count / 100) * perc) : ((total_count * perc) / 100)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max_tries",
                        "type": "long",
                        "definition": [
                            "long max_tries = (long) ((relative_count <= 1) ? (1) : ((relative_count > 1024) ? (1024) : (relative_count)))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_try_reclaim",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "size_t needed_slices",
                "size_t block_size",
                "bool *reclaimed",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static mi_segment_t *mi_segment_try_reclaim(mi_heap_t *heap, size_t needed_slices, size_t block_size, bool *reclaimed, mi_segments_tld_t *tld)\n{\n  *reclaimed = 0;\n  long max_tries = mi_segment_get_reclaim_tries(tld);\n  if (max_tries <= 0)\n  {\n    return 0;\n  }\n  mi_segment_t *result = 0;\n  unsigned int result_idx = 0;\n  mi_segment_t *segment = 0;\n  unsigned int segment_idx = 0;\n  mi_arena_field_cursor_t current;\n  _mi_arena_field_cursor_init(heap, tld->subproc, 0, &current);\n  while ((segment_count_is_within_target(tld, 0) && ((max_tries--) > 0)) && ((segment_idx = _mi_arena_segment_clear_abandoned_next(&current)) != 0))\n  {\n    (segment->subproc == heap->tld->segments.subproc) ? ((void) 0) : (_mi_assert_fail(\"segment->subproc == heap->tld->segments.subproc\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1343, __func__));\n    segment->abandoned_visits += 1;\n    bool is_suitable = _mi_heap_memid_is_suitable(heap, segment->memid);\n    bool has_page = mi_segment_check_free(segment, needed_slices, block_size, tld);\n    if (segment->used == 0)\n    {\n      mi_segment_reclaim(segment, heap, 0, 0, tld);\n    }\n    else\n      if (has_page && is_suitable)\n    {\n      result_idx = mi_segment_reclaim(segment, heap, block_size, reclaimed, tld);\n      break;\n    }\n    else\n      if ((segment->abandoned_visits > 3) && is_suitable)\n    {\n      mi_segment_reclaim(segment, heap, 0, 0, tld);\n    }\n    else\n    {\n      max_tries += 1;\n      mi_segment_try_purge(segment, 0);\n      _mi_arena_segment_mark_abandoned(segment);\n    }\n  }\n\n  _mi_arena_field_cursor_done(&current);\n  return result;\n}\n\n",
            "calle": [
                "_mi_arena_field_cursor_done",
                "_mi_arena_field_cursor_init",
                "_mi_arena_segment_clear_abandoned_next",
                "_mi_arena_segment_mark_abandoned",
                "_mi_assert_fail",
                "_mi_heap_memid_is_suitable",
                "mi_segment_check_free",
                "mi_segment_get_reclaim_tries",
                "mi_segment_reclaim",
                "mi_segment_try_purge",
                "segment_count_is_within_target"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "needed_slices",
                        "type": "size_t",
                        "definition": [
                            "size_t needed_slices"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_size",
                        "type": "size_t",
                        "definition": [
                            "size_t block_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "reclaimed",
                        "type": "bool *",
                        "definition": [
                            "bool *reclaimed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max_tries",
                        "type": "long",
                        "definition": [
                            "long max_tries = mi_segment_get_reclaim_tries(tld)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "result",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *result = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "result_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int result_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int segment_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current",
                        "type": "mi_arena_field_cursor_t",
                        "definition": [
                            "mi_arena_field_cursor_t current"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_suitable",
                        "type": "bool",
                        "definition": [
                            "bool is_suitable = _mi_heap_memid_is_suitable(heap, segment->memid)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "has_page",
                        "type": "bool",
                        "definition": [
                            "bool has_page = mi_segment_check_free(segment, needed_slices, block_size, tld)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_force_abandon",
            "header": "",
            "params": [
                "mi_segment_t *segment",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static void mi_segment_force_abandon(mi_segment_t *segment, mi_segments_tld_t *tld)\n{\n  (!mi_segment_is_abandoned(segment)) ? ((void) 0) : (_mi_assert_fail(\"!mi_segment_is_abandoned(segment)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1411, __func__));\n  (!segment->dont_free) ? ((void) 0) : (_mi_assert_fail(\"!segment->dont_free\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1412, __func__));\n  segment->dont_free = 1;\n  const mi_slice_t *end;\n  mi_slice_t *slice = mi_slices_start_iterate(segment, &end);\n  unsigned int slice_idx = 0;\n  while ((&slice[slice_idx]) < end)\n  {\n    (slice->slice_count > 0) ? ((void) 0) : (_mi_assert_fail(\"slice->slice_count > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1421, __func__));\n    (slice->slice_offset == 0) ? ((void) 0) : (_mi_assert_fail(\"slice->slice_offset == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1422, __func__));\n    if (mi_slice_is_used(slice))\n    {\n      mi_page_t * const page = mi_slice_to_page(slice);\n      _mi_page_free_collect(page, 0);\n      {\n        (segment->used > 0) ? ((void) 0) : (_mi_assert_fail(\"segment->used > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1429, __func__));\n        if (segment->used == (segment->abandoned + 1))\n        {\n          segment->dont_free = 0;\n          _mi_page_force_abandon(page);\n          return;\n        }\n        else\n        {\n          _mi_page_force_abandon(page);\n          slice_idx = mi_slice_first(slice_idx);\n        }\n      }\n    }\n    slice_idx = slice_idx + slice_idx->slice_count;\n  }\n\n  segment->dont_free = 0;\n  (segment->used == segment->abandoned) ? ((void) 0) : (_mi_assert_fail(\"segment->used == segment->abandoned\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1448, __func__));\n  (segment->used == 0) ? ((void) 0) : (_mi_assert_fail(\"segment->used == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1449, __func__));\n  if (segment->used == 0)\n  {\n    mi_segment_free(segment, 0, tld);\n  }\n  else\n  {\n    mi_segment_try_purge(segment, 0);\n  }\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_page_force_abandon",
                "_mi_page_free_collect",
                "mi_segment_free",
                "mi_segment_is_abandoned",
                "mi_segment_try_purge",
                "mi_slice_first",
                "mi_slice_is_used",
                "mi_slice_to_page",
                "mi_slices_start_iterate"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "const mi_slice_t *",
                        "definition": [
                            "const mi_slice_t *end"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice",
                        "type": "mi_slice_t *",
                        "definition": [
                            "mi_slice_t *slice = mi_slices_start_iterate(segment, &end)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int slice_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t * const",
                        "definition": [
                            "mi_page_t * const page = mi_slice_to_page(slice)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segments_try_abandon_to_target",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "size_t target",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static void mi_segments_try_abandon_to_target(mi_heap_t *heap, size_t target, mi_segments_tld_t *tld)\n{\n  if (target <= 1)\n  {\n    return;\n  }\n  const size_t min_target = (target > 4) ? ((target * 3) / 4) : (target);\n  for (int i = 0; (i < 64) && (tld->count >= min_target); i += 1)\n  {\n    mi_page_t *page = heap->pages[73U + 1].first;\n    unsigned int page_idx = 0;\n    while (((&page[page_idx]) != 0) && (mi_page_block_size(page) > ((1UL << (9 + (13 + 3))) / 2)))\n    {\n      page_idx = page_idx->next;\n    }\n\n    if ((&page[page_idx]) == 0)\n    {\n      break;\n    }\n    mi_segment_t *segment = _mi_page_segment(page);\n    mi_segment_force_abandon(segment, tld);\n    ((&page[page_idx]) != heap->pages[73U + 1].first) ? ((void) 0) : (_mi_assert_fail(\"page != heap->pages[MI_BIN_FULL].first\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1477, __func__));\n  }\n\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_page_segment",
                "mi_page_block_size",
                "mi_segment_force_abandon"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "target",
                        "type": "size_t",
                        "definition": [
                            "size_t target"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "min_target",
                        "type": "const size_t",
                        "definition": [
                            "const size_t min_target = (target > 4) ? ((target * 3) / 4) : (target)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "int",
                        "definition": [
                            "int i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = heap->pages[73U + 1].first"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int page_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = _mi_page_segment(page)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segments_try_abandon",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static void mi_segments_try_abandon(mi_heap_t *heap, mi_segments_tld_t *tld)\n{\n  size_t target = 0;\n  if (segment_count_is_within_target(tld, &target))\n  {\n    return;\n  }\n  mi_segments_try_abandon_to_target(heap, target, tld);\n}\n\n",
            "calle": [
                "mi_segments_try_abandon_to_target",
                "segment_count_is_within_target"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "target",
                        "type": "size_t",
                        "definition": [
                            "size_t target = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_reclaim_or_alloc",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "size_t needed_slices",
                "size_t block_size",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static mi_segment_t *mi_segment_reclaim_or_alloc(mi_heap_t *heap, size_t needed_slices, size_t block_size, mi_segments_tld_t *tld)\n{\n  (block_size <= ((1UL << (9 + (13 + 3))) / 2)) ? ((void) 0) : (_mi_assert_fail(\"block_size <= MI_LARGE_OBJ_SIZE_MAX\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1507, __func__));\n  mi_segments_try_abandon(heap, tld);\n  bool reclaimed;\n  mi_segment_t *segment = mi_segment_try_reclaim(heap, needed_slices, block_size, &reclaimed, tld);\n  if (reclaimed)\n  {\n    (segment != 0) ? ((void) 0) : (_mi_assert_fail(\"segment != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1517, __func__));\n    return 0;\n  }\n  else\n    if (segment != 0)\n  {\n    return segment;\n  }\n  return mi_segment_alloc(0, 0, heap->arena_id, tld, 0);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_segment_alloc",
                "mi_segment_try_reclaim",
                "mi_segments_try_abandon"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "needed_slices",
                        "type": "size_t",
                        "definition": [
                            "size_t needed_slices"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_size",
                        "type": "size_t",
                        "definition": [
                            "size_t block_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "reclaimed",
                        "type": "bool",
                        "definition": [
                            "bool reclaimed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = mi_segment_try_reclaim(heap, needed_slices, block_size, &reclaimed, tld)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segments_page_alloc",
            "header": "",
            "params": [
                "mi_heap_t *heap",
                "mi_page_kind_t page_kind",
                "size_t required",
                "size_t block_size",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static mi_page_t *mi_segments_page_alloc(mi_heap_t *heap, mi_page_kind_t page_kind, size_t required, size_t block_size, mi_segments_tld_t *tld)\n{\n  ((required <= ((1UL << (9 + (13 + 3))) / 2)) && (page_kind <= MI_PAGE_LARGE)) ? ((void) 0) : (_mi_assert_fail(\"required <= MI_LARGE_OBJ_SIZE_MAX && page_kind <= MI_PAGE_LARGE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1535, __func__));\n  size_t page_size = _mi_align_up(required, (required > (1UL << (3 + (13 + 3)))) ? (1UL << (3 + (13 + 3))) : (1UL << (13 + 3)));\n  size_t slices_needed = page_size / (1UL << (13 + 3));\n  ((slices_needed * (1UL << (13 + 3))) == page_size) ? ((void) 0) : (_mi_assert_fail(\"slices_needed * MI_SEGMENT_SLICE_SIZE == page_size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1540, __func__));\n  mi_page_t *page = mi_segments_page_find_and_allocate(slices_needed, heap->arena_id, tld);\n  if (page == 0)\n  {\n    if (mi_segment_reclaim_or_alloc(heap, slices_needed, block_size, tld) == 0)\n    {\n      return 0;\n    }\n    else\n    {\n      return mi_segments_page_alloc(heap, page_kind, required, block_size, tld);\n    }\n  }\n  ((page != 0) && ((page->slice_count * (1UL << (13 + 3))) == page_size)) ? ((void) 0) : (_mi_assert_fail(\"page != NULL && page->slice_count*MI_SEGMENT_SLICE_SIZE == page_size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1553, __func__));\n  (_mi_ptr_segment(page)->thread_id == _mi_thread_id()) ? ((void) 0) : (_mi_assert_fail(\"_mi_ptr_segment(page)->thread_id == _mi_thread_id()\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1554, __func__));\n  mi_segment_try_purge(_mi_ptr_segment(page), 0);\n  return page;\n}\n\n",
            "calle": [
                "_mi_align_up",
                "_mi_assert_fail",
                "_mi_ptr_segment",
                "_mi_thread_id",
                "mi_segment_reclaim_or_alloc",
                "mi_segment_try_purge",
                "mi_segments_page_alloc",
                "mi_segments_page_find_and_allocate"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_kind",
                        "type": "mi_page_kind_t",
                        "definition": [
                            "mi_page_kind_t page_kind"
                        ]
                    },
                    {
                        "path": null,
                        "name": "required",
                        "type": "size_t",
                        "definition": [
                            "size_t required"
                        ]
                    },
                    {
                        "path": null,
                        "name": "block_size",
                        "type": "size_t",
                        "definition": [
                            "size_t block_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_size",
                        "type": "size_t",
                        "definition": [
                            "size_t page_size = _mi_align_up(required, (required > (1UL << (3 + (13 + 3)))) ? (1UL << (3 + (13 + 3))) : (1UL << (13 + 3)))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slices_needed",
                        "type": "size_t",
                        "definition": [
                            "size_t slices_needed = page_size / (1UL << (13 + 3))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = mi_segments_page_find_and_allocate(slices_needed, heap->arena_id, tld)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_huge_page_alloc",
            "header": "",
            "params": [
                "size_t size",
                "size_t page_alignment",
                "mi_arena_id_t req_arena_id",
                "mi_segments_tld_t *tld"
            ],
            "definition": "static mi_page_t *mi_segment_huge_page_alloc(size_t size, size_t page_alignment, mi_arena_id_t req_arena_id, mi_segments_tld_t *tld)\n{\n  mi_page_t *page = 0;\n  mi_segment_t *segment = mi_segment_alloc(size, page_alignment, req_arena_id, tld, &page);\n  if ((segment == 0) || (page == 0))\n  {\n    return 0;\n  }\n  (segment->used == 1) ? ((void) 0) : (_mi_assert_fail(\"segment->used==1\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1570, __func__));\n  (mi_page_block_size(page) >= size) ? ((void) 0) : (_mi_assert_fail(\"mi_page_block_size(page) >= size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1571, __func__));\n  size_t psize;\n  uint8_t *start = _mi_segment_page_start(segment, page, &psize);\n  page->block_size = psize;\n  (page->is_huge) ? ((void) 0) : (_mi_assert_fail(\"page->is_huge\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1581, __func__));\n  if ((page_alignment > 0) && segment->allow_decommit)\n  {\n    uint8_t *aligned_p = (uint8_t *) _mi_align_up((uintptr_t) start, page_alignment);\n    (_mi_is_aligned(aligned_p, page_alignment)) ? ((void) 0) : (_mi_assert_fail(\"_mi_is_aligned(aligned_p, page_alignment)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1586, __func__));\n    ((psize - (aligned_p - start)) >= size) ? ((void) 0) : (_mi_assert_fail(\"psize - (aligned_p - start) >= size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1587, __func__));\n    uint8_t *decommit_start = start + (sizeof(mi_block_t));\n    ptrdiff_t decommit_size = aligned_p - decommit_start;\n    _mi_os_reset(decommit_start, decommit_size);\n  }\n  return page;\n}\n\n",
            "calle": [
                "_mi_align_up",
                "_mi_assert_fail",
                "_mi_is_aligned",
                "_mi_os_reset",
                "_mi_segment_page_start",
                "mi_page_block_size",
                "mi_segment_alloc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t page_alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "req_arena_id",
                        "type": "mi_arena_id_t",
                        "definition": [
                            "mi_arena_id_t req_arena_id"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t *",
                        "definition": [
                            "mi_segments_tld_t *tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = mi_segment_alloc(size, page_alignment, req_arena_id, tld, &page)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "psize",
                        "type": "size_t",
                        "definition": [
                            "size_t psize"
                        ]
                    },
                    {
                        "path": null,
                        "name": "start",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *start = _mi_segment_page_start(segment, page, &psize)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "aligned_p",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *aligned_p = (uint8_t *) _mi_align_up((uintptr_t) start, page_alignment)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "decommit_start",
                        "type": "uint8_t *",
                        "definition": [
                            "uint8_t *decommit_start = start + (sizeof(mi_block_t))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "decommit_size",
                        "type": "ptrdiff_t",
                        "definition": [
                            "ptrdiff_t decommit_size = aligned_p - decommit_start"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_visit_page",
            "header": "",
            "params": [
                "mi_page_t *page",
                "bool visit_blocks",
                "mi_block_visit_fun *visitor",
                "void *arg"
            ],
            "definition": "static bool mi_segment_visit_page(mi_page_t *page, bool visit_blocks, mi_block_visit_fun *visitor, void *arg)\n{\n  mi_heap_area_t area;\n  _mi_heap_area_init(&area, page);\n  if (!visitor(0, &area, 0, area.block_size, arg))\n  {\n    return 0;\n  }\n  if (visit_blocks)\n  {\n    return _mi_heap_area_visit_blocks(&area, page, visitor, arg);\n  }\n  else\n  {\n    return 1;\n  }\n}\n\n",
            "calle": [
                "_mi_heap_area_init",
                "_mi_heap_area_visit_blocks",
                "visitor"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page"
                        ]
                    },
                    {
                        "path": null,
                        "name": "visit_blocks",
                        "type": "bool",
                        "definition": [
                            "bool visit_blocks"
                        ]
                    },
                    {
                        "path": null,
                        "name": "visitor",
                        "type": "mi_block_visit_fun *",
                        "definition": [
                            "mi_block_visit_fun *visitor"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "area",
                        "type": "mi_heap_area_t",
                        "definition": [
                            "mi_heap_area_t area"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper__mi_commit_mask_next_run_1",
            "header": "",
            "params": [
                "size_t * const i_ref",
                "size_t * const ofs_ref",
                "size_t * const mask_ref",
                "const mi_commit_mask_t * const cm",
                "size_t * const idx"
            ],
            "definition": "size_t helper__mi_commit_mask_next_run_1(size_t * const i_ref, size_t * const ofs_ref, size_t * const mask_ref, const mi_commit_mask_t * const cm, size_t * const idx)\n{\n  size_t i = *i_ref;\n  size_t ofs = *ofs_ref;\n  size_t mask = *mask_ref;\n  size_t count = 0;\n  *idx = (i * ((1 << 3) * 8)) + ofs;\n  do\n  {\n    ((ofs < ((1 << 3) * 8)) && ((mask & 1) == 1)) ? ((void) 0) : (_mi_assert_fail(\"ofs < MI_COMMIT_MASK_FIELD_BITS && (mask&1) == 1\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 133, __func__));\n    do\n    {\n      count += 1;\n      mask >>= 1;\n    }\n    while ((mask & 1) == 1);\n    if ((((*idx) + count) % ((1 << 3) * 8)) == 0)\n    {\n      i += 1;\n      if (i >= (((1UL << (9 + (13 + 3))) / (1UL << (13 + 3))) / ((1 << 3) * 8)))\n      {\n        break;\n      }\n      mask = cm->mask[i];\n      ofs = 0;\n    }\n  }\n  while ((mask & 1) == 1);\n  (count > 0) ? ((void) 0) : (_mi_assert_fail(\"count > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 145, __func__));\n  return count;\n  *i_ref = i;\n  *ofs_ref = ofs;\n  *mask_ref = mask;\n}\n\n",
            "calle": [
                "_mi_assert_fail"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "i_ref",
                        "type": "size_t * const",
                        "definition": [
                            "size_t * const i_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ofs_ref",
                        "type": "size_t * const",
                        "definition": [
                            "size_t * const ofs_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask_ref",
                        "type": "size_t * const",
                        "definition": [
                            "size_t * const mask_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "cm",
                        "type": "const mi_commit_mask_t * const",
                        "definition": [
                            "const mi_commit_mask_t * const cm"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t * const",
                        "definition": [
                            "size_t * const idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = *i_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ofs",
                        "type": "size_t",
                        "definition": [
                            "size_t ofs = *ofs_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "size_t",
                        "definition": [
                            "size_t mask = *mask_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "helper_mi_segment_reclaim_1",
            "header": "",
            "params": [
                "unsigned int * const slice_idx_ref",
                "mi_segment_t * const segment",
                "mi_heap_t * const heap",
                "size_t requested_block_size",
                "bool * const right_page_reclaimed",
                "mi_segments_tld_t * const tld",
                "mi_slice_t * const slice"
            ],
            "definition": "void helper_mi_segment_reclaim_1(unsigned int * const slice_idx_ref, mi_segment_t * const segment, mi_heap_t * const heap, size_t requested_block_size, bool * const right_page_reclaimed, mi_segments_tld_t * const tld, mi_slice_t * const slice)\n{\n  unsigned int slice_idx = *slice_idx_ref;\n  (slice->slice_count > 0) ? ((void) 0) : (_mi_assert_fail(\"slice->slice_count > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1226, __func__));\n  (slice->slice_offset == 0) ? ((void) 0) : (_mi_assert_fail(\"slice->slice_offset == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1227, __func__));\n  if (mi_slice_is_used(slice))\n  {\n    mi_page_t *page = mi_slice_to_page(slice);\n    (page->is_committed) ? ((void) 0) : (_mi_assert_fail(\"page->is_committed\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1231, __func__));\n    (mi_page_thread_free_flag(page) == MI_NEVER_DELAYED_FREE) ? ((void) 0) : (_mi_assert_fail(\"mi_page_thread_free_flag(page)==MI_NEVER_DELAYED_FREE\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1232, __func__));\n    (mi_page_heap(page) == 0) ? ((void) 0) : (_mi_assert_fail(\"mi_page_heap(page) == NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1233, __func__));\n    ((page->next == 0) && (page->prev == 0)) ? ((void) 0) : (_mi_assert_fail(\"page->next == NULL && page->prev==NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1234, __func__));\n    _mi_stat_decrease(&tld->stats->pages_abandoned, 1);\n    segment->abandoned -= 1;\n    mi_heap_t *target_heap = _mi_heap_by_tag(heap, page->heap_tag);\n    unsigned int target_heap_idx = 0;\n    if ((&target_heap[target_heap_idx]) == 0)\n    {\n      target_heap_idx = heap;\n      _mi_error_message(14, \"page with tag %u cannot be reclaimed by a heap with the same tag (using heap tag %u instead)\\n\", page->heap_tag, heap->tag);\n    }\n    mi_page_set_heap(page, target_heap);\n    _mi_page_use_delayed_free(page, MI_USE_DELAYED_FREE, 1);\n    _mi_page_free_collect(page, 0);\n    if (mi_page_all_free(page))\n    {\n      slice_idx = mi_segment_page_clear(page, tld);\n    }\n    else\n    {\n      _mi_page_reclaim(target_heap, page);\n      if (((requested_block_size == mi_page_block_size(page)) && mi_page_has_any_available(page)) && (heap == (&target_heap[target_heap_idx])))\n      {\n        if (right_page_reclaimed != 0)\n        {\n          *right_page_reclaimed = 1;\n        }\n      }\n    }\n  }\n  else\n  {\n    slice_idx = mi_segment_span_free_coalesce(slice_idx, tld);\n  }\n  ((slice->slice_count > 0) && (slice->slice_offset == 0)) ? ((void) 0) : (_mi_assert_fail(\"slice->slice_count>0 && slice->slice_offset==0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment.c\", 1263, __func__));\n  slice_idx = slice_idx + slice_idx->slice_count;\n  *slice_idx_ref = slice_idx;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_error_message",
                "_mi_heap_by_tag",
                "_mi_page_free_collect",
                "_mi_page_reclaim",
                "_mi_page_use_delayed_free",
                "_mi_stat_decrease",
                "mi_page_all_free",
                "mi_page_block_size",
                "mi_page_has_any_available",
                "mi_page_heap",
                "mi_page_set_heap",
                "mi_page_thread_free_flag",
                "mi_segment_page_clear",
                "mi_segment_span_free_coalesce",
                "mi_slice_is_used",
                "mi_slice_to_page"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "slice_idx_ref",
                        "type": "unsigned int * const",
                        "definition": [
                            "unsigned int * const slice_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t * const",
                        "definition": [
                            "mi_segment_t * const segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t * const",
                        "definition": [
                            "mi_heap_t * const heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "requested_block_size",
                        "type": "size_t",
                        "definition": [
                            "size_t requested_block_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "right_page_reclaimed",
                        "type": "bool * const",
                        "definition": [
                            "bool * const right_page_reclaimed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_segments_tld_t * const",
                        "definition": [
                            "mi_segments_tld_t * const tld"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice",
                        "type": "mi_slice_t * const",
                        "definition": [
                            "mi_slice_t * const slice"
                        ]
                    },
                    {
                        "path": null,
                        "name": "slice_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int slice_idx = *slice_idx_ref"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page",
                        "type": "mi_page_t *",
                        "definition": [
                            "mi_page_t *page = mi_slice_to_page(slice)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "target_heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *target_heap = _mi_heap_by_tag(heap, page->heap_tag)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "target_heap_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int target_heap_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_is_in_heap_region",
            "header": "bool mi_is_in_heap_region(const void *p)",
            "params": [
                "const void *p"
            ],
            "definition": "bool mi_is_in_heap_region(const void *p)\n{\n  return mi_is_valid_pointer(p);\n}\n\n",
            "calle": [
                "mi_is_valid_pointer"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_segment_map_allocated_at",
            "header": "void _mi_segment_map_allocated_at(const mi_segment_t *segment)",
            "params": [
                "const mi_segment_t *segment"
            ],
            "definition": "void _mi_segment_map_allocated_at(const mi_segment_t *segment)\n{\n  if (segment->memid.memkind == MI_MEM_ARENA)\n  {\n    return;\n  }\n  size_t index;\n  size_t bitidx;\n  mi_segmap_part_t *part = mi_segment_map_index_of(segment, 1, &index, &bitidx);\n  if (part == 0)\n  {\n    return;\n  }\n  uintptr_t mask = atomic_load_explicit(&part->map[index], memory_order_relaxed);\n  uintptr_t newmask;\n  do\n  {\n    newmask = mask | (((uintptr_t) 1) << bitidx);\n  }\n  while (!atomic_compare_exchange_weak_explicit(&part->map[index], &mask, newmask, memory_order_release, memory_order_relaxed));\n}\n\n",
            "calle": [
                "atomic_compare_exchange_weak_explicit",
                "atomic_load_explicit",
                "mi_segment_map_index_of"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "const mi_segment_t *",
                        "definition": [
                            "const mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "index",
                        "type": "size_t",
                        "definition": [
                            "size_t index"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitidx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "part",
                        "type": "mi_segmap_part_t *",
                        "definition": [
                            "mi_segmap_part_t *part = mi_segment_map_index_of(segment, 1, &index, &bitidx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t mask = atomic_load_explicit(&part->map[index], memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newmask",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t newmask"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_segment_map_freed_at",
            "header": "void _mi_segment_map_freed_at(const mi_segment_t *segment)",
            "params": [
                "const mi_segment_t *segment"
            ],
            "definition": "void _mi_segment_map_freed_at(const mi_segment_t *segment)\n{\n  if (segment->memid.memkind == MI_MEM_ARENA)\n  {\n    return;\n  }\n  size_t index;\n  size_t bitidx;\n  mi_segmap_part_t *part = mi_segment_map_index_of(segment, 0, &index, &bitidx);\n  if (part == 0)\n  {\n    return;\n  }\n  uintptr_t mask = atomic_load_explicit(&part->map[index], memory_order_relaxed);\n  uintptr_t newmask;\n  do\n  {\n    newmask = mask & (~(((uintptr_t) 1) << bitidx));\n  }\n  while (!atomic_compare_exchange_weak_explicit(&part->map[index], &mask, newmask, memory_order_release, memory_order_relaxed));\n}\n\n",
            "calle": [
                "atomic_compare_exchange_weak_explicit",
                "atomic_load_explicit",
                "mi_segment_map_index_of"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "const mi_segment_t *",
                        "definition": [
                            "const mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "index",
                        "type": "size_t",
                        "definition": [
                            "size_t index"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitidx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "part",
                        "type": "mi_segmap_part_t *",
                        "definition": [
                            "mi_segmap_part_t *part = mi_segment_map_index_of(segment, 0, &index, &bitidx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t mask = atomic_load_explicit(&part->map[index], memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newmask",
                        "type": "uintptr_t",
                        "definition": [
                            "uintptr_t newmask"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_segment_map_unsafe_destroy",
            "header": "void _mi_segment_map_unsafe_destroy(void)",
            "params": [
                "void"
            ],
            "definition": "void _mi_segment_map_unsafe_destroy(void)\n{\n  for (size_t i = 0; i < ((((48 * 1024ULL) * ((1024UL * 1024UL) * 1024UL)) / ((8 * (((1 << 3) * 1024UL) - 128)) * (1UL << (9 + (13 + 3))))) + 1); i += 1)\n  {\n    mi_segmap_part_t *part = atomic_exchange_explicit(&mi_segment_map[i], 0, memory_order_relaxed);\n    if (part != 0)\n    {\n      _mi_os_free(part, sizeof(mi_segmap_part_t), part->memid);\n    }\n  }\n\n}\n\n",
            "calle": [
                "_mi_os_free",
                "atomic_exchange_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "part",
                        "type": "mi_segmap_part_t *",
                        "definition": [
                            "mi_segmap_part_t *part = atomic_exchange_explicit(&mi_segment_map[i], 0, memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_segment_map",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_segment_map_index_of",
            "header": "",
            "params": [
                "const mi_segment_t *segment",
                "bool create_on_demand",
                "size_t *idx",
                "size_t *bitidx"
            ],
            "definition": "static mi_segmap_part_t *mi_segment_map_index_of(const mi_segment_t *segment, bool create_on_demand, size_t *idx, size_t *bitidx)\n{\n  (_mi_ptr_segment(segment + 1) == segment) ? ((void) 0) : (_mi_assert_fail(\"_mi_ptr_segment(segment + 1) == segment\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment-map.c\", 52, __func__));\n  *idx = 0;\n  *bitidx = 0;\n  if (((uintptr_t) segment) >= ((48 * 1024ULL) * ((1024UL * 1024UL) * 1024UL)))\n  {\n    return 0;\n  }\n  const uintptr_t segindex = ((uintptr_t) segment) / ((8 * (((1 << 3) * 1024UL) - 128)) * (1UL << (9 + (13 + 3))));\n  if (segindex >= ((((48 * 1024ULL) * ((1024UL * 1024UL) * 1024UL)) / ((8 * (((1 << 3) * 1024UL) - 128)) * (1UL << (9 + (13 + 3))))) + 1))\n  {\n    return 0;\n  }\n  mi_segmap_part_t *part = atomic_load_explicit(&mi_segment_map[segindex], memory_order_relaxed);\n  unsigned int part_idx = 0;\n  if (__builtin_expect(!(!((&part[part_idx]) == 0)), 0))\n  {\n    if (!create_on_demand)\n    {\n      return 0;\n    }\n    mi_memid_t memid;\n    part_idx = (mi_segmap_part_t *) _mi_os_zalloc(sizeof(mi_segmap_part_t), &memid);\n    if ((&part[part_idx]) == 0)\n    {\n      return 0;\n    }\n    part->memid = memid;\n    mi_segmap_part_t *expected = 0;\n    if (!atomic_compare_exchange_strong_explicit(&mi_segment_map[segindex], &expected, part, memory_order_release, memory_order_relaxed))\n    {\n      _mi_os_free(part, sizeof(mi_segmap_part_t), memid);\n      part_idx = expected;\n      if ((&part[part_idx]) == 0)\n      {\n        return 0;\n      }\n    }\n  }\n  ((&part[part_idx]) != 0) ? ((void) 0) : (_mi_assert_fail(\"part != NULL\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment-map.c\", 74, __func__));\n  const uintptr_t offset = ((uintptr_t) segment) % ((8 * (((1 << 3) * 1024UL) - 128)) * (1UL << (9 + (13 + 3))));\n  const uintptr_t bitofs = offset / (1UL << (9 + (13 + 3)));\n  *idx = bitofs / ((1 << 3) * 8);\n  *bitidx = bitofs % ((1 << 3) * 8);\n  return part;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_os_free",
                "_mi_os_zalloc",
                "_mi_ptr_segment",
                "atomic_compare_exchange_strong_explicit",
                "atomic_load_explicit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "segment",
                        "type": "const mi_segment_t *",
                        "definition": [
                            "const mi_segment_t *segment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "create_on_demand",
                        "type": "bool",
                        "definition": [
                            "bool create_on_demand"
                        ]
                    },
                    {
                        "path": null,
                        "name": "idx",
                        "type": "size_t *",
                        "definition": [
                            "size_t *idx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "size_t *",
                        "definition": [
                            "size_t *bitidx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segindex",
                        "type": "const uintptr_t",
                        "definition": [
                            "const uintptr_t segindex = ((uintptr_t) segment) / ((8 * (((1 << 3) * 1024UL) - 128)) * (1UL << (9 + (13 + 3))))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "part",
                        "type": "mi_segmap_part_t *",
                        "definition": [
                            "mi_segmap_part_t *part = atomic_load_explicit(&mi_segment_map[segindex], memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "part_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int part_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "memid",
                        "type": "mi_memid_t",
                        "definition": [
                            "mi_memid_t memid"
                        ]
                    },
                    {
                        "path": null,
                        "name": "expected",
                        "type": "mi_segmap_part_t *",
                        "definition": [
                            "mi_segmap_part_t *expected = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "offset",
                        "type": "const uintptr_t",
                        "definition": [
                            "const uintptr_t offset = ((uintptr_t) segment) % ((8 * (((1 << 3) * 1024UL) - 128)) * (1UL << (9 + (13 + 3))))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitofs",
                        "type": "const uintptr_t",
                        "definition": [
                            "const uintptr_t bitofs = offset / (1UL << (9 + (13 + 3)))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_segment_map",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_segment_of",
            "header": "",
            "params": [
                "const void *p"
            ],
            "definition": "static mi_segment_t *_mi_segment_of(const void *p)\n{\n  if (p == 0)\n  {\n    return 0;\n  }\n  mi_segment_t *segment = _mi_ptr_segment(p);\n  size_t index;\n  size_t bitidx;\n  mi_segmap_part_t *part = mi_segment_map_index_of(segment, 0, &index, &bitidx);\n  if (part == 0)\n  {\n    return 0;\n  }\n  const uintptr_t mask = atomic_load_explicit(&part->map[index], memory_order_relaxed);\n  if (__builtin_expect(!(!((mask & (((uintptr_t) 1) << bitidx)) != 0)), 1))\n  {\n    bool cookie_ok = _mi_ptr_cookie(segment) == segment->cookie;\n    (cookie_ok) ? ((void) 0) : (_mi_assert_fail(\"cookie_ok\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/segment-map.c\", 119, __func__));\n    (void) cookie_ok;\n    return segment;\n  }\n  return 0;\n}\n\n",
            "calle": [
                "__builtin_expect",
                "_mi_assert_fail",
                "_mi_ptr_cookie",
                "_mi_ptr_segment",
                "atomic_load_explicit",
                "mi_segment_map_index_of"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    },
                    {
                        "path": null,
                        "name": "segment",
                        "type": "mi_segment_t *",
                        "definition": [
                            "mi_segment_t *segment = _mi_ptr_segment(p)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "index",
                        "type": "size_t",
                        "definition": [
                            "size_t index"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bitidx",
                        "type": "size_t",
                        "definition": [
                            "size_t bitidx"
                        ]
                    },
                    {
                        "path": null,
                        "name": "part",
                        "type": "mi_segmap_part_t *",
                        "definition": [
                            "mi_segmap_part_t *part = mi_segment_map_index_of(segment, 0, &index, &bitidx)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mask",
                        "type": "const uintptr_t",
                        "definition": [
                            "const uintptr_t mask = atomic_load_explicit(&part->map[index], memory_order_relaxed)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "cookie_ok",
                        "type": "bool",
                        "definition": [
                            "bool cookie_ok = _mi_ptr_cookie(segment) == segment->cookie"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_is_valid_pointer",
            "header": "",
            "params": [
                "const void *p"
            ],
            "definition": "static bool mi_is_valid_pointer(const void *p)\n{\n  return _mi_arena_contains(p) || (_mi_segment_of(p) != 0);\n}\n\n",
            "calle": [
                "_mi_arena_contains",
                "_mi_segment_of"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "p",
                        "type": "const void *",
                        "definition": [
                            "const void *p"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stats_reset",
            "header": "void mi_stats_reset(void)",
            "params": [
                "void"
            ],
            "definition": "void mi_stats_reset(void)\n{\n  mi_stats_t *stats = mi_stats_get_default();\n  if (stats != (&_mi_stats_main))\n  {\n    memset(stats, 0, sizeof(mi_stats_t));\n  }\n  memset(&_mi_stats_main, 0, sizeof(mi_stats_t));\n  if (mi_process_start == 0)\n  {\n    mi_process_start = _mi_clock_start();\n  }\n  ;\n}\n\n",
            "calle": [
                "_mi_clock_start",
                "memset",
                "mi_stats_get_default"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "stats",
                        "type": "mi_stats_t *",
                        "definition": [
                            "mi_stats_t *stats = mi_stats_get_default()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "mi_process_start",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stats_merge",
            "header": "void mi_stats_merge(void)",
            "params": [
                "void"
            ],
            "definition": "void mi_stats_merge(void)\n{\n  mi_stats_merge_from(mi_stats_get_default());\n}\n\n",
            "calle": [
                "mi_stats_get_default",
                "mi_stats_merge_from"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stats_print",
            "header": "void mi_stats_print(void *out)",
            "params": [
                "void *out"
            ],
            "definition": "void mi_stats_print(void *out)\n{\n  mi_stats_print_out((mi_output_fun *) out, 0);\n}\n\n",
            "calle": [
                "mi_stats_print_out"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "out",
                        "type": "void *",
                        "definition": [
                            "void *out"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stats_print_out",
            "header": "void mi_stats_print_out(mi_output_fun *out, void *arg)",
            "params": [
                "mi_output_fun *out",
                "void *arg"
            ],
            "definition": "void mi_stats_print_out(mi_output_fun *out, void *arg)\n{\n  mi_stats_merge_from(mi_stats_get_default());\n  _mi_stats_print(&_mi_stats_main, out, arg);\n}\n\n",
            "calle": [
                "_mi_stats_print",
                "mi_stats_get_default",
                "mi_stats_merge_from"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_thread_stats_print_out",
            "header": "void mi_thread_stats_print_out(mi_output_fun *out, void *arg)",
            "params": [
                "mi_output_fun *out",
                "void *arg"
            ],
            "definition": "void mi_thread_stats_print_out(mi_output_fun *out, void *arg)\n{\n  _mi_stats_print(mi_stats_get_default(), out, arg);\n}\n\n",
            "calle": [
                "_mi_stats_print",
                "mi_stats_get_default"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_process_info",
            "header": "void mi_process_info(size_t *elapsed_msecs, size_t *user_msecs, size_t *system_msecs, size_t *current_rss, size_t *peak_rss, size_t *current_commit, size_t *peak_commit, size_t *page_faults)",
            "params": [
                "size_t *elapsed_msecs",
                "size_t *user_msecs",
                "size_t *system_msecs",
                "size_t *current_rss",
                "size_t *peak_rss",
                "size_t *current_commit",
                "size_t *peak_commit",
                "size_t *page_faults"
            ],
            "definition": "void mi_process_info(size_t *elapsed_msecs, size_t *user_msecs, size_t *system_msecs, size_t *current_rss, size_t *peak_rss, size_t *current_commit, size_t *peak_commit, size_t *page_faults)\n{\n  mi_process_info_t pinfo;\n  memset(&pinfo, 0, sizeof(pinfo));\n  pinfo.elapsed = _mi_clock_end(mi_process_start);\n  pinfo.current_commit = (size_t) atomic_load_explicit((int64_t *) (&_mi_stats_main.committed.current), memory_order_relaxed);\n  pinfo.peak_commit = (size_t) atomic_load_explicit((int64_t *) (&_mi_stats_main.committed.peak), memory_order_relaxed);\n  pinfo.current_rss = pinfo.current_commit;\n  pinfo.peak_rss = pinfo.peak_commit;\n  pinfo.utime = 0;\n  pinfo.stime = 0;\n  pinfo.page_faults = 0;\n  _mi_prim_process_info(&pinfo);\n  if (elapsed_msecs != 0)\n  {\n    *elapsed_msecs = (pinfo.elapsed < 0) ? (0) : ((pinfo.elapsed < ((mi_msecs_t) PTRDIFF_MAX)) ? ((size_t) pinfo.elapsed) : (PTRDIFF_MAX));\n  }\n  if (user_msecs != 0)\n  {\n    *user_msecs = (pinfo.utime < 0) ? (0) : ((pinfo.utime < ((mi_msecs_t) PTRDIFF_MAX)) ? ((size_t) pinfo.utime) : (PTRDIFF_MAX));\n  }\n  if (system_msecs != 0)\n  {\n    *system_msecs = (pinfo.stime < 0) ? (0) : ((pinfo.stime < ((mi_msecs_t) PTRDIFF_MAX)) ? ((size_t) pinfo.stime) : (PTRDIFF_MAX));\n  }\n  if (current_rss != 0)\n  {\n    *current_rss = pinfo.current_rss;\n  }\n  if (peak_rss != 0)\n  {\n    *peak_rss = pinfo.peak_rss;\n  }\n  if (current_commit != 0)\n  {\n    *current_commit = pinfo.current_commit;\n  }\n  if (peak_commit != 0)\n  {\n    *peak_commit = pinfo.peak_commit;\n  }\n  if (page_faults != 0)\n  {\n    *page_faults = pinfo.page_faults;\n  }\n}\n\n",
            "calle": [
                "_mi_clock_end",
                "_mi_prim_process_info",
                "atomic_load_explicit",
                "memset"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "elapsed_msecs",
                        "type": "size_t *",
                        "definition": [
                            "size_t *elapsed_msecs"
                        ]
                    },
                    {
                        "path": null,
                        "name": "user_msecs",
                        "type": "size_t *",
                        "definition": [
                            "size_t *user_msecs"
                        ]
                    },
                    {
                        "path": null,
                        "name": "system_msecs",
                        "type": "size_t *",
                        "definition": [
                            "size_t *system_msecs"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current_rss",
                        "type": "size_t *",
                        "definition": [
                            "size_t *current_rss"
                        ]
                    },
                    {
                        "path": null,
                        "name": "peak_rss",
                        "type": "size_t *",
                        "definition": [
                            "size_t *peak_rss"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current_commit",
                        "type": "size_t *",
                        "definition": [
                            "size_t *current_commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "peak_commit",
                        "type": "size_t *",
                        "definition": [
                            "size_t *peak_commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_faults",
                        "type": "size_t *",
                        "definition": [
                            "size_t *page_faults"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pinfo",
                        "type": "mi_process_info_t",
                        "definition": [
                            "mi_process_info_t pinfo"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_process_start",
                        "type": "None",
                        "definition": []
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stats_get",
            "header": "void mi_stats_get(size_t stats_size, mi_stats_t *stats)",
            "params": [
                "size_t stats_size",
                "mi_stats_t *stats"
            ],
            "definition": "void mi_stats_get(size_t stats_size, mi_stats_t *stats)\n{\n  if ((stats == 0) || (stats_size == 0))\n  {\n    return;\n  }\n  _mi_memzero(stats, stats_size);\n  const size_t size = (stats_size > (sizeof(mi_stats_t))) ? (sizeof(mi_stats_t)) : (stats_size);\n  _mi_memcpy(stats, &_mi_stats_main, size);\n  stats->version = 1;\n}\n\n",
            "calle": [
                "_mi_memcpy",
                "_mi_memzero"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stats_size",
                        "type": "size_t",
                        "definition": [
                            "size_t stats_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "stats",
                        "type": "mi_stats_t *",
                        "definition": [
                            "mi_stats_t *stats"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "const size_t",
                        "definition": [
                            "const size_t size = (stats_size > (sizeof(mi_stats_t))) ? (sizeof(mi_stats_t)) : (stats_size)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stats_get_json",
            "header": "char *mi_stats_get_json(size_t buf_size, char *buf)",
            "params": [
                "size_t output_size",
                "char *output_buf"
            ],
            "definition": "char *mi_stats_get_json(size_t output_size, char *output_buf)\n{\n  mi_heap_buf_t hbuf = {0, 0, 0, 1};\n  if ((output_size > 0) && (output_buf != 0))\n  {\n    _mi_memzero(output_buf, output_size);\n    hbuf.buf = output_buf;\n    hbuf.size = output_size;\n    hbuf.can_realloc = 0;\n  }\n  else\n  {\n    if (!mi_heap_buf_expand(&hbuf))\n    {\n      return 0;\n    }\n  }\n  mi_heap_buf_print(&hbuf, \"{\\n\");\n  mi_heap_buf_print_value(&hbuf, \"version\", 1);\n  mi_heap_buf_print_value(&hbuf, \"mimalloc_version\", 225);\n  mi_heap_buf_print(&hbuf, \"  \\\"process\\\": {\\n\");\n  size_t elapsed;\n  size_t user_time;\n  size_t sys_time;\n  size_t current_rss;\n  size_t peak_rss;\n  size_t current_commit;\n  size_t peak_commit;\n  size_t page_faults;\n  mi_process_info(&elapsed, &user_time, &sys_time, &current_rss, &peak_rss, &current_commit, &peak_commit, &page_faults);\n  mi_heap_buf_print_size(&hbuf, \"elapsed_msecs\", elapsed, 1);\n  mi_heap_buf_print_size(&hbuf, \"user_msecs\", user_time, 1);\n  mi_heap_buf_print_size(&hbuf, \"system_msecs\", sys_time, 1);\n  mi_heap_buf_print_size(&hbuf, \"page_faults\", page_faults, 1);\n  mi_heap_buf_print_size(&hbuf, \"rss_current\", current_rss, 1);\n  mi_heap_buf_print_size(&hbuf, \"rss_peak\", peak_rss, 1);\n  mi_heap_buf_print_size(&hbuf, \"commit_current\", current_commit, 1);\n  mi_heap_buf_print_size(&hbuf, \"commit_peak\", peak_commit, 0);\n  mi_heap_buf_print(&hbuf, \"  },\\n\");\n  mi_stats_t *stats = &_mi_stats_main;\n  mi_heap_buf_print_count_value(&hbuf, \"pages\", &stats->pages);\n  mi_heap_buf_print_count_value(&hbuf, \"reserved\", &stats->reserved);\n  mi_heap_buf_print_count_value(&hbuf, \"committed\", &stats->committed);\n  mi_heap_buf_print_count_value(&hbuf, \"reset\", &stats->reset);\n  mi_heap_buf_print_count_value(&hbuf, \"purged\", &stats->purged);\n  mi_heap_buf_print_count_value(&hbuf, \"page_committed\", &stats->page_committed);\n  mi_heap_buf_print_count_value(&hbuf, \"pages_abandoned\", &stats->pages_abandoned);\n  mi_heap_buf_print_count_value(&hbuf, \"threads\", &stats->threads);\n  mi_heap_buf_print_count_value(&hbuf, \"malloc_normal\", &stats->malloc_normal);\n  mi_heap_buf_print_count_value(&hbuf, \"malloc_huge\", &stats->malloc_huge);\n  mi_heap_buf_print_count_value(&hbuf, \"malloc_requested\", &stats->malloc_requested);\n  mi_heap_buf_print_counter_value(&hbuf, \"mmap_calls\", &stats->mmap_calls);\n  mi_heap_buf_print_counter_value(&hbuf, \"commit_calls\", &stats->commit_calls);\n  mi_heap_buf_print_counter_value(&hbuf, \"reset_calls\", &stats->reset_calls);\n  mi_heap_buf_print_counter_value(&hbuf, \"purge_calls\", &stats->purge_calls);\n  mi_heap_buf_print_counter_value(&hbuf, \"arena_count\", &stats->arena_count);\n  mi_heap_buf_print_counter_value(&hbuf, \"malloc_normal_count\", &stats->malloc_normal_count);\n  mi_heap_buf_print_counter_value(&hbuf, \"malloc_huge_count\", &stats->malloc_huge_count);\n  mi_heap_buf_print_counter_value(&hbuf, \"malloc_guarded_count\", &stats->malloc_guarded_count);\n  mi_heap_buf_print_counter_value(&hbuf, \"arena_rollback_count\", &stats->arena_rollback_count);\n  mi_heap_buf_print_counter_value(&hbuf, \"arena_purges\", &stats->arena_purges);\n  mi_heap_buf_print_counter_value(&hbuf, \"pages_extended\", &stats->pages_extended);\n  mi_heap_buf_print_counter_value(&hbuf, \"pages_retire\", &stats->pages_retire);\n  mi_heap_buf_print_counter_value(&hbuf, \"page_searches\", &stats->page_searches);\n  mi_heap_buf_print_count_value(&hbuf, \"segments\", &stats->segments);\n  mi_heap_buf_print_count_value(&hbuf, \"segments_abandoned\", &stats->segments_abandoned);\n  mi_heap_buf_print_count_value(&hbuf, \"segments_cache\", &stats->segments_cache);\n  mi_heap_buf_print_count_value(&hbuf, \"_segments_reserved\", &stats->_segments_reserved);\n  mi_heap_buf_print_counter_value(&hbuf, \"pages_reclaim_on_alloc\", &stats->pages_reclaim_on_alloc);\n  mi_heap_buf_print_counter_value(&hbuf, \"pages_reclaim_on_free\", &stats->pages_reclaim_on_free);\n  mi_heap_buf_print_counter_value(&hbuf, \"pages_reabandon_full\", &stats->pages_reabandon_full);\n  mi_heap_buf_print_counter_value(&hbuf, \"pages_unabandon_busy_wait\", &stats->pages_unabandon_busy_wait);\n  mi_heap_buf_print(&hbuf, \"  \\\"malloc_bins\\\": [\\n\");\n  for (size_t i = 0; i <= 73U; i += 1)\n  {\n    mi_heap_buf_print_count_bin(&hbuf, \"    \", &stats->malloc_bins[i], i, i != 73U);\n  }\n\n  mi_heap_buf_print(&hbuf, \"  ],\\n\");\n  mi_heap_buf_print(&hbuf, \"  \\\"page_bins\\\": [\\n\");\n  for (size_t i = 0; i <= 73U; i += 1)\n  {\n    mi_heap_buf_print_count_bin(&hbuf, \"    \", &stats->page_bins[i], i, i != 73U);\n  }\n\n  mi_heap_buf_print(&hbuf, \"  ]\\n\");\n  mi_heap_buf_print(&hbuf, \"}\\n\");\n  return hbuf.buf;\n}\n\n",
            "calle": [
                "_mi_memzero",
                "mi_heap_buf_expand",
                "mi_heap_buf_print",
                "mi_heap_buf_print_count_bin",
                "mi_heap_buf_print_count_value",
                "mi_heap_buf_print_counter_value",
                "mi_heap_buf_print_size",
                "mi_heap_buf_print_value",
                "mi_process_info"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "output_size",
                        "type": "size_t",
                        "definition": [
                            "size_t output_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "output_buf",
                        "type": "char *",
                        "definition": [
                            "char *output_buf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "hbuf",
                        "type": "mi_heap_buf_t",
                        "definition": [
                            "mi_heap_buf_t hbuf = {0, 0, 0, 1}"
                        ]
                    },
                    {
                        "path": null,
                        "name": "elapsed",
                        "type": "size_t",
                        "definition": [
                            "size_t elapsed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "user_time",
                        "type": "size_t",
                        "definition": [
                            "size_t user_time"
                        ]
                    },
                    {
                        "path": null,
                        "name": "sys_time",
                        "type": "size_t",
                        "definition": [
                            "size_t sys_time"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current_rss",
                        "type": "size_t",
                        "definition": [
                            "size_t current_rss"
                        ]
                    },
                    {
                        "path": null,
                        "name": "peak_rss",
                        "type": "size_t",
                        "definition": [
                            "size_t peak_rss"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current_commit",
                        "type": "size_t",
                        "definition": [
                            "size_t current_commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "peak_commit",
                        "type": "size_t",
                        "definition": [
                            "size_t peak_commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_faults",
                        "type": "size_t",
                        "definition": [
                            "size_t page_faults"
                        ]
                    },
                    {
                        "path": null,
                        "name": "stats",
                        "type": "mi_stats_t *",
                        "definition": [
                            "mi_stats_t *stats = &_mi_stats_main"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_stat_increase",
            "header": "void _mi_stat_increase(mi_stat_count_t *stat, size_t amount)",
            "params": [
                "mi_stat_count_t *stat",
                "size_t amount"
            ],
            "definition": "void _mi_stat_increase(mi_stat_count_t *stat, size_t amount)\n{\n  mi_stat_update(stat, (int64_t) amount);\n}\n\n",
            "calle": [
                "mi_stat_update"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stat",
                        "type": "mi_stat_count_t *",
                        "definition": [
                            "mi_stat_count_t *stat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "amount",
                        "type": "size_t",
                        "definition": [
                            "size_t amount"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_stat_decrease",
            "header": "void _mi_stat_decrease(mi_stat_count_t *stat, size_t amount)",
            "params": [
                "mi_stat_count_t *stat",
                "size_t amount"
            ],
            "definition": "void _mi_stat_decrease(mi_stat_count_t *stat, size_t amount)\n{\n  mi_stat_update(stat, -((int64_t) amount));\n}\n\n",
            "calle": [
                "mi_stat_update"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stat",
                        "type": "mi_stat_count_t *",
                        "definition": [
                            "mi_stat_count_t *stat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "amount",
                        "type": "size_t",
                        "definition": [
                            "size_t amount"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_stat_adjust_decrease",
            "header": "void _mi_stat_adjust_decrease(mi_stat_count_t *stat, size_t amount)",
            "params": [
                "mi_stat_count_t *stat",
                "size_t amount"
            ],
            "definition": "void _mi_stat_adjust_decrease(mi_stat_count_t *stat, size_t amount)\n{\n  mi_stat_adjust(stat, -((int64_t) amount));\n}\n\n",
            "calle": [
                "mi_stat_adjust"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stat",
                        "type": "mi_stat_count_t *",
                        "definition": [
                            "mi_stat_count_t *stat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "amount",
                        "type": "size_t",
                        "definition": [
                            "size_t amount"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_stat_counter_increase",
            "header": "void _mi_stat_counter_increase(mi_stat_counter_t *stat, size_t amount)",
            "params": [
                "mi_stat_counter_t *stat",
                "size_t amount"
            ],
            "definition": "void _mi_stat_counter_increase(mi_stat_counter_t *stat, size_t amount)\n{\n  if (mi_is_in_main(stat))\n  {\n    mi_atomic_addi64_relaxed(&stat->total, (int64_t) amount);\n  }\n  else\n  {\n    stat->total += amount;\n  }\n}\n\n",
            "calle": [
                "mi_atomic_addi64_relaxed",
                "mi_is_in_main"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stat",
                        "type": "mi_stat_counter_t *",
                        "definition": [
                            "mi_stat_counter_t *stat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "amount",
                        "type": "size_t",
                        "definition": [
                            "size_t amount"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_stats_done",
            "header": "void _mi_stats_done(mi_stats_t *stats)",
            "params": [
                "mi_stats_t *stats"
            ],
            "definition": "void _mi_stats_done(mi_stats_t *stats)\n{\n  mi_stats_merge_from(stats);\n}\n\n",
            "calle": [
                "mi_stats_merge_from"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stats",
                        "type": "mi_stats_t *",
                        "definition": [
                            "mi_stats_t *stats"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_stats_merge_thread",
            "header": "void _mi_stats_merge_thread(mi_tld_t *tld)",
            "params": [
                "mi_tld_t *tld"
            ],
            "definition": "void _mi_stats_merge_thread(mi_tld_t *tld)\n{\n  mi_stats_merge_from(&tld->stats);\n}\n\n",
            "calle": [
                "mi_stats_merge_from"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "tld",
                        "type": "mi_tld_t *",
                        "definition": [
                            "mi_tld_t *tld"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_clock_now",
            "header": "mi_msecs_t _mi_clock_now(void)",
            "params": [
                "void"
            ],
            "definition": "mi_msecs_t _mi_clock_now(void)\n{\n  return _mi_prim_clock_now();\n}\n\n",
            "calle": [
                "_mi_prim_clock_now"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_clock_end",
            "header": "mi_msecs_t _mi_clock_end(mi_msecs_t start)",
            "params": [
                "mi_msecs_t start"
            ],
            "definition": "mi_msecs_t _mi_clock_end(mi_msecs_t start)\n{\n  mi_msecs_t end = _mi_clock_now();\n  return (end - start) - mi_clock_diff;\n}\n\n",
            "calle": [
                "_mi_clock_now"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "start",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "end",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t end = _mi_clock_now()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_clock_diff",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_clock_start",
            "header": "mi_msecs_t _mi_clock_start(void)",
            "params": [
                "void"
            ],
            "definition": "mi_msecs_t _mi_clock_start(void)\n{\n  if (mi_clock_diff == 0.0)\n  {\n    mi_msecs_t t0 = _mi_clock_now();\n    mi_clock_diff = _mi_clock_now() - t0;\n  }\n  return _mi_clock_now();\n}\n\n",
            "calle": [
                "_mi_clock_now"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "t0",
                        "type": "mi_msecs_t",
                        "definition": [
                            "mi_msecs_t t0 = _mi_clock_now()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mi_clock_diff",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_is_in_main",
            "header": "",
            "params": [
                "void *stat"
            ],
            "definition": "static bool mi_is_in_main(void *stat)\n{\n  return (((uint8_t *) stat) >= ((uint8_t *) (&_mi_stats_main))) && (((uint8_t *) stat) < (((uint8_t *) (&_mi_stats_main)) + (sizeof(mi_stats_t))));\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stat",
                        "type": "void *",
                        "definition": [
                            "void *stat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stat_update",
            "header": "",
            "params": [
                "mi_stat_count_t *stat",
                "int64_t amount"
            ],
            "definition": "static void mi_stat_update(mi_stat_count_t *stat, int64_t amount)\n{\n  if (amount == 0)\n  {\n    return;\n  }\n  if (__builtin_expect(!(!mi_is_in_main(stat)), 0))\n  {\n    int64_t current = mi_atomic_addi64_relaxed(&stat->current, amount);\n    mi_atomic_maxi64_relaxed(&stat->peak, current + amount);\n    if (amount > 0)\n    {\n      mi_atomic_addi64_relaxed(&stat->total, amount);\n    }\n  }\n  else\n  {\n    stat->current += amount;\n    if (stat->current > stat->peak)\n    {\n      stat->peak = stat->current;\n    }\n    if (amount > 0)\n    {\n      stat->total += amount;\n    }\n  }\n}\n\n",
            "calle": [
                "__builtin_expect",
                "mi_atomic_addi64_relaxed",
                "mi_atomic_maxi64_relaxed",
                "mi_is_in_main"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stat",
                        "type": "mi_stat_count_t *",
                        "definition": [
                            "mi_stat_count_t *stat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "amount",
                        "type": "int64_t",
                        "definition": [
                            "int64_t amount"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current",
                        "type": "int64_t",
                        "definition": [
                            "int64_t current = mi_atomic_addi64_relaxed(&stat->current, amount)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stat_adjust",
            "header": "",
            "params": [
                "mi_stat_count_t *stat",
                "int64_t amount"
            ],
            "definition": "static void mi_stat_adjust(mi_stat_count_t *stat, int64_t amount)\n{\n  if (amount == 0)\n  {\n    return;\n  }\n  if (__builtin_expect(!(!mi_is_in_main(stat)), 0))\n  {\n    mi_atomic_addi64_relaxed(&stat->current, amount);\n    mi_atomic_addi64_relaxed(&stat->total, amount);\n  }\n  else\n  {\n    stat->current += amount;\n    stat->total += amount;\n  }\n}\n\n",
            "calle": [
                "__builtin_expect",
                "mi_atomic_addi64_relaxed",
                "mi_is_in_main"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stat",
                        "type": "mi_stat_count_t *",
                        "definition": [
                            "mi_stat_count_t *stat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "amount",
                        "type": "int64_t",
                        "definition": [
                            "int64_t amount"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stat_count_add_mt",
            "header": "",
            "params": [
                "mi_stat_count_t *stat",
                "const mi_stat_count_t *src"
            ],
            "definition": "static void mi_stat_count_add_mt(mi_stat_count_t *stat, const mi_stat_count_t *src)\n{\n  if (stat == src)\n  {\n    return;\n  }\n  mi_atomic_void_addi64_relaxed(&stat->total, &src->total);\n  mi_atomic_void_addi64_relaxed(&stat->current, &src->current);\n  mi_atomic_void_addi64_relaxed(&stat->peak, &src->peak);\n}\n\n",
            "calle": [
                "mi_atomic_void_addi64_relaxed"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stat",
                        "type": "mi_stat_count_t *",
                        "definition": [
                            "mi_stat_count_t *stat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "src",
                        "type": "const mi_stat_count_t *",
                        "definition": [
                            "const mi_stat_count_t *src"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stat_counter_add_mt",
            "header": "",
            "params": [
                "mi_stat_counter_t *stat",
                "const mi_stat_counter_t *src"
            ],
            "definition": "static void mi_stat_counter_add_mt(mi_stat_counter_t *stat, const mi_stat_counter_t *src)\n{\n  if (stat == src)\n  {\n    return;\n  }\n  mi_atomic_void_addi64_relaxed(&stat->total, &src->total);\n}\n\n",
            "calle": [
                "mi_atomic_void_addi64_relaxed"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stat",
                        "type": "mi_stat_counter_t *",
                        "definition": [
                            "mi_stat_counter_t *stat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "src",
                        "type": "const mi_stat_counter_t *",
                        "definition": [
                            "const mi_stat_counter_t *src"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stats_add",
            "header": "",
            "params": [
                "mi_stats_t *stats",
                "const mi_stats_t *src"
            ],
            "definition": "static void mi_stats_add(mi_stats_t *stats, const mi_stats_t *src)\n{\n  if (stats == src)\n  {\n    return;\n  }\n  mi_stat_count_add_mt(&stats->pages, &src->pages);\n  mi_stat_count_add_mt(&stats->reserved, &src->reserved);\n  mi_stat_count_add_mt(&stats->committed, &src->committed);\n  mi_stat_count_add_mt(&stats->reset, &src->reset);\n  mi_stat_count_add_mt(&stats->purged, &src->purged);\n  mi_stat_count_add_mt(&stats->page_committed, &src->page_committed);\n  mi_stat_count_add_mt(&stats->pages_abandoned, &src->pages_abandoned);\n  mi_stat_count_add_mt(&stats->threads, &src->threads);\n  mi_stat_count_add_mt(&stats->malloc_normal, &src->malloc_normal);\n  mi_stat_count_add_mt(&stats->malloc_huge, &src->malloc_huge);\n  mi_stat_count_add_mt(&stats->malloc_requested, &src->malloc_requested);\n  mi_stat_counter_add_mt(&stats->mmap_calls, &src->mmap_calls);\n  mi_stat_counter_add_mt(&stats->commit_calls, &src->commit_calls);\n  mi_stat_counter_add_mt(&stats->reset_calls, &src->reset_calls);\n  mi_stat_counter_add_mt(&stats->purge_calls, &src->purge_calls);\n  mi_stat_counter_add_mt(&stats->arena_count, &src->arena_count);\n  mi_stat_counter_add_mt(&stats->malloc_normal_count, &src->malloc_normal_count);\n  mi_stat_counter_add_mt(&stats->malloc_huge_count, &src->malloc_huge_count);\n  mi_stat_counter_add_mt(&stats->malloc_guarded_count, &src->malloc_guarded_count);\n  mi_stat_counter_add_mt(&stats->arena_rollback_count, &src->arena_rollback_count);\n  mi_stat_counter_add_mt(&stats->arena_purges, &src->arena_purges);\n  mi_stat_counter_add_mt(&stats->pages_extended, &src->pages_extended);\n  mi_stat_counter_add_mt(&stats->pages_retire, &src->pages_retire);\n  mi_stat_counter_add_mt(&stats->page_searches, &src->page_searches);\n  mi_stat_count_add_mt(&stats->segments, &src->segments);\n  mi_stat_count_add_mt(&stats->segments_abandoned, &src->segments_abandoned);\n  mi_stat_count_add_mt(&stats->segments_cache, &src->segments_cache);\n  mi_stat_count_add_mt(&stats->_segments_reserved, &src->_segments_reserved);\n  mi_stat_counter_add_mt(&stats->pages_reclaim_on_alloc, &src->pages_reclaim_on_alloc);\n  mi_stat_counter_add_mt(&stats->pages_reclaim_on_free, &src->pages_reclaim_on_free);\n  mi_stat_counter_add_mt(&stats->pages_reabandon_full, &src->pages_reabandon_full);\n  mi_stat_counter_add_mt(&stats->pages_unabandon_busy_wait, &src->pages_unabandon_busy_wait);\n  for (size_t i = 0; i <= 73U; i += 1)\n  {\n    mi_stat_count_add_mt(&stats->malloc_bins[i], &src->malloc_bins[i]);\n  }\n\n  for (size_t i = 0; i <= 73U; i += 1)\n  {\n    mi_stat_count_add_mt(&stats->page_bins[i], &src->page_bins[i]);\n  }\n\n}\n\n",
            "calle": [
                "mi_stat_count_add_mt",
                "mi_stat_counter_add_mt"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stats",
                        "type": "mi_stats_t *",
                        "definition": [
                            "mi_stats_t *stats"
                        ]
                    },
                    {
                        "path": null,
                        "name": "src",
                        "type": "const mi_stats_t *",
                        "definition": [
                            "const mi_stats_t *src"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_printf_amount",
            "header": "",
            "params": [
                "int64_t n",
                "int64_t unit",
                "mi_output_fun *out",
                "void *arg",
                "const char *fmt"
            ],
            "definition": "static void mi_printf_amount(int64_t n, int64_t unit, mi_output_fun *out, void *arg, const char *fmt)\n{\n  char buf[32];\n  buf[0] = 0;\n  int len = 32;\n  const char *suffix = (unit <= 0) ? (\" \") : (\"B\");\n  const int64_t base = (unit == 0) ? (1000) : (1024);\n  if (unit > 0)\n  {\n    n *= unit;\n  }\n  const int64_t pos = (n < 0) ? (-n) : (n);\n  if (pos < base)\n  {\n    if ((n != 1) || (suffix[0] != 'B'))\n    {\n      _mi_snprintf(buf, len, \"%lld   %-3s\", (long long) n, (n == 0) ? (\"\") : (suffix));\n    }\n  }\n  else\n  {\n    int64_t divider = base;\n    const char *magnitude = \"K\";\n    unsigned int magnitude_idx = 0;\n    if (pos >= (divider * base))\n    {\n      divider *= base;\n      magnitude_idx = \"M\";\n    }\n    if (pos >= (divider * base))\n    {\n      divider *= base;\n      magnitude_idx = \"G\";\n    }\n    const int64_t tens = n / (divider / 10);\n    const long whole = (long) (tens / 10);\n    const long frac1 = (long) (tens % 10);\n    char unitdesc[8];\n    _mi_snprintf(unitdesc, 8, \"%s%s%s\", magnitude, (base == 1024) ? (\"i\") : (\"\"), suffix);\n    _mi_snprintf(buf, len, \"%ld.%ld %-3s\", whole, (frac1 < 0) ? (-frac1) : (frac1), unitdesc);\n  }\n  _mi_fprintf(out, arg, (fmt == 0) ? (\"%12s\") : (fmt), buf);\n}\n\n",
            "calle": [
                "_mi_fprintf",
                "_mi_snprintf"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "n",
                        "type": "int64_t",
                        "definition": [
                            "int64_t n"
                        ]
                    },
                    {
                        "path": null,
                        "name": "unit",
                        "type": "int64_t",
                        "definition": [
                            "int64_t unit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fmt",
                        "type": "const char *",
                        "definition": [
                            "const char *fmt"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char [32]",
                        "definition": [
                            "char buf[32]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "len",
                        "type": "int",
                        "definition": [
                            "int len = 32"
                        ]
                    },
                    {
                        "path": null,
                        "name": "suffix",
                        "type": "const char *",
                        "definition": [
                            "const char *suffix = (unit <= 0) ? (\" \") : (\"B\")"
                        ]
                    },
                    {
                        "path": null,
                        "name": "base",
                        "type": "const int64_t",
                        "definition": [
                            "const int64_t base = (unit == 0) ? (1000) : (1024)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pos",
                        "type": "const int64_t",
                        "definition": [
                            "const int64_t pos = (n < 0) ? (-n) : (n)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "divider",
                        "type": "int64_t",
                        "definition": [
                            "int64_t divider = base"
                        ]
                    },
                    {
                        "path": null,
                        "name": "magnitude",
                        "type": "const char *",
                        "definition": [
                            "const char *magnitude = \"K\""
                        ]
                    },
                    {
                        "path": null,
                        "name": "magnitude_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int magnitude_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "tens",
                        "type": "const int64_t",
                        "definition": [
                            "const int64_t tens = n / (divider / 10)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "whole",
                        "type": "const long",
                        "definition": [
                            "const long whole = (long) (tens / 10)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "frac1",
                        "type": "const long",
                        "definition": [
                            "const long frac1 = (long) (tens % 10)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "unitdesc",
                        "type": "char [8]",
                        "definition": [
                            "char unitdesc[8]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_print_amount",
            "header": "",
            "params": [
                "int64_t n",
                "int64_t unit",
                "mi_output_fun *out",
                "void *arg"
            ],
            "definition": "static void mi_print_amount(int64_t n, int64_t unit, mi_output_fun *out, void *arg)\n{\n  mi_printf_amount(n, unit, out, arg, 0);\n}\n\n",
            "calle": [
                "mi_printf_amount"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "n",
                        "type": "int64_t",
                        "definition": [
                            "int64_t n"
                        ]
                    },
                    {
                        "path": null,
                        "name": "unit",
                        "type": "int64_t",
                        "definition": [
                            "int64_t unit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_print_count",
            "header": "",
            "params": [
                "int64_t n",
                "int64_t unit",
                "mi_output_fun *out",
                "void *arg"
            ],
            "definition": "static void mi_print_count(int64_t n, int64_t unit, mi_output_fun *out, void *arg)\n{\n  if (unit == 1)\n  {\n    _mi_fprintf(out, arg, \"%12s\", \" \");\n  }\n  else\n    mi_print_amount(n, 0, out, arg);\n}\n\n",
            "calle": [
                "_mi_fprintf",
                "mi_print_amount"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "n",
                        "type": "int64_t",
                        "definition": [
                            "int64_t n"
                        ]
                    },
                    {
                        "path": null,
                        "name": "unit",
                        "type": "int64_t",
                        "definition": [
                            "int64_t unit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stat_print_ex",
            "header": "",
            "params": [
                "const mi_stat_count_t *stat",
                "const char *msg",
                "int64_t unit",
                "mi_output_fun *out",
                "void *arg",
                "const char *notok"
            ],
            "definition": "static void mi_stat_print_ex(const mi_stat_count_t *stat, const char *msg, int64_t unit, mi_output_fun *out, void *arg, const char *notok)\n{\n  _mi_fprintf(out, arg, \"%10s:\", msg);\n  if (unit != 0)\n  {\n    if (unit > 0)\n    {\n      mi_print_amount(stat->peak, unit, out, arg);\n      mi_print_amount(stat->total, unit, out, arg);\n      mi_print_amount(stat->current, unit, out, arg);\n      mi_print_amount(unit, 1, out, arg);\n      mi_print_count(stat->total, unit, out, arg);\n    }\n    else\n    {\n      mi_print_amount(stat->peak, -1, out, arg);\n      mi_print_amount(stat->total, -1, out, arg);\n      mi_print_amount(stat->current, -1, out, arg);\n      if (unit == (-1))\n      {\n        _mi_fprintf(out, arg, \"%24s\", \"\");\n      }\n      else\n      {\n        mi_print_amount(-unit, 1, out, arg);\n        mi_print_count(stat->total / (-unit), 0, out, arg);\n      }\n    }\n    if (stat->current != 0)\n    {\n      _mi_fprintf(out, arg, \"  \");\n      _mi_fprintf(out, arg, (notok == 0) ? (\"not all freed\") : (notok));\n      _mi_fprintf(out, arg, \"\\n\");\n    }\n    else\n    {\n      _mi_fprintf(out, arg, \"  ok\\n\");\n    }\n  }\n  else\n  {\n    mi_print_amount(stat->peak, 1, out, arg);\n    mi_print_amount(stat->total, 1, out, arg);\n    _mi_fprintf(out, arg, \"%11s\", \" \");\n    mi_print_amount(stat->current, 1, out, arg);\n    _mi_fprintf(out, arg, \"\\n\");\n  }\n}\n\n",
            "calle": [
                "_mi_fprintf",
                "mi_print_amount",
                "mi_print_count"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stat",
                        "type": "const mi_stat_count_t *",
                        "definition": [
                            "const mi_stat_count_t *stat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "msg",
                        "type": "const char *",
                        "definition": [
                            "const char *msg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "unit",
                        "type": "int64_t",
                        "definition": [
                            "int64_t unit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "notok",
                        "type": "const char *",
                        "definition": [
                            "const char *notok"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stat_print",
            "header": "",
            "params": [
                "const mi_stat_count_t *stat",
                "const char *msg",
                "int64_t unit",
                "mi_output_fun *out",
                "void *arg"
            ],
            "definition": "static void mi_stat_print(const mi_stat_count_t *stat, const char *msg, int64_t unit, mi_output_fun *out, void *arg)\n{\n  mi_stat_print_ex(stat, msg, unit, out, arg, 0);\n}\n\n",
            "calle": [
                "mi_stat_print_ex"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stat",
                        "type": "const mi_stat_count_t *",
                        "definition": [
                            "const mi_stat_count_t *stat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "msg",
                        "type": "const char *",
                        "definition": [
                            "const char *msg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "unit",
                        "type": "int64_t",
                        "definition": [
                            "int64_t unit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stat_peak_print",
            "header": "",
            "params": [
                "const mi_stat_count_t *stat",
                "const char *msg",
                "int64_t unit",
                "mi_output_fun *out",
                "void *arg"
            ],
            "definition": "static void mi_stat_peak_print(const mi_stat_count_t *stat, const char *msg, int64_t unit, mi_output_fun *out, void *arg)\n{\n  _mi_fprintf(out, arg, \"%10s:\", msg);\n  mi_print_amount(stat->peak, unit, out, arg);\n  _mi_fprintf(out, arg, \"\\n\");\n}\n\n",
            "calle": [
                "_mi_fprintf",
                "mi_print_amount"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stat",
                        "type": "const mi_stat_count_t *",
                        "definition": [
                            "const mi_stat_count_t *stat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "msg",
                        "type": "const char *",
                        "definition": [
                            "const char *msg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "unit",
                        "type": "int64_t",
                        "definition": [
                            "int64_t unit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stat_total_print",
            "header": "",
            "params": [
                "const mi_stat_count_t *stat",
                "const char *msg",
                "int64_t unit",
                "mi_output_fun *out",
                "void *arg"
            ],
            "definition": "static void mi_stat_total_print(const mi_stat_count_t *stat, const char *msg, int64_t unit, mi_output_fun *out, void *arg)\n{\n  _mi_fprintf(out, arg, \"%10s:\", msg);\n  _mi_fprintf(out, arg, \"%12s\", \" \");\n  mi_print_amount(stat->total, unit, out, arg);\n  _mi_fprintf(out, arg, \"\\n\");\n}\n\n",
            "calle": [
                "_mi_fprintf",
                "mi_print_amount"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stat",
                        "type": "const mi_stat_count_t *",
                        "definition": [
                            "const mi_stat_count_t *stat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "msg",
                        "type": "const char *",
                        "definition": [
                            "const char *msg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "unit",
                        "type": "int64_t",
                        "definition": [
                            "int64_t unit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stat_counter_print",
            "header": "",
            "params": [
                "const mi_stat_counter_t *stat",
                "const char *msg",
                "mi_output_fun *out",
                "void *arg"
            ],
            "definition": "static void mi_stat_counter_print(const mi_stat_counter_t *stat, const char *msg, mi_output_fun *out, void *arg)\n{\n  _mi_fprintf(out, arg, \"%10s:\", msg);\n  mi_print_amount(stat->total, -1, out, arg);\n  _mi_fprintf(out, arg, \"\\n\");\n}\n\n",
            "calle": [
                "_mi_fprintf",
                "mi_print_amount"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stat",
                        "type": "const mi_stat_counter_t *",
                        "definition": [
                            "const mi_stat_counter_t *stat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "msg",
                        "type": "const char *",
                        "definition": [
                            "const char *msg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stat_counter_print_avg",
            "header": "",
            "params": [
                "const mi_stat_counter_t *stat",
                "const char *msg",
                "mi_output_fun *out",
                "void *arg"
            ],
            "definition": "static void mi_stat_counter_print_avg(const mi_stat_counter_t *stat, const char *msg, mi_output_fun *out, void *arg)\n{\n  const int64_t avg_tens = (stat->total == 0) ? (0) : ((stat->total * 10) / stat->total);\n  const long avg_whole = (long) (avg_tens / 10);\n  const long avg_frac1 = (long) (avg_tens % 10);\n  _mi_fprintf(out, arg, \"%10s: %5ld.%ld avg\\n\", msg, avg_whole, avg_frac1);\n}\n\n",
            "calle": [
                "_mi_fprintf"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stat",
                        "type": "const mi_stat_counter_t *",
                        "definition": [
                            "const mi_stat_counter_t *stat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "msg",
                        "type": "const char *",
                        "definition": [
                            "const char *msg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "avg_tens",
                        "type": "const int64_t",
                        "definition": [
                            "const int64_t avg_tens = (stat->total == 0) ? (0) : ((stat->total * 10) / stat->total)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "avg_whole",
                        "type": "const long",
                        "definition": [
                            "const long avg_whole = (long) (avg_tens / 10)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "avg_frac1",
                        "type": "const long",
                        "definition": [
                            "const long avg_frac1 = (long) (avg_tens % 10)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_print_header",
            "header": "",
            "params": [
                "mi_output_fun *out",
                "void *arg"
            ],
            "definition": "static void mi_print_header(mi_output_fun *out, void *arg)\n{\n  _mi_fprintf(out, arg, \"%10s: %11s %11s %11s %11s %11s\\n\", \"heap stats\", \"peak   \", \"total   \", \"current   \", \"block   \", \"total#   \");\n}\n\n",
            "calle": [
                "_mi_fprintf"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stats_print_bins",
            "header": "",
            "params": [
                "const mi_stat_count_t *bins",
                "size_t max",
                "const char *fmt",
                "mi_output_fun *out",
                "void *arg"
            ],
            "definition": "static void mi_stats_print_bins(const mi_stat_count_t *bins, size_t max, const char *fmt, mi_output_fun *out, void *arg)\n{\n  bool found = 0;\n  char buf[64];\n  for (size_t i = 0; i <= max; i += 1)\n  {\n    if (bins[i].total > 0)\n    {\n      found = 1;\n      int64_t unit = _mi_bin_size((uint8_t) i);\n      _mi_snprintf(buf, 64, \"%s %3lu\", fmt, (long) i);\n      mi_stat_print(&bins[i], buf, unit, out, arg);\n    }\n  }\n\n  if (found)\n  {\n    _mi_fprintf(out, arg, \"\\n\");\n    mi_print_header(out, arg);\n  }\n}\n\n",
            "calle": [
                "_mi_bin_size",
                "_mi_fprintf",
                "_mi_snprintf",
                "mi_print_header",
                "mi_stat_print"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "bins",
                        "type": "const mi_stat_count_t *",
                        "definition": [
                            "const mi_stat_count_t *bins"
                        ]
                    },
                    {
                        "path": null,
                        "name": "max",
                        "type": "size_t",
                        "definition": [
                            "size_t max"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fmt",
                        "type": "const char *",
                        "definition": [
                            "const char *fmt"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "found",
                        "type": "bool",
                        "definition": [
                            "bool found = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char [64]",
                        "definition": [
                            "char buf[64]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "size_t",
                        "definition": [
                            "size_t i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "unit",
                        "type": "int64_t",
                        "definition": [
                            "int64_t unit = _mi_bin_size((uint8_t) i)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_buffered_flush",
            "header": "",
            "params": [
                "buffered_t *buf"
            ],
            "definition": "static void mi_buffered_flush(buffered_t *buf)\n{\n  buf->buf[buf->used] = 0;\n  _mi_fputs(buf->out, buf->arg, 0, buf->buf);\n  buf->used = 0;\n}\n\n",
            "calle": [
                "_mi_fputs"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "buf",
                        "type": "buffered_t *",
                        "definition": [
                            "buffered_t *buf"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_buffered_out",
            "header": "",
            "params": [
                "const char *msg",
                "void *arg"
            ],
            "definition": "static void mi_buffered_out(const char *msg, void *arg)\n{\n  buffered_t *buf = (buffered_t *) arg;\n  if ((msg == 0) || (buf == 0))\n  {\n    return;\n  }\n  for (const char *src = msg; src[src_idx] != 0; src_idx += 1)\n  {\n    char c = src[src_idx];\n    if (buf->used >= buf->count)\n    {\n      mi_buffered_flush(buf);\n    }\n    (buf->used < buf->count) ? ((void) 0) : (_mi_assert_fail(\"buf->used < buf->count\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/stats.c\", 294, __func__));\n    buf->buf[buf->used++] = c;\n    if (c == '\\n')\n    {\n      mi_buffered_flush(buf);\n    }\n  }\n\n  unsigned int src_idx = 0;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_buffered_flush"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "msg",
                        "type": "const char *",
                        "definition": [
                            "const char *msg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf",
                        "type": "buffered_t *",
                        "definition": [
                            "buffered_t *buf = (buffered_t *) arg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "src",
                        "type": "const char *",
                        "definition": [
                            "const char *src = msg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "c",
                        "type": "char",
                        "definition": [
                            "char c = src[src_idx]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "src_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int src_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_stats_print",
            "header": "",
            "params": [
                "mi_stats_t *stats",
                "mi_output_fun *out0",
                "void *arg0"
            ],
            "definition": "static void _mi_stats_print(mi_stats_t *stats, mi_output_fun *out0, void *arg0)\n{\n  char buf[256];\n  buffered_t buffer = {out0, arg0, 0, 0, 255};\n  buffer.buf = buf;\n  mi_output_fun *out = &mi_buffered_out;\n  void *arg = &buffer;\n  mi_print_header(out, arg);\n  mi_stats_print_bins(stats->malloc_bins, 73U, \"bin\", out, arg);\n  mi_stat_print(&stats->malloc_normal, \"binned\", (stats->malloc_normal_count.total == 0) ? (1) : (-1), out, arg);\n  mi_stat_print(&stats->malloc_huge, \"huge\", (stats->malloc_huge_count.total == 0) ? (1) : (-1), out, arg);\n  mi_stat_count_t total = {0, 0, 0};\n  mi_stat_count_add_mt(&total, &stats->malloc_normal);\n  mi_stat_count_add_mt(&total, &stats->malloc_huge);\n  mi_stat_print_ex(&total, \"total\", 1, out, arg, \"\");\n  mi_stat_total_print(&stats->malloc_requested, \"malloc req\", 1, out, arg);\n  _mi_fprintf(out, arg, \"\\n\");\n  mi_stat_print_ex(&stats->reserved, \"reserved\", 1, out, arg, \"\");\n  mi_stat_print_ex(&stats->committed, \"committed\", 1, out, arg, \"\");\n  mi_stat_peak_print(&stats->reset, \"reset\", 1, out, arg);\n  mi_stat_peak_print(&stats->purged, \"purged\", 1, out, arg);\n  mi_stat_print_ex(&stats->page_committed, \"touched\", 1, out, arg, \"\");\n  mi_stat_print(&stats->segments, \"segments\", -1, out, arg);\n  mi_stat_print(&stats->segments_abandoned, \"-abandoned\", -1, out, arg);\n  mi_stat_print(&stats->segments_cache, \"-cached\", -1, out, arg);\n  mi_stat_print(&stats->pages, \"pages\", -1, out, arg);\n  mi_stat_print(&stats->pages_abandoned, \"-abandoned\", -1, out, arg);\n  mi_stat_counter_print(&stats->pages_extended, \"-extended\", out, arg);\n  mi_stat_counter_print(&stats->pages_retire, \"-retire\", out, arg);\n  mi_stat_counter_print(&stats->arena_count, \"arenas\", out, arg);\n  mi_stat_counter_print(&stats->arena_rollback_count, \"-rollback\", out, arg);\n  mi_stat_counter_print(&stats->mmap_calls, \"mmaps\", out, arg);\n  mi_stat_counter_print(&stats->commit_calls, \"commits\", out, arg);\n  mi_stat_counter_print(&stats->reset_calls, \"resets\", out, arg);\n  mi_stat_counter_print(&stats->purge_calls, \"purges\", out, arg);\n  mi_stat_counter_print(&stats->malloc_guarded_count, \"guarded\", out, arg);\n  mi_stat_print(&stats->threads, \"threads\", -1, out, arg);\n  mi_stat_counter_print_avg(&stats->page_searches, \"searches\", out, arg);\n  _mi_fprintf(out, arg, \"%10s: %5i\\n\", \"numa nodes\", _mi_os_numa_node_count());\n  size_t elapsed;\n  size_t user_time;\n  size_t sys_time;\n  size_t current_rss;\n  size_t peak_rss;\n  size_t current_commit;\n  size_t peak_commit;\n  size_t page_faults;\n  mi_process_info(&elapsed, &user_time, &sys_time, &current_rss, &peak_rss, &current_commit, &peak_commit, &page_faults);\n  _mi_fprintf(out, arg, \"%10s: %5zu.%03zu s\\n\", \"elapsed\", elapsed / 1000, elapsed % 1000);\n  _mi_fprintf(out, arg, \"%10s: user: %zu.%03zu s, system: %zu.%03zu s, faults: %zu, rss: \", \"process\", user_time / 1000, user_time % 1000, sys_time / 1000, sys_time % 1000, page_faults);\n  mi_printf_amount((int64_t) peak_rss, 1, out, arg, \"%s\");\n  if (peak_commit > 0)\n  {\n    _mi_fprintf(out, arg, \", commit: \");\n    mi_printf_amount((int64_t) peak_commit, 1, out, arg, \"%s\");\n  }\n  _mi_fprintf(out, arg, \"\\n\");\n}\n\n",
            "calle": [
                "_mi_fprintf",
                "_mi_os_numa_node_count",
                "mi_buffered_out",
                "mi_print_header",
                "mi_printf_amount",
                "mi_process_info",
                "mi_stat_count_add_mt",
                "mi_stat_counter_print",
                "mi_stat_counter_print_avg",
                "mi_stat_peak_print",
                "mi_stat_print",
                "mi_stat_print_ex",
                "mi_stat_total_print",
                "mi_stats_print_bins"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stats",
                        "type": "mi_stats_t *",
                        "definition": [
                            "mi_stats_t *stats"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out0",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg0",
                        "type": "void *",
                        "definition": [
                            "void *arg0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char [256]",
                        "definition": [
                            "char buf[256]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buffer",
                        "type": "buffered_t",
                        "definition": [
                            "buffered_t buffer = {out0, arg0, 0, 0, 255}"
                        ]
                    },
                    {
                        "path": null,
                        "name": "out",
                        "type": "mi_output_fun *",
                        "definition": [
                            "mi_output_fun *out = &mi_buffered_out"
                        ]
                    },
                    {
                        "path": null,
                        "name": "arg",
                        "type": "void *",
                        "definition": [
                            "void *arg = &buffer"
                        ]
                    },
                    {
                        "path": null,
                        "name": "total",
                        "type": "mi_stat_count_t",
                        "definition": [
                            "mi_stat_count_t total = {0, 0, 0}"
                        ]
                    },
                    {
                        "path": null,
                        "name": "elapsed",
                        "type": "size_t",
                        "definition": [
                            "size_t elapsed"
                        ]
                    },
                    {
                        "path": null,
                        "name": "user_time",
                        "type": "size_t",
                        "definition": [
                            "size_t user_time"
                        ]
                    },
                    {
                        "path": null,
                        "name": "sys_time",
                        "type": "size_t",
                        "definition": [
                            "size_t sys_time"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current_rss",
                        "type": "size_t",
                        "definition": [
                            "size_t current_rss"
                        ]
                    },
                    {
                        "path": null,
                        "name": "peak_rss",
                        "type": "size_t",
                        "definition": [
                            "size_t peak_rss"
                        ]
                    },
                    {
                        "path": null,
                        "name": "current_commit",
                        "type": "size_t",
                        "definition": [
                            "size_t current_commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "peak_commit",
                        "type": "size_t",
                        "definition": [
                            "size_t peak_commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "page_faults",
                        "type": "size_t",
                        "definition": [
                            "size_t page_faults"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stats_get_default",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static mi_stats_t *mi_stats_get_default(void)\n{\n  mi_heap_t *heap = mi_heap_get_default();\n  return &heap->tld->stats;\n}\n\n",
            "calle": [
                "mi_heap_get_default"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap = mi_heap_get_default()"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_stats_merge_from",
            "header": "",
            "params": [
                "mi_stats_t *stats"
            ],
            "definition": "static void mi_stats_merge_from(mi_stats_t *stats)\n{\n  if (stats != (&_mi_stats_main))\n  {\n    mi_stats_add(&_mi_stats_main, stats);\n    memset(stats, 0, sizeof(mi_stats_t));\n  }\n}\n\n",
            "calle": [
                "memset",
                "mi_stats_add"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "stats",
                        "type": "mi_stats_t *",
                        "definition": [
                            "mi_stats_t *stats"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_stats_main",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_buf_expand",
            "header": "",
            "params": [
                "mi_heap_buf_t *hbuf"
            ],
            "definition": "static bool mi_heap_buf_expand(mi_heap_buf_t *hbuf)\n{\n  if (hbuf == 0)\n  {\n    return 0;\n  }\n  if ((hbuf->buf != 0) && (hbuf->size > 0))\n  {\n    hbuf->buf[hbuf->size - 1] = 0;\n  }\n  if ((hbuf->size > (SIZE_MAX / 2)) || (!hbuf->can_realloc))\n  {\n    return 0;\n  }\n  const size_t newsize = (hbuf->size == 0) ? (mi_good_size(12 * 1024UL)) : (2 * hbuf->size);\n  char * const newbuf = (char *) mi_rezalloc(hbuf->buf, newsize);\n  if (newbuf == 0)\n  {\n    return 0;\n  }\n  hbuf->buf = newbuf;\n  hbuf->size = newsize;\n  return 1;\n}\n\n",
            "calle": [
                "mi_good_size",
                "mi_rezalloc"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "hbuf",
                        "type": "mi_heap_buf_t *",
                        "definition": [
                            "mi_heap_buf_t *hbuf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t newsize = (hbuf->size == 0) ? (mi_good_size(12 * 1024UL)) : (2 * hbuf->size)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "newbuf",
                        "type": "char * const",
                        "definition": [
                            "char * const newbuf = (char *) mi_rezalloc(hbuf->buf, newsize)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_buf_print",
            "header": "",
            "params": [
                "mi_heap_buf_t *hbuf",
                "const char *msg"
            ],
            "definition": "static void mi_heap_buf_print(mi_heap_buf_t *hbuf, const char *msg)\n{\n  if ((msg == 0) || (hbuf == 0))\n  {\n    return;\n  }\n  if (((hbuf->used + 1) >= hbuf->size) && (!hbuf->can_realloc))\n  {\n    return;\n  }\n  for (const char *src = msg; src[src_idx] != 0; src_idx += 1)\n  {\n    char c = src[src_idx];\n    if ((hbuf->used + 1) >= hbuf->size)\n    {\n      if (!mi_heap_buf_expand(hbuf))\n      {\n        return;\n      }\n    }\n    (hbuf->used < hbuf->size) ? ((void) 0) : (_mi_assert_fail(\"hbuf->used < hbuf->size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/stats.c\", 523, __func__));\n    hbuf->buf[hbuf->used++] = c;\n  }\n\n  unsigned int src_idx = 0;\n  (hbuf->used < hbuf->size) ? ((void) 0) : (_mi_assert_fail(\"hbuf->used < hbuf->size\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/stats.c\", 526, __func__));\n  hbuf->buf[hbuf->used] = 0;\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_heap_buf_expand"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "hbuf",
                        "type": "mi_heap_buf_t *",
                        "definition": [
                            "mi_heap_buf_t *hbuf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "msg",
                        "type": "const char *",
                        "definition": [
                            "const char *msg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "src",
                        "type": "const char *",
                        "definition": [
                            "const char *src = msg"
                        ]
                    },
                    {
                        "path": null,
                        "name": "c",
                        "type": "char",
                        "definition": [
                            "char c = src[src_idx]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "src_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int src_idx = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_buf_print_count_bin",
            "header": "",
            "params": [
                "mi_heap_buf_t *hbuf",
                "const char *prefix",
                "mi_stat_count_t *stat",
                "size_t bin",
                "bool add_comma"
            ],
            "definition": "static void mi_heap_buf_print_count_bin(mi_heap_buf_t *hbuf, const char *prefix, mi_stat_count_t *stat, size_t bin, bool add_comma)\n{\n  const size_t binsize = _mi_bin_size(bin);\n  const size_t pagesize = (binsize <= ((1UL << (13 + 3)) / 8)) ? (1UL << (13 + 3)) : ((binsize <= ((1UL << (3 + (13 + 3))) / 8)) ? (1UL << (3 + (13 + 3))) : (0));\n  char buf[128];\n  _mi_snprintf(buf, 128, \"%s{ \\\"total\\\": %lld, \\\"peak\\\": %lld, \\\"current\\\": %lld, \\\"block_size\\\": %zu, \\\"page_size\\\": %zu }%s\\n\", prefix, stat->total, stat->peak, stat->current, binsize, pagesize, (add_comma) ? (\",\") : (\"\"));\n  buf[127] = 0;\n  mi_heap_buf_print(hbuf, buf);\n}\n\n",
            "calle": [
                "_mi_bin_size",
                "_mi_snprintf",
                "mi_heap_buf_print"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "hbuf",
                        "type": "mi_heap_buf_t *",
                        "definition": [
                            "mi_heap_buf_t *hbuf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prefix",
                        "type": "const char *",
                        "definition": [
                            "const char *prefix"
                        ]
                    },
                    {
                        "path": null,
                        "name": "stat",
                        "type": "mi_stat_count_t *",
                        "definition": [
                            "mi_stat_count_t *stat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bin",
                        "type": "size_t",
                        "definition": [
                            "size_t bin"
                        ]
                    },
                    {
                        "path": null,
                        "name": "add_comma",
                        "type": "bool",
                        "definition": [
                            "bool add_comma"
                        ]
                    },
                    {
                        "path": null,
                        "name": "binsize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t binsize = _mi_bin_size(bin)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "pagesize",
                        "type": "const size_t",
                        "definition": [
                            "const size_t pagesize = (binsize <= ((1UL << (13 + 3)) / 8)) ? (1UL << (13 + 3)) : ((binsize <= ((1UL << (3 + (13 + 3))) / 8)) ? (1UL << (3 + (13 + 3))) : (0))"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char [128]",
                        "definition": [
                            "char buf[128]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_buf_print_count",
            "header": "",
            "params": [
                "mi_heap_buf_t *hbuf",
                "const char *prefix",
                "mi_stat_count_t *stat",
                "bool add_comma"
            ],
            "definition": "static void mi_heap_buf_print_count(mi_heap_buf_t *hbuf, const char *prefix, mi_stat_count_t *stat, bool add_comma)\n{\n  char buf[128];\n  _mi_snprintf(buf, 128, \"%s{ \\\"total\\\": %lld, \\\"peak\\\": %lld, \\\"current\\\": %lld }%s\\n\", prefix, stat->total, stat->peak, stat->current, (add_comma) ? (\",\") : (\"\"));\n  buf[127] = 0;\n  mi_heap_buf_print(hbuf, buf);\n}\n\n",
            "calle": [
                "_mi_snprintf",
                "mi_heap_buf_print"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "hbuf",
                        "type": "mi_heap_buf_t *",
                        "definition": [
                            "mi_heap_buf_t *hbuf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "prefix",
                        "type": "const char *",
                        "definition": [
                            "const char *prefix"
                        ]
                    },
                    {
                        "path": null,
                        "name": "stat",
                        "type": "mi_stat_count_t *",
                        "definition": [
                            "mi_stat_count_t *stat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "add_comma",
                        "type": "bool",
                        "definition": [
                            "bool add_comma"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char [128]",
                        "definition": [
                            "char buf[128]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_buf_print_count_value",
            "header": "",
            "params": [
                "mi_heap_buf_t *hbuf",
                "const char *name",
                "mi_stat_count_t *stat"
            ],
            "definition": "static void mi_heap_buf_print_count_value(mi_heap_buf_t *hbuf, const char *name, mi_stat_count_t *stat)\n{\n  char buf[128];\n  _mi_snprintf(buf, 128, \"  \\\"%s\\\": \", name);\n  buf[127] = 0;\n  mi_heap_buf_print(hbuf, buf);\n  mi_heap_buf_print_count(hbuf, \"\", stat, 1);\n}\n\n",
            "calle": [
                "_mi_snprintf",
                "mi_heap_buf_print",
                "mi_heap_buf_print_count"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "hbuf",
                        "type": "mi_heap_buf_t *",
                        "definition": [
                            "mi_heap_buf_t *hbuf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "name",
                        "type": "const char *",
                        "definition": [
                            "const char *name"
                        ]
                    },
                    {
                        "path": null,
                        "name": "stat",
                        "type": "mi_stat_count_t *",
                        "definition": [
                            "mi_stat_count_t *stat"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char [128]",
                        "definition": [
                            "char buf[128]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_buf_print_value",
            "header": "",
            "params": [
                "mi_heap_buf_t *hbuf",
                "const char *name",
                "int64_t val"
            ],
            "definition": "static void mi_heap_buf_print_value(mi_heap_buf_t *hbuf, const char *name, int64_t val)\n{\n  char buf[128];\n  _mi_snprintf(buf, 128, \"  \\\"%s\\\": %lld,\\n\", name, val);\n  buf[127] = 0;\n  mi_heap_buf_print(hbuf, buf);\n}\n\n",
            "calle": [
                "_mi_snprintf",
                "mi_heap_buf_print"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "hbuf",
                        "type": "mi_heap_buf_t *",
                        "definition": [
                            "mi_heap_buf_t *hbuf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "name",
                        "type": "const char *",
                        "definition": [
                            "const char *name"
                        ]
                    },
                    {
                        "path": null,
                        "name": "val",
                        "type": "int64_t",
                        "definition": [
                            "int64_t val"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char [128]",
                        "definition": [
                            "char buf[128]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_buf_print_size",
            "header": "",
            "params": [
                "mi_heap_buf_t *hbuf",
                "const char *name",
                "size_t val",
                "bool add_comma"
            ],
            "definition": "static void mi_heap_buf_print_size(mi_heap_buf_t *hbuf, const char *name, size_t val, bool add_comma)\n{\n  char buf[128];\n  _mi_snprintf(buf, 128, \"    \\\"%s\\\": %zu%s\\n\", name, val, (add_comma) ? (\",\") : (\"\"));\n  buf[127] = 0;\n  mi_heap_buf_print(hbuf, buf);\n}\n\n",
            "calle": [
                "_mi_snprintf",
                "mi_heap_buf_print"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "hbuf",
                        "type": "mi_heap_buf_t *",
                        "definition": [
                            "mi_heap_buf_t *hbuf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "name",
                        "type": "const char *",
                        "definition": [
                            "const char *name"
                        ]
                    },
                    {
                        "path": null,
                        "name": "val",
                        "type": "size_t",
                        "definition": [
                            "size_t val"
                        ]
                    },
                    {
                        "path": null,
                        "name": "add_comma",
                        "type": "bool",
                        "definition": [
                            "bool add_comma"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char [128]",
                        "definition": [
                            "char buf[128]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_heap_buf_print_counter_value",
            "header": "",
            "params": [
                "mi_heap_buf_t *hbuf",
                "const char *name",
                "mi_stat_counter_t *stat"
            ],
            "definition": "static void mi_heap_buf_print_counter_value(mi_heap_buf_t *hbuf, const char *name, mi_stat_counter_t *stat)\n{\n  mi_heap_buf_print_value(hbuf, name, stat->total);\n}\n\n",
            "calle": [
                "mi_heap_buf_print_value"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "hbuf",
                        "type": "mi_heap_buf_t *",
                        "definition": [
                            "mi_heap_buf_t *hbuf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "name",
                        "type": "const char *",
                        "definition": [
                            "const char *name"
                        ]
                    },
                    {
                        "path": null,
                        "name": "stat",
                        "type": "mi_stat_counter_t *",
                        "definition": [
                            "mi_stat_counter_t *stat"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_is_redirected",
            "header": "bool _mi_is_redirected(void)",
            "params": [
                "void"
            ],
            "definition": "bool _mi_is_redirected(void)\n{\n  return 0;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_allocator_init",
            "header": "bool _mi_allocator_init(const char **message)",
            "params": [
                "const char **message"
            ],
            "definition": "bool _mi_allocator_init(const char **message)\n{\n  if (message != 0)\n  {\n    *message = 0;\n  }\n  return 1;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "message",
                        "type": "const char **",
                        "definition": [
                            "const char **message"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_allocator_done",
            "header": "void _mi_allocator_done(void)",
            "params": [
                "void"
            ],
            "definition": "void _mi_allocator_done(void)\n{\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_mem_init",
            "header": "void _mi_prim_mem_init(mi_os_mem_config_t *config)",
            "params": [
                "mi_os_mem_config_t *config"
            ],
            "definition": "void _mi_prim_mem_init(mi_os_mem_config_t *config)\n{\n  long psize = sysconf(_SC_PAGESIZE);\n  if (psize > 0)\n  {\n    config->page_size = (size_t) psize;\n    config->alloc_granularity = (size_t) psize;\n  }\n  config->large_page_size = 2 * (1024UL * 1024UL);\n  config->has_overcommit = unix_detect_overcommit();\n  config->has_partial_free = 1;\n  config->has_virtual_reserve = 1;\n}\n\n",
            "calle": [
                "sysconf",
                "unix_detect_overcommit"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "config",
                        "type": "mi_os_mem_config_t *",
                        "definition": [
                            "mi_os_mem_config_t *config"
                        ]
                    },
                    {
                        "path": null,
                        "name": "psize",
                        "type": "long",
                        "definition": [
                            "long psize = sysconf(_SC_PAGESIZE)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_free",
            "header": "int _mi_prim_free(void *addr, size_t size)",
            "params": [
                "void *addr",
                "size_t size"
            ],
            "definition": "int _mi_prim_free(void *addr, size_t size)\n{\n  if (size == 0)\n  {\n    return 0;\n  }\n  bool err = munmap(addr, size) == (-1);\n  return (err) ? (errno) : (0);\n}\n\n",
            "calle": [
                "munmap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "err",
                        "type": "bool",
                        "definition": [
                            "bool err = munmap(addr, size) == (-1)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_alloc",
            "header": "int _mi_prim_alloc(void *hint_addr, size_t size, size_t try_alignment, bool commit, bool allow_large, bool *is_large, bool *is_zero, void **addr)",
            "params": [
                "void *hint_addr",
                "size_t size",
                "size_t try_alignment",
                "bool commit",
                "bool allow_large",
                "bool *is_large",
                "bool *is_zero",
                "void **addr"
            ],
            "definition": "int _mi_prim_alloc(void *hint_addr, size_t size, size_t try_alignment, bool commit, bool allow_large, bool *is_large, bool *is_zero, void **addr)\n{\n  ((size > 0) && ((size % _mi_os_page_size()) == 0)) ? ((void) 0) : (_mi_assert_fail(\"size > 0 && (size % _mi_os_page_size()) == 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/prim/unix/prim.c\", 387, __func__));\n  (commit || (!allow_large)) ? ((void) 0) : (_mi_assert_fail(\"commit || !allow_large\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/prim/unix/prim.c\", 388, __func__));\n  (try_alignment > 0) ? ((void) 0) : (_mi_assert_fail(\"try_alignment > 0\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/prim/unix/prim.c\", 389, __func__));\n  if (((((hint_addr == 0) && (size >= (8 * (2 * (1024UL * 1024UL))))) && (try_alignment > 1)) && _mi_is_power_of_two(try_alignment)) && (try_alignment < (2 * (1024UL * 1024UL))))\n  {\n    try_alignment = 2 * (1024UL * 1024UL);\n  }\n  *is_zero = 1;\n  int protect_flags = (commit) ? (PROT_WRITE | PROT_READ) : (PROT_NONE);\n  *addr = unix_mmap(hint_addr, size, try_alignment, protect_flags, 0, allow_large, is_large);\n  return ((*addr) != 0) ? (0) : (errno);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "_mi_is_power_of_two",
                "_mi_os_page_size",
                "unix_mmap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "hint_addr",
                        "type": "void *",
                        "definition": [
                            "void *hint_addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "try_alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t try_alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "commit",
                        "type": "bool",
                        "definition": [
                            "bool commit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_large",
                        "type": "bool",
                        "definition": [
                            "bool allow_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_large",
                        "type": "bool *",
                        "definition": [
                            "bool *is_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_zero",
                        "type": "bool *",
                        "definition": [
                            "bool *is_zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void **",
                        "definition": [
                            "void **addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "protect_flags",
                        "type": "int",
                        "definition": [
                            "int protect_flags = (commit) ? (PROT_WRITE | PROT_READ) : (PROT_NONE)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_commit",
            "header": "int _mi_prim_commit(void *addr, size_t size, bool *is_zero)",
            "params": [
                "void *start",
                "size_t size",
                "bool *is_zero"
            ],
            "definition": "int _mi_prim_commit(void *start, size_t size, bool *is_zero)\n{\n  *is_zero = 0;\n  int err = mprotect(start, size, PROT_READ | PROT_WRITE);\n  if (err != 0)\n  {\n    err = errno;\n    unix_mprotect_hint(err);\n  }\n  return err;\n}\n\n",
            "calle": [
                "mprotect",
                "unix_mprotect_hint"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "start",
                        "type": "void *",
                        "definition": [
                            "void *start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_zero",
                        "type": "bool *",
                        "definition": [
                            "bool *is_zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "err",
                        "type": "int",
                        "definition": [
                            "int err = mprotect(start, size, PROT_READ | PROT_WRITE)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_decommit",
            "header": "int _mi_prim_decommit(void *addr, size_t size, bool *needs_recommit)",
            "params": [
                "void *start",
                "size_t size",
                "bool *needs_recommit"
            ],
            "definition": "int _mi_prim_decommit(void *start, size_t size, bool *needs_recommit)\n{\n  int err = 0;\n  err = unix_madvise(start, size, MADV_DONTNEED);\n  *needs_recommit = 1;\n  mprotect(start, size, PROT_NONE);\n  return err;\n}\n\n",
            "calle": [
                "mprotect",
                "unix_madvise"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "start",
                        "type": "void *",
                        "definition": [
                            "void *start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "needs_recommit",
                        "type": "bool *",
                        "definition": [
                            "bool *needs_recommit"
                        ]
                    },
                    {
                        "path": null,
                        "name": "err",
                        "type": "int",
                        "definition": [
                            "int err = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_reset",
            "header": "int _mi_prim_reset(void *addr, size_t size)",
            "params": [
                "void *start",
                "size_t size"
            ],
            "definition": "int _mi_prim_reset(void *start, size_t size)\n{\n  int err = 0;\n  err = unix_madvise(start, size, MADV_DONTNEED);\n  return err;\n}\n\n",
            "calle": [
                "unix_madvise"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "start",
                        "type": "void *",
                        "definition": [
                            "void *start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "err",
                        "type": "int",
                        "definition": [
                            "int err = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_reuse",
            "header": "int _mi_prim_reuse(void *addr, size_t size)",
            "params": [
                "void *start",
                "size_t size"
            ],
            "definition": "int _mi_prim_reuse(void *start, size_t size)\n{\n  (void) start;\n  (void) size;\n  return 0;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "start",
                        "type": "void *",
                        "definition": [
                            "void *start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_protect",
            "header": "int _mi_prim_protect(void *addr, size_t size, bool protect)",
            "params": [
                "void *start",
                "size_t size",
                "bool protect"
            ],
            "definition": "int _mi_prim_protect(void *start, size_t size, bool protect)\n{\n  int err = mprotect(start, size, (protect) ? (PROT_NONE) : (PROT_READ | PROT_WRITE));\n  if (err != 0)\n  {\n    err = errno;\n  }\n  unix_mprotect_hint(err);\n  return err;\n}\n\n",
            "calle": [
                "mprotect",
                "unix_mprotect_hint"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "start",
                        "type": "void *",
                        "definition": [
                            "void *start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "protect",
                        "type": "bool",
                        "definition": [
                            "bool protect"
                        ]
                    },
                    {
                        "path": null,
                        "name": "err",
                        "type": "int",
                        "definition": [
                            "int err = mprotect(start, size, (protect) ? (PROT_NONE) : (PROT_READ | PROT_WRITE))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_alloc_huge_os_pages",
            "header": "int _mi_prim_alloc_huge_os_pages(void *hint_addr, size_t size, int numa_node, bool *is_zero, void **addr)",
            "params": [
                "void *hint_addr",
                "size_t size",
                "int numa_node",
                "bool *is_zero",
                "void **addr"
            ],
            "definition": "int _mi_prim_alloc_huge_os_pages(void *hint_addr, size_t size, int numa_node, bool *is_zero, void **addr)\n{\n  bool is_large = 1;\n  *is_zero = 1;\n  *addr = unix_mmap(hint_addr, size, 1UL << (9 + (13 + 3)), PROT_READ | PROT_WRITE, 1, 1, &is_large);\n  if ((((*addr) != 0) && (numa_node >= 0)) && (numa_node < (8 * (1 << 3))))\n  {\n    unsigned long numa_mask = 1UL << numa_node;\n    long err = mi_prim_mbind(*addr, size, 1, &numa_mask, 8 * (1 << 3), 0);\n    if (err != 0)\n    {\n      err = errno;\n      _mi_warning_message(\"failed to bind huge (1GiB) pages to numa node %d (error: %d (0x%x))\\n\", numa_node, err, err);\n    }\n  }\n  return ((*addr) != 0) ? (0) : (errno);\n}\n\n",
            "calle": [
                "_mi_warning_message",
                "mi_prim_mbind",
                "unix_mmap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "hint_addr",
                        "type": "void *",
                        "definition": [
                            "void *hint_addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numa_node",
                        "type": "int",
                        "definition": [
                            "int numa_node"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_zero",
                        "type": "bool *",
                        "definition": [
                            "bool *is_zero"
                        ]
                    },
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void **",
                        "definition": [
                            "void **addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_large",
                        "type": "bool",
                        "definition": [
                            "bool is_large = 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "numa_mask",
                        "type": "unsigned long",
                        "definition": [
                            "unsigned long numa_mask = 1UL << numa_node"
                        ]
                    },
                    {
                        "path": null,
                        "name": "err",
                        "type": "long",
                        "definition": [
                            "long err = mi_prim_mbind(*addr, size, 1, &numa_mask, 8 * (1 << 3), 0)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_numa_node",
            "header": "size_t _mi_prim_numa_node(void)",
            "params": [
                "void"
            ],
            "definition": "size_t _mi_prim_numa_node(void)\n{\n  return 0;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_numa_node_count",
            "header": "size_t _mi_prim_numa_node_count(void)",
            "params": [
                "void"
            ],
            "definition": "size_t _mi_prim_numa_node_count(void)\n{\n  char buf[128];\n  unsigned node = 0;\n  for (node = 0; node < 256; node += 1)\n  {\n    _mi_snprintf(buf, 127, \"/sys/devices/system/node/node%u\", node + 1);\n    if (mi_prim_access(buf, R_OK) != 0)\n    {\n      break;\n    }\n  }\n\n  return node + 1;\n}\n\n",
            "calle": [
                "_mi_snprintf",
                "mi_prim_access"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char [128]",
                        "definition": [
                            "char buf[128]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "node",
                        "type": "unsigned",
                        "definition": [
                            "unsigned node = 0"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_clock_now",
            "header": "mi_msecs_t _mi_prim_clock_now(void)",
            "params": [
                "void"
            ],
            "definition": "mi_msecs_t _mi_prim_clock_now(void)\n{\n  return (mi_msecs_t) clock();\n}\n\n",
            "calle": [
                "clock"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_process_info",
            "header": "void _mi_prim_process_info(mi_process_info_t *pinfo)",
            "params": [
                "mi_process_info_t *pinfo"
            ],
            "definition": "void _mi_prim_process_info(mi_process_info_t *pinfo)\n{\n  struct rusage rusage;\n  getrusage(RUSAGE_SELF, &rusage);\n  pinfo->utime = timeval_secs(&rusage.ru_utime);\n  pinfo->stime = timeval_secs(&rusage.ru_stime);\n  pinfo->page_faults = rusage.ru_majflt;\n  pinfo->peak_rss = rusage.ru_maxrss * 1024;\n}\n\n",
            "calle": [
                "getrusage",
                "timeval_secs"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "pinfo",
                        "type": "mi_process_info_t *",
                        "definition": [
                            "mi_process_info_t *pinfo"
                        ]
                    },
                    {
                        "path": null,
                        "name": "rusage",
                        "type": "struct rusage",
                        "definition": [
                            "struct rusage rusage"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_out_stderr",
            "header": "void _mi_prim_out_stderr(const char *msg)",
            "params": [
                "const char *msg"
            ],
            "definition": "void _mi_prim_out_stderr(const char *msg)\n{\n  fputs(msg, stderr);\n}\n\n",
            "calle": [
                "fputs"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "msg",
                        "type": "const char *",
                        "definition": [
                            "const char *msg"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_getenv",
            "header": "bool _mi_prim_getenv(const char *name, char *result, size_t result_size)",
            "params": [
                "const char *name",
                "char *result",
                "size_t result_size"
            ],
            "definition": "bool _mi_prim_getenv(const char *name, char *result, size_t result_size)\n{\n  if (name == 0)\n  {\n    return 0;\n  }\n  const size_t len = _mi_strlen(name);\n  if (len == 0)\n  {\n    return 0;\n  }\n  char **env = mi_get_environ();\n  if (env == 0)\n  {\n    return 0;\n  }\n  for (int i = 0; (i < 10000) && (env[i] != 0); i += 1)\n  {\n    const char *s = env[i];\n    if ((_mi_strnicmp(name, s, len) == 0) && (s[len] == '='))\n    {\n      _mi_strlcpy(result, (s + len) + 1, result_size);\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\n",
            "calle": [
                "_mi_strlcpy",
                "_mi_strlen",
                "_mi_strnicmp",
                "mi_get_environ"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "name",
                        "type": "const char *",
                        "definition": [
                            "const char *name"
                        ]
                    },
                    {
                        "path": null,
                        "name": "result",
                        "type": "char *",
                        "definition": [
                            "char *result"
                        ]
                    },
                    {
                        "path": null,
                        "name": "result_size",
                        "type": "size_t",
                        "definition": [
                            "size_t result_size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "len",
                        "type": "const size_t",
                        "definition": [
                            "const size_t len = _mi_strlen(name)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "env",
                        "type": "char **",
                        "definition": [
                            "char **env = mi_get_environ()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "i",
                        "type": "int",
                        "definition": [
                            "int i = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "s",
                        "type": "const char *",
                        "definition": [
                            "const char *s = env[i]"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_random_buf",
            "header": "bool _mi_prim_random_buf(void *buf, size_t buf_len)",
            "params": [
                "void *buf",
                "size_t buf_len"
            ],
            "definition": "bool _mi_prim_random_buf(void *buf, size_t buf_len)\n{\n  int flags = O_RDONLY;\n  int fd = mi_prim_open(\"/dev/urandom\", flags);\n  if (fd < 0)\n  {\n    return 0;\n  }\n  size_t count = 0;\n  while (count < buf_len)\n  {\n    ssize_t ret = mi_prim_read(fd, ((char *) buf) + count, buf_len - count);\n    if (ret <= 0)\n    {\n      if ((errno != 11) && (errno != EINTR))\n      {\n        break;\n      }\n    }\n    else\n    {\n      count += ret;\n    }\n  }\n\n  mi_prim_close(fd);\n  return count == buf_len;\n}\n\n",
            "calle": [
                "mi_prim_close",
                "mi_prim_open",
                "mi_prim_read"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "buf",
                        "type": "void *",
                        "definition": [
                            "void *buf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf_len",
                        "type": "size_t",
                        "definition": [
                            "size_t buf_len"
                        ]
                    },
                    {
                        "path": null,
                        "name": "flags",
                        "type": "int",
                        "definition": [
                            "int flags = O_RDONLY"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fd",
                        "type": "int",
                        "definition": [
                            "int fd = mi_prim_open(\"/dev/urandom\", flags)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "count",
                        "type": "size_t",
                        "definition": [
                            "size_t count = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "ret",
                        "type": "ssize_t",
                        "definition": [
                            "ssize_t ret = mi_prim_read(fd, ((char *) buf) + count, buf_len - count)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_thread_init_auto_done",
            "header": "void _mi_prim_thread_init_auto_done(void)",
            "params": [
                "void"
            ],
            "definition": "void _mi_prim_thread_init_auto_done(void)\n{\n  (_mi_heap_default_key == ((pthread_key_t) (-1))) ? ((void) 0) : (_mi_assert_fail(\"_mi_heap_default_key == (pthread_key_t)(-1)\", \"/home/ubuntu/C2RustTranslation/subjects/mimalloc/src/prim/unix/prim.c\", 904, __func__));\n  pthread_key_create(&_mi_heap_default_key, &mi_pthread_done);\n}\n\n",
            "calle": [
                "_mi_assert_fail",
                "mi_pthread_done",
                "pthread_key_create"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_default_key",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_thread_done_auto_done",
            "header": "void _mi_prim_thread_done_auto_done(void)",
            "params": [
                "void"
            ],
            "definition": "void _mi_prim_thread_done_auto_done(void)\n{\n  if (_mi_heap_default_key != ((pthread_key_t) (-1)))\n  {\n    pthread_key_delete(_mi_heap_default_key);\n  }\n}\n\n",
            "calle": [
                "pthread_key_delete"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_default_key",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "_mi_prim_thread_associate_default_heap",
            "header": "void _mi_prim_thread_associate_default_heap(mi_heap_t *heap)",
            "params": [
                "mi_heap_t *heap"
            ],
            "definition": "void _mi_prim_thread_associate_default_heap(mi_heap_t *heap)\n{\n  if (_mi_heap_default_key != ((pthread_key_t) (-1)))\n  {\n    pthread_setspecific(_mi_heap_default_key, heap);\n  }\n}\n\n",
            "calle": [
                "pthread_setspecific"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "heap",
                        "type": "mi_heap_t *",
                        "definition": [
                            "mi_heap_t *heap"
                        ]
                    },
                    {
                        "path": null,
                        "name": "_mi_heap_default_key",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_prim_open",
            "header": "",
            "params": [
                "const char *fpath",
                "int open_flags"
            ],
            "definition": "inline static int mi_prim_open(const char *fpath, int open_flags)\n{\n  return open(fpath, open_flags);\n}\n\n",
            "calle": [
                "open"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "fpath",
                        "type": "const char *",
                        "definition": [
                            "const char *fpath"
                        ]
                    },
                    {
                        "path": null,
                        "name": "open_flags",
                        "type": "int",
                        "definition": [
                            "int open_flags"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_prim_read",
            "header": "",
            "params": [
                "int fd",
                "void *buf",
                "size_t bufsize"
            ],
            "definition": "inline static ssize_t mi_prim_read(int fd, void *buf, size_t bufsize)\n{\n  return read(fd, buf, bufsize);\n}\n\n",
            "calle": [
                "read"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "fd",
                        "type": "int",
                        "definition": [
                            "int fd"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf",
                        "type": "void *",
                        "definition": [
                            "void *buf"
                        ]
                    },
                    {
                        "path": null,
                        "name": "bufsize",
                        "type": "size_t",
                        "definition": [
                            "size_t bufsize"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_prim_close",
            "header": "",
            "params": [
                "int fd"
            ],
            "definition": "inline static int mi_prim_close(int fd)\n{\n  return close(fd);\n}\n\n",
            "calle": [
                "close"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "fd",
                        "type": "int",
                        "definition": [
                            "int fd"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_prim_access",
            "header": "",
            "params": [
                "const char *fpath",
                "int mode"
            ],
            "definition": "inline static int mi_prim_access(const char *fpath, int mode)\n{\n  return access(fpath, mode);\n}\n\n",
            "calle": [
                "access"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "fpath",
                        "type": "const char *",
                        "definition": [
                            "const char *fpath"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mode",
                        "type": "int",
                        "definition": [
                            "int mode"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "unix_detect_overcommit",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static bool unix_detect_overcommit(void)\n{\n  bool os_overcommit = 1;\n  int fd = mi_prim_open(\"/proc/sys/vm/overcommit_memory\", O_RDONLY);\n  if (fd >= 0)\n  {\n    char buf[32];\n    ssize_t nread = mi_prim_read(fd, &buf, sizeof(buf));\n    mi_prim_close(fd);\n    if (nread >= 1)\n    {\n      os_overcommit = (buf[0] == '0') || (buf[0] == '1');\n    }\n  }\n  return os_overcommit;\n}\n\n",
            "calle": [
                "mi_prim_close",
                "mi_prim_open",
                "mi_prim_read"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "os_overcommit",
                        "type": "bool",
                        "definition": [
                            "bool os_overcommit = 1"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fd",
                        "type": "int",
                        "definition": [
                            "int fd = mi_prim_open(\"/proc/sys/vm/overcommit_memory\", O_RDONLY)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "buf",
                        "type": "char [32]",
                        "definition": [
                            "char buf[32]"
                        ]
                    },
                    {
                        "path": null,
                        "name": "nread",
                        "type": "ssize_t",
                        "definition": [
                            "ssize_t nread = mi_prim_read(fd, &buf, sizeof(buf))"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "unix_madvise",
            "header": "",
            "params": [
                "void *addr",
                "size_t size",
                "int advice"
            ],
            "definition": "static int unix_madvise(void *addr, size_t size, int advice)\n{\n  int res = madvise(addr, size, advice);\n  return (res == 0) ? (0) : (errno);\n}\n\n",
            "calle": [
                "madvise"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "advice",
                        "type": "int",
                        "definition": [
                            "int advice"
                        ]
                    },
                    {
                        "path": null,
                        "name": "res",
                        "type": "int",
                        "definition": [
                            "int res = madvise(addr, size, advice)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "unix_mmap_prim",
            "header": "",
            "params": [
                "void *addr",
                "size_t size",
                "int protect_flags",
                "int flags",
                "int fd"
            ],
            "definition": "static void *unix_mmap_prim(void *addr, size_t size, int protect_flags, int flags, int fd)\n{\n  void *p = mmap(addr, size, protect_flags, flags, fd, 0);\n  return p;\n}\n\n",
            "calle": [
                "mmap"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "protect_flags",
                        "type": "int",
                        "definition": [
                            "int protect_flags"
                        ]
                    },
                    {
                        "path": null,
                        "name": "flags",
                        "type": "int",
                        "definition": [
                            "int flags"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fd",
                        "type": "int",
                        "definition": [
                            "int fd"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = mmap(addr, size, protect_flags, flags, fd, 0)"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "unix_mmap_prim_aligned",
            "header": "",
            "params": [
                "void *addr",
                "size_t size",
                "size_t try_alignment",
                "int protect_flags",
                "int flags",
                "int fd"
            ],
            "definition": "static void *unix_mmap_prim_aligned(void *addr, size_t size, size_t try_alignment, int protect_flags, int flags, int fd)\n{\n  (void) try_alignment;\n  void *p = 0;\n  unsigned int p_idx = 0;\n  if (addr == 0)\n  {\n    void *hint = _mi_os_get_aligned_hint(try_alignment, size);\n    if (hint != 0)\n    {\n      p_idx = unix_mmap_prim(hint, size, protect_flags, flags, fd);\n      if (((&p[p_idx]) == MAP_FAILED) || (!_mi_is_aligned(p, try_alignment)))\n      {\n        int err = errno;\n        _mi_trace_message(\"unable to directly request hinted aligned OS memory (error: %d (0x%x), size: 0x%zx bytes, alignment: 0x%zx, hint address: %p)\\n\", err, err, size, try_alignment, hint);\n      }\n      if ((&p[p_idx]) != MAP_FAILED)\n      {\n        return p;\n      }\n    }\n  }\n  p_idx = unix_mmap_prim(addr, size, protect_flags, flags, fd);\n  if ((&p[p_idx]) != MAP_FAILED)\n  {\n    return p;\n  }\n  return 0;\n}\n\n",
            "calle": [
                "_mi_is_aligned",
                "_mi_os_get_aligned_hint",
                "_mi_trace_message",
                "unix_mmap_prim"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "try_alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t try_alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "protect_flags",
                        "type": "int",
                        "definition": [
                            "int protect_flags"
                        ]
                    },
                    {
                        "path": null,
                        "name": "flags",
                        "type": "int",
                        "definition": [
                            "int flags"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fd",
                        "type": "int",
                        "definition": [
                            "int fd"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int p_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "hint",
                        "type": "void *",
                        "definition": [
                            "void *hint = _mi_os_get_aligned_hint(try_alignment, size)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "err",
                        "type": "int",
                        "definition": [
                            "int err = errno"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "unix_mmap_fd",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static int unix_mmap_fd(void)\n{\n  return -1;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "unix_mmap",
            "header": "",
            "params": [
                "void *addr",
                "size_t size",
                "size_t try_alignment",
                "int protect_flags",
                "bool large_only",
                "bool allow_large",
                "bool *is_large"
            ],
            "definition": "static void *unix_mmap(void *addr, size_t size, size_t try_alignment, int protect_flags, bool large_only, bool allow_large, bool *is_large)\n{\n  void *p = 0;\n  unsigned int p_idx = 0;\n  const int fd = unix_mmap_fd();\n  int flags = MAP_PRIVATE | MAP_ANON;\n  if (_mi_os_has_overcommit())\n  {\n    flags |= 0;\n  }\n  if (allow_large && (large_only || (_mi_os_use_large_page(size, try_alignment) && (mi_option_get(mi_option_allow_large_os_pages) == 1))))\n  {\n    static _Atomic size_t large_page_try_ok;\n    size_t try_ok = atomic_load_explicit(&large_page_try_ok, memory_order_acquire);\n    if ((!large_only) && (try_ok > 0))\n    {\n      atomic_compare_exchange_strong_explicit(&large_page_try_ok, &try_ok, try_ok - 1, memory_order_acq_rel, memory_order_acquire);\n    }\n    else\n    {\n      int lflags = flags & (~0);\n      int lfd = fd;\n      {\n      }\n      if (large_only || (lflags != flags))\n      {\n        *is_large = 1;\n        p_idx = unix_mmap_prim_aligned(addr, size, try_alignment, protect_flags, lflags, lfd);\n        if (large_only)\n        {\n          return p;\n        }\n        if ((&p[p_idx]) == 0)\n        {\n          atomic_store_explicit(&large_page_try_ok, (size_t) 8, memory_order_release);\n        }\n      }\n    }\n  }\n  if ((&p[p_idx]) == 0)\n  {\n    *is_large = 0;\n    p_idx = unix_mmap_prim_aligned(addr, size, try_alignment, protect_flags, flags, fd);\n    if ((&p[p_idx]) != 0)\n    {\n    }\n  }\n  return p;\n}\n\n",
            "calle": [
                "_mi_os_has_overcommit",
                "_mi_os_use_large_page",
                "atomic_compare_exchange_strong_explicit",
                "atomic_load_explicit",
                "atomic_store_explicit",
                "mi_option_get",
                "unix_mmap_fd",
                "unix_mmap_prim_aligned"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "addr",
                        "type": "void *",
                        "definition": [
                            "void *addr"
                        ]
                    },
                    {
                        "path": null,
                        "name": "size",
                        "type": "size_t",
                        "definition": [
                            "size_t size"
                        ]
                    },
                    {
                        "path": null,
                        "name": "try_alignment",
                        "type": "size_t",
                        "definition": [
                            "size_t try_alignment"
                        ]
                    },
                    {
                        "path": null,
                        "name": "protect_flags",
                        "type": "int",
                        "definition": [
                            "int protect_flags"
                        ]
                    },
                    {
                        "path": null,
                        "name": "large_only",
                        "type": "bool",
                        "definition": [
                            "bool large_only"
                        ]
                    },
                    {
                        "path": null,
                        "name": "allow_large",
                        "type": "bool",
                        "definition": [
                            "bool allow_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "is_large",
                        "type": "bool *",
                        "definition": [
                            "bool *is_large"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p",
                        "type": "void *",
                        "definition": [
                            "void *p = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "p_idx",
                        "type": "unsigned int",
                        "definition": [
                            "unsigned int p_idx = 0"
                        ]
                    },
                    {
                        "path": null,
                        "name": "fd",
                        "type": "const int",
                        "definition": [
                            "const int fd = unix_mmap_fd()"
                        ]
                    },
                    {
                        "path": null,
                        "name": "flags",
                        "type": "int",
                        "definition": [
                            "int flags = MAP_PRIVATE | MAP_ANON"
                        ]
                    },
                    {
                        "path": null,
                        "name": "large_page_try_ok",
                        "type": "_Atomic size_t",
                        "definition": [
                            "static _Atomic size_t large_page_try_ok"
                        ]
                    },
                    {
                        "path": null,
                        "name": "try_ok",
                        "type": "size_t",
                        "definition": [
                            "size_t try_ok = atomic_load_explicit(&large_page_try_ok, memory_order_acquire)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "lflags",
                        "type": "int",
                        "definition": [
                            "int lflags = flags & (~0)"
                        ]
                    },
                    {
                        "path": null,
                        "name": "lfd",
                        "type": "int",
                        "definition": [
                            "int lfd = fd"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "unix_mprotect_hint",
            "header": "",
            "params": [
                "int err"
            ],
            "definition": "static void unix_mprotect_hint(int err)\n{\n  (void) err;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "err",
                        "type": "int",
                        "definition": [
                            "int err"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_prim_mbind",
            "header": "",
            "params": [
                "void *start",
                "unsigned long len",
                "unsigned long mode",
                "const unsigned long *nmask",
                "unsigned long maxnode",
                "unsigned flags"
            ],
            "definition": "static long mi_prim_mbind(void *start, unsigned long len, unsigned long mode, const unsigned long *nmask, unsigned long maxnode, unsigned flags)\n{\n  (void) start;\n  (void) len;\n  (void) mode;\n  (void) nmask;\n  (void) maxnode;\n  (void) flags;\n  return 0;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "start",
                        "type": "void *",
                        "definition": [
                            "void *start"
                        ]
                    },
                    {
                        "path": null,
                        "name": "len",
                        "type": "unsigned long",
                        "definition": [
                            "unsigned long len"
                        ]
                    },
                    {
                        "path": null,
                        "name": "mode",
                        "type": "unsigned long",
                        "definition": [
                            "unsigned long mode"
                        ]
                    },
                    {
                        "path": null,
                        "name": "nmask",
                        "type": "const unsigned long *",
                        "definition": [
                            "const unsigned long *nmask"
                        ]
                    },
                    {
                        "path": null,
                        "name": "maxnode",
                        "type": "unsigned long",
                        "definition": [
                            "unsigned long maxnode"
                        ]
                    },
                    {
                        "path": null,
                        "name": "flags",
                        "type": "unsigned",
                        "definition": [
                            "unsigned flags"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "timeval_secs",
            "header": "",
            "params": [
                "const struct timeval *tv"
            ],
            "definition": "static mi_msecs_t timeval_secs(const struct timeval *tv)\n{\n  return (((mi_msecs_t) tv->tv_sec) * 1000L) + (((mi_msecs_t) tv->tv_usec) / 1000L);\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "struct timeval",
                        "type": "const struct timeval *",
                        "definition": [
                            "const struct timeval *tv"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_get_environ",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static char **mi_get_environ(void)\n{\n  return environ;\n}\n\n",
            "calle": [],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    },
                    {
                        "path": null,
                        "name": "environ",
                        "type": "None",
                        "definition": []
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_pthread_done",
            "header": "",
            "params": [
                "void *value"
            ],
            "definition": "static void mi_pthread_done(void *value)\n{\n  if (value != 0)\n  {\n    _mi_thread_done((mi_heap_t *) value);\n  }\n}\n\n",
            "calle": [
                "_mi_thread_done"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": "value",
                        "type": "void *",
                        "definition": [
                            "void *value"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_process_attach",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static void mi_process_attach(void)\n{\n  _mi_auto_process_init();\n}\n\n",
            "calle": [
                "_mi_auto_process_init"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        },
        {
            "path": null,
            "name": "mi_process_detach",
            "header": "",
            "params": [
                "void"
            ],
            "definition": "static void mi_process_detach(void)\n{\n  _mi_auto_process_done();\n}\n\n",
            "calle": [
                "_mi_auto_process_done"
            ],
            "inner": {
                "special_type": [],
                "global_variable": [
                    {
                        "path": null,
                        "name": null,
                        "type": "void",
                        "definition": [
                            "void"
                        ]
                    }
                ],
                "function": [],
                "typedefs": []
            }
        }
    ],
    "typedefs": [
        "typedef int mi_arena_id_t",
        "typedef void *mi_subproc_id_t",
        "typedef _Atomic uintptr_t mi_atomic_once_t",
        "typedef _Atomic uintptr_t mi_atomic_guard_t",
        "typedef int64_t mi_ssize_t",
        "typedef uintptr_t mi_encoded_t",
        "typedef size_t mi_threadid_t",
        "typedef uintptr_t mi_thread_free_t",
        "typedef mi_page_t mi_slice_t",
        "typedef int64_t mi_msecs_t",
        "typedef _Atomic size_t mi_bitmap_field_t",
        "typedef mi_bitmap_field_t *mi_bitmap_t",
        "typedef size_t mi_bitmap_index_t"
    ]
}