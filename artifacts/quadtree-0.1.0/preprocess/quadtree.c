# 0 "/home/enumclass/Documents/C2RustTranslation/bkp/quadtree-0.1.0/src/quadtree.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/quadtree-0.1.0/src/quadtree.c"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/quadtree-0.1.0/src/quadtree.h" 1
# 10 "/home/enumclass/Documents/C2RustTranslation/bkp/quadtree-0.1.0/src/quadtree.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 2
# 11 "/home/enumclass/Documents/C2RustTranslation/bkp/quadtree-0.1.0/src/quadtree.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/math.h" 1
# 12 "/home/enumclass/Documents/C2RustTranslation/bkp/quadtree-0.1.0/src/quadtree.h" 2

typedef struct quadtree_point {
  double x;
  double y;
} quadtree_point_t;

typedef struct quadtree_bounds {
  quadtree_point_t *nw;
  quadtree_point_t *se;
  double width;
  double height;
} quadtree_bounds_t;

typedef struct quadtree_node {
  struct quadtree_node *ne;
  struct quadtree_node *nw;
  struct quadtree_node *se;
  struct quadtree_node *sw;
  quadtree_bounds_t *bounds;
  quadtree_point_t *point;
  void *key;
} quadtree_node_t;

typedef struct quadtree {
  quadtree_node_t *root;
  void (*key_free)(void *key);
  unsigned int length;
} quadtree_t;


quadtree_point_t*
quadtree_point_new(double x, double y);

void
quadtree_point_free(quadtree_point_t *point);


quadtree_bounds_t*
quadtree_bounds_new();

void
quadtree_bounds_extend(quadtree_bounds_t *bounds, double x, double y);

void
quadtree_bounds_free(quadtree_bounds_t *bounds);


quadtree_node_t*
quadtree_node_new();

void
quadtree_node_free(quadtree_node_t *node, void (*value_free)(void*));

int
quadtree_node_ispointer(quadtree_node_t *node);

int
quadtree_node_isempty(quadtree_node_t *node);

int
quadtree_node_isleaf(quadtree_node_t *node);

void
quadtree_node_reset(quadtree_node_t* node, void (*key_free)(void*));

quadtree_node_t*
quadtree_node_with_bounds(double minx, double miny, double maxx, double maxy);

quadtree_t*
quadtree_new(double minx, double miny, double maxx, double maxy);

void
quadtree_free(quadtree_t *tree);

quadtree_point_t*
quadtree_search(quadtree_t *tree, double x, double y);

int
quadtree_insert(quadtree_t *tree, double x, double y, void *key);

void
quadtree_walk(quadtree_node_t *root,
              void (*descent)(quadtree_node_t *node),
              void (*ascent)(quadtree_node_t *node));
# 2 "/home/enumclass/Documents/C2RustTranslation/bkp/quadtree-0.1.0/src/quadtree.c" 2


static int
split_node_(quadtree_t *tree, quadtree_node_t *node);

static int
insert_(quadtree_t* tree, quadtree_node_t *root, quadtree_point_t *point, void *key);

static int
node_contains_(quadtree_node_t *outer, quadtree_point_t *it);

static quadtree_node_t *
get_quadrant_(quadtree_node_t *root, quadtree_point_t *point);


static int
node_contains_(quadtree_node_t *outer, quadtree_point_t *it) {
  return outer->bounds != 0
      && outer->bounds->nw->x < it->x
      && outer->bounds->nw->y > it->y
      && outer->bounds->se->x > it->x
      && outer->bounds->se->y < it->y;
}

static void
elision_(void* key){}

static void
reset_node_(quadtree_t *tree, quadtree_node_t *node){
  if(tree->key_free != 0) {
    quadtree_node_reset(node, tree->key_free);
  } else {
    quadtree_node_reset(node, elision_);
  }
}

static quadtree_node_t *
get_quadrant_(quadtree_node_t *root, quadtree_point_t *point) {
  if(node_contains_(root->nw, point)) return root->nw;
  if(node_contains_(root->ne, point)) return root->ne;
  if(node_contains_(root->sw, point)) return root->sw;
  if(node_contains_(root->se, point)) return root->se;
  return 0;
}


static int
split_node_(quadtree_t *tree, quadtree_node_t *node){
  quadtree_node_t *nw;
  quadtree_node_t *ne;
  quadtree_node_t *sw;
  quadtree_node_t *se;

  double x = node->bounds->nw->x;
  double y = node->bounds->nw->y;
  double hw = node->bounds->width / 2;
  double hh = node->bounds->height / 2;


  if(!(nw = quadtree_node_with_bounds(x, y - hh, x + hw, y))) return 0;
  if(!(ne = quadtree_node_with_bounds(x + hw, y - hh, x + hw * 2, y))) return 0;
  if(!(sw = quadtree_node_with_bounds(x, y - hh * 2, x + hw, y - hh))) return 0;
  if(!(se = quadtree_node_with_bounds(x + hw, y - hh * 2, x + hw * 2, y - hh))) return 0;

  node->nw = nw;
  node->ne = ne;
  node->sw = sw;
  node->se = se;

  quadtree_point_t *old = node->point;
  void *key = node->key;
  node->point = 0;
  node->key = 0;

  return insert_(tree, node, old, key);
}


static quadtree_point_t*
find_(quadtree_node_t* node, double x, double y) {
  if(quadtree_node_isleaf(node)) {
    if(node->point->x == x && node->point->y == y)
      return node->point;
  } else {
    quadtree_point_t test;
    test.x = x;
    test.y = y;
    return find_(get_quadrant_(node, &test), x, y);
  }

  return 0;
}


static int
insert_(quadtree_t* tree, quadtree_node_t *root, quadtree_point_t *point, void *key) {
  if(quadtree_node_isempty(root)) {
    root->point = point;
    root->key = key;
    return 1;
  } else if(quadtree_node_isleaf(root)){
    if(root->point->x == point->x && root->point->y == point->y){
      reset_node_(tree, root);
      root->point = point;
      root->key = key;
      return 0;
    } else {
      if(!split_node_(tree, root)) return 0;
      return insert_(tree, root, point, key);
    }
    return 1;
  } else if(quadtree_node_ispointer(root)){
    quadtree_node_t* quadrant = get_quadrant_(root, point);
    return quadrant == 0 ? 0 : insert_(tree, quadrant, point, key);
  }
  return 0;
}



quadtree_t*
quadtree_new(double minx, double miny, double maxx, double maxy) {
  quadtree_t *tree;
  if(!(tree = malloc(sizeof(*tree))))
    return 0;
  tree->root = quadtree_node_with_bounds(minx, miny, maxx, maxy);
  if(!(tree->root))
    return 0;
  tree->key_free = 0;
  tree->length = 0;
  return tree;
}

int
quadtree_insert(quadtree_t *tree, double x, double y, void *key) {
  quadtree_point_t *point;
  if(!(point = quadtree_point_new(x, y))) return 0;
  if(!node_contains_(tree->root, point)) return 0;
  if(!insert_(tree, tree->root, point, key)) return 0;
  tree->length++;
  return 1;
}

quadtree_point_t*
quadtree_search(quadtree_t *tree, double x, double y) {
  return find_(tree->root, x, y);
}

void
quadtree_free(quadtree_t *tree) {
  if(tree->key_free != 0) {
    quadtree_node_free(tree->root, tree->key_free);
  } else {
    quadtree_node_free(tree->root, elision_);
  }
  free(tree);
}

void
quadtree_walk(quadtree_node_t *root, void (*descent)(quadtree_node_t *node),
                                     void (*ascent)(quadtree_node_t *node)) {
  (*descent)(root);
  if(root->nw != 0) quadtree_walk(root->nw, descent, ascent);
  if(root->ne != 0) quadtree_walk(root->ne, descent, ascent);
  if(root->sw != 0) quadtree_walk(root->sw, descent, ascent);
  if(root->se != 0) quadtree_walk(root->se, descent, ascent);
  (*ascent)(root);
}
# 0 "/home/enumclass/Documents/C2RustTranslation/bkp/quadtree-0.1.0/src/quadtree.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/quadtree-0.1.0/src/quadtree.c"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/quadtree-0.1.0/src/quadtree.h" 1
# 10 "/home/enumclass/Documents/C2RustTranslation/bkp/quadtree-0.1.0/src/quadtree.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 2
# 11 "/home/enumclass/Documents/C2RustTranslation/bkp/quadtree-0.1.0/src/quadtree.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/math.h" 1
# 12 "/home/enumclass/Documents/C2RustTranslation/bkp/quadtree-0.1.0/src/quadtree.h" 2

typedef struct quadtree_point {
  double x;
  double y;
} quadtree_point_t;

typedef struct quadtree_bounds {
  quadtree_point_t *nw;
  quadtree_point_t *se;
  double width;
  double height;
} quadtree_bounds_t;

typedef struct quadtree_node {
  struct quadtree_node *ne;
  struct quadtree_node *nw;
  struct quadtree_node *se;
  struct quadtree_node *sw;
  quadtree_bounds_t *bounds;
  quadtree_point_t *point;
  void *key;
} quadtree_node_t;

typedef struct quadtree {
  quadtree_node_t *root;
  void (*key_free)(void *key);
  unsigned int length;
} quadtree_t;


quadtree_point_t*
quadtree_point_new(double x, double y);

void
quadtree_point_free(quadtree_point_t *point);


quadtree_bounds_t*
quadtree_bounds_new();

void
quadtree_bounds_extend(quadtree_bounds_t *bounds, double x, double y);

void
quadtree_bounds_free(quadtree_bounds_t *bounds);


quadtree_node_t*
quadtree_node_new();

void
quadtree_node_free(quadtree_node_t *node, void (*value_free)(void*));

int
quadtree_node_ispointer(quadtree_node_t *node);

int
quadtree_node_isempty(quadtree_node_t *node);

int
quadtree_node_isleaf(quadtree_node_t *node);

void
quadtree_node_reset(quadtree_node_t* node, void (*key_free)(void*));

quadtree_node_t*
quadtree_node_with_bounds(double minx, double miny, double maxx, double maxy);

quadtree_t*
quadtree_new(double minx, double miny, double maxx, double maxy);

void
quadtree_free(quadtree_t *tree);

quadtree_point_t*
quadtree_search(quadtree_t *tree, double x, double y);

int
quadtree_insert(quadtree_t *tree, double x, double y, void *key);

void
quadtree_walk(quadtree_node_t *root,
              void (*descent)(quadtree_node_t *node),
              void (*ascent)(quadtree_node_t *node));
# 2 "/home/enumclass/Documents/C2RustTranslation/bkp/quadtree-0.1.0/src/quadtree.c" 2


static int
split_node_(quadtree_t *tree, quadtree_node_t *node);

static int
insert_(quadtree_t* tree, quadtree_node_t *root, quadtree_point_t *point, void *key);

static int
node_contains_(quadtree_node_t *outer, quadtree_point_t *it);

static quadtree_node_t *
get_quadrant_(quadtree_node_t *root, quadtree_point_t *point);


static int
node_contains_(quadtree_node_t *outer, quadtree_point_t *it) {
  return outer->bounds != 0
      && outer->bounds->nw->x < it->x
      && outer->bounds->nw->y > it->y
      && outer->bounds->se->x > it->x
      && outer->bounds->se->y < it->y;
}

static void
elision_(void* key){}

static void
reset_node_(quadtree_t *tree, quadtree_node_t *node){
  if(tree->key_free != 0) {
    quadtree_node_reset(node, tree->key_free);
  } else {
    quadtree_node_reset(node, elision_);
  }
}

static quadtree_node_t *
get_quadrant_(quadtree_node_t *root, quadtree_point_t *point) {
  if(node_contains_(root->nw, point)) return root->nw;
  if(node_contains_(root->ne, point)) return root->ne;
  if(node_contains_(root->sw, point)) return root->sw;
  if(node_contains_(root->se, point)) return root->se;
  return 0;
}


static int
split_node_(quadtree_t *tree, quadtree_node_t *node){
  quadtree_node_t *nw;
  quadtree_node_t *ne;
  quadtree_node_t *sw;
  quadtree_node_t *se;

  double x = node->bounds->nw->x;
  double y = node->bounds->nw->y;
  double hw = node->bounds->width / 2;
  double hh = node->bounds->height / 2;


  if(!(nw = quadtree_node_with_bounds(x, y - hh, x + hw, y))) return 0;
  if(!(ne = quadtree_node_with_bounds(x + hw, y - hh, x + hw * 2, y))) return 0;
  if(!(sw = quadtree_node_with_bounds(x, y - hh * 2, x + hw, y - hh))) return 0;
  if(!(se = quadtree_node_with_bounds(x + hw, y - hh * 2, x + hw * 2, y - hh))) return 0;

  node->nw = nw;
  node->ne = ne;
  node->sw = sw;
  node->se = se;

  quadtree_point_t *old = node->point;
  void *key = node->key;
  node->point = 0;
  node->key = 0;

  return insert_(tree, node, old, key);
}


static quadtree_point_t*
find_(quadtree_node_t* node, double x, double y) {
  if(quadtree_node_isleaf(node)) {
    if(node->point->x == x && node->point->y == y)
      return node->point;
  } else {
    quadtree_point_t test;
    test.x = x;
    test.y = y;
    return find_(get_quadrant_(node, &test), x, y);
  }

  return 0;
}


static int
insert_(quadtree_t* tree, quadtree_node_t *root, quadtree_point_t *point, void *key) {
  if(quadtree_node_isempty(root)) {
    root->point = point;
    root->key = key;
    return 1;
  } else if(quadtree_node_isleaf(root)){
    if(root->point->x == point->x && root->point->y == point->y){
      reset_node_(tree, root);
      root->point = point;
      root->key = key;
      return 0;
    } else {
      if(!split_node_(tree, root)) return 0;
      return insert_(tree, root, point, key);
    }
    return 1;
  } else if(quadtree_node_ispointer(root)){
    quadtree_node_t* quadrant = get_quadrant_(root, point);
    return quadrant == 0 ? 0 : insert_(tree, quadrant, point, key);
  }
  return 0;
}



quadtree_t*
quadtree_new(double minx, double miny, double maxx, double maxy) {
  quadtree_t *tree;
  if(!(tree = malloc(sizeof(*tree))))
    return 0;
  tree->root = quadtree_node_with_bounds(minx, miny, maxx, maxy);
  if(!(tree->root))
    return 0;
  tree->key_free = 0;
  tree->length = 0;
  return tree;
}

int
quadtree_insert(quadtree_t *tree, double x, double y, void *key) {
  quadtree_point_t *point;
  if(!(point = quadtree_point_new(x, y))) return 0;
  if(!node_contains_(tree->root, point)) return 0;
  if(!insert_(tree, tree->root, point, key)) return 0;
  tree->length++;
  return 1;
}

quadtree_point_t*
quadtree_search(quadtree_t *tree, double x, double y) {
  return find_(tree->root, x, y);
}

void
quadtree_free(quadtree_t *tree) {
  if(tree->key_free != 0) {
    quadtree_node_free(tree->root, tree->key_free);
  } else {
    quadtree_node_free(tree->root, elision_);
  }
  free(tree);
}

void
quadtree_walk(quadtree_node_t *root, void (*descent)(quadtree_node_t *node),
                                     void (*ascent)(quadtree_node_t *node)) {
  (*descent)(root);
  if(root->nw != 0) quadtree_walk(root->nw, descent, ascent);
  if(root->ne != 0) quadtree_walk(root->ne, descent, ascent);
  if(root->sw != 0) quadtree_walk(root->sw, descent, ascent);
  if(root->se != 0) quadtree_walk(root->se, descent, ascent);
  (*ascent)(root);
}
