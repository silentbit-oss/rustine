{"fn_data":{"src::src::lighting::compute_occlusion":"unsafe extern \"C\" fn compute_occlusion(\n    mut thispt: crate::src::kazmath::aabb3::kmVec3,\n    mut horizonpt: crate::src::kazmath::aabb3::kmVec3,\n) -> libc::c_float {\n    let mut direction = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    crate::src::kazmath::vec3::kmVec3Subtract(core::ptr::addr_of_mut!(direction), core::ptr::addr_of!(horizonpt), core::ptr::addr_of!(thispt));\n    crate::src::kazmath::vec3::kmVec3Normalize(core::ptr::addr_of_mut!(direction), core::ptr::addr_of!(direction));\n    let mut dot = crate::src::kazmath::vec3::kmVec3Dot(core::ptr::addr_of!(direction), &KM_VEC3_POS_Z);\n    return (atan((if dot > 0.0f32 { dot } else { 0.0f32 }) as libc::c_double)\n        * 0.63661977236f64) as libc::c_float;\n}","src::src::image::heman_image_clear":"pub unsafe extern \"C\" fn heman_image_clear(\n    mut img: Option<&mut heman_image>,\n    mut value: libc::c_float,\n) {\n    let mut size = (*img.as_deref().unwrap()).width * (*img.as_deref().unwrap()).height * (*img.as_deref().unwrap()).nbands;\n    let mut dst = (*img.as_deref().unwrap()).data;\n    loop {\n        let fresh3 = size;\n        size= size - 1;\n        if !(fresh3 != 0) {\n            break;\n        }\n        let fresh4 = dst;\n        dst= dst.offset(1);\n        *fresh4= value;\n    };\n}","src::kazmath::aabb3::kmAABB3ContainsAABB":"pub unsafe extern \"C\" fn kmAABB3ContainsAABB(\n    mut container: *const kmAABB3,\n    mut to_check: *const kmAABB3,\n) -> libc::c_uint {\n    let mut corners: [kmVec3; 8] = [kmVec3 { x: 0., y: 0., z: 0. }; 8];\n    let mut result = 2 as libc::c_int as libc::c_uint;\n    let mut found = 0 as libc::c_int as libc::c_uchar;\n    crate::src::kazmath::vec3::kmVec3Fill(\n        Some(&mut *corners.as_mut_ptr().offset(0 as libc::c_int as isize)),\n        (*to_check).min.x,\n        (*to_check).min.y,\n        (*to_check).min.z,\n    );\n    crate::src::kazmath::vec3::kmVec3Fill(\n        Some(&mut *corners.as_mut_ptr().offset(1 as libc::c_int as isize)),\n        (*to_check).max.x,\n        (*to_check).min.y,\n        (*to_check).min.z,\n    );\n    crate::src::kazmath::vec3::kmVec3Fill(\n        Some(&mut *corners.as_mut_ptr().offset(2 as libc::c_int as isize)),\n        (*to_check).max.x,\n        (*to_check).max.y,\n        (*to_check).min.z,\n    );\n    crate::src::kazmath::vec3::kmVec3Fill(\n        Some(&mut *corners.as_mut_ptr().offset(3 as libc::c_int as isize)),\n        (*to_check).min.x,\n        (*to_check).max.y,\n        (*to_check).min.z,\n    );\n    crate::src::kazmath::vec3::kmVec3Fill(\n        Some(&mut *corners.as_mut_ptr().offset(4 as libc::c_int as isize)),\n        (*to_check).min.x,\n        (*to_check).min.y,\n        (*to_check).max.z,\n    );\n    crate::src::kazmath::vec3::kmVec3Fill(\n        Some(&mut *corners.as_mut_ptr().offset(5 as libc::c_int as isize)),\n        (*to_check).max.x,\n        (*to_check).min.y,\n        (*to_check).max.z,\n    );\n    crate::src::kazmath::vec3::kmVec3Fill(\n        Some(&mut *corners.as_mut_ptr().offset(6 as libc::c_int as isize)),\n        (*to_check).max.x,\n        (*to_check).max.y,\n        (*to_check).max.z,\n    );\n    crate::src::kazmath::vec3::kmVec3Fill(\n        Some(&mut *corners.as_mut_ptr().offset(7 as libc::c_int as isize)),\n        (*to_check).min.x,\n        (*to_check).max.y,\n        (*to_check).max.z,\n    );\n    let mut i = 0 as libc::c_int as libc::c_uchar;\n    while (i as libc::c_int) < 8 as libc::c_int {\n        if kmAABB3ContainsPoint(container, core::ptr::addr_of_mut!(*corners.as_mut_ptr().offset(i as isize)))\n            == 0\n        {\n            result= 1 as libc::c_int as libc::c_uint;\n            if found != 0 {\n                return result;\n            }\n        } else {\n            found= 1 as libc::c_int as libc::c_uchar;\n        }\n        i= i.wrapping_add(1);\n    }\n    if found == 0 {\n        result= 0 as libc::c_int as libc::c_uint;\n    }\n    return result;\n}","src::kazmath::utility::kmClamp":"pub unsafe extern \"C\" fn kmClamp(\n    mut x: libc::c_float,\n    mut min: libc::c_float,\n    mut max: libc::c_float,\n) -> libc::c_float {\n    return if x < min { min } else if x > max { max } else { x };\n}","src::kazmath::aabb2::kmAABB2Scale":"pub unsafe extern \"C\" fn kmAABB2Scale(\n    mut pOut: *mut kmAABB2,\n    mut pIn: *const kmAABB2,\n    mut s: libc::c_float,\n) -> *mut kmAABB2 {\n    crate::src::kazmath::vec2::kmVec2Scale(core::ptr::addr_of_mut!((*pOut).max), &(*pIn).max, s);\n    crate::src::kazmath::vec2::kmVec2Scale(core::ptr::addr_of_mut!((*pOut).min), &(*pIn).min, s);\n    return pOut;\n}","src::kazmath::vec2::kmVec2Div":"pub unsafe extern \"C\" fn kmVec2Div(\n    mut pOut: Option<&mut crate::src::kazmath::aabb2::kmVec2>,\n    mut pV1: *const crate::src::kazmath::aabb2::kmVec2,\n    mut pV2: *const crate::src::kazmath::aabb2::kmVec2,\n) -> *mut crate::src::kazmath::aabb2::kmVec2 {\n    if (*pV2).x != 0. && (*pV2).y != 0. {\n        (*pOut.as_deref_mut().unwrap()).x= (*pV1).x / (*pV2).x;\n        (*pOut.as_deref_mut().unwrap()).y= (*pV1).y / (*pV2).y;\n    }\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::quaternion::kmQuaternionRotationPitchYawRoll":"pub unsafe extern \"C\" fn kmQuaternionRotationPitchYawRoll(\n    mut pOut: Option<&mut crate::src::kazmath::mat3::kmQuaternion>,\n    mut pitch: libc::c_float,\n    mut yaw: libc::c_float,\n    mut roll: libc::c_float,\n) -> *mut crate::src::kazmath::mat3::kmQuaternion {\n    if pitch <= 2 as libc::c_int as libc::c_float * 3.14159265358979323846f32 {} else {\n        __assert_fail(\n            b\"pitch <= 2*kmPI\\0\" as *const u8 as *const libc::c_char,\n            b\"../kazmath/quaternion.c\\0\" as *const u8 as *const libc::c_char,\n            334 as libc::c_int as libc::c_uint,\n            b\"kmQuaternion *kmQuaternionRotationPitchYawRoll(kmQuaternion *, float, float, float)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if yaw <= 2 as libc::c_int as libc::c_float * 3.14159265358979323846f32 {} else {\n        __assert_fail(\n            b\"yaw <= 2*kmPI\\0\" as *const u8 as *const libc::c_char,\n            b\"../kazmath/quaternion.c\\0\" as *const u8 as *const libc::c_char,\n            335 as libc::c_int as libc::c_uint,\n            b\"kmQuaternion *kmQuaternionRotationPitchYawRoll(kmQuaternion *, float, float, float)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if roll <= 2 as libc::c_int as libc::c_float * 3.14159265358979323846f32 {} else {\n        __assert_fail(\n            b\"roll <= 2*kmPI\\0\" as *const u8 as *const libc::c_char,\n            b\"../kazmath/quaternion.c\\0\" as *const u8 as *const libc::c_char,\n            336 as libc::c_int as libc::c_uint,\n            b\"kmQuaternion *kmQuaternionRotationPitchYawRoll(kmQuaternion *, float, float, float)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut sY = sinf((yaw as libc::c_double * 0.5f64) as libc::c_float);\n    let mut cY = cosf((yaw as libc::c_double * 0.5f64) as libc::c_float);\n    let mut sZ = sinf((roll as libc::c_double * 0.5f64) as libc::c_float);\n    let mut cZ = cosf((roll as libc::c_double * 0.5f64) as libc::c_float);\n    let mut sX = sinf((pitch as libc::c_double * 0.5f64) as libc::c_float);\n    let mut cX = cosf((pitch as libc::c_double * 0.5f64) as libc::c_float);\n    (*pOut.as_deref_mut().unwrap()).w= cY * cZ * cX - sY * sZ * sX;\n    (*pOut.as_deref_mut().unwrap()).x= sY * sZ * cX + cY * cZ * sX;\n    (*pOut.as_deref_mut().unwrap()).y= sY * cZ * cX + cY * sZ * sX;\n    (*pOut.as_deref_mut().unwrap()).z= cY * sZ * cX - sY * cZ * sX;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::draw::heman_draw_splats":"pub unsafe extern \"C\" fn heman_draw_splats(\n    mut target: Option<&mut heman_image>,\n    mut pts: *mut heman_points,\n    mut radius: libc::c_int,\n    mut blend_mode: libc::c_int,\n) {\n    let mut fwidth = radius * 2 as libc::c_int + 1 as libc::c_int;\n    let mut gaussian_splat = malloc(\n        ((fwidth * fwidth) as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<libc::c_float>() as libc::c_ulong),\n    ) as *mut libc::c_float;\n    crate::src::src::gaussian::generate_gaussian_splat(gaussian_splat, fwidth);\n    let mut src = (*pts).data;\n    let mut w = (*target.as_deref().unwrap()).width;\n    let mut h = (*target.as_deref().unwrap()).height;\n    let mut i = 0 as libc::c_int;\n    while i < (*pts).width {\n        let fresh6 = src;\n        src= src.offset(1);\n        let mut x = (*fresh6);\n        let fresh7 = src;\n        src= src.offset(1);\n        let mut y = (*fresh7);\n        let mut ii = (x * w as libc::c_float - radius as libc::c_float) as libc::c_int;\n        let mut jj = (y * h as libc::c_float - radius as libc::c_float) as libc::c_int;\n        let mut kj = 0 as libc::c_int;\n        while kj < fwidth {\n            let mut ki = 0 as libc::c_int;\n            while ki < fwidth {\n                let mut i_0 = ii + ki;\n                let mut j = jj + kj;\n                if !(i_0 < 0 as libc::c_int || i_0 >= w || j < 0 as libc::c_int\n                    || j >= h)\n                {\n                    let mut texel = crate::src::src::image::heman_image_texel(target.as_deref_mut(), i_0, j);\n                    let mut c = 0 as libc::c_int;\n                    while c < (*target.as_deref().unwrap()).nbands {\n                        let fresh8 = texel;\n                        texel= texel.offset(1);\n                        *fresh8+= *gaussian_splat.offset((kj * fwidth + ki) as isize);\n                        c+= 1;\n                    }\n                }\n                ki+= 1;\n            }\n            kj+= 1;\n        }\n        i+= 1;\n    }\n    free(gaussian_splat as *mut libc::c_void);\n}","src::kazmath::quaternion::kmQuaternionToAxisAngle":"pub unsafe extern \"C\" fn kmQuaternionToAxisAngle(\n    mut pIn: *const crate::src::kazmath::mat3::kmQuaternion,\n    mut pAxis: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pAngle: Option<&mut libc::c_float>,\n) {\n    let mut tempAngle: libc::c_float = 0.;\n    let mut scale: libc::c_float = 0.;\n    tempAngle= acosf((*pIn).w);\n    scale= sqrtf(crate::src::kazmath::utility::kmSQR((*pIn).x) + crate::src::kazmath::utility::kmSQR((*pIn).y) + crate::src::kazmath::utility::kmSQR((*pIn).z));\n    if scale as libc::c_double > -0.0001f64 && (scale as libc::c_double) < 0.0001f64\n        || (scale as libc::c_double)\n            < (2 as libc::c_int as libc::c_float * 3.14159265358979323846f32)\n                as libc::c_double + 0.0001f64\n            && scale as libc::c_double\n                > (2 as libc::c_int as libc::c_float * 3.14159265358979323846f32)\n                    as libc::c_double - 0.0001f64\n    {\n        *pAngle.as_deref_mut().unwrap()= 0.0f32;\n        (*pAxis.as_deref_mut().unwrap()).x= 0.0f32;\n        (*pAxis.as_deref_mut().unwrap()).y= 0.0f32;\n        (*pAxis.as_deref_mut().unwrap()).z= 1.0f32;\n    } else {\n        *pAngle.as_deref_mut().unwrap()= tempAngle * 2.0f32;\n        (*pAxis.as_deref_mut().unwrap()).x= (*pIn).x / scale;\n        (*pAxis.as_deref_mut().unwrap()).y= (*pIn).y / scale;\n        (*pAxis.as_deref_mut().unwrap()).z= (*pIn).z / scale;\n        crate::src::kazmath::vec3::kmVec3Normalize(pAxis.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), pAxis.as_deref().map(|r| r as *const _).unwrap_or(std::ptr::null()));\n    };\n}","src::kazmath::ray2::kmSegment2WithSegmentIntersection":"pub unsafe extern \"C\" fn kmSegment2WithSegmentIntersection(\n    mut segmentA: *const kmRay2,\n    mut segmentB: *const kmRay2,\n    mut intersection: Option<&mut crate::src::kazmath::aabb2::kmVec2>,\n) -> libc::c_uchar {\n    let mut ua: libc::c_float = 0.;\n    let mut ub: libc::c_float = 0.;\n    let mut pt = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    if kmLine2WithLineIntersection(\n        &(*segmentA).start,\n        &(*segmentA).dir,\n        &(*segmentB).start,\n        &(*segmentB).start,\n        Some(&mut ua),\n        Some(&mut ub),\n        Some(&mut pt),\n    ) as libc::c_int != 0 && 0.0f64 <= ua as libc::c_double\n        && ua as libc::c_double <= 1.0f64 && 0.0f64 <= ub as libc::c_double\n        && ub as libc::c_double <= 1.0f64\n    {\n        (*intersection.as_deref_mut().unwrap()).x= pt.x;\n        (*intersection.as_deref_mut().unwrap()).y= pt.y;\n        return 1 as libc::c_int as libc::c_uchar;\n    }\n    return 0 as libc::c_int as libc::c_uchar;\n}","src::kazmath::utility::kmMax":"pub unsafe extern \"C\" fn kmMax(\n    mut lhs: libc::c_float,\n    mut rhs: libc::c_float,\n) -> libc::c_float {\n    return if lhs > rhs { lhs } else { rhs };\n}","src::kazmath::vec2::kmVec2Fill":"pub unsafe extern \"C\" fn kmVec2Fill(\n    mut pOut: Option<&mut crate::src::kazmath::aabb2::kmVec2>,\n    mut x: libc::c_float,\n    mut y: libc::c_float,\n) -> *mut crate::src::kazmath::aabb2::kmVec2 {\n    (*pOut.as_deref_mut().unwrap()).x= x;\n    (*pOut.as_deref_mut().unwrap()).y= y;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::ops::copy_row":"unsafe extern \"C\" fn copy_row(\n    mut src: *mut heman_image,\n    mut dst: *mut heman_image,\n    mut dstx: libc::c_int,\n    mut y: libc::c_int,\n) {\n    let mut width = (*src).width;\n    if (*src).nbands == 1 as libc::c_int {\n        let mut x = 0 as libc::c_int;\n        while x < width {\n            let mut srcp = crate::src::src::image::heman_image_texel(src.as_mut(), x, y);\n            let mut dstp = crate::src::src::image::heman_image_texel(dst.as_mut(), dstx + x, y);\n            *dstp= (*srcp);\n            x+= 1;\n        }\n        return;\n    }\n    let mut x_0 = 0 as libc::c_int;\n    while x_0 < width {\n        let mut srcp_0 = crate::src::src::image::heman_image_texel(src.as_mut(), x_0, y);\n        let mut dstp_0 = crate::src::src::image::heman_image_texel(dst.as_mut(), dstx + x_0, y);\n        let mut nbands = (*src).nbands;\n        loop {\n            let fresh4 = nbands;\n            nbands= nbands - 1;\n            if !(fresh4 != 0) {\n                break;\n            }\n            let fresh5 = srcp_0;\n            srcp_0= srcp_0.offset(1);\n            let fresh6 = dstp_0;\n            dstp_0= dstp_0.offset(1);\n            *fresh6= (*fresh5);\n        }\n        x_0+= 1;\n    }\n}","src::kazmath::aabb2::kmAABB2Assign":"pub unsafe extern \"C\" fn kmAABB2Assign(\n    mut pOut: *mut kmAABB2,\n    mut pIn: *const kmAABB2,\n) -> *mut kmAABB2 {\n    crate::src::kazmath::vec2::kmVec2Assign(core::ptr::addr_of_mut!((*pOut).min), &(*pIn).min);\n    crate::src::kazmath::vec2::kmVec2Assign(core::ptr::addr_of_mut!((*pOut).max), &(*pIn).max);\n    return pOut;\n}","src::kazmath::aabb2::kmAABB2ContainsPoint":"pub unsafe extern \"C\" fn kmAABB2ContainsPoint(\n    mut pBox: *const kmAABB2,\n    mut pPoint: *const kmVec2,\n) -> libc::c_int {\n    if (*pPoint).x >= (*pBox).min.x && (*pPoint).x <= (*pBox).max.x\n        && (*pPoint).y >= (*pBox).min.y && (*pPoint).y <= (*pBox).max.y\n    {\n        return 1 as libc::c_int;\n    }\n    return 0 as libc::c_int;\n}","src::kazmath::mat4::kmMat4AreEqual":"pub unsafe extern \"C\" fn kmMat4AreEqual(\n    mut pMat1: *const crate::src::kazmath::mat3::kmMat4,\n    mut pMat2: *const crate::src::kazmath::mat3::kmMat4,\n) -> libc::c_int {\n    let mut i = 0 as libc::c_int;\n    if pMat1 != pMat2\n        && !(b\"You are comparing the same thing!\\0\" as *const u8 as *const libc::c_char)\n            .is_null()\n    {} else {\n        __assert_fail(\n            b\"pMat1 != pMat2 && \\\"You are comparing the same thing!\\\"\\0\" as *const u8\n                as *const libc::c_char,\n            b\"../kazmath/mat4.c\\0\" as *const u8 as *const libc::c_char,\n            308 as libc::c_int as libc::c_uint,\n            b\"int kmMat4AreEqual(const kmMat4 *, const kmMat4 *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    i= 0 as libc::c_int;\n    while i < 16 as libc::c_int {\n        if !((*pMat1).mat[i as usize] as libc::c_double + 0.0001f64\n            > (*pMat2).mat[i as usize] as libc::c_double\n            && (*pMat1).mat[i as usize] as libc::c_double - 0.0001f64\n                < (*pMat2).mat[i as usize] as libc::c_double)\n        {\n            return 0 as libc::c_int;\n        }\n        i+= 1;\n    }\n    return 1 as libc::c_int;\n}","src::kazmath::mat3::kmMat3RotationQuaternion":"pub unsafe extern \"C\" fn kmMat3RotationQuaternion(\n    mut pOut: Option<&mut kmMat3>,\n    mut pIn: *const kmQuaternion,\n) -> *mut kmMat3 {\n    if pIn.is_null() || pOut.as_deref().is_none() {\n        return 0 as *mut kmMat3;\n    }\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int\n        as usize]= 1.0f32 - 2.0f32 * ((*pIn).y * (*pIn).y + (*pIn).z * (*pIn).z);\n    (*pOut.as_deref_mut().unwrap()).mat[1 as libc::c_int\n        as usize]= 2.0f32 * ((*pIn).x * (*pIn).y - (*pIn).w * (*pIn).z);\n    (*pOut.as_deref_mut().unwrap()).mat[2 as libc::c_int\n        as usize]= 2.0f32 * ((*pIn).x * (*pIn).z + (*pIn).w * (*pIn).y);\n    (*pOut.as_deref_mut().unwrap()).mat[3 as libc::c_int\n        as usize]= 2.0f32 * ((*pIn).x * (*pIn).y + (*pIn).w * (*pIn).z);\n    (*pOut.as_deref_mut().unwrap()).mat[4 as libc::c_int\n        as usize]= 1.0f32 - 2.0f32 * ((*pIn).x * (*pIn).x + (*pIn).z * (*pIn).z);\n    (*pOut.as_deref_mut().unwrap()).mat[5 as libc::c_int\n        as usize]= 2.0f32 * ((*pIn).y * (*pIn).z - (*pIn).w * (*pIn).x);\n    (*pOut.as_deref_mut().unwrap()).mat[6 as libc::c_int\n        as usize]= 2.0f32 * ((*pIn).x * (*pIn).z - (*pIn).w * (*pIn).y);\n    (*pOut.as_deref_mut().unwrap()).mat[7 as libc::c_int\n        as usize]= 2.0f32 * ((*pIn).y * (*pIn).z + (*pIn).w * (*pIn).x);\n    (*pOut.as_deref_mut().unwrap()).mat[8 as libc::c_int\n        as usize]= 1.0f32 - 2.0f32 * ((*pIn).x * (*pIn).x + (*pIn).y * (*pIn).y);\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::mat4::kmMat4OrthographicProjection":"pub unsafe extern \"C\" fn kmMat4OrthographicProjection(\n    mut pOut: Option<&mut crate::src::kazmath::mat3::kmMat4>,\n    mut left: libc::c_float,\n    mut right: libc::c_float,\n    mut bottom: libc::c_float,\n    mut top: libc::c_float,\n    mut nearVal: libc::c_float,\n    mut farVal: libc::c_float,\n) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    let mut tx = -((right + left) / (right - left));\n    let mut ty = -((top + bottom) / (top - bottom));\n    let mut tz = -((farVal + nearVal) / (farVal - nearVal));\n    kmMat4Identity(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()));\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int\n        as usize]= 2 as libc::c_int as libc::c_float / (right - left);\n    (*pOut.as_deref_mut().unwrap()).mat[5 as libc::c_int\n        as usize]= 2 as libc::c_int as libc::c_float / (top - bottom);\n    (*pOut.as_deref_mut().unwrap()).mat[10 as libc::c_int\n        as usize]= -(2 as libc::c_int) as libc::c_float / (farVal - nearVal);\n    (*pOut.as_deref_mut().unwrap()).mat[12 as libc::c_int as usize]= tx;\n    (*pOut.as_deref_mut().unwrap()).mat[13 as libc::c_int as usize]= ty;\n    (*pOut.as_deref_mut().unwrap()).mat[14 as libc::c_int as usize]= tz;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::vec2::kmVec2Lerp":"pub unsafe extern \"C\" fn kmVec2Lerp(\n    mut pOut: Option<&mut crate::src::kazmath::aabb2::kmVec2>,\n    mut pV1: *const crate::src::kazmath::aabb2::kmVec2,\n    mut pV2: *const crate::src::kazmath::aabb2::kmVec2,\n    mut t: libc::c_float,\n) -> *mut crate::src::kazmath::aabb2::kmVec2 {\n    (*pOut.as_deref_mut().unwrap()).x= (*pV1).x + t * ((*pV2).x - (*pV1).x);\n    (*pOut.as_deref_mut().unwrap()).y= (*pV1).y + t * ((*pV2).y - (*pV1).y);\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::vec3::kmVec3Length":"pub unsafe extern \"C\" fn kmVec3Length(mut pIn: *const crate::src::kazmath::aabb3::kmVec3) -> libc::c_float {\n    return sqrtf(crate::src::kazmath::utility::kmSQR((*pIn).x) + crate::src::kazmath::utility::kmSQR((*pIn).y) + crate::src::kazmath::utility::kmSQR((*pIn).z));\n}","src::kazmath::mat3::kmMat3Translation":"pub unsafe extern \"C\" fn kmMat3Translation(\n    mut pOut: Option<&mut kmMat3>,\n    mut x: libc::c_float,\n    mut y: libc::c_float,\n) -> *mut kmMat3 {\n    kmMat3Identity(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()));\n    (*pOut.as_deref_mut().unwrap()).mat[6 as libc::c_int as usize]= x;\n    (*pOut.as_deref_mut().unwrap()).mat[7 as libc::c_int as usize]= y;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::points::randhash":"pub unsafe extern \"C\" fn randhash(mut seed: libc::c_uint) -> libc::c_uint {\n    let mut i = (seed ^ 12345391 as libc::c_uint)\n        .wrapping_mul(2654435769 as libc::c_uint);\n    i^= i << 6 as libc::c_int ^ i >> 26 as libc::c_int;\n    i= i.wrapping_mul(2654435769 as libc::c_uint);\n    i= i.wrapping_add(i << 5 as libc::c_int ^ i >> 12 as libc::c_int);\n    return i;\n}","src::kazmath::aabb2::kmAABB2Sanitize":"pub unsafe extern \"C\" fn kmAABB2Sanitize(\n    mut pOut: Option<&mut kmAABB2>,\n    mut pIn: *const kmAABB2,\n) -> *mut kmAABB2 {\n    if (*pIn).min.x <= (*pIn).max.x {\n        (*pOut.as_deref_mut().unwrap()).min.x= (*pIn).min.x;\n        (*pOut.as_deref_mut().unwrap()).max.x= (*pIn).max.x;\n    } else {\n        (*pOut.as_deref_mut().unwrap()).min.x= (*pIn).max.x;\n        (*pOut.as_deref_mut().unwrap()).max.x= (*pIn).min.x;\n    }\n    if (*pIn).min.y <= (*pIn).max.y {\n        (*pOut.as_deref_mut().unwrap()).min.y= (*pIn).min.y;\n        (*pOut.as_deref_mut().unwrap()).max.y= (*pIn).max.y;\n    } else {\n        (*pOut.as_deref_mut().unwrap()).min.y= (*pIn).max.y;\n        (*pOut.as_deref_mut().unwrap()).max.y= (*pIn).min.y;\n    }\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::quaternion::kmQuaternionExp":"pub unsafe extern \"C\" fn kmQuaternionExp(\n    mut pOut: *mut crate::src::kazmath::mat3::kmQuaternion,\n    mut pIn: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> *mut crate::src::kazmath::mat3::kmQuaternion {\n    __assert_fail(\n        b\"0\\0\" as *const u8 as *const libc::c_char,\n        b\"../kazmath/quaternion.c\\0\" as *const u8 as *const libc::c_char,\n        68 as libc::c_int as libc::c_uint,\n        b\"kmQuaternion *kmQuaternionExp(kmQuaternion *, const kmQuaternion *)\\0\" as *const u8 as *const libc::c_char,\n    );\n    return pOut;\n}","src::kazmath::utility::kmMin":"pub unsafe extern \"C\" fn kmMin(\n    mut lhs: libc::c_float,\n    mut rhs: libc::c_float,\n) -> libc::c_float {\n    return if lhs < rhs { lhs } else { rhs };\n}","src::kazmath::quaternion::kmQuaternionAreEqual":"pub unsafe extern \"C\" fn kmQuaternionAreEqual(\n    mut p1: *const crate::src::kazmath::mat3::kmQuaternion,\n    mut p2: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> libc::c_int {\n    if ((*p1).x as libc::c_double) < (*p2).x as libc::c_double + 0.0001f64\n        && (*p1).x as libc::c_double > (*p2).x as libc::c_double - 0.0001f64\n        && (((*p1).y as libc::c_double) < (*p2).y as libc::c_double + 0.0001f64\n            && (*p1).y as libc::c_double > (*p2).y as libc::c_double - 0.0001f64)\n        && (((*p1).z as libc::c_double) < (*p2).z as libc::c_double + 0.0001f64\n            && (*p1).z as libc::c_double > (*p2).z as libc::c_double - 0.0001f64)\n        && (((*p1).w as libc::c_double) < (*p2).w as libc::c_double + 0.0001f64\n            && (*p1).w as libc::c_double > (*p2).w as libc::c_double - 0.0001f64)\n    {\n        return 1 as libc::c_int;\n    }\n    return 0 as libc::c_int;\n}","src::kazmath::vec4::kmVec4Lerp":"pub unsafe extern \"C\" fn kmVec4Lerp(\n    mut pOut: Option<&mut crate::src::kazmath::plane::kmVec4>,\n    mut pV1: *const crate::src::kazmath::plane::kmVec4,\n    mut pV2: *const crate::src::kazmath::plane::kmVec4,\n    mut t: libc::c_float,\n) -> *mut crate::src::kazmath::plane::kmVec4 {\n    (*pOut.as_deref_mut().unwrap()).x= (*pV1).x + t * ((*pV2).x - (*pV1).x);\n    (*pOut.as_deref_mut().unwrap()).y= (*pV1).y + t * ((*pV2).y - (*pV1).y);\n    (*pOut.as_deref_mut().unwrap()).z= (*pV1).z + t * ((*pV2).z - (*pV1).z);\n    (*pOut.as_deref_mut().unwrap()).w= (*pV1).w + t * ((*pV2).w - (*pV1).w);\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::mat4::kmMat4RotationX":"pub unsafe extern \"C\" fn kmMat4RotationX(\n    mut pOut: Option<&mut crate::src::kazmath::mat3::kmMat4>,\n    mut radians: libc::c_float,\n) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int as usize]= 1.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[1 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[2 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[3 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[4 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[5 as libc::c_int as usize]= cosf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[6 as libc::c_int as usize]= sinf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[7 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[8 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[9 as libc::c_int as usize]= -sinf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[10 as libc::c_int as usize]= cosf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[11 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[12 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[13 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[14 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[15 as libc::c_int as usize]= 1.0f32;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::image::heman_image_array":"pub unsafe extern \"C\" fn heman_image_array(\n    mut img: *mut heman_image,\n    mut data: Option<&mut *mut libc::c_float>,\n    mut nfloats: Option<&mut libc::c_int>,\n) {\n    *data.as_deref_mut().unwrap()= (*img).data;\n    *nfloats.as_deref_mut().unwrap()= (*img).width * (*img).height * (*img).nbands;\n}","src::src::ops::heman_ops_sweep":"pub unsafe extern \"C\" fn heman_ops_sweep(\n    mut hmap: *mut heman_image,\n) -> *mut /* owning */ heman_image {\n    if (*hmap).nbands == 1 as libc::c_int {} else {\n        __assert_fail(\n            b\"hmap->nbands == 1\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            47 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_sweep(heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut result = crate::src::src::image::heman_image_create(\n        (*hmap).height,\n        1 as libc::c_int,\n        1 as libc::c_int,\n    );\n    let mut dst = (*result).data;\n    let mut src: *const libc::c_float = (*hmap).data as *const f32;\n    let mut invw = 1.0f32 / (*hmap).width as libc::c_float;\n    let mut y = 0 as libc::c_int;\n    while y < (*hmap).height {\n        let mut acc = 0 as libc::c_int as libc::c_float;\n        let mut x = 0 as libc::c_int;\n        while x < (*hmap).width {\n            let fresh2 = src;\n            src= src.offset(1);\n            acc+= (*fresh2);\n            x+= 1;\n        }\n        let fresh3 = dst;\n        dst= dst.offset(1);\n        *fresh3= acc * invw;\n        y+= 1;\n    }\n    return result;\n}","src::src::export::heman_export_ply":"pub unsafe extern \"C\" fn heman_export_ply(\n    mut img: Option<&mut heman_image>,\n    mut filename: *const libc::c_char,\n) {\n    if (*img.as_deref().unwrap()).nbands == 1 as libc::c_int {} else {\n        __assert_fail(\n            b\"img->nbands == 1\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/export.c\\0\" as *const u8 as *const libc::c_char,\n            8 as libc::c_int as libc::c_uint,\n            b\"void heman_export_ply(heman_image *, const char *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut fout = fopen(filename, b\"wb\\0\" as *const u8 as *const libc::c_char);\n    let mut ncols = (*img.as_deref().unwrap()).width - 1 as libc::c_int;\n    let mut nrows = (*img.as_deref().unwrap()).height - 1 as libc::c_int;\n    let mut ncells = ncols * nrows;\n    let mut nverts = (*img.as_deref().unwrap()).width * (*img.as_deref().unwrap()).height;\n    fprintf(\n        fout,\n        b\"ply\\nformat binary_little_endian 1.0\\ncomment heman\\nelement vertex %d\\nproperty float32 x\\nproperty float32 y\\nproperty float32 z\\nelement face %d\\nproperty list int32 int32 vertex_indices\\nend_header\\n\\0\"\n            as *const u8 as *const libc::c_char,\n        nverts,\n        ncells,\n    );\n    let mut invw = 2.0f32 / (*img.as_deref().unwrap()).width as libc::c_float;\n    let mut invh = 2.0f32 / (*img.as_deref().unwrap()).height as libc::c_float;\n    let mut vert: [libc::c_float; 3] = [0.; 3];\n    let mut j = 0 as libc::c_int;\n    while j < (*img.as_deref().unwrap()).height {\n        let mut i = 0 as libc::c_int;\n        while i < (*img.as_deref().unwrap()).width {\n            vert[0 as libc::c_int\n                as usize]= -(1 as libc::c_int) as libc::c_float\n                + i as libc::c_float * invw;\n            vert[1 as libc::c_int\n                as usize]= -(1 as libc::c_int) as libc::c_float\n                + j as libc::c_float * invh;\n            vert[2 as libc::c_int as usize]= *crate::src::src::image::heman_image_texel(img.as_deref_mut(), i, j);\n            fwrite(\n                vert.as_mut_ptr() as *const libc::c_void,\n                ::std::mem::size_of::<[libc::c_float; 3]>() as libc::c_ulong,\n                1 as libc::c_int as libc::c_ulong,\n                fout,\n            );\n            i+= 1;\n        }\n        j+= 1;\n    }\n    let mut face: [libc::c_int; 5] = [0; 5];\n    face[0 as libc::c_int as usize]= 4 as libc::c_int;\n    let mut j_0 = 0 as libc::c_int;\n    while j_0 < nrows {\n        let mut p = j_0 * (*img.as_deref().unwrap()).width;\n        let mut i_0 = 0 as libc::c_int;\n        while i_0 < ncols {\n            face[1 as libc::c_int as usize]= p;\n            face[2 as libc::c_int as usize]= p + 1 as libc::c_int;\n            face[3 as libc::c_int as usize]= p + (*img.as_deref().unwrap()).width + 1 as libc::c_int;\n            face[4 as libc::c_int as usize]= p + (*img.as_deref().unwrap()).width;\n            fwrite(\n                face.as_mut_ptr() as *const libc::c_void,\n                ::std::mem::size_of::<[libc::c_int; 5]>() as libc::c_ulong,\n                1 as libc::c_int as libc::c_ulong,\n                fout,\n            );\n            i_0+= 1;\n            p+= 1;\n        }\n        j_0+= 1;\n    }\n    fclose(fout);\n}","src::src::ops::heman_ops_percentiles":"pub unsafe extern \"C\" fn heman_ops_percentiles(\n    mut hmap: Option<&mut heman_image>,\n    mut nsteps: libc::c_int,\n    mut mask: *mut heman_image,\n    mut mask_color: heman_color,\n    mut invert_mask: libc::c_int,\n    mut offset: libc::c_float,\n) -> *mut heman_image {\n    if (*hmap.as_deref().unwrap()).nbands == 1 as libc::c_int {} else {\n        __assert_fail(\n            b\"hmap->nbands == 1\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            427 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_percentiles(heman_image *, int, heman_image *, heman_color, int, float)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if mask.is_null() || (*mask).nbands == 3 as libc::c_int {} else {\n        __assert_fail(\n            b\"!mask || mask->nbands == 3\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            428 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_percentiles(heman_image *, int, heman_image *, heman_color, int, float)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut size = (*hmap.as_deref().unwrap()).height * (*hmap.as_deref().unwrap()).width;\n    let mut src = (*hmap.as_deref().unwrap()).data;\n    let mut minv = 1000 as libc::c_int as libc::c_float;\n    let mut maxv = -(1000 as libc::c_int) as libc::c_float;\n    let mut npixels = 0 as libc::c_int;\n    let mut i = 0 as libc::c_int;\n    while i < size {\n        if mask.is_null() || _match(mask, mask_color, invert_mask, i) != 0 {\n            minv= if minv > *src.offset(i as isize) {\n                *src.offset(i as isize)\n            } else {\n                minv\n            };\n            maxv= if maxv > *src.offset(i as isize) {\n                maxv\n            } else {\n                *src.offset(i as isize)\n            };\n            npixels+= 1;\n        }\n        i+= 1;\n    }\n    let mut vals = malloc(\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(npixels as libc::c_ulong),\n    ) as *mut libc::c_float;\n    npixels= 0 as libc::c_int;\n    let mut i_0 = 0 as libc::c_int;\n    while i_0 < size {\n        if mask.is_null() || _match(mask, mask_color, invert_mask, i_0) != 0 {\n            let fresh20 = npixels;\n            npixels= npixels + 1;\n            *vals.offset(fresh20 as isize) = *src.offset(i_0 as isize);\n        }\n        i_0+= 1;\n    }\n    let mut percentiles = malloc(\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(nsteps as libc::c_ulong),\n    ) as *mut libc::c_float;\n    let mut tier = 0 as libc::c_int;\n    while tier < nsteps {\n        let mut height = qselect(vals, npixels, tier * npixels / nsteps);\n        *percentiles.offset(tier as isize) = height;\n        tier+= 1;\n    }\n    free(vals as *mut libc::c_void);\n    let mut i_1 = 0 as libc::c_int;\n    while i_1 < size {\n        let mut e = (*src);\n        if mask.is_null() || _match(mask, mask_color, invert_mask, i_1) != 0 {\n            let mut tier_0 = nsteps - 1 as libc::c_int;\n            while tier_0 >= 0 as libc::c_int {\n                if e > *percentiles.offset(tier_0 as isize) {\n                    e= *percentiles.offset(tier_0 as isize);\n                    break;\n                } else {\n                    tier_0-= 1;\n                }\n            }\n        }\n        let fresh21 = src;\n        src= src.offset(1);\n        *fresh21= e + offset;\n        i_1+= 1;\n    }\n    free(percentiles as *mut libc::c_void);\n    return hmap.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::quaternion::kmQuaternionFill":"pub unsafe extern \"C\" fn kmQuaternionFill(\n    mut pOut: Option<&mut crate::src::kazmath::mat3::kmQuaternion>,\n    mut x: libc::c_float,\n    mut y: libc::c_float,\n    mut z: libc::c_float,\n    mut w: libc::c_float,\n) -> *mut crate::src::kazmath::mat3::kmQuaternion {\n    (*pOut.as_deref_mut().unwrap()).x= x;\n    (*pOut.as_deref_mut().unwrap()).y= y;\n    (*pOut.as_deref_mut().unwrap()).z= z;\n    (*pOut.as_deref_mut().unwrap()).w= w;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::quaternion::kmQuaternionGetUpVec3":"pub unsafe extern \"C\" fn kmQuaternionGetUpVec3(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pIn: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    return kmQuaternionMultiplyVec3(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), pIn, &KM_VEC3_POS_Y);\n}","src::kazmath::vec3::kmVec3Mul":"pub unsafe extern \"C\" fn kmVec3Mul(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pV1: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pV2: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    (*pOut.as_deref_mut().unwrap()).x= (*pV1).x * (*pV2).x;\n    (*pOut.as_deref_mut().unwrap()).y= (*pV1).y * (*pV2).y;\n    (*pOut.as_deref_mut().unwrap()).z= (*pV1).z * (*pV2).z;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::utility::kmRadiansToDegrees":"pub unsafe extern \"C\" fn kmRadiansToDegrees(\n    mut radians: libc::c_float,\n) -> libc::c_float {\n    return (radians as libc::c_double\n        * (180.0f64 / 3.14159265358979323846f32 as libc::c_double)) as libc::c_float;\n}","src::kazmath::vec4::kmVec4MultiplyMat4":"pub unsafe extern \"C\" fn kmVec4MultiplyMat4(\n    mut pOut: Option<&mut crate::src::kazmath::plane::kmVec4>,\n    mut pV: *const crate::src::kazmath::plane::kmVec4,\n    mut pM: *const crate::src::kazmath::mat3::kmMat4,\n) -> *mut crate::src::kazmath::plane::kmVec4 {\n    (*pOut.as_deref_mut().unwrap()).x= (*pV).x * (*pM).mat[0 as libc::c_int as usize]\n        + (*pV).y * (*pM).mat[4 as libc::c_int as usize]\n        + (*pV).z * (*pM).mat[8 as libc::c_int as usize]\n        + (*pV).w * (*pM).mat[12 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).y= (*pV).x * (*pM).mat[1 as libc::c_int as usize]\n        + (*pV).y * (*pM).mat[5 as libc::c_int as usize]\n        + (*pV).z * (*pM).mat[9 as libc::c_int as usize]\n        + (*pV).w * (*pM).mat[13 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).z= (*pV).x * (*pM).mat[2 as libc::c_int as usize]\n        + (*pV).y * (*pM).mat[6 as libc::c_int as usize]\n        + (*pV).z * (*pM).mat[10 as libc::c_int as usize]\n        + (*pV).w * (*pM).mat[14 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).w= (*pV).x * (*pM).mat[3 as libc::c_int as usize]\n        + (*pV).y * (*pM).mat[7 as libc::c_int as usize]\n        + (*pV).z * (*pM).mat[11 as libc::c_int as usize]\n        + (*pV).w * (*pM).mat[15 as libc::c_int as usize];\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::mat4::kmMat4Identity":"pub unsafe extern \"C\" fn kmMat4Identity(mut pOut: *mut crate::src::kazmath::mat3::kmMat4) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    memset(\n        (*pOut).mat.as_mut_ptr() as *mut libc::c_void,\n        0 as libc::c_int,\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(16 as libc::c_int as libc::c_ulong),\n    );\n    (*pOut).mat[15 as libc::c_int as usize]= 1.0f32; (*pOut).mat[10 as libc::c_int as usize]= (*pOut).mat[15 as libc::c_int as usize]; (*pOut).mat[5 as libc::c_int as usize]= (*pOut).mat[10 as libc::c_int as usize]; (*pOut).mat[0 as libc::c_int as usize]= (*pOut).mat[5 as libc::c_int as usize];\n    return pOut;\n}","src::kazmath::vec3::kmVec3Reflect":"pub unsafe extern \"C\" fn kmVec3Reflect(\n    mut pOut: *mut crate::src::kazmath::aabb3::kmVec3,\n    mut pIn: *const crate::src::kazmath::aabb3::kmVec3,\n    mut normal: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    let mut tmp = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    {let crown_promoted_local_0 = 2.0f32 * kmVec3Dot(pIn, normal);kmVec3Scale(core::ptr::addr_of_mut!(tmp), normal, crown_promoted_local_0)};\n    kmVec3Subtract(pOut, pIn, core::ptr::addr_of!(tmp));\n    return pOut;\n}","src::kazmath::mat4::kmMat4Multiply":"pub unsafe extern \"C\" fn kmMat4Multiply(\n    mut pOut: *mut crate::src::kazmath::mat3::kmMat4,\n    mut pM1: *const crate::src::kazmath::mat3::kmMat4,\n    mut pM2: *const crate::src::kazmath::mat3::kmMat4,\n) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    let mut mat: [libc::c_float; 16] = [0.; 16];\n    let mut m1 = ((*pM1).mat).as_ptr();\n    let mut m2 = ((*pM2).mat).as_ptr();\n    mat[0 as libc::c_int\n        as usize]= *m1.offset(0 as libc::c_int as isize)\n        * *m2.offset(0 as libc::c_int as isize)\n        + *m1.offset(4 as libc::c_int as isize) * *m2.offset(1 as libc::c_int as isize)\n        + *m1.offset(8 as libc::c_int as isize) * *m2.offset(2 as libc::c_int as isize)\n        + *m1.offset(12 as libc::c_int as isize) * *m2.offset(3 as libc::c_int as isize);\n    mat[1 as libc::c_int\n        as usize]= *m1.offset(1 as libc::c_int as isize)\n        * *m2.offset(0 as libc::c_int as isize)\n        + *m1.offset(5 as libc::c_int as isize) * *m2.offset(1 as libc::c_int as isize)\n        + *m1.offset(9 as libc::c_int as isize) * *m2.offset(2 as libc::c_int as isize)\n        + *m1.offset(13 as libc::c_int as isize) * *m2.offset(3 as libc::c_int as isize);\n    mat[2 as libc::c_int\n        as usize]= *m1.offset(2 as libc::c_int as isize)\n        * *m2.offset(0 as libc::c_int as isize)\n        + *m1.offset(6 as libc::c_int as isize) * *m2.offset(1 as libc::c_int as isize)\n        + *m1.offset(10 as libc::c_int as isize) * *m2.offset(2 as libc::c_int as isize)\n        + *m1.offset(14 as libc::c_int as isize) * *m2.offset(3 as libc::c_int as isize);\n    mat[3 as libc::c_int\n        as usize]= *m1.offset(3 as libc::c_int as isize)\n        * *m2.offset(0 as libc::c_int as isize)\n        + *m1.offset(7 as libc::c_int as isize) * *m2.offset(1 as libc::c_int as isize)\n        + *m1.offset(11 as libc::c_int as isize) * *m2.offset(2 as libc::c_int as isize)\n        + *m1.offset(15 as libc::c_int as isize) * *m2.offset(3 as libc::c_int as isize);\n    mat[4 as libc::c_int\n        as usize]= *m1.offset(0 as libc::c_int as isize)\n        * *m2.offset(4 as libc::c_int as isize)\n        + *m1.offset(4 as libc::c_int as isize) * *m2.offset(5 as libc::c_int as isize)\n        + *m1.offset(8 as libc::c_int as isize) * *m2.offset(6 as libc::c_int as isize)\n        + *m1.offset(12 as libc::c_int as isize) * *m2.offset(7 as libc::c_int as isize);\n    mat[5 as libc::c_int\n        as usize]= *m1.offset(1 as libc::c_int as isize)\n        * *m2.offset(4 as libc::c_int as isize)\n        + *m1.offset(5 as libc::c_int as isize) * *m2.offset(5 as libc::c_int as isize)\n        + *m1.offset(9 as libc::c_int as isize) * *m2.offset(6 as libc::c_int as isize)\n        + *m1.offset(13 as libc::c_int as isize) * *m2.offset(7 as libc::c_int as isize);\n    mat[6 as libc::c_int\n        as usize]= *m1.offset(2 as libc::c_int as isize)\n        * *m2.offset(4 as libc::c_int as isize)\n        + *m1.offset(6 as libc::c_int as isize) * *m2.offset(5 as libc::c_int as isize)\n        + *m1.offset(10 as libc::c_int as isize) * *m2.offset(6 as libc::c_int as isize)\n        + *m1.offset(14 as libc::c_int as isize) * *m2.offset(7 as libc::c_int as isize);\n    mat[7 as libc::c_int\n        as usize]= *m1.offset(3 as libc::c_int as isize)\n        * *m2.offset(4 as libc::c_int as isize)\n        + *m1.offset(7 as libc::c_int as isize) * *m2.offset(5 as libc::c_int as isize)\n        + *m1.offset(11 as libc::c_int as isize) * *m2.offset(6 as libc::c_int as isize)\n        + *m1.offset(15 as libc::c_int as isize) * *m2.offset(7 as libc::c_int as isize);\n    mat[8 as libc::c_int\n        as usize]= *m1.offset(0 as libc::c_int as isize)\n        * *m2.offset(8 as libc::c_int as isize)\n        + *m1.offset(4 as libc::c_int as isize) * *m2.offset(9 as libc::c_int as isize)\n        + *m1.offset(8 as libc::c_int as isize) * *m2.offset(10 as libc::c_int as isize)\n        + *m1.offset(12 as libc::c_int as isize)\n            * *m2.offset(11 as libc::c_int as isize);\n    mat[9 as libc::c_int\n        as usize]= *m1.offset(1 as libc::c_int as isize)\n        * *m2.offset(8 as libc::c_int as isize)\n        + *m1.offset(5 as libc::c_int as isize) * *m2.offset(9 as libc::c_int as isize)\n        + *m1.offset(9 as libc::c_int as isize) * *m2.offset(10 as libc::c_int as isize)\n        + *m1.offset(13 as libc::c_int as isize)\n            * *m2.offset(11 as libc::c_int as isize);\n    mat[10 as libc::c_int\n        as usize]= *m1.offset(2 as libc::c_int as isize)\n        * *m2.offset(8 as libc::c_int as isize)\n        + *m1.offset(6 as libc::c_int as isize) * *m2.offset(9 as libc::c_int as isize)\n        + *m1.offset(10 as libc::c_int as isize) * *m2.offset(10 as libc::c_int as isize)\n        + *m1.offset(14 as libc::c_int as isize)\n            * *m2.offset(11 as libc::c_int as isize);\n    mat[11 as libc::c_int\n        as usize]= *m1.offset(3 as libc::c_int as isize)\n        * *m2.offset(8 as libc::c_int as isize)\n        + *m1.offset(7 as libc::c_int as isize) * *m2.offset(9 as libc::c_int as isize)\n        + *m1.offset(11 as libc::c_int as isize) * *m2.offset(10 as libc::c_int as isize)\n        + *m1.offset(15 as libc::c_int as isize)\n            * *m2.offset(11 as libc::c_int as isize);\n    mat[12 as libc::c_int\n        as usize]= *m1.offset(0 as libc::c_int as isize)\n        * *m2.offset(12 as libc::c_int as isize)\n        + *m1.offset(4 as libc::c_int as isize) * *m2.offset(13 as libc::c_int as isize)\n        + *m1.offset(8 as libc::c_int as isize) * *m2.offset(14 as libc::c_int as isize)\n        + *m1.offset(12 as libc::c_int as isize)\n            * *m2.offset(15 as libc::c_int as isize);\n    mat[13 as libc::c_int\n        as usize]= *m1.offset(1 as libc::c_int as isize)\n        * *m2.offset(12 as libc::c_int as isize)\n        + *m1.offset(5 as libc::c_int as isize) * *m2.offset(13 as libc::c_int as isize)\n        + *m1.offset(9 as libc::c_int as isize) * *m2.offset(14 as libc::c_int as isize)\n        + *m1.offset(13 as libc::c_int as isize)\n            * *m2.offset(15 as libc::c_int as isize);\n    mat[14 as libc::c_int\n        as usize]= *m1.offset(2 as libc::c_int as isize)\n        * *m2.offset(12 as libc::c_int as isize)\n        + *m1.offset(6 as libc::c_int as isize) * *m2.offset(13 as libc::c_int as isize)\n        + *m1.offset(10 as libc::c_int as isize) * *m2.offset(14 as libc::c_int as isize)\n        + *m1.offset(14 as libc::c_int as isize)\n            * *m2.offset(15 as libc::c_int as isize);\n    mat[15 as libc::c_int\n        as usize]= *m1.offset(3 as libc::c_int as isize)\n        * *m2.offset(12 as libc::c_int as isize)\n        + *m1.offset(7 as libc::c_int as isize) * *m2.offset(13 as libc::c_int as isize)\n        + *m1.offset(11 as libc::c_int as isize) * *m2.offset(14 as libc::c_int as isize)\n        + *m1.offset(15 as libc::c_int as isize)\n            * *m2.offset(15 as libc::c_int as isize);\n    memcpy(\n        (*pOut).mat.as_mut_ptr() as *mut libc::c_void,\n        mat.as_mut_ptr() as *const libc::c_void,\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(16 as libc::c_int as libc::c_ulong),\n    );\n    return pOut;\n}","src::kazmath::aabb2::kmAABB2DiameterX":"pub unsafe extern \"C\" fn kmAABB2DiameterX(mut aabb: *const kmAABB2) -> libc::c_float {\n    return (*aabb).max.x - (*aabb).min.x;\n}","src::kazmath::quaternion::kmQuaternionAdd":"pub unsafe extern \"C\" fn kmQuaternionAdd(\n    mut pOut: *mut crate::src::kazmath::mat3::kmQuaternion,\n    mut pQ1: *const crate::src::kazmath::mat3::kmQuaternion,\n    mut pQ2: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> *mut crate::src::kazmath::mat3::kmQuaternion {\n    (*pOut).x= (*pQ1).x + (*pQ2).x;\n    (*pOut).y= (*pQ1).y + (*pQ2).y;\n    (*pOut).z= (*pQ1).z + (*pQ2).z;\n    (*pOut).w= (*pQ1).w + (*pQ2).w;\n    return pOut;\n}","src::src::noise::open_simplex_noise2":"pub unsafe extern \"C\" fn open_simplex_noise2(\n    mut ctx: *mut osn_context,\n    mut x: libc::c_double,\n    mut y: libc::c_double,\n) -> libc::c_double {\n    let mut stretchOffset = (x + y) * -0.211324865405187f64;\n    let mut xs = x + stretchOffset;\n    let mut ys = y + stretchOffset;\n    let mut xsb = fastFloor(xs);\n    let mut ysb = fastFloor(ys);\n    let mut squishOffset = (xsb + ysb) as libc::c_double * 0.366025403784439f64;\n    let mut xb = xsb as libc::c_double + squishOffset;\n    let mut yb = ysb as libc::c_double + squishOffset;\n    let mut xins = xs - xsb as libc::c_double;\n    let mut yins = ys - ysb as libc::c_double;\n    let mut inSum = xins + yins;\n    let mut dx0 = x - xb;\n    let mut dy0 = y - yb;\n    let mut dx_ext: libc::c_double = 0.;\n    let mut dy_ext: libc::c_double = 0.;\n    let mut xsv_ext: libc::c_int = 0;\n    let mut ysv_ext: libc::c_int = 0;\n    let mut value = 0 as libc::c_int as libc::c_double;\n    let mut dx1 = dx0 - 1 as libc::c_int as libc::c_double - 0.366025403784439f64;\n    let mut dy1 = dy0 - 0 as libc::c_int as libc::c_double - 0.366025403784439f64;\n    let mut attn1 = 2 as libc::c_int as libc::c_double - dx1 * dx1 - dy1 * dy1;\n    if attn1 > 0 as libc::c_int as libc::c_double {\n        attn1*= attn1;\n        value+= attn1 * attn1\n                * extrapolate2(\n                    ctx,\n                    xsb + 1 as libc::c_int,\n                    ysb + 0 as libc::c_int,\n                    dx1,\n                    dy1,\n                );\n    }\n    let mut dx2 = dx0 - 0 as libc::c_int as libc::c_double - 0.366025403784439f64;\n    let mut dy2 = dy0 - 1 as libc::c_int as libc::c_double - 0.366025403784439f64;\n    let mut attn2 = 2 as libc::c_int as libc::c_double - dx2 * dx2 - dy2 * dy2;\n    if attn2 > 0 as libc::c_int as libc::c_double {\n        attn2*= attn2;\n        value+= attn2 * attn2\n                * extrapolate2(\n                    ctx,\n                    xsb + 0 as libc::c_int,\n                    ysb + 1 as libc::c_int,\n                    dx2,\n                    dy2,\n                );\n    }\n    if inSum <= 1 as libc::c_int as libc::c_double {\n        let mut zins = 1 as libc::c_int as libc::c_double - inSum;\n        if zins > xins || zins > yins {\n            if xins > yins {\n                xsv_ext= xsb + 1 as libc::c_int;\n                ysv_ext= ysb - 1 as libc::c_int;\n                dx_ext= dx0 - 1 as libc::c_int as libc::c_double;\n                dy_ext= dy0 + 1 as libc::c_int as libc::c_double;\n            } else {\n                xsv_ext= xsb - 1 as libc::c_int;\n                ysv_ext= ysb + 1 as libc::c_int;\n                dx_ext= dx0 + 1 as libc::c_int as libc::c_double;\n                dy_ext= dy0 - 1 as libc::c_int as libc::c_double;\n            }\n        } else {\n            xsv_ext= xsb + 1 as libc::c_int;\n            ysv_ext= ysb + 1 as libc::c_int;\n            dx_ext= dx0 - 1 as libc::c_int as libc::c_double\n                - 2 as libc::c_int as libc::c_double * 0.366025403784439f64;\n            dy_ext= dy0 - 1 as libc::c_int as libc::c_double\n                - 2 as libc::c_int as libc::c_double * 0.366025403784439f64;\n        }\n    } else {\n        let mut zins_0 = 2 as libc::c_int as libc::c_double - inSum;\n        if zins_0 < xins || zins_0 < yins {\n            if xins > yins {\n                xsv_ext= xsb + 2 as libc::c_int;\n                ysv_ext= ysb + 0 as libc::c_int;\n                dx_ext= dx0 - 2 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * 0.366025403784439f64;\n                dy_ext= dy0 + 0 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * 0.366025403784439f64;\n            } else {\n                xsv_ext= xsb + 0 as libc::c_int;\n                ysv_ext= ysb + 2 as libc::c_int;\n                dx_ext= dx0 + 0 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * 0.366025403784439f64;\n                dy_ext= dy0 - 2 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * 0.366025403784439f64;\n            }\n        } else {\n            dx_ext= dx0;\n            dy_ext= dy0;\n            xsv_ext= xsb;\n            ysv_ext= ysb;\n        }\n        xsb+= 1 as libc::c_int;\n        ysb+= 1 as libc::c_int;\n        dx0= dx0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.366025403784439f64;\n        dy0= dy0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.366025403784439f64;\n    }\n    let mut attn0 = 2 as libc::c_int as libc::c_double - dx0 * dx0 - dy0 * dy0;\n    if attn0 > 0 as libc::c_int as libc::c_double {\n        attn0*= attn0;\n        value+= attn0 * attn0 * extrapolate2(ctx, xsb, ysb, dx0, dy0);\n    }\n    let mut attn_ext = 2 as libc::c_int as libc::c_double - dx_ext * dx_ext\n        - dy_ext * dy_ext;\n    if attn_ext > 0 as libc::c_int as libc::c_double {\n        attn_ext*= attn_ext;\n        value+= attn_ext * attn_ext * extrapolate2(ctx, xsv_ext, ysv_ext, dx_ext, dy_ext);\n    }\n    return value / 47.0f64;\n}","src::kazmath::vec2::kmVec2Assign":"pub unsafe extern \"C\" fn kmVec2Assign(\n    mut pOut: *mut crate::src::kazmath::aabb2::kmVec2,\n    mut pIn: *const crate::src::kazmath::aabb2::kmVec2,\n) -> *mut crate::src::kazmath::aabb2::kmVec2 {\n    if pOut == pIn as *mut crate::src::kazmath::aabb2::kmVec2 {\n        return pOut;\n    }\n    (*pOut).x= (*pIn).x;\n    (*pOut).y= (*pIn).y;\n    return pOut;\n}","src::src::distance::transform_to_distance":"unsafe extern \"C\" fn transform_to_distance(mut sdf: Option<&mut heman_image>) {\n    let mut width = (*sdf.as_deref().unwrap()).width;\n    let mut height = (*sdf.as_deref().unwrap()).height;\n    let mut size = width * height;\n    let mut ff = calloc(\n        size as libc::c_ulong,\n        ::std::mem::size_of::<libc::c_float>() as libc::c_ulong,\n    ) as *mut libc::c_float;\n    let mut dd = calloc(\n        size as libc::c_ulong,\n        ::std::mem::size_of::<libc::c_float>() as libc::c_ulong,\n    ) as *mut libc::c_float;\n    let mut zz = calloc(\n        ((height + 1 as libc::c_int) * (width + 1 as libc::c_int)) as libc::c_ulong,\n        ::std::mem::size_of::<libc::c_float>() as libc::c_ulong,\n    ) as *mut libc::c_float;\n    let mut ww = calloc(\n        size as libc::c_ulong,\n        ::std::mem::size_of::<uint16_t>() as libc::c_ulong,\n    ) as *mut uint16_t;\n    let mut x: libc::c_int = 0;\n    x= 0 as libc::c_int;\n    while x < width {\n        let mut f = ff.offset((height * x) as isize);\n        let mut d = dd.offset((height * x) as isize);\n        let mut z = zz.offset(((height + 1 as libc::c_int) * x) as isize);\n        let mut w = ww.offset((height * x) as isize);\n        let mut y = 0 as libc::c_int;\n        while y < height {\n            *f\n                .offset(\n                    y as isize,\n                ) = *(*sdf.as_deref().unwrap()).data.offset((y * width) as isize).offset(x as isize);\n            y+= 1;\n        }\n        edt(f, d, z, w, height);\n        let mut y_0 = 0 as libc::c_int;\n        while y_0 < height {\n            *(*sdf.as_deref().unwrap()).data\n                .offset((y_0 * width) as isize)\n                .offset(x as isize) = *d.offset(y_0 as isize);\n            y_0+= 1;\n        }\n        x+= 1;\n    }\n    let mut y_1: libc::c_int = 0;\n    y_1= 0 as libc::c_int;\n    while y_1 < height {\n        let mut f_0 = ff.offset((width * y_1) as isize);\n        let mut d_0 = dd.offset((width * y_1) as isize);\n        let mut z_0 = zz.offset(((width + 1 as libc::c_int) * y_1) as isize);\n        let mut w_0 = ww.offset((width * y_1) as isize);\n        let mut x_0 = 0 as libc::c_int;\n        while x_0 < width {\n            *f_0\n                .offset(\n                    x_0 as isize,\n                ) = *(*sdf.as_deref().unwrap()).data.offset((y_1 * width) as isize).offset(x_0 as isize);\n            x_0+= 1;\n        }\n        edt(f_0, d_0, z_0, w_0, width);\n        let mut x_1 = 0 as libc::c_int;\n        while x_1 < width {\n            *(*sdf.as_deref().unwrap()).data\n                .offset((y_1 * width) as isize)\n                .offset(x_1 as isize) = *d_0.offset(x_1 as isize);\n            x_1+= 1;\n        }\n        y_1+= 1;\n    }\n    free(ff as *mut libc::c_void);\n    free(dd as *mut libc::c_void);\n    free(zz as *mut libc::c_void);\n    free(ww as *mut libc::c_void);\n}","src::kazmath::ray2::kmRay2IntersectCircle":"pub unsafe extern \"C\" fn kmRay2IntersectCircle(\n    mut ray: *const kmRay2,\n    mut centre: crate::src::kazmath::aabb2::kmVec2,\n    mut radius: libc::c_float,\n    mut intersection: *mut crate::src::kazmath::aabb2::kmVec2,\n) -> libc::c_uchar {\n    if 0 as libc::c_int != 0\n        && !(b\"Not implemented\\0\" as *const u8 as *const libc::c_char).is_null()\n    {} else {\n        __assert_fail(\n            b\"0 && \\\"Not implemented\\\"\\0\" as *const u8 as *const libc::c_char,\n            b\"../kazmath/ray2.c\\0\" as *const u8 as *const libc::c_char,\n            256 as libc::c_int as libc::c_uint,\n            b\"unsigned char kmRay2IntersectCircle(const kmRay2 *, const kmVec2, const float, kmVec2 *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    return 1 as libc::c_int as libc::c_uchar;\n}","src::kazmath::mat4::kmMat4RotationTranslation":"pub unsafe extern \"C\" fn kmMat4RotationTranslation(\n    mut pOut: Option<&mut crate::src::kazmath::mat3::kmMat4>,\n    mut rotation: *const crate::src::kazmath::mat3::kmMat3,\n    mut translation: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int as usize]= (*rotation).mat[0 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[1 as libc::c_int as usize]= (*rotation).mat[1 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[2 as libc::c_int as usize]= (*rotation).mat[2 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[3 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[4 as libc::c_int as usize]= (*rotation).mat[3 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[5 as libc::c_int as usize]= (*rotation).mat[4 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[6 as libc::c_int as usize]= (*rotation).mat[5 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[7 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[8 as libc::c_int as usize]= (*rotation).mat[6 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[9 as libc::c_int as usize]= (*rotation).mat[7 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[10 as libc::c_int as usize]= (*rotation).mat[8 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[11 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[12 as libc::c_int as usize]= (*translation).x;\n    (*pOut.as_deref_mut().unwrap()).mat[13 as libc::c_int as usize]= (*translation).y;\n    (*pOut.as_deref_mut().unwrap()).mat[14 as libc::c_int as usize]= (*translation).z;\n    (*pOut.as_deref_mut().unwrap()).mat[15 as libc::c_int as usize]= 1.0f32;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::quaternion::kmQuaternionGetYaw":"pub unsafe extern \"C\" fn kmQuaternionGetYaw(\n    mut q: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> libc::c_float {\n    let mut result = asin(\n        (-(2 as libc::c_int) as libc::c_float * ((*q).x * (*q).z - (*q).w * (*q).y))\n            as libc::c_double,\n    ) as libc::c_float;\n    return result;\n}","src::src::image::heman_image_extract_alpha":"pub unsafe extern \"C\" fn heman_image_extract_alpha(\n    mut img: *mut heman_image,\n) -> *mut /* owning */ heman_image {\n    if (*img).nbands == 4 as libc::c_int {} else {\n        __assert_fail(\n            b\"img->nbands == 4\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/image.c\\0\" as *const u8 as *const libc::c_char,\n            63 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_image_extract_alpha(heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut retval = heman_image_create((*img).width, (*img).height, 1 as libc::c_int);\n    let mut size = (*img).width * (*img).height;\n    let mut src = (*img).data;\n    let mut dst = (*retval).data;\n    loop {\n        let fresh5 = size;\n        size= size - 1;\n        if !(fresh5 != 0) {\n            break;\n        }\n        src= src.offset(3 as libc::c_int as isize);\n        let fresh6 = src;\n        src= src.offset(1);\n        let fresh7 = dst;\n        dst= dst.offset(1);\n        *fresh7= (*fresh6);\n    }\n    return retval;\n}","src::kazmath::quaternion::kmQuaternionGetForwardVec3LH":"pub unsafe extern \"C\" fn kmQuaternionGetForwardVec3LH(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pIn: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    return kmQuaternionMultiplyVec3(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), pIn, &KM_VEC3_POS_Z);\n}","src::kazmath::mat3::kmMat3Scaling":"pub unsafe extern \"C\" fn kmMat3Scaling(\n    mut pOut: Option<&mut kmMat3>,\n    mut x: libc::c_float,\n    mut y: libc::c_float,\n) -> *mut kmMat3 {\n    kmMat3Identity(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()));\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int as usize]= x;\n    (*pOut.as_deref_mut().unwrap()).mat[4 as libc::c_int as usize]= y;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::mat3::kmMat3Rotation":"pub unsafe extern \"C\" fn kmMat3Rotation(\n    mut pOut: Option<&mut kmMat3>,\n    mut radians: libc::c_float,\n) -> *mut kmMat3 {\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int as usize]= cosf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[1 as libc::c_int as usize]= sinf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[2 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[3 as libc::c_int as usize]= -sinf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[4 as libc::c_int as usize]= cosf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[5 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[6 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[7 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[8 as libc::c_int as usize]= 1.0f32;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::generate::heman_generate_planet_heightmap":"pub unsafe extern \"C\" fn heman_generate_planet_heightmap(\n    mut width: libc::c_int,\n    mut height: libc::c_int,\n    mut seed: libc::c_int,\n) -> *mut /* owning */ heman_image {\n    let mut ctx = 0 as *mut crate::src::src::noise::osn_context;\n    crate::src::src::noise::open_simplex_noise(seed as int64_t, Some(&mut ctx));\n    let mut result = crate::src::src::image::heman_image_create(width, height, 1 as libc::c_int);\n    let mut scalex = (2.0f32 as libc::c_double * 3.1415926535f64\n        / width as libc::c_double) as libc::c_float;\n    let mut scaley = (3.1415926535f64 / height as libc::c_double) as libc::c_float;\n    let mut invh = 1.0f32 / height as libc::c_float;\n    let mut y: libc::c_int = 0;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut dst = (*result).data.offset((y * width) as isize);\n        let mut p = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n        let mut v = y as libc::c_float * invh;\n        let mut s = 0.95f64 as libc::c_float;\n        let mut antarctic_influence = (if (10 as libc::c_int as libc::c_float * (v - s)\n            / s) as libc::c_double > -0.5f64\n        {\n            (10 as libc::c_int as libc::c_float * (v - s) / s) as libc::c_double\n        } else {\n            -0.5f64\n        }) as libc::c_float;\n        v= fabs(v as libc::c_double - 0.5f64) as libc::c_float;\n        v= (1.5f64 * (0.5f64 - v as libc::c_double)) as libc::c_float;\n        let mut equatorial_influence = v * v;\n        v= y as libc::c_float * scaley;\n        let mut x = 0 as libc::c_int;\n        while x < width {\n            let mut u = x as libc::c_float * scalex;\n            let mut freq = 1 as libc::c_int as libc::c_float;\n            let mut amp = 1 as libc::c_int as libc::c_float;\n            let mut h = antarctic_influence + equatorial_influence;\n            let mut oct = 0 as libc::c_int;\n            while oct < 6 as libc::c_int {\n                sphere(u, v, freq, Some(&mut p));\n                h= (h as libc::c_double\n                    + amp as libc::c_double\n                        * crate::src::src::noise::open_simplex_noise3(\n                            ctx,\n                            p.x as libc::c_double,\n                            p.y as libc::c_double,\n                            p.z as libc::c_double,\n                        )) as libc::c_float;\n                amp= (amp as libc::c_double * 0.5f64) as libc::c_float;\n                freq*= 2 as libc::c_int as libc::c_float;\n                oct+= 1;\n            }\n            let fresh10 = dst;\n            dst= dst.offset(1);\n            *fresh10= h;\n            x+= 1;\n        }\n        y+= 1;\n    }\n    crate::src::src::noise::open_simplex_noise_free(ctx);\n    return result;\n}","src::src::noise::open_simplex_noise3":"pub unsafe extern \"C\" fn open_simplex_noise3(\n    mut ctx: *mut osn_context,\n    mut x: libc::c_double,\n    mut y: libc::c_double,\n    mut z: libc::c_double,\n) -> libc::c_double {\n    let mut stretchOffset = (x + y + z) * (-1.0f64 / 6.0f64);\n    let mut xs = x + stretchOffset;\n    let mut ys = y + stretchOffset;\n    let mut zs = z + stretchOffset;\n    let mut xsb = fastFloor(xs);\n    let mut ysb = fastFloor(ys);\n    let mut zsb = fastFloor(zs);\n    let mut squishOffset = (xsb + ysb + zsb) as libc::c_double * (1.0f64 / 3.0f64);\n    let mut xb = xsb as libc::c_double + squishOffset;\n    let mut yb = ysb as libc::c_double + squishOffset;\n    let mut zb = zsb as libc::c_double + squishOffset;\n    let mut xins = xs - xsb as libc::c_double;\n    let mut yins = ys - ysb as libc::c_double;\n    let mut zins = zs - zsb as libc::c_double;\n    let mut inSum = xins + yins + zins;\n    let mut dx0 = x - xb;\n    let mut dy0 = y - yb;\n    let mut dz0 = z - zb;\n    let mut dx_ext0: libc::c_double = 0.;\n    let mut dy_ext0: libc::c_double = 0.;\n    let mut dz_ext0: libc::c_double = 0.;\n    let mut dx_ext1: libc::c_double = 0.;\n    let mut dy_ext1: libc::c_double = 0.;\n    let mut dz_ext1: libc::c_double = 0.;\n    let mut xsv_ext0: libc::c_int = 0;\n    let mut ysv_ext0: libc::c_int = 0;\n    let mut zsv_ext0: libc::c_int = 0;\n    let mut xsv_ext1: libc::c_int = 0;\n    let mut ysv_ext1: libc::c_int = 0;\n    let mut zsv_ext1: libc::c_int = 0;\n    let mut value = 0 as libc::c_int as libc::c_double;\n    if inSum <= 1 as libc::c_int as libc::c_double {\n        let mut aPoint = 0x1 as libc::c_int as int8_t;\n        let mut aScore = xins;\n        let mut bPoint = 0x2 as libc::c_int as int8_t;\n        let mut bScore = yins;\n        if aScore >= bScore && zins > bScore {\n            bScore= zins;\n            bPoint= 0x4 as libc::c_int as int8_t;\n        } else if aScore < bScore && zins > aScore {\n            aScore= zins;\n            aPoint= 0x4 as libc::c_int as int8_t;\n        }\n        let mut wins = 1 as libc::c_int as libc::c_double - inSum;\n        if wins > aScore || wins > bScore {\n            let mut c = (if bScore > aScore {\n                bPoint as libc::c_int\n            } else {\n                aPoint as libc::c_int\n            }) as int8_t;\n            if c as libc::c_int & 0x1 as libc::c_int == 0 as libc::c_int {\n                xsv_ext0= xsb - 1 as libc::c_int;\n                xsv_ext1= xsb;\n                dx_ext0= dx0 + 1 as libc::c_int as libc::c_double;\n                dx_ext1= dx0;\n            } else {\n                xsv_ext1= xsb + 1 as libc::c_int;\n                xsv_ext0= xsv_ext1;\n                dx_ext1= dx0 - 1 as libc::c_int as libc::c_double;\n                dx_ext0= dx_ext1;\n            }\n            if c as libc::c_int & 0x2 as libc::c_int == 0 as libc::c_int {\n                ysv_ext1= ysb;\n                ysv_ext0= ysv_ext1;\n                dy_ext1= dy0;\n                dy_ext0= dy_ext1;\n                if c as libc::c_int & 0x1 as libc::c_int == 0 as libc::c_int {\n                    ysv_ext1-= 1 as libc::c_int;\n                    dy_ext1+= 1 as libc::c_int as libc::c_double;\n                } else {\n                    ysv_ext0-= 1 as libc::c_int;\n                    dy_ext0+= 1 as libc::c_int as libc::c_double;\n                }\n            } else {\n                ysv_ext1= ysb + 1 as libc::c_int;\n                ysv_ext0= ysv_ext1;\n                dy_ext1= dy0 - 1 as libc::c_int as libc::c_double;\n                dy_ext0= dy_ext1;\n            }\n            if c as libc::c_int & 0x4 as libc::c_int == 0 as libc::c_int {\n                zsv_ext0= zsb;\n                zsv_ext1= zsb - 1 as libc::c_int;\n                dz_ext0= dz0;\n                dz_ext1= dz0 + 1 as libc::c_int as libc::c_double;\n            } else {\n                zsv_ext1= zsb + 1 as libc::c_int;\n                zsv_ext0= zsv_ext1;\n                dz_ext1= dz0 - 1 as libc::c_int as libc::c_double;\n                dz_ext0= dz_ext1;\n            }\n        } else {\n            let mut c_0 = (aPoint as libc::c_int | bPoint as libc::c_int) as int8_t;\n            if c_0 as libc::c_int & 0x1 as libc::c_int == 0 as libc::c_int {\n                xsv_ext0= xsb;\n                xsv_ext1= xsb - 1 as libc::c_int;\n                dx_ext0= dx0 - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                dx_ext1= dx0 + 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n            } else {\n                xsv_ext1= xsb + 1 as libc::c_int;\n                xsv_ext0= xsv_ext1;\n                dx_ext0= dx0 - 1 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                dx_ext1= dx0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n            }\n            if c_0 as libc::c_int & 0x2 as libc::c_int == 0 as libc::c_int {\n                ysv_ext0= ysb;\n                ysv_ext1= ysb - 1 as libc::c_int;\n                dy_ext0= dy0 - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                dy_ext1= dy0 + 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n            } else {\n                ysv_ext1= ysb + 1 as libc::c_int;\n                ysv_ext0= ysv_ext1;\n                dy_ext0= dy0 - 1 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                dy_ext1= dy0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n            }\n            if c_0 as libc::c_int & 0x4 as libc::c_int == 0 as libc::c_int {\n                zsv_ext0= zsb;\n                zsv_ext1= zsb - 1 as libc::c_int;\n                dz_ext0= dz0 - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                dz_ext1= dz0 + 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n            } else {\n                zsv_ext1= zsb + 1 as libc::c_int;\n                zsv_ext0= zsv_ext1;\n                dz_ext0= dz0 - 1 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                dz_ext1= dz0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n            }\n        }\n        let mut attn0 = 2 as libc::c_int as libc::c_double - dx0 * dx0 - dy0 * dy0\n            - dz0 * dz0;\n        if attn0 > 0 as libc::c_int as libc::c_double {\n            attn0*= attn0;\n            value+= attn0 * attn0\n                    * extrapolate3(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        dx0,\n                        dy0,\n                        dz0,\n                    );\n        }\n        let mut dx1 = dx0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n        let mut dy1 = dy0 - 0 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n        let mut dz1 = dz0 - 0 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n        let mut attn1 = 2 as libc::c_int as libc::c_double - dx1 * dx1 - dy1 * dy1\n            - dz1 * dz1;\n        if attn1 > 0 as libc::c_int as libc::c_double {\n            attn1*= attn1;\n            value+= attn1 * attn1\n                    * extrapolate3(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        dx1,\n                        dy1,\n                        dz1,\n                    );\n        }\n        let mut dx2 = dx0 - 0 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n        let mut dy2 = dy0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n        let mut dz2 = dz1;\n        let mut attn2 = 2 as libc::c_int as libc::c_double - dx2 * dx2 - dy2 * dy2\n            - dz2 * dz2;\n        if attn2 > 0 as libc::c_int as libc::c_double {\n            attn2*= attn2;\n            value+= attn2 * attn2\n                    * extrapolate3(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        dx2,\n                        dy2,\n                        dz2,\n                    );\n        }\n        let mut dx3 = dx2;\n        let mut dy3 = dy1;\n        let mut dz3 = dz0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n        let mut attn3 = 2 as libc::c_int as libc::c_double - dx3 * dx3 - dy3 * dy3\n            - dz3 * dz3;\n        if attn3 > 0 as libc::c_int as libc::c_double {\n            attn3*= attn3;\n            value+= attn3 * attn3\n                    * extrapolate3(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        dx3,\n                        dy3,\n                        dz3,\n                    );\n        }\n    } else if inSum >= 2 as libc::c_int as libc::c_double {\n        let mut aPoint_0 = 0x6 as libc::c_int as int8_t;\n        let mut aScore_0 = xins;\n        let mut bPoint_0 = 0x5 as libc::c_int as int8_t;\n        let mut bScore_0 = yins;\n        if aScore_0 <= bScore_0 && zins < bScore_0 {\n            bScore_0= zins;\n            bPoint_0= 0x3 as libc::c_int as int8_t;\n        } else if aScore_0 > bScore_0 && zins < aScore_0 {\n            aScore_0= zins;\n            aPoint_0= 0x3 as libc::c_int as int8_t;\n        }\n        let mut wins_0 = 3 as libc::c_int as libc::c_double - inSum;\n        if wins_0 < aScore_0 || wins_0 < bScore_0 {\n            let mut c_1 = (if bScore_0 < aScore_0 {\n                bPoint_0 as libc::c_int\n            } else {\n                aPoint_0 as libc::c_int\n            }) as int8_t;\n            if c_1 as libc::c_int & 0x1 as libc::c_int != 0 as libc::c_int {\n                xsv_ext0= xsb + 2 as libc::c_int;\n                xsv_ext1= xsb + 1 as libc::c_int;\n                dx_ext0= dx0 - 2 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                dx_ext1= dx0 - 1 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n            } else {\n                xsv_ext1= xsb;\n                xsv_ext0= xsv_ext1;\n                dx_ext1= dx0 - 3 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                dx_ext0= dx_ext1;\n            }\n            if c_1 as libc::c_int & 0x2 as libc::c_int != 0 as libc::c_int {\n                ysv_ext1= ysb + 1 as libc::c_int;\n                ysv_ext0= ysv_ext1;\n                dy_ext1= dy0 - 1 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                dy_ext0= dy_ext1;\n                if c_1 as libc::c_int & 0x1 as libc::c_int != 0 as libc::c_int {\n                    ysv_ext1+= 1 as libc::c_int;\n                    dy_ext1-= 1 as libc::c_int as libc::c_double;\n                } else {\n                    ysv_ext0+= 1 as libc::c_int;\n                    dy_ext0-= 1 as libc::c_int as libc::c_double;\n                }\n            } else {\n                ysv_ext1= ysb;\n                ysv_ext0= ysv_ext1;\n                dy_ext1= dy0 - 3 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                dy_ext0= dy_ext1;\n            }\n            if c_1 as libc::c_int & 0x4 as libc::c_int != 0 as libc::c_int {\n                zsv_ext0= zsb + 1 as libc::c_int;\n                zsv_ext1= zsb + 2 as libc::c_int;\n                dz_ext0= dz0 - 1 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                dz_ext1= dz0 - 2 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n            } else {\n                zsv_ext1= zsb;\n                zsv_ext0= zsv_ext1;\n                dz_ext1= dz0 - 3 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                dz_ext0= dz_ext1;\n            }\n        } else {\n            let mut c_2 = (aPoint_0 as libc::c_int & bPoint_0 as libc::c_int) as int8_t;\n            if c_2 as libc::c_int & 0x1 as libc::c_int != 0 as libc::c_int {\n                xsv_ext0= xsb + 1 as libc::c_int;\n                xsv_ext1= xsb + 2 as libc::c_int;\n                dx_ext0= dx0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                dx_ext1= dx0 - 2 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n            } else {\n                xsv_ext1= xsb;\n                xsv_ext0= xsv_ext1;\n                dx_ext0= dx0 - 1.0f64 / 3.0f64;\n                dx_ext1= dx0 - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n            }\n            if c_2 as libc::c_int & 0x2 as libc::c_int != 0 as libc::c_int {\n                ysv_ext0= ysb + 1 as libc::c_int;\n                ysv_ext1= ysb + 2 as libc::c_int;\n                dy_ext0= dy0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                dy_ext1= dy0 - 2 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n            } else {\n                ysv_ext1= ysb;\n                ysv_ext0= ysv_ext1;\n                dy_ext0= dy0 - 1.0f64 / 3.0f64;\n                dy_ext1= dy0 - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n            }\n            if c_2 as libc::c_int & 0x4 as libc::c_int != 0 as libc::c_int {\n                zsv_ext0= zsb + 1 as libc::c_int;\n                zsv_ext1= zsb + 2 as libc::c_int;\n                dz_ext0= dz0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                dz_ext1= dz0 - 2 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n            } else {\n                zsv_ext1= zsb;\n                zsv_ext0= zsv_ext1;\n                dz_ext0= dz0 - 1.0f64 / 3.0f64;\n                dz_ext1= dz0 - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n            }\n        }\n        let mut dx3_0 = dx0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n        let mut dy3_0 = dy0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n        let mut dz3_0 = dz0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n        let mut attn3_0 = 2 as libc::c_int as libc::c_double - dx3_0 * dx3_0\n            - dy3_0 * dy3_0 - dz3_0 * dz3_0;\n        if attn3_0 > 0 as libc::c_int as libc::c_double {\n            attn3_0*= attn3_0;\n            value+= attn3_0 * attn3_0\n                    * extrapolate3(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        dx3_0,\n                        dy3_0,\n                        dz3_0,\n                    );\n        }\n        let mut dx2_0 = dx3_0;\n        let mut dy2_0 = dy0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n        let mut dz2_0 = dz0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n        let mut attn2_0 = 2 as libc::c_int as libc::c_double - dx2_0 * dx2_0\n            - dy2_0 * dy2_0 - dz2_0 * dz2_0;\n        if attn2_0 > 0 as libc::c_int as libc::c_double {\n            attn2_0*= attn2_0;\n            value+= attn2_0 * attn2_0\n                    * extrapolate3(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        dx2_0,\n                        dy2_0,\n                        dz2_0,\n                    );\n        }\n        let mut dx1_0 = dx0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n        let mut dy1_0 = dy3_0;\n        let mut dz1_0 = dz2_0;\n        let mut attn1_0 = 2 as libc::c_int as libc::c_double - dx1_0 * dx1_0\n            - dy1_0 * dy1_0 - dz1_0 * dz1_0;\n        if attn1_0 > 0 as libc::c_int as libc::c_double {\n            attn1_0*= attn1_0;\n            value+= attn1_0 * attn1_0\n                    * extrapolate3(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        dx1_0,\n                        dy1_0,\n                        dz1_0,\n                    );\n        }\n        dx0= dx0 - 1 as libc::c_int as libc::c_double\n            - 3 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n        dy0= dy0 - 1 as libc::c_int as libc::c_double\n            - 3 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n        dz0= dz0 - 1 as libc::c_int as libc::c_double\n            - 3 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n        let mut attn0_0 = 2 as libc::c_int as libc::c_double - dx0 * dx0 - dy0 * dy0\n            - dz0 * dz0;\n        if attn0_0 > 0 as libc::c_int as libc::c_double {\n            attn0_0*= attn0_0;\n            value+= attn0_0 * attn0_0\n                    * extrapolate3(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        dx0,\n                        dy0,\n                        dz0,\n                    );\n        }\n    } else {\n        let mut aScore_1: libc::c_double = 0.;\n        let mut aPoint_1: int8_t = 0;\n        let mut aIsFurtherSide: libc::c_int = 0;\n        let mut bScore_1: libc::c_double = 0.;\n        let mut bPoint_1: int8_t = 0;\n        let mut bIsFurtherSide: libc::c_int = 0;\n        let mut p1 = xins + yins;\n        if p1 > 1 as libc::c_int as libc::c_double {\n            aScore_1= p1 - 1 as libc::c_int as libc::c_double;\n            aPoint_1= 0x3 as libc::c_int as int8_t;\n            aIsFurtherSide= 1 as libc::c_int;\n        } else {\n            aScore_1= 1 as libc::c_int as libc::c_double - p1;\n            aPoint_1= 0x4 as libc::c_int as int8_t;\n            aIsFurtherSide= 0 as libc::c_int;\n        }\n        let mut p2 = xins + zins;\n        if p2 > 1 as libc::c_int as libc::c_double {\n            bScore_1= p2 - 1 as libc::c_int as libc::c_double;\n            bPoint_1= 0x5 as libc::c_int as int8_t;\n            bIsFurtherSide= 1 as libc::c_int;\n        } else {\n            bScore_1= 1 as libc::c_int as libc::c_double - p2;\n            bPoint_1= 0x2 as libc::c_int as int8_t;\n            bIsFurtherSide= 0 as libc::c_int;\n        }\n        let mut p3 = yins + zins;\n        if p3 > 1 as libc::c_int as libc::c_double {\n            let mut score = p3 - 1 as libc::c_int as libc::c_double;\n            if aScore_1 <= bScore_1 && aScore_1 < score {\n                aScore_1= score;\n                aPoint_1= 0x6 as libc::c_int as int8_t;\n                aIsFurtherSide= 1 as libc::c_int;\n            } else if aScore_1 > bScore_1 && bScore_1 < score {\n                bScore_1= score;\n                bPoint_1= 0x6 as libc::c_int as int8_t;\n                bIsFurtherSide= 1 as libc::c_int;\n            }\n        } else {\n            let mut score_0 = 1 as libc::c_int as libc::c_double - p3;\n            if aScore_1 <= bScore_1 && aScore_1 < score_0 {\n                aScore_1= score_0;\n                aPoint_1= 0x1 as libc::c_int as int8_t;\n                aIsFurtherSide= 0 as libc::c_int;\n            } else if aScore_1 > bScore_1 && bScore_1 < score_0 {\n                bScore_1= score_0;\n                bPoint_1= 0x1 as libc::c_int as int8_t;\n                bIsFurtherSide= 0 as libc::c_int;\n            }\n        }\n        if aIsFurtherSide == bIsFurtherSide {\n            if aIsFurtherSide != 0 {\n                dx_ext0= dx0 - 1 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                dy_ext0= dy0 - 1 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                dz_ext0= dz0 - 1 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                xsv_ext0= xsb + 1 as libc::c_int;\n                ysv_ext0= ysb + 1 as libc::c_int;\n                zsv_ext0= zsb + 1 as libc::c_int;\n                let mut c_3 = (aPoint_1 as libc::c_int & bPoint_1 as libc::c_int)\n                    as int8_t;\n                if c_3 as libc::c_int & 0x1 as libc::c_int != 0 as libc::c_int {\n                    dx_ext1= dx0 - 2 as libc::c_int as libc::c_double\n                        - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                    dy_ext1= dy0\n                        - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                    dz_ext1= dz0\n                        - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                    xsv_ext1= xsb + 2 as libc::c_int;\n                    ysv_ext1= ysb;\n                    zsv_ext1= zsb;\n                } else if c_3 as libc::c_int & 0x2 as libc::c_int != 0 as libc::c_int {\n                    dx_ext1= dx0\n                        - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                    dy_ext1= dy0 - 2 as libc::c_int as libc::c_double\n                        - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                    dz_ext1= dz0\n                        - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                    xsv_ext1= xsb;\n                    ysv_ext1= ysb + 2 as libc::c_int;\n                    zsv_ext1= zsb;\n                } else {\n                    dx_ext1= dx0\n                        - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                    dy_ext1= dy0\n                        - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                    dz_ext1= dz0 - 2 as libc::c_int as libc::c_double\n                        - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n                    xsv_ext1= xsb;\n                    ysv_ext1= ysb;\n                    zsv_ext1= zsb + 2 as libc::c_int;\n                }\n            } else {\n                dx_ext0= dx0;\n                dy_ext0= dy0;\n                dz_ext0= dz0;\n                xsv_ext0= xsb;\n                ysv_ext0= ysb;\n                zsv_ext0= zsb;\n                let mut c_4 = (aPoint_1 as libc::c_int | bPoint_1 as libc::c_int)\n                    as int8_t;\n                if c_4 as libc::c_int & 0x1 as libc::c_int == 0 as libc::c_int {\n                    dx_ext1= dx0 + 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                    dy_ext1= dy0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                    dz_ext1= dz0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                    xsv_ext1= xsb - 1 as libc::c_int;\n                    ysv_ext1= ysb + 1 as libc::c_int;\n                    zsv_ext1= zsb + 1 as libc::c_int;\n                } else if c_4 as libc::c_int & 0x2 as libc::c_int == 0 as libc::c_int {\n                    dx_ext1= dx0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                    dy_ext1= dy0 + 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                    dz_ext1= dz0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                    xsv_ext1= xsb + 1 as libc::c_int;\n                    ysv_ext1= ysb - 1 as libc::c_int;\n                    zsv_ext1= zsb + 1 as libc::c_int;\n                } else {\n                    dx_ext1= dx0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                    dy_ext1= dy0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                    dz_ext1= dz0 + 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                    xsv_ext1= xsb + 1 as libc::c_int;\n                    ysv_ext1= ysb + 1 as libc::c_int;\n                    zsv_ext1= zsb - 1 as libc::c_int;\n                }\n            }\n        } else {\n            let mut c1: int8_t = 0;\n            let mut c2: int8_t = 0;\n            if aIsFurtherSide != 0 {\n                c1= aPoint_1;\n                c2= bPoint_1;\n            } else {\n                c1= bPoint_1;\n                c2= aPoint_1;\n            }\n            if c1 as libc::c_int & 0x1 as libc::c_int == 0 as libc::c_int {\n                dx_ext0= dx0 + 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                dy_ext0= dy0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                dz_ext0= dz0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                xsv_ext0= xsb - 1 as libc::c_int;\n                ysv_ext0= ysb + 1 as libc::c_int;\n                zsv_ext0= zsb + 1 as libc::c_int;\n            } else if c1 as libc::c_int & 0x2 as libc::c_int == 0 as libc::c_int {\n                dx_ext0= dx0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                dy_ext0= dy0 + 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                dz_ext0= dz0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                xsv_ext0= xsb + 1 as libc::c_int;\n                ysv_ext0= ysb - 1 as libc::c_int;\n                zsv_ext0= zsb + 1 as libc::c_int;\n            } else {\n                dx_ext0= dx0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                dy_ext0= dy0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                dz_ext0= dz0 + 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n                xsv_ext0= xsb + 1 as libc::c_int;\n                ysv_ext0= ysb + 1 as libc::c_int;\n                zsv_ext0= zsb - 1 as libc::c_int;\n            }\n            dx_ext1= dx0 - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n            dy_ext1= dy0 - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n            dz_ext1= dz0 - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n            xsv_ext1= xsb;\n            ysv_ext1= ysb;\n            zsv_ext1= zsb;\n            if c2 as libc::c_int & 0x1 as libc::c_int != 0 as libc::c_int {\n                dx_ext1-= 2 as libc::c_int as libc::c_double;\n                xsv_ext1+= 2 as libc::c_int;\n            } else if c2 as libc::c_int & 0x2 as libc::c_int != 0 as libc::c_int {\n                dy_ext1-= 2 as libc::c_int as libc::c_double;\n                ysv_ext1+= 2 as libc::c_int;\n            } else {\n                dz_ext1-= 2 as libc::c_int as libc::c_double;\n                zsv_ext1+= 2 as libc::c_int;\n            }\n        }\n        let mut dx1_1 = dx0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n        let mut dy1_1 = dy0 - 0 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n        let mut dz1_1 = dz0 - 0 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n        let mut attn1_1 = 2 as libc::c_int as libc::c_double - dx1_1 * dx1_1\n            - dy1_1 * dy1_1 - dz1_1 * dz1_1;\n        if attn1_1 > 0 as libc::c_int as libc::c_double {\n            attn1_1*= attn1_1;\n            value+= attn1_1 * attn1_1\n                    * extrapolate3(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        dx1_1,\n                        dy1_1,\n                        dz1_1,\n                    );\n        }\n        let mut dx2_1 = dx0 - 0 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n        let mut dy2_1 = dy0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n        let mut dz2_1 = dz1_1;\n        let mut attn2_1 = 2 as libc::c_int as libc::c_double - dx2_1 * dx2_1\n            - dy2_1 * dy2_1 - dz2_1 * dz2_1;\n        if attn2_1 > 0 as libc::c_int as libc::c_double {\n            attn2_1*= attn2_1;\n            value+= attn2_1 * attn2_1\n                    * extrapolate3(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        dx2_1,\n                        dy2_1,\n                        dz2_1,\n                    );\n        }\n        let mut dx3_1 = dx2_1;\n        let mut dy3_1 = dy1_1;\n        let mut dz3_1 = dz0 - 1 as libc::c_int as libc::c_double - 1.0f64 / 3.0f64;\n        let mut attn3_1 = 2 as libc::c_int as libc::c_double - dx3_1 * dx3_1\n            - dy3_1 * dy3_1 - dz3_1 * dz3_1;\n        if attn3_1 > 0 as libc::c_int as libc::c_double {\n            attn3_1*= attn3_1;\n            value+= attn3_1 * attn3_1\n                    * extrapolate3(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        dx3_1,\n                        dy3_1,\n                        dz3_1,\n                    );\n        }\n        let mut dx4 = dx0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n        let mut dy4 = dy0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n        let mut dz4 = dz0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n        let mut attn4 = 2 as libc::c_int as libc::c_double - dx4 * dx4 - dy4 * dy4\n            - dz4 * dz4;\n        if attn4 > 0 as libc::c_int as libc::c_double {\n            attn4*= attn4;\n            value+= attn4 * attn4\n                    * extrapolate3(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        dx4,\n                        dy4,\n                        dz4,\n                    );\n        }\n        let mut dx5 = dx4;\n        let mut dy5 = dy0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n        let mut dz5 = dz0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n        let mut attn5 = 2 as libc::c_int as libc::c_double - dx5 * dx5 - dy5 * dy5\n            - dz5 * dz5;\n        if attn5 > 0 as libc::c_int as libc::c_double {\n            attn5*= attn5;\n            value+= attn5 * attn5\n                    * extrapolate3(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        dx5,\n                        dy5,\n                        dz5,\n                    );\n        }\n        let mut dx6 = dx0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * (1.0f64 / 3.0f64);\n        let mut dy6 = dy4;\n        let mut dz6 = dz5;\n        let mut attn6 = 2 as libc::c_int as libc::c_double - dx6 * dx6 - dy6 * dy6\n            - dz6 * dz6;\n        if attn6 > 0 as libc::c_int as libc::c_double {\n            attn6*= attn6;\n            value+= attn6 * attn6\n                    * extrapolate3(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        dx6,\n                        dy6,\n                        dz6,\n                    );\n        }\n    }\n    let mut attn_ext0 = 2 as libc::c_int as libc::c_double - dx_ext0 * dx_ext0\n        - dy_ext0 * dy_ext0 - dz_ext0 * dz_ext0;\n    if attn_ext0 > 0 as libc::c_int as libc::c_double {\n        attn_ext0*= attn_ext0;\n        value+= attn_ext0 * attn_ext0\n                * extrapolate3(\n                    ctx,\n                    xsv_ext0,\n                    ysv_ext0,\n                    zsv_ext0,\n                    dx_ext0,\n                    dy_ext0,\n                    dz_ext0,\n                );\n    }\n    let mut attn_ext1 = 2 as libc::c_int as libc::c_double - dx_ext1 * dx_ext1\n        - dy_ext1 * dy_ext1 - dz_ext1 * dz_ext1;\n    if attn_ext1 > 0 as libc::c_int as libc::c_double {\n        attn_ext1*= attn_ext1;\n        value+= attn_ext1 * attn_ext1\n                * extrapolate3(\n                    ctx,\n                    xsv_ext1,\n                    ysv_ext1,\n                    zsv_ext1,\n                    dx_ext1,\n                    dy_ext1,\n                    dz_ext1,\n                );\n    }\n    return value / 103.0f64;\n}","src::kazmath::plane::kmPlaneDot":"pub unsafe extern \"C\" fn kmPlaneDot(\n    mut pP: *const crate::src::kazmath::mat4::kmPlane,\n    mut pV: *const kmVec4,\n) -> libc::c_float {\n    return (*pP).a * (*pV).x + (*pP).b * (*pV).y + (*pP).c * (*pV).z + (*pP).d * (*pV).w;\n}","src::src::noise::extrapolate4":"unsafe extern \"C\" fn extrapolate4(\n    mut ctx: *mut osn_context,\n    mut xsb: libc::c_int,\n    mut ysb: libc::c_int,\n    mut zsb: libc::c_int,\n    mut wsb: libc::c_int,\n    mut dx: libc::c_double,\n    mut dy: libc::c_double,\n    mut dz: libc::c_double,\n    mut dw: libc::c_double,\n) -> libc::c_double {\n    let mut perm = (*ctx).perm;\n    let mut index = *perm\n        .offset(\n            (*perm\n                .offset(\n                    (*perm\n                        .offset(\n                            (*perm.offset((xsb & 0xff as libc::c_int) as isize)\n                                as libc::c_int + ysb & 0xff as libc::c_int) as isize,\n                        ) as libc::c_int + zsb & 0xff as libc::c_int) as isize,\n                ) as libc::c_int + wsb & 0xff as libc::c_int) as isize,\n        ) as libc::c_int & 0xfc as libc::c_int;\n    return crate::src::src::noise::gradients4D[index as usize] as libc::c_int as libc::c_double * dx\n        + crate::src::src::noise::gradients4D[(index + 1 as libc::c_int) as usize] as libc::c_int\n            as libc::c_double * dy\n        + crate::src::src::noise::gradients4D[(index + 2 as libc::c_int) as usize] as libc::c_int\n            as libc::c_double * dz\n        + crate::src::src::noise::gradients4D[(index + 3 as libc::c_int) as usize] as libc::c_int\n            as libc::c_double * dw;\n}","src::src::ops::heman_ops_sobel":"pub unsafe extern \"C\" fn heman_ops_sobel(\n    mut img: *mut heman_image,\n    mut rgb: heman_color,\n) -> *mut /* owning */ heman_image {\n    let mut width = (*img).width;\n    let mut height = (*img).height;\n    if (*img).nbands == 3 as libc::c_int {} else {\n        __assert_fail(\n            b\"img->nbands == 3\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            187 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_sobel(heman_image *, heman_color)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut result = crate::src::src::image::heman_image_create(width, height, 3 as libc::c_int);\n    let mut gray = crate::src::src::color::heman_color_to_grayscale(img);\n    let mut inv = 1.0f32 / 255.0f32;\n    let mut edge_rgb = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    edge_rgb.x= (rgb >> 16 as libc::c_int) as libc::c_float * inv;\n    edge_rgb.y= (rgb >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint)\n        as libc::c_float * inv;\n    edge_rgb.z= (rgb & 0xff as libc::c_int as libc::c_uint) as libc::c_float * inv;\n    let mut y: libc::c_int = 0;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut dst = ((*result).data as *mut crate::src::kazmath::aabb3::kmVec3).offset((y * width) as isize);\n        let mut src: *const crate::src::kazmath::aabb3::kmVec3 = ((*img).data as *mut crate::src::kazmath::aabb3::kmVec3)\n            .offset((y * width) as isize);\n        let mut x = 0 as libc::c_int;\n        while x < width {\n            let mut xm1 = if x - 1 as libc::c_int > 0 as libc::c_int {\n                x - 1 as libc::c_int\n            } else {\n                0 as libc::c_int\n            };\n            let mut xp1 = if x + 1 as libc::c_int > width - 1 as libc::c_int {\n                width - 1 as libc::c_int\n            } else {\n                x + 1 as libc::c_int\n            };\n            let mut ym1 = if y - 1 as libc::c_int > 0 as libc::c_int {\n                y - 1 as libc::c_int\n            } else {\n                0 as libc::c_int\n            };\n            let mut yp1 = if y + 1 as libc::c_int > height - 1 as libc::c_int {\n                height - 1 as libc::c_int\n            } else {\n                y + 1 as libc::c_int\n            };\n            let mut t00 = *crate::src::src::image::heman_image_texel(gray.as_mut(), xm1, ym1);\n            let mut t10 = *crate::src::src::image::heman_image_texel(gray.as_mut(), x, ym1);\n            let mut t20 = *crate::src::src::image::heman_image_texel(gray.as_mut(), xp1, ym1);\n            let mut t01 = *crate::src::src::image::heman_image_texel(gray.as_mut(), xm1, 0 as libc::c_int);\n            let mut t21 = *crate::src::src::image::heman_image_texel(gray.as_mut(), xp1, 0 as libc::c_int);\n            let mut t02 = *crate::src::src::image::heman_image_texel(gray.as_mut(), xm1, yp1);\n            let mut t12 = *crate::src::src::image::heman_image_texel(gray.as_mut(), x, yp1);\n            let mut t22 = *crate::src::src::image::heman_image_texel(gray.as_mut(), xp1, yp1);\n            let mut gx = (t00 as libc::c_double + 2.0f64 * t01 as libc::c_double\n                + t02 as libc::c_double - t20 as libc::c_double\n                - 2.0f64 * t21 as libc::c_double - t22 as libc::c_double)\n                as libc::c_float;\n            let mut gy = (t00 as libc::c_double + 2.0f64 * t10 as libc::c_double\n                + t20 as libc::c_double - t02 as libc::c_double\n                - 2.0f64 * t12 as libc::c_double - t22 as libc::c_double)\n                as libc::c_float;\n            let mut is_edge = ((gx * gx + gy * gy) as libc::c_double > 1e-5f64)\n                as libc::c_int as libc::c_float;\n            let fresh12 = dst;\n            dst= dst.offset(1);\n            let fresh13 = src;\n            src= src.offset(1);\n            crate::src::kazmath::vec3::kmVec3Lerp(fresh12, fresh13, core::ptr::addr_of!(edge_rgb), is_edge);\n            x+= 1;\n        }\n        y+= 1;\n    }\n    crate::src::src::image::heman_image_destroy(gray);\n    return result;\n}","src::kazmath::vec3::kmVec3Assign":"pub unsafe extern \"C\" fn kmVec3Assign(\n    mut pOut: *mut crate::src::kazmath::aabb3::kmVec3,\n    mut pIn: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    if pOut == pIn as *mut crate::src::kazmath::aabb3::kmVec3 {\n        return pOut;\n    }\n    (*pOut).x= (*pIn).x;\n    (*pOut).y= (*pIn).y;\n    (*pOut).z= (*pIn).z;\n    return pOut;\n}","src::kazmath::plane::kmPlaneDotCoord":"pub unsafe extern \"C\" fn kmPlaneDotCoord(\n    mut pP: *const crate::src::kazmath::mat4::kmPlane,\n    mut pV: *const crate::src::kazmath::aabb3::kmVec3,\n) -> libc::c_float {\n    return (*pP).a * (*pV).x + (*pP).b * (*pV).y + (*pP).c * (*pV).z + (*pP).d;\n}","src::src::distance::heman_distance_identity_cpcf":"pub unsafe extern \"C\" fn heman_distance_identity_cpcf(\n    mut width: libc::c_int,\n    mut height: libc::c_int,\n) -> *mut /* owning */ heman_image {\n    let mut retval = crate::src::src::image::heman_image_create(width, height, 2 as libc::c_int);\n    let mut cdata = (*retval).data;\n    let mut y = 0 as libc::c_int;\n    while y < height {\n        let mut x = 0 as libc::c_int;\n        while x < width {\n            let fresh3 = cdata;\n            cdata= cdata.offset(1);\n            *fresh3= x as libc::c_float;\n            let fresh4 = cdata;\n            cdata= cdata.offset(1);\n            *fresh4= y as libc::c_float;\n            x+= 1;\n        }\n        y+= 1;\n    }\n    return retval;\n}","src::kazmath::mat4::kmMat4RotationAxisAngle":"pub unsafe extern \"C\" fn kmMat4RotationAxisAngle(\n    mut pOut: Option<&mut crate::src::kazmath::mat3::kmMat4>,\n    mut axis: *const crate::src::kazmath::aabb3::kmVec3,\n    mut radians: libc::c_float,\n) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    let mut quat = crate::src::kazmath::mat3::kmQuaternion {\n        x: 0.,\n        y: 0.,\n        z: 0.,\n        w: 0.,\n    };\n    crate::src::kazmath::quaternion::kmQuaternionRotationAxisAngle(core::ptr::addr_of_mut!(quat), axis, radians);\n    kmMat4RotationQuaternion(pOut.as_deref_mut(), core::ptr::addr_of!(quat));\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::vec3::kmVec3MultiplyMat4":"pub unsafe extern \"C\" fn kmVec3MultiplyMat4(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pV: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pM: *const crate::src::kazmath::mat3::kmMat4,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    let mut v = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    v.x= (*pV).x * (*pM).mat[0 as libc::c_int as usize]\n        + (*pV).y * (*pM).mat[4 as libc::c_int as usize]\n        + (*pV).z * (*pM).mat[8 as libc::c_int as usize]\n        + (*pM).mat[12 as libc::c_int as usize];\n    v.y= (*pV).x * (*pM).mat[1 as libc::c_int as usize]\n        + (*pV).y * (*pM).mat[5 as libc::c_int as usize]\n        + (*pV).z * (*pM).mat[9 as libc::c_int as usize]\n        + (*pM).mat[13 as libc::c_int as usize];\n    v.z= (*pV).x * (*pM).mat[2 as libc::c_int as usize]\n        + (*pV).y * (*pM).mat[6 as libc::c_int as usize]\n        + (*pV).z * (*pM).mat[10 as libc::c_int as usize]\n        + (*pM).mat[14 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).x= v.x;\n    (*pOut.as_deref_mut().unwrap()).y= v.y;\n    (*pOut.as_deref_mut().unwrap()).z= v.z;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::lighting::heman_lighting_apply":"pub unsafe extern \"C\" fn heman_lighting_apply(\n    mut heightmap: *mut heman_image,\n    mut albedo: *mut heman_image,\n    mut occlusion: libc::c_float,\n    mut diffuse: libc::c_float,\n    mut diffuse_softening: libc::c_float,\n    mut light_position: *const libc::c_float,\n) -> *mut heman_image {\n    if (*heightmap).nbands == 1 as libc::c_int {} else {\n        __assert_fail(\n            b\"heightmap->nbands == 1\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/lighting.c\\0\" as *const u8 as *const libc::c_char,\n            61 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_lighting_apply(heman_image *, heman_image *, float, float, float, const float *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut width = (*heightmap).width;\n    let mut height = (*heightmap).height;\n    let mut final_0 = crate::src::src::image::heman_image_create(width, height, 3 as libc::c_int);\n    let mut normals = heman_lighting_compute_normals(heightmap);\n    let mut occ = heman_lighting_compute_occlusion(heightmap);\n    if !albedo.is_null() {\n        if (*albedo).nbands == 3 as libc::c_int {} else {\n            __assert_fail(\n                b\"albedo->nbands == 3\\0\" as *const u8 as *const libc::c_char,\n                b\"../src/lighting.c\\0\" as *const u8 as *const libc::c_char,\n                69 as libc::c_int as libc::c_uint,\n                b\"heman_image *heman_lighting_apply(heman_image *, heman_image *, float, float, float, const float *)\\0\" as *const u8 as *const libc::c_char,\n            );\n        }\n        if (*albedo).width == width {} else {\n            __assert_fail(\n                b\"albedo->width == width\\0\" as *const u8 as *const libc::c_char,\n                b\"../src/lighting.c\\0\" as *const u8 as *const libc::c_char,\n                70 as libc::c_int as libc::c_uint,\n                b\"heman_image *heman_lighting_apply(heman_image *, heman_image *, float, float, float, const float *)\\0\" as *const u8 as *const libc::c_char,\n            );\n        }\n        if (*albedo).height == height {} else {\n            __assert_fail(\n                b\"albedo->height == height\\0\" as *const u8 as *const libc::c_char,\n                b\"../src/lighting.c\\0\" as *const u8 as *const libc::c_char,\n                71 as libc::c_int as libc::c_uint,\n                b\"heman_image *heman_lighting_apply(heman_image *, heman_image *, float, float, float, const float *)\\0\" as *const u8 as *const libc::c_char,\n            );\n        }\n    }else { (); }\n    static mut default_pos: [libc::c_float; 3] = [-0.5f32, 0.5f32, 1.0f32];\n    if light_position.is_null() {();\n        light_position= default_pos.as_mut_ptr();\n    }\n    let mut colors = (*final_0).data as *mut crate::src::kazmath::aabb3::kmVec3;\n    let mut invgamma = 1.0f32 / crate::src::src::lighting::_gamma;\n    let mut L = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    L.x= *light_position.offset(0 as libc::c_int as isize);\n    L.y= *light_position.offset(1 as libc::c_int as isize);\n    L.z= *light_position.offset(2 as libc::c_int as isize);\n    crate::src::kazmath::vec3::kmVec3Normalize(core::ptr::addr_of_mut!(L), core::ptr::addr_of!(L));\n    let mut y: libc::c_int = 0;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut color = colors.offset((y * width) as isize);\n        let mut x = 0 as libc::c_int;\n        while x < width {\n            let mut N = crate::src::src::image::heman_image_texel(normals.as_mut(), x, y) as *mut crate::src::kazmath::aabb3::kmVec3;\n            crate::src::kazmath::vec3::kmVec3Lerp(N, N, &KM_VEC3_POS_Z, diffuse_softening);\n            let mut df = 1 as libc::c_int as libc::c_float\n                - diffuse\n                    * (1 as libc::c_int as libc::c_float\n                        - crate::src::kazmath::utility::kmClamp(\n                            crate::src::kazmath::vec3::kmVec3Dot(N, core::ptr::addr_of!(L)),\n                            0 as libc::c_int as libc::c_float,\n                            1 as libc::c_int as libc::c_float,\n                        ));\n            let mut of = 1 as libc::c_int as libc::c_float\n                - occlusion\n                    * (1 as libc::c_int as libc::c_float\n                        - *crate::src::src::image::heman_image_texel(occ.as_mut(), x, y));\n            if !albedo.is_null() {\n                *color= *(crate::src::src::image::heman_image_texel(albedo.as_mut(), x, y) as *mut crate::src::kazmath::aabb3::kmVec3);\n            } else {();\n                (*color).z= 1 as libc::c_int as libc::c_float; (*color).y= (*color).z; (*color).x= (*color).y;\n            }\n            (*color).x= pow((*color).x as libc::c_double, crate::src::src::lighting::_gamma as libc::c_double)\n                as libc::c_float;\n            (*color).y= pow((*color).y as libc::c_double, crate::src::src::lighting::_gamma as libc::c_double)\n                as libc::c_float;\n            (*color).z= pow((*color).z as libc::c_double, crate::src::src::lighting::_gamma as libc::c_double)\n                as libc::c_float;\n            crate::src::kazmath::vec3::kmVec3Scale(color, color, df * of);\n            (*color).x= pow((*color).x as libc::c_double, invgamma as libc::c_double)\n                as libc::c_float;\n            (*color).y= pow((*color).y as libc::c_double, invgamma as libc::c_double)\n                as libc::c_float;\n            (*color).z= pow((*color).z as libc::c_double, invgamma as libc::c_double)\n                as libc::c_float;\n            x+= 1;\n            color= color.offset(1);\n        }\n        y+= 1;\n    }\n    crate::src::src::image::heman_image_destroy(normals);\n    crate::src::src::image::heman_image_destroy(occ);\n    return final_0;\n}","src::src::generate::heman_internal_generate_island_noise":"pub unsafe extern \"C\" fn heman_internal_generate_island_noise(\n    mut width: libc::c_int,\n    mut height: libc::c_int,\n    mut seed: libc::c_int,\n) -> *mut /* owning */ heman_image {\n    let mut ctx = 0 as *mut crate::src::src::noise::osn_context;\n    crate::src::src::noise::open_simplex_noise(seed as int64_t, Some(&mut ctx));\n    let mut img = crate::src::src::image::heman_image_create(width, height, 3 as libc::c_int);\n    let mut data = (*img).data;\n    let mut invh = 1.0f32\n        / (if width > height { width } else { height }) as libc::c_float;\n    let mut invw = 1.0f32\n        / (if width > height { width } else { height }) as libc::c_float;\n    let mut freqs: [libc::c_float; 5] = [\n        4.0f64 as libc::c_float,\n        16.0f64 as libc::c_float,\n        32.0f64 as libc::c_float,\n        64.0f64 as libc::c_float,\n        128.0f64 as libc::c_float,\n    ];\n    let mut ampls: [libc::c_float; 5] = [\n        0.2f64 as libc::c_float,\n        0.1f64 as libc::c_float,\n        0.05f64 as libc::c_float,\n        0.025f64 as libc::c_float,\n        0.0125f64 as libc::c_float,\n    ];\n    let mut y: libc::c_int = 0;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut v = y as libc::c_float * invh;\n        let mut dst = data.offset((y * width * 3 as libc::c_int) as isize);\n        let mut x = 0 as libc::c_int;\n        while x < width {\n            let mut u = x as libc::c_float * invw;\n            let fresh0 = dst;\n            dst= dst.offset(1);\n            *fresh0= (ampls[0 as libc::c_int as usize] as libc::c_double\n                * crate::src::src::noise::open_simplex_noise2(\n                    ctx,\n                    (u * freqs[0 as libc::c_int as usize]) as libc::c_double,\n                    (v * freqs[0 as libc::c_int as usize]) as libc::c_double,\n                )\n                + ampls[1 as libc::c_int as usize] as libc::c_double\n                    * crate::src::src::noise::open_simplex_noise2(\n                        ctx,\n                        (u * freqs[1 as libc::c_int as usize]) as libc::c_double,\n                        (v * freqs[1 as libc::c_int as usize]) as libc::c_double,\n                    )\n                + ampls[2 as libc::c_int as usize] as libc::c_double\n                    * crate::src::src::noise::open_simplex_noise2(\n                        ctx,\n                        (u * freqs[2 as libc::c_int as usize]) as libc::c_double,\n                        (v * freqs[2 as libc::c_int as usize]) as libc::c_double,\n                    )) as libc::c_float;\n            let fresh1 = dst;\n            dst= dst.offset(1);\n            *fresh1= (ampls[3 as libc::c_int as usize] as libc::c_double\n                * crate::src::src::noise::open_simplex_noise2(\n                    ctx,\n                    (u * freqs[3 as libc::c_int as usize]) as libc::c_double,\n                    (v * freqs[3 as libc::c_int as usize]) as libc::c_double,\n                )\n                + ampls[4 as libc::c_int as usize] as libc::c_double\n                    * crate::src::src::noise::open_simplex_noise2(\n                        ctx,\n                        (u * freqs[4 as libc::c_int as usize]) as libc::c_double,\n                        (v * freqs[4 as libc::c_int as usize]) as libc::c_double,\n                    )) as libc::c_float;\n            u= (u as libc::c_double + 0.5f64) as libc::c_float;\n            let fresh2 = dst;\n            dst= dst.offset(1);\n            *fresh2= (ampls[3 as libc::c_int as usize] as libc::c_double\n                * crate::src::src::noise::open_simplex_noise2(\n                    ctx,\n                    (u * freqs[3 as libc::c_int as usize]) as libc::c_double,\n                    (v * freqs[3 as libc::c_int as usize]) as libc::c_double,\n                )\n                + ampls[4 as libc::c_int as usize] as libc::c_double\n                    * crate::src::src::noise::open_simplex_noise2(\n                        ctx,\n                        (u * freqs[4 as libc::c_int as usize]) as libc::c_double,\n                        (v * freqs[4 as libc::c_int as usize]) as libc::c_double,\n                    )) as libc::c_float;\n            x+= 1;\n        }\n        y+= 1;\n    }\n    crate::src::src::noise::open_simplex_noise_free(ctx);\n    return img;\n}","src::kazmath::utility::kmDegreesToRadians":"pub unsafe extern \"C\" fn kmDegreesToRadians(\n    mut degrees: libc::c_float,\n) -> libc::c_float {\n    return degrees * (3.14159265358979323846f32 / 180.0f32);\n}","src::kazmath::vec2::kmVec2Reflect":"pub unsafe extern \"C\" fn kmVec2Reflect(\n    mut pOut: *mut crate::src::kazmath::aabb2::kmVec2,\n    mut pIn: *const crate::src::kazmath::aabb2::kmVec2,\n    mut normal: *const crate::src::kazmath::aabb2::kmVec2,\n) -> *mut crate::src::kazmath::aabb2::kmVec2 {\n    let mut tmp = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    {let crown_promoted_local_0 = 2.0f32 * kmVec2Dot(pIn, normal);kmVec2Scale(core::ptr::addr_of_mut!(tmp), normal, crown_promoted_local_0)};\n    kmVec2Subtract(pOut, pIn, core::ptr::addr_of!(tmp));\n    return pOut;\n}","src::kazmath::vec2::kmVec2MidPointBetween":"pub unsafe extern \"C\" fn kmVec2MidPointBetween(\n    mut pOut: Option<&mut crate::src::kazmath::aabb2::kmVec2>,\n    mut v1: *const crate::src::kazmath::aabb2::kmVec2,\n    mut v2: *const crate::src::kazmath::aabb2::kmVec2,\n) -> *mut crate::src::kazmath::aabb2::kmVec2 {\n    let mut sum = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    kmVec2Add(core::ptr::addr_of_mut!(sum), v1, v2);\n    (*pOut.as_deref_mut().unwrap()).x= sum.x / 2.0f32;\n    (*pOut.as_deref_mut().unwrap()).y= sum.y / 2.0f32;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::aabb3::kmAABB3IntersectsTriangle":"pub unsafe extern \"C\" fn kmAABB3IntersectsTriangle(\n    mut box_0: *mut kmAABB3,\n    mut p1: *const kmVec3,\n    mut p2: *const kmVec3,\n    mut p3: *const kmVec3,\n) -> libc::c_uchar {\n    if 0 as libc::c_int != 0\n        && !(b\"Not implemented\\0\" as *const u8 as *const libc::c_char).is_null()\n    {} else {\n        __assert_fail(\n            b\"0 && \\\"Not implemented\\\"\\0\" as *const u8 as *const libc::c_char,\n            b\"../kazmath/aabb3.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            b\"unsigned char kmAABB3IntersectsTriangle(kmAABB3 *, const kmVec3 *, const kmVec3 *, const kmVec3 *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    return 1 as libc::c_int as libc::c_uchar;\n}","src::kazmath::aabb3::kmAABB3ContainsPoint":"pub unsafe extern \"C\" fn kmAABB3ContainsPoint(\n    mut pBox: *const kmAABB3,\n    mut pPoint: *const kmVec3,\n) -> libc::c_int {\n    if (*pPoint).x >= (*pBox).min.x && (*pPoint).x <= (*pBox).max.x\n        && (*pPoint).y >= (*pBox).min.y && (*pPoint).y <= (*pBox).max.y\n        && (*pPoint).z >= (*pBox).min.z && (*pPoint).z <= (*pBox).max.z\n    {\n        return 1 as libc::c_int;\n    }\n    return 0 as libc::c_int;\n}","src::kazmath::mat3::kmMat3IsIdentity":"pub unsafe extern \"C\" fn kmMat3IsIdentity(mut pIn: *const kmMat3) -> libc::c_int {\n    static mut identity: [libc::c_float; 9] = [\n        1.0f32,\n        0.0f32,\n        0.0f32,\n        0.0f32,\n        1.0f32,\n        0.0f32,\n        0.0f32,\n        0.0f32,\n        1.0f32,\n    ];\n    return (memcmp(\n        identity.as_mut_ptr() as *const libc::c_void,\n        ((*pIn).mat).as_ptr() as *const libc::c_void,\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(9 as libc::c_int as libc::c_ulong),\n    ) == 0 as libc::c_int) as libc::c_int;\n}","src::kazmath::mat3::kmMat3AssignMat4":"pub unsafe extern \"C\" fn kmMat3AssignMat4(\n    mut pOut: Option<&mut kmMat3>,\n    mut pIn: *const kmMat4,\n) -> *mut kmMat3 {\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int as usize]= (*pIn).mat[0 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[1 as libc::c_int as usize]= (*pIn).mat[1 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[2 as libc::c_int as usize]= (*pIn).mat[2 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[3 as libc::c_int as usize]= (*pIn).mat[4 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[4 as libc::c_int as usize]= (*pIn).mat[5 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[5 as libc::c_int as usize]= (*pIn).mat[6 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[6 as libc::c_int as usize]= (*pIn).mat[8 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[7 as libc::c_int as usize]= (*pIn).mat[9 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[8 as libc::c_int as usize]= (*pIn).mat[10 as libc::c_int as usize];\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::generate::heman_generate_simplex_fbm":"pub unsafe extern \"C\" fn heman_generate_simplex_fbm(\n    mut width: libc::c_int,\n    mut height: libc::c_int,\n    mut frequency: libc::c_float,\n    mut amplitude: libc::c_float,\n    mut octaves: libc::c_int,\n    mut lacunarity: libc::c_float,\n    mut gain: libc::c_float,\n    mut seed: libc::c_int,\n) -> *mut /* owning */ heman_image {\n    let mut ctx = 0 as *mut crate::src::src::noise::osn_context;\n    crate::src::src::noise::open_simplex_noise(seed as int64_t, Some(&mut ctx));\n    let mut img = crate::src::src::image::heman_image_create(width, height, 1 as libc::c_int);\n    let mut data = (*img).data;\n    let mut invh = 1.0f32 / height as libc::c_float;\n    let mut invw = 1.0f32 / width as libc::c_float;\n    let mut ampl = amplitude;\n    let mut freq = frequency;\n    memset(\n        data as *mut libc::c_void,\n        0 as libc::c_int,\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(width as libc::c_ulong)\n            .wrapping_mul(height as libc::c_ulong),\n    );\n    loop {\n        let fresh8 = octaves;\n        octaves= octaves - 1;\n        if !(fresh8 != 0) {\n            break;\n        }\n        let mut y: libc::c_int = 0;\n        y= 0 as libc::c_int;\n        while y < height {\n            let mut v = y as libc::c_float * invh;\n            let mut dst = data.offset((y * width) as isize);\n            let mut x = 0 as libc::c_int;\n            while x < width {\n                let mut u = x as libc::c_float * invw;\n                let fresh9 = dst;\n                dst= dst.offset(1);\n                *fresh9= ((*fresh9) as libc::c_double\n                    + ampl as libc::c_double\n                        * crate::src::src::noise::open_simplex_noise2(\n                            ctx,\n                            (u * freq) as libc::c_double,\n                            (v * freq) as libc::c_double,\n                        )) as libc::c_float;\n                x+= 1;\n            }\n            y+= 1;\n        }\n        ampl*= gain;\n        freq*= lacunarity;\n    }\n    crate::src::src::noise::open_simplex_noise_free(ctx);\n    return img;\n}","src::src::generate::heman_internal_generate_rock_noise":"pub unsafe extern \"C\" fn heman_internal_generate_rock_noise(\n    mut width: libc::c_int,\n    mut height: libc::c_int,\n    mut seed: libc::c_int,\n) -> *mut /* owning */ heman_image {\n    let mut ctx = 0 as *mut crate::src::src::noise::osn_context;\n    crate::src::src::noise::open_simplex_noise(seed as int64_t, Some(&mut ctx));\n    let mut img = crate::src::src::image::heman_image_create(width, height, 1 as libc::c_int);\n    let mut data = (*img).data;\n    let mut invh = 1.0f32\n        / (if width > height { width } else { height }) as libc::c_float;\n    let mut invw = 1.0f32\n        / (if width > height { width } else { height }) as libc::c_float;\n    let mut freqs: [libc::c_float; 3] = [\n        2.0f64 as libc::c_float,\n        4.0f64 as libc::c_float,\n        16.0f64 as libc::c_float,\n    ];\n    let mut ampls: [libc::c_float; 3] = [\n        0.2f64 as libc::c_float,\n        0.05f64 as libc::c_float,\n        0.01f64 as libc::c_float,\n    ];\n    let mut y: libc::c_int = 0;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut v = y as libc::c_float * invh;\n        let mut dst = data.offset((y * width) as isize);\n        let mut x = 0 as libc::c_int;\n        while x < width {\n            let mut u = x as libc::c_float * invw;\n            let fresh3 = dst;\n            dst= dst.offset(1);\n            *fresh3= (ampls[0 as libc::c_int as usize] as libc::c_double\n                * crate::src::src::noise::open_simplex_noise2(\n                    ctx,\n                    (u * freqs[0 as libc::c_int as usize]) as libc::c_double,\n                    (v * freqs[0 as libc::c_int as usize]) as libc::c_double,\n                )\n                + ampls[1 as libc::c_int as usize] as libc::c_double\n                    * crate::src::src::noise::open_simplex_noise2(\n                        ctx,\n                        (u * freqs[1 as libc::c_int as usize]) as libc::c_double,\n                        (v * freqs[1 as libc::c_int as usize]) as libc::c_double,\n                    )\n                + ampls[2 as libc::c_int as usize] as libc::c_double\n                    * crate::src::src::noise::open_simplex_noise2(\n                        ctx,\n                        (u * freqs[2 as libc::c_int as usize]) as libc::c_double,\n                        (v * freqs[2 as libc::c_int as usize]) as libc::c_double,\n                    )) as libc::c_float;\n            x+= 1;\n        }\n        y+= 1;\n    }\n    crate::src::src::noise::open_simplex_noise_free(ctx);\n    return img;\n}","src::kazmath::quaternion::kmQuaternionRotationMatrix":"pub unsafe extern \"C\" fn kmQuaternionRotationMatrix(\n    mut pOut: Option<&mut crate::src::kazmath::mat3::kmQuaternion>,\n    mut pIn: *const crate::src::kazmath::mat3::kmMat3,\n) -> *mut crate::src::kazmath::mat3::kmQuaternion {\n    let mut x: libc::c_float = 0.;\n    let mut y: libc::c_float = 0.;\n    let mut z: libc::c_float = 0.;\n    let mut w: libc::c_float = 0.;\n    let mut pMatrix = 0 as *mut libc::c_float;\n    let mut m4x4: [libc::c_float; 16] = [\n        0 as libc::c_int as libc::c_float,\n        0.,\n        0.,\n        0.,\n        0.,\n        0.,\n        0.,\n        0.,\n        0.,\n        0.,\n        0.,\n        0.,\n        0.,\n        0.,\n        0.,\n        0.,\n    ];\n    let mut scale = 0.0f32;\n    let mut diagonal = 0.0f32;\n    if pIn.is_null() {();\n        return 0 as *mut crate::src::kazmath::mat3::kmQuaternion;\n    }\n    m4x4[0 as libc::c_int as usize]= (*pIn).mat[0 as libc::c_int as usize];\n    m4x4[1 as libc::c_int as usize]= (*pIn).mat[3 as libc::c_int as usize];\n    m4x4[2 as libc::c_int as usize]= (*pIn).mat[6 as libc::c_int as usize];\n    m4x4[4 as libc::c_int as usize]= (*pIn).mat[1 as libc::c_int as usize];\n    m4x4[5 as libc::c_int as usize]= (*pIn).mat[4 as libc::c_int as usize];\n    m4x4[6 as libc::c_int as usize]= (*pIn).mat[7 as libc::c_int as usize];\n    m4x4[8 as libc::c_int as usize]= (*pIn).mat[2 as libc::c_int as usize];\n    m4x4[9 as libc::c_int as usize]= (*pIn).mat[5 as libc::c_int as usize];\n    m4x4[10 as libc::c_int as usize]= (*pIn).mat[8 as libc::c_int as usize];\n    m4x4[15 as libc::c_int as usize]= 1 as libc::c_int as libc::c_float;\n    pMatrix= core::ptr::addr_of_mut!(*m4x4.as_mut_ptr().offset(0 as libc::c_int as isize))\n        as *mut libc::c_float;\n    diagonal= *pMatrix.offset(0 as libc::c_int as isize)\n        + *pMatrix.offset(5 as libc::c_int as isize)\n        + *pMatrix.offset(10 as libc::c_int as isize)\n        + 1 as libc::c_int as libc::c_float;\n    if diagonal as libc::c_double > 0.0001f64 {\n        scale= sqrt(diagonal as libc::c_double) as libc::c_float\n            * 2 as libc::c_int as libc::c_float;\n        x= (*pMatrix.offset(9 as libc::c_int as isize)\n            - *pMatrix.offset(6 as libc::c_int as isize)) / scale;\n        y= (*pMatrix.offset(2 as libc::c_int as isize)\n            - *pMatrix.offset(8 as libc::c_int as isize)) / scale;\n        z= (*pMatrix.offset(4 as libc::c_int as isize)\n            - *pMatrix.offset(1 as libc::c_int as isize)) / scale;\n        w= 0.25f32 * scale;\n    } else if *pMatrix.offset(0 as libc::c_int as isize)\n        > *pMatrix.offset(5 as libc::c_int as isize)\n        && *pMatrix.offset(0 as libc::c_int as isize)\n            > *pMatrix.offset(10 as libc::c_int as isize)\n    {\n        scale= sqrt(\n            (1.0f32 + *pMatrix.offset(0 as libc::c_int as isize)\n                - *pMatrix.offset(5 as libc::c_int as isize)\n                - *pMatrix.offset(10 as libc::c_int as isize)) as libc::c_double,\n        ) as libc::c_float * 2.0f32;\n        x= 0.25f32 * scale;\n        y= (*pMatrix.offset(4 as libc::c_int as isize)\n            + *pMatrix.offset(1 as libc::c_int as isize)) / scale;\n        z= (*pMatrix.offset(2 as libc::c_int as isize)\n            + *pMatrix.offset(8 as libc::c_int as isize)) / scale;\n        w= (*pMatrix.offset(9 as libc::c_int as isize)\n            - *pMatrix.offset(6 as libc::c_int as isize)) / scale;\n    } else if *pMatrix.offset(5 as libc::c_int as isize)\n        > *pMatrix.offset(10 as libc::c_int as isize)\n    {\n        scale= sqrt(\n            (1.0f32 + *pMatrix.offset(5 as libc::c_int as isize)\n                - *pMatrix.offset(0 as libc::c_int as isize)\n                - *pMatrix.offset(10 as libc::c_int as isize)) as libc::c_double,\n        ) as libc::c_float * 2.0f32;\n        x= (*pMatrix.offset(4 as libc::c_int as isize)\n            + *pMatrix.offset(1 as libc::c_int as isize)) / scale;\n        y= 0.25f32 * scale;\n        z= (*pMatrix.offset(9 as libc::c_int as isize)\n            + *pMatrix.offset(6 as libc::c_int as isize)) / scale;\n        w= (*pMatrix.offset(2 as libc::c_int as isize)\n            - *pMatrix.offset(8 as libc::c_int as isize)) / scale;\n    } else {\n        scale= sqrt(\n            (1.0f32 + *pMatrix.offset(10 as libc::c_int as isize)\n                - *pMatrix.offset(0 as libc::c_int as isize)\n                - *pMatrix.offset(5 as libc::c_int as isize)) as libc::c_double,\n        ) as libc::c_float * 2.0f32;\n        x= (*pMatrix.offset(2 as libc::c_int as isize)\n            + *pMatrix.offset(8 as libc::c_int as isize)) / scale;\n        y= (*pMatrix.offset(9 as libc::c_int as isize)\n            + *pMatrix.offset(6 as libc::c_int as isize)) / scale;\n        z= 0.25f32 * scale;\n        w= (*pMatrix.offset(4 as libc::c_int as isize)\n            - *pMatrix.offset(1 as libc::c_int as isize)) / scale;\n    }\n    (*pOut.as_deref_mut().unwrap()).x= x;\n    (*pOut.as_deref_mut().unwrap()).y= y;\n    (*pOut.as_deref_mut().unwrap()).z= z;\n    (*pOut.as_deref_mut().unwrap()).w= w;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::ray2::kmRay2IntersectLineSegment":"pub unsafe extern \"C\" fn kmRay2IntersectLineSegment(\n    mut ray: *const kmRay2,\n    mut p1: *const crate::src::kazmath::aabb2::kmVec2,\n    mut p2: *const crate::src::kazmath::aabb2::kmVec2,\n    mut intersection: *mut crate::src::kazmath::aabb2::kmVec2,\n) -> libc::c_uchar {\n    let mut ua: libc::c_float = 0.;\n    let mut ub: libc::c_float = 0.;\n    let mut pt = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    let mut otherSegment = kmRay2 {\n        start: crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. },\n        dir: crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. },\n    };\n    kmRay2FillWithEndpoints(Some(&mut otherSegment), p1, p2);\n    if kmLine2WithLineIntersection(\n        &(*ray).start,\n        &(*ray).dir,\n        core::ptr::addr_of!(otherSegment.start),\n        core::ptr::addr_of!(otherSegment.dir),\n        Some(&mut ua),\n        Some(&mut ub),\n        Some(&mut pt),\n    ) as libc::c_int != 0 && 0.0f64 <= ua as libc::c_double\n        && 0.0f64 <= ub as libc::c_double && ub as libc::c_double <= 1.0f64\n    {\n        (*intersection).x= pt.x;\n        (*intersection).y= pt.y;\n        return 1 as libc::c_int as libc::c_uchar;\n    }\n    return 0 as libc::c_int as libc::c_uchar;\n}","src::kazmath::vec2::kmVec2Mul":"pub unsafe extern \"C\" fn kmVec2Mul(\n    mut pOut: Option<&mut crate::src::kazmath::aabb2::kmVec2>,\n    mut pV1: *const crate::src::kazmath::aabb2::kmVec2,\n    mut pV2: *const crate::src::kazmath::aabb2::kmVec2,\n) -> *mut crate::src::kazmath::aabb2::kmVec2 {\n    (*pOut.as_deref_mut().unwrap()).x= (*pV1).x * (*pV2).x;\n    (*pOut.as_deref_mut().unwrap()).y= (*pV1).y * (*pV2).y;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::generate::sphere":"unsafe extern \"C\" fn sphere(\n    mut u: libc::c_float,\n    mut v: libc::c_float,\n    mut r: libc::c_float,\n    mut dst: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n) {\n    (*dst.as_deref_mut().unwrap()).x= (r as libc::c_double * sin(v as libc::c_double) * cos(u as libc::c_double))\n        as libc::c_float;\n    (*dst.as_deref_mut().unwrap()).y= (r as libc::c_double * cos(v as libc::c_double)) as libc::c_float;\n    (*dst.as_deref_mut().unwrap()).z= (r as libc::c_double * -sin(v as libc::c_double) * sin(u as libc::c_double))\n        as libc::c_float;\n}","src::kazmath::mat4::kmMat4RotationQuaternion":"pub unsafe extern \"C\" fn kmMat4RotationQuaternion(\n    mut pOut: Option<&mut crate::src::kazmath::mat3::kmMat4>,\n    mut pQ: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    let mut xx = ((*pQ).x * (*pQ).x) as libc::c_double;\n    let mut xy = ((*pQ).x * (*pQ).y) as libc::c_double;\n    let mut xz = ((*pQ).x * (*pQ).z) as libc::c_double;\n    let mut xw = ((*pQ).x * (*pQ).w) as libc::c_double;\n    let mut yy = ((*pQ).y * (*pQ).y) as libc::c_double;\n    let mut yz = ((*pQ).y * (*pQ).z) as libc::c_double;\n    let mut yw = ((*pQ).y * (*pQ).w) as libc::c_double;\n    let mut zz = ((*pQ).z * (*pQ).z) as libc::c_double;\n    let mut zw = ((*pQ).z * (*pQ).w) as libc::c_double;\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int\n        as usize]= (1 as libc::c_int as libc::c_double\n        - 2 as libc::c_int as libc::c_double * (yy + zz)) as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).mat[1 as libc::c_int\n        as usize]= (2 as libc::c_int as libc::c_double * (xy + zw)) as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).mat[2 as libc::c_int\n        as usize]= (2 as libc::c_int as libc::c_double * (xz - yw)) as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).mat[3 as libc::c_int as usize]= 0 as libc::c_int as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).mat[4 as libc::c_int\n        as usize]= (2 as libc::c_int as libc::c_double * (xy - zw)) as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).mat[5 as libc::c_int\n        as usize]= (1 as libc::c_int as libc::c_double\n        - 2 as libc::c_int as libc::c_double * (xx + zz)) as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).mat[6 as libc::c_int\n        as usize]= (2 as libc::c_int as libc::c_double * (yz + xw)) as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).mat[7 as libc::c_int as usize]= 0.0f64 as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).mat[8 as libc::c_int\n        as usize]= (2 as libc::c_int as libc::c_double * (xz + yw)) as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).mat[9 as libc::c_int\n        as usize]= (2 as libc::c_int as libc::c_double * (yz - xw)) as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).mat[10 as libc::c_int\n        as usize]= (1 as libc::c_int as libc::c_double\n        - 2 as libc::c_int as libc::c_double * (xx + yy)) as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).mat[11 as libc::c_int as usize]= 0.0f64 as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).mat[12 as libc::c_int as usize]= 0.0f64 as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).mat[13 as libc::c_int as usize]= 0.0f64 as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).mat[14 as libc::c_int as usize]= 0.0f64 as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).mat[15 as libc::c_int as usize]= 1.0f64 as libc::c_float;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::export::heman_export_with_colors_ply":"pub unsafe extern \"C\" fn heman_export_with_colors_ply(\n    mut hmap: Option<&mut heman_image>,\n    mut colors: *mut heman_image,\n    mut filename: *const libc::c_char,\n) {\n    let mut width = (*hmap.as_deref().unwrap()).width;\n    let mut height = (*hmap.as_deref().unwrap()).height;\n    if (*hmap.as_deref().unwrap()).nbands == 1 as libc::c_int {} else {\n        __assert_fail(\n            b\"hmap->nbands == 1\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/export.c\\0\" as *const u8 as *const libc::c_char,\n            57 as libc::c_int as libc::c_uint,\n            b\"void heman_export_with_colors_ply(heman_image *, heman_image *, const char *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if (*colors).nbands == 3 as libc::c_int {} else {\n        __assert_fail(\n            b\"colors->nbands == 3\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/export.c\\0\" as *const u8 as *const libc::c_char,\n            58 as libc::c_int as libc::c_uint,\n            b\"void heman_export_with_colors_ply(heman_image *, heman_image *, const char *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if (*colors).width == width {} else {\n        __assert_fail(\n            b\"colors->width == width\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/export.c\\0\" as *const u8 as *const libc::c_char,\n            59 as libc::c_int as libc::c_uint,\n            b\"void heman_export_with_colors_ply(heman_image *, heman_image *, const char *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if (*colors).height == height {} else {\n        __assert_fail(\n            b\"colors->height == height\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/export.c\\0\" as *const u8 as *const libc::c_char,\n            60 as libc::c_int as libc::c_uint,\n            b\"void heman_export_with_colors_ply(heman_image *, heman_image *, const char *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut fout = fopen(filename, b\"wb\\0\" as *const u8 as *const libc::c_char);\n    let mut ncols = (*hmap.as_deref().unwrap()).width - 1 as libc::c_int;\n    let mut nrows = (*hmap.as_deref().unwrap()).height - 1 as libc::c_int;\n    let mut ncells = ncols * nrows;\n    let mut nverts = (*hmap.as_deref().unwrap()).width * (*hmap.as_deref().unwrap()).height;\n    let mut colordata = malloc((width * height * 3 as libc::c_int) as libc::c_ulong)\n        as *mut libc::c_uchar;\n    heman_export_u8(colors, 0.0f64 as libc::c_float, 1.0f64 as libc::c_float, colordata);\n    fprintf(\n        fout,\n        b\"ply\\nformat binary_little_endian 1.0\\ncomment heman\\nelement vertex %d\\nproperty float32 x\\nproperty float32 y\\nproperty float32 z\\nproperty uchar red\\nproperty uchar green\\nproperty uchar blue\\nproperty uchar alpha\\nelement face %d\\nproperty list int32 int32 vertex_indices\\nend_header\\n\\0\"\n            as *const u8 as *const libc::c_char,\n        nverts,\n        ncells,\n    );\n    let mut invw = 2.0f32 / width as libc::c_float;\n    let mut invh = 2.0f32 / height as libc::c_float;\n    let mut pcolor = colordata;\n    let mut vert: [libc::c_float; 3] = [0.; 3];\n    let mut j = 0 as libc::c_int;\n    while j < height {\n        let mut i = 0 as libc::c_int;\n        while i < width {\n            vert[0 as libc::c_int\n                as usize]= -(1 as libc::c_int) as libc::c_float\n                + i as libc::c_float * invw;\n            vert[1 as libc::c_int\n                as usize]= -(1 as libc::c_int) as libc::c_float\n                + j as libc::c_float * invh;\n            vert[2 as libc::c_int as usize]= *crate::src::src::image::heman_image_texel(hmap.as_deref_mut(), i, j);\n            fwrite(\n                vert.as_mut_ptr() as *const libc::c_void,\n                ::std::mem::size_of::<[libc::c_float; 3]>() as libc::c_ulong,\n                1 as libc::c_int as libc::c_ulong,\n                fout,\n            );\n            fwrite(\n                pcolor as *const libc::c_void,\n                3 as libc::c_int as libc::c_ulong,\n                1 as libc::c_int as libc::c_ulong,\n                fout,\n            );\n            pcolor= pcolor.offset(3 as libc::c_int as isize);\n            fputc(255 as libc::c_int, fout);\n            i+= 1;\n        }\n        j+= 1;\n    }\n    let mut face: [libc::c_int; 5] = [0; 5];\n    face[0 as libc::c_int as usize]= 4 as libc::c_int;\n    let mut j_0 = 0 as libc::c_int;\n    while j_0 < nrows {\n        let mut p = j_0 * width;\n        let mut i_0 = 0 as libc::c_int;\n        while i_0 < ncols {\n            face[1 as libc::c_int as usize]= p;\n            face[2 as libc::c_int as usize]= p + 1 as libc::c_int;\n            face[3 as libc::c_int as usize]= p + (*hmap.as_deref().unwrap()).width + 1 as libc::c_int;\n            face[4 as libc::c_int as usize]= p + (*hmap.as_deref().unwrap()).width;\n            fwrite(\n                face.as_mut_ptr() as *const libc::c_void,\n                ::std::mem::size_of::<[libc::c_int; 5]>() as libc::c_ulong,\n                1 as libc::c_int as libc::c_ulong,\n                fout,\n            );\n            i_0+= 1;\n            p+= 1;\n        }\n        j_0+= 1;\n    }\n    fclose(fout);\n    free(colordata as *mut libc::c_void);\n}","src::src::ops::heman_ops_max":"pub unsafe extern \"C\" fn heman_ops_max(\n    mut imga: *mut heman_image,\n    mut imgb: *mut heman_image,\n) -> *mut /* owning */ heman_image {\n    if (*imga).width == (*imgb).width {} else {\n        __assert_fail(\n            b\"imga->width == imgb->width\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            30 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_max(heman_image *, heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if (*imga).height == (*imgb).height {} else {\n        __assert_fail(\n            b\"imga->height == imgb->height\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            31 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_max(heman_image *, heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if (*imga).nbands == (*imgb).nbands {} else {\n        __assert_fail(\n            b\"imga->nbands == imgb->nbands\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            32 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_max(heman_image *, heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut result = crate::src::src::image::heman_image_create((*imga).width, (*imga).height, (*imga).nbands);\n    let mut size = (*imga).height * (*imga).width * (*imga).nbands;\n    let mut srca = (*imga).data;\n    let mut srcb = (*imgb).data;\n    let mut dst = (*result).data;\n    let mut i = 0 as libc::c_int;\n    while i < size {\n        *dst= if (*srca) > (*srcb) { (*srca) } else { (*srcb) };\n        i+= 1;\n        dst= dst.offset(1);\n        srca= srca.offset(1);\n        srcb= srcb.offset(1);\n    }\n    return result;\n}","src::src::points::heman_points_create":"pub unsafe extern \"C\" fn heman_points_create(\n    mut xy: *mut libc::c_float,\n    mut npoints: libc::c_int,\n    mut nbands: libc::c_int,\n) -> *mut /* owning */ heman_image {\n    let mut img = malloc(::std::mem::size_of::<heman_image>() as libc::c_ulong)\n        as *mut heman_points;\n    (*img).width= npoints;\n    (*img).height= 1 as libc::c_int;\n    (*img).nbands= nbands;\n    let mut nbytes = (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n        .wrapping_mul(npoints as libc::c_ulong)\n        .wrapping_mul(nbands as libc::c_ulong) as libc::c_int;\n    (*img).data= malloc(nbytes as libc::c_ulong) as *mut libc::c_float;\n    memcpy(\n        (*img).data as *mut libc::c_void,\n        xy as *const libc::c_void,\n        nbytes as libc::c_ulong,\n    );\n    return img;\n}","src::kazmath::mat4::kmMat4ExtractPlane":"pub unsafe extern \"C\" fn kmMat4ExtractPlane(\n    mut pOut: Option<&mut kmPlane>,\n    mut pIn: *const crate::src::kazmath::mat3::kmMat4,\n    mut plane: libc::c_uint,\n) -> *mut kmPlane {\n    let mut t = 1.0f32;\n    match plane {\n        1 => {\n            (*pOut.as_deref_mut().unwrap()).a= (*pIn).mat[3 as libc::c_int as usize]\n                - (*pIn).mat[0 as libc::c_int as usize];\n            (*pOut.as_deref_mut().unwrap()).b= (*pIn).mat[7 as libc::c_int as usize]\n                - (*pIn).mat[4 as libc::c_int as usize];\n            (*pOut.as_deref_mut().unwrap()).c= (*pIn).mat[11 as libc::c_int as usize]\n                - (*pIn).mat[8 as libc::c_int as usize];\n            (*pOut.as_deref_mut().unwrap()).d= (*pIn).mat[15 as libc::c_int as usize]\n                - (*pIn).mat[12 as libc::c_int as usize];\n        }\n        0 => {\n            (*pOut.as_deref_mut().unwrap()).a= (*pIn).mat[3 as libc::c_int as usize]\n                + (*pIn).mat[0 as libc::c_int as usize];\n            (*pOut.as_deref_mut().unwrap()).b= (*pIn).mat[7 as libc::c_int as usize]\n                + (*pIn).mat[4 as libc::c_int as usize];\n            (*pOut.as_deref_mut().unwrap()).c= (*pIn).mat[11 as libc::c_int as usize]\n                + (*pIn).mat[8 as libc::c_int as usize];\n            (*pOut.as_deref_mut().unwrap()).d= (*pIn).mat[15 as libc::c_int as usize]\n                + (*pIn).mat[12 as libc::c_int as usize];\n        }\n        2 => {\n            (*pOut.as_deref_mut().unwrap()).a= (*pIn).mat[3 as libc::c_int as usize]\n                + (*pIn).mat[1 as libc::c_int as usize];\n            (*pOut.as_deref_mut().unwrap()).b= (*pIn).mat[7 as libc::c_int as usize]\n                + (*pIn).mat[5 as libc::c_int as usize];\n            (*pOut.as_deref_mut().unwrap()).c= (*pIn).mat[11 as libc::c_int as usize]\n                + (*pIn).mat[9 as libc::c_int as usize];\n            (*pOut.as_deref_mut().unwrap()).d= (*pIn).mat[15 as libc::c_int as usize]\n                + (*pIn).mat[13 as libc::c_int as usize];\n        }\n        3 => {\n            (*pOut.as_deref_mut().unwrap()).a= (*pIn).mat[3 as libc::c_int as usize]\n                - (*pIn).mat[1 as libc::c_int as usize];\n            (*pOut.as_deref_mut().unwrap()).b= (*pIn).mat[7 as libc::c_int as usize]\n                - (*pIn).mat[5 as libc::c_int as usize];\n            (*pOut.as_deref_mut().unwrap()).c= (*pIn).mat[11 as libc::c_int as usize]\n                - (*pIn).mat[9 as libc::c_int as usize];\n            (*pOut.as_deref_mut().unwrap()).d= (*pIn).mat[15 as libc::c_int as usize]\n                - (*pIn).mat[13 as libc::c_int as usize];\n        }\n        5 => {\n            (*pOut.as_deref_mut().unwrap()).a= (*pIn).mat[3 as libc::c_int as usize]\n                - (*pIn).mat[2 as libc::c_int as usize];\n            (*pOut.as_deref_mut().unwrap()).b= (*pIn).mat[7 as libc::c_int as usize]\n                - (*pIn).mat[6 as libc::c_int as usize];\n            (*pOut.as_deref_mut().unwrap()).c= (*pIn).mat[11 as libc::c_int as usize]\n                - (*pIn).mat[10 as libc::c_int as usize];\n            (*pOut.as_deref_mut().unwrap()).d= (*pIn).mat[15 as libc::c_int as usize]\n                - (*pIn).mat[14 as libc::c_int as usize];\n        }\n        4 => {\n            (*pOut.as_deref_mut().unwrap()).a= (*pIn).mat[3 as libc::c_int as usize]\n                + (*pIn).mat[2 as libc::c_int as usize];\n            (*pOut.as_deref_mut().unwrap()).b= (*pIn).mat[7 as libc::c_int as usize]\n                + (*pIn).mat[6 as libc::c_int as usize];\n            (*pOut.as_deref_mut().unwrap()).c= (*pIn).mat[11 as libc::c_int as usize]\n                + (*pIn).mat[10 as libc::c_int as usize];\n            (*pOut.as_deref_mut().unwrap()).d= (*pIn).mat[15 as libc::c_int as usize]\n                + (*pIn).mat[14 as libc::c_int as usize];\n        }\n        _ => {\n            if 0 as libc::c_int != 0\n                && !(b\"Invalid plane index\\0\" as *const u8 as *const libc::c_char)\n                    .is_null()\n            {} else {\n                __assert_fail(\n                    b\"0 && \\\"Invalid plane index\\\"\\0\" as *const u8\n                        as *const libc::c_char,\n                    b\"../kazmath/mat4.c\\0\" as *const u8 as *const libc::c_char,\n                    779 as libc::c_int as libc::c_uint,\n                    b\"struct kmPlane *kmMat4ExtractPlane(kmPlane *, const kmMat4 *, const unsigned int)\\0\" as *const u8 as *const libc::c_char,\n                );\n            }\n        }\n    }\n    t= sqrtf((*pOut.as_deref().unwrap()).a * (*pOut.as_deref().unwrap()).a + (*pOut.as_deref().unwrap()).b * (*pOut.as_deref().unwrap()).b + (*pOut.as_deref().unwrap()).c * (*pOut.as_deref().unwrap()).c);\n    (*pOut.as_deref_mut().unwrap()).a/= t;\n    (*pOut.as_deref_mut().unwrap()).b/= t;\n    (*pOut.as_deref_mut().unwrap()).c/= t;\n    (*pOut.as_deref_mut().unwrap()).d/= t;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::mat3::kmMat3RotationAxisAngle":"pub unsafe extern \"C\" fn kmMat3RotationAxisAngle(\n    mut pOut: Option<&mut kmMat3>,\n    mut axis: *const crate::src::kazmath::aabb3::kmVec3,\n    mut radians: libc::c_float,\n) -> *mut kmMat3 {\n    let mut rcos = cosf(radians);\n    let mut rsin = sinf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int\n        as usize]= rcos\n        + (*axis).x * (*axis).x * (1 as libc::c_int as libc::c_float - rcos);\n    (*pOut.as_deref_mut().unwrap()).mat[1 as libc::c_int\n        as usize]= (*axis).z * rsin\n        + (*axis).y * (*axis).x * (1 as libc::c_int as libc::c_float - rcos);\n    (*pOut.as_deref_mut().unwrap()).mat[2 as libc::c_int\n        as usize]= -(*axis).y * rsin\n        + (*axis).z * (*axis).x * (1 as libc::c_int as libc::c_float - rcos);\n    (*pOut.as_deref_mut().unwrap()).mat[3 as libc::c_int\n        as usize]= -(*axis).z * rsin\n        + (*axis).x * (*axis).y * (1 as libc::c_int as libc::c_float - rcos);\n    (*pOut.as_deref_mut().unwrap()).mat[4 as libc::c_int\n        as usize]= rcos\n        + (*axis).y * (*axis).y * (1 as libc::c_int as libc::c_float - rcos);\n    (*pOut.as_deref_mut().unwrap()).mat[5 as libc::c_int\n        as usize]= (*axis).x * rsin\n        + (*axis).z * (*axis).y * (1 as libc::c_int as libc::c_float - rcos);\n    (*pOut.as_deref_mut().unwrap()).mat[6 as libc::c_int\n        as usize]= (*axis).y * rsin\n        + (*axis).x * (*axis).z * (1 as libc::c_int as libc::c_float - rcos);\n    (*pOut.as_deref_mut().unwrap()).mat[7 as libc::c_int\n        as usize]= -(*axis).x * rsin\n        + (*axis).y * (*axis).z * (1 as libc::c_int as libc::c_float - rcos);\n    (*pOut.as_deref_mut().unwrap()).mat[8 as libc::c_int\n        as usize]= rcos\n        + (*axis).z * (*axis).z * (1 as libc::c_int as libc::c_float - rcos);\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::quaternion::kmQuaternionDot":"pub unsafe extern \"C\" fn kmQuaternionDot(\n    mut q1: *const crate::src::kazmath::mat3::kmQuaternion,\n    mut q2: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> libc::c_float {\n    return (*q1).w * (*q2).w + (*q1).x * (*q2).x + (*q1).y * (*q2).y + (*q1).z * (*q2).z;\n}","src::kazmath::mat3::kmMat3RotationZ":"pub unsafe extern \"C\" fn kmMat3RotationZ(\n    mut pOut: Option<&mut kmMat3>,\n    mut radians: libc::c_float,\n) -> *mut kmMat3 {\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int as usize]= cosf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[1 as libc::c_int as usize]= -sinf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[2 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[3 as libc::c_int as usize]= sinf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[4 as libc::c_int as usize]= cosf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[5 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[6 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[7 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[8 as libc::c_int as usize]= 1.0f32;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::mat3::kmMat3Determinant":"pub unsafe extern \"C\" fn kmMat3Determinant(mut pIn: *const kmMat3) -> libc::c_float {\n    let mut output: libc::c_float = 0.;\n    output= (*pIn).mat[0 as libc::c_int as usize]\n        * (*pIn).mat[4 as libc::c_int as usize] * (*pIn).mat[8 as libc::c_int as usize]\n        + (*pIn).mat[1 as libc::c_int as usize] * (*pIn).mat[5 as libc::c_int as usize]\n            * (*pIn).mat[6 as libc::c_int as usize]\n        + (*pIn).mat[2 as libc::c_int as usize] * (*pIn).mat[3 as libc::c_int as usize]\n            * (*pIn).mat[7 as libc::c_int as usize];\n    output-= (*pIn).mat[2 as libc::c_int as usize] * (*pIn).mat[4 as libc::c_int as usize]\n            * (*pIn).mat[6 as libc::c_int as usize]\n            + (*pIn).mat[0 as libc::c_int as usize]\n                * (*pIn).mat[5 as libc::c_int as usize]\n                * (*pIn).mat[7 as libc::c_int as usize]\n            + (*pIn).mat[1 as libc::c_int as usize]\n                * (*pIn).mat[3 as libc::c_int as usize]\n                * (*pIn).mat[8 as libc::c_int as usize];\n    return output;\n}","src::src::color::heman_color_create_gradient":"pub unsafe extern \"C\" fn heman_color_create_gradient(\n    mut width: libc::c_int,\n    mut num_colors: libc::c_int,\n    mut cp_locations: *const libc::c_int,\n    mut cp_values: *const heman_color,\n) -> *mut /* owning */ heman_image {\n    if width > 0 as libc::c_int && num_colors >= 2 as libc::c_int {} else {\n        __assert_fail(\n            b\"width > 0 && num_colors >= 2\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/color.c\\0\" as *const u8 as *const libc::c_char,\n            13 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_color_create_gradient(int, int, const int *, const heman_color *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if *cp_locations.offset(0 as libc::c_int as isize) == 0 as libc::c_int {} else {\n        __assert_fail(\n            b\"cp_locations[0] == 0\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/color.c\\0\" as *const u8 as *const libc::c_char,\n            14 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_color_create_gradient(int, int, const int *, const heman_color *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if *cp_locations.offset((num_colors - 1 as libc::c_int) as isize)\n        == width - 1 as libc::c_int\n    {} else {\n        __assert_fail(\n            b\"cp_locations[num_colors - 1] == width - 1\\0\" as *const u8\n                as *const libc::c_char,\n            b\"../src/color.c\\0\" as *const u8 as *const libc::c_char,\n            15 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_color_create_gradient(int, int, const int *, const heman_color *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut f32colors = malloc(\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(3 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(num_colors as libc::c_ulong),\n    ) as *mut libc::c_float;\n    let mut inv = 1.0f32 / 255.0f32;\n    let mut f32color = f32colors;\n    let mut u32color = cp_values;\n    let mut index = 0 as libc::c_int;\n    while index < num_colors {\n        let fresh0 = u32color;\n        u32color= u32color.offset(1);\n        let mut rgb = (*fresh0);\n        let mut r = (rgb >> 16 as libc::c_int) as libc::c_float * inv;\n        let mut g = (rgb >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint)\n            as libc::c_float * inv;\n        let mut b = (rgb & 0xff as libc::c_int as libc::c_uint) as libc::c_float * inv;\n        let fresh1 = f32color;\n        f32color= f32color.offset(1);\n        *fresh1= pow(r as libc::c_double, crate::src::src::color::_gamma as libc::c_double) as libc::c_float;\n        let fresh2 = f32color;\n        f32color= f32color.offset(1);\n        *fresh2= pow(g as libc::c_double, crate::src::src::color::_gamma as libc::c_double) as libc::c_float;\n        let fresh3 = f32color;\n        f32color= f32color.offset(1);\n        *fresh3= pow(b as libc::c_double, crate::src::src::color::_gamma as libc::c_double) as libc::c_float;\n        index+= 1;\n    }\n    let mut result = crate::src::src::image::heman_image_create(width, 1 as libc::c_int, 3 as libc::c_int);\n    let mut index0 = 0 as libc::c_int;\n    let mut index1 = 1 as libc::c_int;\n    let mut dst = (*result).data;\n    let mut t: libc::c_float = 0.;\n    let mut invgamma = 1.0f32 / crate::src::src::color::_gamma;\n    let mut current_block_16: u64;\n    let mut x = 0 as libc::c_int;\n    while x < width {\n        let mut loc0 = *cp_locations.offset(index0 as isize);\n        let mut loc1 = *cp_locations.offset(index1 as isize);\n        if loc0 == loc1 {\n            t= 0 as libc::c_int as libc::c_float;\n            current_block_16= 11057878835866523405;\n        } else {\n            t= (x - loc0) as libc::c_float / (loc1 - loc0) as libc::c_float;\n            if t >= 1 as libc::c_int as libc::c_float {\n                x-= 1;\n                index0+= 1;\n                index1= if index1 + 1 as libc::c_int > num_colors - 1 as libc::c_int {\n                    num_colors - 1 as libc::c_int\n                } else {\n                    index1 + 1 as libc::c_int\n                };\n                current_block_16= 12039483399334584727;\n            } else {\n                current_block_16= 11057878835866523405;\n            }\n        }\n        match current_block_16 {\n            11057878835866523405 => {\n                let mut r0 = *f32colors.offset((index0 * 3 as libc::c_int) as isize);\n                let mut g0 = *f32colors\n                    .offset((index0 * 3 as libc::c_int + 1 as libc::c_int) as isize);\n                let mut b0 = *f32colors\n                    .offset((index0 * 3 as libc::c_int + 2 as libc::c_int) as isize);\n                let mut r1 = *f32colors.offset((index1 * 3 as libc::c_int) as isize);\n                let mut g1 = *f32colors\n                    .offset((index1 * 3 as libc::c_int + 1 as libc::c_int) as isize);\n                let mut b1 = *f32colors\n                    .offset((index1 * 3 as libc::c_int + 2 as libc::c_int) as isize);\n                let mut invt = 1.0f32 - t;\n                let mut r_0 = r0 * invt + r1 * t;\n                let mut g_0 = g0 * invt + g1 * t;\n                let mut b_0 = b0 * invt + b1 * t;\n                let fresh4 = dst;\n                dst= dst.offset(1);\n                *fresh4= pow(r_0 as libc::c_double, invgamma as libc::c_double)\n                    as libc::c_float;\n                let fresh5 = dst;\n                dst= dst.offset(1);\n                *fresh5= pow(g_0 as libc::c_double, invgamma as libc::c_double)\n                    as libc::c_float;\n                let fresh6 = dst;\n                dst= dst.offset(1);\n                *fresh6= pow(b_0 as libc::c_double, invgamma as libc::c_double)\n                    as libc::c_float;\n            }\n            _ => {}\n        }\n        x+= 1;\n    }\n    free(f32colors as *mut libc::c_void);\n    return result;\n}","src::src::distance::heman_distance_from_cpcf":"pub unsafe extern \"C\" fn heman_distance_from_cpcf(\n    mut cf: *mut heman_image,\n) -> *mut /* owning */ heman_image {\n    if (*cf).nbands == 2 as libc::c_int\n        && !(b\"Coordinate field input must have 2 bands.\\0\" as *const u8\n            as *const libc::c_char)\n            .is_null()\n    {} else {\n        __assert_fail(\n            b\"cf->nbands == 2 && \\\"Coordinate field input must have 2 bands.\\\"\\0\"\n                as *const u8 as *const libc::c_char,\n            b\"../src/distance.c\\0\" as *const u8 as *const libc::c_char,\n            259 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_distance_from_cpcf(heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut udf = crate::src::src::image::heman_image_create((*cf).width, (*cf).height, 1 as libc::c_int);\n    let mut dptr = (*udf).data;\n    let mut sptr = (*cf).data;\n    let mut scale = (1.0f32 as libc::c_double\n        / sqrt(\n            ((*cf).width * (*cf).width + (*cf).height * (*cf).height) as libc::c_double,\n        )) as libc::c_float;\n    let mut y = 0 as libc::c_int;\n    while y < (*cf).height {\n        let mut x = 0 as libc::c_int;\n        while x < (*cf).width {\n            let fresh7 = sptr;\n            sptr= sptr.offset(1);\n            let mut u = (*fresh7);\n            let fresh8 = sptr;\n            sptr= sptr.offset(1);\n            let mut v = (*fresh8);\n            let mut dist = (sqrt(\n                ((u - x as libc::c_float) * (u - x as libc::c_float)\n                    + (v - y as libc::c_float) * (v - y as libc::c_float))\n                    as libc::c_double,\n            ) * scale as libc::c_double) as libc::c_float;\n            let fresh9 = dptr;\n            dptr= dptr.offset(1);\n            *fresh9= dist;\n            x+= 1;\n        }\n        y+= 1;\n    }\n    return udf;\n}","src::kazmath::mat4::kmMat4Transpose":"pub unsafe extern \"C\" fn kmMat4Transpose(\n    mut pOut: Option<&mut crate::src::kazmath::mat3::kmMat4>,\n    mut pIn: *const crate::src::kazmath::mat3::kmMat4,\n) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    let mut x: libc::c_int = 0;\n    let mut z: libc::c_int = 0;\n    z= 0 as libc::c_int;\n    while z < 4 as libc::c_int {\n        x= 0 as libc::c_int;\n        while x < 4 as libc::c_int {\n            (*pOut.as_deref_mut().unwrap()).mat[(z * 4 as libc::c_int + x)\n                as usize]= (*pIn).mat[(x * 4 as libc::c_int + z) as usize];\n            x+= 1;\n        }\n        z+= 1;\n    }\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::mat3::kmMat3RotationX":"pub unsafe extern \"C\" fn kmMat3RotationX(\n    mut pOut: Option<&mut kmMat3>,\n    mut radians: libc::c_float,\n) -> *mut kmMat3 {\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int as usize]= 1.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[1 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[2 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[3 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[4 as libc::c_int as usize]= cosf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[5 as libc::c_int as usize]= sinf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[6 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[7 as libc::c_int as usize]= -sinf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[8 as libc::c_int as usize]= cosf(radians);\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::quaternion::kmQuaternionAssign":"pub unsafe extern \"C\" fn kmQuaternionAssign(\n    mut pOut: *mut crate::src::kazmath::mat3::kmQuaternion,\n    mut pIn: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> *mut crate::src::kazmath::mat3::kmQuaternion {\n    memcpy(\n        pOut as *mut libc::c_void,\n        pIn as *const libc::c_void,\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(4 as libc::c_int as libc::c_ulong),\n    );\n    return pOut;\n}","src::src::noise::open_simplex_noise":"pub unsafe extern \"C\" fn open_simplex_noise(\n    mut seed: int64_t,\n    mut ctx: Option<&mut *mut osn_context>,\n) -> libc::c_int {\n    let mut rc: libc::c_int = 0;\n    let mut source: [int16_t; 256] = [0; 256];\n    let mut i: libc::c_int = 0;\n    let mut perm = 0 as *mut int16_t;\n    let mut permGradIndex3D = 0 as *mut int16_t;\n    *ctx.as_deref_mut().unwrap()= malloc(::std::mem::size_of::<osn_context>() as libc::c_ulong)\n        as *mut osn_context;\n    if (*ctx.as_deref().unwrap()).is_null() {();\n        return -(12 as libc::c_int);\n    }\n    (*(*ctx.as_deref_mut().unwrap())).perm= 0 as *mut int16_t;\n    (*(*ctx.as_deref_mut().unwrap())).permGradIndex3D= 0 as *mut int16_t;\n    rc= allocate_perm((*ctx.as_deref().unwrap()), 256 as libc::c_int, 256 as libc::c_int);\n    if rc != 0 {\n        free((*ctx.as_deref().unwrap()) as *mut libc::c_void);\n        return rc;\n    }\n    perm= (*(*ctx.as_deref().unwrap())).perm;\n    permGradIndex3D= (*(*ctx.as_deref().unwrap())).permGradIndex3D;\n    i= 0 as libc::c_int;\n    while i < 256 as libc::c_int {\n        source[i as usize]= i as int16_t;\n        i+= 1;\n    }\n    seed= (seed as libc::c_longlong * 6364136223846793005 as libc::c_longlong\n        + 1442695040888963407 as libc::c_longlong) as int64_t;\n    seed= (seed as libc::c_longlong * 6364136223846793005 as libc::c_longlong\n        + 1442695040888963407 as libc::c_longlong) as int64_t;\n    seed= (seed as libc::c_longlong * 6364136223846793005 as libc::c_longlong\n        + 1442695040888963407 as libc::c_longlong) as int64_t;\n    i= 255 as libc::c_int;\n    while i >= 0 as libc::c_int {\n        seed= (seed as libc::c_longlong * 6364136223846793005 as libc::c_longlong\n            + 1442695040888963407 as libc::c_longlong) as int64_t;\n        let mut r = ((seed + 31 as libc::c_int as libc::c_long)\n            % (i + 1 as libc::c_int) as libc::c_long) as libc::c_int;\n        if r < 0 as libc::c_int {\n            r+= i + 1 as libc::c_int;\n        }\n        *perm.offset(i as isize) = source[r as usize];\n        *permGradIndex3D\n            .offset(\n                i as isize,\n            ) = (*perm.offset(i as isize) as libc::c_ulong)\n            .wrapping_rem(\n                (::std::mem::size_of::<[libc::c_schar; 72]>() as libc::c_ulong)\n                    .wrapping_div(\n                        ::std::mem::size_of::<libc::c_schar>() as libc::c_ulong,\n                    )\n                    .wrapping_div(3 as libc::c_int as libc::c_ulong),\n            )\n            .wrapping_mul(3 as libc::c_int as libc::c_ulong) as libc::c_short;\n        source[r as usize]= source[i as usize];\n        i-= 1;\n    }\n    return 0 as libc::c_int;\n}","src::kazmath::vec2::kmVec2TransformCoord":"pub unsafe extern \"C\" fn kmVec2TransformCoord(\n    mut pOut: *mut crate::src::kazmath::aabb2::kmVec2,\n    mut pV: *const crate::src::kazmath::aabb2::kmVec2,\n    mut pM: *const crate::src::kazmath::mat3::kmMat3,\n) -> *mut crate::src::kazmath::aabb2::kmVec2 {\n    __assert_fail(\n        b\"0\\0\" as *const u8 as *const libc::c_char,\n        b\"../kazmath/vec2.c\\0\" as *const u8 as *const libc::c_char,\n        134 as libc::c_int as libc::c_uint,\n        b\"kmVec2 *kmVec2TransformCoord(kmVec2 *, const kmVec2 *, const kmMat3 *)\\0\" as *const u8 as *const libc::c_char,\n    );\n    return 0 as *mut crate::src::kazmath::aabb2::kmVec2;\n}","src::kazmath::aabb3::kmAABB3Initialize":"pub unsafe extern \"C\" fn kmAABB3Initialize(\n    mut pBox: Option<&mut kmAABB3>,\n    mut centre: *const kmVec3,\n    mut width: libc::c_float,\n    mut height: libc::c_float,\n    mut depth: libc::c_float,\n) -> *mut kmAABB3 {\n    if pBox.as_deref().is_none() {();\n        return 0 as *mut kmAABB3;\n    }\n    let mut origin = kmVec3 { x: 0., y: 0., z: 0. };\n    let mut point = if !centre.is_null() { centre as *mut kmVec3 } else {(); core::ptr::addr_of_mut!(origin) };\n    crate::src::kazmath::vec3::kmVec3Zero(Some(&mut origin));\n    (*pBox.as_deref_mut().unwrap()).min.x= (*point).x - width / 2 as libc::c_int as libc::c_float;\n    (*pBox.as_deref_mut().unwrap()).min.y= (*point).y - height / 2 as libc::c_int as libc::c_float;\n    (*pBox.as_deref_mut().unwrap()).min.z= (*point).z - depth / 2 as libc::c_int as libc::c_float;\n    (*pBox.as_deref_mut().unwrap()).max.x= (*point).x + width / 2 as libc::c_int as libc::c_float;\n    (*pBox.as_deref_mut().unwrap()).max.y= (*point).y + height / 2 as libc::c_int as libc::c_float;\n    (*pBox.as_deref_mut().unwrap()).max.z= (*point).z + depth / 2 as libc::c_int as libc::c_float;\n    return pBox.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::vec3::kmVec3Scale":"pub unsafe extern \"C\" fn kmVec3Scale(\n    mut pOut: *mut crate::src::kazmath::aabb3::kmVec3,\n    mut pIn: *const crate::src::kazmath::aabb3::kmVec3,\n    mut s: libc::c_float,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    (*pOut).x= (*pIn).x * s;\n    (*pOut).y= (*pIn).y * s;\n    (*pOut).z= (*pIn).z * s;\n    return pOut;\n}","src::src::ops::heman_ops_extract_mask":"pub unsafe extern \"C\" fn heman_ops_extract_mask(\n    mut source: *mut heman_image,\n    mut color: heman_color,\n    mut invert: libc::c_int,\n) -> *mut /* owning */ heman_image {\n    if (*source).nbands == 3 as libc::c_int {} else {\n        __assert_fail(\n            b\"source->nbands == 3\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            330 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_extract_mask(heman_image *, heman_color, int)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut inv = 1.0f32 / 255.0f32;\n    let mut r = (color >> 16 as libc::c_int) as libc::c_float * inv;\n    let mut g = (color >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint)\n        as libc::c_float * inv;\n    let mut b = (color & 0xff as libc::c_int as libc::c_uint) as libc::c_float * inv;\n    let mut height = (*source).height;\n    let mut width = (*source).width;\n    let mut result = crate::src::src::image::heman_image_create(width, height, 1 as libc::c_int);\n    let mut y: libc::c_int = 0;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut dst = (*result).data.offset((y * width) as isize);\n        let mut src = (*source).data.offset((y * width * 3 as libc::c_int) as isize);\n        let mut x = 0 as libc::c_int;\n        while x < width {\n            let mut val = (*src.offset(0 as libc::c_int as isize) == r\n                && *src.offset(1 as libc::c_int as isize) == g\n                && *src.offset(2 as libc::c_int as isize) == b) as libc::c_int\n                as libc::c_float;\n            if invert == 0 {\n                val= 1 as libc::c_int as libc::c_float - val;\n            }\n            let fresh19 = dst;\n            dst= dst.offset(1);\n            *fresh19= val;\n            x+= 1;\n            src= src.offset(3 as libc::c_int as isize);\n        }\n        y+= 1;\n    }\n    return result;\n}","src::kazmath::vec3::kmVec3Zero":"pub unsafe extern \"C\" fn kmVec3Zero(mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    (*pOut.as_deref_mut().unwrap()).x= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).y= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).z= 0.0f32;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::distance::heman_distance_create_df":"pub unsafe extern \"C\" fn heman_distance_create_df(\n    mut src: *mut heman_image,\n) -> *mut /* owning */ heman_image {\n    if (*src).nbands == 1 as libc::c_int\n        && !(b\"Distance field input must have only 1 band.\\0\" as *const u8\n            as *const libc::c_char)\n            .is_null()\n    {} else {\n        __assert_fail(\n            b\"src->nbands == 1 && \\\"Distance field input must have only 1 band.\\\"\\0\"\n                as *const u8 as *const libc::c_char,\n            b\"../src/distance.c\\0\" as *const u8 as *const libc::c_char,\n            208 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_distance_create_df(heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut positive = crate::src::src::image::heman_image_create((*src).width, (*src).height, 1 as libc::c_int);\n    let mut size = (*src).height * (*src).width;\n    let mut pptr = (*positive).data;\n    let mut sptr = (*src).data;\n    let mut i = 0 as libc::c_int;\n    while i < size {\n        let fresh2 = pptr;\n        pptr= pptr.offset(1);\n        *fresh2= if (*sptr) != 0. { 0 as libc::c_int as libc::c_float } else { crate::src::src::distance::INF };\n        i+= 1;\n        sptr= sptr.offset(1);\n    }\n    transform_to_distance(positive.as_mut());\n    let mut inv = 1.0f32 / (*src).width as libc::c_float;\n    pptr= (*positive).data;\n    let mut i_0 = 0 as libc::c_int;\n    while i_0 < size {\n        *pptr= (sqrt((*pptr) as libc::c_double) * inv as libc::c_double) as libc::c_float;\n        i_0+= 1;\n        pptr= pptr.offset(1);\n    }\n    return positive;\n}","src::src::generate::heman_internal_draw_seeds":"pub unsafe extern \"C\" fn heman_internal_draw_seeds(\n    mut target: Option<&mut heman_image>,\n    mut pts: *mut heman_points,\n    mut filterd: libc::c_int,\n) {\n    let mut radius = (*target.as_deref().unwrap()).width / filterd;\n    let mut fwidth = radius * 2 as libc::c_int + 1 as libc::c_int;\n    let mut src = (*pts).data;\n    let mut w = (*target.as_deref().unwrap()).width;\n    let mut h = (*target.as_deref().unwrap()).height;\n    let mut i = 0 as libc::c_int;\n    while i < (*pts).width {\n        let fresh11 = src;\n        src= src.offset(1);\n        let mut x = (*fresh11);\n        let fresh12 = src;\n        src= src.offset(1);\n        let mut y = (*fresh12);\n        let mut strength = crate::src::src::generate::DEFAULT_STRENGTH;\n        if (*pts).nbands == 3 as libc::c_int {\n            let fresh13 = src;\n            src= src.offset(1);\n            strength= (*fresh13);\n        }\n        strength= (crate::src::src::generate::SEALEVEL as libc::c_double + strength as libc::c_double * 0.1f64)\n            as libc::c_float;\n        let mut ix = (x * w as libc::c_float) as libc::c_int;\n        let mut iy = (y * h as libc::c_float) as libc::c_int;\n        let mut ii = ix - radius;\n        let mut jj = iy - radius;\n        let mut kj = 0 as libc::c_int;\n        while kj < fwidth {\n            let mut ki = 0 as libc::c_int;\n            while ki < fwidth {\n                let mut i_0 = ii + ki;\n                let mut j = jj + kj;\n                if !(i_0 < 0 as libc::c_int || i_0 >= w || j < 0 as libc::c_int\n                    || j >= h)\n                {\n                    let mut texel = crate::src::src::image::heman_image_texel(target.as_deref_mut(), i_0, j);\n                    let mut d2 = (i_0 - ix) * (i_0 - ix) + (j - iy) * (j - iy);\n                    let mut dist = (1 as libc::c_int as libc::c_double\n                        - sqrt(d2 as libc::c_double) / radius as libc::c_double)\n                        as libc::c_float;\n                    *texel= if (*texel) > strength * dist {\n                        (*texel)\n                    } else {\n                        strength * dist\n                    };\n                }\n                ki+= 1;\n            }\n            kj+= 1;\n        }\n        i+= 1;\n    }\n}","src::src::color::heman_color_from_grayscale":"pub unsafe extern \"C\" fn heman_color_from_grayscale(\n    mut grayscale: *mut heman_image,\n) -> *mut /* owning */ heman_image {\n    if (*grayscale).nbands == 1 as libc::c_int {} else {\n        __assert_fail(\n            b\"grayscale->nbands == 1\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/color.c\\0\" as *const u8 as *const libc::c_char,\n            93 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_color_from_grayscale(heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut w = (*grayscale).width;\n    let mut h = (*grayscale).height;\n    let mut result = crate::src::src::image::heman_image_create(w, h, 3 as libc::c_int);\n    let mut size = w * h;\n    let mut dst = (*result).data;\n    let mut src: *const libc::c_float = (*grayscale).data as *const f32;\n    let mut i = 0 as libc::c_int;\n    while i < size {\n        let fresh7 = src;\n        src= src.offset(1);\n        let mut v = (*fresh7);\n        let fresh8 = dst;\n        dst= dst.offset(1);\n        *fresh8= v;\n        let fresh9 = dst;\n        dst= dst.offset(1);\n        *fresh9= v;\n        let fresh10 = dst;\n        dst= dst.offset(1);\n        *fresh10= v;\n        i+= 1;\n    }\n    return result;\n}","src::kazmath::vec4::kmVec4Dot":"pub unsafe extern \"C\" fn kmVec4Dot(\n    mut pV1: *const crate::src::kazmath::plane::kmVec4,\n    mut pV2: *const crate::src::kazmath::plane::kmVec4,\n) -> libc::c_float {\n    return (*pV1).x * (*pV2).x + (*pV1).y * (*pV2).y + (*pV1).z * (*pV2).z\n        + (*pV1).w * (*pV2).w;\n}","src::kazmath::vec2::kmVec2DistanceBetween":"pub unsafe extern \"C\" fn kmVec2DistanceBetween(\n    mut v1: *const crate::src::kazmath::aabb2::kmVec2,\n    mut v2: *const crate::src::kazmath::aabb2::kmVec2,\n) -> libc::c_float {\n    let mut diff = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    kmVec2Subtract(core::ptr::addr_of_mut!(diff), v2, v1);\n    return fabs(kmVec2Length(core::ptr::addr_of!(diff)) as libc::c_double) as libc::c_float;\n}","src::src::draw::heman_draw_contour_from_points":"pub unsafe extern \"C\" fn heman_draw_contour_from_points(\n    mut target: *mut heman_image,\n    mut coords: *mut heman_points,\n    mut rgb: heman_color,\n    mut mind: libc::c_float,\n    mut maxd: libc::c_float,\n    mut filterd: libc::c_int,\n) {\n    if (*target).nbands == 3 as libc::c_int || (*target).nbands == 4 as libc::c_int\n    {} else {\n        __assert_fail(\n            b\"target->nbands == 3 || target->nbands == 4\\0\" as *const u8\n                as *const libc::c_char,\n            b\"../src/draw.c\\0\" as *const u8 as *const libc::c_char,\n            119 as libc::c_int as libc::c_uint,\n            b\"void heman_draw_contour_from_points(heman_image *, heman_points *, heman_color, float, float, int)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut width = (*target).width;\n    let mut height = (*target).height;\n    let mut seed = crate::src::src::image::heman_image_create(width, height, 1 as libc::c_int);\n    crate::src::src::image::heman_image_clear(seed.as_mut(), 0 as libc::c_int as libc::c_float);\n    crate::src::src::generate::heman_internal_draw_seeds(seed.as_mut(), coords, filterd);\n    let mut inv = 1.0f32 / 255.0f32;\n    let mut r = (rgb >> 16 as libc::c_int & 0xff as libc::c_int as libc::c_uint)\n        as libc::c_float * inv;\n    let mut g = (rgb >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint)\n        as libc::c_float * inv;\n    let mut b = (rgb & 0xff as libc::c_int as libc::c_uint) as libc::c_float * inv;\n    let mut a = 1 as libc::c_int as libc::c_float;\n    if (*target).nbands == 4 as libc::c_int {\n        a= (rgb >> 24 as libc::c_int) as libc::c_float * inv;\n    }\n    let mut y: libc::c_int = 0;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut dst = (*target).data.offset((y * width * (*target).nbands) as isize);\n        let mut x = 0 as libc::c_int;\n        while x < width {\n            let mut dist = *crate::src::src::image::heman_image_texel(seed.as_mut(), x, y);\n            if dist > mind && dist < maxd {\n                *dst.offset(0 as libc::c_int as isize) = r;\n                *dst.offset(1 as libc::c_int as isize) = g;\n                *dst.offset(2 as libc::c_int as isize) = b;\n                if (*target).nbands == 4 as libc::c_int {\n                    *dst.offset(3 as libc::c_int as isize) = a;\n                }\n            }\n            dst= dst.offset((*target).nbands as isize);\n            x+= 1;\n        }\n        y+= 1;\n    }\n    crate::src::src::points::heman_points_destroy(seed);\n}","src::kazmath::ray3::kmRay3Fill":"pub unsafe extern \"C\" fn kmRay3Fill(\n    mut ray: Option<&mut kmRay3>,\n    mut px: libc::c_float,\n    mut py: libc::c_float,\n    mut pz: libc::c_float,\n    mut vx: libc::c_float,\n    mut vy: libc::c_float,\n    mut vz: libc::c_float,\n) -> *mut kmRay3 {\n    (*ray.as_deref_mut().unwrap()).start.x= px;\n    (*ray.as_deref_mut().unwrap()).start.y= py;\n    (*ray.as_deref_mut().unwrap()).start.z= pz;\n    (*ray.as_deref_mut().unwrap()).dir.x= vx;\n    (*ray.as_deref_mut().unwrap()).dir.y= vy;\n    (*ray.as_deref_mut().unwrap()).dir.z= vz;\n    return ray.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::draw::heman_draw_colored_circles":"pub unsafe extern \"C\" fn heman_draw_colored_circles(\n    mut target: Option<&mut heman_image>,\n    mut pts: *mut heman_points,\n    mut radius: libc::c_int,\n    mut colors: *const heman_color,\n) {\n    let mut fwidth = radius * 2 as libc::c_int + 1 as libc::c_int;\n    let mut radius2 = radius * radius;\n    let mut src = (*pts).data;\n    let mut inv = 1.0f32 / 255.0f32;\n    let mut w = (*target.as_deref().unwrap()).width;\n    let mut h = (*target.as_deref().unwrap()).height;\n    let mut k = 0 as libc::c_int;\n    while k < (*pts).width {\n        let mut x = *src.offset(0 as libc::c_int as isize);\n        let mut y = *src.offset(1 as libc::c_int as isize);\n        src= src.offset((*pts).nbands as isize);\n        let mut ii = (x * w as libc::c_float - radius as libc::c_float) as libc::c_int;\n        let mut jj = (y * h as libc::c_float - radius as libc::c_float) as libc::c_int;\n        let mut kj = 0 as libc::c_int;\n        while kj < fwidth {\n            let mut ki = 0 as libc::c_int;\n            while ki < fwidth {\n                let mut i = ii + ki;\n                let mut j = jj + kj;\n                let mut r2 = ((i as libc::c_float - x * w as libc::c_float)\n                    * (i as libc::c_float - x * w as libc::c_float)\n                    + (j as libc::c_float - y * h as libc::c_float)\n                        * (j as libc::c_float - y * h as libc::c_float)) as libc::c_int;\n                if !(r2 > radius2) {\n                    let mut texel = crate::src::src::image::heman_image_texel(target.as_deref_mut(), i, j);\n                    let mut rgb = *colors.offset(k as isize);\n                    let fresh4 = texel;\n                    texel= texel.offset(1);\n                    *fresh4= (rgb >> 16 as libc::c_int) as libc::c_float * inv;\n                    let fresh5 = texel;\n                    texel= texel.offset(1);\n                    *fresh5= (rgb >> 8 as libc::c_int\n                        & 0xff as libc::c_int as libc::c_uint) as libc::c_float * inv;\n                    *texel= (rgb & 0xff as libc::c_int as libc::c_uint) as libc::c_float\n                        * inv;\n                }\n                ki+= 1;\n            }\n            kj+= 1;\n        }\n        k+= 1;\n    }\n}","src::kazmath::mat4::kmMat4RotationYawPitchRoll":"pub unsafe extern \"C\" fn kmMat4RotationYawPitchRoll(\n    mut pOut: *mut crate::src::kazmath::mat3::kmMat4,\n    mut pitch: libc::c_float,\n    mut yaw: libc::c_float,\n    mut roll: libc::c_float,\n) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    let mut yaw_matrix = crate::src::kazmath::mat3::kmMat4 { mat: [0.; 16] };\n    kmMat4RotationY(Some(&mut yaw_matrix), yaw);\n    let mut pitch_matrix = crate::src::kazmath::mat3::kmMat4 { mat: [0.; 16] };\n    kmMat4RotationX(Some(&mut pitch_matrix), pitch);\n    let mut roll_matrix = crate::src::kazmath::mat3::kmMat4 { mat: [0.; 16] };\n    kmMat4RotationZ(Some(&mut roll_matrix), roll);\n    kmMat4Multiply(pOut, core::ptr::addr_of!(pitch_matrix), core::ptr::addr_of!(roll_matrix));\n    kmMat4Multiply(pOut, core::ptr::addr_of!(yaw_matrix), pOut);\n    return pOut;\n}","src::kazmath::quaternion::kmQuaternionLookRotation":"pub unsafe extern \"C\" fn kmQuaternionLookRotation(\n    mut pOut: *mut crate::src::kazmath::mat3::kmQuaternion,\n    mut direction: *const crate::src::kazmath::aabb3::kmVec3,\n    mut up: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut crate::src::kazmath::mat3::kmQuaternion {\n    let mut tmp = crate::src::kazmath::mat3::kmMat3 { mat: [0.; 9] };\n    crate::src::kazmath::mat3::kmMat3LookAt(Some(&mut tmp), &KM_VEC3_ZERO, direction, up);\n    return kmQuaternionNormalize(pOut, kmQuaternionRotationMatrix(pOut.as_mut(), core::ptr::addr_of!(tmp)));\n}","src::src::ops::heman_ops_warp_points":"pub unsafe extern \"C\" fn heman_ops_warp_points(\n    mut img: *mut heman_image,\n    mut seed: libc::c_int,\n    mut octaves: libc::c_int,\n    mut pts: Option<&mut heman_points>,\n) -> *mut heman_image {\n    let mut width = (*img).width;\n    let mut height = (*img).height;\n    let mut mapping = crate::src::src::distance::heman_distance_identity_cpcf(width, height);\n    let mut retval = heman_ops_warp_core(img, mapping, seed, octaves);\n    let mut src = (*pts.as_deref().unwrap()).data;\n    let mut k = 0 as libc::c_int;\n    while k < (*pts.as_deref().unwrap()).width {\n        let mut x = *src.offset(0 as libc::c_int as isize);\n        let mut y = *src.offset(1 as libc::c_int as isize);\n        let mut i = (x * (*mapping).width as libc::c_float) as libc::c_int;\n        let mut j = (y * (*mapping).height as libc::c_float) as libc::c_int;\n        if !(i < 0 as libc::c_int || i >= (*mapping).width || j < 0 as libc::c_int\n            || j >= (*mapping).height)\n        {\n            let mut texel = crate::src::src::image::heman_image_texel(mapping.as_mut(), i, j);\n            *src\n                .offset(\n                    0 as libc::c_int as isize,\n                ) = *texel.offset(0 as libc::c_int as isize)\n                / (*mapping).width as libc::c_float;\n            *src\n                .offset(\n                    1 as libc::c_int as isize,\n                ) = *texel.offset(1 as libc::c_int as isize)\n                / (*mapping).height as libc::c_float;\n        }\n        k+= 1;\n        src= src.offset((*pts.as_deref().unwrap()).nbands as isize);\n    }\n    crate::src::src::image::heman_image_destroy(mapping);\n    return retval;\n}","src::kazmath::quaternion::kmQuaternionGetForwardVec3RH":"pub unsafe extern \"C\" fn kmQuaternionGetForwardVec3RH(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pIn: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    return kmQuaternionMultiplyVec3(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), pIn, &KM_VEC3_NEG_Z);\n}","src::kazmath::vec4::kmVec4Div":"pub unsafe extern \"C\" fn kmVec4Div(\n    mut pOut: Option<&mut crate::src::kazmath::plane::kmVec4>,\n    mut pV1: *const crate::src::kazmath::plane::kmVec4,\n    mut pV2: *const crate::src::kazmath::plane::kmVec4,\n) -> *mut crate::src::kazmath::plane::kmVec4 {\n    if (*pV2).x != 0. && (*pV2).y != 0. && (*pV2).z != 0. && (*pV2).w != 0. {\n        (*pOut.as_deref_mut().unwrap()).x= (*pV1).x / (*pV2).x;\n        (*pOut.as_deref_mut().unwrap()).y= (*pV1).y / (*pV2).y;\n        (*pOut.as_deref_mut().unwrap()).z= (*pV1).z / (*pV2).z;\n        (*pOut.as_deref_mut().unwrap()).w= (*pV1).w / (*pV2).w;\n    }\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::ops::heman_ops_accumulate":"pub unsafe extern \"C\" fn heman_ops_accumulate(\n    mut dst: Option<&mut heman_image>,\n    mut src: *mut heman_image,\n) {\n    if (*dst.as_deref().unwrap()).nbands == (*src).nbands {} else {\n        __assert_fail(\n            b\"dst->nbands == src->nbands\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            172 as libc::c_int as libc::c_uint,\n            b\"void heman_ops_accumulate(heman_image *, heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if (*dst.as_deref().unwrap()).width == (*src).width {} else {\n        __assert_fail(\n            b\"dst->width == src->width\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            173 as libc::c_int as libc::c_uint,\n            b\"void heman_ops_accumulate(heman_image *, heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if (*dst.as_deref().unwrap()).height == (*src).height {} else {\n        __assert_fail(\n            b\"dst->height == src->height\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            174 as libc::c_int as libc::c_uint,\n            b\"void heman_ops_accumulate(heman_image *, heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut size = (*dst.as_deref().unwrap()).height * (*dst.as_deref().unwrap()).width;\n    let mut sdata = (*src).data;\n    let mut ddata = (*dst.as_deref().unwrap()).data;\n    let mut i = 0 as libc::c_int;\n    while i < size {\n        let fresh10 = sdata;\n        sdata= sdata.offset(1);\n        let fresh11 = ddata;\n        ddata= ddata.offset(1);\n        *fresh11+= (*fresh10);\n        i+= 1;\n    }\n}","src::kazmath::ray3::kmRay3IntersectPlane":"pub unsafe extern \"C\" fn kmRay3IntersectPlane(\n    mut pOut: *mut crate::src::kazmath::aabb3::kmVec3,\n    mut ray: *const kmRay3,\n    mut plane: *const crate::src::kazmath::mat4::kmPlane,\n) -> libc::c_uchar {\n    let mut d = (*plane).a * (*ray).dir.x + (*plane).b * (*ray).dir.y\n        + (*plane).c * (*ray).dir.z;\n    if d == 0 as libc::c_int as libc::c_float {\n        return 0 as libc::c_int as libc::c_uchar;\n    }\n    let mut t = -((*plane).a * (*ray).start.x + (*plane).b * (*ray).start.y\n        + (*plane).c * (*ray).start.z + (*plane).d) / d;\n    if t < 0 as libc::c_int as libc::c_float {\n        return 0 as libc::c_int as libc::c_uchar;\n    }\n    let mut scaled_dir = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    crate::src::kazmath::vec3::kmVec3Scale(core::ptr::addr_of_mut!(scaled_dir), &(*ray).dir, t);\n    crate::src::kazmath::vec3::kmVec3Add(pOut, &(*ray).start, core::ptr::addr_of!(scaled_dir));\n    return 1 as libc::c_int as libc::c_uchar;\n}","src::src::generate::heman_generate_archipelago_political_1":"pub unsafe extern \"C\" fn heman_generate_archipelago_political_1(\n    mut width: libc::c_int,\n    mut height: libc::c_int,\n    mut points: *mut heman_points,\n    mut colors: *const heman_color,\n    mut ocean: heman_color,\n    mut seed: libc::c_int,\n) -> *mut heman_image {\n    let mut contour = crate::src::src::image::heman_image_create(width, height, 3 as libc::c_int);\n    crate::src::src::image::heman_image_clear(contour.as_mut(), 0 as libc::c_int as libc::c_float);\n    crate::src::src::draw::heman_draw_contour_from_points(\n        contour,\n        points,\n        ocean,\n        0.40f64 as libc::c_float,\n        0.41f64 as libc::c_float,\n        1 as libc::c_int,\n    );\n    crate::src::src::draw::heman_draw_colored_points(contour.as_mut(), points, colors);\n    let mut cf = crate::src::src::distance::heman_distance_create_cpcf(contour);\n    let mut warped_cpcf = crate::src::src::ops::heman_ops_warp(cf, seed, 4 as libc::c_int);\n    let mut political = crate::src::src::color::heman_color_from_cpcf(warped_cpcf, contour);\n    crate::src::src::image::heman_image_destroy(warped_cpcf);\n    crate::src::src::image::heman_image_destroy(cf);\n    crate::src::src::image::heman_image_destroy(contour);\n    return political;\n}","src::kazmath::mat3::kmMat3Transpose":"pub unsafe extern \"C\" fn kmMat3Transpose(\n    mut pOut: *mut kmMat3,\n    mut pIn: *const kmMat3,\n) -> *mut kmMat3 {\n    let mut temp: [libc::c_float; 9] = [0.; 9];\n    temp[0 as libc::c_int as usize]= (*pIn).mat[0 as libc::c_int as usize];\n    temp[1 as libc::c_int as usize]= (*pIn).mat[3 as libc::c_int as usize];\n    temp[2 as libc::c_int as usize]= (*pIn).mat[6 as libc::c_int as usize];\n    temp[3 as libc::c_int as usize]= (*pIn).mat[1 as libc::c_int as usize];\n    temp[4 as libc::c_int as usize]= (*pIn).mat[4 as libc::c_int as usize];\n    temp[5 as libc::c_int as usize]= (*pIn).mat[7 as libc::c_int as usize];\n    temp[6 as libc::c_int as usize]= (*pIn).mat[2 as libc::c_int as usize];\n    temp[7 as libc::c_int as usize]= (*pIn).mat[5 as libc::c_int as usize];\n    temp[8 as libc::c_int as usize]= (*pIn).mat[8 as libc::c_int as usize];\n    memcpy(\n        core::ptr::addr_of_mut!((*pOut).mat) as *mut [libc::c_float; 9] as *mut libc::c_void,\n        temp.as_mut_ptr() as *const libc::c_void,\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(9 as libc::c_int as libc::c_ulong),\n    );\n    return pOut;\n}","src::kazmath::mat3::kmMat3Fill":"pub unsafe extern \"C\" fn kmMat3Fill(\n    mut pOut: *mut kmMat3,\n    mut pMat: *const libc::c_float,\n) -> *mut kmMat3 {\n    memcpy(\n        (*pOut).mat.as_mut_ptr() as *mut libc::c_void,\n        pMat as *const libc::c_void,\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(9 as libc::c_int as libc::c_ulong),\n    );\n    return pOut;\n}","src::kazmath::plane::kmPlaneScale":"pub unsafe extern \"C\" fn kmPlaneScale(\n    mut pOut: *mut crate::src::kazmath::mat4::kmPlane,\n    mut pP: *const crate::src::kazmath::mat4::kmPlane,\n    mut s: libc::c_float,\n) -> *mut crate::src::kazmath::mat4::kmPlane {\n    if 0 as libc::c_int != 0\n        && !(b\"Not implemented\\0\" as *const u8 as *const libc::c_char).is_null()\n    {} else {\n        __assert_fail(\n            b\"0 && \\\"Not implemented\\\"\\0\" as *const u8 as *const libc::c_char,\n            b\"../kazmath/plane.c\\0\" as *const u8 as *const libc::c_char,\n            179 as libc::c_int as libc::c_uint,\n            b\"kmPlane *kmPlaneScale(kmPlane *, const kmPlane *, float)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    return 0 as *mut crate::src::kazmath::mat4::kmPlane;\n}","src::src::draw::heman_draw_colored_points":"pub unsafe extern \"C\" fn heman_draw_colored_points(\n    mut target: Option<&mut heman_image>,\n    mut pts: *mut heman_points,\n    mut colors: *const heman_color,\n) {\n    if (*target.as_deref().unwrap()).nbands == 3 as libc::c_int || (*target.as_deref().unwrap()).nbands == 4 as libc::c_int\n    {} else {\n        __assert_fail(\n            b\"target->nbands == 3 || target->nbands == 4\\0\" as *const u8\n                as *const libc::c_char,\n            b\"../src/draw.c\\0\" as *const u8 as *const libc::c_char,\n            27 as libc::c_int as libc::c_uint,\n            b\"void heman_draw_colored_points(heman_image *, heman_points *, const heman_color *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut src = (*pts).data;\n    let mut inv = 1.0f32 / 255.0f32;\n    let mut k = 0 as libc::c_int;\n    while k < (*pts).width {\n        let mut x = *src.offset(0 as libc::c_int as isize);\n        let mut y = *src.offset(1 as libc::c_int as isize);\n        src= src.offset((*pts).nbands as isize);\n        let mut i = (x * (*target.as_deref().unwrap()).width as libc::c_float) as libc::c_int;\n        let mut j = (y * (*target.as_deref().unwrap()).height as libc::c_float) as libc::c_int;\n        if !(i < 0 as libc::c_int || i >= (*target.as_deref().unwrap()).width || j < 0 as libc::c_int\n            || j >= (*target.as_deref().unwrap()).height)\n        {\n            let mut texel = crate::src::src::image::heman_image_texel(target.as_deref_mut(), i, j);\n            let mut rgb = *colors.offset(k as isize);\n            let fresh1 = texel;\n            texel= texel.offset(1);\n            *fresh1= (rgb >> 16 as libc::c_int & 0xff as libc::c_int as libc::c_uint)\n                as libc::c_float * inv;\n            let fresh2 = texel;\n            texel= texel.offset(1);\n            *fresh2= (rgb >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint)\n                as libc::c_float * inv;\n            let fresh3 = texel;\n            texel= texel.offset(1);\n            *fresh3= (rgb & 0xff as libc::c_int as libc::c_uint) as libc::c_float * inv;\n            if (*target.as_deref().unwrap()).nbands == 4 as libc::c_int {\n                *texel= (rgb >> 24 as libc::c_int) as libc::c_float * inv;\n            }\n        }\n        k+= 1;\n    }\n}","src::kazmath::quaternion::kmQuaternionRotationAxisAngle":"pub unsafe extern \"C\" fn kmQuaternionRotationAxisAngle(\n    mut pOut: *mut crate::src::kazmath::mat3::kmQuaternion,\n    mut pV: *const crate::src::kazmath::aabb3::kmVec3,\n    mut angle: libc::c_float,\n) -> *mut crate::src::kazmath::mat3::kmQuaternion {\n    let mut rad = angle * 0.5f32;\n    let mut scale = sinf(rad);\n    (*pOut).x= (*pV).x * scale;\n    (*pOut).y= (*pV).y * scale;\n    (*pOut).z= (*pV).z * scale;\n    (*pOut).w= cosf(rad);\n    kmQuaternionNormalize(pOut, pOut);\n    return pOut;\n}","src::kazmath::aabb3::kmAABB3DiameterY":"pub unsafe extern \"C\" fn kmAABB3DiameterY(mut aabb: *const kmAABB3) -> libc::c_float {\n    return fabs(((*aabb).max.y - (*aabb).min.y) as libc::c_double) as libc::c_float;\n}","src::src::distance::heman_distance_create_sdf":"pub unsafe extern \"C\" fn heman_distance_create_sdf(\n    mut src: *mut heman_image,\n) -> *mut /* owning */ heman_image {\n    if (*src).nbands == 1 as libc::c_int\n        && !(b\"Distance field input must have only 1 band.\\0\" as *const u8\n            as *const libc::c_char)\n            .is_null()\n    {} else {\n        __assert_fail(\n            b\"src->nbands == 1 && \\\"Distance field input must have only 1 band.\\\"\\0\"\n                as *const u8 as *const libc::c_char,\n            b\"../src/distance.c\\0\" as *const u8 as *const libc::c_char,\n            183 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_distance_create_sdf(heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut positive = crate::src::src::image::heman_image_create((*src).width, (*src).height, 1 as libc::c_int);\n    let mut negative = crate::src::src::image::heman_image_create((*src).width, (*src).height, 1 as libc::c_int);\n    let mut size = (*src).height * (*src).width;\n    let mut pptr = (*positive).data;\n    let mut nptr = (*negative).data;\n    let mut sptr = (*src).data;\n    let mut i = 0 as libc::c_int;\n    while i < size {\n        let fresh0 = pptr;\n        pptr= pptr.offset(1);\n        *fresh0= if (*sptr) != 0. { crate::src::src::distance::INF } else { 0 as libc::c_int as libc::c_float };\n        let fresh1 = nptr;\n        nptr= nptr.offset(1);\n        *fresh1= if (*sptr) != 0. { 0 as libc::c_int as libc::c_float } else { crate::src::src::distance::INF };\n        i+= 1;\n        sptr= sptr.offset(1);\n    }\n    transform_to_distance(positive.as_mut());\n    transform_to_distance(negative.as_mut());\n    let mut inv = 1.0f32 / (*src).width as libc::c_float;\n    pptr= (*positive).data;\n    nptr= (*negative).data;\n    let mut i_0 = 0 as libc::c_int;\n    while i_0 < size {\n        *pptr= ((sqrt((*pptr) as libc::c_double) - sqrt((*nptr) as libc::c_double))\n            * inv as libc::c_double) as libc::c_float;\n        i_0+= 1;\n        pptr= pptr.offset(1);\n        nptr= nptr.offset(1);\n    }\n    crate::src::src::image::heman_image_destroy(negative);\n    return positive;\n}","src::kazmath::quaternion::kmQuaternionLn":"pub unsafe extern \"C\" fn kmQuaternionLn(\n    mut pOut: *mut crate::src::kazmath::mat3::kmQuaternion,\n    mut pIn: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> *mut crate::src::kazmath::mat3::kmQuaternion {\n    __assert_fail(\n        b\"0\\0\" as *const u8 as *const libc::c_char,\n        b\"../kazmath/quaternion.c\\0\" as *const u8 as *const libc::c_char,\n        137 as libc::c_int as libc::c_uint,\n        b\"kmQuaternion *kmQuaternionLn(kmQuaternion *, const kmQuaternion *)\\0\" as *const u8 as *const libc::c_char,\n    );\n    return pOut;\n}","src::kazmath::mat4::kmMat4LookAt":"pub unsafe extern \"C\" fn kmMat4LookAt(\n    mut pOut: *mut crate::src::kazmath::mat3::kmMat4,\n    mut pEye: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pCenter: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pUp: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    let mut f = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut up = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut s = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut u = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut translate = crate::src::kazmath::mat3::kmMat4 { mat: [0.; 16] };\n    crate::src::kazmath::vec3::kmVec3Subtract(core::ptr::addr_of_mut!(f), pCenter, pEye);\n    crate::src::kazmath::vec3::kmVec3Normalize(core::ptr::addr_of_mut!(f), core::ptr::addr_of!(f));\n    crate::src::kazmath::vec3::kmVec3Assign(core::ptr::addr_of_mut!(up), pUp);\n    crate::src::kazmath::vec3::kmVec3Normalize(core::ptr::addr_of_mut!(up), core::ptr::addr_of!(up));\n    crate::src::kazmath::vec3::kmVec3Cross(core::ptr::addr_of_mut!(s), core::ptr::addr_of!(f), core::ptr::addr_of!(up));\n    crate::src::kazmath::vec3::kmVec3Normalize(core::ptr::addr_of_mut!(s), core::ptr::addr_of!(s));\n    crate::src::kazmath::vec3::kmVec3Cross(core::ptr::addr_of_mut!(u), core::ptr::addr_of!(s), core::ptr::addr_of!(f));\n    crate::src::kazmath::vec3::kmVec3Normalize(core::ptr::addr_of_mut!(s), core::ptr::addr_of!(s));\n    kmMat4Identity(pOut);\n    (*pOut).mat[0 as libc::c_int as usize]= s.x;\n    (*pOut).mat[4 as libc::c_int as usize]= s.y;\n    (*pOut).mat[8 as libc::c_int as usize]= s.z;\n    (*pOut).mat[1 as libc::c_int as usize]= u.x;\n    (*pOut).mat[5 as libc::c_int as usize]= u.y;\n    (*pOut).mat[9 as libc::c_int as usize]= u.z;\n    (*pOut).mat[2 as libc::c_int as usize]= -f.x;\n    (*pOut).mat[6 as libc::c_int as usize]= -f.y;\n    (*pOut).mat[10 as libc::c_int as usize]= -f.z;\n    kmMat4Translation(core::ptr::addr_of_mut!(translate), -(*pEye).x, -(*pEye).y, -(*pEye).z);\n    kmMat4Multiply(pOut, pOut, core::ptr::addr_of!(translate));\n    return pOut;\n}","src::kazmath::quaternion::kmQuaternionLengthSq":"pub unsafe extern \"C\" fn kmQuaternionLengthSq(\n    mut pIn: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> libc::c_float {\n    return (*pIn).x * (*pIn).x + (*pIn).y * (*pIn).y + (*pIn).z * (*pIn).z\n        + (*pIn).w * (*pIn).w;\n}","src::kazmath::vec3::kmVec3GetHorizontalAngle":"pub unsafe extern \"C\" fn kmVec3GetHorizontalAngle(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pIn: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    let z1 = sqrt(((*pIn).x * (*pIn).x + (*pIn).z * (*pIn).z) as libc::c_double)\n        as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).y= crate::src::kazmath::utility::kmRadiansToDegrees(\n        atan2((*pIn).x as libc::c_double, (*pIn).z as libc::c_double) as libc::c_float,\n    );\n    if (*pOut.as_deref().unwrap()).y < 0 as libc::c_int as libc::c_float {\n        (*pOut.as_deref_mut().unwrap()).y+= 360 as libc::c_int as libc::c_float;\n    }\n    if (*pOut.as_deref().unwrap()).y >= 360 as libc::c_int as libc::c_float {\n        (*pOut.as_deref_mut().unwrap()).y-= 360 as libc::c_int as libc::c_float;\n    }\n    (*pOut.as_deref_mut().unwrap()).x= (crate::src::kazmath::utility::kmRadiansToDegrees(\n        atan2(z1 as libc::c_double, (*pIn).y as libc::c_double) as libc::c_float,\n    ) as libc::c_double - 90.0f64) as libc::c_float;\n    if (*pOut.as_deref().unwrap()).x < 0 as libc::c_int as libc::c_float {\n        (*pOut.as_deref_mut().unwrap()).x+= 360 as libc::c_int as libc::c_float;\n    }\n    if (*pOut.as_deref().unwrap()).x >= 360 as libc::c_int as libc::c_float {\n        (*pOut.as_deref_mut().unwrap()).x-= 360 as libc::c_int as libc::c_float;\n    }\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::vec3::kmVec3TransformNormal":"pub unsafe extern \"C\" fn kmVec3TransformNormal(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pV: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pM: *const crate::src::kazmath::mat3::kmMat4,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    let mut v = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    v.x= (*pV).x * (*pM).mat[0 as libc::c_int as usize]\n        + (*pV).y * (*pM).mat[4 as libc::c_int as usize]\n        + (*pV).z * (*pM).mat[8 as libc::c_int as usize];\n    v.y= (*pV).x * (*pM).mat[1 as libc::c_int as usize]\n        + (*pV).y * (*pM).mat[5 as libc::c_int as usize]\n        + (*pV).z * (*pM).mat[9 as libc::c_int as usize];\n    v.z= (*pV).x * (*pM).mat[2 as libc::c_int as usize]\n        + (*pV).y * (*pM).mat[6 as libc::c_int as usize]\n        + (*pV).z * (*pM).mat[10 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).x= v.x;\n    (*pOut.as_deref_mut().unwrap()).y= v.y;\n    (*pOut.as_deref_mut().unwrap()).z= v.z;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::plane::kmPlaneFromPoints":"pub unsafe extern \"C\" fn kmPlaneFromPoints(\n    mut pOut: Option<&mut crate::src::kazmath::mat4::kmPlane>,\n    mut p1: *const crate::src::kazmath::aabb3::kmVec3,\n    mut p2: *const crate::src::kazmath::aabb3::kmVec3,\n    mut p3: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut crate::src::kazmath::mat4::kmPlane {\n    let mut n = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut v1 = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut v2 = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    crate::src::kazmath::vec3::kmVec3Subtract(core::ptr::addr_of_mut!(v1), p2, p1);\n    crate::src::kazmath::vec3::kmVec3Subtract(core::ptr::addr_of_mut!(v2), p3, p1);\n    crate::src::kazmath::vec3::kmVec3Cross(core::ptr::addr_of_mut!(n), core::ptr::addr_of!(v1), core::ptr::addr_of!(v2));\n    crate::src::kazmath::vec3::kmVec3Normalize(core::ptr::addr_of_mut!(n), core::ptr::addr_of!(n));\n    (*pOut.as_deref_mut().unwrap()).a= n.x;\n    (*pOut.as_deref_mut().unwrap()).b= n.y;\n    (*pOut.as_deref_mut().unwrap()).c= n.z;\n    (*pOut.as_deref_mut().unwrap()).d= crate::src::kazmath::vec3::kmVec3Dot(crate::src::kazmath::vec3::kmVec3Scale(core::ptr::addr_of_mut!(n), core::ptr::addr_of!(n), -1.0f64 as libc::c_float), p1);\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::plane::kmPlaneClassifyPoint":"pub unsafe extern \"C\" fn kmPlaneClassifyPoint(\n    mut pIn: *const crate::src::kazmath::mat4::kmPlane,\n    mut pP: *const crate::src::kazmath::aabb3::kmVec3,\n) -> KM_POINT_CLASSIFICATION {\n    let mut distance = (*pIn).a * (*pP).x + (*pIn).b * (*pP).y + (*pIn).c * (*pP).z\n        + (*pIn).d;\n    if distance as libc::c_double > 0.0001f64 {\n        return POINT_INFRONT_OF_PLANE;\n    }\n    if (distance as libc::c_double) < -0.0001f64 {\n        return POINT_BEHIND_PLANE;\n    }\n    return POINT_ON_PLANE;\n}","src::kazmath::quaternion::kmQuaternionIsIdentity":"pub unsafe extern \"C\" fn kmQuaternionIsIdentity(\n    mut pIn: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> libc::c_int {\n    return ((*pIn).x as libc::c_double == 0.0f64 && (*pIn).y as libc::c_double == 0.0f64\n        && (*pIn).z as libc::c_double == 0.0f64 && (*pIn).w as libc::c_double == 1.0f64)\n        as libc::c_int;\n}","src::kazmath::mat4::kmMat4RotationZ":"pub unsafe extern \"C\" fn kmMat4RotationZ(\n    mut pOut: Option<&mut crate::src::kazmath::mat3::kmMat4>,\n    mut radians: libc::c_float,\n) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int as usize]= cosf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[1 as libc::c_int as usize]= sinf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[2 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[3 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[4 as libc::c_int as usize]= -sinf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[5 as libc::c_int as usize]= cosf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[6 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[7 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[8 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[9 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[10 as libc::c_int as usize]= 1.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[11 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[12 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[13 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[14 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[15 as libc::c_int as usize]= 1.0f32;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::color::heman_color_from_cpcf":"pub unsafe extern \"C\" fn heman_color_from_cpcf(\n    mut cfield: *mut heman_image,\n    mut texture: *mut heman_image,\n) -> *mut heman_image {\n    if texture.is_null() {();\n        return heman_internal_rg(cfield);\n    }\n    if (*cfield).nbands == 2 as libc::c_int {} else {\n        __assert_fail(\n            b\"cfield->nbands == 2\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/color.c\\0\" as *const u8 as *const libc::c_char,\n            151 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_color_from_cpcf(heman_image *, heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if (*texture).nbands == 3 as libc::c_int || (*texture).nbands == 4 as libc::c_int\n    {} else {\n        __assert_fail(\n            b\"texture->nbands == 3 || texture->nbands == 4\\0\" as *const u8\n                as *const libc::c_char,\n            b\"../src/color.c\\0\" as *const u8 as *const libc::c_char,\n            152 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_color_from_cpcf(heman_image *, heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if (*cfield).width == (*texture).width {} else {\n        __assert_fail(\n            b\"cfield->width == texture->width\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/color.c\\0\" as *const u8 as *const libc::c_char,\n            153 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_color_from_cpcf(heman_image *, heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if (*cfield).height == (*texture).height {} else {\n        __assert_fail(\n            b\"cfield->height == texture->height\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/color.c\\0\" as *const u8 as *const libc::c_char,\n            154 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_color_from_cpcf(heman_image *, heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut w = (*cfield).width;\n    let mut h = (*cfield).height;\n    let mut target = crate::src::src::image::heman_image_create(w, h, (*texture).nbands);\n    let mut dst = (*target).data;\n    let mut src = (*cfield).data;\n    let mut size = w * h;\n    let mut i = 0 as libc::c_int;\n    while i < size {\n        let fresh20 = src;\n        src= src.offset(1);\n        let mut u = (*fresh20);\n        let fresh21 = src;\n        src= src.offset(1);\n        let mut v = (*fresh21);\n        let mut texel = crate::src::src::image::heman_image_texel(texture.as_mut(), u as libc::c_int, v as libc::c_int);\n        let mut c = 0 as libc::c_int;\n        while c < (*texture).nbands {\n            let fresh22 = texel;\n            texel= texel.offset(1);\n            let fresh23 = dst;\n            dst= dst.offset(1);\n            *fresh23= (*fresh22);\n            c+= 1;\n        }\n        i+= 1;\n    }\n    return target;\n}","src::kazmath::vec2::kmVec2Cross":"pub unsafe extern \"C\" fn kmVec2Cross(\n    mut pV1: *const crate::src::kazmath::aabb2::kmVec2,\n    mut pV2: *const crate::src::kazmath::aabb2::kmVec2,\n) -> libc::c_float {\n    return (*pV1).x * (*pV2).y - (*pV1).y * (*pV2).x;\n}","src::kazmath::vec4::kmVec4Mul":"pub unsafe extern \"C\" fn kmVec4Mul(\n    mut pOut: Option<&mut crate::src::kazmath::plane::kmVec4>,\n    mut pV1: *const crate::src::kazmath::plane::kmVec4,\n    mut pV2: *const crate::src::kazmath::plane::kmVec4,\n) -> *mut crate::src::kazmath::plane::kmVec4 {\n    (*pOut.as_deref_mut().unwrap()).x= (*pV1).x * (*pV2).x;\n    (*pOut.as_deref_mut().unwrap()).y= (*pV1).y * (*pV2).y;\n    (*pOut.as_deref_mut().unwrap()).z= (*pV1).z * (*pV2).z;\n    (*pOut.as_deref_mut().unwrap()).w= (*pV1).w * (*pV2).w;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::vec4::kmVec4Scale":"pub unsafe extern \"C\" fn kmVec4Scale(\n    mut pOut: *mut crate::src::kazmath::plane::kmVec4,\n    mut pIn: *const crate::src::kazmath::plane::kmVec4,\n    mut s: libc::c_float,\n) -> *mut crate::src::kazmath::plane::kmVec4 {\n    kmVec4Normalize(pOut, pIn);\n    (*pOut).x*= s;\n    (*pOut).y*= s;\n    (*pOut).z*= s;\n    (*pOut).w*= s;\n    return pOut;\n}","src::src::gaussian::generate_gaussian_row":"pub unsafe extern \"C\" fn generate_gaussian_row(\n    mut target: *mut libc::c_int,\n    mut fwidth: libc::c_int,\n) {\n    if fwidth > 0 as libc::c_int {} else {\n        __assert_fail(\n            b\"fwidth > 0\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/gaussian.c\\0\" as *const u8 as *const libc::c_char,\n            9 as libc::c_int as libc::c_uint,\n            b\"void generate_gaussian_row(int *, int)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut nbytes = (fwidth as libc::c_ulong)\n        .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong)\n        as libc::c_int;\n    let mut tmp = malloc(nbytes as libc::c_ulong) as *mut libc::c_int;\n    *tmp.offset(0 as libc::c_int as isize) = 1 as libc::c_int; *target.offset(0 as libc::c_int as isize)  = *tmp.offset(0 as libc::c_int as isize);\n    let mut col = 1 as libc::c_int;\n    while col < fwidth {\n        *target.offset(col as isize) = 0 as libc::c_int;\n        *tmp.offset(col as isize) = 0 as libc::c_int;\n        col+= 1;\n    }\n    let mut row = 1 as libc::c_int;\n    while row < fwidth {\n        let mut col_0 = 1 as libc::c_int;\n        while col_0 <= row {\n            *target\n                .offset(\n                    col_0 as isize,\n                ) = *tmp.offset(col_0 as isize)\n                + *tmp.offset((col_0 - 1 as libc::c_int) as isize);\n            col_0+= 1;\n        }\n        let mut col_1 = 1 as libc::c_int;\n        while col_1 <= row {\n            *tmp.offset(col_1 as isize) = *target.offset(col_1 as isize);\n            col_1+= 1;\n        }\n        row+= 1;\n    }\n    free(tmp as *mut libc::c_void);\n}","src::kazmath::mat4::kmMat4PerspectiveProjection":"pub unsafe extern \"C\" fn kmMat4PerspectiveProjection(\n    mut pOut: Option<&mut crate::src::kazmath::mat3::kmMat4>,\n    mut fovY: libc::c_float,\n    mut aspect: libc::c_float,\n    mut zNear: libc::c_float,\n    mut zFar: libc::c_float,\n) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    let mut r = crate::src::kazmath::utility::kmDegreesToRadians(fovY / 2 as libc::c_int as libc::c_float);\n    let mut deltaZ = zFar - zNear;\n    let mut s = sin(r as libc::c_double) as libc::c_float;\n    let mut cotangent = 0 as libc::c_int as libc::c_float;\n    if deltaZ == 0 as libc::c_int as libc::c_float\n        || s == 0 as libc::c_int as libc::c_float\n        || aspect == 0 as libc::c_int as libc::c_float\n    {\n        return 0 as *mut crate::src::kazmath::mat3::kmMat4;\n    }\n    cotangent= (cos(r as libc::c_double) / s as libc::c_double) as libc::c_float;\n    kmMat4Identity(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()));\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int as usize]= cotangent / aspect;\n    (*pOut.as_deref_mut().unwrap()).mat[5 as libc::c_int as usize]= cotangent;\n    (*pOut.as_deref_mut().unwrap()).mat[10 as libc::c_int as usize]= -(zFar + zNear) / deltaZ;\n    (*pOut.as_deref_mut().unwrap()).mat[11 as libc::c_int as usize]= -(1 as libc::c_int) as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).mat[14 as libc::c_int\n        as usize]= -(2 as libc::c_int) as libc::c_float * zNear * zFar / deltaZ;\n    (*pOut.as_deref_mut().unwrap()).mat[15 as libc::c_int as usize]= 0 as libc::c_int as libc::c_float;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::vec3::kmVec3LengthSq":"pub unsafe extern \"C\" fn kmVec3LengthSq(mut pIn: *const crate::src::kazmath::aabb3::kmVec3) -> libc::c_float {\n    return crate::src::kazmath::utility::kmSQR((*pIn).x) + crate::src::kazmath::utility::kmSQR((*pIn).y) + crate::src::kazmath::utility::kmSQR((*pIn).z);\n}","src::src::image::heman_image_destroy":"pub unsafe extern \"C\" fn heman_image_destroy(mut img: *mut /* owning */ heman_image) {\n    free((*img).data as *mut libc::c_void);\n    free(img as *mut libc::c_void);\n}","src::src::ops::heman_ops_stitch_horizontal":"pub unsafe extern \"C\" fn heman_ops_stitch_horizontal(\n    mut images: *mut *mut heman_image,\n    mut count: libc::c_int,\n) -> *mut /* owning */ heman_image {\n    if count > 0 as libc::c_int {} else {\n        __assert_fail(\n            b\"count > 0\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            85 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_stitch_horizontal(heman_image **, int)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut width = (**images.offset(0 as libc::c_int as isize)).width;\n    let mut height = (**images.offset(0 as libc::c_int as isize)).height;\n    let mut nbands = (**images.offset(0 as libc::c_int as isize)).nbands;\n    let mut i = 1 as libc::c_int;\n    while i < count {\n        if (**images.offset(i as isize)).width == width {} else {\n            __assert_fail(\n                b\"images[i]->width == width\\0\" as *const u8 as *const libc::c_char,\n                b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n                90 as libc::c_int as libc::c_uint,\n                b\"heman_image *heman_ops_stitch_horizontal(heman_image **, int)\\0\" as *const u8 as *const libc::c_char,\n            );\n        }\n        if (**images.offset(i as isize)).height == height {} else {\n            __assert_fail(\n                b\"images[i]->height == height\\0\" as *const u8 as *const libc::c_char,\n                b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n                91 as libc::c_int as libc::c_uint,\n                b\"heman_image *heman_ops_stitch_horizontal(heman_image **, int)\\0\" as *const u8 as *const libc::c_char,\n            );\n        }\n        if (**images.offset(i as isize)).nbands == nbands {} else {\n            __assert_fail(\n                b\"images[i]->nbands == nbands\\0\" as *const u8 as *const libc::c_char,\n                b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n                92 as libc::c_int as libc::c_uint,\n                b\"heman_image *heman_ops_stitch_horizontal(heman_image **, int)\\0\" as *const u8 as *const libc::c_char,\n            );\n        }\n        i+= 1;\n    }\n    let mut result = crate::src::src::image::heman_image_create(width * count, height, nbands);\n    let mut y: libc::c_int = 0;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut tile = 0 as libc::c_int;\n        while tile < count {\n            copy_row(*images.offset(tile as isize), result, tile * width, y);\n            tile+= 1;\n        }\n        y+= 1;\n    }\n    return result;\n}","src::kazmath::vec4::kmVec4Add":"pub unsafe extern \"C\" fn kmVec4Add(\n    mut pOut: Option<&mut crate::src::kazmath::plane::kmVec4>,\n    mut pV1: *const crate::src::kazmath::plane::kmVec4,\n    mut pV2: *const crate::src::kazmath::plane::kmVec4,\n) -> *mut crate::src::kazmath::plane::kmVec4 {\n    (*pOut.as_deref_mut().unwrap()).x= (*pV1).x + (*pV2).x;\n    (*pOut.as_deref_mut().unwrap()).y= (*pV1).y + (*pV2).y;\n    (*pOut.as_deref_mut().unwrap()).z= (*pV1).z + (*pV2).z;\n    (*pOut.as_deref_mut().unwrap()).w= (*pV1).w + (*pV2).w;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::aabb3::kmAABB3DiameterZ":"pub unsafe extern \"C\" fn kmAABB3DiameterZ(mut aabb: *const kmAABB3) -> libc::c_float {\n    return fabs(((*aabb).max.z - (*aabb).min.z) as libc::c_double) as libc::c_float;\n}","src::kazmath::vec3::kmVec3InverseTransformNormal":"pub unsafe extern \"C\" fn kmVec3InverseTransformNormal(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pVect: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pM: *const crate::src::kazmath::mat3::kmMat4,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    let mut v = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    v.x= (*pVect).x * (*pM).mat[0 as libc::c_int as usize]\n        + (*pVect).y * (*pM).mat[1 as libc::c_int as usize]\n        + (*pVect).z * (*pM).mat[2 as libc::c_int as usize];\n    v.y= (*pVect).x * (*pM).mat[4 as libc::c_int as usize]\n        + (*pVect).y * (*pM).mat[5 as libc::c_int as usize]\n        + (*pVect).z * (*pM).mat[6 as libc::c_int as usize];\n    v.z= (*pVect).x * (*pM).mat[8 as libc::c_int as usize]\n        + (*pVect).y * (*pM).mat[9 as libc::c_int as usize]\n        + (*pVect).z * (*pM).mat[10 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).x= v.x;\n    (*pOut.as_deref_mut().unwrap()).y= v.y;\n    (*pOut.as_deref_mut().unwrap()).z= v.z;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::points::heman_points_from_grid":"pub unsafe extern \"C\" fn heman_points_from_grid(\n    mut width: libc::c_float,\n    mut height: libc::c_float,\n    mut cellsize: libc::c_float,\n    mut jitter: libc::c_float,\n) -> *mut /* owning */ heman_points {\n    let mut cols = (width / cellsize) as libc::c_int;\n    let mut rows = (height / cellsize) as libc::c_int;\n    let mut ncells = cols * rows;\n    let mut result = crate::src::src::image::heman_image_create(ncells, 1 as libc::c_int, 2 as libc::c_int);\n    let mut rscale = (2.0f64 * jitter as libc::c_double\n        / 2147483647 as libc::c_int as libc::c_float as libc::c_double) as libc::c_float;\n    let mut j: libc::c_int = 0;\n    j= 0 as libc::c_int;\n    while j < rows {\n        let mut dst = (*result).data.offset((j * cols * 2 as libc::c_int) as isize);\n        let mut y = (cellsize as libc::c_double * 0.5f64\n            + (cellsize * j as libc::c_float) as libc::c_double) as libc::c_float;\n        let mut x = (cellsize as libc::c_double * 0.5f64) as libc::c_float;\n        let mut i = 0 as libc::c_int;\n        while i < cols {\n            let mut rx = rand() as libc::c_float * rscale - jitter;\n            let mut ry = rand() as libc::c_float * rscale - jitter;\n            let fresh1 = dst;\n            dst= dst.offset(1);\n            *fresh1= x + rx;\n            let fresh2 = dst;\n            dst= dst.offset(1);\n            *fresh2= y + ry;\n            x+= cellsize;\n            i+= 1;\n        }\n        j+= 1;\n    }\n    return result;\n}","src::kazmath::aabb2::kmAABB2ContainsAABB":"pub unsafe extern \"C\" fn kmAABB2ContainsAABB(\n    mut container: *const kmAABB2,\n    mut to_check: *const kmAABB2,\n) -> libc::c_uint {\n    let mut corners: [kmVec2; 4] = [kmVec2 { x: 0., y: 0. }; 4];\n    crate::src::kazmath::vec2::kmVec2Fill(\n        Some(&mut *corners.as_mut_ptr().offset(0 as libc::c_int as isize)),\n        (*to_check).min.x,\n        (*to_check).min.y,\n    );\n    crate::src::kazmath::vec2::kmVec2Fill(\n        Some(&mut *corners.as_mut_ptr().offset(1 as libc::c_int as isize)),\n        (*to_check).max.x,\n        (*to_check).min.y,\n    );\n    crate::src::kazmath::vec2::kmVec2Fill(\n        Some(&mut *corners.as_mut_ptr().offset(2 as libc::c_int as isize)),\n        (*to_check).max.x,\n        (*to_check).max.y,\n    );\n    crate::src::kazmath::vec2::kmVec2Fill(\n        Some(&mut *corners.as_mut_ptr().offset(3 as libc::c_int as isize)),\n        (*to_check).min.x,\n        (*to_check).max.y,\n    );\n    let mut nContains = kmAABB2ContainsPoint(\n        container,\n        core::ptr::addr_of_mut!(*corners.as_mut_ptr().offset(0 as libc::c_int as isize)),\n    )\n        + kmAABB2ContainsPoint(\n            container,\n            core::ptr::addr_of_mut!(*corners.as_mut_ptr().offset(1 as libc::c_int as isize)),\n        )\n        + kmAABB2ContainsPoint(\n            container,\n            core::ptr::addr_of_mut!(*corners.as_mut_ptr().offset(2 as libc::c_int as isize)),\n        )\n        + kmAABB2ContainsPoint(\n            container,\n            core::ptr::addr_of_mut!(*corners.as_mut_ptr().offset(3 as libc::c_int as isize)),\n        );\n    if nContains == 0 as libc::c_int {\n        return 0 as libc::c_int as libc::c_uint\n    } else if nContains < 4 as libc::c_int {\n        return 1 as libc::c_int as libc::c_uint\n    } else {\n        return 2 as libc::c_int as libc::c_uint\n    };\n}","src::src::ops::heman_ops_warp":"pub unsafe extern \"C\" fn heman_ops_warp(\n    mut img: *mut heman_image,\n    mut seed: libc::c_int,\n    mut octaves: libc::c_int,\n) -> *mut heman_image {\n    return heman_ops_warp_core(img, 0 as *mut heman_image, seed, octaves);\n}","src::src::ops::heman_ops_stairstep":"pub unsafe extern \"C\" fn heman_ops_stairstep(\n    mut hmap: Option<&mut heman_image>,\n    mut nsteps: libc::c_int,\n    mut mask: *mut heman_image,\n    mut mask_color: heman_color,\n    mut invert_mask: libc::c_int,\n    mut offset: libc::c_float,\n) -> *mut heman_image {\n    if (*hmap.as_deref().unwrap()).nbands == 1 as libc::c_int {} else {\n        __assert_fail(\n            b\"hmap->nbands == 1\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            477 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_stairstep(heman_image *, int, heman_image *, heman_color, int, float)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if mask.is_null() || (*mask).nbands == 3 as libc::c_int {} else {\n        __assert_fail(\n            b\"!mask || mask->nbands == 3\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            478 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_stairstep(heman_image *, int, heman_image *, heman_color, int, float)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut size = (*hmap.as_deref().unwrap()).height * (*hmap.as_deref().unwrap()).width;\n    let mut src = (*hmap.as_deref().unwrap()).data;\n    let mut minv = 1000 as libc::c_int as libc::c_float;\n    let mut maxv = -(1000 as libc::c_int) as libc::c_float;\n    let mut i = 0 as libc::c_int;\n    while i < size {\n        if mask.is_null() || _match(mask, mask_color, invert_mask, i) != 0 {\n            minv= if minv > *src.offset(i as isize) {\n                *src.offset(i as isize)\n            } else {\n                minv\n            };\n            maxv= if maxv > *src.offset(i as isize) {\n                maxv\n            } else {\n                *src.offset(i as isize)\n            };\n        }\n        i+= 1;\n    }\n    let mut range = maxv - minv;\n    let mut i_0 = 0 as libc::c_int;\n    while i_0 < size {\n        let mut e = (*src);\n        if mask.is_null() || _match(mask, mask_color, invert_mask, i_0) != 0 {\n            e= e - minv;\n            e/= range;\n            e= (floor((e * nsteps as libc::c_float) as libc::c_double)\n                / nsteps as libc::c_double) as libc::c_float;\n            e= e * range + minv;\n        }\n        let fresh22 = src;\n        src= src.offset(1);\n        *fresh22= e + offset;\n        i_0+= 1;\n    }\n    return hmap.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::plane::kmPlaneFromPointAndNormal":"pub unsafe extern \"C\" fn kmPlaneFromPointAndNormal(\n    mut pOut: Option<&mut crate::src::kazmath::mat4::kmPlane>,\n    mut pPoint: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pNormal: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut crate::src::kazmath::mat4::kmPlane {\n    (*pOut.as_deref_mut().unwrap()).a= (*pNormal).x;\n    (*pOut.as_deref_mut().unwrap()).b= (*pNormal).y;\n    (*pOut.as_deref_mut().unwrap()).c= (*pNormal).z;\n    (*pOut.as_deref_mut().unwrap()).d= -crate::src::kazmath::vec3::kmVec3Dot(pNormal, pPoint);\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::utility::kmAlmostEqual":"pub unsafe extern \"C\" fn kmAlmostEqual(\n    mut lhs: libc::c_float,\n    mut rhs: libc::c_float,\n) -> libc::c_uchar {\n    return (lhs as libc::c_double + 0.0001f64 > rhs as libc::c_double\n        && lhs as libc::c_double - 0.0001f64 < rhs as libc::c_double) as libc::c_int\n        as libc::c_uchar;\n}","src::kazmath::mat3::kmMat3GetRightVec3":"pub unsafe extern \"C\" fn kmMat3GetRightVec3(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pIn: *const kmMat3,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    (*pOut.as_deref_mut().unwrap()).x= (*pIn).mat[0 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).y= (*pIn).mat[1 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).z= (*pIn).mat[2 as libc::c_int as usize];\n    crate::src::kazmath::vec3::kmVec3Normalize(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), pOut.as_deref().map(|r| r as *const _).unwrap_or(std::ptr::null()));\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::mat4::kmMat4GetForwardVec3LH":"pub unsafe extern \"C\" fn kmMat4GetForwardVec3LH(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pIn: *const crate::src::kazmath::mat3::kmMat4,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    crate::src::kazmath::vec3::kmVec3MultiplyMat4(pOut.as_deref_mut(), &KM_VEC3_POS_Z, pIn);\n    crate::src::kazmath::vec3::kmVec3Normalize(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), pOut.as_deref().map(|r| r as *const _).unwrap_or(std::ptr::null()));\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::generate::heman_generate_archipelago_political_2":"pub unsafe extern \"C\" fn heman_generate_archipelago_political_2(\n    mut width: libc::c_int,\n    mut height: libc::c_int,\n    mut ocean: heman_color,\n    mut seed: libc::c_int,\n    mut political: *mut heman_image,\n    mut invert: libc::c_int,\n) -> *mut /* owning */ heman_image {\n    let mut coastmask = crate::src::src::ops::heman_ops_extract_mask(political, ocean, invert);\n    let mut sdf = crate::src::src::distance::heman_distance_create_sdf(coastmask);\n    crate::src::src::image::heman_image_destroy(coastmask);\n    let mut elevation = crate::src::src::image::heman_image_create(width, height, 1 as libc::c_int);\n    let mut noisetex = heman_internal_generate_island_noise(width, height, seed);\n    let mut data = (*elevation).data;\n    let mut invw = (1.0f64 / width as libc::c_double) as libc::c_float;\n    let mut invh = (1.0f64 / height as libc::c_double) as libc::c_float;\n    let mut y: libc::c_int = 0;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut dst = data.offset((y * width) as isize);\n        let mut x = 0 as libc::c_int;\n        while x < width {\n            let mut n: [libc::c_float; 3] = [0.; 3];\n            let mut u = x as libc::c_float * invw;\n            let mut v = y as libc::c_float * invh;\n            crate::src::src::image::heman_image_sample(noisetex.as_mut(), u, v, n.as_mut_ptr());\n            let mut z: libc::c_float = 0.;\n            crate::src::src::image::heman_image_sample(sdf.as_mut(), u, v, core::ptr::addr_of_mut!(z));\n            if z as libc::c_double > 0.0f64 {\n                let mut influence = z;\n                u+= influence * n[1 as libc::c_int as usize];\n                v+= influence * n[2 as libc::c_int as usize];\n                crate::src::src::image::heman_image_sample(sdf.as_mut(), u, v, core::ptr::addr_of_mut!(z));\n                z+= 6 as libc::c_int as libc::c_float * influence\n                        * n[0 as libc::c_int as usize];\n            }\n            let fresh16 = dst;\n            dst= dst.offset(1);\n            *fresh16= z;\n            x+= 1;\n        }\n        y+= 1;\n    }\n    crate::src::src::image::heman_image_destroy(noisetex);\n    crate::src::src::image::heman_image_destroy(sdf);\n    return elevation;\n}","src::kazmath::vec4::kmVec4AreEqual":"pub unsafe extern \"C\" fn kmVec4AreEqual(\n    mut p1: *const crate::src::kazmath::plane::kmVec4,\n    mut p2: *const crate::src::kazmath::plane::kmVec4,\n) -> libc::c_int {\n    return (((*p1).x as libc::c_double) < (*p2).x as libc::c_double + 0.0001f64\n        && (*p1).x as libc::c_double > (*p2).x as libc::c_double - 0.0001f64\n        && (((*p1).y as libc::c_double) < (*p2).y as libc::c_double + 0.0001f64\n            && (*p1).y as libc::c_double > (*p2).y as libc::c_double - 0.0001f64)\n        && (((*p1).z as libc::c_double) < (*p2).z as libc::c_double + 0.0001f64\n            && (*p1).z as libc::c_double > (*p2).z as libc::c_double - 0.0001f64)\n        && (((*p1).w as libc::c_double) < (*p2).w as libc::c_double + 0.0001f64\n            && (*p1).w as libc::c_double > (*p2).w as libc::c_double - 0.0001f64))\n        as libc::c_int;\n}","src::kazmath::mat3::kmMat3GetUpVec3":"pub unsafe extern \"C\" fn kmMat3GetUpVec3(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pIn: *const kmMat3,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    (*pOut.as_deref_mut().unwrap()).x= (*pIn).mat[3 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).y= (*pIn).mat[4 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).z= (*pIn).mat[5 as libc::c_int as usize];\n    crate::src::kazmath::vec3::kmVec3Normalize(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), pOut.as_deref().map(|r| r as *const _).unwrap_or(std::ptr::null()));\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::mat4::kmMat4GetUpVec3":"pub unsafe extern \"C\" fn kmMat4GetUpVec3(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pIn: *const crate::src::kazmath::mat3::kmMat4,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    crate::src::kazmath::vec3::kmVec3MultiplyMat4(pOut.as_deref_mut(), &KM_VEC3_POS_Y, pIn);\n    crate::src::kazmath::vec3::kmVec3Normalize(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), pOut.as_deref().map(|r| r as *const _).unwrap_or(std::ptr::null()));\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::vec3::kmVec3Normalize":"pub unsafe extern \"C\" fn kmVec3Normalize(\n    mut pOut: *mut crate::src::kazmath::aabb3::kmVec3,\n    mut pIn: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    if (*pIn).x == 0. && (*pIn).y == 0. && (*pIn).z == 0. {\n        return kmVec3Assign(pOut, pIn);\n    }\n    let mut l = 1.0f32 / kmVec3Length(pIn);\n    let mut v = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    v.x= (*pIn).x * l;\n    v.y= (*pIn).y * l;\n    v.z= (*pIn).z * l;\n    (*pOut).x= v.x;\n    (*pOut).y= v.y;\n    (*pOut).z= v.z;\n    return pOut;\n}","src::src::ops::heman_ops_laplacian":"pub unsafe extern \"C\" fn heman_ops_laplacian(\n    mut heightmap: *mut heman_image,\n) -> *mut heman_image {\n    if (*heightmap).nbands == 1 as libc::c_int {} else {\n        __assert_fail(\n            b\"heightmap->nbands == 1\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            146 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_laplacian(heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut width = (*heightmap).width;\n    let mut height = (*heightmap).height;\n    let mut result = crate::src::src::image::heman_image_create(width, height, 1 as libc::c_int);\n    let mut maxx = width - 1 as libc::c_int;\n    let mut maxy = height - 1 as libc::c_int;\n    let mut y: libc::c_int = 0;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut y1 = if y + 1 as libc::c_int > maxy {\n            maxy\n        } else {\n            y + 1 as libc::c_int\n        };\n        let mut dst = (*result).data.offset((y * width) as isize);\n        let mut x = 0 as libc::c_int;\n        while x < width {\n            let mut x1 = if x + 1 as libc::c_int > maxx {\n                maxx\n            } else {\n                x + 1 as libc::c_int\n            };\n            let mut p = *crate::src::src::image::heman_image_texel(heightmap.as_mut(), x, y);\n            let mut px = *crate::src::src::image::heman_image_texel(heightmap.as_mut(), x1, y);\n            let mut py = *crate::src::src::image::heman_image_texel(heightmap.as_mut(), x, y1);\n            let fresh9 = dst;\n            dst= dst.offset(1);\n            *fresh9= (p - px) * (p - px) + (p - py) * (p - py);\n            x+= 1;\n        }\n        y+= 1;\n    }\n    return result;\n}","src::src::noise::extrapolate2":"unsafe extern \"C\" fn extrapolate2(\n    mut ctx: *mut osn_context,\n    mut xsb: libc::c_int,\n    mut ysb: libc::c_int,\n    mut dx: libc::c_double,\n    mut dy: libc::c_double,\n) -> libc::c_double {\n    let mut perm = (*ctx).perm;\n    let mut index = *perm\n        .offset(\n            (*perm.offset((xsb & 0xff as libc::c_int) as isize) as libc::c_int + ysb\n                & 0xff as libc::c_int) as isize,\n        ) as libc::c_int & 0xe as libc::c_int;\n    return crate::src::src::noise::gradients2D[index as usize] as libc::c_int as libc::c_double * dx\n        + crate::src::src::noise::gradients2D[(index + 1 as libc::c_int) as usize] as libc::c_int\n            as libc::c_double * dy;\n}","src::kazmath::vec2::kmVec2Transform":"pub unsafe extern \"C\" fn kmVec2Transform(\n    mut pOut: Option<&mut crate::src::kazmath::aabb2::kmVec2>,\n    mut pV: *const crate::src::kazmath::aabb2::kmVec2,\n    mut pM: *const crate::src::kazmath::mat3::kmMat3,\n) -> *mut crate::src::kazmath::aabb2::kmVec2 {\n    let mut v = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    v.x= (*pV).x * (*pM).mat[0 as libc::c_int as usize]\n        + (*pV).y * (*pM).mat[3 as libc::c_int as usize]\n        + (*pM).mat[6 as libc::c_int as usize];\n    v.y= (*pV).x * (*pM).mat[1 as libc::c_int as usize]\n        + (*pV).y * (*pM).mat[4 as libc::c_int as usize]\n        + (*pM).mat[7 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).x= v.x;\n    (*pOut.as_deref_mut().unwrap()).y= v.y;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::quaternion::kmQuaternionIdentity":"pub unsafe extern \"C\" fn kmQuaternionIdentity(\n    mut pOut: Option<&mut crate::src::kazmath::mat3::kmQuaternion>,\n) -> *mut crate::src::kazmath::mat3::kmQuaternion {\n    (*pOut.as_deref_mut().unwrap()).x= 0.0f64 as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).y= 0.0f64 as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).z= 0.0f64 as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).w= 1.0f64 as libc::c_float;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::ops::heman_ops_step":"pub unsafe extern \"C\" fn heman_ops_step(\n    mut hmap: *mut heman_image,\n    mut threshold: libc::c_float,\n) -> *mut /* owning */ heman_image {\n    if (*hmap).nbands == 1 as libc::c_int {} else {\n        __assert_fail(\n            b\"hmap->nbands == 1\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            17 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_step(heman_image *, float)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut result = crate::src::src::image::heman_image_create((*hmap).width, (*hmap).height, 1 as libc::c_int);\n    let mut size = (*hmap).height * (*hmap).width;\n    let mut src = (*hmap).data;\n    let mut dst = (*result).data;\n    let mut i = 0 as libc::c_int;\n    while i < size {\n        let fresh0 = src;\n        src= src.offset(1);\n        let fresh1 = dst;\n        dst= dst.offset(1);\n        *fresh1= (if (*fresh0) >= threshold {\n            1 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_float;\n        i+= 1;\n    }\n    return result;\n}","src::src::lighting::heman_lighting_compute_normals":"pub unsafe extern \"C\" fn heman_lighting_compute_normals(\n    mut heightmap: *mut heman_image,\n) -> *mut heman_image {\n    if (*heightmap).nbands == 1 as libc::c_int {} else {\n        __assert_fail(\n            b\"heightmap->nbands == 1\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/lighting.c\\0\" as *const u8 as *const libc::c_char,\n            16 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_lighting_compute_normals(heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut width = (*heightmap).width;\n    let mut height = (*heightmap).height;\n    let mut result = crate::src::src::image::heman_image_create(width, height, 3 as libc::c_int);\n    let mut invh = 1.0f32 / height as libc::c_float;\n    let mut invw = 1.0f32 / width as libc::c_float;\n    let mut maxx = width - 1 as libc::c_int;\n    let mut maxy = height - 1 as libc::c_int;\n    let mut normals = (*result).data as *mut crate::src::kazmath::aabb3::kmVec3;\n    let mut y: libc::c_int = 0;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut v = y as libc::c_float * invh;\n        let mut y1 = if y + 1 as libc::c_int > maxy {\n            maxy\n        } else {\n            y + 1 as libc::c_int\n        };\n        let mut p = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n        let mut px = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n        let mut py = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n        let mut n = normals.offset((y * width) as isize);\n        let mut x = 0 as libc::c_int;\n        while x < width {\n            let mut u = x as libc::c_float * invw;\n            let mut x1 = if x + 1 as libc::c_int > maxx {\n                maxx\n            } else {\n                x + 1 as libc::c_int\n            };\n            p.x= u;\n            p.y= v;\n            p.z= *crate::src::src::image::heman_image_texel(heightmap.as_mut(), x, y);\n            px.x= u + invw;\n            px.y= v;\n            px.z= *crate::src::src::image::heman_image_texel(heightmap.as_mut(), x1, y);\n            py.x= u;\n            py.y= v + invh;\n            py.z= *crate::src::src::image::heman_image_texel(heightmap.as_mut(), x, y1);\n            crate::src::kazmath::vec3::kmVec3Subtract(core::ptr::addr_of_mut!(px), core::ptr::addr_of!(px), core::ptr::addr_of!(p));\n            crate::src::kazmath::vec3::kmVec3Subtract(core::ptr::addr_of_mut!(py), core::ptr::addr_of!(py), core::ptr::addr_of!(p));\n            crate::src::kazmath::vec3::kmVec3Cross(n, core::ptr::addr_of!(px), core::ptr::addr_of!(py));\n            crate::src::kazmath::vec3::kmVec3Normalize(n, n);\n            (*n).y*= -(1 as libc::c_int) as libc::c_float;\n            x+= 1;\n            n= n.offset(1);\n        }\n        y+= 1;\n    }\n    return result;\n}","src::kazmath::ray2::calculate_line_normal":"pub unsafe extern \"C\" fn calculate_line_normal(\n    mut p1: crate::src::kazmath::aabb2::kmVec2,\n    mut p2: crate::src::kazmath::aabb2::kmVec2,\n    mut other_point: crate::src::kazmath::aabb2::kmVec2,\n    mut normal_out: Option<&mut crate::src::kazmath::aabb2::kmVec2>,\n) {\n    let mut edge = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    let mut other_edge = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    crate::src::kazmath::vec2::kmVec2Subtract(core::ptr::addr_of_mut!(edge), core::ptr::addr_of!(p2), core::ptr::addr_of!(p1));\n    crate::src::kazmath::vec2::kmVec2Subtract(core::ptr::addr_of_mut!(other_edge), core::ptr::addr_of!(other_point), core::ptr::addr_of!(p1));\n    crate::src::kazmath::vec2::kmVec2Normalize(core::ptr::addr_of_mut!(edge), core::ptr::addr_of!(edge));\n    crate::src::kazmath::vec2::kmVec2Normalize(core::ptr::addr_of_mut!(other_edge), core::ptr::addr_of!(other_edge));\n    let mut n = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    n.x= edge.y;\n    n.y= -edge.x;\n    let mut d = crate::src::kazmath::vec2::kmVec2Dot(core::ptr::addr_of!(n), core::ptr::addr_of!(other_edge));\n    if d > 0.0f32 {\n        n.x= -n.x;\n        n.y= -n.y;\n    }\n    (*normal_out.as_deref_mut().unwrap()).x= n.x;\n    (*normal_out.as_deref_mut().unwrap()).y= n.y;\n    crate::src::kazmath::vec2::kmVec2Normalize(normal_out.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), normal_out.as_deref().map(|r| r as *const _).unwrap_or(std::ptr::null()));\n}","src::kazmath::mat3::kmMat3RotationY":"pub unsafe extern \"C\" fn kmMat3RotationY(\n    mut pOut: Option<&mut kmMat3>,\n    mut radians: libc::c_float,\n) -> *mut kmMat3 {\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int as usize]= cosf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[1 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[2 as libc::c_int as usize]= -sinf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[3 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[4 as libc::c_int as usize]= 1.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[5 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[6 as libc::c_int as usize]= sinf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[7 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[8 as libc::c_int as usize]= cosf(radians);\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::mat4::kmMat4GetForwardVec3RH":"pub unsafe extern \"C\" fn kmMat4GetForwardVec3RH(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pIn: *const crate::src::kazmath::mat3::kmMat4,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    crate::src::kazmath::vec3::kmVec3MultiplyMat4(pOut.as_deref_mut(), &KM_VEC3_NEG_Z, pIn);\n    crate::src::kazmath::vec3::kmVec3Normalize(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), pOut.as_deref().map(|r| r as *const _).unwrap_or(std::ptr::null()));\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::points::randhashf":"pub unsafe extern \"C\" fn randhashf(\n    mut seed: libc::c_uint,\n    mut a: libc::c_float,\n    mut b: libc::c_float,\n) -> libc::c_float {\n    return (b - a) * randhash(seed) as libc::c_float\n        / (2147483647 as libc::c_int as libc::c_uint)\n            .wrapping_mul(2 as libc::c_uint)\n            .wrapping_add(1 as libc::c_uint) as libc::c_float + a;\n}","src::src::export::heman_export_u8":"pub unsafe extern \"C\" fn heman_export_u8(\n    mut source: *mut heman_image,\n    mut minv: libc::c_float,\n    mut maxv: libc::c_float,\n    mut outp: *mut heman_byte,\n) {\n    let mut inp: *const libc::c_float = (*source).data as *const f32;\n    let mut scale = 1.0f32 / (maxv - minv);\n    let mut size = (*source).height * (*source).width * (*source).nbands;\n    let mut i = 0 as libc::c_int;\n    while i < size {\n        let fresh0 = inp;\n        inp= inp.offset(1);\n        let mut v = 255 as libc::c_int as libc::c_float * ((*fresh0) - minv) * scale;\n        let fresh1 = outp;\n        outp= outp.offset(1);\n        *fresh1= (if 0 as libc::c_int as libc::c_float\n            > (if 255 as libc::c_int as libc::c_float > v {\n                v\n            } else {\n                255 as libc::c_int as libc::c_float\n            })\n        {\n            0 as libc::c_int as libc::c_float\n        } else if 255 as libc::c_int as libc::c_float > v {\n            v\n        } else {\n            255 as libc::c_int as libc::c_float\n        }) as heman_byte;\n        i+= 1;\n    }\n}","src::src::distance::edt":"unsafe extern \"C\" fn edt(\n    mut f: *mut libc::c_float,\n    mut d: *mut libc::c_float,\n    mut z: *mut libc::c_float,\n    mut w: *mut uint16_t,\n    mut n: libc::c_int,\n) {\n    let mut k = 0 as libc::c_int;\n    let mut s: libc::c_float = 0.;\n    *w.offset(0 as libc::c_int as isize) = 0 as libc::c_int as uint16_t;\n    *z.offset(0 as libc::c_int as isize) = -crate::src::src::distance::INF;\n    *z.offset(1 as libc::c_int as isize) = crate::src::src::distance::INF;\n    let mut q = 1 as libc::c_int;\n    while q < n {\n        s= (*f.offset(q as isize) + (q * q) as libc::c_float\n            - (*f.offset(*w.offset(k as isize) as isize)\n                + (*w.offset(k as isize) as libc::c_int\n                    * *w.offset(k as isize) as libc::c_int) as libc::c_float))\n            / (2 as libc::c_int * q\n                - 2 as libc::c_int * *w.offset(k as isize) as libc::c_int)\n                as libc::c_float;\n        while s <= *z.offset(k as isize) {\n            k-= 1;\n            s= (*f.offset(q as isize) + (q * q) as libc::c_float\n                - (*f.offset(*w.offset(k as isize) as isize)\n                    + (*w.offset(k as isize) as libc::c_int\n                        * *w.offset(k as isize) as libc::c_int) as libc::c_float))\n                / (2 as libc::c_int * q\n                    - 2 as libc::c_int * *w.offset(k as isize) as libc::c_int)\n                    as libc::c_float;\n        }\n        k+= 1;\n        *w.offset(k as isize) = q as uint16_t;\n        *z.offset(k as isize) = s;\n        *z.offset((k + 1 as libc::c_int) as isize) = crate::src::src::distance::INF;\n        q+= 1;\n    }\n    k= 0 as libc::c_int;\n    let mut q_0 = 0 as libc::c_int;\n    while q_0 < n {\n        while *z.offset((k + 1 as libc::c_int) as isize) < q_0 as libc::c_float {\n            k+= 1;\n        }\n        *d\n            .offset(\n                q_0 as isize,\n            ) = ((q_0 - *w.offset(k as isize) as libc::c_int)\n            * (q_0 - *w.offset(k as isize) as libc::c_int)) as libc::c_float\n            + *f.offset(*w.offset(k as isize) as isize);\n        q_0+= 1;\n    }\n}","src::kazmath::quaternion::kmQuaternionSlerp":"pub unsafe extern \"C\" fn kmQuaternionSlerp(\n    mut pOut: *mut crate::src::kazmath::mat3::kmQuaternion,\n    mut q1: *const crate::src::kazmath::mat3::kmQuaternion,\n    mut q2: *const crate::src::kazmath::mat3::kmQuaternion,\n    mut t: libc::c_float,\n) -> *mut crate::src::kazmath::mat3::kmQuaternion {\n    let mut dot = kmQuaternionDot(q1, q2);\n    let DOT_THRESHOLD = 0.9995f64;\n    if dot as libc::c_double > DOT_THRESHOLD {\n        let mut diff = crate::src::kazmath::mat3::kmQuaternion {\n            x: 0.,\n            y: 0.,\n            z: 0.,\n            w: 0.,\n        };\n        kmQuaternionSubtract(core::ptr::addr_of_mut!(diff), q2, q1);\n        kmQuaternionScale(core::ptr::addr_of_mut!(diff), core::ptr::addr_of!(diff), t);\n        kmQuaternionAdd(pOut, q1, core::ptr::addr_of!(diff));\n        kmQuaternionNormalize(pOut, pOut);\n        return pOut;\n    }\n    dot= crate::src::kazmath::utility::kmClamp(\n        dot,\n        -(1 as libc::c_int) as libc::c_float,\n        1 as libc::c_int as libc::c_float,\n    );\n    let mut theta_0 = acos(dot as libc::c_double) as libc::c_float;\n    let mut theta = theta_0 * t;\n    let mut tmp = crate::src::kazmath::mat3::kmQuaternion {\n        x: 0.,\n        y: 0.,\n        z: 0.,\n        w: 0.,\n    };\n    kmQuaternionScale(core::ptr::addr_of_mut!(tmp), q1, dot);\n    kmQuaternionSubtract(core::ptr::addr_of_mut!(tmp), q2, core::ptr::addr_of!(tmp));\n    kmQuaternionNormalize(core::ptr::addr_of_mut!(tmp), core::ptr::addr_of!(tmp));\n    let mut t1 = crate::src::kazmath::mat3::kmQuaternion {\n        x: 0.,\n        y: 0.,\n        z: 0.,\n        w: 0.,\n    };\n    let mut t2 = crate::src::kazmath::mat3::kmQuaternion {\n        x: 0.,\n        y: 0.,\n        z: 0.,\n        w: 0.,\n    };\n    kmQuaternionScale(core::ptr::addr_of_mut!(t1), q1, cos(theta as libc::c_double) as libc::c_float);\n    kmQuaternionScale(core::ptr::addr_of_mut!(t2), core::ptr::addr_of!(tmp), sin(theta as libc::c_double) as libc::c_float);\n    kmQuaternionAdd(pOut, core::ptr::addr_of!(t1), core::ptr::addr_of!(t2));\n    return pOut;\n}","src::src::ops::heman_ops_stitch_vertical":"pub unsafe extern \"C\" fn heman_ops_stitch_vertical(\n    mut images: *mut *mut heman_image,\n    mut count: libc::c_int,\n) -> *mut /* owning */ heman_image {\n    if count > 0 as libc::c_int {} else {\n        __assert_fail(\n            b\"count > 0\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            109 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_stitch_vertical(heman_image **, int)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut width = (**images.offset(0 as libc::c_int as isize)).width;\n    let mut height = (**images.offset(0 as libc::c_int as isize)).height;\n    let mut nbands = (**images.offset(0 as libc::c_int as isize)).nbands;\n    let mut i = 1 as libc::c_int;\n    while i < count {\n        if (**images.offset(i as isize)).width == width {} else {\n            __assert_fail(\n                b\"images[i]->width == width\\0\" as *const u8 as *const libc::c_char,\n                b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n                114 as libc::c_int as libc::c_uint,\n                b\"heman_image *heman_ops_stitch_vertical(heman_image **, int)\\0\" as *const u8 as *const libc::c_char,\n            );\n        }\n        if (**images.offset(i as isize)).height == height {} else {\n            __assert_fail(\n                b\"images[i]->height == height\\0\" as *const u8 as *const libc::c_char,\n                b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n                115 as libc::c_int as libc::c_uint,\n                b\"heman_image *heman_ops_stitch_vertical(heman_image **, int)\\0\" as *const u8 as *const libc::c_char,\n            );\n        }\n        if (**images.offset(i as isize)).nbands == nbands {} else {\n            __assert_fail(\n                b\"images[i]->nbands == nbands\\0\" as *const u8 as *const libc::c_char,\n                b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n                116 as libc::c_int as libc::c_uint,\n                b\"heman_image *heman_ops_stitch_vertical(heman_image **, int)\\0\" as *const u8 as *const libc::c_char,\n            );\n        }\n        i+= 1;\n    }\n    let mut result = crate::src::src::image::heman_image_create(width, height * count, nbands);\n    let mut size = width * height * nbands;\n    let mut dst = (*result).data;\n    let mut tile = 0 as libc::c_int;\n    while tile < count {\n        memcpy(\n            dst as *mut libc::c_void,\n            (**images.offset(tile as isize)).data as *const libc::c_void,\n            (size as libc::c_ulong)\n                .wrapping_mul(::std::mem::size_of::<libc::c_float>() as libc::c_ulong),\n        );\n        dst= dst.offset(size as isize);\n        tile+= 1;\n    }\n    return result;\n}","src::kazmath::vec2::kmVec2Normalize":"pub unsafe extern \"C\" fn kmVec2Normalize(\n    mut pOut: *mut crate::src::kazmath::aabb2::kmVec2,\n    mut pIn: *const crate::src::kazmath::aabb2::kmVec2,\n) -> *mut crate::src::kazmath::aabb2::kmVec2 {\n    if (*pIn).x == 0. && (*pIn).y == 0. {\n        return kmVec2Assign(pOut, pIn);\n    }\n    let mut l = 1.0f32 / kmVec2Length(pIn);\n    let mut v = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    v.x= (*pIn).x * l;\n    v.y= (*pIn).y * l;\n    (*pOut).x= v.x;\n    (*pOut).y= v.y;\n    return pOut;\n}","src::src::distance::transform_to_coordfield":"unsafe extern \"C\" fn transform_to_coordfield(\n    mut sdf: *mut heman_image,\n    mut cf: *mut heman_image,\n) {\n    let mut width = (*sdf).width;\n    let mut height = (*sdf).height;\n    let mut size = width * height;\n    let mut ff = calloc(\n        size as libc::c_ulong,\n        ::std::mem::size_of::<libc::c_float>() as libc::c_ulong,\n    ) as *mut libc::c_float;\n    let mut dd = calloc(\n        size as libc::c_ulong,\n        ::std::mem::size_of::<libc::c_float>() as libc::c_ulong,\n    ) as *mut libc::c_float;\n    let mut zz = calloc(\n        ((height + 1 as libc::c_int) * (width + 1 as libc::c_int)) as libc::c_ulong,\n        ::std::mem::size_of::<libc::c_float>() as libc::c_ulong,\n    ) as *mut libc::c_float;\n    let mut ww = calloc(\n        size as libc::c_ulong,\n        ::std::mem::size_of::<uint16_t>() as libc::c_ulong,\n    ) as *mut uint16_t;\n    let mut x: libc::c_int = 0;\n    x= 0 as libc::c_int;\n    while x < width {\n        let mut pl1 = calloc(\n            (height * 2 as libc::c_int) as libc::c_ulong,\n            ::std::mem::size_of::<libc::c_float>() as libc::c_ulong,\n        ) as *mut libc::c_float;\n        let mut pl2 = calloc(\n            (height * 2 as libc::c_int) as libc::c_ulong,\n            ::std::mem::size_of::<libc::c_float>() as libc::c_ulong,\n        ) as *mut libc::c_float;\n        let mut f = ff.offset((height * x) as isize);\n        let mut d = dd.offset((height * x) as isize);\n        let mut z = zz.offset(((height + 1 as libc::c_int) * x) as isize);\n        let mut w = ww.offset((height * x) as isize);\n        let mut y = 0 as libc::c_int;\n        while y < height {\n            *f\n                .offset(\n                    y as isize,\n                ) = *(*sdf).data.offset((y * width) as isize).offset(x as isize);\n            *pl1\n                .offset(\n                    (y * 2 as libc::c_int) as isize,\n                ) = *(*cf).data\n                .offset((2 as libc::c_int * (y * width + x)) as isize)\n                .offset(0 as libc::c_int as isize);\n            *pl1\n                .offset(\n                    (y * 2 as libc::c_int + 1 as libc::c_int) as isize,\n                ) = *(*cf).data\n                .offset((2 as libc::c_int * (y * width + x)) as isize)\n                .offset(1 as libc::c_int as isize);\n            y+= 1;\n        }\n        edt_with_payload(f, d, z, w, height, pl1, pl2);\n        let mut y_0 = 0 as libc::c_int;\n        while y_0 < height {\n            *(*sdf).data\n                .offset((y_0 * width) as isize)\n                .offset(x as isize) = *d.offset(y_0 as isize);\n            *(*cf).data\n                .offset((2 as libc::c_int * (y_0 * width + x)) as isize)\n                .offset(\n                    0 as libc::c_int as isize,\n                ) = *pl2.offset((2 as libc::c_int * y_0) as isize);\n            *(*cf).data\n                .offset((2 as libc::c_int * (y_0 * width + x)) as isize)\n                .offset(\n                    1 as libc::c_int as isize,\n                ) = *pl2.offset((2 as libc::c_int * y_0 + 1 as libc::c_int) as isize);\n            y_0+= 1;\n        }\n        free(pl1 as *mut libc::c_void);\n        free(pl2 as *mut libc::c_void);\n        x+= 1;\n    }\n    let mut y_1: libc::c_int = 0;\n    y_1= 0 as libc::c_int;\n    while y_1 < height {\n        let mut pl1_0 = calloc(\n            (width * 2 as libc::c_int) as libc::c_ulong,\n            ::std::mem::size_of::<libc::c_float>() as libc::c_ulong,\n        ) as *mut libc::c_float;\n        let mut pl2_0 = calloc(\n            (width * 2 as libc::c_int) as libc::c_ulong,\n            ::std::mem::size_of::<libc::c_float>() as libc::c_ulong,\n        ) as *mut libc::c_float;\n        let mut f_0 = ff.offset((width * y_1) as isize);\n        let mut d_0 = dd.offset((width * y_1) as isize);\n        let mut z_0 = zz.offset(((width + 1 as libc::c_int) * y_1) as isize);\n        let mut w_0 = ww.offset((width * y_1) as isize);\n        let mut x_0 = 0 as libc::c_int;\n        while x_0 < width {\n            *f_0\n                .offset(\n                    x_0 as isize,\n                ) = *(*sdf).data.offset((y_1 * width) as isize).offset(x_0 as isize);\n            *pl1_0\n                .offset(\n                    (x_0 * 2 as libc::c_int) as isize,\n                ) = *(*cf).data\n                .offset((2 as libc::c_int * (y_1 * width + x_0)) as isize)\n                .offset(0 as libc::c_int as isize);\n            *pl1_0\n                .offset(\n                    (x_0 * 2 as libc::c_int + 1 as libc::c_int) as isize,\n                ) = *(*cf).data\n                .offset((2 as libc::c_int * (y_1 * width + x_0)) as isize)\n                .offset(1 as libc::c_int as isize);\n            x_0+= 1;\n        }\n        edt_with_payload(f_0, d_0, z_0, w_0, width, pl1_0, pl2_0);\n        let mut x_1 = 0 as libc::c_int;\n        while x_1 < width {\n            *(*sdf).data\n                .offset((y_1 * width) as isize)\n                .offset(x_1 as isize) = *d_0.offset(x_1 as isize);\n            *(*cf).data\n                .offset((2 as libc::c_int * (y_1 * width + x_1)) as isize)\n                .offset(\n                    0 as libc::c_int as isize,\n                ) = *pl2_0.offset((2 as libc::c_int * x_1) as isize);\n            *(*cf).data\n                .offset((2 as libc::c_int * (y_1 * width + x_1)) as isize)\n                .offset(\n                    1 as libc::c_int as isize,\n                ) = *pl2_0.offset((2 as libc::c_int * x_1 + 1 as libc::c_int) as isize);\n            x_1+= 1;\n        }\n        free(pl1_0 as *mut libc::c_void);\n        free(pl2_0 as *mut libc::c_void);\n        y_1+= 1;\n    }\n    free(ff as *mut libc::c_void);\n    free(dd as *mut libc::c_void);\n    free(zz as *mut libc::c_void);\n    free(ww as *mut libc::c_void);\n}","src::src::distance::heman_distance_create_cpcf":"pub unsafe extern \"C\" fn heman_distance_create_cpcf(\n    mut src: *mut heman_image,\n) -> *mut /* owning */ heman_image {\n    let mut negative = crate::src::src::image::heman_image_create((*src).width, (*src).height, 1 as libc::c_int);\n    let mut size = (*src).height * (*src).width;\n    let mut nptr = (*negative).data;\n    let mut sptr = (*src).data;\n    let mut i = 0 as libc::c_int;\n    while i < size {\n        let mut val = 0 as libc::c_int as libc::c_float;\n        let mut b = 0 as libc::c_int;\n        while b < (*src).nbands {\n            let fresh5 = sptr;\n            sptr= sptr.offset(1);\n            val+= (*fresh5);\n            b+= 1;\n        }\n        let fresh6 = nptr;\n        nptr= nptr.offset(1);\n        *fresh6= if val != 0. { 0 as libc::c_int as libc::c_float } else { crate::src::src::distance::INF };\n        i+= 1;\n    }\n    let mut coordfield = heman_distance_identity_cpcf((*src).width, (*src).height);\n    transform_to_coordfield(negative, coordfield);\n    crate::src::src::image::heman_image_destroy(negative);\n    return coordfield;\n}","src::kazmath::aabb3::kmAABB3Centre":"pub unsafe extern \"C\" fn kmAABB3Centre(\n    mut aabb: *const kmAABB3,\n    mut pOut: *mut kmVec3,\n) -> *mut kmVec3 {\n    crate::src::kazmath::vec3::kmVec3Add(pOut, &(*aabb).min, &(*aabb).max);\n    crate::src::kazmath::vec3::kmVec3Scale(pOut, pOut, 0.5f64 as libc::c_float);\n    return pOut;\n}","src::src::noise::open_simplex_noise4":"pub unsafe extern \"C\" fn open_simplex_noise4(\n    mut ctx: *mut osn_context,\n    mut x: libc::c_double,\n    mut y: libc::c_double,\n    mut z: libc::c_double,\n    mut w: libc::c_double,\n) -> libc::c_double {\n    let mut stretchOffset = (x + y + z + w) * -0.138196601125011f64;\n    let mut xs = x + stretchOffset;\n    let mut ys = y + stretchOffset;\n    let mut zs = z + stretchOffset;\n    let mut ws = w + stretchOffset;\n    let mut xsb = fastFloor(xs);\n    let mut ysb = fastFloor(ys);\n    let mut zsb = fastFloor(zs);\n    let mut wsb = fastFloor(ws);\n    let mut squishOffset = (xsb + ysb + zsb + wsb) as libc::c_double\n        * 0.309016994374947f64;\n    let mut xb = xsb as libc::c_double + squishOffset;\n    let mut yb = ysb as libc::c_double + squishOffset;\n    let mut zb = zsb as libc::c_double + squishOffset;\n    let mut wb = wsb as libc::c_double + squishOffset;\n    let mut xins = xs - xsb as libc::c_double;\n    let mut yins = ys - ysb as libc::c_double;\n    let mut zins = zs - zsb as libc::c_double;\n    let mut wins = ws - wsb as libc::c_double;\n    let mut inSum = xins + yins + zins + wins;\n    let mut dx0 = x - xb;\n    let mut dy0 = y - yb;\n    let mut dz0 = z - zb;\n    let mut dw0 = w - wb;\n    let mut dx_ext0: libc::c_double = 0.;\n    let mut dy_ext0: libc::c_double = 0.;\n    let mut dz_ext0: libc::c_double = 0.;\n    let mut dw_ext0: libc::c_double = 0.;\n    let mut dx_ext1: libc::c_double = 0.;\n    let mut dy_ext1: libc::c_double = 0.;\n    let mut dz_ext1: libc::c_double = 0.;\n    let mut dw_ext1: libc::c_double = 0.;\n    let mut dx_ext2: libc::c_double = 0.;\n    let mut dy_ext2: libc::c_double = 0.;\n    let mut dz_ext2: libc::c_double = 0.;\n    let mut dw_ext2: libc::c_double = 0.;\n    let mut xsv_ext0: libc::c_int = 0;\n    let mut ysv_ext0: libc::c_int = 0;\n    let mut zsv_ext0: libc::c_int = 0;\n    let mut wsv_ext0: libc::c_int = 0;\n    let mut xsv_ext1: libc::c_int = 0;\n    let mut ysv_ext1: libc::c_int = 0;\n    let mut zsv_ext1: libc::c_int = 0;\n    let mut wsv_ext1: libc::c_int = 0;\n    let mut xsv_ext2: libc::c_int = 0;\n    let mut ysv_ext2: libc::c_int = 0;\n    let mut zsv_ext2: libc::c_int = 0;\n    let mut wsv_ext2: libc::c_int = 0;\n    let mut value = 0 as libc::c_int as libc::c_double;\n    if inSum <= 1 as libc::c_int as libc::c_double {\n        let mut aPoint = 0x1 as libc::c_int as int8_t;\n        let mut aScore = xins;\n        let mut bPoint = 0x2 as libc::c_int as int8_t;\n        let mut bScore = yins;\n        if aScore >= bScore && zins > bScore {\n            bScore= zins;\n            bPoint= 0x4 as libc::c_int as int8_t;\n        } else if aScore < bScore && zins > aScore {\n            aScore= zins;\n            aPoint= 0x4 as libc::c_int as int8_t;\n        }\n        if aScore >= bScore && wins > bScore {\n            bScore= wins;\n            bPoint= 0x8 as libc::c_int as int8_t;\n        } else if aScore < bScore && wins > aScore {\n            aScore= wins;\n            aPoint= 0x8 as libc::c_int as int8_t;\n        }\n        let mut uins = 1 as libc::c_int as libc::c_double - inSum;\n        if uins > aScore || uins > bScore {\n            let mut c = (if bScore > aScore {\n                bPoint as libc::c_int\n            } else {\n                aPoint as libc::c_int\n            }) as int8_t;\n            if c as libc::c_int & 0x1 as libc::c_int == 0 as libc::c_int {\n                xsv_ext0= xsb - 1 as libc::c_int;\n                xsv_ext2= xsb;\n                xsv_ext1= xsv_ext2;\n                dx_ext0= dx0 + 1 as libc::c_int as libc::c_double;\n                dx_ext2= dx0;\n                dx_ext1= dx_ext2;\n            } else {\n                xsv_ext2= xsb + 1 as libc::c_int;\n                xsv_ext1= xsv_ext2;\n                xsv_ext0= xsv_ext1;\n                dx_ext2= dx0 - 1 as libc::c_int as libc::c_double;\n                dx_ext1= dx_ext2;\n                dx_ext0= dx_ext1;\n            }\n            if c as libc::c_int & 0x2 as libc::c_int == 0 as libc::c_int {\n                ysv_ext2= ysb;\n                ysv_ext1= ysv_ext2;\n                ysv_ext0= ysv_ext1;\n                dy_ext2= dy0;\n                dy_ext1= dy_ext2;\n                dy_ext0= dy_ext1;\n                if c as libc::c_int & 0x1 as libc::c_int == 0x1 as libc::c_int {\n                    ysv_ext0-= 1 as libc::c_int;\n                    dy_ext0+= 1 as libc::c_int as libc::c_double;\n                } else {\n                    ysv_ext1-= 1 as libc::c_int;\n                    dy_ext1+= 1 as libc::c_int as libc::c_double;\n                }\n            } else {\n                ysv_ext2= ysb + 1 as libc::c_int;\n                ysv_ext1= ysv_ext2;\n                ysv_ext0= ysv_ext1;\n                dy_ext2= dy0 - 1 as libc::c_int as libc::c_double;\n                dy_ext1= dy_ext2;\n                dy_ext0= dy_ext1;\n            }\n            if c as libc::c_int & 0x4 as libc::c_int == 0 as libc::c_int {\n                zsv_ext2= zsb;\n                zsv_ext1= zsv_ext2;\n                zsv_ext0= zsv_ext1;\n                dz_ext2= dz0;\n                dz_ext1= dz_ext2;\n                dz_ext0= dz_ext1;\n                if c as libc::c_int & 0x3 as libc::c_int != 0 as libc::c_int {\n                    if c as libc::c_int & 0x3 as libc::c_int == 0x3 as libc::c_int {\n                        zsv_ext0-= 1 as libc::c_int;\n                        dz_ext0+= 1 as libc::c_int as libc::c_double;\n                    } else {\n                        zsv_ext1-= 1 as libc::c_int;\n                        dz_ext1+= 1 as libc::c_int as libc::c_double;\n                    }\n                } else {\n                    zsv_ext2-= 1 as libc::c_int;\n                    dz_ext2+= 1 as libc::c_int as libc::c_double;\n                }\n            } else {\n                zsv_ext2= zsb + 1 as libc::c_int;\n                zsv_ext1= zsv_ext2;\n                zsv_ext0= zsv_ext1;\n                dz_ext2= dz0 - 1 as libc::c_int as libc::c_double;\n                dz_ext1= dz_ext2;\n                dz_ext0= dz_ext1;\n            }\n            if c as libc::c_int & 0x8 as libc::c_int == 0 as libc::c_int {\n                wsv_ext1= wsb;\n                wsv_ext0= wsv_ext1;\n                wsv_ext2= wsb - 1 as libc::c_int;\n                dw_ext1= dw0;\n                dw_ext0= dw_ext1;\n                dw_ext2= dw0 + 1 as libc::c_int as libc::c_double;\n            } else {\n                wsv_ext2= wsb + 1 as libc::c_int;\n                wsv_ext1= wsv_ext2;\n                wsv_ext0= wsv_ext1;\n                dw_ext2= dw0 - 1 as libc::c_int as libc::c_double;\n                dw_ext1= dw_ext2;\n                dw_ext0= dw_ext1;\n            }\n        } else {\n            let mut c_0 = (aPoint as libc::c_int | bPoint as libc::c_int) as int8_t;\n            if c_0 as libc::c_int & 0x1 as libc::c_int == 0 as libc::c_int {\n                xsv_ext2= xsb;\n                xsv_ext0= xsv_ext2;\n                xsv_ext1= xsb - 1 as libc::c_int;\n                dx_ext0= dx0\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dx_ext1= dx0 + 1 as libc::c_int as libc::c_double\n                    - 0.309016994374947f64;\n                dx_ext2= dx0 - 0.309016994374947f64;\n            } else {\n                xsv_ext2= xsb + 1 as libc::c_int;\n                xsv_ext1= xsv_ext2;\n                xsv_ext0= xsv_ext1;\n                dx_ext0= dx0 - 1 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dx_ext2= dx0 - 1 as libc::c_int as libc::c_double\n                    - 0.309016994374947f64;\n                dx_ext1= dx_ext2;\n            }\n            if c_0 as libc::c_int & 0x2 as libc::c_int == 0 as libc::c_int {\n                ysv_ext2= ysb;\n                ysv_ext1= ysv_ext2;\n                ysv_ext0= ysv_ext1;\n                dy_ext0= dy0\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dy_ext2= dy0 - 0.309016994374947f64;\n                dy_ext1= dy_ext2;\n                if c_0 as libc::c_int & 0x1 as libc::c_int == 0x1 as libc::c_int {\n                    ysv_ext1-= 1 as libc::c_int;\n                    dy_ext1+= 1 as libc::c_int as libc::c_double;\n                } else {\n                    ysv_ext2-= 1 as libc::c_int;\n                    dy_ext2+= 1 as libc::c_int as libc::c_double;\n                }\n            } else {\n                ysv_ext2= ysb + 1 as libc::c_int;\n                ysv_ext1= ysv_ext2;\n                ysv_ext0= ysv_ext1;\n                dy_ext0= dy0 - 1 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dy_ext2= dy0 - 1 as libc::c_int as libc::c_double\n                    - 0.309016994374947f64;\n                dy_ext1= dy_ext2;\n            }\n            if c_0 as libc::c_int & 0x4 as libc::c_int == 0 as libc::c_int {\n                zsv_ext2= zsb;\n                zsv_ext1= zsv_ext2;\n                zsv_ext0= zsv_ext1;\n                dz_ext0= dz0\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dz_ext2= dz0 - 0.309016994374947f64;\n                dz_ext1= dz_ext2;\n                if c_0 as libc::c_int & 0x3 as libc::c_int == 0x3 as libc::c_int {\n                    zsv_ext1-= 1 as libc::c_int;\n                    dz_ext1+= 1 as libc::c_int as libc::c_double;\n                } else {\n                    zsv_ext2-= 1 as libc::c_int;\n                    dz_ext2+= 1 as libc::c_int as libc::c_double;\n                }\n            } else {\n                zsv_ext2= zsb + 1 as libc::c_int;\n                zsv_ext1= zsv_ext2;\n                zsv_ext0= zsv_ext1;\n                dz_ext0= dz0 - 1 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dz_ext2= dz0 - 1 as libc::c_int as libc::c_double\n                    - 0.309016994374947f64;\n                dz_ext1= dz_ext2;\n            }\n            if c_0 as libc::c_int & 0x8 as libc::c_int == 0 as libc::c_int {\n                wsv_ext1= wsb;\n                wsv_ext0= wsv_ext1;\n                wsv_ext2= wsb - 1 as libc::c_int;\n                dw_ext0= dw0\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dw_ext1= dw0 - 0.309016994374947f64;\n                dw_ext2= dw0 + 1 as libc::c_int as libc::c_double\n                    - 0.309016994374947f64;\n            } else {\n                wsv_ext2= wsb + 1 as libc::c_int;\n                wsv_ext1= wsv_ext2;\n                wsv_ext0= wsv_ext1;\n                dw_ext0= dw0 - 1 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dw_ext2= dw0 - 1 as libc::c_int as libc::c_double\n                    - 0.309016994374947f64;\n                dw_ext1= dw_ext2;\n            }\n        }\n        let mut attn0 = 2 as libc::c_int as libc::c_double - dx0 * dx0 - dy0 * dy0\n            - dz0 * dz0 - dw0 * dw0;\n        if attn0 > 0 as libc::c_int as libc::c_double {\n            attn0*= attn0;\n            value+= attn0 * attn0\n                    * extrapolate4(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        wsb + 0 as libc::c_int,\n                        dx0,\n                        dy0,\n                        dz0,\n                        dw0,\n                    );\n        }\n        let mut dx1 = dx0 - 1 as libc::c_int as libc::c_double - 0.309016994374947f64;\n        let mut dy1 = dy0 - 0 as libc::c_int as libc::c_double - 0.309016994374947f64;\n        let mut dz1 = dz0 - 0 as libc::c_int as libc::c_double - 0.309016994374947f64;\n        let mut dw1 = dw0 - 0 as libc::c_int as libc::c_double - 0.309016994374947f64;\n        let mut attn1 = 2 as libc::c_int as libc::c_double - dx1 * dx1 - dy1 * dy1\n            - dz1 * dz1 - dw1 * dw1;\n        if attn1 > 0 as libc::c_int as libc::c_double {\n            attn1*= attn1;\n            value+= attn1 * attn1\n                    * extrapolate4(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        wsb + 0 as libc::c_int,\n                        dx1,\n                        dy1,\n                        dz1,\n                        dw1,\n                    );\n        }\n        let mut dx2 = dx0 - 0 as libc::c_int as libc::c_double - 0.309016994374947f64;\n        let mut dy2 = dy0 - 1 as libc::c_int as libc::c_double - 0.309016994374947f64;\n        let mut dz2 = dz1;\n        let mut dw2 = dw1;\n        let mut attn2 = 2 as libc::c_int as libc::c_double - dx2 * dx2 - dy2 * dy2\n            - dz2 * dz2 - dw2 * dw2;\n        if attn2 > 0 as libc::c_int as libc::c_double {\n            attn2*= attn2;\n            value+= attn2 * attn2\n                    * extrapolate4(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        wsb + 0 as libc::c_int,\n                        dx2,\n                        dy2,\n                        dz2,\n                        dw2,\n                    );\n        }\n        let mut dx3 = dx2;\n        let mut dy3 = dy1;\n        let mut dz3 = dz0 - 1 as libc::c_int as libc::c_double - 0.309016994374947f64;\n        let mut dw3 = dw1;\n        let mut attn3 = 2 as libc::c_int as libc::c_double - dx3 * dx3 - dy3 * dy3\n            - dz3 * dz3 - dw3 * dw3;\n        if attn3 > 0 as libc::c_int as libc::c_double {\n            attn3*= attn3;\n            value+= attn3 * attn3\n                    * extrapolate4(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        wsb + 0 as libc::c_int,\n                        dx3,\n                        dy3,\n                        dz3,\n                        dw3,\n                    );\n        }\n        let mut dx4 = dx2;\n        let mut dy4 = dy1;\n        let mut dz4 = dz1;\n        let mut dw4 = dw0 - 1 as libc::c_int as libc::c_double - 0.309016994374947f64;\n        let mut attn4 = 2 as libc::c_int as libc::c_double - dx4 * dx4 - dy4 * dy4\n            - dz4 * dz4 - dw4 * dw4;\n        if attn4 > 0 as libc::c_int as libc::c_double {\n            attn4*= attn4;\n            value+= attn4 * attn4\n                    * extrapolate4(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        wsb + 1 as libc::c_int,\n                        dx4,\n                        dy4,\n                        dz4,\n                        dw4,\n                    );\n        }\n    } else if inSum >= 3 as libc::c_int as libc::c_double {\n        let mut aPoint_0 = 0xe as libc::c_int as int8_t;\n        let mut aScore_0 = xins;\n        let mut bPoint_0 = 0xd as libc::c_int as int8_t;\n        let mut bScore_0 = yins;\n        if aScore_0 <= bScore_0 && zins < bScore_0 {\n            bScore_0= zins;\n            bPoint_0= 0xb as libc::c_int as int8_t;\n        } else if aScore_0 > bScore_0 && zins < aScore_0 {\n            aScore_0= zins;\n            aPoint_0= 0xb as libc::c_int as int8_t;\n        }\n        if aScore_0 <= bScore_0 && wins < bScore_0 {\n            bScore_0= wins;\n            bPoint_0= 0x7 as libc::c_int as int8_t;\n        } else if aScore_0 > bScore_0 && wins < aScore_0 {\n            aScore_0= wins;\n            aPoint_0= 0x7 as libc::c_int as int8_t;\n        }\n        let mut uins_0 = 4 as libc::c_int as libc::c_double - inSum;\n        if uins_0 < aScore_0 || uins_0 < bScore_0 {\n            let mut c_1 = (if bScore_0 < aScore_0 {\n                bPoint_0 as libc::c_int\n            } else {\n                aPoint_0 as libc::c_int\n            }) as int8_t;\n            if c_1 as libc::c_int & 0x1 as libc::c_int != 0 as libc::c_int {\n                xsv_ext0= xsb + 2 as libc::c_int;\n                xsv_ext2= xsb + 1 as libc::c_int;\n                xsv_ext1= xsv_ext2;\n                dx_ext0= dx0 - 2 as libc::c_int as libc::c_double\n                    - 4 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dx_ext2= dx0 - 1 as libc::c_int as libc::c_double\n                    - 4 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dx_ext1= dx_ext2;\n            } else {\n                xsv_ext2= xsb;\n                xsv_ext1= xsv_ext2;\n                xsv_ext0= xsv_ext1;\n                dx_ext2= dx0\n                    - 4 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dx_ext1= dx_ext2;\n                dx_ext0= dx_ext1;\n            }\n            if c_1 as libc::c_int & 0x2 as libc::c_int != 0 as libc::c_int {\n                ysv_ext2= ysb + 1 as libc::c_int;\n                ysv_ext1= ysv_ext2;\n                ysv_ext0= ysv_ext1;\n                dy_ext2= dy0 - 1 as libc::c_int as libc::c_double\n                    - 4 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dy_ext1= dy_ext2;\n                dy_ext0= dy_ext1;\n                if c_1 as libc::c_int & 0x1 as libc::c_int != 0 as libc::c_int {\n                    ysv_ext1+= 1 as libc::c_int;\n                    dy_ext1-= 1 as libc::c_int as libc::c_double;\n                } else {\n                    ysv_ext0+= 1 as libc::c_int;\n                    dy_ext0-= 1 as libc::c_int as libc::c_double;\n                }\n            } else {\n                ysv_ext2= ysb;\n                ysv_ext1= ysv_ext2;\n                ysv_ext0= ysv_ext1;\n                dy_ext2= dy0\n                    - 4 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dy_ext1= dy_ext2;\n                dy_ext0= dy_ext1;\n            }\n            if c_1 as libc::c_int & 0x4 as libc::c_int != 0 as libc::c_int {\n                zsv_ext2= zsb + 1 as libc::c_int;\n                zsv_ext1= zsv_ext2;\n                zsv_ext0= zsv_ext1;\n                dz_ext2= dz0 - 1 as libc::c_int as libc::c_double\n                    - 4 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dz_ext1= dz_ext2;\n                dz_ext0= dz_ext1;\n                if c_1 as libc::c_int & 0x3 as libc::c_int != 0x3 as libc::c_int {\n                    if c_1 as libc::c_int & 0x3 as libc::c_int == 0 as libc::c_int {\n                        zsv_ext0+= 1 as libc::c_int;\n                        dz_ext0-= 1 as libc::c_int as libc::c_double;\n                    } else {\n                        zsv_ext1+= 1 as libc::c_int;\n                        dz_ext1-= 1 as libc::c_int as libc::c_double;\n                    }\n                } else {\n                    zsv_ext2+= 1 as libc::c_int;\n                    dz_ext2-= 1 as libc::c_int as libc::c_double;\n                }\n            } else {\n                zsv_ext2= zsb;\n                zsv_ext1= zsv_ext2;\n                zsv_ext0= zsv_ext1;\n                dz_ext2= dz0\n                    - 4 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dz_ext1= dz_ext2;\n                dz_ext0= dz_ext1;\n            }\n            if c_1 as libc::c_int & 0x8 as libc::c_int != 0 as libc::c_int {\n                wsv_ext1= wsb + 1 as libc::c_int;\n                wsv_ext0= wsv_ext1;\n                wsv_ext2= wsb + 2 as libc::c_int;\n                dw_ext1= dw0 - 1 as libc::c_int as libc::c_double\n                    - 4 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dw_ext0= dw_ext1;\n                dw_ext2= dw0 - 2 as libc::c_int as libc::c_double\n                    - 4 as libc::c_int as libc::c_double * 0.309016994374947f64;\n            } else {\n                wsv_ext2= wsb;\n                wsv_ext1= wsv_ext2;\n                wsv_ext0= wsv_ext1;\n                dw_ext2= dw0\n                    - 4 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dw_ext1= dw_ext2;\n                dw_ext0= dw_ext1;\n            }\n        } else {\n            let mut c_2 = (aPoint_0 as libc::c_int & bPoint_0 as libc::c_int) as int8_t;\n            if c_2 as libc::c_int & 0x1 as libc::c_int != 0 as libc::c_int {\n                xsv_ext2= xsb + 1 as libc::c_int;\n                xsv_ext0= xsv_ext2;\n                xsv_ext1= xsb + 2 as libc::c_int;\n                dx_ext0= dx0 - 1 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dx_ext1= dx0 - 2 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dx_ext2= dx0 - 1 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n            } else {\n                xsv_ext2= xsb;\n                xsv_ext1= xsv_ext2;\n                xsv_ext0= xsv_ext1;\n                dx_ext0= dx0\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dx_ext2= dx0\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dx_ext1= dx_ext2;\n            }\n            if c_2 as libc::c_int & 0x2 as libc::c_int != 0 as libc::c_int {\n                ysv_ext2= ysb + 1 as libc::c_int;\n                ysv_ext1= ysv_ext2;\n                ysv_ext0= ysv_ext1;\n                dy_ext0= dy0 - 1 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dy_ext2= dy0 - 1 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dy_ext1= dy_ext2;\n                if c_2 as libc::c_int & 0x1 as libc::c_int != 0 as libc::c_int {\n                    ysv_ext2+= 1 as libc::c_int;\n                    dy_ext2-= 1 as libc::c_int as libc::c_double;\n                } else {\n                    ysv_ext1+= 1 as libc::c_int;\n                    dy_ext1-= 1 as libc::c_int as libc::c_double;\n                }\n            } else {\n                ysv_ext2= ysb;\n                ysv_ext1= ysv_ext2;\n                ysv_ext0= ysv_ext1;\n                dy_ext0= dy0\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dy_ext2= dy0\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dy_ext1= dy_ext2;\n            }\n            if c_2 as libc::c_int & 0x4 as libc::c_int != 0 as libc::c_int {\n                zsv_ext2= zsb + 1 as libc::c_int;\n                zsv_ext1= zsv_ext2;\n                zsv_ext0= zsv_ext1;\n                dz_ext0= dz0 - 1 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dz_ext2= dz0 - 1 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dz_ext1= dz_ext2;\n                if c_2 as libc::c_int & 0x3 as libc::c_int != 0 as libc::c_int {\n                    zsv_ext2+= 1 as libc::c_int;\n                    dz_ext2-= 1 as libc::c_int as libc::c_double;\n                } else {\n                    zsv_ext1+= 1 as libc::c_int;\n                    dz_ext1-= 1 as libc::c_int as libc::c_double;\n                }\n            } else {\n                zsv_ext2= zsb;\n                zsv_ext1= zsv_ext2;\n                zsv_ext0= zsv_ext1;\n                dz_ext0= dz0\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dz_ext2= dz0\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dz_ext1= dz_ext2;\n            }\n            if c_2 as libc::c_int & 0x8 as libc::c_int != 0 as libc::c_int {\n                wsv_ext1= wsb + 1 as libc::c_int;\n                wsv_ext0= wsv_ext1;\n                wsv_ext2= wsb + 2 as libc::c_int;\n                dw_ext0= dw0 - 1 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dw_ext1= dw0 - 1 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dw_ext2= dw0 - 2 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n            } else {\n                wsv_ext2= wsb;\n                wsv_ext1= wsv_ext2;\n                wsv_ext0= wsv_ext1;\n                dw_ext0= dw0\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dw_ext2= dw0\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dw_ext1= dw_ext2;\n            }\n        }\n        let mut dx4_0 = dx0 - 1 as libc::c_int as libc::c_double\n            - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dy4_0 = dy0 - 1 as libc::c_int as libc::c_double\n            - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dz4_0 = dz0 - 1 as libc::c_int as libc::c_double\n            - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dw4_0 = dw0 - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut attn4_0 = 2 as libc::c_int as libc::c_double - dx4_0 * dx4_0\n            - dy4_0 * dy4_0 - dz4_0 * dz4_0 - dw4_0 * dw4_0;\n        if attn4_0 > 0 as libc::c_int as libc::c_double {\n            attn4_0*= attn4_0;\n            value+= attn4_0 * attn4_0\n                    * extrapolate4(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        wsb + 0 as libc::c_int,\n                        dx4_0,\n                        dy4_0,\n                        dz4_0,\n                        dw4_0,\n                    );\n        }\n        let mut dx3_0 = dx4_0;\n        let mut dy3_0 = dy4_0;\n        let mut dz3_0 = dz0 - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dw3_0 = dw0 - 1 as libc::c_int as libc::c_double\n            - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut attn3_0 = 2 as libc::c_int as libc::c_double - dx3_0 * dx3_0\n            - dy3_0 * dy3_0 - dz3_0 * dz3_0 - dw3_0 * dw3_0;\n        if attn3_0 > 0 as libc::c_int as libc::c_double {\n            attn3_0*= attn3_0;\n            value+= attn3_0 * attn3_0\n                    * extrapolate4(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        wsb + 1 as libc::c_int,\n                        dx3_0,\n                        dy3_0,\n                        dz3_0,\n                        dw3_0,\n                    );\n        }\n        let mut dx2_0 = dx4_0;\n        let mut dy2_0 = dy0 - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dz2_0 = dz4_0;\n        let mut dw2_0 = dw3_0;\n        let mut attn2_0 = 2 as libc::c_int as libc::c_double - dx2_0 * dx2_0\n            - dy2_0 * dy2_0 - dz2_0 * dz2_0 - dw2_0 * dw2_0;\n        if attn2_0 > 0 as libc::c_int as libc::c_double {\n            attn2_0*= attn2_0;\n            value+= attn2_0 * attn2_0\n                    * extrapolate4(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        wsb + 1 as libc::c_int,\n                        dx2_0,\n                        dy2_0,\n                        dz2_0,\n                        dw2_0,\n                    );\n        }\n        let mut dx1_0 = dx0 - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dz1_0 = dz4_0;\n        let mut dy1_0 = dy4_0;\n        let mut dw1_0 = dw3_0;\n        let mut attn1_0 = 2 as libc::c_int as libc::c_double - dx1_0 * dx1_0\n            - dy1_0 * dy1_0 - dz1_0 * dz1_0 - dw1_0 * dw1_0;\n        if attn1_0 > 0 as libc::c_int as libc::c_double {\n            attn1_0*= attn1_0;\n            value+= attn1_0 * attn1_0\n                    * extrapolate4(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        wsb + 1 as libc::c_int,\n                        dx1_0,\n                        dy1_0,\n                        dz1_0,\n                        dw1_0,\n                    );\n        }\n        dx0= dx0 - 1 as libc::c_int as libc::c_double\n            - 4 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        dy0= dy0 - 1 as libc::c_int as libc::c_double\n            - 4 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        dz0= dz0 - 1 as libc::c_int as libc::c_double\n            - 4 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        dw0= dw0 - 1 as libc::c_int as libc::c_double\n            - 4 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut attn0_0 = 2 as libc::c_int as libc::c_double - dx0 * dx0 - dy0 * dy0\n            - dz0 * dz0 - dw0 * dw0;\n        if attn0_0 > 0 as libc::c_int as libc::c_double {\n            attn0_0*= attn0_0;\n            value+= attn0_0 * attn0_0\n                    * extrapolate4(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        wsb + 1 as libc::c_int,\n                        dx0,\n                        dy0,\n                        dz0,\n                        dw0,\n                    );\n        }\n    } else if inSum <= 2 as libc::c_int as libc::c_double {\n        let mut aScore_1: libc::c_double = 0.;\n        let mut aPoint_1: int8_t = 0;\n        let mut aIsBiggerSide = 1 as libc::c_int;\n        let mut bScore_1: libc::c_double = 0.;\n        let mut bPoint_1: int8_t = 0;\n        let mut bIsBiggerSide = 1 as libc::c_int;\n        if xins + yins > zins + wins {\n            aScore_1= xins + yins;\n            aPoint_1= 0x3 as libc::c_int as int8_t;\n        } else {\n            aScore_1= zins + wins;\n            aPoint_1= 0xc as libc::c_int as int8_t;\n        }\n        if xins + zins > yins + wins {\n            bScore_1= xins + zins;\n            bPoint_1= 0x5 as libc::c_int as int8_t;\n        } else {\n            bScore_1= yins + wins;\n            bPoint_1= 0xa as libc::c_int as int8_t;\n        }\n        if xins + wins > yins + zins {\n            let mut score = xins + wins;\n            if aScore_1 >= bScore_1 && score > bScore_1 {\n                bScore_1= score;\n                bPoint_1= 0x9 as libc::c_int as int8_t;\n            } else if aScore_1 < bScore_1 && score > aScore_1 {\n                aScore_1= score;\n                aPoint_1= 0x9 as libc::c_int as int8_t;\n            }\n        } else {\n            let mut score_0 = yins + zins;\n            if aScore_1 >= bScore_1 && score_0 > bScore_1 {\n                bScore_1= score_0;\n                bPoint_1= 0x6 as libc::c_int as int8_t;\n            } else if aScore_1 < bScore_1 && score_0 > aScore_1 {\n                aScore_1= score_0;\n                aPoint_1= 0x6 as libc::c_int as int8_t;\n            }\n        }\n        let mut p1 = 2 as libc::c_int as libc::c_double - inSum + xins;\n        if aScore_1 >= bScore_1 && p1 > bScore_1 {\n            bScore_1= p1;\n            bPoint_1= 0x1 as libc::c_int as int8_t;\n            bIsBiggerSide= 0 as libc::c_int;\n        } else if aScore_1 < bScore_1 && p1 > aScore_1 {\n            aScore_1= p1;\n            aPoint_1= 0x1 as libc::c_int as int8_t;\n            aIsBiggerSide= 0 as libc::c_int;\n        }\n        let mut p2 = 2 as libc::c_int as libc::c_double - inSum + yins;\n        if aScore_1 >= bScore_1 && p2 > bScore_1 {\n            bScore_1= p2;\n            bPoint_1= 0x2 as libc::c_int as int8_t;\n            bIsBiggerSide= 0 as libc::c_int;\n        } else if aScore_1 < bScore_1 && p2 > aScore_1 {\n            aScore_1= p2;\n            aPoint_1= 0x2 as libc::c_int as int8_t;\n            aIsBiggerSide= 0 as libc::c_int;\n        }\n        let mut p3 = 2 as libc::c_int as libc::c_double - inSum + zins;\n        if aScore_1 >= bScore_1 && p3 > bScore_1 {\n            bScore_1= p3;\n            bPoint_1= 0x4 as libc::c_int as int8_t;\n            bIsBiggerSide= 0 as libc::c_int;\n        } else if aScore_1 < bScore_1 && p3 > aScore_1 {\n            aScore_1= p3;\n            aPoint_1= 0x4 as libc::c_int as int8_t;\n            aIsBiggerSide= 0 as libc::c_int;\n        }\n        let mut p4 = 2 as libc::c_int as libc::c_double - inSum + wins;\n        if aScore_1 >= bScore_1 && p4 > bScore_1 {\n            bScore_1= p4;\n            bPoint_1= 0x8 as libc::c_int as int8_t;\n            bIsBiggerSide= 0 as libc::c_int;\n        } else if aScore_1 < bScore_1 && p4 > aScore_1 {\n            aScore_1= p4;\n            aPoint_1= 0x8 as libc::c_int as int8_t;\n            aIsBiggerSide= 0 as libc::c_int;\n        }\n        if aIsBiggerSide == bIsBiggerSide {\n            if aIsBiggerSide != 0 {\n                let mut c1 = (aPoint_1 as libc::c_int | bPoint_1 as libc::c_int)\n                    as int8_t;\n                let mut c2 = (aPoint_1 as libc::c_int & bPoint_1 as libc::c_int)\n                    as int8_t;\n                if c1 as libc::c_int & 0x1 as libc::c_int == 0 as libc::c_int {\n                    xsv_ext0= xsb;\n                    xsv_ext1= xsb - 1 as libc::c_int;\n                    dx_ext0= dx0\n                        - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                    dx_ext1= dx0 + 1 as libc::c_int as libc::c_double\n                        - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                } else {\n                    xsv_ext1= xsb + 1 as libc::c_int;\n                    xsv_ext0= xsv_ext1;\n                    dx_ext0= dx0 - 1 as libc::c_int as libc::c_double\n                        - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                    dx_ext1= dx0 - 1 as libc::c_int as libc::c_double\n                        - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                }\n                if c1 as libc::c_int & 0x2 as libc::c_int == 0 as libc::c_int {\n                    ysv_ext0= ysb;\n                    ysv_ext1= ysb - 1 as libc::c_int;\n                    dy_ext0= dy0\n                        - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                    dy_ext1= dy0 + 1 as libc::c_int as libc::c_double\n                        - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                } else {\n                    ysv_ext1= ysb + 1 as libc::c_int;\n                    ysv_ext0= ysv_ext1;\n                    dy_ext0= dy0 - 1 as libc::c_int as libc::c_double\n                        - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                    dy_ext1= dy0 - 1 as libc::c_int as libc::c_double\n                        - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                }\n                if c1 as libc::c_int & 0x4 as libc::c_int == 0 as libc::c_int {\n                    zsv_ext0= zsb;\n                    zsv_ext1= zsb - 1 as libc::c_int;\n                    dz_ext0= dz0\n                        - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                    dz_ext1= dz0 + 1 as libc::c_int as libc::c_double\n                        - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                } else {\n                    zsv_ext1= zsb + 1 as libc::c_int;\n                    zsv_ext0= zsv_ext1;\n                    dz_ext0= dz0 - 1 as libc::c_int as libc::c_double\n                        - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                    dz_ext1= dz0 - 1 as libc::c_int as libc::c_double\n                        - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                }\n                if c1 as libc::c_int & 0x8 as libc::c_int == 0 as libc::c_int {\n                    wsv_ext0= wsb;\n                    wsv_ext1= wsb - 1 as libc::c_int;\n                    dw_ext0= dw0\n                        - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                    dw_ext1= dw0 + 1 as libc::c_int as libc::c_double\n                        - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                } else {\n                    wsv_ext1= wsb + 1 as libc::c_int;\n                    wsv_ext0= wsv_ext1;\n                    dw_ext0= dw0 - 1 as libc::c_int as libc::c_double\n                        - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                    dw_ext1= dw0 - 1 as libc::c_int as libc::c_double\n                        - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                }\n                xsv_ext2= xsb;\n                ysv_ext2= ysb;\n                zsv_ext2= zsb;\n                wsv_ext2= wsb;\n                dx_ext2= dx0\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dy_ext2= dy0\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dz_ext2= dz0\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dw_ext2= dw0\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                if c2 as libc::c_int & 0x1 as libc::c_int != 0 as libc::c_int {\n                    xsv_ext2+= 2 as libc::c_int;\n                    dx_ext2-= 2 as libc::c_int as libc::c_double;\n                } else if c2 as libc::c_int & 0x2 as libc::c_int != 0 as libc::c_int {\n                    ysv_ext2+= 2 as libc::c_int;\n                    dy_ext2-= 2 as libc::c_int as libc::c_double;\n                } else if c2 as libc::c_int & 0x4 as libc::c_int != 0 as libc::c_int {\n                    zsv_ext2+= 2 as libc::c_int;\n                    dz_ext2-= 2 as libc::c_int as libc::c_double;\n                } else {\n                    wsv_ext2+= 2 as libc::c_int;\n                    dw_ext2-= 2 as libc::c_int as libc::c_double;\n                }\n            } else {\n                xsv_ext2= xsb;\n                ysv_ext2= ysb;\n                zsv_ext2= zsb;\n                wsv_ext2= wsb;\n                dx_ext2= dx0;\n                dy_ext2= dy0;\n                dz_ext2= dz0;\n                dw_ext2= dw0;\n                let mut c_3 = (aPoint_1 as libc::c_int | bPoint_1 as libc::c_int)\n                    as int8_t;\n                if c_3 as libc::c_int & 0x1 as libc::c_int == 0 as libc::c_int {\n                    xsv_ext0= xsb - 1 as libc::c_int;\n                    xsv_ext1= xsb;\n                    dx_ext0= dx0 + 1 as libc::c_int as libc::c_double\n                        - 0.309016994374947f64;\n                    dx_ext1= dx0 - 0.309016994374947f64;\n                } else {\n                    xsv_ext1= xsb + 1 as libc::c_int;\n                    xsv_ext0= xsv_ext1;\n                    dx_ext1= dx0 - 1 as libc::c_int as libc::c_double\n                        - 0.309016994374947f64;\n                    dx_ext0= dx_ext1;\n                }\n                if c_3 as libc::c_int & 0x2 as libc::c_int == 0 as libc::c_int {\n                    ysv_ext1= ysb;\n                    ysv_ext0= ysv_ext1;\n                    dy_ext1= dy0 - 0.309016994374947f64;\n                    dy_ext0= dy_ext1;\n                    if c_3 as libc::c_int & 0x1 as libc::c_int == 0x1 as libc::c_int {\n                        ysv_ext0-= 1 as libc::c_int;\n                        dy_ext0+= 1 as libc::c_int as libc::c_double;\n                    } else {\n                        ysv_ext1-= 1 as libc::c_int;\n                        dy_ext1+= 1 as libc::c_int as libc::c_double;\n                    }\n                } else {\n                    ysv_ext1= ysb + 1 as libc::c_int;\n                    ysv_ext0= ysv_ext1;\n                    dy_ext1= dy0 - 1 as libc::c_int as libc::c_double\n                        - 0.309016994374947f64;\n                    dy_ext0= dy_ext1;\n                }\n                if c_3 as libc::c_int & 0x4 as libc::c_int == 0 as libc::c_int {\n                    zsv_ext1= zsb;\n                    zsv_ext0= zsv_ext1;\n                    dz_ext1= dz0 - 0.309016994374947f64;\n                    dz_ext0= dz_ext1;\n                    if c_3 as libc::c_int & 0x3 as libc::c_int == 0x3 as libc::c_int {\n                        zsv_ext0-= 1 as libc::c_int;\n                        dz_ext0+= 1 as libc::c_int as libc::c_double;\n                    } else {\n                        zsv_ext1-= 1 as libc::c_int;\n                        dz_ext1+= 1 as libc::c_int as libc::c_double;\n                    }\n                } else {\n                    zsv_ext1= zsb + 1 as libc::c_int;\n                    zsv_ext0= zsv_ext1;\n                    dz_ext1= dz0 - 1 as libc::c_int as libc::c_double\n                        - 0.309016994374947f64;\n                    dz_ext0= dz_ext1;\n                }\n                if c_3 as libc::c_int & 0x8 as libc::c_int == 0 as libc::c_int {\n                    wsv_ext0= wsb;\n                    wsv_ext1= wsb - 1 as libc::c_int;\n                    dw_ext0= dw0 - 0.309016994374947f64;\n                    dw_ext1= dw0 + 1 as libc::c_int as libc::c_double\n                        - 0.309016994374947f64;\n                } else {\n                    wsv_ext1= wsb + 1 as libc::c_int;\n                    wsv_ext0= wsv_ext1;\n                    dw_ext1= dw0 - 1 as libc::c_int as libc::c_double\n                        - 0.309016994374947f64;\n                    dw_ext0= dw_ext1;\n                }\n            }\n        } else {\n            let mut c1_0: int8_t = 0;\n            let mut c2_0: int8_t = 0;\n            if aIsBiggerSide != 0 {\n                c1_0= aPoint_1;\n                c2_0= bPoint_1;\n            } else {\n                c1_0= bPoint_1;\n                c2_0= aPoint_1;\n            }\n            if c1_0 as libc::c_int & 0x1 as libc::c_int == 0 as libc::c_int {\n                xsv_ext0= xsb - 1 as libc::c_int;\n                xsv_ext1= xsb;\n                dx_ext0= dx0 + 1 as libc::c_int as libc::c_double\n                    - 0.309016994374947f64;\n                dx_ext1= dx0 - 0.309016994374947f64;\n            } else {\n                xsv_ext1= xsb + 1 as libc::c_int;\n                xsv_ext0= xsv_ext1;\n                dx_ext1= dx0 - 1 as libc::c_int as libc::c_double\n                    - 0.309016994374947f64;\n                dx_ext0= dx_ext1;\n            }\n            if c1_0 as libc::c_int & 0x2 as libc::c_int == 0 as libc::c_int {\n                ysv_ext1= ysb;\n                ysv_ext0= ysv_ext1;\n                dy_ext1= dy0 - 0.309016994374947f64;\n                dy_ext0= dy_ext1;\n                if c1_0 as libc::c_int & 0x1 as libc::c_int == 0x1 as libc::c_int {\n                    ysv_ext0-= 1 as libc::c_int;\n                    dy_ext0+= 1 as libc::c_int as libc::c_double;\n                } else {\n                    ysv_ext1-= 1 as libc::c_int;\n                    dy_ext1+= 1 as libc::c_int as libc::c_double;\n                }\n            } else {\n                ysv_ext1= ysb + 1 as libc::c_int;\n                ysv_ext0= ysv_ext1;\n                dy_ext1= dy0 - 1 as libc::c_int as libc::c_double\n                    - 0.309016994374947f64;\n                dy_ext0= dy_ext1;\n            }\n            if c1_0 as libc::c_int & 0x4 as libc::c_int == 0 as libc::c_int {\n                zsv_ext1= zsb;\n                zsv_ext0= zsv_ext1;\n                dz_ext1= dz0 - 0.309016994374947f64;\n                dz_ext0= dz_ext1;\n                if c1_0 as libc::c_int & 0x3 as libc::c_int == 0x3 as libc::c_int {\n                    zsv_ext0-= 1 as libc::c_int;\n                    dz_ext0+= 1 as libc::c_int as libc::c_double;\n                } else {\n                    zsv_ext1-= 1 as libc::c_int;\n                    dz_ext1+= 1 as libc::c_int as libc::c_double;\n                }\n            } else {\n                zsv_ext1= zsb + 1 as libc::c_int;\n                zsv_ext0= zsv_ext1;\n                dz_ext1= dz0 - 1 as libc::c_int as libc::c_double\n                    - 0.309016994374947f64;\n                dz_ext0= dz_ext1;\n            }\n            if c1_0 as libc::c_int & 0x8 as libc::c_int == 0 as libc::c_int {\n                wsv_ext0= wsb;\n                wsv_ext1= wsb - 1 as libc::c_int;\n                dw_ext0= dw0 - 0.309016994374947f64;\n                dw_ext1= dw0 + 1 as libc::c_int as libc::c_double\n                    - 0.309016994374947f64;\n            } else {\n                wsv_ext1= wsb + 1 as libc::c_int;\n                wsv_ext0= wsv_ext1;\n                dw_ext1= dw0 - 1 as libc::c_int as libc::c_double\n                    - 0.309016994374947f64;\n                dw_ext0= dw_ext1;\n            }\n            xsv_ext2= xsb;\n            ysv_ext2= ysb;\n            zsv_ext2= zsb;\n            wsv_ext2= wsb;\n            dx_ext2= dx0 - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n            dy_ext2= dy0 - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n            dz_ext2= dz0 - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n            dw_ext2= dw0 - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n            if c2_0 as libc::c_int & 0x1 as libc::c_int != 0 as libc::c_int {\n                xsv_ext2+= 2 as libc::c_int;\n                dx_ext2-= 2 as libc::c_int as libc::c_double;\n            } else if c2_0 as libc::c_int & 0x2 as libc::c_int != 0 as libc::c_int {\n                ysv_ext2+= 2 as libc::c_int;\n                dy_ext2-= 2 as libc::c_int as libc::c_double;\n            } else if c2_0 as libc::c_int & 0x4 as libc::c_int != 0 as libc::c_int {\n                zsv_ext2+= 2 as libc::c_int;\n                dz_ext2-= 2 as libc::c_int as libc::c_double;\n            } else {\n                wsv_ext2+= 2 as libc::c_int;\n                dw_ext2-= 2 as libc::c_int as libc::c_double;\n            }\n        }\n        let mut dx1_1 = dx0 - 1 as libc::c_int as libc::c_double - 0.309016994374947f64;\n        let mut dy1_1 = dy0 - 0 as libc::c_int as libc::c_double - 0.309016994374947f64;\n        let mut dz1_1 = dz0 - 0 as libc::c_int as libc::c_double - 0.309016994374947f64;\n        let mut dw1_1 = dw0 - 0 as libc::c_int as libc::c_double - 0.309016994374947f64;\n        let mut attn1_1 = 2 as libc::c_int as libc::c_double - dx1_1 * dx1_1\n            - dy1_1 * dy1_1 - dz1_1 * dz1_1 - dw1_1 * dw1_1;\n        if attn1_1 > 0 as libc::c_int as libc::c_double {\n            attn1_1*= attn1_1;\n            value+= attn1_1 * attn1_1\n                    * extrapolate4(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        wsb + 0 as libc::c_int,\n                        dx1_1,\n                        dy1_1,\n                        dz1_1,\n                        dw1_1,\n                    );\n        }\n        let mut dx2_1 = dx0 - 0 as libc::c_int as libc::c_double - 0.309016994374947f64;\n        let mut dy2_1 = dy0 - 1 as libc::c_int as libc::c_double - 0.309016994374947f64;\n        let mut dz2_1 = dz1_1;\n        let mut dw2_1 = dw1_1;\n        let mut attn2_1 = 2 as libc::c_int as libc::c_double - dx2_1 * dx2_1\n            - dy2_1 * dy2_1 - dz2_1 * dz2_1 - dw2_1 * dw2_1;\n        if attn2_1 > 0 as libc::c_int as libc::c_double {\n            attn2_1*= attn2_1;\n            value+= attn2_1 * attn2_1\n                    * extrapolate4(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        wsb + 0 as libc::c_int,\n                        dx2_1,\n                        dy2_1,\n                        dz2_1,\n                        dw2_1,\n                    );\n        }\n        let mut dx3_1 = dx2_1;\n        let mut dy3_1 = dy1_1;\n        let mut dz3_1 = dz0 - 1 as libc::c_int as libc::c_double - 0.309016994374947f64;\n        let mut dw3_1 = dw1_1;\n        let mut attn3_1 = 2 as libc::c_int as libc::c_double - dx3_1 * dx3_1\n            - dy3_1 * dy3_1 - dz3_1 * dz3_1 - dw3_1 * dw3_1;\n        if attn3_1 > 0 as libc::c_int as libc::c_double {\n            attn3_1*= attn3_1;\n            value+= attn3_1 * attn3_1\n                    * extrapolate4(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        wsb + 0 as libc::c_int,\n                        dx3_1,\n                        dy3_1,\n                        dz3_1,\n                        dw3_1,\n                    );\n        }\n        let mut dx4_1 = dx2_1;\n        let mut dy4_1 = dy1_1;\n        let mut dz4_1 = dz1_1;\n        let mut dw4_1 = dw0 - 1 as libc::c_int as libc::c_double - 0.309016994374947f64;\n        let mut attn4_1 = 2 as libc::c_int as libc::c_double - dx4_1 * dx4_1\n            - dy4_1 * dy4_1 - dz4_1 * dz4_1 - dw4_1 * dw4_1;\n        if attn4_1 > 0 as libc::c_int as libc::c_double {\n            attn4_1*= attn4_1;\n            value+= attn4_1 * attn4_1\n                    * extrapolate4(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        wsb + 1 as libc::c_int,\n                        dx4_1,\n                        dy4_1,\n                        dz4_1,\n                        dw4_1,\n                    );\n        }\n        let mut dx5 = dx0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dy5 = dy0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dz5 = dz0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dw5 = dw0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut attn5 = 2 as libc::c_int as libc::c_double - dx5 * dx5 - dy5 * dy5\n            - dz5 * dz5 - dw5 * dw5;\n        if attn5 > 0 as libc::c_int as libc::c_double {\n            attn5*= attn5;\n            value+= attn5 * attn5\n                    * extrapolate4(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        wsb + 0 as libc::c_int,\n                        dx5,\n                        dy5,\n                        dz5,\n                        dw5,\n                    );\n        }\n        let mut dx6 = dx0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dy6 = dy0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dz6 = dz0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dw6 = dw0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut attn6 = 2 as libc::c_int as libc::c_double - dx6 * dx6 - dy6 * dy6\n            - dz6 * dz6 - dw6 * dw6;\n        if attn6 > 0 as libc::c_int as libc::c_double {\n            attn6*= attn6;\n            value+= attn6 * attn6\n                    * extrapolate4(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        wsb + 0 as libc::c_int,\n                        dx6,\n                        dy6,\n                        dz6,\n                        dw6,\n                    );\n        }\n        let mut dx7 = dx0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dy7 = dy0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dz7 = dz0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dw7 = dw0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut attn7 = 2 as libc::c_int as libc::c_double - dx7 * dx7 - dy7 * dy7\n            - dz7 * dz7 - dw7 * dw7;\n        if attn7 > 0 as libc::c_int as libc::c_double {\n            attn7*= attn7;\n            value+= attn7 * attn7\n                    * extrapolate4(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        wsb + 1 as libc::c_int,\n                        dx7,\n                        dy7,\n                        dz7,\n                        dw7,\n                    );\n        }\n        let mut dx8 = dx0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dy8 = dy0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dz8 = dz0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dw8 = dw0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut attn8 = 2 as libc::c_int as libc::c_double - dx8 * dx8 - dy8 * dy8\n            - dz8 * dz8 - dw8 * dw8;\n        if attn8 > 0 as libc::c_int as libc::c_double {\n            attn8*= attn8;\n            value+= attn8 * attn8\n                    * extrapolate4(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        wsb + 0 as libc::c_int,\n                        dx8,\n                        dy8,\n                        dz8,\n                        dw8,\n                    );\n        }\n        let mut dx9 = dx0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dy9 = dy0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dz9 = dz0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dw9 = dw0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut attn9 = 2 as libc::c_int as libc::c_double - dx9 * dx9 - dy9 * dy9\n            - dz9 * dz9 - dw9 * dw9;\n        if attn9 > 0 as libc::c_int as libc::c_double {\n            attn9*= attn9;\n            value+= attn9 * attn9\n                    * extrapolate4(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        wsb + 1 as libc::c_int,\n                        dx9,\n                        dy9,\n                        dz9,\n                        dw9,\n                    );\n        }\n        let mut dx10 = dx0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dy10 = dy0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dz10 = dz0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dw10 = dw0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut attn10 = 2 as libc::c_int as libc::c_double - dx10 * dx10 - dy10 * dy10\n            - dz10 * dz10 - dw10 * dw10;\n        if attn10 > 0 as libc::c_int as libc::c_double {\n            attn10*= attn10;\n            value+= attn10 * attn10\n                    * extrapolate4(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        wsb + 1 as libc::c_int,\n                        dx10,\n                        dy10,\n                        dz10,\n                        dw10,\n                    );\n        }\n    } else {\n        let mut aScore_2: libc::c_double = 0.;\n        let mut aPoint_2: int8_t = 0;\n        let mut aIsBiggerSide_0 = 1 as libc::c_int;\n        let mut bScore_2: libc::c_double = 0.;\n        let mut bPoint_2: int8_t = 0;\n        let mut bIsBiggerSide_0 = 1 as libc::c_int;\n        if xins + yins < zins + wins {\n            aScore_2= xins + yins;\n            aPoint_2= 0xc as libc::c_int as int8_t;\n        } else {\n            aScore_2= zins + wins;\n            aPoint_2= 0x3 as libc::c_int as int8_t;\n        }\n        if xins + zins < yins + wins {\n            bScore_2= xins + zins;\n            bPoint_2= 0xa as libc::c_int as int8_t;\n        } else {\n            bScore_2= yins + wins;\n            bPoint_2= 0x5 as libc::c_int as int8_t;\n        }\n        if xins + wins < yins + zins {\n            let mut score_1 = xins + wins;\n            if aScore_2 <= bScore_2 && score_1 < bScore_2 {\n                bScore_2= score_1;\n                bPoint_2= 0x6 as libc::c_int as int8_t;\n            } else if aScore_2 > bScore_2 && score_1 < aScore_2 {\n                aScore_2= score_1;\n                aPoint_2= 0x6 as libc::c_int as int8_t;\n            }\n        } else {\n            let mut score_2 = yins + zins;\n            if aScore_2 <= bScore_2 && score_2 < bScore_2 {\n                bScore_2= score_2;\n                bPoint_2= 0x9 as libc::c_int as int8_t;\n            } else if aScore_2 > bScore_2 && score_2 < aScore_2 {\n                aScore_2= score_2;\n                aPoint_2= 0x9 as libc::c_int as int8_t;\n            }\n        }\n        let mut p1_0 = 3 as libc::c_int as libc::c_double - inSum + xins;\n        if aScore_2 <= bScore_2 && p1_0 < bScore_2 {\n            bScore_2= p1_0;\n            bPoint_2= 0xe as libc::c_int as int8_t;\n            bIsBiggerSide_0= 0 as libc::c_int;\n        } else if aScore_2 > bScore_2 && p1_0 < aScore_2 {\n            aScore_2= p1_0;\n            aPoint_2= 0xe as libc::c_int as int8_t;\n            aIsBiggerSide_0= 0 as libc::c_int;\n        }\n        let mut p2_0 = 3 as libc::c_int as libc::c_double - inSum + yins;\n        if aScore_2 <= bScore_2 && p2_0 < bScore_2 {\n            bScore_2= p2_0;\n            bPoint_2= 0xd as libc::c_int as int8_t;\n            bIsBiggerSide_0= 0 as libc::c_int;\n        } else if aScore_2 > bScore_2 && p2_0 < aScore_2 {\n            aScore_2= p2_0;\n            aPoint_2= 0xd as libc::c_int as int8_t;\n            aIsBiggerSide_0= 0 as libc::c_int;\n        }\n        let mut p3_0 = 3 as libc::c_int as libc::c_double - inSum + zins;\n        if aScore_2 <= bScore_2 && p3_0 < bScore_2 {\n            bScore_2= p3_0;\n            bPoint_2= 0xb as libc::c_int as int8_t;\n            bIsBiggerSide_0= 0 as libc::c_int;\n        } else if aScore_2 > bScore_2 && p3_0 < aScore_2 {\n            aScore_2= p3_0;\n            aPoint_2= 0xb as libc::c_int as int8_t;\n            aIsBiggerSide_0= 0 as libc::c_int;\n        }\n        let mut p4_0 = 3 as libc::c_int as libc::c_double - inSum + wins;\n        if aScore_2 <= bScore_2 && p4_0 < bScore_2 {\n            bScore_2= p4_0;\n            bPoint_2= 0x7 as libc::c_int as int8_t;\n            bIsBiggerSide_0= 0 as libc::c_int;\n        } else if aScore_2 > bScore_2 && p4_0 < aScore_2 {\n            aScore_2= p4_0;\n            aPoint_2= 0x7 as libc::c_int as int8_t;\n            aIsBiggerSide_0= 0 as libc::c_int;\n        }\n        if aIsBiggerSide_0 == bIsBiggerSide_0 {\n            if aIsBiggerSide_0 != 0 {\n                let mut c1_1 = (aPoint_2 as libc::c_int & bPoint_2 as libc::c_int)\n                    as int8_t;\n                let mut c2_1 = (aPoint_2 as libc::c_int | bPoint_2 as libc::c_int)\n                    as int8_t;\n                xsv_ext1= xsb;\n                xsv_ext0= xsv_ext1;\n                ysv_ext1= ysb;\n                ysv_ext0= ysv_ext1;\n                zsv_ext1= zsb;\n                zsv_ext0= zsv_ext1;\n                wsv_ext1= wsb;\n                wsv_ext0= wsv_ext1;\n                dx_ext0= dx0 - 0.309016994374947f64;\n                dy_ext0= dy0 - 0.309016994374947f64;\n                dz_ext0= dz0 - 0.309016994374947f64;\n                dw_ext0= dw0 - 0.309016994374947f64;\n                dx_ext1= dx0\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dy_ext1= dy0\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dz_ext1= dz0\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dw_ext1= dw0\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                if c1_1 as libc::c_int & 0x1 as libc::c_int != 0 as libc::c_int {\n                    xsv_ext0+= 1 as libc::c_int;\n                    dx_ext0-= 1 as libc::c_int as libc::c_double;\n                    xsv_ext1+= 2 as libc::c_int;\n                    dx_ext1-= 2 as libc::c_int as libc::c_double;\n                } else if c1_1 as libc::c_int & 0x2 as libc::c_int != 0 as libc::c_int {\n                    ysv_ext0+= 1 as libc::c_int;\n                    dy_ext0-= 1 as libc::c_int as libc::c_double;\n                    ysv_ext1+= 2 as libc::c_int;\n                    dy_ext1-= 2 as libc::c_int as libc::c_double;\n                } else if c1_1 as libc::c_int & 0x4 as libc::c_int != 0 as libc::c_int {\n                    zsv_ext0+= 1 as libc::c_int;\n                    dz_ext0-= 1 as libc::c_int as libc::c_double;\n                    zsv_ext1+= 2 as libc::c_int;\n                    dz_ext1-= 2 as libc::c_int as libc::c_double;\n                } else {\n                    wsv_ext0+= 1 as libc::c_int;\n                    dw_ext0-= 1 as libc::c_int as libc::c_double;\n                    wsv_ext1+= 2 as libc::c_int;\n                    dw_ext1-= 2 as libc::c_int as libc::c_double;\n                }\n                xsv_ext2= xsb + 1 as libc::c_int;\n                ysv_ext2= ysb + 1 as libc::c_int;\n                zsv_ext2= zsb + 1 as libc::c_int;\n                wsv_ext2= wsb + 1 as libc::c_int;\n                dx_ext2= dx0 - 1 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dy_ext2= dy0 - 1 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dz_ext2= dz0 - 1 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dw_ext2= dw0 - 1 as libc::c_int as libc::c_double\n                    - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                if c2_1 as libc::c_int & 0x1 as libc::c_int == 0 as libc::c_int {\n                    xsv_ext2-= 2 as libc::c_int;\n                    dx_ext2+= 2 as libc::c_int as libc::c_double;\n                } else if c2_1 as libc::c_int & 0x2 as libc::c_int == 0 as libc::c_int {\n                    ysv_ext2-= 2 as libc::c_int;\n                    dy_ext2+= 2 as libc::c_int as libc::c_double;\n                } else if c2_1 as libc::c_int & 0x4 as libc::c_int == 0 as libc::c_int {\n                    zsv_ext2-= 2 as libc::c_int;\n                    dz_ext2+= 2 as libc::c_int as libc::c_double;\n                } else {\n                    wsv_ext2-= 2 as libc::c_int;\n                    dw_ext2+= 2 as libc::c_int as libc::c_double;\n                }\n            } else {\n                xsv_ext2= xsb + 1 as libc::c_int;\n                ysv_ext2= ysb + 1 as libc::c_int;\n                zsv_ext2= zsb + 1 as libc::c_int;\n                wsv_ext2= wsb + 1 as libc::c_int;\n                dx_ext2= dx0 - 1 as libc::c_int as libc::c_double\n                    - 4 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dy_ext2= dy0 - 1 as libc::c_int as libc::c_double\n                    - 4 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dz_ext2= dz0 - 1 as libc::c_int as libc::c_double\n                    - 4 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dw_ext2= dw0 - 1 as libc::c_int as libc::c_double\n                    - 4 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                let mut c_4 = (aPoint_2 as libc::c_int & bPoint_2 as libc::c_int)\n                    as int8_t;\n                if c_4 as libc::c_int & 0x1 as libc::c_int != 0 as libc::c_int {\n                    xsv_ext0= xsb + 2 as libc::c_int;\n                    xsv_ext1= xsb + 1 as libc::c_int;\n                    dx_ext0= dx0 - 2 as libc::c_int as libc::c_double\n                        - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                    dx_ext1= dx0 - 1 as libc::c_int as libc::c_double\n                        - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                } else {\n                    xsv_ext1= xsb;\n                    xsv_ext0= xsv_ext1;\n                    dx_ext1= dx0\n                        - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                    dx_ext0= dx_ext1;\n                }\n                if c_4 as libc::c_int & 0x2 as libc::c_int != 0 as libc::c_int {\n                    ysv_ext1= ysb + 1 as libc::c_int;\n                    ysv_ext0= ysv_ext1;\n                    dy_ext1= dy0 - 1 as libc::c_int as libc::c_double\n                        - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                    dy_ext0= dy_ext1;\n                    if c_4 as libc::c_int & 0x1 as libc::c_int == 0 as libc::c_int {\n                        ysv_ext0+= 1 as libc::c_int;\n                        dy_ext0-= 1 as libc::c_int as libc::c_double;\n                    } else {\n                        ysv_ext1+= 1 as libc::c_int;\n                        dy_ext1-= 1 as libc::c_int as libc::c_double;\n                    }\n                } else {\n                    ysv_ext1= ysb;\n                    ysv_ext0= ysv_ext1;\n                    dy_ext1= dy0\n                        - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                    dy_ext0= dy_ext1;\n                }\n                if c_4 as libc::c_int & 0x4 as libc::c_int != 0 as libc::c_int {\n                    zsv_ext1= zsb + 1 as libc::c_int;\n                    zsv_ext0= zsv_ext1;\n                    dz_ext1= dz0 - 1 as libc::c_int as libc::c_double\n                        - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                    dz_ext0= dz_ext1;\n                    if c_4 as libc::c_int & 0x3 as libc::c_int == 0 as libc::c_int {\n                        zsv_ext0+= 1 as libc::c_int;\n                        dz_ext0-= 1 as libc::c_int as libc::c_double;\n                    } else {\n                        zsv_ext1+= 1 as libc::c_int;\n                        dz_ext1-= 1 as libc::c_int as libc::c_double;\n                    }\n                } else {\n                    zsv_ext1= zsb;\n                    zsv_ext0= zsv_ext1;\n                    dz_ext1= dz0\n                        - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                    dz_ext0= dz_ext1;\n                }\n                if c_4 as libc::c_int & 0x8 as libc::c_int != 0 as libc::c_int {\n                    wsv_ext0= wsb + 1 as libc::c_int;\n                    wsv_ext1= wsb + 2 as libc::c_int;\n                    dw_ext0= dw0 - 1 as libc::c_int as libc::c_double\n                        - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                    dw_ext1= dw0 - 2 as libc::c_int as libc::c_double\n                        - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                } else {\n                    wsv_ext1= wsb;\n                    wsv_ext0= wsv_ext1;\n                    dw_ext1= dw0\n                        - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                    dw_ext0= dw_ext1;\n                }\n            }\n        } else {\n            let mut c1_2: int8_t = 0;\n            let mut c2_2: int8_t = 0;\n            if aIsBiggerSide_0 != 0 {\n                c1_2= aPoint_2;\n                c2_2= bPoint_2;\n            } else {\n                c1_2= bPoint_2;\n                c2_2= aPoint_2;\n            }\n            if c1_2 as libc::c_int & 0x1 as libc::c_int != 0 as libc::c_int {\n                xsv_ext0= xsb + 2 as libc::c_int;\n                xsv_ext1= xsb + 1 as libc::c_int;\n                dx_ext0= dx0 - 2 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dx_ext1= dx0 - 1 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n            } else {\n                xsv_ext1= xsb;\n                xsv_ext0= xsv_ext1;\n                dx_ext1= dx0\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dx_ext0= dx_ext1;\n            }\n            if c1_2 as libc::c_int & 0x2 as libc::c_int != 0 as libc::c_int {\n                ysv_ext1= ysb + 1 as libc::c_int;\n                ysv_ext0= ysv_ext1;\n                dy_ext1= dy0 - 1 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dy_ext0= dy_ext1;\n                if c1_2 as libc::c_int & 0x1 as libc::c_int == 0 as libc::c_int {\n                    ysv_ext0+= 1 as libc::c_int;\n                    dy_ext0-= 1 as libc::c_int as libc::c_double;\n                } else {\n                    ysv_ext1+= 1 as libc::c_int;\n                    dy_ext1-= 1 as libc::c_int as libc::c_double;\n                }\n            } else {\n                ysv_ext1= ysb;\n                ysv_ext0= ysv_ext1;\n                dy_ext1= dy0\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dy_ext0= dy_ext1;\n            }\n            if c1_2 as libc::c_int & 0x4 as libc::c_int != 0 as libc::c_int {\n                zsv_ext1= zsb + 1 as libc::c_int;\n                zsv_ext0= zsv_ext1;\n                dz_ext1= dz0 - 1 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dz_ext0= dz_ext1;\n                if c1_2 as libc::c_int & 0x3 as libc::c_int == 0 as libc::c_int {\n                    zsv_ext0+= 1 as libc::c_int;\n                    dz_ext0-= 1 as libc::c_int as libc::c_double;\n                } else {\n                    zsv_ext1+= 1 as libc::c_int;\n                    dz_ext1-= 1 as libc::c_int as libc::c_double;\n                }\n            } else {\n                zsv_ext1= zsb;\n                zsv_ext0= zsv_ext1;\n                dz_ext1= dz0\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dz_ext0= dz_ext1;\n            }\n            if c1_2 as libc::c_int & 0x8 as libc::c_int != 0 as libc::c_int {\n                wsv_ext0= wsb + 1 as libc::c_int;\n                wsv_ext1= wsb + 2 as libc::c_int;\n                dw_ext0= dw0 - 1 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dw_ext1= dw0 - 2 as libc::c_int as libc::c_double\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n            } else {\n                wsv_ext1= wsb;\n                wsv_ext0= wsv_ext1;\n                dw_ext1= dw0\n                    - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n                dw_ext0= dw_ext1;\n            }\n            xsv_ext2= xsb + 1 as libc::c_int;\n            ysv_ext2= ysb + 1 as libc::c_int;\n            zsv_ext2= zsb + 1 as libc::c_int;\n            wsv_ext2= wsb + 1 as libc::c_int;\n            dx_ext2= dx0 - 1 as libc::c_int as libc::c_double\n                - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n            dy_ext2= dy0 - 1 as libc::c_int as libc::c_double\n                - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n            dz_ext2= dz0 - 1 as libc::c_int as libc::c_double\n                - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n            dw_ext2= dw0 - 1 as libc::c_int as libc::c_double\n                - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n            if c2_2 as libc::c_int & 0x1 as libc::c_int == 0 as libc::c_int {\n                xsv_ext2-= 2 as libc::c_int;\n                dx_ext2+= 2 as libc::c_int as libc::c_double;\n            } else if c2_2 as libc::c_int & 0x2 as libc::c_int == 0 as libc::c_int {\n                ysv_ext2-= 2 as libc::c_int;\n                dy_ext2+= 2 as libc::c_int as libc::c_double;\n            } else if c2_2 as libc::c_int & 0x4 as libc::c_int == 0 as libc::c_int {\n                zsv_ext2-= 2 as libc::c_int;\n                dz_ext2+= 2 as libc::c_int as libc::c_double;\n            } else {\n                wsv_ext2-= 2 as libc::c_int;\n                dw_ext2+= 2 as libc::c_int as libc::c_double;\n            }\n        }\n        let mut dx4_2 = dx0 - 1 as libc::c_int as libc::c_double\n            - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dy4_2 = dy0 - 1 as libc::c_int as libc::c_double\n            - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dz4_2 = dz0 - 1 as libc::c_int as libc::c_double\n            - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dw4_2 = dw0 - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut attn4_2 = 2 as libc::c_int as libc::c_double - dx4_2 * dx4_2\n            - dy4_2 * dy4_2 - dz4_2 * dz4_2 - dw4_2 * dw4_2;\n        if attn4_2 > 0 as libc::c_int as libc::c_double {\n            attn4_2*= attn4_2;\n            value+= attn4_2 * attn4_2\n                    * extrapolate4(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        wsb + 0 as libc::c_int,\n                        dx4_2,\n                        dy4_2,\n                        dz4_2,\n                        dw4_2,\n                    );\n        }\n        let mut dx3_2 = dx4_2;\n        let mut dy3_2 = dy4_2;\n        let mut dz3_2 = dz0 - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dw3_2 = dw0 - 1 as libc::c_int as libc::c_double\n            - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut attn3_2 = 2 as libc::c_int as libc::c_double - dx3_2 * dx3_2\n            - dy3_2 * dy3_2 - dz3_2 * dz3_2 - dw3_2 * dw3_2;\n        if attn3_2 > 0 as libc::c_int as libc::c_double {\n            attn3_2*= attn3_2;\n            value+= attn3_2 * attn3_2\n                    * extrapolate4(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        wsb + 1 as libc::c_int,\n                        dx3_2,\n                        dy3_2,\n                        dz3_2,\n                        dw3_2,\n                    );\n        }\n        let mut dx2_2 = dx4_2;\n        let mut dy2_2 = dy0 - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dz2_2 = dz4_2;\n        let mut dw2_2 = dw3_2;\n        let mut attn2_2 = 2 as libc::c_int as libc::c_double - dx2_2 * dx2_2\n            - dy2_2 * dy2_2 - dz2_2 * dz2_2 - dw2_2 * dw2_2;\n        if attn2_2 > 0 as libc::c_int as libc::c_double {\n            attn2_2*= attn2_2;\n            value+= attn2_2 * attn2_2\n                    * extrapolate4(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        wsb + 1 as libc::c_int,\n                        dx2_2,\n                        dy2_2,\n                        dz2_2,\n                        dw2_2,\n                    );\n        }\n        let mut dx1_2 = dx0 - 3 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dz1_2 = dz4_2;\n        let mut dy1_2 = dy4_2;\n        let mut dw1_2 = dw3_2;\n        let mut attn1_2 = 2 as libc::c_int as libc::c_double - dx1_2 * dx1_2\n            - dy1_2 * dy1_2 - dz1_2 * dz1_2 - dw1_2 * dw1_2;\n        if attn1_2 > 0 as libc::c_int as libc::c_double {\n            attn1_2*= attn1_2;\n            value+= attn1_2 * attn1_2\n                    * extrapolate4(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        wsb + 1 as libc::c_int,\n                        dx1_2,\n                        dy1_2,\n                        dz1_2,\n                        dw1_2,\n                    );\n        }\n        let mut dx5_0 = dx0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dy5_0 = dy0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dz5_0 = dz0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dw5_0 = dw0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut attn5_0 = 2 as libc::c_int as libc::c_double - dx5_0 * dx5_0\n            - dy5_0 * dy5_0 - dz5_0 * dz5_0 - dw5_0 * dw5_0;\n        if attn5_0 > 0 as libc::c_int as libc::c_double {\n            attn5_0*= attn5_0;\n            value+= attn5_0 * attn5_0\n                    * extrapolate4(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        wsb + 0 as libc::c_int,\n                        dx5_0,\n                        dy5_0,\n                        dz5_0,\n                        dw5_0,\n                    );\n        }\n        let mut dx6_0 = dx0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dy6_0 = dy0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dz6_0 = dz0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dw6_0 = dw0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut attn6_0 = 2 as libc::c_int as libc::c_double - dx6_0 * dx6_0\n            - dy6_0 * dy6_0 - dz6_0 * dz6_0 - dw6_0 * dw6_0;\n        if attn6_0 > 0 as libc::c_int as libc::c_double {\n            attn6_0*= attn6_0;\n            value+= attn6_0 * attn6_0\n                    * extrapolate4(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        wsb + 0 as libc::c_int,\n                        dx6_0,\n                        dy6_0,\n                        dz6_0,\n                        dw6_0,\n                    );\n        }\n        let mut dx7_0 = dx0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dy7_0 = dy0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dz7_0 = dz0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dw7_0 = dw0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut attn7_0 = 2 as libc::c_int as libc::c_double - dx7_0 * dx7_0\n            - dy7_0 * dy7_0 - dz7_0 * dz7_0 - dw7_0 * dw7_0;\n        if attn7_0 > 0 as libc::c_int as libc::c_double {\n            attn7_0*= attn7_0;\n            value+= attn7_0 * attn7_0\n                    * extrapolate4(\n                        ctx,\n                        xsb + 1 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        wsb + 1 as libc::c_int,\n                        dx7_0,\n                        dy7_0,\n                        dz7_0,\n                        dw7_0,\n                    );\n        }\n        let mut dx8_0 = dx0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dy8_0 = dy0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dz8_0 = dz0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dw8_0 = dw0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut attn8_0 = 2 as libc::c_int as libc::c_double - dx8_0 * dx8_0\n            - dy8_0 * dy8_0 - dz8_0 * dz8_0 - dw8_0 * dw8_0;\n        if attn8_0 > 0 as libc::c_int as libc::c_double {\n            attn8_0*= attn8_0;\n            value+= attn8_0 * attn8_0\n                    * extrapolate4(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        wsb + 0 as libc::c_int,\n                        dx8_0,\n                        dy8_0,\n                        dz8_0,\n                        dw8_0,\n                    );\n        }\n        let mut dx9_0 = dx0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dy9_0 = dy0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dz9_0 = dz0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dw9_0 = dw0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut attn9_0 = 2 as libc::c_int as libc::c_double - dx9_0 * dx9_0\n            - dy9_0 * dy9_0 - dz9_0 * dz9_0 - dw9_0 * dw9_0;\n        if attn9_0 > 0 as libc::c_int as libc::c_double {\n            attn9_0*= attn9_0;\n            value+= attn9_0 * attn9_0\n                    * extrapolate4(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 1 as libc::c_int,\n                        zsb + 0 as libc::c_int,\n                        wsb + 1 as libc::c_int,\n                        dx9_0,\n                        dy9_0,\n                        dz9_0,\n                        dw9_0,\n                    );\n        }\n        let mut dx10_0 = dx0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dy10_0 = dy0 - 0 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dz10_0 = dz0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut dw10_0 = dw0 - 1 as libc::c_int as libc::c_double\n            - 2 as libc::c_int as libc::c_double * 0.309016994374947f64;\n        let mut attn10_0 = 2 as libc::c_int as libc::c_double - dx10_0 * dx10_0\n            - dy10_0 * dy10_0 - dz10_0 * dz10_0 - dw10_0 * dw10_0;\n        if attn10_0 > 0 as libc::c_int as libc::c_double {\n            attn10_0*= attn10_0;\n            value+= attn10_0 * attn10_0\n                    * extrapolate4(\n                        ctx,\n                        xsb + 0 as libc::c_int,\n                        ysb + 0 as libc::c_int,\n                        zsb + 1 as libc::c_int,\n                        wsb + 1 as libc::c_int,\n                        dx10_0,\n                        dy10_0,\n                        dz10_0,\n                        dw10_0,\n                    );\n        }\n    }\n    let mut attn_ext0 = 2 as libc::c_int as libc::c_double - dx_ext0 * dx_ext0\n        - dy_ext0 * dy_ext0 - dz_ext0 * dz_ext0 - dw_ext0 * dw_ext0;\n    if attn_ext0 > 0 as libc::c_int as libc::c_double {\n        attn_ext0*= attn_ext0;\n        value+= attn_ext0 * attn_ext0\n                * extrapolate4(\n                    ctx,\n                    xsv_ext0,\n                    ysv_ext0,\n                    zsv_ext0,\n                    wsv_ext0,\n                    dx_ext0,\n                    dy_ext0,\n                    dz_ext0,\n                    dw_ext0,\n                );\n    }\n    let mut attn_ext1 = 2 as libc::c_int as libc::c_double - dx_ext1 * dx_ext1\n        - dy_ext1 * dy_ext1 - dz_ext1 * dz_ext1 - dw_ext1 * dw_ext1;\n    if attn_ext1 > 0 as libc::c_int as libc::c_double {\n        attn_ext1*= attn_ext1;\n        value+= attn_ext1 * attn_ext1\n                * extrapolate4(\n                    ctx,\n                    xsv_ext1,\n                    ysv_ext1,\n                    zsv_ext1,\n                    wsv_ext1,\n                    dx_ext1,\n                    dy_ext1,\n                    dz_ext1,\n                    dw_ext1,\n                );\n    }\n    let mut attn_ext2 = 2 as libc::c_int as libc::c_double - dx_ext2 * dx_ext2\n        - dy_ext2 * dy_ext2 - dz_ext2 * dz_ext2 - dw_ext2 * dw_ext2;\n    if attn_ext2 > 0 as libc::c_int as libc::c_double {\n        attn_ext2*= attn_ext2;\n        value+= attn_ext2 * attn_ext2\n                * extrapolate4(\n                    ctx,\n                    xsv_ext2,\n                    ysv_ext2,\n                    zsv_ext2,\n                    wsv_ext2,\n                    dx_ext2,\n                    dy_ext2,\n                    dz_ext2,\n                    dw_ext2,\n                );\n    }\n    return value / 30.0f64;\n}","src::kazmath::plane::kmPlaneNormalize":"pub unsafe extern \"C\" fn kmPlaneNormalize(\n    mut pOut: *mut crate::src::kazmath::mat4::kmPlane,\n    mut pP: *const crate::src::kazmath::mat4::kmPlane,\n) -> *mut crate::src::kazmath::mat4::kmPlane {\n    let mut n = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut l = 0 as libc::c_int as libc::c_float;\n    if (*pP).a == 0. && (*pP).b == 0. && (*pP).c == 0. {\n        (*pOut).a= (*pP).a;\n        (*pOut).b= (*pP).b;\n        (*pOut).c= (*pP).c;\n        (*pOut).d= (*pP).d;\n        return pOut;\n    }\n    n.x= (*pP).a;\n    n.y= (*pP).b;\n    n.z= (*pP).c;\n    l= 1.0f32 / crate::src::kazmath::vec3::kmVec3Length(core::ptr::addr_of!(n));\n    crate::src::kazmath::vec3::kmVec3Normalize(core::ptr::addr_of_mut!(n), core::ptr::addr_of!(n));\n    (*pOut).a= n.x;\n    (*pOut).b= n.y;\n    (*pOut).c= n.z;\n    (*pOut).d= (*pP).d * l;\n    return pOut;\n}","src::kazmath::aabb2::kmAABB2ExpandToContain":"pub unsafe extern \"C\" fn kmAABB2ExpandToContain(\n    mut pOut: Option<&mut kmAABB2>,\n    mut pIn: *const kmAABB2,\n    mut other: *const kmAABB2,\n) -> *mut kmAABB2 {\n    let mut result = kmAABB2 {\n        min: kmVec2 { x: 0., y: 0. },\n        max: kmVec2 { x: 0., y: 0. },\n    };\n    result.min.x= if (*pIn).min.x < (*other).min.x { (*pIn).min.x } else { (*other).min.x };\n    result.max.x= if (*pIn).max.x > (*other).max.x { (*pIn).max.x } else { (*other).max.x };\n    result.min.y= if (*pIn).min.y < (*other).min.y { (*pIn).min.y } else { (*other).min.y };\n    result.max.y= if (*pIn).max.y > (*other).max.y { (*pIn).max.y } else { (*other).max.y };\n    kmAABB2Assign(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), core::ptr::addr_of!(result));\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::plane::kmPlaneExtractFromMat4":"pub unsafe extern \"C\" fn kmPlaneExtractFromMat4(\n    mut pOut: Option<&mut crate::src::kazmath::mat4::kmPlane>,\n    mut pIn: *const crate::src::kazmath::mat3::kmMat4,\n    mut row: libc::c_int,\n) -> *mut crate::src::kazmath::mat4::kmPlane {\n    let mut scale = if row < 0 as libc::c_int {\n        -(1 as libc::c_int)\n    } else {\n        1 as libc::c_int\n    };\n    row= abs(row) - 1 as libc::c_int;\n    (*pOut.as_deref_mut().unwrap()).a= (*pIn).mat[3 as libc::c_int as usize]\n        + scale as libc::c_float * (*pIn).mat[row as usize];\n    (*pOut.as_deref_mut().unwrap()).b= (*pIn).mat[7 as libc::c_int as usize]\n        + scale as libc::c_float * (*pIn).mat[(row + 4 as libc::c_int) as usize];\n    (*pOut.as_deref_mut().unwrap()).c= (*pIn).mat[11 as libc::c_int as usize]\n        + scale as libc::c_float * (*pIn).mat[(row + 8 as libc::c_int) as usize];\n    (*pOut.as_deref_mut().unwrap()).d= (*pIn).mat[15 as libc::c_int as usize]\n        + scale as libc::c_float * (*pIn).mat[(row + 12 as libc::c_int) as usize];\n    return kmPlaneNormalize(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), pOut.as_deref().map(|r| r as *const _).unwrap_or(std::ptr::null()));\n}","src::kazmath::aabb2::kmAABB2Initialize":"pub unsafe extern \"C\" fn kmAABB2Initialize(\n    mut pBox: Option<&mut kmAABB2>,\n    mut centre: *const kmVec2,\n    mut width: libc::c_float,\n    mut height: libc::c_float,\n    mut depth: libc::c_float,\n) -> *mut kmAABB2 {\n    if pBox.as_deref().is_none() {();\n        return 0 as *mut kmAABB2;\n    }\n    let mut origin = kmVec2 { x: 0., y: 0. };\n    let mut point = if !centre.is_null() { centre as *mut kmVec2 } else {(); core::ptr::addr_of_mut!(origin) };\n    crate::src::kazmath::vec2::kmVec2Fill(Some(&mut origin), 0.0f32, 0.0f32);\n    (*pBox.as_deref_mut().unwrap()).min.x= (*point).x - width / 2 as libc::c_int as libc::c_float;\n    (*pBox.as_deref_mut().unwrap()).min.y= (*point).y - height / 2 as libc::c_int as libc::c_float;\n    (*pBox.as_deref_mut().unwrap()).max.x= (*point).x + width / 2 as libc::c_int as libc::c_float;\n    (*pBox.as_deref_mut().unwrap()).max.y= (*point).y + height / 2 as libc::c_int as libc::c_float;\n    return pBox.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::mat3::kmMat3Adjugate":"pub unsafe extern \"C\" fn kmMat3Adjugate(\n    mut pOut: Option<&mut kmMat3>,\n    mut pIn: *const kmMat3,\n) -> *mut kmMat3 {\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int\n        as usize]= (*pIn).mat[4 as libc::c_int as usize]\n        * (*pIn).mat[8 as libc::c_int as usize]\n        - (*pIn).mat[5 as libc::c_int as usize] * (*pIn).mat[7 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[1 as libc::c_int\n        as usize]= (*pIn).mat[2 as libc::c_int as usize]\n        * (*pIn).mat[7 as libc::c_int as usize]\n        - (*pIn).mat[1 as libc::c_int as usize] * (*pIn).mat[8 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[2 as libc::c_int\n        as usize]= (*pIn).mat[1 as libc::c_int as usize]\n        * (*pIn).mat[5 as libc::c_int as usize]\n        - (*pIn).mat[2 as libc::c_int as usize] * (*pIn).mat[4 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[3 as libc::c_int\n        as usize]= (*pIn).mat[5 as libc::c_int as usize]\n        * (*pIn).mat[6 as libc::c_int as usize]\n        - (*pIn).mat[3 as libc::c_int as usize] * (*pIn).mat[8 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[4 as libc::c_int\n        as usize]= (*pIn).mat[0 as libc::c_int as usize]\n        * (*pIn).mat[8 as libc::c_int as usize]\n        - (*pIn).mat[2 as libc::c_int as usize] * (*pIn).mat[6 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[5 as libc::c_int\n        as usize]= (*pIn).mat[2 as libc::c_int as usize]\n        * (*pIn).mat[3 as libc::c_int as usize]\n        - (*pIn).mat[0 as libc::c_int as usize] * (*pIn).mat[5 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[6 as libc::c_int\n        as usize]= (*pIn).mat[3 as libc::c_int as usize]\n        * (*pIn).mat[7 as libc::c_int as usize]\n        - (*pIn).mat[4 as libc::c_int as usize] * (*pIn).mat[6 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[7 as libc::c_int\n        as usize]= (*pIn).mat[1 as libc::c_int as usize]\n        * (*pIn).mat[6 as libc::c_int as usize]\n        - (*pIn).mat[0 as libc::c_int as usize] * (*pIn).mat[7 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[8 as libc::c_int\n        as usize]= (*pIn).mat[0 as libc::c_int as usize]\n        * (*pIn).mat[4 as libc::c_int as usize]\n        - (*pIn).mat[1 as libc::c_int as usize] * (*pIn).mat[3 as libc::c_int as usize];\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::mat3::kmMat3Assign":"pub unsafe extern \"C\" fn kmMat3Assign(\n    mut pOut: *mut kmMat3,\n    mut pIn: *const kmMat3,\n) -> *mut kmMat3 {\n    if pOut != pIn as *mut kmMat3 {} else {\n        __assert_fail(\n            b\"pOut != pIn\\0\" as *const u8 as *const libc::c_char,\n            b\"../kazmath/mat3.c\\0\" as *const u8 as *const libc::c_char,\n            177 as libc::c_int as libc::c_uint,\n            b\"kmMat3 *kmMat3Assign(kmMat3 *, const kmMat3 *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    memcpy(\n        (*pOut).mat.as_mut_ptr() as *mut libc::c_void,\n        ((*pIn).mat).as_ptr() as *const libc::c_void,\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(9 as libc::c_int as libc::c_ulong),\n    );\n    return pOut;\n}","src::kazmath::mat4::kmMat4Scaling":"pub unsafe extern \"C\" fn kmMat4Scaling(\n    mut pOut: *mut crate::src::kazmath::mat3::kmMat4,\n    mut x: libc::c_float,\n    mut y: libc::c_float,\n    mut z: libc::c_float,\n) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    memset(\n        (*pOut).mat.as_mut_ptr() as *mut libc::c_void,\n        0 as libc::c_int,\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(16 as libc::c_int as libc::c_ulong),\n    );\n    (*pOut).mat[0 as libc::c_int as usize]= x;\n    (*pOut).mat[5 as libc::c_int as usize]= y;\n    (*pOut).mat[10 as libc::c_int as usize]= z;\n    (*pOut).mat[15 as libc::c_int as usize]= 1.0f32;\n    return pOut;\n}","src::kazmath::aabb3::kmAABB3Scale":"pub unsafe extern \"C\" fn kmAABB3Scale(\n    mut pOut: *mut kmAABB3,\n    mut pIn: *const kmAABB3,\n    mut s: libc::c_float,\n) -> *mut kmAABB3 {\n    if 0 as libc::c_int != 0\n        && !(b\"Not implemented\\0\" as *const u8 as *const libc::c_char).is_null()\n    {} else {\n        __assert_fail(\n            b\"0 && \\\"Not implemented\\\"\\0\" as *const u8 as *const libc::c_char,\n            b\"../kazmath/aabb3.c\\0\" as *const u8 as *const libc::c_char,\n            81 as libc::c_int as libc::c_uint,\n            b\"kmAABB3 *kmAABB3Scale(kmAABB3 *, const kmAABB3 *, float)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    return pOut;\n}","src::kazmath::utility::kmLerp":"pub unsafe extern \"C\" fn kmLerp(\n    mut x: libc::c_float,\n    mut y: libc::c_float,\n    mut t: libc::c_float,\n) -> libc::c_float {\n    return x + t * (y - x);\n}","src::kazmath::vec2::kmVec2LengthSq":"pub unsafe extern \"C\" fn kmVec2LengthSq(mut pIn: *const crate::src::kazmath::aabb2::kmVec2) -> libc::c_float {\n    return crate::src::kazmath::utility::kmSQR((*pIn).x) + crate::src::kazmath::utility::kmSQR((*pIn).y);\n}","src::kazmath::vec3::kmVec3InverseTransform":"pub unsafe extern \"C\" fn kmVec3InverseTransform(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pVect: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pM: *const crate::src::kazmath::mat3::kmMat4,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    let mut v1 = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut v2 = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    v1.x= (*pVect).x - (*pM).mat[12 as libc::c_int as usize];\n    v1.y= (*pVect).y - (*pM).mat[13 as libc::c_int as usize];\n    v1.z= (*pVect).z - (*pM).mat[14 as libc::c_int as usize];\n    v2.x= v1.x * (*pM).mat[0 as libc::c_int as usize]\n        + v1.y * (*pM).mat[1 as libc::c_int as usize]\n        + v1.z * (*pM).mat[2 as libc::c_int as usize];\n    v2.y= v1.x * (*pM).mat[4 as libc::c_int as usize]\n        + v1.y * (*pM).mat[5 as libc::c_int as usize]\n        + v1.z * (*pM).mat[6 as libc::c_int as usize];\n    v2.z= v1.x * (*pM).mat[8 as libc::c_int as usize]\n        + v1.y * (*pM).mat[9 as libc::c_int as usize]\n        + v1.z * (*pM).mat[10 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).x= v2.x;\n    (*pOut.as_deref_mut().unwrap()).y= v2.y;\n    (*pOut.as_deref_mut().unwrap()).z= v2.z;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::vec3::kmVec3AreEqual":"pub unsafe extern \"C\" fn kmVec3AreEqual(\n    mut p1: *const crate::src::kazmath::aabb3::kmVec3,\n    mut p2: *const crate::src::kazmath::aabb3::kmVec3,\n) -> libc::c_int {\n    if ((*p1).x as libc::c_double) < (*p2).x as libc::c_double + 0.0001f64\n        && (*p1).x as libc::c_double > (*p2).x as libc::c_double - 0.0001f64\n        && (((*p1).y as libc::c_double) < (*p2).y as libc::c_double + 0.0001f64\n            && (*p1).y as libc::c_double > (*p2).y as libc::c_double - 0.0001f64)\n        && (((*p1).z as libc::c_double) < (*p2).z as libc::c_double + 0.0001f64\n            && (*p1).z as libc::c_double > (*p2).z as libc::c_double - 0.0001f64)\n    {\n        return 1 as libc::c_int;\n    }\n    return 0 as libc::c_int;\n}","src::kazmath::vec3::kmVec3RotationToDirection":"pub unsafe extern \"C\" fn kmVec3RotationToDirection(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pIn: *const crate::src::kazmath::aabb3::kmVec3,\n    mut forwards: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    let xr = crate::src::kazmath::utility::kmDegreesToRadians((*pIn).x);\n    let yr = crate::src::kazmath::utility::kmDegreesToRadians((*pIn).y);\n    let zr = crate::src::kazmath::utility::kmDegreesToRadians((*pIn).z);\n    let cr = cos(xr as libc::c_double) as libc::c_float;\n    let sr = sin(xr as libc::c_double) as libc::c_float;\n    let cp = cos(yr as libc::c_double) as libc::c_float;\n    let sp = sin(yr as libc::c_double) as libc::c_float;\n    let cy = cos(zr as libc::c_double) as libc::c_float;\n    let sy = sin(zr as libc::c_double) as libc::c_float;\n    let srsp = sr * sp;\n    let crsp = cr * sp;\n    let pseudoMatrix: [libc::c_float; 9] = [\n        cp * cy,\n        cp * sy,\n        -sp,\n        srsp * cy - cr * sy,\n        srsp * sy + cr * cy,\n        sr * cp,\n        crsp * cy + sr * sy,\n        crsp * sy - sr * cy,\n        cr * cp,\n    ];\n    (*pOut.as_deref_mut().unwrap()).x= (*forwards).x * pseudoMatrix[0 as libc::c_int as usize]\n        + (*forwards).y * pseudoMatrix[3 as libc::c_int as usize]\n        + (*forwards).z * pseudoMatrix[6 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).y= (*forwards).x * pseudoMatrix[1 as libc::c_int as usize]\n        + (*forwards).y * pseudoMatrix[4 as libc::c_int as usize]\n        + (*forwards).z * pseudoMatrix[7 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).z= (*forwards).x * pseudoMatrix[2 as libc::c_int as usize]\n        + (*forwards).y * pseudoMatrix[5 as libc::c_int as usize]\n        + (*forwards).z * pseudoMatrix[8 as libc::c_int as usize];\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::vec4::kmVec4Transform":"pub unsafe extern \"C\" fn kmVec4Transform(\n    mut pOut: Option<&mut crate::src::kazmath::plane::kmVec4>,\n    mut pV: *const crate::src::kazmath::plane::kmVec4,\n    mut pM: *const crate::src::kazmath::mat3::kmMat4,\n) -> *mut crate::src::kazmath::plane::kmVec4 {\n    return kmVec4MultiplyMat4(pOut.as_deref_mut(), pV, pM);\n}","src::kazmath::aabb2::kmAABB2ScaleWithPivot":"pub unsafe extern \"C\" fn kmAABB2ScaleWithPivot(\n    mut pOut: *mut kmAABB2,\n    mut pIn: *const kmAABB2,\n    mut pivot: *const kmVec2,\n    mut s: libc::c_float,\n) -> *mut kmAABB2 {\n    let mut translate = kmVec2 { x: 0., y: 0. };\n    translate.x= -(*pivot).x;\n    translate.y= -(*pivot).y;\n    kmAABB2Translate(pOut, pIn, core::ptr::addr_of!(translate));\n    kmAABB2Scale(pOut, pIn, s);\n    kmAABB2Translate(pOut, pIn, pivot);\n    return pOut;\n}","src::kazmath::quaternion::kmQuaternionNormalize":"pub unsafe extern \"C\" fn kmQuaternionNormalize(\n    mut pOut: *mut /* owning */ crate::src::kazmath::mat3::kmQuaternion,\n    mut pIn: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> *mut /* owning */ crate::src::kazmath::mat3::kmQuaternion {\n    let mut length = kmQuaternionLength(pIn);\n    if fabs(length as libc::c_double) < 0.0001f64 {\n        (*pOut).x= 0.0f64 as libc::c_float;\n        (*pOut).y= 0.0f64 as libc::c_float;\n        (*pOut).z= 0.0f64 as libc::c_float;\n        (*pOut).w= 0.0f64 as libc::c_float;\n        return pOut;\n    }\n    {let crown_promoted_local_0 = (*pOut).x / length;kmQuaternionFill(\n        pOut.as_mut(),\n        crown_promoted_local_0,\n        (*pOut).y / length,\n        (*pOut).z / length,\n        (*pOut).w / length,\n    )};\n    return pOut;\n}","src::src::generate::heman_generate_archipelago_political_3":"pub unsafe extern \"C\" fn heman_generate_archipelago_political_3(\n    mut width: libc::c_int,\n    mut height: libc::c_int,\n    mut colors: *const heman_color,\n    mut ncolors: libc::c_int,\n    mut ocean: heman_color,\n    mut seed: libc::c_int,\n    mut political: *mut heman_image,\n) -> *mut /* owning */ heman_image {\n    let mut elevations = malloc(\n        (::std::mem::size_of::<*mut heman_image>() as libc::c_ulong)\n            .wrapping_mul(ncolors as libc::c_ulong),\n    ) as *mut *mut heman_image;\n    let mut cindex = 0 as libc::c_int;\n    while cindex < ncolors {\n        *elevations.offset(cindex as isize) = heman_generate_archipelago_political_2(\n            width,\n            height,\n            *colors.offset(cindex as isize),\n            seed,\n            political,\n            1 as libc::c_int,\n        );\n        cindex+= 1;\n    }\n    let mut elevation = crate::src::src::image::heman_image_create(width, height, 1 as libc::c_int);\n    crate::src::src::image::heman_image_clear(elevation.as_mut(), 0 as libc::c_int as libc::c_float);\n    let mut cindex_0 = 0 as libc::c_int;\n    while cindex_0 < ncolors {\n        let mut y: libc::c_int = 0;\n        y= 0 as libc::c_int;\n        while y < height {\n            let mut dst = (*elevation).data.offset((y * width) as isize);\n            let mut src = ((**elevations.offset(cindex_0 as isize)).data)\n                .offset((y * width) as isize);\n            let mut x = 0 as libc::c_int;\n            while x < width {\n                *dst= if (*src) > (*dst) { (*src) } else { (*dst) };\n                x+= 1;\n                dst= dst.offset(1);\n                src= src.offset(1);\n            }\n            y+= 1;\n        }\n        crate::src::src::image::heman_image_destroy(*elevations.offset(cindex_0 as isize));\n        cindex_0+= 1;\n    }\n    free(elevations as *mut libc::c_void);\n    let mut ocean_elevation = heman_generate_archipelago_political_2(\n        width,\n        height,\n        ocean,\n        seed,\n        political,\n        0 as libc::c_int,\n    );\n    let mut y_0: libc::c_int = 0;\n    y_0= 0 as libc::c_int;\n    while y_0 < height {\n        let mut dst_0 = (*elevation).data.offset((y_0 * width) as isize);\n        let mut src_0 = (*ocean_elevation).data.offset((y_0 * width) as isize);\n        let mut x_0 = 0 as libc::c_int;\n        while x_0 < width {\n            if (*src_0) < 0 as libc::c_int as libc::c_float {\n                *dst_0= (*src_0);\n            }\n            x_0+= 1;\n            dst_0= dst_0.offset(1);\n            src_0= src_0.offset(1);\n        }\n        y_0+= 1;\n    }\n    crate::src::src::image::heman_image_destroy(ocean_elevation);\n    return elevation;\n}","src::kazmath::mat4::kmMat4ExtractRotation":"pub unsafe extern \"C\" fn kmMat4ExtractRotation(\n    mut pOut: Option<&mut crate::src::kazmath::mat3::kmMat3>,\n    mut pIn: *const crate::src::kazmath::mat3::kmMat4,\n) -> *mut crate::src::kazmath::mat3::kmMat3 {\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int as usize]= (*pIn).mat[0 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[1 as libc::c_int as usize]= (*pIn).mat[1 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[2 as libc::c_int as usize]= (*pIn).mat[2 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[3 as libc::c_int as usize]= (*pIn).mat[4 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[4 as libc::c_int as usize]= (*pIn).mat[5 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[5 as libc::c_int as usize]= (*pIn).mat[6 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[6 as libc::c_int as usize]= (*pIn).mat[8 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[7 as libc::c_int as usize]= (*pIn).mat[9 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[8 as libc::c_int as usize]= (*pIn).mat[10 as libc::c_int as usize];\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::quaternion::kmQuaternionSubtract":"pub unsafe extern \"C\" fn kmQuaternionSubtract(\n    mut pOut: *mut crate::src::kazmath::mat3::kmQuaternion,\n    mut pQ1: *const crate::src::kazmath::mat3::kmQuaternion,\n    mut pQ2: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> *mut crate::src::kazmath::mat3::kmQuaternion {\n    (*pOut).x= (*pQ1).x - (*pQ2).x;\n    (*pOut).y= (*pQ1).y - (*pQ2).y;\n    (*pOut).z= (*pQ1).z - (*pQ2).z;\n    (*pOut).w= (*pQ1).w - (*pQ2).w;\n    return pOut;\n}","src::kazmath::ray2::kmRay2FillWithEndpoints":"pub unsafe extern \"C\" fn kmRay2FillWithEndpoints(\n    mut ray: Option<&mut kmRay2>,\n    mut start: *const crate::src::kazmath::aabb2::kmVec2,\n    mut end: *const crate::src::kazmath::aabb2::kmVec2,\n) {\n    (*ray.as_deref_mut().unwrap()).start.x= (*start).x;\n    (*ray.as_deref_mut().unwrap()).start.y= (*start).y;\n    (*ray.as_deref_mut().unwrap()).dir.x= (*end).x - (*start).x;\n    (*ray.as_deref_mut().unwrap()).dir.y= (*end).y - (*start).y;\n}","src::src::image::heman_image_sample":"pub unsafe extern \"C\" fn heman_image_sample(\n    mut img: Option<&mut heman_image>,\n    mut u: libc::c_float,\n    mut v: libc::c_float,\n    mut result: *mut libc::c_float,\n) {\n    let mut x = (if 0 as libc::c_int as libc::c_float\n        > (if ((*img.as_deref().unwrap()).width - 1 as libc::c_int) as libc::c_float\n            > (*img.as_deref().unwrap()).width as libc::c_float * u\n        {\n            (*img.as_deref().unwrap()).width as libc::c_float * u\n        } else {\n            ((*img.as_deref().unwrap()).width - 1 as libc::c_int) as libc::c_float\n        })\n    {\n        0 as libc::c_int as libc::c_float\n    } else if ((*img.as_deref().unwrap()).width - 1 as libc::c_int) as libc::c_float\n        > (*img.as_deref().unwrap()).width as libc::c_float * u\n    {\n        (*img.as_deref().unwrap()).width as libc::c_float * u\n    } else {\n        ((*img.as_deref().unwrap()).width - 1 as libc::c_int) as libc::c_float\n    }) as libc::c_int;\n    let mut y = (if 0 as libc::c_int as libc::c_float\n        > (if ((*img.as_deref().unwrap()).height - 1 as libc::c_int) as libc::c_float\n            > (*img.as_deref().unwrap()).height as libc::c_float * v\n        {\n            (*img.as_deref().unwrap()).height as libc::c_float * v\n        } else {\n            ((*img.as_deref().unwrap()).height - 1 as libc::c_int) as libc::c_float\n        })\n    {\n        0 as libc::c_int as libc::c_float\n    } else if ((*img.as_deref().unwrap()).height - 1 as libc::c_int) as libc::c_float\n        > (*img.as_deref().unwrap()).height as libc::c_float * v\n    {\n        (*img.as_deref().unwrap()).height as libc::c_float * v\n    } else {\n        ((*img.as_deref().unwrap()).height - 1 as libc::c_int) as libc::c_float\n    }) as libc::c_int;\n    let mut data = heman_image_texel(img.as_deref_mut(), x, y);\n    let mut b = 0 as libc::c_int;\n    while b < (*img.as_deref().unwrap()).nbands {\n        let fresh1 = data;\n        data= data.offset(1);\n        let fresh2 = result;\n        result= result.offset(1);\n        *fresh2= (*fresh1);\n        b+= 1;\n    }\n}","src::src::import::heman_import_u8":"pub unsafe extern \"C\" fn heman_import_u8(\n    mut width: libc::c_int,\n    mut height: libc::c_int,\n    mut nbands: libc::c_int,\n    mut source: *const heman_byte,\n    mut minval: libc::c_float,\n    mut maxval: libc::c_float,\n) -> *mut /* owning */ heman_image {\n    let mut result = crate::src::src::image::heman_image_create(width, height, nbands);\n    let mut inp = source;\n    let mut outp = (*result).data;\n    let mut scale = (maxval - minval) / 255.0f32;\n    let mut size = height * width * nbands;\n    let mut i = 0 as libc::c_int;\n    while i < size {\n        let fresh0 = inp;\n        inp= inp.offset(1);\n        let mut v = (*fresh0) as libc::c_int as libc::c_float * scale + minval;\n        let fresh1 = outp;\n        outp= outp.offset(1);\n        *fresh1= if minval > (if maxval > v { v } else { maxval }) {\n            minval\n        } else if maxval > v {\n            v\n        } else {\n            maxval\n        };\n        i+= 1;\n    }\n    return result;\n}","src::kazmath::vec4::kmVec4Normalize":"pub unsafe extern \"C\" fn kmVec4Normalize(\n    mut pOut: *mut crate::src::kazmath::plane::kmVec4,\n    mut pIn: *const crate::src::kazmath::plane::kmVec4,\n) -> *mut crate::src::kazmath::plane::kmVec4 {\n    if (*pIn).x == 0. && (*pIn).y == 0. && (*pIn).z == 0. && (*pIn).w == 0. {\n        return kmVec4Assign(pOut, pIn);\n    }\n    let mut l = 1.0f32 / kmVec4Length(pIn);\n    (*pOut).x= (*pIn).x * l;\n    (*pOut).y= (*pIn).y * l;\n    (*pOut).z= (*pIn).z * l;\n    (*pOut).w= (*pIn).w * l;\n    return pOut;\n}","src::src::lighting::horizon_scan":"unsafe extern \"C\" fn horizon_scan(\n    mut heightmap: *mut heman_image,\n    mut result: *mut heman_image,\n    mut startpts: *mut libc::c_int,\n    mut dx: libc::c_int,\n    mut dy: libc::c_int,\n) {\n    let mut w = (*heightmap).width;\n    let mut h = (*heightmap).height;\n    let mut sx = (dx > 0 as libc::c_int) as libc::c_int\n        - (dx < 0 as libc::c_int) as libc::c_int;\n    let mut sy = (dy > 0 as libc::c_int) as libc::c_int\n        - (dy < 0 as libc::c_int) as libc::c_int;\n    let mut ax = abs(dx);\n    let mut ay = abs(dy);\n    let mut nsweeps = ay * w + ax * h - (ax + ay - 1 as libc::c_int);\n    let mut p = startpts;\n    let mut x = -ax;\n    while x < w - ax {\n        let mut y = -ay;\n        while y < h - ay {\n            if !(x >= 0 as libc::c_int && x < w && y >= 0 as libc::c_int && y < h) {\n                let fresh2 = p;\n                p= p.offset(1);\n                *fresh2= if sx < 0 as libc::c_int {\n                    w - x - 1 as libc::c_int\n                } else {\n                    x\n                };\n                let fresh3 = p;\n                p= p.offset(1);\n                *fresh3= if sy < 0 as libc::c_int {\n                    h - y - 1 as libc::c_int\n                } else {\n                    y\n                };\n            }\n            y+= 1;\n        }\n        x+= 1;\n    }\n    if nsweeps as libc::c_long\n        == p.offset_from(startpts) as libc::c_long / 2 as libc::c_int as libc::c_long\n    {} else {\n        __assert_fail(\n            b\"nsweeps == (p - startpts) / 2\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/lighting.c\\0\" as *const u8 as *const libc::c_char,\n            160 as libc::c_int as libc::c_uint,\n            b\"void horizon_scan(heman_image *, heman_image *, int *, int, int)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut pathlen = 0 as libc::c_int;\n    let mut i = *startpts.offset(0 as libc::c_int as isize);\n    let mut j = *startpts.offset(1 as libc::c_int as isize);\n    loop {\n        i+= dx;\n        j+= dy;\n        pathlen+= 1;\n        if !(i >= 0 as libc::c_int && i < w && j >= 0 as libc::c_int && j < h) {\n            break;\n        }\n    }\n    let mut cellw = crate::src::src::lighting::_occlusion_scale / (if w > h { w } else { h }) as libc::c_float;\n    let mut cellh = crate::src::src::lighting::_occlusion_scale / (if w > h { w } else { h }) as libc::c_float;\n    let mut hull_buffer = malloc(\n        (::std::mem::size_of::<crate::src::kazmath::aabb3::kmVec3>() as libc::c_ulong)\n            .wrapping_mul(pathlen as libc::c_ulong)\n            .wrapping_mul(nsweeps as libc::c_ulong),\n    ) as *mut crate::src::kazmath::aabb3::kmVec3;\n    let mut sweep: libc::c_int = 0;\n    sweep= 0 as libc::c_int;\n    while sweep < nsweeps {\n        let mut convex_hull = hull_buffer.offset((sweep * pathlen) as isize);\n        let mut p_0 = startpts.offset((sweep * 2 as libc::c_int) as isize);\n        let mut i_0 = *p_0.offset(0 as libc::c_int as isize);\n        let mut j_0 = *p_0.offset(1 as libc::c_int as isize);\n        let mut thispt = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n        let mut horizonpt = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n        thispt.x= i_0 as libc::c_float * cellw;\n        thispt.y= j_0 as libc::c_float * cellh;\n        thispt.z= *crate::src::src::image::heman_image_texel(\n            heightmap.as_mut(),\n            if 0 as libc::c_int\n                > (if w - 1 as libc::c_int > i_0 { i_0 } else { w - 1 as libc::c_int })\n            {\n                0 as libc::c_int\n            } else if w - 1 as libc::c_int > i_0 {\n                i_0\n            } else {\n                w - 1 as libc::c_int\n            },\n            if 0 as libc::c_int\n                > (if h - 1 as libc::c_int > j_0 { j_0 } else { h - 1 as libc::c_int })\n            {\n                0 as libc::c_int\n            } else if h - 1 as libc::c_int > j_0 {\n                j_0\n            } else {\n                h - 1 as libc::c_int\n            },\n        );\n        let mut stack_top = 0 as libc::c_int;\n        *convex_hull.offset(0 as libc::c_int as isize) = thispt;\n        i_0+= dx;\n        j_0+= dy;\n        while i_0 >= 0 as libc::c_int && i_0 < w && j_0 >= 0 as libc::c_int && j_0 < h {\n            thispt.x= i_0 as libc::c_float * cellw;\n            thispt.y= j_0 as libc::c_float * cellh;\n            thispt.z= *crate::src::src::image::heman_image_texel(heightmap.as_mut(), i_0, j_0);\n            while stack_top > 0 as libc::c_int {\n                let mut s1 = azimuth_slope(\n                    thispt,\n                    *convex_hull.offset(stack_top as isize),\n                );\n                let mut s2 = azimuth_slope(\n                    thispt,\n                    *convex_hull.offset((stack_top - 1 as libc::c_int) as isize),\n                );\n                if s1 >= s2 {\n                    break;\n                }\n                stack_top-= 1;\n            }\n            let fresh4 = stack_top;\n            stack_top= stack_top + 1;\n            horizonpt= *convex_hull.offset(fresh4 as isize);\n            if stack_top < pathlen {} else {\n                __assert_fail(\n                    b\"stack_top < pathlen\\0\" as *const u8 as *const libc::c_char,\n                    b\"../src/lighting.c\\0\" as *const u8 as *const libc::c_char,\n                    213 as libc::c_int as libc::c_uint,\n                    b\"void horizon_scan(heman_image *, heman_image *, int *, int, int)\\0\" as *const u8 as *const libc::c_char,\n                );\n            }\n            *convex_hull.offset(stack_top as isize) = thispt;\n            let mut occlusion = compute_occlusion(thispt, horizonpt);\n            *crate::src::src::image::heman_image_texel(result.as_mut(), i_0, j_0) += 1.0f32 / 16.0f32 * occlusion;\n            i_0+= dx;\n            j_0+= dy;\n        }\n        sweep+= 1;\n    }\n    free(hull_buffer as *mut libc::c_void);\n}","src::kazmath::ray2::kmRay2IntersectBox":"pub unsafe extern \"C\" fn kmRay2IntersectBox(\n    mut ray: *const kmRay2,\n    mut p1: *const crate::src::kazmath::aabb2::kmVec2,\n    mut p2: *const crate::src::kazmath::aabb2::kmVec2,\n    mut p3: *const crate::src::kazmath::aabb2::kmVec2,\n    mut p4: *const crate::src::kazmath::aabb2::kmVec2,\n    mut intersection: Option<&mut crate::src::kazmath::aabb2::kmVec2>,\n    mut normal_out: Option<&mut crate::src::kazmath::aabb2::kmVec2>,\n) -> libc::c_uchar {\n    let mut intersected = 0 as libc::c_int as libc::c_uchar;\n    let mut intersect = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    let mut final_intersect = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    let mut normal = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    let mut distance = 10000.0f32;\n    let mut points: [*const crate::src::kazmath::aabb2::kmVec2; 4] = [0 as *const crate::src::kazmath::aabb2::kmVec2; 4];\n    points[0 as libc::c_int as usize]= p1;\n    points[1 as libc::c_int as usize]= p2;\n    points[2 as libc::c_int as usize]= p3;\n    points[3 as libc::c_int as usize]= p4;\n    let mut i = 0 as libc::c_int as libc::c_uint;\n    while i < 4 as libc::c_int as libc::c_uint {\n        let mut this_point = points[i as usize];\n        let mut next_point = if i == 3 as libc::c_int as libc::c_uint {\n            points[0 as libc::c_int as usize]\n        } else {\n            points[i.wrapping_add(1 as libc::c_int as libc::c_uint) as usize]\n        };\n        let mut other_point = if i == 3 as libc::c_int as libc::c_uint\n            || i == 0 as libc::c_int as libc::c_uint\n        {\n            points[1 as libc::c_int as usize]\n        } else {\n            points[0 as libc::c_int as usize]\n        };\n        if kmRay2IntersectLineSegment(ray, this_point, next_point, core::ptr::addr_of_mut!(intersect)) != 0 {\n            let mut tmp = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n            let mut this_distance = crate::src::kazmath::vec2::kmVec2Length(\n                crate::src::kazmath::vec2::kmVec2Subtract(core::ptr::addr_of_mut!(tmp), core::ptr::addr_of!(intersect), &(*ray).start),\n            );\n            let mut this_normal = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n            calculate_line_normal(\n                (*this_point),\n                (*next_point),\n                (*other_point),\n                Some(&mut this_normal),\n            );\n            if this_distance < distance\n                && crate::src::kazmath::vec2::kmVec2Dot(core::ptr::addr_of!(this_normal), &(*ray).dir) < 0.0f32\n            {\n                crate::src::kazmath::vec2::kmVec2Assign(core::ptr::addr_of_mut!(final_intersect), core::ptr::addr_of!(intersect));\n                distance= this_distance;\n                intersected= 1 as libc::c_int as libc::c_uchar;\n                crate::src::kazmath::vec2::kmVec2Assign(core::ptr::addr_of_mut!(normal), core::ptr::addr_of!(this_normal));\n            }\n        }\n        i= i.wrapping_add(1);\n    }\n    if intersected != 0 {\n        (*intersection.as_deref_mut().unwrap()).x= final_intersect.x;\n        (*intersection.as_deref_mut().unwrap()).y= final_intersect.y;\n        if !normal_out.as_deref().is_none() {\n            (*normal_out.as_deref_mut().unwrap()).x= normal.x;\n            (*normal_out.as_deref_mut().unwrap()).y= normal.y;\n        }else { (); }\n    }\n    return intersected;\n}","src::src::points::heman_points_from_density":"pub unsafe extern \"C\" fn heman_points_from_density(\n    mut density: *mut heman_image,\n    mut minradius: libc::c_float,\n    mut maxradius: libc::c_float,\n) -> *mut heman_points {\n    if (*density).nbands == 1 as libc::c_int {} else {\n        __assert_fail(\n            b\"density->nbands == 1\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/points.c\\0\" as *const u8 as *const libc::c_char,\n            215 as libc::c_int as libc::c_uint,\n            b\"heman_points *heman_points_from_density(heman_image *, float, float)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut width = 1 as libc::c_int as libc::c_float;\n    let mut height = 1 as libc::c_int as libc::c_float;\n    let mut maxattempts = 30 as libc::c_int;\n    let mut rscale = 1.0f32\n        / (2147483647 as libc::c_int as libc::c_uint)\n            .wrapping_mul(2 as libc::c_uint)\n            .wrapping_add(1 as libc::c_uint) as libc::c_float;\n    let mut seed = 0 as libc::c_int as libc::c_uint;\n    let mut rvec = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    rvec.y= maxradius;\n    rvec.x= rvec.y;\n    let mut gindex: libc::c_int = 0;\n    let mut cellsize = maxradius / sqrtf(2 as libc::c_int as libc::c_float);\n    let mut invcell = 1.0f32 / cellsize;\n    let mut ncols = ceil((width * invcell) as libc::c_double) as libc::c_int;\n    let mut nrows = ceil((height * invcell) as libc::c_double) as libc::c_int;\n    let mut maxcol = ncols - 1 as libc::c_int;\n    let mut maxrow = nrows - 1 as libc::c_int;\n    let mut ncells = ncols * nrows;\n    let mut ntexels = (cellsize * (*density).width as libc::c_float) as libc::c_int;\n    let mut gcapacity = ntexels * ntexels;\n    let mut grid = malloc(\n        (ncells as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong)\n            .wrapping_mul(gcapacity as libc::c_ulong),\n    ) as *mut libc::c_int;\n    let mut ngrid = malloc(\n        (ncells as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong),\n    ) as *mut libc::c_int;\n    let mut i = 0 as libc::c_int;\n    while i < ncells {\n        *ngrid.offset(i as isize) = 0 as libc::c_int;\n        i+= 1;\n    }\n    let mut actives = malloc(\n        (ncells as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong),\n    ) as *mut libc::c_int;\n    let mut nactives = 0 as libc::c_int;\n    let mut maxsamples = ncells * gcapacity;\n    let mut result = crate::src::src::image::heman_image_create(maxsamples, 1 as libc::c_int, 2 as libc::c_int);\n    let mut samples = (*result).data as *mut crate::src::kazmath::aabb2::kmVec2;\n    let mut nsamples = 0 as libc::c_int;\n    let mut pt = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    let fresh15 = seed;\n    seed= seed.wrapping_add(1);\n    pt.x= width * randhash(fresh15) as libc::c_float * rscale;\n    let fresh16 = seed;\n    seed= seed.wrapping_add(1);\n    pt.y= height * randhash(fresh16) as libc::c_float * rscale;\n    let fresh17 = nactives;\n    nactives= nactives + 1;\n    *actives.offset(fresh17 as isize) = nsamples;\n    gindex= (pt.x * invcell) as libc::c_int + ncols * (pt.y * invcell) as libc::c_int;\n    *grid\n        .offset(\n            (gcapacity * gindex + *ngrid.offset(gindex as isize)) as isize,\n        ) = nsamples;\n    *ngrid.offset(gindex as isize) += 1;\n    let fresh19 = nsamples;\n    nsamples= nsamples + 1;\n    *samples.offset(fresh19 as isize) = pt;\n    while nsamples < maxsamples {\n        let fresh20 = seed;\n        seed= seed.wrapping_add(1);\n        let mut aindex = (if randhashf(\n            fresh20,\n            0 as libc::c_int as libc::c_float,\n            nactives as libc::c_float,\n        ) > (nactives - 1 as libc::c_int) as libc::c_float\n        {\n            (nactives - 1 as libc::c_int) as libc::c_float\n        } else {\n            let fresh21 = seed;\n            seed= seed.wrapping_add(1);\n            randhashf(\n                fresh21,\n                0 as libc::c_int as libc::c_float,\n                nactives as libc::c_float,\n            )\n        }) as libc::c_int;\n        let mut sindex = *actives.offset(aindex as isize);\n        let mut found = 0 as libc::c_int;\n        let mut j = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n        let mut minj = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n        let mut maxj = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n        let mut delta = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n        let mut attempt: libc::c_int = 0;\n        attempt= 0 as libc::c_int;\n        while attempt < maxattempts && found == 0 {\n            pt= sample_annulus(maxradius, *samples.offset(sindex as isize), Some(&mut seed));\n            if !(pt.x < 0 as libc::c_int as libc::c_float || pt.x >= width\n                || pt.y < 0 as libc::c_int as libc::c_float || pt.y >= height)\n            {\n                maxj= pt;\n                minj= maxj;\n                crate::src::kazmath::vec2::kmVec2Add(core::ptr::addr_of_mut!(maxj), core::ptr::addr_of!(maxj), core::ptr::addr_of!(rvec));\n                crate::src::kazmath::vec2::kmVec2Subtract(core::ptr::addr_of_mut!(minj), core::ptr::addr_of!(minj), core::ptr::addr_of!(rvec));\n                crate::src::kazmath::vec2::kmVec2Scale(core::ptr::addr_of_mut!(minj), core::ptr::addr_of!(minj), invcell);\n                crate::src::kazmath::vec2::kmVec2Scale(core::ptr::addr_of_mut!(maxj), core::ptr::addr_of!(maxj), invcell);\n                minj.x= (if 0 as libc::c_int\n                    > (if maxcol > minj.x as libc::c_int {\n                        minj.x as libc::c_int\n                    } else {\n                        maxcol\n                    })\n                {\n                    0 as libc::c_int\n                } else if maxcol > minj.x as libc::c_int {\n                    minj.x as libc::c_int\n                } else {\n                    maxcol\n                }) as libc::c_float;\n                maxj.x= (if 0 as libc::c_int\n                    > (if maxcol > maxj.x as libc::c_int {\n                        maxj.x as libc::c_int\n                    } else {\n                        maxcol\n                    })\n                {\n                    0 as libc::c_int\n                } else if maxcol > maxj.x as libc::c_int {\n                    maxj.x as libc::c_int\n                } else {\n                    maxcol\n                }) as libc::c_float;\n                minj.y= (if 0 as libc::c_int\n                    > (if maxrow > minj.y as libc::c_int {\n                        minj.y as libc::c_int\n                    } else {\n                        maxrow\n                    })\n                {\n                    0 as libc::c_int\n                } else if maxrow > minj.y as libc::c_int {\n                    minj.y as libc::c_int\n                } else {\n                    maxrow\n                }) as libc::c_float;\n                maxj.y= (if 0 as libc::c_int\n                    > (if maxrow > maxj.y as libc::c_int {\n                        maxj.y as libc::c_int\n                    } else {\n                        maxrow\n                    })\n                {\n                    0 as libc::c_int\n                } else if maxrow > maxj.y as libc::c_int {\n                    maxj.y as libc::c_int\n                } else {\n                    maxrow\n                }) as libc::c_float;\n                let mut reject = 0 as libc::c_int;\n                let mut densityval: libc::c_float = 0.;\n                crate::src::src::image::heman_image_sample(density.as_mut(), pt.x, pt.y, core::ptr::addr_of_mut!(densityval));\n                densityval= sqrt(densityval as libc::c_double) as libc::c_float;\n                let mut mindist = maxradius - densityval * (maxradius - minradius);\n                let mut r2 = mindist * mindist;\n                j.y= minj.y;\n                while j.y <= maxj.y && reject == 0 {\n                    j.x= minj.x;\n                    while j.x <= maxj.x && reject == 0 {\n                        let mut g = (j.y as libc::c_int * ncols + j.x as libc::c_int)\n                            * gcapacity;\n                        while g\n                            < (j.y as libc::c_int * ncols + j.x as libc::c_int)\n                                * gcapacity\n                                + *ngrid\n                                    .offset(\n                                        (j.y as libc::c_int * ncols + j.x as libc::c_int) as isize,\n                                    )\n                        {\n                            let mut entry = *grid.offset(g as isize);\n                            if entry != sindex {\n                                crate::src::kazmath::vec2::kmVec2Subtract(\n                                    core::ptr::addr_of_mut!(delta),\n                                    core::ptr::addr_of_mut!(*samples.offset(entry as isize)),\n                                    core::ptr::addr_of!(pt),\n                                );\n                                if crate::src::kazmath::vec2::kmVec2LengthSq(core::ptr::addr_of!(delta)) < r2 {\n                                    reject= 1 as libc::c_int;\n                                }\n                            }\n                            g+= 1;\n                        }\n                        j.x+= 1.;\n                    }\n                    j.y+= 1.;\n                }\n                if !(reject != 0) {\n                    found= 1 as libc::c_int;\n                }\n            }\n            attempt+= 1;\n        }\n        if found != 0\n            && *ngrid\n                .offset(\n                    ((pt.x * invcell) as libc::c_int\n                        + ncols * (pt.y * invcell) as libc::c_int) as isize,\n                ) >= gcapacity\n        {\n            found= 0 as libc::c_int;\n        }\n        if found != 0 {\n            let fresh22 = nactives;\n            nactives= nactives + 1;\n            *actives.offset(fresh22 as isize) = nsamples;\n            gindex= (pt.x * invcell) as libc::c_int\n                + ncols * (pt.y * invcell) as libc::c_int;\n            *grid\n                .offset(\n                    (gcapacity * gindex + *ngrid.offset(gindex as isize)) as isize,\n                ) = nsamples;\n            *ngrid.offset(gindex as isize) += 1;\n            let fresh24 = nsamples;\n            nsamples= nsamples + 1;\n            *samples.offset(fresh24 as isize) = pt;\n        } else {\n            nactives-= 1;\n            if nactives <= 0 as libc::c_int {\n                break;\n            }\n            *actives.offset(aindex as isize) = *actives.offset(nactives as isize);\n        }\n    }\n    (*result).width= nsamples;\n    free(grid as *mut libc::c_void);\n    free(ngrid as *mut libc::c_void);\n    free(actives as *mut libc::c_void);\n    return result;\n}","src::src::draw::heman_draw_points":"pub unsafe extern \"C\" fn heman_draw_points(\n    mut target: Option<&mut heman_image>,\n    mut pts: *mut heman_points,\n    mut val: libc::c_float,\n) {\n    let mut src = (*pts).data;\n    let mut k = 0 as libc::c_int;\n    while k < (*pts).width {\n        let mut x = *src.offset(0 as libc::c_int as isize);\n        let mut y = *src.offset(1 as libc::c_int as isize);\n        src= src.offset((*pts).nbands as isize);\n        let mut i = (x * (*target.as_deref().unwrap()).width as libc::c_float) as libc::c_int;\n        let mut j = (y * (*target.as_deref().unwrap()).height as libc::c_float) as libc::c_int;\n        if !(i < 0 as libc::c_int || i >= (*target.as_deref().unwrap()).width || j < 0 as libc::c_int\n            || j >= (*target.as_deref().unwrap()).height)\n        {\n            let mut texel = crate::src::src::image::heman_image_texel(target.as_deref_mut(), i, j);\n            let mut c = 0 as libc::c_int;\n            while c < (*target.as_deref().unwrap()).nbands {\n                let fresh0 = texel;\n                texel= texel.offset(1);\n                *fresh0= val;\n                c+= 1;\n            }\n        }\n        k+= 1;\n    }\n}","src::src::noise::fastFloor":"unsafe extern \"C\" fn fastFloor(mut x: libc::c_double) -> libc::c_int {\n    let mut xi = x as libc::c_int;\n    return if x < xi as libc::c_double { xi - 1 as libc::c_int } else { xi };\n}","src::kazmath::mat3::kmMat3LookAt":"pub unsafe extern \"C\" fn kmMat3LookAt(\n    mut pOut: Option<&mut kmMat3>,\n    mut pEye: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pCenter: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pUp: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut kmMat3 {\n    let mut f = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut up = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut s = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut u = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    crate::src::kazmath::vec3::kmVec3Subtract(core::ptr::addr_of_mut!(f), pCenter, pEye);\n    crate::src::kazmath::vec3::kmVec3Normalize(core::ptr::addr_of_mut!(f), core::ptr::addr_of!(f));\n    crate::src::kazmath::vec3::kmVec3Assign(core::ptr::addr_of_mut!(up), pUp);\n    crate::src::kazmath::vec3::kmVec3Normalize(core::ptr::addr_of_mut!(up), core::ptr::addr_of!(up));\n    crate::src::kazmath::vec3::kmVec3Cross(core::ptr::addr_of_mut!(s), core::ptr::addr_of!(f), core::ptr::addr_of!(up));\n    crate::src::kazmath::vec3::kmVec3Normalize(core::ptr::addr_of_mut!(s), core::ptr::addr_of!(s));\n    crate::src::kazmath::vec3::kmVec3Cross(core::ptr::addr_of_mut!(u), core::ptr::addr_of!(s), core::ptr::addr_of!(f));\n    crate::src::kazmath::vec3::kmVec3Normalize(core::ptr::addr_of_mut!(s), core::ptr::addr_of!(s));\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int as usize]= s.x;\n    (*pOut.as_deref_mut().unwrap()).mat[3 as libc::c_int as usize]= s.y;\n    (*pOut.as_deref_mut().unwrap()).mat[6 as libc::c_int as usize]= s.z;\n    (*pOut.as_deref_mut().unwrap()).mat[1 as libc::c_int as usize]= u.x;\n    (*pOut.as_deref_mut().unwrap()).mat[4 as libc::c_int as usize]= u.y;\n    (*pOut.as_deref_mut().unwrap()).mat[7 as libc::c_int as usize]= u.z;\n    (*pOut.as_deref_mut().unwrap()).mat[2 as libc::c_int as usize]= -f.x;\n    (*pOut.as_deref_mut().unwrap()).mat[5 as libc::c_int as usize]= -f.y;\n    (*pOut.as_deref_mut().unwrap()).mat[8 as libc::c_int as usize]= -f.z;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::mat4::kmMat4AssignMat3":"pub unsafe extern \"C\" fn kmMat4AssignMat3(\n    mut pOut: Option<&mut crate::src::kazmath::mat3::kmMat4>,\n    mut pIn: *const crate::src::kazmath::mat3::kmMat3,\n) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    kmMat4Identity(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()));\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int as usize]= (*pIn).mat[0 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[1 as libc::c_int as usize]= (*pIn).mat[1 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[2 as libc::c_int as usize]= (*pIn).mat[2 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[3 as libc::c_int as usize]= 0.0f64 as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).mat[4 as libc::c_int as usize]= (*pIn).mat[3 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[5 as libc::c_int as usize]= (*pIn).mat[4 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[6 as libc::c_int as usize]= (*pIn).mat[5 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[7 as libc::c_int as usize]= 0.0f64 as libc::c_float;\n    (*pOut.as_deref_mut().unwrap()).mat[8 as libc::c_int as usize]= (*pIn).mat[6 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[9 as libc::c_int as usize]= (*pIn).mat[7 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[10 as libc::c_int as usize]= (*pIn).mat[8 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).mat[11 as libc::c_int as usize]= 0.0f64 as libc::c_float;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::mat4::kmMat4RotationY":"pub unsafe extern \"C\" fn kmMat4RotationY(\n    mut pOut: Option<&mut crate::src::kazmath::mat3::kmMat4>,\n    mut radians: libc::c_float,\n) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    (*pOut.as_deref_mut().unwrap()).mat[0 as libc::c_int as usize]= cosf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[1 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[2 as libc::c_int as usize]= -sinf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[3 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[4 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[5 as libc::c_int as usize]= 1.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[6 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[7 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[8 as libc::c_int as usize]= sinf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[9 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[10 as libc::c_int as usize]= cosf(radians);\n    (*pOut.as_deref_mut().unwrap()).mat[11 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[12 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[13 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[14 as libc::c_int as usize]= 0.0f32;\n    (*pOut.as_deref_mut().unwrap()).mat[15 as libc::c_int as usize]= 1.0f32;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::ray2::kmRay2IntersectTriangle":"pub unsafe extern \"C\" fn kmRay2IntersectTriangle(\n    mut ray: *const kmRay2,\n    mut p1: *const crate::src::kazmath::aabb2::kmVec2,\n    mut p2: *const crate::src::kazmath::aabb2::kmVec2,\n    mut p3: *const crate::src::kazmath::aabb2::kmVec2,\n    mut intersection: Option<&mut crate::src::kazmath::aabb2::kmVec2>,\n    mut normal_out: Option<&mut crate::src::kazmath::aabb2::kmVec2>,\n    mut distance_out: Option<&mut libc::c_float>,\n) -> libc::c_uchar {\n    let mut intersect = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    let mut final_intersect = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    let mut normal = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    let mut distance = 10000.0f32;\n    let mut intersected = 0 as libc::c_int as libc::c_uchar;\n    if kmRay2IntersectLineSegment(ray, p1, p2, core::ptr::addr_of_mut!(intersect)) != 0 {\n        let mut tmp = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n        let mut this_distance = crate::src::kazmath::vec2::kmVec2Length(\n            crate::src::kazmath::vec2::kmVec2Subtract(core::ptr::addr_of_mut!(tmp), core::ptr::addr_of!(intersect), &(*ray).start),\n        );\n        let mut this_normal = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n        calculate_line_normal((*p1), (*p2), (*p3), Some(&mut this_normal));\n        if this_distance < distance && crate::src::kazmath::vec2::kmVec2Dot(core::ptr::addr_of!(this_normal), &(*ray).dir) < 0.0f32\n        {\n            final_intersect.x= intersect.x;\n            final_intersect.y= intersect.y;\n            distance= this_distance;\n            crate::src::kazmath::vec2::kmVec2Assign(core::ptr::addr_of_mut!(normal), core::ptr::addr_of!(this_normal));\n            intersected= 1 as libc::c_int as libc::c_uchar;\n        }\n    }\n    if kmRay2IntersectLineSegment(ray, p2, p3, core::ptr::addr_of_mut!(intersect)) != 0 {\n        let mut tmp_0 = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n        let mut this_distance_0 = crate::src::kazmath::vec2::kmVec2Length(\n            crate::src::kazmath::vec2::kmVec2Subtract(core::ptr::addr_of_mut!(tmp_0), core::ptr::addr_of!(intersect), &(*ray).start),\n        );\n        let mut this_normal_0 = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n        calculate_line_normal((*p2), (*p3), (*p1), Some(&mut this_normal_0));\n        if this_distance_0 < distance\n            && crate::src::kazmath::vec2::kmVec2Dot(core::ptr::addr_of!(this_normal_0), &(*ray).dir) < 0.0f32\n        {\n            final_intersect.x= intersect.x;\n            final_intersect.y= intersect.y;\n            distance= this_distance_0;\n            crate::src::kazmath::vec2::kmVec2Assign(core::ptr::addr_of_mut!(normal), core::ptr::addr_of!(this_normal_0));\n            intersected= 1 as libc::c_int as libc::c_uchar;\n        }\n    }\n    if kmRay2IntersectLineSegment(ray, p3, p1, core::ptr::addr_of_mut!(intersect)) != 0 {\n        let mut tmp_1 = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n        let mut this_distance_1 = crate::src::kazmath::vec2::kmVec2Length(\n            crate::src::kazmath::vec2::kmVec2Subtract(core::ptr::addr_of_mut!(tmp_1), core::ptr::addr_of!(intersect), &(*ray).start),\n        );\n        let mut this_normal_1 = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n        calculate_line_normal((*p3), (*p1), (*p2), Some(&mut this_normal_1));\n        if this_distance_1 < distance\n            && crate::src::kazmath::vec2::kmVec2Dot(core::ptr::addr_of!(this_normal_1), &(*ray).dir) < 0.0f32\n        {\n            final_intersect.x= intersect.x;\n            final_intersect.y= intersect.y;\n            distance= this_distance_1;\n            crate::src::kazmath::vec2::kmVec2Assign(core::ptr::addr_of_mut!(normal), core::ptr::addr_of!(this_normal_1));\n            intersected= 1 as libc::c_int as libc::c_uchar;\n        }\n    }\n    if intersected != 0 {\n        (*intersection.as_deref_mut().unwrap()).x= final_intersect.x;\n        (*intersection.as_deref_mut().unwrap()).y= final_intersect.y;\n        if !normal_out.as_deref().is_none() {\n            (*normal_out.as_deref_mut().unwrap()).x= normal.x;\n            (*normal_out.as_deref_mut().unwrap()).y= normal.y;\n        }else { (); }\n        if distance != 0. {\n            *distance_out.as_deref_mut().unwrap()= distance;\n        }\n    }\n    return intersected;\n}","src::src::image::heman_image_texel":"pub unsafe extern \"C\" fn heman_image_texel(\n    mut img: Option<&mut heman_image>,\n    mut x: libc::c_int,\n    mut y: libc::c_int,\n) -> *mut libc::c_float {\n    return (*img.as_deref().unwrap()).data\n        .offset((y * (*img.as_deref().unwrap()).width * (*img.as_deref().unwrap()).nbands) as isize)\n        .offset((x * (*img.as_deref().unwrap()).nbands) as isize);\n}","src::kazmath::mat4::kmMat4Assign":"pub unsafe extern \"C\" fn kmMat4Assign(\n    mut pOut: *mut crate::src::kazmath::mat3::kmMat4,\n    mut pIn: *const crate::src::kazmath::mat3::kmMat4,\n) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    if pOut != pIn as *mut crate::src::kazmath::mat3::kmMat4\n        && !(b\"You have tried to self-assign!!\\0\" as *const u8 as *const libc::c_char)\n            .is_null()\n    {} else {\n        __assert_fail(\n            b\"pOut != pIn && \\\"You have tried to self-assign!!\\\"\\0\" as *const u8\n                as *const libc::c_char,\n            b\"../kazmath/mat4.c\\0\" as *const u8 as *const libc::c_char,\n            272 as libc::c_int as libc::c_uint,\n            b\"kmMat4 *kmMat4Assign(kmMat4 *, const kmMat4 *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    memcpy(\n        (*pOut).mat.as_mut_ptr() as *mut libc::c_void,\n        ((*pIn).mat).as_ptr() as *const libc::c_void,\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(16 as libc::c_int as libc::c_ulong),\n    );\n    return pOut;\n}","src::src::noise::extrapolate3":"unsafe extern \"C\" fn extrapolate3(\n    mut ctx: *mut osn_context,\n    mut xsb: libc::c_int,\n    mut ysb: libc::c_int,\n    mut zsb: libc::c_int,\n    mut dx: libc::c_double,\n    mut dy: libc::c_double,\n    mut dz: libc::c_double,\n) -> libc::c_double {\n    let mut perm = (*ctx).perm;\n    let mut permGradIndex3D = (*ctx).permGradIndex3D;\n    let mut index = *permGradIndex3D\n        .offset(\n            (*perm\n                .offset(\n                    (*perm.offset((xsb & 0xff as libc::c_int) as isize) as libc::c_int\n                        + ysb & 0xff as libc::c_int) as isize,\n                ) as libc::c_int + zsb & 0xff as libc::c_int) as isize,\n        ) as libc::c_int;\n    return crate::src::src::noise::gradients3D[index as usize] as libc::c_int as libc::c_double * dx\n        + crate::src::src::noise::gradients3D[(index + 1 as libc::c_int) as usize] as libc::c_int\n            as libc::c_double * dy\n        + crate::src::src::noise::gradients3D[(index + 2 as libc::c_int) as usize] as libc::c_int\n            as libc::c_double * dz;\n}","src::src::gaussian::generate_gaussian_splat":"pub unsafe extern \"C\" fn generate_gaussian_splat(\n    mut target: *mut libc::c_float,\n    mut fwidth: libc::c_int,\n) {\n    let mut gaussian_row = malloc(\n        (fwidth as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong),\n    ) as *mut libc::c_int;\n    generate_gaussian_row(gaussian_row, fwidth);\n    let mut shift = (1 as libc::c_int) << fwidth - 1 as libc::c_int;\n    let mut scale = (1.0f64 / (shift * shift) as libc::c_double) as libc::c_float;\n    let mut gptr = target;\n    let mut j = 0 as libc::c_int;\n    while j < fwidth {\n        let mut i = 0 as libc::c_int;\n        while i < fwidth {\n            let fresh1 = gptr;\n            gptr= gptr.offset(1);\n            *fresh1= (*gaussian_row.offset(i as isize)\n                * *gaussian_row.offset(j as isize)) as libc::c_float * scale;\n            i+= 1;\n        }\n        j+= 1;\n    }\n    free(gaussian_row as *mut libc::c_void);\n}","src::src::lighting::heman_lighting_compute_occlusion":"pub unsafe extern \"C\" fn heman_lighting_compute_occlusion(\n    mut heightmap: *mut heman_image,\n) -> *mut /* owning */ heman_image {\n    if (*heightmap).nbands == 1 as libc::c_int {} else {\n        __assert_fail(\n            b\"heightmap->nbands == 1\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/lighting.c\\0\" as *const u8 as *const libc::c_char,\n            227 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_lighting_compute_occlusion(heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut width = (*heightmap).width;\n    let mut height = (*heightmap).height;\n    let mut result = crate::src::src::image::heman_image_create(width, height, 1 as libc::c_int);\n    memset(\n        (*result).data as *mut libc::c_void,\n        0 as libc::c_int,\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(width as libc::c_ulong)\n            .wrapping_mul(height as libc::c_ulong),\n    );\n    let scans: [libc::c_int; 32] = [\n        1 as libc::c_int,\n        0 as libc::c_int,\n        0 as libc::c_int,\n        1 as libc::c_int,\n        -(1 as libc::c_int),\n        0 as libc::c_int,\n        0 as libc::c_int,\n        -(1 as libc::c_int),\n        1 as libc::c_int,\n        1 as libc::c_int,\n        -(1 as libc::c_int),\n        -(1 as libc::c_int),\n        1 as libc::c_int,\n        -(1 as libc::c_int),\n        -(1 as libc::c_int),\n        1 as libc::c_int,\n        2 as libc::c_int,\n        1 as libc::c_int,\n        2 as libc::c_int,\n        -(1 as libc::c_int),\n        -(2 as libc::c_int),\n        1 as libc::c_int,\n        -(2 as libc::c_int),\n        -(1 as libc::c_int),\n        1 as libc::c_int,\n        2 as libc::c_int,\n        1 as libc::c_int,\n        -(2 as libc::c_int),\n        -(1 as libc::c_int),\n        2 as libc::c_int,\n        -(1 as libc::c_int),\n        -(2 as libc::c_int),\n    ];\n    let mut startpts = malloc(\n        ((::std::mem::size_of::<libc::c_int>() as libc::c_ulong)\n            .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(3 as libc::c_int as libc::c_ulong) as libc::c_float\n            * crate::src::kazmath::utility::kmMax(width as libc::c_float, height as libc::c_float)) as libc::c_ulong,\n    ) as *mut libc::c_int;\n    let mut i = 0 as libc::c_int;\n    while i < 16 as libc::c_int {\n        let mut dx = scans[(i * 2 as libc::c_int) as usize];\n        let mut dy = scans[(i * 2 as libc::c_int + 1 as libc::c_int) as usize];\n        horizon_scan(heightmap, result, startpts, dx, dy);\n        i+= 1;\n    }\n    let mut i_0 = 0 as libc::c_int;\n    while i_0 < width * height {\n        *(*result).data\n            .offset(i_0 as isize) = 1.0f32 - *(*result).data.offset(i_0 as isize);\n        if *(*result).data.offset(i_0 as isize) as libc::c_double >= 0.0f64\n            && *(*result).data.offset(i_0 as isize) <= 1.0f32\n        {} else {\n            __assert_fail(\n                b\"result->data[i] >= 0.0 && result->data[i] <= 1.0f\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"../src/lighting.c\\0\" as *const u8 as *const libc::c_char,\n                253 as libc::c_int as libc::c_uint,\n                b\"heman_image *heman_lighting_compute_occlusion(heman_image *)\\0\" as *const u8 as *const libc::c_char,\n            );\n        }\n        i_0+= 1;\n    }\n    free(startpts as *mut libc::c_void);\n    return result;\n}","src::kazmath::mat4::kmMat4RotationToAxisAngle":"pub unsafe extern \"C\" fn kmMat4RotationToAxisAngle(\n    mut pAxis: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut radians: Option<&mut libc::c_float>,\n    mut pIn: *const crate::src::kazmath::mat3::kmMat4,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    let mut temp = crate::src::kazmath::mat3::kmQuaternion {\n        x: 0.,\n        y: 0.,\n        z: 0.,\n        w: 0.,\n    };\n    let mut rotation = crate::src::kazmath::mat3::kmMat3 { mat: [0.; 9] };\n    kmMat4ExtractRotation(Some(&mut rotation), pIn);\n    crate::src::kazmath::quaternion::kmQuaternionRotationMatrix(Some(&mut temp), core::ptr::addr_of!(rotation));\n    crate::src::kazmath::quaternion::kmQuaternionToAxisAngle(core::ptr::addr_of!(temp), pAxis.as_deref_mut(), radians.as_deref_mut());\n    return pAxis.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::mat4::kmMat4Translation":"pub unsafe extern \"C\" fn kmMat4Translation(\n    mut pOut: *mut crate::src::kazmath::mat3::kmMat4,\n    mut x: libc::c_float,\n    mut y: libc::c_float,\n    mut z: libc::c_float,\n) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    memset(\n        (*pOut).mat.as_mut_ptr() as *mut libc::c_void,\n        0 as libc::c_int,\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(16 as libc::c_int as libc::c_ulong),\n    );\n    (*pOut).mat[0 as libc::c_int as usize]= 1.0f32;\n    (*pOut).mat[5 as libc::c_int as usize]= 1.0f32;\n    (*pOut).mat[10 as libc::c_int as usize]= 1.0f32;\n    (*pOut).mat[12 as libc::c_int as usize]= x;\n    (*pOut).mat[13 as libc::c_int as usize]= y;\n    (*pOut).mat[14 as libc::c_int as usize]= z;\n    (*pOut).mat[15 as libc::c_int as usize]= 1.0f32;\n    return pOut;\n}","src::src::generate::heman_generate_rock_heightmap":"pub unsafe extern \"C\" fn heman_generate_rock_heightmap(\n    mut width: libc::c_int,\n    mut height: libc::c_int,\n    mut seed: libc::c_int,\n) -> *mut /* owning */ heman_image {\n    let mut noisetex = heman_internal_generate_rock_noise(width, height, seed);\n    let mut heightmap = crate::src::src::image::heman_image_create(width, height, 1 as libc::c_int);\n    let mut data = (*heightmap).data;\n    let mut invh = 1.0f32 / height as libc::c_float;\n    let mut invw = 1.0f32 / width as libc::c_float;\n    let mut hh = height / 2 as libc::c_int;\n    let mut hw = width / 2 as libc::c_int;\n    let mut y: libc::c_int = 0;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut vv = (y - hh) as libc::c_float * invh;\n        let mut dst = data.offset((y * width) as isize);\n        let mut x = 0 as libc::c_int;\n        while x < width {\n            let mut v = y as libc::c_float * invh;\n            let mut u = x as libc::c_float * invw;\n            let mut n: libc::c_float = 0.;\n            crate::src::src::image::heman_image_sample(noisetex.as_mut(), u, v, core::ptr::addr_of_mut!(n));\n            u= (x - hw) as libc::c_float * invw;\n            v= vv;\n            let mut r = (0.3f64 + n as libc::c_double) as libc::c_float;\n            if u * u + v * v > r * r {\n                let fresh6 = dst;\n                dst= dst.offset(1);\n                *fresh6= 0 as libc::c_int as libc::c_float;\n            } else {\n                let mut z = sqrt((r * r - u * u - v * v) as libc::c_double)\n                    as libc::c_float;\n                let fresh7 = dst;\n                dst= dst.offset(1);\n                *fresh7= z;\n            }\n            x+= 1;\n        }\n        y+= 1;\n    }\n    crate::src::src::image::heman_image_destroy(noisetex);\n    return heightmap;\n}","src::kazmath::quaternion::kmQuaternionInverse":"pub unsafe extern \"C\" fn kmQuaternionInverse(\n    mut pOut: Option<&mut crate::src::kazmath::mat3::kmQuaternion>,\n    mut pIn: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> *mut crate::src::kazmath::mat3::kmQuaternion {\n    let mut l = kmQuaternionLength(pIn);\n    if fabs(l as libc::c_double) < 0.0001f64 {\n        (*pOut.as_deref_mut().unwrap()).x= 0.0f64 as libc::c_float;\n        (*pOut.as_deref_mut().unwrap()).y= 0.0f64 as libc::c_float;\n        (*pOut.as_deref_mut().unwrap()).z= 0.0f64 as libc::c_float;\n        (*pOut.as_deref_mut().unwrap()).w= 0.0f64 as libc::c_float;\n        return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n    }\n    (*pOut.as_deref_mut().unwrap()).x= -(*pIn).x;\n    (*pOut.as_deref_mut().unwrap()).y= -(*pIn).y;\n    (*pOut.as_deref_mut().unwrap()).z= -(*pIn).z;\n    (*pOut.as_deref_mut().unwrap()).w= (*pIn).w;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::quaternion::kmQuaternionScale":"pub unsafe extern \"C\" fn kmQuaternionScale(\n    mut pOut: *mut crate::src::kazmath::mat3::kmQuaternion,\n    mut pIn: *const crate::src::kazmath::mat3::kmQuaternion,\n    mut s: libc::c_float,\n) -> *mut crate::src::kazmath::mat3::kmQuaternion {\n    (*pOut).x= (*pIn).x * s;\n    (*pOut).y= (*pIn).y * s;\n    (*pOut).z= (*pIn).z * s;\n    (*pOut).w= (*pIn).w * s;\n    return pOut;\n}","src::src::noise::open_simplex_noise_free":"pub unsafe extern \"C\" fn open_simplex_noise_free(mut ctx: *mut /* owning */ osn_context) {\n    if ctx.is_null() {();\n        return;\n    }\n    if !(*ctx).perm.is_null() {\n        free((*ctx).perm as *mut libc::c_void);\n        (*ctx).perm= 0 as *mut int16_t;\n    }else { (); }\n    if !(*ctx).permGradIndex3D.is_null() {\n        free((*ctx).permGradIndex3D as *mut libc::c_void);\n        (*ctx).permGradIndex3D= 0 as *mut int16_t;\n    }else { (); }\n    free(ctx as *mut libc::c_void);\n}","src::src::lighting::heman_lighting_set_occlusion_scale":"pub unsafe extern \"C\" fn heman_lighting_set_occlusion_scale(mut s: libc::c_float) {\n    crate::src::src::lighting::_occlusion_scale= s;\n}","src::kazmath::aabb2::kmAABB2Translate":"pub unsafe extern \"C\" fn kmAABB2Translate(\n    mut pOut: *mut kmAABB2,\n    mut pIn: *const kmAABB2,\n    mut translation: *const kmVec2,\n) -> *mut kmAABB2 {\n    crate::src::kazmath::vec2::kmVec2Add(core::ptr::addr_of_mut!((*pOut).min), &(*pIn).min, translation);\n    crate::src::kazmath::vec2::kmVec2Add(core::ptr::addr_of_mut!((*pOut).max), &(*pIn).max, translation);\n    return pOut;\n}","src::kazmath::aabb3::kmAABB3Assign":"pub unsafe extern \"C\" fn kmAABB3Assign(\n    mut pOut: *mut kmAABB3,\n    mut pIn: *const kmAABB3,\n) -> *mut kmAABB3 {\n    crate::src::kazmath::vec3::kmVec3Assign(core::ptr::addr_of_mut!((*pOut).min), &(*pIn).min);\n    crate::src::kazmath::vec3::kmVec3Assign(core::ptr::addr_of_mut!((*pOut).max), &(*pIn).max);\n    return pOut;\n}","src::kazmath::vec3::kmVec3TransformCoord":"pub unsafe extern \"C\" fn kmVec3TransformCoord(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pV: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pM: *const crate::src::kazmath::mat3::kmMat4,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    let mut v = crate::src::kazmath::plane::kmVec4 {\n        x: 0.,\n        y: 0.,\n        z: 0.,\n        w: 0.,\n    };\n    let mut inV = crate::src::kazmath::plane::kmVec4 {\n        x: 0.,\n        y: 0.,\n        z: 0.,\n        w: 0.,\n    };\n    crate::src::kazmath::vec4::kmVec4Fill(Some(&mut inV), (*pV).x, (*pV).y, (*pV).z, 1.0f64 as libc::c_float);\n    crate::src::kazmath::vec4::kmVec4Transform(Some(&mut v), core::ptr::addr_of!(inV), pM);\n    (*pOut.as_deref_mut().unwrap()).x= v.x / v.w;\n    (*pOut.as_deref_mut().unwrap()).y= v.y / v.w;\n    (*pOut.as_deref_mut().unwrap()).z= v.z / v.w;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::vec2::kmVec2DegreesBetween":"pub unsafe extern \"C\" fn kmVec2DegreesBetween(\n    mut v1: *const crate::src::kazmath::aabb2::kmVec2,\n    mut v2: *const crate::src::kazmath::aabb2::kmVec2,\n) -> libc::c_float {\n    if kmVec2AreEqual(v1, v2) != 0 {\n        return 0.0f64 as libc::c_float;\n    }\n    let mut t1 = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    let mut t2 = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    kmVec2Normalize(core::ptr::addr_of_mut!(t1), v1);\n    kmVec2Normalize(core::ptr::addr_of_mut!(t2), v2);\n    let mut cross = kmVec2Cross(core::ptr::addr_of!(t1), core::ptr::addr_of!(t2));\n    let mut dot = kmVec2Dot(core::ptr::addr_of!(t1), core::ptr::addr_of!(t2));\n    if dot as libc::c_double > 1.0f64 {\n        dot= 1.0f64 as libc::c_float;\n    }\n    if (dot as libc::c_double) < -1.0f64 {\n        dot= -1.0f64 as libc::c_float;\n    }\n    return crate::src::kazmath::utility::kmRadiansToDegrees(\n        atan2(cross as libc::c_double, dot as libc::c_double) as libc::c_float,\n    );\n}","src::src::ops::heman_get_num_threads":"pub unsafe extern \"C\" fn heman_get_num_threads() -> libc::c_int {\n    return omp_get_max_threads();\n}","src::src::image::heman_image_data":"pub unsafe extern \"C\" fn heman_image_data(\n    mut img: *mut heman_image,\n) -> *mut libc::c_float {\n    return (*img).data;\n}","src::kazmath::vec3::kmVec3Fill":"pub unsafe extern \"C\" fn kmVec3Fill(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut x: libc::c_float,\n    mut y: libc::c_float,\n    mut z: libc::c_float,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    (*pOut.as_deref_mut().unwrap()).x= x;\n    (*pOut.as_deref_mut().unwrap()).y= y;\n    (*pOut.as_deref_mut().unwrap()).z= z;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::vec3::kmVec3Dot":"pub unsafe extern \"C\" fn kmVec3Dot(\n    mut pV1: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pV2: *const crate::src::kazmath::aabb3::kmVec3,\n) -> libc::c_float {\n    return (*pV1).x * (*pV2).x + (*pV1).y * (*pV2).y + (*pV1).z * (*pV2).z;\n}","src::kazmath::vec3::kmVec3MultiplyMat3":"pub unsafe extern \"C\" fn kmVec3MultiplyMat3(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pV: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pM: *const crate::src::kazmath::mat3::kmMat3,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    let mut v = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    v.x= (*pV).x * (*pM).mat[0 as libc::c_int as usize]\n        + (*pV).y * (*pM).mat[3 as libc::c_int as usize]\n        + (*pV).z * (*pM).mat[6 as libc::c_int as usize];\n    v.y= (*pV).x * (*pM).mat[1 as libc::c_int as usize]\n        + (*pV).y * (*pM).mat[4 as libc::c_int as usize]\n        + (*pV).z * (*pM).mat[7 as libc::c_int as usize];\n    v.z= (*pV).x * (*pM).mat[2 as libc::c_int as usize]\n        + (*pV).y * (*pM).mat[5 as libc::c_int as usize]\n        + (*pV).z * (*pM).mat[8 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).x= v.x;\n    (*pOut.as_deref_mut().unwrap()).y= v.y;\n    (*pOut.as_deref_mut().unwrap()).z= v.z;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::vec4::kmVec4LengthSq":"pub unsafe extern \"C\" fn kmVec4LengthSq(mut pIn: *const crate::src::kazmath::plane::kmVec4) -> libc::c_float {\n    return crate::src::kazmath::utility::kmSQR((*pIn).x) + crate::src::kazmath::utility::kmSQR((*pIn).y) + crate::src::kazmath::utility::kmSQR((*pIn).z) + crate::src::kazmath::utility::kmSQR((*pIn).w);\n}","src::src::ops::heman_ops_merge_political":"pub unsafe extern \"C\" fn heman_ops_merge_political(\n    mut hmap: *mut heman_image,\n    mut cmap: *mut heman_image,\n    mut ocean: heman_color,\n) -> *mut /* owning */ heman_image {\n    if (*hmap).nbands == 1 as libc::c_int {} else {\n        __assert_fail(\n            b\"hmap->nbands == 1\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            506 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_merge_political(heman_image *, heman_image *, heman_color)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if (*cmap).nbands == 3 as libc::c_int {} else {\n        __assert_fail(\n            b\"cmap->nbands == 3\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            507 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_merge_political(heman_image *, heman_image *, heman_color)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut result = crate::src::src::image::heman_image_create((*hmap).width, (*hmap).height, 4 as libc::c_int);\n    let mut pheight = (*hmap).data;\n    let mut pcolour = (*cmap).data;\n    let mut pmerged = (*result).data;\n    let mut inv = 1.0f32 / 255.0f32;\n    let mut oceanr = (ocean >> 16 as libc::c_int) as libc::c_float * inv;\n    let mut oceang = (ocean >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint)\n        as libc::c_float * inv;\n    let mut oceanb = (ocean & 0xff as libc::c_int as libc::c_uint) as libc::c_float\n        * inv;\n    let mut size = (*hmap).height * (*hmap).width;\n    let mut minh = 1000 as libc::c_int as libc::c_float;\n    let mut maxh = -(1000 as libc::c_int) as libc::c_float;\n    let mut i = 0 as libc::c_int;\n    while i < size {\n        minh= if minh > *pheight.offset(i as isize) {\n            *pheight.offset(i as isize)\n        } else {\n            minh\n        };\n        maxh= if maxh > *pheight.offset(i as isize) {\n            *pheight.offset(i as isize)\n        } else {\n            maxh\n        };\n        i+= 1;\n    }\n    let mut i_0 = 0 as libc::c_int;\n    while i_0 < size {\n        let fresh23 = pheight;\n        pheight= pheight.offset(1);\n        let mut h = (*fresh23);\n        if h < 0 as libc::c_int as libc::c_float {\n            let fresh24 = pmerged;\n            pmerged= pmerged.offset(1);\n            *fresh24= oceanr;\n            let fresh25 = pmerged;\n            pmerged= pmerged.offset(1);\n            *fresh25= oceang;\n            let fresh26 = pmerged;\n            pmerged= pmerged.offset(1);\n            *fresh26= oceanb;\n            pcolour= pcolour.offset(3 as libc::c_int as isize);\n        } else {\n            let fresh27 = pcolour;\n            pcolour= pcolour.offset(1);\n            let fresh28 = pmerged;\n            pmerged= pmerged.offset(1);\n            *fresh28= (*fresh27);\n            let fresh29 = pcolour;\n            pcolour= pcolour.offset(1);\n            let fresh30 = pmerged;\n            pmerged= pmerged.offset(1);\n            *fresh30= (*fresh29);\n            let fresh31 = pcolour;\n            pcolour= pcolour.offset(1);\n            let fresh32 = pmerged;\n            pmerged= pmerged.offset(1);\n            *fresh32= (*fresh31);\n        }\n        let fresh33 = pmerged;\n        pmerged= pmerged.offset(1);\n        *fresh33= (h - minh) / (maxh - minh);\n        i_0+= 1;\n    }\n    return result;\n}","src::kazmath::mat3::kmMat3Identity":"pub unsafe extern \"C\" fn kmMat3Identity(mut pOut: *mut kmMat3) -> *mut kmMat3 {\n    memset(\n        (*pOut).mat.as_mut_ptr() as *mut libc::c_void,\n        0 as libc::c_int,\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(9 as libc::c_int as libc::c_ulong),\n    );\n    (*pOut).mat[8 as libc::c_int as usize]= 1.0f32; (*pOut).mat[4 as libc::c_int as usize]= (*pOut).mat[8 as libc::c_int as usize]; (*pOut).mat[0 as libc::c_int as usize]= (*pOut).mat[4 as libc::c_int as usize];\n    return pOut;\n}","src::kazmath::vec2::kmVec2RotateBy":"pub unsafe extern \"C\" fn kmVec2RotateBy(\n    mut pOut: Option<&mut crate::src::kazmath::aabb2::kmVec2>,\n    mut pIn: *const crate::src::kazmath::aabb2::kmVec2,\n    mut degrees: libc::c_float,\n    mut center: *const crate::src::kazmath::aabb2::kmVec2,\n) -> *mut crate::src::kazmath::aabb2::kmVec2 {\n    let mut x: libc::c_float = 0.;\n    let mut y: libc::c_float = 0.;\n    let radians = crate::src::kazmath::utility::kmDegreesToRadians(degrees);\n    let cs = cosf(radians);\n    let sn = sinf(radians);\n    (*pOut.as_deref_mut().unwrap()).x= (*pIn).x - (*center).x;\n    (*pOut.as_deref_mut().unwrap()).y= (*pIn).y - (*center).y;\n    x= (*pOut.as_deref().unwrap()).x * cs - (*pOut.as_deref().unwrap()).y * sn;\n    y= (*pOut.as_deref().unwrap()).x * sn + (*pOut.as_deref().unwrap()).y * cs;\n    (*pOut.as_deref_mut().unwrap()).x= x + (*center).x;\n    (*pOut.as_deref_mut().unwrap()).y= y + (*center).y;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::mat4::kmMat4Inverse":"pub unsafe extern \"C\" fn kmMat4Inverse(\n    mut pOut: Option<&mut crate::src::kazmath::mat3::kmMat4>,\n    mut pM: *const crate::src::kazmath::mat3::kmMat4,\n) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    let mut tmp = crate::src::kazmath::mat3::kmMat4 { mat: [0.; 16] };\n    let mut det: libc::c_double = 0.;\n    let mut i: libc::c_int = 0;\n    tmp.mat[0 as libc::c_int\n        as usize]= (*pM).mat[5 as libc::c_int as usize]\n        * (*pM).mat[10 as libc::c_int as usize] * (*pM).mat[15 as libc::c_int as usize]\n        - (*pM).mat[5 as libc::c_int as usize] * (*pM).mat[11 as libc::c_int as usize]\n            * (*pM).mat[14 as libc::c_int as usize]\n        - (*pM).mat[9 as libc::c_int as usize] * (*pM).mat[6 as libc::c_int as usize]\n            * (*pM).mat[15 as libc::c_int as usize]\n        + (*pM).mat[9 as libc::c_int as usize] * (*pM).mat[7 as libc::c_int as usize]\n            * (*pM).mat[14 as libc::c_int as usize]\n        + (*pM).mat[13 as libc::c_int as usize] * (*pM).mat[6 as libc::c_int as usize]\n            * (*pM).mat[11 as libc::c_int as usize]\n        - (*pM).mat[13 as libc::c_int as usize] * (*pM).mat[7 as libc::c_int as usize]\n            * (*pM).mat[10 as libc::c_int as usize];\n    tmp.mat[4 as libc::c_int\n        as usize]= -(*pM).mat[4 as libc::c_int as usize]\n        * (*pM).mat[10 as libc::c_int as usize] * (*pM).mat[15 as libc::c_int as usize]\n        + (*pM).mat[4 as libc::c_int as usize] * (*pM).mat[11 as libc::c_int as usize]\n            * (*pM).mat[14 as libc::c_int as usize]\n        + (*pM).mat[8 as libc::c_int as usize] * (*pM).mat[6 as libc::c_int as usize]\n            * (*pM).mat[15 as libc::c_int as usize]\n        - (*pM).mat[8 as libc::c_int as usize] * (*pM).mat[7 as libc::c_int as usize]\n            * (*pM).mat[14 as libc::c_int as usize]\n        - (*pM).mat[12 as libc::c_int as usize] * (*pM).mat[6 as libc::c_int as usize]\n            * (*pM).mat[11 as libc::c_int as usize]\n        + (*pM).mat[12 as libc::c_int as usize] * (*pM).mat[7 as libc::c_int as usize]\n            * (*pM).mat[10 as libc::c_int as usize];\n    tmp.mat[8 as libc::c_int\n        as usize]= (*pM).mat[4 as libc::c_int as usize]\n        * (*pM).mat[9 as libc::c_int as usize] * (*pM).mat[15 as libc::c_int as usize]\n        - (*pM).mat[4 as libc::c_int as usize] * (*pM).mat[11 as libc::c_int as usize]\n            * (*pM).mat[13 as libc::c_int as usize]\n        - (*pM).mat[8 as libc::c_int as usize] * (*pM).mat[5 as libc::c_int as usize]\n            * (*pM).mat[15 as libc::c_int as usize]\n        + (*pM).mat[8 as libc::c_int as usize] * (*pM).mat[7 as libc::c_int as usize]\n            * (*pM).mat[13 as libc::c_int as usize]\n        + (*pM).mat[12 as libc::c_int as usize] * (*pM).mat[5 as libc::c_int as usize]\n            * (*pM).mat[11 as libc::c_int as usize]\n        - (*pM).mat[12 as libc::c_int as usize] * (*pM).mat[7 as libc::c_int as usize]\n            * (*pM).mat[9 as libc::c_int as usize];\n    tmp.mat[12 as libc::c_int\n        as usize]= -(*pM).mat[4 as libc::c_int as usize]\n        * (*pM).mat[9 as libc::c_int as usize] * (*pM).mat[14 as libc::c_int as usize]\n        + (*pM).mat[4 as libc::c_int as usize] * (*pM).mat[10 as libc::c_int as usize]\n            * (*pM).mat[13 as libc::c_int as usize]\n        + (*pM).mat[8 as libc::c_int as usize] * (*pM).mat[5 as libc::c_int as usize]\n            * (*pM).mat[14 as libc::c_int as usize]\n        - (*pM).mat[8 as libc::c_int as usize] * (*pM).mat[6 as libc::c_int as usize]\n            * (*pM).mat[13 as libc::c_int as usize]\n        - (*pM).mat[12 as libc::c_int as usize] * (*pM).mat[5 as libc::c_int as usize]\n            * (*pM).mat[10 as libc::c_int as usize]\n        + (*pM).mat[12 as libc::c_int as usize] * (*pM).mat[6 as libc::c_int as usize]\n            * (*pM).mat[9 as libc::c_int as usize];\n    tmp.mat[1 as libc::c_int\n        as usize]= -(*pM).mat[1 as libc::c_int as usize]\n        * (*pM).mat[10 as libc::c_int as usize] * (*pM).mat[15 as libc::c_int as usize]\n        + (*pM).mat[1 as libc::c_int as usize] * (*pM).mat[11 as libc::c_int as usize]\n            * (*pM).mat[14 as libc::c_int as usize]\n        + (*pM).mat[9 as libc::c_int as usize] * (*pM).mat[2 as libc::c_int as usize]\n            * (*pM).mat[15 as libc::c_int as usize]\n        - (*pM).mat[9 as libc::c_int as usize] * (*pM).mat[3 as libc::c_int as usize]\n            * (*pM).mat[14 as libc::c_int as usize]\n        - (*pM).mat[13 as libc::c_int as usize] * (*pM).mat[2 as libc::c_int as usize]\n            * (*pM).mat[11 as libc::c_int as usize]\n        + (*pM).mat[13 as libc::c_int as usize] * (*pM).mat[3 as libc::c_int as usize]\n            * (*pM).mat[10 as libc::c_int as usize];\n    tmp.mat[5 as libc::c_int\n        as usize]= (*pM).mat[0 as libc::c_int as usize]\n        * (*pM).mat[10 as libc::c_int as usize] * (*pM).mat[15 as libc::c_int as usize]\n        - (*pM).mat[0 as libc::c_int as usize] * (*pM).mat[11 as libc::c_int as usize]\n            * (*pM).mat[14 as libc::c_int as usize]\n        - (*pM).mat[8 as libc::c_int as usize] * (*pM).mat[2 as libc::c_int as usize]\n            * (*pM).mat[15 as libc::c_int as usize]\n        + (*pM).mat[8 as libc::c_int as usize] * (*pM).mat[3 as libc::c_int as usize]\n            * (*pM).mat[14 as libc::c_int as usize]\n        + (*pM).mat[12 as libc::c_int as usize] * (*pM).mat[2 as libc::c_int as usize]\n            * (*pM).mat[11 as libc::c_int as usize]\n        - (*pM).mat[12 as libc::c_int as usize] * (*pM).mat[3 as libc::c_int as usize]\n            * (*pM).mat[10 as libc::c_int as usize];\n    tmp.mat[9 as libc::c_int\n        as usize]= -(*pM).mat[0 as libc::c_int as usize]\n        * (*pM).mat[9 as libc::c_int as usize] * (*pM).mat[15 as libc::c_int as usize]\n        + (*pM).mat[0 as libc::c_int as usize] * (*pM).mat[11 as libc::c_int as usize]\n            * (*pM).mat[13 as libc::c_int as usize]\n        + (*pM).mat[8 as libc::c_int as usize] * (*pM).mat[1 as libc::c_int as usize]\n            * (*pM).mat[15 as libc::c_int as usize]\n        - (*pM).mat[8 as libc::c_int as usize] * (*pM).mat[3 as libc::c_int as usize]\n            * (*pM).mat[13 as libc::c_int as usize]\n        - (*pM).mat[12 as libc::c_int as usize] * (*pM).mat[1 as libc::c_int as usize]\n            * (*pM).mat[11 as libc::c_int as usize]\n        + (*pM).mat[12 as libc::c_int as usize] * (*pM).mat[3 as libc::c_int as usize]\n            * (*pM).mat[9 as libc::c_int as usize];\n    tmp.mat[13 as libc::c_int\n        as usize]= (*pM).mat[0 as libc::c_int as usize]\n        * (*pM).mat[9 as libc::c_int as usize] * (*pM).mat[14 as libc::c_int as usize]\n        - (*pM).mat[0 as libc::c_int as usize] * (*pM).mat[10 as libc::c_int as usize]\n            * (*pM).mat[13 as libc::c_int as usize]\n        - (*pM).mat[8 as libc::c_int as usize] * (*pM).mat[1 as libc::c_int as usize]\n            * (*pM).mat[14 as libc::c_int as usize]\n        + (*pM).mat[8 as libc::c_int as usize] * (*pM).mat[2 as libc::c_int as usize]\n            * (*pM).mat[13 as libc::c_int as usize]\n        + (*pM).mat[12 as libc::c_int as usize] * (*pM).mat[1 as libc::c_int as usize]\n            * (*pM).mat[10 as libc::c_int as usize]\n        - (*pM).mat[12 as libc::c_int as usize] * (*pM).mat[2 as libc::c_int as usize]\n            * (*pM).mat[9 as libc::c_int as usize];\n    tmp.mat[2 as libc::c_int\n        as usize]= (*pM).mat[1 as libc::c_int as usize]\n        * (*pM).mat[6 as libc::c_int as usize] * (*pM).mat[15 as libc::c_int as usize]\n        - (*pM).mat[1 as libc::c_int as usize] * (*pM).mat[7 as libc::c_int as usize]\n            * (*pM).mat[14 as libc::c_int as usize]\n        - (*pM).mat[5 as libc::c_int as usize] * (*pM).mat[2 as libc::c_int as usize]\n            * (*pM).mat[15 as libc::c_int as usize]\n        + (*pM).mat[5 as libc::c_int as usize] * (*pM).mat[3 as libc::c_int as usize]\n            * (*pM).mat[14 as libc::c_int as usize]\n        + (*pM).mat[13 as libc::c_int as usize] * (*pM).mat[2 as libc::c_int as usize]\n            * (*pM).mat[7 as libc::c_int as usize]\n        - (*pM).mat[13 as libc::c_int as usize] * (*pM).mat[3 as libc::c_int as usize]\n            * (*pM).mat[6 as libc::c_int as usize];\n    tmp.mat[6 as libc::c_int\n        as usize]= -(*pM).mat[0 as libc::c_int as usize]\n        * (*pM).mat[6 as libc::c_int as usize] * (*pM).mat[15 as libc::c_int as usize]\n        + (*pM).mat[0 as libc::c_int as usize] * (*pM).mat[7 as libc::c_int as usize]\n            * (*pM).mat[14 as libc::c_int as usize]\n        + (*pM).mat[4 as libc::c_int as usize] * (*pM).mat[2 as libc::c_int as usize]\n            * (*pM).mat[15 as libc::c_int as usize]\n        - (*pM).mat[4 as libc::c_int as usize] * (*pM).mat[3 as libc::c_int as usize]\n            * (*pM).mat[14 as libc::c_int as usize]\n        - (*pM).mat[12 as libc::c_int as usize] * (*pM).mat[2 as libc::c_int as usize]\n            * (*pM).mat[7 as libc::c_int as usize]\n        + (*pM).mat[12 as libc::c_int as usize] * (*pM).mat[3 as libc::c_int as usize]\n            * (*pM).mat[6 as libc::c_int as usize];\n    tmp.mat[10 as libc::c_int\n        as usize]= (*pM).mat[0 as libc::c_int as usize]\n        * (*pM).mat[5 as libc::c_int as usize] * (*pM).mat[15 as libc::c_int as usize]\n        - (*pM).mat[0 as libc::c_int as usize] * (*pM).mat[7 as libc::c_int as usize]\n            * (*pM).mat[13 as libc::c_int as usize]\n        - (*pM).mat[4 as libc::c_int as usize] * (*pM).mat[1 as libc::c_int as usize]\n            * (*pM).mat[15 as libc::c_int as usize]\n        + (*pM).mat[4 as libc::c_int as usize] * (*pM).mat[3 as libc::c_int as usize]\n            * (*pM).mat[13 as libc::c_int as usize]\n        + (*pM).mat[12 as libc::c_int as usize] * (*pM).mat[1 as libc::c_int as usize]\n            * (*pM).mat[7 as libc::c_int as usize]\n        - (*pM).mat[12 as libc::c_int as usize] * (*pM).mat[3 as libc::c_int as usize]\n            * (*pM).mat[5 as libc::c_int as usize];\n    tmp.mat[14 as libc::c_int\n        as usize]= -(*pM).mat[0 as libc::c_int as usize]\n        * (*pM).mat[5 as libc::c_int as usize] * (*pM).mat[14 as libc::c_int as usize]\n        + (*pM).mat[0 as libc::c_int as usize] * (*pM).mat[6 as libc::c_int as usize]\n            * (*pM).mat[13 as libc::c_int as usize]\n        + (*pM).mat[4 as libc::c_int as usize] * (*pM).mat[1 as libc::c_int as usize]\n            * (*pM).mat[14 as libc::c_int as usize]\n        - (*pM).mat[4 as libc::c_int as usize] * (*pM).mat[2 as libc::c_int as usize]\n            * (*pM).mat[13 as libc::c_int as usize]\n        - (*pM).mat[12 as libc::c_int as usize] * (*pM).mat[1 as libc::c_int as usize]\n            * (*pM).mat[6 as libc::c_int as usize]\n        + (*pM).mat[12 as libc::c_int as usize] * (*pM).mat[2 as libc::c_int as usize]\n            * (*pM).mat[5 as libc::c_int as usize];\n    tmp.mat[3 as libc::c_int\n        as usize]= -(*pM).mat[1 as libc::c_int as usize]\n        * (*pM).mat[6 as libc::c_int as usize] * (*pM).mat[11 as libc::c_int as usize]\n        + (*pM).mat[1 as libc::c_int as usize] * (*pM).mat[7 as libc::c_int as usize]\n            * (*pM).mat[10 as libc::c_int as usize]\n        + (*pM).mat[5 as libc::c_int as usize] * (*pM).mat[2 as libc::c_int as usize]\n            * (*pM).mat[11 as libc::c_int as usize]\n        - (*pM).mat[5 as libc::c_int as usize] * (*pM).mat[3 as libc::c_int as usize]\n            * (*pM).mat[10 as libc::c_int as usize]\n        - (*pM).mat[9 as libc::c_int as usize] * (*pM).mat[2 as libc::c_int as usize]\n            * (*pM).mat[7 as libc::c_int as usize]\n        + (*pM).mat[9 as libc::c_int as usize] * (*pM).mat[3 as libc::c_int as usize]\n            * (*pM).mat[6 as libc::c_int as usize];\n    tmp.mat[7 as libc::c_int\n        as usize]= (*pM).mat[0 as libc::c_int as usize]\n        * (*pM).mat[6 as libc::c_int as usize] * (*pM).mat[11 as libc::c_int as usize]\n        - (*pM).mat[0 as libc::c_int as usize] * (*pM).mat[7 as libc::c_int as usize]\n            * (*pM).mat[10 as libc::c_int as usize]\n        - (*pM).mat[4 as libc::c_int as usize] * (*pM).mat[2 as libc::c_int as usize]\n            * (*pM).mat[11 as libc::c_int as usize]\n        + (*pM).mat[4 as libc::c_int as usize] * (*pM).mat[3 as libc::c_int as usize]\n            * (*pM).mat[10 as libc::c_int as usize]\n        + (*pM).mat[8 as libc::c_int as usize] * (*pM).mat[2 as libc::c_int as usize]\n            * (*pM).mat[7 as libc::c_int as usize]\n        - (*pM).mat[8 as libc::c_int as usize] * (*pM).mat[3 as libc::c_int as usize]\n            * (*pM).mat[6 as libc::c_int as usize];\n    tmp.mat[11 as libc::c_int\n        as usize]= -(*pM).mat[0 as libc::c_int as usize]\n        * (*pM).mat[5 as libc::c_int as usize] * (*pM).mat[11 as libc::c_int as usize]\n        + (*pM).mat[0 as libc::c_int as usize] * (*pM).mat[7 as libc::c_int as usize]\n            * (*pM).mat[9 as libc::c_int as usize]\n        + (*pM).mat[4 as libc::c_int as usize] * (*pM).mat[1 as libc::c_int as usize]\n            * (*pM).mat[11 as libc::c_int as usize]\n        - (*pM).mat[4 as libc::c_int as usize] * (*pM).mat[3 as libc::c_int as usize]\n            * (*pM).mat[9 as libc::c_int as usize]\n        - (*pM).mat[8 as libc::c_int as usize] * (*pM).mat[1 as libc::c_int as usize]\n            * (*pM).mat[7 as libc::c_int as usize]\n        + (*pM).mat[8 as libc::c_int as usize] * (*pM).mat[3 as libc::c_int as usize]\n            * (*pM).mat[5 as libc::c_int as usize];\n    tmp.mat[15 as libc::c_int\n        as usize]= (*pM).mat[0 as libc::c_int as usize]\n        * (*pM).mat[5 as libc::c_int as usize] * (*pM).mat[10 as libc::c_int as usize]\n        - (*pM).mat[0 as libc::c_int as usize] * (*pM).mat[6 as libc::c_int as usize]\n            * (*pM).mat[9 as libc::c_int as usize]\n        - (*pM).mat[4 as libc::c_int as usize] * (*pM).mat[1 as libc::c_int as usize]\n            * (*pM).mat[10 as libc::c_int as usize]\n        + (*pM).mat[4 as libc::c_int as usize] * (*pM).mat[2 as libc::c_int as usize]\n            * (*pM).mat[9 as libc::c_int as usize]\n        + (*pM).mat[8 as libc::c_int as usize] * (*pM).mat[1 as libc::c_int as usize]\n            * (*pM).mat[6 as libc::c_int as usize]\n        - (*pM).mat[8 as libc::c_int as usize] * (*pM).mat[2 as libc::c_int as usize]\n            * (*pM).mat[5 as libc::c_int as usize];\n    det= ((*pM).mat[0 as libc::c_int as usize] * tmp.mat[0 as libc::c_int as usize]\n        + (*pM).mat[1 as libc::c_int as usize] * tmp.mat[4 as libc::c_int as usize]\n        + (*pM).mat[2 as libc::c_int as usize] * tmp.mat[8 as libc::c_int as usize]\n        + (*pM).mat[3 as libc::c_int as usize] * tmp.mat[12 as libc::c_int as usize])\n        as libc::c_double;\n    if det == 0 as libc::c_int as libc::c_double {\n        return 0 as *mut crate::src::kazmath::mat3::kmMat4;\n    }\n    det= 1.0f64 / det;\n    i= 0 as libc::c_int;\n    while i < 16 as libc::c_int {\n        (*pOut.as_deref_mut().unwrap()).mat[i\n            as usize]= (tmp.mat[i as usize] as libc::c_double * det) as libc::c_float;\n        i+= 1;\n    }\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::vec3::kmVec3Transform":"pub unsafe extern \"C\" fn kmVec3Transform(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pV: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pM: *const crate::src::kazmath::mat3::kmMat4,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    return kmVec3MultiplyMat4(pOut.as_deref_mut(), pV, pM);\n}","src::src::color::heman_color_set_gamma":"pub unsafe extern \"C\" fn heman_color_set_gamma(mut g: libc::c_float) {\n    crate::src::src::color::_gamma= g;\n}","src::src::image::heman_image_info":"pub unsafe extern \"C\" fn heman_image_info(\n    mut img: *mut heman_image,\n    mut width: Option<&mut libc::c_int>,\n    mut height: Option<&mut libc::c_int>,\n    mut nbands: Option<&mut libc::c_int>,\n) {\n    *width.as_deref_mut().unwrap()= (*img).width;\n    *height.as_deref_mut().unwrap()= (*img).height;\n    *nbands.as_deref_mut().unwrap()= (*img).nbands;\n}","src::src::image::heman_image_create":"pub unsafe extern \"C\" fn heman_image_create(\n    mut width: libc::c_int,\n    mut height: libc::c_int,\n    mut nbands: libc::c_int,\n) -> *mut /* owning */ heman_image {\n    let mut img = malloc(::std::mem::size_of::<heman_image>() as libc::c_ulong)\n        as *mut heman_image;\n    (*img).width= width;\n    (*img).height= height;\n    (*img).nbands= nbands;\n    (*img).data= malloc(\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(width as libc::c_ulong)\n            .wrapping_mul(height as libc::c_ulong)\n            .wrapping_mul(nbands as libc::c_ulong),\n    ) as *mut libc::c_float;\n    return img;\n}","src::kazmath::mat4::kmMat4IsIdentity":"pub unsafe extern \"C\" fn kmMat4IsIdentity(mut pIn: *const crate::src::kazmath::mat3::kmMat4) -> libc::c_int {\n    static mut identity: [libc::c_float; 16] = [\n        1.0f32,\n        0.0f32,\n        0.0f32,\n        0.0f32,\n        0.0f32,\n        1.0f32,\n        0.0f32,\n        0.0f32,\n        0.0f32,\n        0.0f32,\n        1.0f32,\n        0.0f32,\n        0.0f32,\n        0.0f32,\n        0.0f32,\n        1.0f32,\n    ];\n    return (memcmp(\n        identity.as_mut_ptr() as *const libc::c_void,\n        ((*pIn).mat).as_ptr() as *const libc::c_void,\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(16 as libc::c_int as libc::c_ulong),\n    ) == 0 as libc::c_int) as libc::c_int;\n}","src::kazmath::ray2::kmLine2WithLineIntersection":"pub unsafe extern \"C\" fn kmLine2WithLineIntersection(\n    mut ptA: *const crate::src::kazmath::aabb2::kmVec2,\n    mut vecA: *const crate::src::kazmath::aabb2::kmVec2,\n    mut ptB: *const crate::src::kazmath::aabb2::kmVec2,\n    mut vecB: *const crate::src::kazmath::aabb2::kmVec2,\n    mut outTA: Option<&mut libc::c_float>,\n    mut outTB: Option<&mut libc::c_float>,\n    mut outIntersection: Option<&mut crate::src::kazmath::aabb2::kmVec2>,\n) -> libc::c_uchar {\n    let mut x1 = (*ptA).x;\n    let mut y1 = (*ptA).y;\n    let mut x2 = x1 + (*vecA).x;\n    let mut y2 = y1 + (*vecA).y;\n    let mut x3 = (*ptB).x;\n    let mut y3 = (*ptB).y;\n    let mut x4 = x3 + (*vecB).x;\n    let mut y4 = y3 + (*vecB).y;\n    let mut denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n    if denom as libc::c_double > -0.0001f64 && (denom as libc::c_double) < 0.0001f64 {\n        return 0 as libc::c_int as libc::c_uchar;\n    }\n    let mut ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;\n    let mut ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;\n    let mut x = x1 + ua * (x2 - x1);\n    let mut y = y1 + ua * (y2 - y1);\n    if !outTA.as_deref().is_none() {\n        *outTA.as_deref_mut().unwrap()= ua;\n    }else { (); }\n    if !outTB.as_deref().is_none() {\n        *outTB.as_deref_mut().unwrap()= ub;\n    }else { (); }\n    if !outIntersection.as_deref().is_none() {\n        (*outIntersection.as_deref_mut().unwrap()).x= x;\n        (*outIntersection.as_deref_mut().unwrap()).y= y;\n    }else { (); }\n    return 1 as libc::c_int as libc::c_uchar;\n}","src::kazmath::mat4::kmMat4Fill":"pub unsafe extern \"C\" fn kmMat4Fill(\n    mut pOut: *mut crate::src::kazmath::mat3::kmMat4,\n    mut pMat: *const libc::c_float,\n) -> *mut crate::src::kazmath::mat3::kmMat4 {\n    memcpy(\n        (*pOut).mat.as_mut_ptr() as *mut libc::c_void,\n        pMat as *const libc::c_void,\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(16 as libc::c_int as libc::c_ulong),\n    );\n    return pOut;\n}","src::src::ops::heman_ops_warp_core":"pub unsafe extern \"C\" fn heman_ops_warp_core(\n    mut img: *mut heman_image,\n    mut secondary: *mut heman_image,\n    mut seed: libc::c_int,\n    mut octaves: libc::c_int,\n) -> *mut heman_image {\n    let mut ctx = 0 as *mut crate::src::src::noise::osn_context;\n    crate::src::src::noise::open_simplex_noise(seed as int64_t, Some(&mut ctx));\n    let mut width = (*img).width;\n    let mut height = (*img).height;\n    let mut nbands = (*img).nbands;\n    let mut result = crate::src::src::image::heman_image_create(width, height, nbands);\n    let mut result2 = if !secondary.is_null() {\n        crate::src::src::image::heman_image_create(width, height, (*secondary).nbands)\n    } else {();\n        0 as *mut heman_image\n    };\n    let mut invw = (1.0f64 / width as libc::c_double) as libc::c_float;\n    let mut invh = (1.0f64 / height as libc::c_double) as libc::c_float;\n    let mut inv = if invw > invh { invh } else { invw };\n    let mut aspect = width as libc::c_float / height as libc::c_float;\n    let mut gain = 0.6f64 as libc::c_float;\n    let mut lacunarity = 2.0f64 as libc::c_float;\n    let mut initial_amplitude = 0.05f64 as libc::c_float;\n    let mut initial_frequency = 8.0f64 as libc::c_float;\n    let mut y: libc::c_int = 0;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut dst = (*result).data.offset((y * width * nbands) as isize);\n        let mut x = 0 as libc::c_int;\n        while x < width {\n            let mut a = initial_amplitude;\n            let mut f = initial_frequency;\n            let mut src = 0 as *mut libc::c_float;\n            if nbands == 4 as libc::c_int {\n                src= crate::src::src::image::heman_image_texel(img.as_mut(), x, y);\n                let mut elev = 1 as libc::c_int as libc::c_float\n                    - *src.offset(3 as libc::c_int as isize);\n                a= (a as libc::c_double\n                    * pow(elev as libc::c_double, 4 as libc::c_int as libc::c_double))\n                    as libc::c_float;\n            }\n            let mut s = x as libc::c_float * inv;\n            let mut t = y as libc::c_float * inv;\n            let mut u = x as libc::c_float * invw;\n            let mut v = y as libc::c_float * invh;\n            let mut i = 0 as libc::c_int;\n            while i < octaves {\n                u= (u as libc::c_double\n                    + a as libc::c_double\n                        * crate::src::src::noise::open_simplex_noise2(\n                            ctx,\n                            (s * f) as libc::c_double,\n                            (t * f) as libc::c_double,\n                        )) as libc::c_float;\n                v= (v as libc::c_double\n                    + aspect as libc::c_double\n                        * (a as libc::c_double\n                            * crate::src::src::noise::open_simplex_noise2(\n                                ctx,\n                                (s * f) as libc::c_double + 0.5f64,\n                                (t * f) as libc::c_double,\n                            ))) as libc::c_float;\n                a*= gain;\n                f*= lacunarity;\n                i+= 1;\n            }\n            let mut i_0 = (if 0 as libc::c_int as libc::c_float\n                > (if (width - 1 as libc::c_int) as libc::c_float\n                    > u * width as libc::c_float\n                {\n                    u * width as libc::c_float\n                } else {\n                    (width - 1 as libc::c_int) as libc::c_float\n                })\n            {\n                0 as libc::c_int as libc::c_float\n            } else if (width - 1 as libc::c_int) as libc::c_float\n                > u * width as libc::c_float\n            {\n                u * width as libc::c_float\n            } else {\n                (width - 1 as libc::c_int) as libc::c_float\n            }) as libc::c_int;\n            let mut j = (if 0 as libc::c_int as libc::c_float\n                > (if (height - 1 as libc::c_int) as libc::c_float\n                    > v * height as libc::c_float\n                {\n                    v * height as libc::c_float\n                } else {\n                    (height - 1 as libc::c_int) as libc::c_float\n                })\n            {\n                0 as libc::c_int as libc::c_float\n            } else if (height - 1 as libc::c_int) as libc::c_float\n                > v * height as libc::c_float\n            {\n                v * height as libc::c_float\n            } else {\n                (height - 1 as libc::c_int) as libc::c_float\n            }) as libc::c_int;\n            src= crate::src::src::image::heman_image_texel(img.as_mut(), i_0, j);\n            let mut n = 0 as libc::c_int;\n            while n < nbands {\n                let fresh14 = src;\n                src= src.offset(1);\n                let fresh15 = dst;\n                dst= dst.offset(1);\n                *fresh15= (*fresh14);\n                n+= 1;\n            }\n            if !secondary.is_null() {\n                src= crate::src::src::image::heman_image_texel(secondary.as_mut(), x, y);\n                let mut dst2 = crate::src::src::image::heman_image_texel(result2.as_mut(), i_0, j);\n                let mut n_0 = 0 as libc::c_int;\n                while n_0 < (*secondary).nbands {\n                    let fresh16 = src;\n                    src= src.offset(1);\n                    let fresh17 = dst2;\n                    dst2= dst2.offset(1);\n                    *fresh17= (*fresh16);\n                    n_0+= 1;\n                }\n            }else { (); }\n            x+= 1;\n        }\n        y+= 1;\n    }\n    crate::src::src::noise::open_simplex_noise_free(ctx);\n    if !secondary.is_null() {\n        free((*secondary).data as *mut libc::c_void);\n        (*secondary).data= (*result2).data;\n        free(result2 as *mut libc::c_void);\n    }else { (); }\n    return result;\n}","src::src::ops::heman_ops_emboss":"pub unsafe extern \"C\" fn heman_ops_emboss(\n    mut img: *mut heman_image,\n    mut mode: libc::c_int,\n) -> *mut heman_image {\n    let mut seed = 1 as libc::c_int;\n    let mut octaves = 4 as libc::c_int;\n    let mut ctx = 0 as *mut crate::src::src::noise::osn_context;\n    crate::src::src::noise::open_simplex_noise(seed as int64_t, Some(&mut ctx));\n    let mut width = (*img).width;\n    let mut height = (*img).height;\n    if (*img).nbands == 1 as libc::c_int {} else {\n        __assert_fail(\n            b\"img->nbands == 1\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            549 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_emboss(heman_image *, int)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut result = crate::src::src::image::heman_image_create(width, height, 1 as libc::c_int);\n    let mut invw = (1.0f64 / width as libc::c_double) as libc::c_float;\n    let mut invh = (1.0f64 / height as libc::c_double) as libc::c_float;\n    let mut inv = if invw > invh { invh } else { invw };\n    let mut gain = 0.6f64 as libc::c_float;\n    let mut lacunarity = 2.0f64 as libc::c_float;\n    let mut land_amplitude = 0.0005f64 as libc::c_float;\n    let mut land_frequency = 256.0f64 as libc::c_float;\n    let mut ocean_amplitude = 0.5f64 as libc::c_float;\n    let mut ocean_frequency = 1.0f64 as libc::c_float;\n    let mut y: libc::c_int = 0;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut dst = (*result).data.offset((y * width) as isize);\n        let mut x = 0 as libc::c_int;\n        while x < width {\n            let mut z = *crate::src::src::image::heman_image_texel(img.as_mut(), x, y);\n            if z > 0 as libc::c_int as libc::c_float && mode == 1 as libc::c_int {\n                let mut s = x as libc::c_float * inv;\n                let mut t = y as libc::c_float * inv;\n                let mut a = land_amplitude;\n                let mut f = land_frequency;\n                let mut i = 0 as libc::c_int;\n                while i < octaves {\n                    z= (z as libc::c_double\n                        + a as libc::c_double\n                            * crate::src::src::noise::open_simplex_noise2(\n                                ctx,\n                                (s * f) as libc::c_double,\n                                (t * f) as libc::c_double,\n                            )) as libc::c_float;\n                    a*= gain;\n                    f*= lacunarity;\n                    i+= 1;\n                }\n            } else if z <= 0 as libc::c_int as libc::c_float\n                && mode == -(1 as libc::c_int)\n            {\n                z= (if z as libc::c_double > -0.1f64 {\n                    z as libc::c_double\n                } else {\n                    -0.1f64\n                }) as libc::c_float;\n                let mut soften = fabsf(z);\n                let mut s_0 = x as libc::c_float * inv;\n                let mut t_0 = y as libc::c_float * inv;\n                let mut a_0 = ocean_amplitude;\n                let mut f_0 = ocean_frequency;\n                let mut i_0 = 0 as libc::c_int;\n                while i_0 < octaves {\n                    z= (z as libc::c_double\n                        + soften as libc::c_double\n                            * (a_0 as libc::c_double\n                                * crate::src::src::noise::open_simplex_noise2(\n                                    ctx,\n                                    (s_0 * f_0) as libc::c_double,\n                                    (t_0 * f_0) as libc::c_double,\n                                ))) as libc::c_float;\n                    a_0*= gain;\n                    f_0*= lacunarity;\n                    i_0+= 1;\n                }\n            }\n            let fresh34 = dst;\n            dst= dst.offset(1);\n            *fresh34= z;\n            x+= 1;\n        }\n        y+= 1;\n    }\n    crate::src::src::noise::open_simplex_noise_free(ctx);\n    return result;\n}","src::kazmath::quaternion::kmQuaternionGetRoll":"pub unsafe extern \"C\" fn kmQuaternionGetRoll(\n    mut q: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> libc::c_float {\n    let mut result = atan2(\n        (2 as libc::c_int as libc::c_float * ((*q).x * (*q).y + (*q).w * (*q).z))\n            as libc::c_double,\n        ((*q).w * (*q).w + (*q).x * (*q).x - (*q).y * (*q).y - (*q).z * (*q).z)\n            as libc::c_double,\n    ) as libc::c_float;\n    return result;\n}","src::kazmath::aabb3::kmAABB3ExpandToContain":"pub unsafe extern \"C\" fn kmAABB3ExpandToContain(\n    mut pOut: Option<&mut kmAABB3>,\n    mut pIn: *const kmAABB3,\n    mut other: *const kmAABB3,\n) -> *mut kmAABB3 {\n    let mut result = kmAABB3 {\n        min: kmVec3 { x: 0., y: 0., z: 0. },\n        max: kmVec3 { x: 0., y: 0., z: 0. },\n    };\n    result.min.x= if (*pIn).min.x < (*other).min.x { (*pIn).min.x } else { (*other).min.x };\n    result.max.x= if (*pIn).max.x > (*other).max.x { (*pIn).max.x } else { (*other).max.x };\n    result.min.y= if (*pIn).min.y < (*other).min.y { (*pIn).min.y } else { (*other).min.y };\n    result.max.y= if (*pIn).max.y > (*other).max.y { (*pIn).max.y } else { (*other).max.y };\n    result.min.z= if (*pIn).min.z < (*other).min.z { (*pIn).min.z } else { (*other).min.z };\n    result.max.z= if (*pIn).max.z > (*other).max.z { (*pIn).max.z } else { (*other).max.z };\n    kmAABB3Assign(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), core::ptr::addr_of!(result));\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::quaternion::kmQuaternionMultiplyVec3":"pub unsafe extern \"C\" fn kmQuaternionMultiplyVec3(\n    mut pOut: *mut crate::src::kazmath::aabb3::kmVec3,\n    mut q: *const crate::src::kazmath::mat3::kmQuaternion,\n    mut v: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    let mut uv = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut uuv = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut qvec = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    qvec.x= (*q).x;\n    qvec.y= (*q).y;\n    qvec.z= (*q).z;\n    crate::src::kazmath::vec3::kmVec3Cross(core::ptr::addr_of_mut!(uv), core::ptr::addr_of!(qvec), v);\n    crate::src::kazmath::vec3::kmVec3Cross(core::ptr::addr_of_mut!(uuv), core::ptr::addr_of!(qvec), core::ptr::addr_of!(uv));\n    crate::src::kazmath::vec3::kmVec3Scale(core::ptr::addr_of_mut!(uv), core::ptr::addr_of!(uv), 2.0f32 * (*q).w);\n    crate::src::kazmath::vec3::kmVec3Scale(core::ptr::addr_of_mut!(uuv), core::ptr::addr_of!(uuv), 2.0f32);\n    crate::src::kazmath::vec3::kmVec3Add(pOut, v, core::ptr::addr_of!(uv));\n    crate::src::kazmath::vec3::kmVec3Add(pOut, pOut, core::ptr::addr_of!(uuv));\n    return pOut;\n}","src::kazmath::vec2::kmVec2Add":"pub unsafe extern \"C\" fn kmVec2Add(\n    mut pOut: *mut crate::src::kazmath::aabb2::kmVec2,\n    mut pV1: *const crate::src::kazmath::aabb2::kmVec2,\n    mut pV2: *const crate::src::kazmath::aabb2::kmVec2,\n) -> *mut crate::src::kazmath::aabb2::kmVec2 {\n    (*pOut).x= (*pV1).x + (*pV2).x;\n    (*pOut).y= (*pV1).y + (*pV2).y;\n    return pOut;\n}","src::kazmath::vec4::kmVec4Length":"pub unsafe extern \"C\" fn kmVec4Length(mut pIn: *const crate::src::kazmath::plane::kmVec4) -> libc::c_float {\n    return sqrtf(crate::src::kazmath::utility::kmSQR((*pIn).x) + crate::src::kazmath::utility::kmSQR((*pIn).y) + crate::src::kazmath::utility::kmSQR((*pIn).z) + crate::src::kazmath::utility::kmSQR((*pIn).w));\n}","src::kazmath::quaternion::kmQuaternionRotationBetweenVec3":"pub unsafe extern \"C\" fn kmQuaternionRotationBetweenVec3(\n    mut pOut: *mut crate::src::kazmath::mat3::kmQuaternion,\n    mut vec1: *const crate::src::kazmath::aabb3::kmVec3,\n    mut vec2: *const crate::src::kazmath::aabb3::kmVec3,\n    mut fallback: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut crate::src::kazmath::mat3::kmQuaternion {\n    let mut v1 = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut v2 = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut a: libc::c_float = 0.;\n    crate::src::kazmath::vec3::kmVec3Assign(core::ptr::addr_of_mut!(v1), vec1);\n    crate::src::kazmath::vec3::kmVec3Assign(core::ptr::addr_of_mut!(v2), vec2);\n    crate::src::kazmath::vec3::kmVec3Normalize(core::ptr::addr_of_mut!(v1), core::ptr::addr_of!(v1));\n    crate::src::kazmath::vec3::kmVec3Normalize(core::ptr::addr_of_mut!(v2), core::ptr::addr_of!(v2));\n    a= crate::src::kazmath::vec3::kmVec3Dot(core::ptr::addr_of!(v1), core::ptr::addr_of!(v2));\n    if a as libc::c_double >= 1.0f64 {\n        kmQuaternionIdentity(pOut.as_mut());\n        return pOut;\n    }\n    if a < 1e-6f32 - 1.0f32 {\n        if fabs(crate::src::kazmath::vec3::kmVec3LengthSq(fallback) as libc::c_double) < 0.0001f64 {\n            kmQuaternionRotationAxisAngle(pOut, fallback, 3.14159265358979323846f32);\n        } else {\n            let mut axis = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n            let mut X = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n            X.x= 1.0f64 as libc::c_float;\n            X.y= 0.0f64 as libc::c_float;\n            X.z= 0.0f64 as libc::c_float;\n            crate::src::kazmath::vec3::kmVec3Cross(core::ptr::addr_of_mut!(axis), core::ptr::addr_of!(X), vec1);\n            if fabs(crate::src::kazmath::vec3::kmVec3LengthSq(core::ptr::addr_of!(axis)) as libc::c_double) < 0.0001f64 {\n                let mut Y = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n                Y.x= 0.0f64 as libc::c_float;\n                Y.y= 1.0f64 as libc::c_float;\n                Y.z= 0.0f64 as libc::c_float;\n                crate::src::kazmath::vec3::kmVec3Cross(core::ptr::addr_of_mut!(axis), core::ptr::addr_of!(Y), vec1);\n            }\n            crate::src::kazmath::vec3::kmVec3Normalize(core::ptr::addr_of_mut!(axis), core::ptr::addr_of!(axis));\n            kmQuaternionRotationAxisAngle(pOut, core::ptr::addr_of!(axis), 3.14159265358979323846f32);\n        }\n    } else {\n        let mut s = sqrtf(\n            (1 as libc::c_int as libc::c_float + a) * 2 as libc::c_int as libc::c_float,\n        );\n        let mut invs = 1 as libc::c_int as libc::c_float / s;\n        let mut c = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n        crate::src::kazmath::vec3::kmVec3Cross(core::ptr::addr_of_mut!(c), core::ptr::addr_of!(v1), core::ptr::addr_of!(v2));\n        (*pOut).x= c.x * invs;\n        (*pOut).y= c.y * invs;\n        (*pOut).z= c.z * invs;\n        (*pOut).w= s * 0.5f32;\n        kmQuaternionNormalize(pOut, pOut);\n    }\n    return pOut;\n}","src::src::color::heman_color_apply_gradient":"pub unsafe extern \"C\" fn heman_color_apply_gradient(\n    mut heightmap: *mut heman_image,\n    mut minheight: libc::c_float,\n    mut maxheight: libc::c_float,\n    mut gradient: *mut heman_image,\n) -> *mut heman_image {\n    if (*heightmap).nbands == 1 as libc::c_int {} else {\n        __assert_fail(\n            b\"heightmap->nbands == 1\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/color.c\\0\" as *const u8 as *const libc::c_char,\n            74 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_color_apply_gradient(heman_image *, float, float, heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if (*gradient).height == 1 as libc::c_int {} else {\n        __assert_fail(\n            b\"gradient->height == 1\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/color.c\\0\" as *const u8 as *const libc::c_char,\n            75 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_color_apply_gradient(heman_image *, float, float, heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if (*gradient).nbands == 3 as libc::c_int {} else {\n        __assert_fail(\n            b\"gradient->nbands == 3\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/color.c\\0\" as *const u8 as *const libc::c_char,\n            76 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_color_apply_gradient(heman_image *, float, float, heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut w = (*heightmap).width;\n    let mut h = (*heightmap).height;\n    let mut result = crate::src::src::image::heman_image_create(w, h, 3 as libc::c_int);\n    let mut size = (*result).height * (*result).width;\n    let mut dst = (*result).data;\n    let mut src: *const libc::c_float = (*heightmap).data as *const f32;\n    let mut scale = 1.0f32 / (maxheight - minheight);\n    let mut i = 0 as libc::c_int;\n    while i < size {\n        let mut u = if 0.0f32\n            > (if 1.0f32 > ((*src) - minheight) * scale {\n                ((*src) - minheight) * scale\n            } else {\n                1.0f32\n            })\n        {\n            0.0f32\n        } else if 1.0f32 > ((*src) - minheight) * scale {\n            ((*src) - minheight) * scale\n        } else {\n            1.0f32\n        };\n        crate::src::src::image::heman_image_sample(gradient.as_mut(), u, 0.5f32, dst);\n        i+= 1;\n        dst= dst.offset(3 as libc::c_int as isize);\n        src= src.offset(1);\n    }\n    return result;\n}","src::kazmath::plane::kmPlaneDotNormal":"pub unsafe extern \"C\" fn kmPlaneDotNormal(\n    mut pP: *const crate::src::kazmath::mat4::kmPlane,\n    mut pV: *const crate::src::kazmath::aabb3::kmVec3,\n) -> libc::c_float {\n    return (*pP).a * (*pV).x + (*pP).b * (*pV).y + (*pP).c * (*pV).z;\n}","src::kazmath::aabb3::kmAABB3DiameterX":"pub unsafe extern \"C\" fn kmAABB3DiameterX(mut aabb: *const kmAABB3) -> libc::c_float {\n    return fabs(((*aabb).max.x - (*aabb).min.x) as libc::c_double) as libc::c_float;\n}","src::kazmath::plane::kmPlaneGetIntersection":"pub unsafe extern \"C\" fn kmPlaneGetIntersection(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut p1: *const crate::src::kazmath::mat4::kmPlane,\n    mut p2: *const crate::src::kazmath::mat4::kmPlane,\n    mut p3: *const crate::src::kazmath::mat4::kmPlane,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    let mut n1 = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut n2 = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut n3 = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut cross = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut r1 = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut r2 = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut r3 = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    let mut denom = 0 as libc::c_int as libc::c_double;\n    crate::src::kazmath::vec3::kmVec3Fill(Some(&mut n1), (*p1).a, (*p1).b, (*p1).c);\n    crate::src::kazmath::vec3::kmVec3Fill(Some(&mut n2), (*p2).a, (*p2).b, (*p2).c);\n    crate::src::kazmath::vec3::kmVec3Fill(Some(&mut n3), (*p3).a, (*p3).b, (*p3).c);\n    crate::src::kazmath::vec3::kmVec3Cross(core::ptr::addr_of_mut!(cross), core::ptr::addr_of!(n2), core::ptr::addr_of!(n3));\n    denom= crate::src::kazmath::vec3::kmVec3Dot(core::ptr::addr_of!(n1), core::ptr::addr_of!(cross)) as libc::c_double;\n    if crate::src::kazmath::utility::kmAlmostEqual(denom as libc::c_float, 0.0f64 as libc::c_float) != 0 {\n        return 0 as *mut crate::src::kazmath::aabb3::kmVec3;\n    }\n    crate::src::kazmath::vec3::kmVec3Cross(core::ptr::addr_of_mut!(r1), core::ptr::addr_of!(n2), core::ptr::addr_of!(n3));\n    crate::src::kazmath::vec3::kmVec3Cross(core::ptr::addr_of_mut!(r2), core::ptr::addr_of!(n3), core::ptr::addr_of!(n1));\n    crate::src::kazmath::vec3::kmVec3Cross(core::ptr::addr_of_mut!(r3), core::ptr::addr_of!(n1), core::ptr::addr_of!(n2));\n    crate::src::kazmath::vec3::kmVec3Scale(core::ptr::addr_of_mut!(r1), core::ptr::addr_of!(r1), -(*p1).d);\n    crate::src::kazmath::vec3::kmVec3Scale(core::ptr::addr_of_mut!(r2), core::ptr::addr_of!(r2), (*p2).d);\n    crate::src::kazmath::vec3::kmVec3Scale(core::ptr::addr_of_mut!(r3), core::ptr::addr_of!(r3), (*p3).d);\n    crate::src::kazmath::vec3::kmVec3Subtract(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), core::ptr::addr_of!(r1), core::ptr::addr_of!(r2));\n    crate::src::kazmath::vec3::kmVec3Subtract(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), pOut.as_deref().map(|r| r as *const _).unwrap_or(std::ptr::null()), core::ptr::addr_of!(r3));\n    crate::src::kazmath::vec3::kmVec3Scale(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), pOut.as_deref().map(|r| r as *const _).unwrap_or(std::ptr::null()), (1.0f64 / denom) as libc::c_float);\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::vec2::kmVec2Scale":"pub unsafe extern \"C\" fn kmVec2Scale(\n    mut pOut: *mut crate::src::kazmath::aabb2::kmVec2,\n    mut pIn: *const crate::src::kazmath::aabb2::kmVec2,\n    mut s: libc::c_float,\n) -> *mut crate::src::kazmath::aabb2::kmVec2 {\n    (*pOut).x= (*pIn).x * s;\n    (*pOut).y= (*pIn).y * s;\n    return pOut;\n}","src::src::generate::heman_generate_archipelago_political":"pub unsafe extern \"C\" fn heman_generate_archipelago_political(\n    mut width: libc::c_int,\n    mut height: libc::c_int,\n    mut points: *mut heman_points,\n    mut colors: *const heman_color,\n    mut ocean: heman_color,\n    mut seed: libc::c_int,\n    mut elevation: Option<&mut *mut /* owning */ heman_image>,\n    mut political: Option<&mut *mut heman_image>,\n    mut elevation_mode: libc::c_int,\n) {\n    *political.as_deref_mut().unwrap()= heman_generate_archipelago_political_1(\n        width,\n        height,\n        points,\n        colors,\n        ocean,\n        seed,\n    );\n    if elevation_mode == 0 as libc::c_int {\n        *elevation.as_deref_mut().unwrap()= heman_generate_archipelago_political_2(\n            width,\n            height,\n            ocean,\n            seed,\n            (*political.as_deref().unwrap()),\n            0 as libc::c_int,\n        );\n    } else {\n        let mut ncolors = (*points).width;\n        *elevation.as_deref_mut().unwrap()= heman_generate_archipelago_political_3(\n            width,\n            height,\n            colors,\n            ncolors,\n            ocean,\n            seed,\n            (*political.as_deref().unwrap()),\n        );\n    };\n}","src::kazmath::aabb3::kmAABB3IntersectsAABB":"pub unsafe extern \"C\" fn kmAABB3IntersectsAABB(\n    mut box_0: *const kmAABB3,\n    mut other: *const kmAABB3,\n) -> libc::c_uchar {\n    return (kmAABB3ContainsAABB(box_0, other) != 0 as libc::c_int as libc::c_uint)\n        as libc::c_int as libc::c_uchar;\n}","src::kazmath::quaternion::kmQuaternionGetPitch":"pub unsafe extern \"C\" fn kmQuaternionGetPitch(\n    mut q: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> libc::c_float {\n    let mut result = atan2(\n        (2 as libc::c_int as libc::c_float * ((*q).y * (*q).z + (*q).w * (*q).x))\n            as libc::c_double,\n        ((*q).w * (*q).w - (*q).x * (*q).x - (*q).y * (*q).y + (*q).z * (*q).z)\n            as libc::c_double,\n    ) as libc::c_float;\n    return result;\n}","src::src::generate::heman_generate_island_heightmap":"pub unsafe extern \"C\" fn heman_generate_island_heightmap(\n    mut width: libc::c_int,\n    mut height: libc::c_int,\n    mut seed: libc::c_int,\n) -> *mut /* owning */ heman_image {\n    let mut noisetex = heman_internal_generate_island_noise(width, height, seed);\n    let mut coastmask = crate::src::src::image::heman_image_create(width, height, 1 as libc::c_int);\n    let mut data = (*coastmask).data;\n    let mut invh = 1.0f32 / height as libc::c_float;\n    let mut invw = 1.0f32 / width as libc::c_float;\n    let mut hh = height / 2 as libc::c_int;\n    let mut hw = width / 2 as libc::c_int;\n    let mut y: libc::c_int = 0;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut vv = (y - hh) as libc::c_float * invh;\n        let mut dst = data.offset((y * width) as isize);\n        let mut x = 0 as libc::c_int;\n        while x < width {\n            let mut n: [libc::c_float; 3] = [0.; 3];\n            let mut v = y as libc::c_float * invh;\n            let mut u = x as libc::c_float * invw;\n            crate::src::src::image::heman_image_sample(noisetex.as_mut(), u, v, n.as_mut_ptr());\n            u= (x - hw) as libc::c_float * invw;\n            v= vv;\n            u+= n[1 as libc::c_int as usize];\n            v+= n[2 as libc::c_int as usize];\n            let mut m = (0.707f64 - sqrt((u * u + v * v) as libc::c_double))\n                as libc::c_float;\n            m+= n[0 as libc::c_int as usize];\n            let fresh4 = dst;\n            dst= dst.offset(1);\n            *fresh4= (if m < crate::src::src::generate::SEALEVEL { 0 as libc::c_int } else { 1 as libc::c_int })\n                as libc::c_float;\n            x+= 1;\n        }\n        y+= 1;\n    }\n    let mut heightmap = crate::src::src::distance::heman_distance_create_sdf(coastmask);\n    crate::src::src::image::heman_image_destroy(coastmask);\n    let mut result = crate::src::src::image::heman_image_create(width, height, 1 as libc::c_int);\n    data= (*result).data;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut dst_0 = data.offset((y * width) as isize);\n        let mut x_0 = 0 as libc::c_int;\n        while x_0 < width {\n            let mut n_0: [libc::c_float; 3] = [0.; 3];\n            let mut u_0 = x_0 as libc::c_float * invw;\n            let mut v_0 = y as libc::c_float * invh;\n            crate::src::src::image::heman_image_sample(noisetex.as_mut(), u_0, v_0, n_0.as_mut_ptr());\n            let mut z: libc::c_float = 0.;\n            crate::src::src::image::heman_image_sample(heightmap.as_mut(), u_0, v_0, core::ptr::addr_of_mut!(z));\n            if z as libc::c_double > 0.0f64 {\n                let mut influence = z;\n                u_0+= influence * n_0[1 as libc::c_int as usize];\n                v_0+= influence * n_0[2 as libc::c_int as usize];\n                crate::src::src::image::heman_image_sample(heightmap.as_mut(), u_0, v_0, core::ptr::addr_of_mut!(z));\n                z+= 6 as libc::c_int as libc::c_float * influence\n                        * n_0[0 as libc::c_int as usize];\n            }\n            let fresh5 = dst_0;\n            dst_0= dst_0.offset(1);\n            *fresh5= z;\n            x_0+= 1;\n        }\n        y+= 1;\n    }\n    crate::src::src::image::heman_image_destroy(noisetex);\n    crate::src::src::image::heman_image_destroy(heightmap);\n    return result;\n}","src::kazmath::vec4::kmVec4TransformArray":"pub unsafe extern \"C\" fn kmVec4TransformArray(\n    mut pOut: *mut crate::src::kazmath::plane::kmVec4,\n    mut outStride: libc::c_uint,\n    mut pV: *const crate::src::kazmath::plane::kmVec4,\n    mut vStride: libc::c_uint,\n    mut pM: *const crate::src::kazmath::mat3::kmMat4,\n    mut count: libc::c_uint,\n) -> *mut crate::src::kazmath::plane::kmVec4 {\n    let mut i = 0 as libc::c_int as libc::c_uint;\n    while i < count {\n        let mut in_0 = pV.offset(i.wrapping_mul(vStride) as isize);\n        let mut out = pOut.offset(i.wrapping_mul(outStride) as isize);\n        kmVec4Transform(out.as_mut(), in_0, pM);\n        i= i.wrapping_add(1);\n    }\n    return pOut;\n}","src::kazmath::mat3::kmMat3ScalarMultiply":"pub unsafe extern \"C\" fn kmMat3ScalarMultiply(\n    mut pOut: *mut kmMat3,\n    mut pM: *const kmMat3,\n    mut pFactor: libc::c_float,\n) -> *mut kmMat3 {\n    let mut mat: [libc::c_float; 9] = [0.; 9];\n    let mut i: libc::c_int = 0;\n    i= 0 as libc::c_int;\n    while i < 9 as libc::c_int {\n        mat[i as usize]= (*pM).mat[i as usize] * pFactor;\n        i+= 1;\n    }\n    memcpy(\n        (*pOut).mat.as_mut_ptr() as *mut libc::c_void,\n        mat.as_mut_ptr() as *const libc::c_void,\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(9 as libc::c_int as libc::c_ulong),\n    );\n    return pOut;\n}","src::kazmath::vec2::kmVec2Dot":"pub unsafe extern \"C\" fn kmVec2Dot(\n    mut pV1: *const crate::src::kazmath::aabb2::kmVec2,\n    mut pV2: *const crate::src::kazmath::aabb2::kmVec2,\n) -> libc::c_float {\n    return (*pV1).x * (*pV2).x + (*pV1).y * (*pV2).y;\n}","src::kazmath::vec3::kmVec3Cross":"pub unsafe extern \"C\" fn kmVec3Cross(\n    mut pOut: *mut crate::src::kazmath::aabb3::kmVec3,\n    mut pV1: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pV2: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    let mut v = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    v.x= (*pV1).y * (*pV2).z - (*pV1).z * (*pV2).y;\n    v.y= (*pV1).z * (*pV2).x - (*pV1).x * (*pV2).z;\n    v.z= (*pV1).x * (*pV2).y - (*pV1).y * (*pV2).x;\n    (*pOut).x= v.x;\n    (*pOut).y= v.y;\n    (*pOut).z= v.z;\n    return pOut;\n}","src::kazmath::vec3::kmVec3Add":"pub unsafe extern \"C\" fn kmVec3Add(\n    mut pOut: *mut crate::src::kazmath::aabb3::kmVec3,\n    mut pV1: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pV2: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    let mut v = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    v.x= (*pV1).x + (*pV2).x;\n    v.y= (*pV1).y + (*pV2).y;\n    v.z= (*pV1).z + (*pV2).z;\n    (*pOut).x= v.x;\n    (*pOut).y= v.y;\n    (*pOut).z= v.z;\n    return pOut;\n}","src::kazmath::vec2::kmVec2Subtract":"pub unsafe extern \"C\" fn kmVec2Subtract(\n    mut pOut: *mut crate::src::kazmath::aabb2::kmVec2,\n    mut pV1: *const crate::src::kazmath::aabb2::kmVec2,\n    mut pV2: *const crate::src::kazmath::aabb2::kmVec2,\n) -> *mut crate::src::kazmath::aabb2::kmVec2 {\n    (*pOut).x= (*pV1).x - (*pV2).x;\n    (*pOut).y= (*pV1).y - (*pV2).y;\n    return pOut;\n}","src::src::distance::edt_with_payload":"unsafe extern \"C\" fn edt_with_payload(\n    mut f: *mut libc::c_float,\n    mut d: *mut libc::c_float,\n    mut z: *mut libc::c_float,\n    mut w: *mut uint16_t,\n    mut n: libc::c_int,\n    mut payload_in: *mut libc::c_float,\n    mut payload_out: *mut libc::c_float,\n) {\n    let mut k = 0 as libc::c_int;\n    let mut s: libc::c_float = 0.;\n    *w.offset(0 as libc::c_int as isize) = 0 as libc::c_int as uint16_t;\n    *z.offset(0 as libc::c_int as isize) = -crate::src::src::distance::INF;\n    *z.offset(1 as libc::c_int as isize) = crate::src::src::distance::INF;\n    let mut q = 1 as libc::c_int;\n    while q < n {\n        s= (*f.offset(q as isize) + (q * q) as libc::c_float\n            - (*f.offset(*w.offset(k as isize) as isize)\n                + (*w.offset(k as isize) as libc::c_int\n                    * *w.offset(k as isize) as libc::c_int) as libc::c_float))\n            / (2 as libc::c_int * q\n                - 2 as libc::c_int * *w.offset(k as isize) as libc::c_int)\n                as libc::c_float;\n        while s <= *z.offset(k as isize) {\n            k-= 1;\n            s= (*f.offset(q as isize) + (q * q) as libc::c_float\n                - (*f.offset(*w.offset(k as isize) as isize)\n                    + (*w.offset(k as isize) as libc::c_int\n                        * *w.offset(k as isize) as libc::c_int) as libc::c_float))\n                / (2 as libc::c_int * q\n                    - 2 as libc::c_int * *w.offset(k as isize) as libc::c_int)\n                    as libc::c_float;\n        }\n        k+= 1;\n        *w.offset(k as isize) = q as uint16_t;\n        *z.offset(k as isize) = s;\n        *z.offset((k + 1 as libc::c_int) as isize) = crate::src::src::distance::INF;\n        q+= 1;\n    }\n    k= 0 as libc::c_int;\n    let mut q_0 = 0 as libc::c_int;\n    while q_0 < n {\n        while *z.offset((k + 1 as libc::c_int) as isize) < q_0 as libc::c_float {\n            k+= 1;\n        }\n        *d\n            .offset(\n                q_0 as isize,\n            ) = ((q_0 - *w.offset(k as isize) as libc::c_int)\n            * (q_0 - *w.offset(k as isize) as libc::c_int)) as libc::c_float\n            + *f.offset(*w.offset(k as isize) as isize);\n        *payload_out\n            .offset(\n                (q_0 * 2 as libc::c_int) as isize,\n            ) = *payload_in\n            .offset((*w.offset(k as isize) as libc::c_int * 2 as libc::c_int) as isize);\n        *payload_out\n            .offset(\n                (q_0 * 2 as libc::c_int + 1 as libc::c_int) as isize,\n            ) = *payload_in\n            .offset(\n                (*w.offset(k as isize) as libc::c_int * 2 as libc::c_int\n                    + 1 as libc::c_int) as isize,\n            );\n        q_0+= 1;\n    }\n}","src::src::ops::heman_ops_normalize_f32":"pub unsafe extern \"C\" fn heman_ops_normalize_f32(\n    mut source: *mut heman_image,\n    mut minv: libc::c_float,\n    mut maxv: libc::c_float,\n) -> *mut /* owning */ heman_image {\n    let mut result = crate::src::src::image::heman_image_create(\n        (*source).width,\n        (*source).height,\n        (*source).nbands,\n    );\n    let mut src = (*source).data;\n    let mut dst = (*result).data;\n    let mut scale = 1.0f32 / (maxv - minv);\n    let mut size = (*source).height * (*source).width * (*source).nbands;\n    let mut i = 0 as libc::c_int;\n    while i < size {\n        let fresh7 = src;\n        src= src.offset(1);\n        let mut v = ((*fresh7) - minv) * scale;\n        let fresh8 = dst;\n        dst= dst.offset(1);\n        *fresh8= if 0 as libc::c_int as libc::c_float\n            > (if 1 as libc::c_int as libc::c_float > v {\n                v\n            } else {\n                1 as libc::c_int as libc::c_float\n            })\n        {\n            0 as libc::c_int as libc::c_float\n        } else if 1 as libc::c_int as libc::c_float > v {\n            v\n        } else {\n            1 as libc::c_int as libc::c_float\n        };\n        i+= 1;\n    }\n    return result;\n}","src::kazmath::vec2::kmVec2AreEqual":"pub unsafe extern \"C\" fn kmVec2AreEqual(\n    mut p1: *const crate::src::kazmath::aabb2::kmVec2,\n    mut p2: *const crate::src::kazmath::aabb2::kmVec2,\n) -> libc::c_int {\n    return (((*p1).x as libc::c_double) < (*p2).x as libc::c_double + 0.0001f64\n        && (*p1).x as libc::c_double > (*p2).x as libc::c_double - 0.0001f64\n        && (((*p1).y as libc::c_double) < (*p2).y as libc::c_double + 0.0001f64\n            && (*p1).y as libc::c_double > (*p2).y as libc::c_double - 0.0001f64))\n        as libc::c_int;\n}","src::kazmath::mat3::kmMat3RotationToAxisAngle":"pub unsafe extern \"C\" fn kmMat3RotationToAxisAngle(\n    mut pAxis: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut radians: Option<&mut libc::c_float>,\n    mut pIn: *const kmMat3,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    let mut temp = kmQuaternion {\n        x: 0.,\n        y: 0.,\n        z: 0.,\n        w: 0.,\n    };\n    crate::src::kazmath::quaternion::kmQuaternionRotationMatrix(Some(&mut temp), pIn);\n    crate::src::kazmath::quaternion::kmQuaternionToAxisAngle(core::ptr::addr_of!(temp), pAxis.as_deref_mut(), radians.as_deref_mut());\n    return pAxis.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::plane::kmPlaneFill":"pub unsafe extern \"C\" fn kmPlaneFill(\n    mut plane: Option<&mut crate::src::kazmath::mat4::kmPlane>,\n    mut a: libc::c_float,\n    mut b: libc::c_float,\n    mut c: libc::c_float,\n    mut d: libc::c_float,\n) -> *mut crate::src::kazmath::mat4::kmPlane {\n    (*plane.as_deref_mut().unwrap()).a= a;\n    (*plane.as_deref_mut().unwrap()).b= b;\n    (*plane.as_deref_mut().unwrap()).c= c;\n    (*plane.as_deref_mut().unwrap()).d= d;\n    return plane.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::vec3::kmVec3Div":"pub unsafe extern \"C\" fn kmVec3Div(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pV1: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pV2: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    if (*pV2).x != 0. && (*pV2).y != 0. && (*pV2).z != 0. {\n        (*pOut.as_deref_mut().unwrap()).x= (*pV1).x / (*pV2).x;\n        (*pOut.as_deref_mut().unwrap()).y= (*pV1).y / (*pV2).y;\n        (*pOut.as_deref_mut().unwrap()).z= (*pV1).z / (*pV2).z;\n    }\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::mat4::kmMat4GetRightVec3":"pub unsafe extern \"C\" fn kmMat4GetRightVec3(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pIn: *const crate::src::kazmath::mat3::kmMat4,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    crate::src::kazmath::vec3::kmVec3MultiplyMat4(pOut.as_deref_mut(), &KM_VEC3_POS_X, pIn);\n    crate::src::kazmath::vec3::kmVec3Normalize(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), pOut.as_deref().map(|r| r as *const _).unwrap_or(std::ptr::null()));\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::points::heman_points_destroy":"pub unsafe extern \"C\" fn heman_points_destroy(mut img: *mut /* owning */ heman_points) {\n    free((*img).data as *mut libc::c_void);\n    free(img as *mut libc::c_void);\n}","src::kazmath::mat3::kmMat3GetForwardVec3":"pub unsafe extern \"C\" fn kmMat3GetForwardVec3(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pIn: *const kmMat3,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    (*pOut.as_deref_mut().unwrap()).x= (*pIn).mat[6 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).y= (*pIn).mat[7 as libc::c_int as usize];\n    (*pOut.as_deref_mut().unwrap()).z= (*pIn).mat[8 as libc::c_int as usize];\n    crate::src::kazmath::vec3::kmVec3Normalize(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), pOut.as_deref().map(|r| r as *const _).unwrap_or(std::ptr::null()));\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::points::heman_points_from_poisson":"pub unsafe extern \"C\" fn heman_points_from_poisson(\n    mut width: libc::c_float,\n    mut height: libc::c_float,\n    mut radius: libc::c_float,\n) -> *mut /* owning */ heman_points {\n    let mut maxattempts = 30 as libc::c_int;\n    let mut rscale = 1.0f32\n        / (2147483647 as libc::c_int as libc::c_uint)\n            .wrapping_mul(2 as libc::c_uint)\n            .wrapping_add(1 as libc::c_uint) as libc::c_float;\n    let mut seed = 0 as libc::c_int as libc::c_uint;\n    let mut rvec = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    rvec.y= radius;\n    rvec.x= rvec.y;\n    let mut r2 = radius * radius;\n    let mut cellsize = radius / sqrtf(2 as libc::c_int as libc::c_float);\n    let mut invcell = 1.0f32 / cellsize;\n    let mut ncols = ceil((width * invcell) as libc::c_double) as libc::c_int;\n    let mut nrows = ceil((height * invcell) as libc::c_double) as libc::c_int;\n    let mut maxcol = ncols - 1 as libc::c_int;\n    let mut maxrow = nrows - 1 as libc::c_int;\n    let mut ncells = ncols * nrows;\n    let mut grid = malloc(\n        (ncells as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong),\n    ) as *mut libc::c_int;\n    let mut i = 0 as libc::c_int;\n    while i < ncells {\n        *grid.offset(i as isize) = -(1 as libc::c_int);\n        i+= 1;\n    }\n    let mut actives = malloc(\n        (ncells as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong),\n    ) as *mut libc::c_int;\n    let mut nactives = 0 as libc::c_int;\n    let mut result = crate::src::src::image::heman_image_create(ncells, 1 as libc::c_int, 2 as libc::c_int);\n    let mut samples = (*result).data as *mut crate::src::kazmath::aabb2::kmVec2;\n    let mut nsamples = 0 as libc::c_int;\n    let mut pt = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    let fresh5 = seed;\n    seed= seed.wrapping_add(1);\n    pt.x= width * randhash(fresh5) as libc::c_float * rscale;\n    let fresh6 = seed;\n    seed= seed.wrapping_add(1);\n    pt.y= height * randhash(fresh6) as libc::c_float * rscale;\n    let fresh7 = nactives;\n    nactives= nactives + 1;\n    *actives.offset(fresh7 as isize) = nsamples; *grid\n        .offset(\n            ((pt.x * invcell) as libc::c_int + ncols * (pt.y * invcell) as libc::c_int)\n                as isize,\n        )  = *actives.offset(fresh7 as isize);\n    let fresh9 = nsamples;\n    nsamples= nsamples + 1;\n    *samples.offset(fresh9 as isize) = pt;\n    while nsamples < ncells {\n        let fresh10 = seed;\n        seed= seed.wrapping_add(1);\n        let mut aindex = (if randhashf(\n            fresh10,\n            0 as libc::c_int as libc::c_float,\n            nactives as libc::c_float,\n        ) > (nactives - 1 as libc::c_int) as libc::c_float\n        {\n            (nactives - 1 as libc::c_int) as libc::c_float\n        } else {\n            let fresh11 = seed;\n            seed= seed.wrapping_add(1);\n            randhashf(\n                fresh11,\n                0 as libc::c_int as libc::c_float,\n                nactives as libc::c_float,\n            )\n        }) as libc::c_int;\n        let mut sindex = *actives.offset(aindex as isize);\n        let mut found = 0 as libc::c_int;\n        let mut j = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n        let mut minj = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n        let mut maxj = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n        let mut delta = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n        let mut attempt: libc::c_int = 0;\n        attempt= 0 as libc::c_int;\n        while attempt < maxattempts && found == 0 {\n            pt= sample_annulus(radius, *samples.offset(sindex as isize), Some(&mut seed));\n            if !(pt.x < 0 as libc::c_int as libc::c_float || pt.x >= width\n                || pt.y < 0 as libc::c_int as libc::c_float || pt.y >= height)\n            {\n                maxj= pt;\n                minj= maxj;\n                crate::src::kazmath::vec2::kmVec2Add(core::ptr::addr_of_mut!(maxj), core::ptr::addr_of!(maxj), core::ptr::addr_of!(rvec));\n                crate::src::kazmath::vec2::kmVec2Subtract(core::ptr::addr_of_mut!(minj), core::ptr::addr_of!(minj), core::ptr::addr_of!(rvec));\n                crate::src::kazmath::vec2::kmVec2Scale(core::ptr::addr_of_mut!(minj), core::ptr::addr_of!(minj), invcell);\n                crate::src::kazmath::vec2::kmVec2Scale(core::ptr::addr_of_mut!(maxj), core::ptr::addr_of!(maxj), invcell);\n                minj.x= (if 0 as libc::c_int\n                    > (if maxcol > minj.x as libc::c_int {\n                        minj.x as libc::c_int\n                    } else {\n                        maxcol\n                    })\n                {\n                    0 as libc::c_int\n                } else if maxcol > minj.x as libc::c_int {\n                    minj.x as libc::c_int\n                } else {\n                    maxcol\n                }) as libc::c_float;\n                maxj.x= (if 0 as libc::c_int\n                    > (if maxcol > maxj.x as libc::c_int {\n                        maxj.x as libc::c_int\n                    } else {\n                        maxcol\n                    })\n                {\n                    0 as libc::c_int\n                } else if maxcol > maxj.x as libc::c_int {\n                    maxj.x as libc::c_int\n                } else {\n                    maxcol\n                }) as libc::c_float;\n                minj.y= (if 0 as libc::c_int\n                    > (if maxrow > minj.y as libc::c_int {\n                        minj.y as libc::c_int\n                    } else {\n                        maxrow\n                    })\n                {\n                    0 as libc::c_int\n                } else if maxrow > minj.y as libc::c_int {\n                    minj.y as libc::c_int\n                } else {\n                    maxrow\n                }) as libc::c_float;\n                maxj.y= (if 0 as libc::c_int\n                    > (if maxrow > maxj.y as libc::c_int {\n                        maxj.y as libc::c_int\n                    } else {\n                        maxrow\n                    })\n                {\n                    0 as libc::c_int\n                } else if maxrow > maxj.y as libc::c_int {\n                    maxj.y as libc::c_int\n                } else {\n                    maxrow\n                }) as libc::c_float;\n                let mut reject = 0 as libc::c_int;\n                j.y= minj.y;\n                while j.y <= maxj.y && reject == 0 {\n                    j.x= minj.x;\n                    while j.x <= maxj.x && reject == 0 {\n                        let mut entry = *grid\n                            .offset(\n                                (j.y as libc::c_int * ncols + j.x as libc::c_int) as isize,\n                            );\n                        if entry > -(1 as libc::c_int) && entry != sindex {\n                            crate::src::kazmath::vec2::kmVec2Subtract(\n                                core::ptr::addr_of_mut!(delta),\n                                core::ptr::addr_of_mut!(*samples.offset(entry as isize)),\n                                core::ptr::addr_of!(pt),\n                            );\n                            if crate::src::kazmath::vec2::kmVec2LengthSq(core::ptr::addr_of!(delta)) < r2 {\n                                reject= 1 as libc::c_int;\n                            }\n                        }\n                        j.x+= 1.;\n                    }\n                    j.y+= 1.;\n                }\n                if !(reject != 0) {\n                    found= 1 as libc::c_int;\n                }\n            }\n            attempt+= 1;\n        }\n        if found != 0 {\n            let fresh12 = nactives;\n            nactives= nactives + 1;\n            *actives.offset(fresh12 as isize) = nsamples; *grid\n                .offset(\n                    ((pt.x * invcell) as libc::c_int\n                        + ncols * (pt.y * invcell) as libc::c_int) as isize,\n                )  = *actives.offset(fresh12 as isize);\n            let fresh14 = nsamples;\n            nsamples= nsamples + 1;\n            *samples.offset(fresh14 as isize) = pt;\n        } else {\n            nactives-= 1;\n            if nactives <= 0 as libc::c_int {\n                break;\n            }\n            *actives.offset(aindex as isize) = *actives.offset(nactives as isize);\n        }\n    }\n    (*result).width= nsamples;\n    free(grid as *mut libc::c_void);\n    free(actives as *mut libc::c_void);\n    return result;\n}","src::kazmath::mat3::kmMat3AreEqual":"pub unsafe extern \"C\" fn kmMat3AreEqual(\n    mut pMat1: *const kmMat3,\n    mut pMat2: *const kmMat3,\n) -> libc::c_int {\n    let mut i: libc::c_int = 0;\n    if pMat1 == pMat2 {\n        return 1 as libc::c_int;\n    }\n    i= 0 as libc::c_int;\n    while i < 9 as libc::c_int {\n        if !((*pMat1).mat[i as usize] as libc::c_double + 0.0001f64\n            > (*pMat2).mat[i as usize] as libc::c_double\n            && (*pMat1).mat[i as usize] as libc::c_double - 0.0001f64\n                < (*pMat2).mat[i as usize] as libc::c_double)\n        {\n            return 0 as libc::c_int;\n        }\n        i+= 1;\n    }\n    return 1 as libc::c_int;\n}","src::src::ops::_match":"unsafe extern \"C\" fn _match(\n    mut mask: *mut heman_image,\n    mut mask_color: heman_color,\n    mut invert_mask: libc::c_int,\n    mut pixel_index: libc::c_int,\n) -> libc::c_int {\n    let mut mcolor = (*mask).data.offset((pixel_index * 3 as libc::c_int) as isize);\n    let mut r1 = (*mcolor.offset(0 as libc::c_int as isize)\n        * 255 as libc::c_int as libc::c_float) as libc::c_uchar;\n    let mut g1 = (*mcolor.offset(1 as libc::c_int as isize)\n        * 255 as libc::c_int as libc::c_float) as libc::c_uchar;\n    let mut b1 = (*mcolor.offset(2 as libc::c_int as isize)\n        * 255 as libc::c_int as libc::c_float) as libc::c_uchar;\n    let mut r2 = (mask_color >> 16 as libc::c_int) as libc::c_uchar;\n    let mut g2 = (mask_color >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint)\n        as libc::c_uchar;\n    let mut b2 = (mask_color & 0xff as libc::c_int as libc::c_uint) as libc::c_uchar;\n    let mut retval = (r1 as libc::c_int == r2 as libc::c_int\n        && g1 as libc::c_int == g2 as libc::c_int\n        && b1 as libc::c_int == b2 as libc::c_int) as libc::c_int;\n    return if invert_mask != 0 { 1 as libc::c_int - retval } else { retval };\n}","src::kazmath::vec2::kmVec2Length":"pub unsafe extern \"C\" fn kmVec2Length(mut pIn: *const crate::src::kazmath::aabb2::kmVec2) -> libc::c_float {\n    return sqrtf(crate::src::kazmath::utility::kmSQR((*pIn).x) + crate::src::kazmath::utility::kmSQR((*pIn).y));\n}","src::kazmath::vec4::kmVec4Assign":"pub unsafe extern \"C\" fn kmVec4Assign(\n    mut pOut: *mut crate::src::kazmath::plane::kmVec4,\n    mut pIn: *const crate::src::kazmath::plane::kmVec4,\n) -> *mut crate::src::kazmath::plane::kmVec4 {\n    if pOut != pIn as *mut crate::src::kazmath::plane::kmVec4 {} else {\n        __assert_fail(\n            b\"pOut != pIn\\0\" as *const u8 as *const libc::c_char,\n            b\"../kazmath/vec4.c\\0\" as *const u8 as *const libc::c_char,\n            176 as libc::c_int as libc::c_uint,\n            b\"kmVec4 *kmVec4Assign(kmVec4 *, const kmVec4 *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    memcpy(\n        pOut as *mut libc::c_void,\n        pIn as *const libc::c_void,\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(4 as libc::c_int as libc::c_ulong),\n    );\n    return pOut;\n}","src::src::points::sample_annulus":"pub unsafe extern \"C\" fn sample_annulus(\n    mut radius: libc::c_float,\n    mut center: crate::src::kazmath::aabb2::kmVec2,\n    mut seedptr: Option<&mut libc::c_uint>,\n) -> crate::src::kazmath::aabb2::kmVec2 {\n    let mut seed = (*seedptr.as_deref().unwrap());\n    let mut r = crate::src::kazmath::aabb2::kmVec2 { x: 0., y: 0. };\n    let mut rscale = 1.0f32\n        / (2147483647 as libc::c_int as libc::c_uint)\n            .wrapping_mul(2 as libc::c_uint)\n            .wrapping_add(1 as libc::c_uint) as libc::c_float;\n    loop {\n        let fresh3 = seed;\n        seed= seed.wrapping_add(1);\n        r.x= 4 as libc::c_int as libc::c_float * rscale\n            * randhash(fresh3) as libc::c_float - 2 as libc::c_int as libc::c_float;\n        let fresh4 = seed;\n        seed= seed.wrapping_add(1);\n        r.y= 4 as libc::c_int as libc::c_float * rscale\n            * randhash(fresh4) as libc::c_float - 2 as libc::c_int as libc::c_float;\n        let mut r2 = crate::src::kazmath::vec2::kmVec2LengthSq(core::ptr::addr_of!(r));\n        if r2 > 1 as libc::c_int as libc::c_float\n            && r2 <= 4 as libc::c_int as libc::c_float\n        {\n            break;\n        }\n    }\n    *seedptr.as_deref_mut().unwrap()= seed;\n    crate::src::kazmath::vec2::kmVec2Scale(core::ptr::addr_of_mut!(r), core::ptr::addr_of!(r), radius);\n    crate::src::kazmath::vec2::kmVec2Add(core::ptr::addr_of_mut!(r), core::ptr::addr_of!(r), core::ptr::addr_of!(center));\n    return r;\n}","src::src::color::heman_color_to_grayscale":"pub unsafe extern \"C\" fn heman_color_to_grayscale(\n    mut colorimg: *mut heman_image,\n) -> *mut /* owning */ heman_image {\n    if (*colorimg).nbands == 3 as libc::c_int {} else {\n        __assert_fail(\n            b\"colorimg->nbands == 3\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/color.c\\0\" as *const u8 as *const libc::c_char,\n            111 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_color_to_grayscale(heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut w = (*colorimg).width;\n    let mut h = (*colorimg).height;\n    let mut result = crate::src::src::image::heman_image_create(w, h, 1 as libc::c_int);\n    let mut size = w * h;\n    let mut dst = (*result).data;\n    let mut src: *const libc::c_float = (*colorimg).data as *const f32;\n    let mut i = 0 as libc::c_int;\n    while i < size {\n        let fresh11 = src;\n        src= src.offset(1);\n        let mut r = (*fresh11);\n        let fresh12 = src;\n        src= src.offset(1);\n        let mut g = (*fresh12);\n        let fresh13 = src;\n        src= src.offset(1);\n        let mut b = (*fresh13);\n        let fresh14 = dst;\n        dst= dst.offset(1);\n        *fresh14= (0.299f64 * r as libc::c_double + 0.587f64 * g as libc::c_double\n            + 0.114f64 * b as libc::c_double) as libc::c_float;\n        i+= 1;\n    }\n    return result;\n}","src::src::ops::qselect":"unsafe extern \"C\" fn qselect(\n    mut v: *mut libc::c_float,\n    mut len: libc::c_int,\n    mut k: libc::c_int,\n) -> libc::c_float {\n    let mut i: libc::c_int = 0;\n    let mut st: libc::c_int = 0;\n    i= 0 as libc::c_int;\n    st= i;\n    while i < len - 1 as libc::c_int {\n        if !(*v.offset(i as isize) > *v.offset((len - 1 as libc::c_int) as isize)) {\n            let mut f = *v.offset(i as isize);\n            *v.offset(i as isize) = *v.offset(st as isize);\n            *v.offset(st as isize) = f;\n            st+= 1;\n        }\n        i+= 1;\n    }\n    let mut __0 = *v.offset((len - 1 as libc::c_int) as isize);\n    *v.offset((len - 1 as libc::c_int) as isize) = *v.offset(st as isize);\n    *v.offset(st as isize) = __0;\n    return if k == st {\n        *v.offset(st as isize)\n    } else if st > k {\n        qselect(v, st, k)\n    } else {\n        qselect(v.offset(st as isize), len - st, k - st)\n    };\n}","src::src::lighting::azimuth_slope":"unsafe extern \"C\" fn azimuth_slope(mut a: crate::src::kazmath::aabb3::kmVec3, mut b: crate::src::kazmath::aabb3::kmVec3) -> libc::c_float {\n    let mut d = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    crate::src::kazmath::vec3::kmVec3Subtract(core::ptr::addr_of_mut!(d), core::ptr::addr_of!(a), core::ptr::addr_of!(b));\n    let mut x = crate::src::kazmath::vec3::kmVec3Length(core::ptr::addr_of!(d));\n    let mut y = b.z - a.z;\n    return y / x;\n}","src::src::color::heman_internal_rg":"pub unsafe extern \"C\" fn heman_internal_rg(\n    mut cfield: *mut heman_image,\n) -> *mut /* owning */ heman_image {\n    if (*cfield).nbands == 2 as libc::c_int {} else {\n        __assert_fail(\n            b\"cfield->nbands == 2\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/color.c\\0\" as *const u8 as *const libc::c_char,\n            129 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_internal_rg(heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut w = (*cfield).width;\n    let mut h = (*cfield).height;\n    let mut target = crate::src::src::image::heman_image_create(w, h, 3 as libc::c_int);\n    let mut dst = (*target).data;\n    let mut src = (*cfield).data;\n    let mut size = w * h;\n    let mut i = 0 as libc::c_int;\n    while i < size {\n        let fresh15 = src;\n        src= src.offset(1);\n        let mut u = (*fresh15) / w as libc::c_float;\n        let fresh16 = src;\n        src= src.offset(1);\n        let mut v = (*fresh16) / h as libc::c_float;\n        let fresh17 = dst;\n        dst= dst.offset(1);\n        *fresh17= u;\n        let fresh18 = dst;\n        dst= dst.offset(1);\n        *fresh18= v;\n        let fresh19 = dst;\n        dst= dst.offset(1);\n        *fresh19= 0 as libc::c_int as libc::c_float;\n        i+= 1;\n    }\n    return target;\n}","src::kazmath::mat3::kmMat3Multiply":"pub unsafe extern \"C\" fn kmMat3Multiply(\n    mut pOut: *mut kmMat3,\n    mut pM1: *const kmMat3,\n    mut pM2: *const kmMat3,\n) -> *mut kmMat3 {\n    let mut mat: [libc::c_float; 9] = [0.; 9];\n    let mut m1 = ((*pM1).mat).as_ptr();\n    let mut m2 = ((*pM2).mat).as_ptr();\n    mat[0 as libc::c_int\n        as usize]= *m1.offset(0 as libc::c_int as isize)\n        * *m2.offset(0 as libc::c_int as isize)\n        + *m1.offset(3 as libc::c_int as isize) * *m2.offset(1 as libc::c_int as isize)\n        + *m1.offset(6 as libc::c_int as isize) * *m2.offset(2 as libc::c_int as isize);\n    mat[1 as libc::c_int\n        as usize]= *m1.offset(1 as libc::c_int as isize)\n        * *m2.offset(0 as libc::c_int as isize)\n        + *m1.offset(4 as libc::c_int as isize) * *m2.offset(1 as libc::c_int as isize)\n        + *m1.offset(7 as libc::c_int as isize) * *m2.offset(2 as libc::c_int as isize);\n    mat[2 as libc::c_int\n        as usize]= *m1.offset(2 as libc::c_int as isize)\n        * *m2.offset(0 as libc::c_int as isize)\n        + *m1.offset(5 as libc::c_int as isize) * *m2.offset(1 as libc::c_int as isize)\n        + *m1.offset(8 as libc::c_int as isize) * *m2.offset(2 as libc::c_int as isize);\n    mat[3 as libc::c_int\n        as usize]= *m1.offset(0 as libc::c_int as isize)\n        * *m2.offset(3 as libc::c_int as isize)\n        + *m1.offset(3 as libc::c_int as isize) * *m2.offset(4 as libc::c_int as isize)\n        + *m1.offset(6 as libc::c_int as isize) * *m2.offset(5 as libc::c_int as isize);\n    mat[4 as libc::c_int\n        as usize]= *m1.offset(1 as libc::c_int as isize)\n        * *m2.offset(3 as libc::c_int as isize)\n        + *m1.offset(4 as libc::c_int as isize) * *m2.offset(4 as libc::c_int as isize)\n        + *m1.offset(7 as libc::c_int as isize) * *m2.offset(5 as libc::c_int as isize);\n    mat[5 as libc::c_int\n        as usize]= *m1.offset(2 as libc::c_int as isize)\n        * *m2.offset(3 as libc::c_int as isize)\n        + *m1.offset(5 as libc::c_int as isize) * *m2.offset(4 as libc::c_int as isize)\n        + *m1.offset(8 as libc::c_int as isize) * *m2.offset(5 as libc::c_int as isize);\n    mat[6 as libc::c_int\n        as usize]= *m1.offset(0 as libc::c_int as isize)\n        * *m2.offset(6 as libc::c_int as isize)\n        + *m1.offset(3 as libc::c_int as isize) * *m2.offset(7 as libc::c_int as isize)\n        + *m1.offset(6 as libc::c_int as isize) * *m2.offset(8 as libc::c_int as isize);\n    mat[7 as libc::c_int\n        as usize]= *m1.offset(1 as libc::c_int as isize)\n        * *m2.offset(6 as libc::c_int as isize)\n        + *m1.offset(4 as libc::c_int as isize) * *m2.offset(7 as libc::c_int as isize)\n        + *m1.offset(7 as libc::c_int as isize) * *m2.offset(8 as libc::c_int as isize);\n    mat[8 as libc::c_int\n        as usize]= *m1.offset(2 as libc::c_int as isize)\n        * *m2.offset(6 as libc::c_int as isize)\n        + *m1.offset(5 as libc::c_int as isize) * *m2.offset(7 as libc::c_int as isize)\n        + *m1.offset(8 as libc::c_int as isize) * *m2.offset(8 as libc::c_int as isize);\n    memcpy(\n        (*pOut).mat.as_mut_ptr() as *mut libc::c_void,\n        mat.as_mut_ptr() as *const libc::c_void,\n        (::std::mem::size_of::<libc::c_float>() as libc::c_ulong)\n            .wrapping_mul(9 as libc::c_int as libc::c_ulong),\n    );\n    return pOut;\n}","src::kazmath::plane::kmPlaneFromNormalAndDistance":"pub unsafe extern \"C\" fn kmPlaneFromNormalAndDistance(\n    mut plane: Option<&mut crate::src::kazmath::mat4::kmPlane>,\n    mut normal: *const crate::src::kazmath::aabb3::kmVec3,\n    mut dist: libc::c_float,\n) -> *mut crate::src::kazmath::mat4::kmPlane {\n    (*plane.as_deref_mut().unwrap()).a= (*normal).x;\n    (*plane.as_deref_mut().unwrap()).b= (*normal).y;\n    (*plane.as_deref_mut().unwrap()).c= (*normal).z;\n    (*plane.as_deref_mut().unwrap()).d= dist;\n    return plane.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::quaternion::kmQuaternionMultiply":"pub unsafe extern \"C\" fn kmQuaternionMultiply(\n    mut pOut: Option<&mut crate::src::kazmath::mat3::kmQuaternion>,\n    mut qu1: *const crate::src::kazmath::mat3::kmQuaternion,\n    mut qu2: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> *mut crate::src::kazmath::mat3::kmQuaternion {\n    let mut tmp1 = crate::src::kazmath::mat3::kmQuaternion {\n        x: 0.,\n        y: 0.,\n        z: 0.,\n        w: 0.,\n    };\n    let mut tmp2 = crate::src::kazmath::mat3::kmQuaternion {\n        x: 0.,\n        y: 0.,\n        z: 0.,\n        w: 0.,\n    };\n    kmQuaternionAssign(core::ptr::addr_of_mut!(tmp1), qu1);\n    kmQuaternionAssign(core::ptr::addr_of_mut!(tmp2), qu2);\n    let mut q1: *mut crate::src::kazmath::mat3::kmQuaternion = core::ptr::addr_of_mut!(tmp1);\n    let mut q2: *mut crate::src::kazmath::mat3::kmQuaternion = core::ptr::addr_of_mut!(tmp2);\n    (*pOut.as_deref_mut().unwrap()).x= (*q1).w * (*q2).x + (*q1).x * (*q2).w + (*q1).y * (*q2).z\n        - (*q1).z * (*q2).y;\n    (*pOut.as_deref_mut().unwrap()).y= (*q1).w * (*q2).y + (*q1).y * (*q2).w + (*q1).z * (*q2).x\n        - (*q1).x * (*q2).z;\n    (*pOut.as_deref_mut().unwrap()).z= (*q1).w * (*q2).z + (*q1).z * (*q2).w + (*q1).x * (*q2).y\n        - (*q1).y * (*q2).x;\n    (*pOut.as_deref_mut().unwrap()).w= (*q1).w * (*q2).w - (*q1).x * (*q2).x - (*q1).y * (*q2).y\n        - (*q1).z * (*q2).z;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::vec4::kmVec4Fill":"pub unsafe extern \"C\" fn kmVec4Fill(\n    mut pOut: Option<&mut crate::src::kazmath::plane::kmVec4>,\n    mut x: libc::c_float,\n    mut y: libc::c_float,\n    mut z: libc::c_float,\n    mut w: libc::c_float,\n) -> *mut crate::src::kazmath::plane::kmVec4 {\n    (*pOut.as_deref_mut().unwrap()).x= x;\n    (*pOut.as_deref_mut().unwrap()).y= y;\n    (*pOut.as_deref_mut().unwrap()).z= z;\n    (*pOut.as_deref_mut().unwrap()).w= w;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::quaternion::kmQuaternionGetRightVec3":"pub unsafe extern \"C\" fn kmQuaternionGetRightVec3(\n    mut pOut: Option<&mut crate::src::kazmath::aabb3::kmVec3>,\n    mut pIn: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    return kmQuaternionMultiplyVec3(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), pIn, &KM_VEC3_POS_X);\n}","src::kazmath::aabb2::kmAABB2Centre":"pub unsafe extern \"C\" fn kmAABB2Centre(\n    mut aabb: *const kmAABB2,\n    mut pOut: *mut kmVec2,\n) -> *mut kmVec2 {\n    crate::src::kazmath::vec2::kmVec2Add(pOut, &(*aabb).min, &(*aabb).max);\n    crate::src::kazmath::vec2::kmVec2Scale(pOut, pOut, 0.5f64 as libc::c_float);\n    return pOut;\n}","src::kazmath::utility::kmSQR":"pub unsafe extern \"C\" fn kmSQR(mut s: libc::c_float) -> libc::c_float {\n    return s * s;\n}","src::kazmath::ray3::kmRay3FromPointAndDirection":"pub unsafe extern \"C\" fn kmRay3FromPointAndDirection(\n    mut ray: *mut kmRay3,\n    mut point: *const crate::src::kazmath::aabb3::kmVec3,\n    mut direction: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut kmRay3 {\n    crate::src::kazmath::vec3::kmVec3Assign(core::ptr::addr_of_mut!((*ray).start), point);\n    crate::src::kazmath::vec3::kmVec3Assign(core::ptr::addr_of_mut!((*ray).dir), direction);\n    return ray;\n}","src::kazmath::vec3::kmVec3Subtract":"pub unsafe extern \"C\" fn kmVec3Subtract(\n    mut pOut: *mut crate::src::kazmath::aabb3::kmVec3,\n    mut pV1: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pV2: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    let mut v = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    v.x= (*pV1).x - (*pV2).x;\n    v.y= (*pV1).y - (*pV2).y;\n    v.z= (*pV1).z - (*pV2).z;\n    (*pOut).x= v.x;\n    (*pOut).y= v.y;\n    (*pOut).z= v.z;\n    return pOut;\n}","src::kazmath::ray2::kmRay2Fill":"pub unsafe extern \"C\" fn kmRay2Fill(\n    mut ray: Option<&mut kmRay2>,\n    mut px: libc::c_float,\n    mut py: libc::c_float,\n    mut vx: libc::c_float,\n    mut vy: libc::c_float,\n) {\n    (*ray.as_deref_mut().unwrap()).start.x= px;\n    (*ray.as_deref_mut().unwrap()).start.y= py;\n    (*ray.as_deref_mut().unwrap()).dir.x= vx;\n    (*ray.as_deref_mut().unwrap()).dir.y= vy;\n}","src::kazmath::aabb2::kmAABB2DiameterY":"pub unsafe extern \"C\" fn kmAABB2DiameterY(mut aabb: *const kmAABB2) -> libc::c_float {\n    return (*aabb).max.y - (*aabb).min.y;\n}","src::src::image::heman_image_extract_rgb":"pub unsafe extern \"C\" fn heman_image_extract_rgb(\n    mut img: *mut heman_image,\n) -> *mut /* owning */ heman_image {\n    if (*img).nbands == 4 as libc::c_int {} else {\n        __assert_fail(\n            b\"img->nbands == 4\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/image.c\\0\" as *const u8 as *const libc::c_char,\n            77 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_image_extract_rgb(heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut retval = heman_image_create((*img).width, (*img).height, 3 as libc::c_int);\n    let mut size = (*img).width * (*img).height;\n    let mut src = (*img).data;\n    let mut dst = (*retval).data;\n    loop {\n        let fresh8 = size;\n        size= size - 1;\n        if !(fresh8 != 0) {\n            break;\n        }\n        let fresh9 = src;\n        src= src.offset(1);\n        let fresh10 = dst;\n        dst= dst.offset(1);\n        *fresh10= (*fresh9);\n        let fresh11 = src;\n        src= src.offset(1);\n        let fresh12 = dst;\n        dst= dst.offset(1);\n        *fresh12= (*fresh11);\n        let fresh13 = src;\n        src= src.offset(1);\n        let fresh14 = dst;\n        dst= dst.offset(1);\n        *fresh14= (*fresh13);\n        src= src.offset(1);\n    }\n    return retval;\n}","src::src::ops::heman_ops_replace_color":"pub unsafe extern \"C\" fn heman_ops_replace_color(\n    mut source: *mut heman_image,\n    mut color: heman_color,\n    mut texture: *mut heman_image,\n) -> *mut /* owning */ heman_image {\n    if (*source).nbands == 3 as libc::c_int {} else {\n        __assert_fail(\n            b\"source->nbands == 3\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            359 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_replace_color(heman_image *, heman_color, heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if (*texture).nbands == 3 as libc::c_int {} else {\n        __assert_fail(\n            b\"texture->nbands == 3\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            360 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_replace_color(heman_image *, heman_color, heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut height = (*source).height;\n    let mut width = (*source).width;\n    if (*texture).width == width {} else {\n        __assert_fail(\n            b\"texture->width == width\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            363 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_replace_color(heman_image *, heman_color, heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if (*texture).height == height {} else {\n        __assert_fail(\n            b\"texture->height == height\\0\" as *const u8 as *const libc::c_char,\n            b\"../src/ops.c\\0\" as *const u8 as *const libc::c_char,\n            364 as libc::c_int as libc::c_uint,\n            b\"heman_image *heman_ops_replace_color(heman_image *, heman_color, heman_image *)\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    let mut inv = 1.0f32 / 255.0f32;\n    let mut r = (color >> 16 as libc::c_int) as libc::c_float * inv;\n    let mut g = (color >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint)\n        as libc::c_float * inv;\n    let mut b = (color & 0xff as libc::c_int as libc::c_uint) as libc::c_float * inv;\n    let mut result = crate::src::src::image::heman_image_create(width, height, 3 as libc::c_int);\n    let mut y: libc::c_int = 0;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut dst = (*result).data.offset((y * width * 3 as libc::c_int) as isize);\n        let mut src = (*source).data.offset((y * width * 3 as libc::c_int) as isize);\n        let mut tex = (*texture).data.offset((y * width * 3 as libc::c_int) as isize);\n        let mut x = 0 as libc::c_int;\n        while x < width {\n            if *src.offset(0 as libc::c_int as isize) == r\n                && *src.offset(1 as libc::c_int as isize) == g\n                && *src.offset(2 as libc::c_int as isize) == b\n            {\n                *dst\n                    .offset(\n                        0 as libc::c_int as isize,\n                    ) = *tex.offset(0 as libc::c_int as isize);\n                *dst\n                    .offset(\n                        1 as libc::c_int as isize,\n                    ) = *tex.offset(1 as libc::c_int as isize);\n                *dst\n                    .offset(\n                        2 as libc::c_int as isize,\n                    ) = *tex.offset(2 as libc::c_int as isize);\n            } else {\n                *dst\n                    .offset(\n                        0 as libc::c_int as isize,\n                    ) = *src.offset(0 as libc::c_int as isize);\n                *dst\n                    .offset(\n                        1 as libc::c_int as isize,\n                    ) = *src.offset(1 as libc::c_int as isize);\n                *dst\n                    .offset(\n                        2 as libc::c_int as isize,\n                    ) = *src.offset(2 as libc::c_int as isize);\n            }\n            x+= 1;\n            src= src.offset(3 as libc::c_int as isize);\n            dst= dst.offset(3 as libc::c_int as isize);\n            tex= tex.offset(3 as libc::c_int as isize);\n        }\n        y+= 1;\n    }\n    return result;\n}","src::kazmath::mat3::kmMat3Inverse":"pub unsafe extern \"C\" fn kmMat3Inverse(\n    mut pOut: Option<&mut kmMat3>,\n    mut pM: *const kmMat3,\n) -> *mut kmMat3 {\n    let mut determinate = kmMat3Determinant(pM);\n    let mut detInv: libc::c_float = 0.;\n    let mut adjugate = kmMat3 { mat: [0.; 9] };\n    if determinate as libc::c_double == 0.0f64 {\n        return 0 as *mut kmMat3;\n    }\n    detInv= (1.0f64 / determinate as libc::c_double) as libc::c_float;\n    kmMat3Adjugate(Some(&mut adjugate), pM);\n    kmMat3ScalarMultiply(pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), core::ptr::addr_of!(adjugate), detInv);\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::kazmath::quaternion::kmQuaternionLength":"pub unsafe extern \"C\" fn kmQuaternionLength(\n    mut pIn: *const crate::src::kazmath::mat3::kmQuaternion,\n) -> libc::c_float {\n    return sqrt(kmQuaternionLengthSq(pIn) as libc::c_double) as libc::c_float;\n}","src::kazmath::vec3::kmVec3ProjectOnToPlane":"pub unsafe extern \"C\" fn kmVec3ProjectOnToPlane(\n    mut pOut: *mut crate::src::kazmath::aabb3::kmVec3,\n    mut point: *const crate::src::kazmath::aabb3::kmVec3,\n    mut plane: *const crate::src::kazmath::mat4::kmPlane,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    let mut ray = crate::src::kazmath::ray3::kmRay3 {\n        start: crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. },\n        dir: crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. },\n    };\n    kmVec3Assign(core::ptr::addr_of_mut!(ray.start), point);\n    ray.dir.x= -(*plane).a;\n    ray.dir.y= -(*plane).b;\n    ray.dir.z= -(*plane).c;\n    crate::src::kazmath::ray3::kmRay3IntersectPlane(pOut, core::ptr::addr_of!(ray), plane);\n    return pOut;\n}","src::src::noise::open_simplex_noise_init_perm":"pub unsafe extern \"C\" fn open_simplex_noise_init_perm(\n    mut ctx: Option<&mut osn_context>,\n    mut p: *mut int16_t,\n    mut nelements: libc::c_int,\n) -> libc::c_int {\n    let mut i: libc::c_int = 0;\n    let mut rc: libc::c_int = 0;\n    rc= allocate_perm(ctx.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), nelements, 256 as libc::c_int);\n    if rc != 0 {\n        return rc;\n    }\n    memcpy(\n        (*ctx.as_deref().unwrap()).perm as *mut libc::c_void,\n        p as *const libc::c_void,\n        (::std::mem::size_of::<int16_t>() as libc::c_ulong)\n            .wrapping_mul(nelements as libc::c_ulong),\n    );\n    i= 0 as libc::c_int;\n    while i < 256 as libc::c_int {\n        *(*ctx.as_deref().unwrap()).permGradIndex3D\n            .offset(\n                i as isize,\n            ) = (*(*ctx.as_deref().unwrap()).perm.offset(i as isize) as libc::c_ulong)\n            .wrapping_rem(\n                (::std::mem::size_of::<[libc::c_schar; 72]>() as libc::c_ulong)\n                    .wrapping_div(\n                        ::std::mem::size_of::<libc::c_schar>() as libc::c_ulong,\n                    )\n                    .wrapping_div(3 as libc::c_int as libc::c_ulong),\n            )\n            .wrapping_mul(3 as libc::c_int as libc::c_ulong) as int16_t;\n        i+= 1;\n    }\n    return 0 as libc::c_int;\n}","src::kazmath::vec3::kmVec3Lerp":"pub unsafe extern \"C\" fn kmVec3Lerp(\n    mut pOut: *mut crate::src::kazmath::aabb3::kmVec3,\n    mut pV1: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pV2: *const crate::src::kazmath::aabb3::kmVec3,\n    mut t: libc::c_float,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    (*pOut).x= (*pV1).x + t * ((*pV2).x - (*pV1).x);\n    (*pOut).y= (*pV1).y + t * ((*pV2).y - (*pV1).y);\n    (*pOut).z= (*pV1).z + t * ((*pV2).z - (*pV1).z);\n    return pOut;\n}","src::kazmath::plane::kmPlaneIntersectLine":"pub unsafe extern \"C\" fn kmPlaneIntersectLine(\n    mut pOut: *mut crate::src::kazmath::aabb3::kmVec3,\n    mut pP: *const crate::src::kazmath::mat4::kmPlane,\n    mut pV1: *const crate::src::kazmath::aabb3::kmVec3,\n    mut pV2: *const crate::src::kazmath::aabb3::kmVec3,\n) -> *mut crate::src::kazmath::aabb3::kmVec3 {\n    let mut d = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    crate::src::kazmath::vec3::kmVec3Subtract(core::ptr::addr_of_mut!(d), pV2, pV1);\n    let mut n = crate::src::kazmath::aabb3::kmVec3 { x: 0., y: 0., z: 0. };\n    n.x= (*pP).a;\n    n.y= (*pP).b;\n    n.z= (*pP).c;\n    crate::src::kazmath::vec3::kmVec3Normalize(core::ptr::addr_of_mut!(n), core::ptr::addr_of!(n));\n    let mut nt = -(n.x * (*pV1).x + n.y * (*pV1).y + n.z * (*pV1).z + (*pP).d);\n    let mut dt = n.x * d.x + n.y * d.y + n.z * d.z;\n    if fabs(dt as libc::c_double) < 0.0001f64 {\n        pOut= 0 as *mut crate::src::kazmath::aabb3::kmVec3;\n        return pOut;\n    }\n    let mut t = nt / dt;\n    (*pOut).x= (*pV1).x + d.x * t;\n    (*pOut).y= (*pV1).y + d.y * t;\n    (*pOut).z= (*pV1).z + d.z * t;\n    return pOut;\n}","src::kazmath::vec4::kmVec4Subtract":"pub unsafe extern \"C\" fn kmVec4Subtract(\n    mut pOut: Option<&mut crate::src::kazmath::plane::kmVec4>,\n    mut pV1: *const crate::src::kazmath::plane::kmVec4,\n    mut pV2: *const crate::src::kazmath::plane::kmVec4,\n) -> *mut crate::src::kazmath::plane::kmVec4 {\n    (*pOut.as_deref_mut().unwrap()).x= (*pV1).x - (*pV2).x;\n    (*pOut.as_deref_mut().unwrap()).y= (*pV1).y - (*pV2).y;\n    (*pOut.as_deref_mut().unwrap()).z= (*pV1).z - (*pV2).z;\n    (*pOut.as_deref_mut().unwrap()).w= (*pV1).w - (*pV2).w;\n    return pOut.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut());\n}","src::src::generate::heman_generate_archipelago_heightmap":"pub unsafe extern \"C\" fn heman_generate_archipelago_heightmap(\n    mut width: libc::c_int,\n    mut height: libc::c_int,\n    mut points: *mut heman_points,\n    mut noiseamt: libc::c_float,\n    mut seed: libc::c_int,\n) -> *mut /* owning */ heman_image {\n    let mut noisetex = heman_internal_generate_island_noise(width, height, seed);\n    let mut coastmask = crate::src::src::image::heman_image_create(width, height, 1 as libc::c_int);\n    crate::src::src::image::heman_image_clear(coastmask.as_mut(), 0 as libc::c_int as libc::c_float);\n    heman_internal_draw_seeds(coastmask.as_mut(), points, 1 as libc::c_int);\n    let mut data = (*coastmask).data;\n    let mut invh = 1.0f32 / height as libc::c_float;\n    let mut invw = 1.0f32 / width as libc::c_float;\n    let mut hh = height / 2 as libc::c_int;\n    let mut hw = width / 2 as libc::c_int;\n    let mut y: libc::c_int = 0;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut vv = (y - hh) as libc::c_float * invh;\n        let mut dst = data.offset((y * width) as isize);\n        let mut x = 0 as libc::c_int;\n        while x < width {\n            let mut n: [libc::c_float; 3] = [0 as libc::c_int as libc::c_float, 0., 0.];\n            let mut v = y as libc::c_float * invh;\n            let mut u = x as libc::c_float * invw;\n            crate::src::src::image::heman_image_sample(noisetex.as_mut(), u, v, n.as_mut_ptr());\n            u= (x - hw) as libc::c_float * invw;\n            v= vv;\n            u+= noiseamt * n[1 as libc::c_int as usize];\n            v+= noiseamt * n[2 as libc::c_int as usize];\n            let mut m = (*dst);\n            m+= noiseamt * n[0 as libc::c_int as usize];\n            let fresh14 = dst;\n            dst= dst.offset(1);\n            *fresh14= (if m < crate::src::src::generate::SEALEVEL { 0 as libc::c_int } else { 1 as libc::c_int })\n                as libc::c_float;\n            x+= 1;\n        }\n        y+= 1;\n    }\n    let mut heightmap = crate::src::src::distance::heman_distance_create_sdf(coastmask);\n    crate::src::src::image::heman_image_destroy(coastmask);\n    let mut result = crate::src::src::image::heman_image_create(width, height, 1 as libc::c_int);\n    data= (*result).data;\n    y= 0 as libc::c_int;\n    while y < height {\n        let mut dst_0 = data.offset((y * width) as isize);\n        let mut x_0 = 0 as libc::c_int;\n        while x_0 < width {\n            let mut n_0: [libc::c_float; 3] = [0.; 3];\n            let mut u_0 = x_0 as libc::c_float * invw;\n            let mut v_0 = y as libc::c_float * invh;\n            crate::src::src::image::heman_image_sample(noisetex.as_mut(), u_0, v_0, n_0.as_mut_ptr());\n            let mut z: libc::c_float = 0.;\n            crate::src::src::image::heman_image_sample(heightmap.as_mut(), u_0, v_0, core::ptr::addr_of_mut!(z));\n            if z as libc::c_double > 0.0f64 {\n                let mut influence = z;\n                u_0+= influence * n_0[1 as libc::c_int as usize];\n                v_0+= influence * n_0[2 as libc::c_int as usize];\n                crate::src::src::image::heman_image_sample(heightmap.as_mut(), u_0, v_0, core::ptr::addr_of_mut!(z));\n                z+= 6 as libc::c_int as libc::c_float * influence\n                        * n_0[0 as libc::c_int as usize];\n            }\n            let fresh15 = dst_0;\n            dst_0= dst_0.offset(1);\n            *fresh15= z;\n            x_0+= 1;\n        }\n        y+= 1;\n    }\n    crate::src::src::image::heman_image_destroy(noisetex);\n    crate::src::src::image::heman_image_destroy(heightmap);\n    return result;\n}","src::src::noise::allocate_perm":"unsafe extern \"C\" fn allocate_perm(\n    mut ctx: *mut osn_context,\n    mut nperm: libc::c_int,\n    mut ngrad: libc::c_int,\n) -> libc::c_int {\n    if !(*ctx).perm.is_null() {\n        free((*ctx).perm as *mut libc::c_void);\n    }else { (); }\n    if !(*ctx).permGradIndex3D.is_null() {\n        free((*ctx).permGradIndex3D as *mut libc::c_void);\n    }else { (); }\n    (*ctx).perm= malloc(\n        (::std::mem::size_of::<int16_t>() as libc::c_ulong)\n            .wrapping_mul(nperm as libc::c_ulong),\n    ) as *mut int16_t;\n    if (*ctx).perm.is_null() {();\n        return -(12 as libc::c_int);\n    }\n    (*ctx).permGradIndex3D= malloc(\n        (::std::mem::size_of::<int16_t>() as libc::c_ulong)\n            .wrapping_mul(ngrad as libc::c_ulong),\n    ) as *mut int16_t;\n    if (*ctx).permGradIndex3D.is_null() {();\n        free((*ctx).perm as *mut libc::c_void);\n        return -(12 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}"},"struct_data":{"src::kazmath::mat4::ErasedByPreprocessor1":"struct ErasedByPreprocessor1 { dummy: () }","src::kazmath::vec2::ErasedByPreprocessor14":"struct ErasedByPreprocessor14 { dummy: () }","src::kazmath::plane::ErasedByPreprocessor7":"struct ErasedByPreprocessor7 { dummy: () }","src::kazmath::vec3::ErasedByPreprocessor19":"struct ErasedByPreprocessor19 { dummy: () }","src::kazmath::vec3::ErasedByPreprocessor16":"struct ErasedByPreprocessor16 { dummy: () }","src::kazmath::mat3::kmMat3":"pub struct kmMat3 {\n    pub mat: [libc::c_float; 9],\n}","src::kazmath::vec3::ErasedByPreprocessor21":"struct ErasedByPreprocessor21 { dummy: () }","src::kazmath::ray2::kmRay2":"pub struct kmRay2 {\n    pub start: crate::src::kazmath::aabb2::kmVec2,\n    pub dir: crate::src::kazmath::aabb2::kmVec2,\n}","src::kazmath::mat4::ErasedByPreprocessor2":"struct ErasedByPreprocessor2 { dummy: () }","src::kazmath::vec3::ErasedByPreprocessor20":"struct ErasedByPreprocessor20 { dummy: () }","src::src::draw::ErasedByPreprocessor25":"struct ErasedByPreprocessor25 { dummy: () }","src::src::export::_IO_FILE":"pub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}","src::src::generate::ErasedByPreprocessor28":"struct ErasedByPreprocessor28 { dummy: () }","src::src::lighting::ErasedByPreprocessor31":"struct ErasedByPreprocessor31 { dummy: () }","src::src::lighting::ErasedByPreprocessor32":"struct ErasedByPreprocessor32 { dummy: () }","src::src::noise::osn_context":"pub struct osn_context {\n    pub perm: *mut /* owning */ int16_t,\n    pub permGradIndex3D: *mut /* owning */ int16_t,\n}","src::kazmath::quaternion::ErasedByPreprocessor8":"struct ErasedByPreprocessor8 { dummy: () }","src::src::color::ErasedByRefactorer0":"struct ErasedByRefactorer0;","src::src::image::ErasedByPreprocessor29":"struct ErasedByPreprocessor29 { dummy: () }","src::src::distance::ErasedByPreprocessor24":"struct ErasedByPreprocessor24 { dummy: () }","src::src::export::ErasedByPreprocessor26":"struct ErasedByPreprocessor26 { dummy: () }","src::kazmath::mat4::ErasedByPreprocessor4":"struct ErasedByPreprocessor4 { dummy: () }","src::src::generate::ErasedByPreprocessor27":"struct ErasedByPreprocessor27 { dummy: () }","src::src::points::ErasedByPreprocessor36":"struct ErasedByPreprocessor36 { dummy: () }","src::src::noise::ErasedByRefactorer1":"struct ErasedByRefactorer1;","src::kazmath::aabb3::kmVec3":"pub struct kmVec3 {\n    pub x: libc::c_float,\n    pub y: libc::c_float,\n    pub z: libc::c_float,\n}","src::kazmath::aabb3::kmAABB3":"pub struct kmAABB3 {\n    pub min: kmVec3,\n    pub max: kmVec3,\n}","src::src::color::heman_image_s":"pub struct heman_image_s {\n    pub width: libc::c_int,\n    pub height: libc::c_int,\n    pub nbands: libc::c_int,\n    pub data: *mut /* owning */ libc::c_float,\n}","src::kazmath::vec2::ErasedByPreprocessor15":"struct ErasedByPreprocessor15 { dummy: () }","src::src::import::ErasedByPreprocessor30":"struct ErasedByPreprocessor30 { dummy: () }","src::kazmath::plane::kmVec4":"pub struct kmVec4 {\n    pub x: libc::c_float,\n    pub y: libc::c_float,\n    pub z: libc::c_float,\n    pub w: libc::c_float,\n}","src::src::ops::ErasedByPreprocessor33":"struct ErasedByPreprocessor33 { dummy: () }","src::src::ops::ErasedByPreprocessor34":"struct ErasedByPreprocessor34 { dummy: () }","src::kazmath::mat3::ErasedByPreprocessor0":"struct ErasedByPreprocessor0 { dummy: () }","src::kazmath::aabb2::kmVec2":"pub struct kmVec2 {\n    pub x: libc::c_float,\n    pub y: libc::c_float,\n}","src::kazmath::plane::ErasedByPreprocessor6":"struct ErasedByPreprocessor6 { dummy: () }","src::kazmath::ray3::ErasedByPreprocessor13":"struct ErasedByPreprocessor13 { dummy: () }","src::src::points::ErasedByPreprocessor35":"struct ErasedByPreprocessor35 { dummy: () }","src::kazmath::vec4::ErasedByPreprocessor23":"struct ErasedByPreprocessor23 { dummy: () }","src::kazmath::mat4::ErasedByPreprocessor3":"struct ErasedByPreprocessor3 { dummy: () }","src::kazmath::quaternion::ErasedByPreprocessor10":"struct ErasedByPreprocessor10 { dummy: () }","src::kazmath::mat3::kmMat4":"pub struct kmMat4 {\n    pub mat: [libc::c_float; 16],\n}","src::kazmath::aabb2::kmAABB2":"pub struct kmAABB2 {\n    pub min: kmVec2,\n    pub max: kmVec2,\n}","src::kazmath::ray3::ErasedByPreprocessor12":"struct ErasedByPreprocessor12 { dummy: () }","src::kazmath::plane::ErasedByPreprocessor5":"struct ErasedByPreprocessor5 { dummy: () }","src::kazmath::vec3::ErasedByPreprocessor17":"struct ErasedByPreprocessor17 { dummy: () }","src::kazmath::ray3::kmRay3":"pub struct kmRay3 {\n    pub start: crate::src::kazmath::aabb3::kmVec3,\n    pub dir: crate::src::kazmath::aabb3::kmVec3,\n}","src::kazmath::vec3::ErasedByPreprocessor18":"struct ErasedByPreprocessor18 { dummy: () }","src::kazmath::ray2::ErasedByPreprocessor11":"struct ErasedByPreprocessor11 { dummy: () }","src::kazmath::vec4::ErasedByPreprocessor22":"struct ErasedByPreprocessor22 { dummy: () }","src::kazmath::quaternion::ErasedByPreprocessor9":"struct ErasedByPreprocessor9 { dummy: () }","src::kazmath::mat3::kmQuaternion":"pub struct kmQuaternion {\n    pub x: libc::c_float,\n    pub y: libc::c_float,\n    pub z: libc::c_float,\n    pub w: libc::c_float,\n}","src::kazmath::mat4::kmPlane":"pub struct kmPlane {\n    pub a: libc::c_float,\n    pub b: libc::c_float,\n    pub c: libc::c_float,\n    pub d: libc::c_float,\n}"}}