# 0 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c"
# 26 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef unsigned chtype;
typedef chtype attr_t;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 2
# 27 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/memory.h" 1
# 28 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/assert.h" 1
# 29 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c" 2

# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/utility.h" 1
# 29 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/utility.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/math.h" 1
# 30 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/utility.h" 2
# 81 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/utility.h"
extern float kmSQR(float s);
extern float kmDegreesToRadians(float degrees);
extern float kmRadiansToDegrees(float radians);

extern float kmMin(float lhs, float rhs);
extern float kmMax(float lhs, float rhs);
extern unsigned char kmAlmostEqual(float lhs, float rhs);

extern float kmClamp(float x, float min, float max);
extern float kmLerp(float x, float y, float factor);
# 31 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/vec3.h" 1
# 29 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/vec3.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/assert.h" 1
# 30 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/vec3.h" 2


struct kmMat4;
struct kmMat3;
struct kmPlane;

typedef struct kmVec3 {
 float x;
 float y;
 float z;
} kmVec3;





kmVec3* kmVec3Fill(kmVec3* pOut, float x, float y, float z);
float kmVec3Length(const kmVec3* pIn);
float kmVec3LengthSq(const kmVec3* pIn);
kmVec3* kmVec3Lerp(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2, float t);
kmVec3* kmVec3Normalize(kmVec3* pOut, const kmVec3* pIn);
kmVec3* kmVec3Cross(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2);
float kmVec3Dot(const kmVec3* pV1, const kmVec3* pV2);
kmVec3* kmVec3Add(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2);
kmVec3* kmVec3Subtract(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2);
kmVec3* kmVec3Mul( kmVec3* pOut,const kmVec3* pV1, const kmVec3* pV2 );
kmVec3* kmVec3Div( kmVec3* pOut,const kmVec3* pV1, const kmVec3* pV2 );

kmVec3* kmVec3MultiplyMat3(kmVec3 *pOut, const kmVec3 *pV, const struct kmMat3* pM);
kmVec3* kmVec3MultiplyMat4(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);

kmVec3* kmVec3Transform(kmVec3* pOut, const kmVec3* pV1, const struct kmMat4* pM);
kmVec3* kmVec3TransformNormal(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);
kmVec3* kmVec3TransformCoord(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);

kmVec3* kmVec3Scale(kmVec3* pOut, const kmVec3* pIn, const float s);
int kmVec3AreEqual(const kmVec3* p1, const kmVec3* p2);
kmVec3* kmVec3InverseTransform(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);
kmVec3* kmVec3InverseTransformNormal(kmVec3* pOut, const kmVec3* pVect, const struct kmMat4* pM);
kmVec3* kmVec3Assign(kmVec3* pOut, const kmVec3* pIn);
kmVec3* kmVec3Zero(kmVec3* pOut);
kmVec3* kmVec3GetHorizontalAngle(kmVec3* pOut, const kmVec3 *pIn);
kmVec3* kmVec3RotationToDirection(kmVec3* pOut, const kmVec3* pIn, const kmVec3* forwards);

kmVec3* kmVec3ProjectOnToPlane(kmVec3* pOut, const kmVec3* point, const struct kmPlane* plane);

kmVec3* kmVec3Reflect(kmVec3* pOut, const kmVec3* pIn, const kmVec3* normal);

extern const kmVec3 KM_VEC3_NEG_Z;
extern const kmVec3 KM_VEC3_POS_Z;
extern const kmVec3 KM_VEC3_POS_Y;
extern const kmVec3 KM_VEC3_NEG_Y;
extern const kmVec3 KM_VEC3_NEG_X;
extern const kmVec3 KM_VEC3_POS_X;
extern const kmVec3 KM_VEC3_ZERO;
# 32 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.h" 1
# 35 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.h"
struct kmVec3;
struct kmQuaternion;
struct kmMat4;

typedef struct kmMat3{
 float mat[9];
} kmMat3;





kmMat3* kmMat3Fill(kmMat3* pOut, const float* pMat);
kmMat3* kmMat3Adjugate(kmMat3* pOut, const kmMat3* pIn);
kmMat3* kmMat3Identity(kmMat3* pOut);
kmMat3* kmMat3Inverse(kmMat3* pOut, const kmMat3* pM);
int kmMat3IsIdentity(const kmMat3* pIn);
kmMat3* kmMat3Transpose(kmMat3* pOut, const kmMat3* pIn);
float kmMat3Determinant(const kmMat3* pIn);
kmMat3* kmMat3Multiply(kmMat3* pOut, const kmMat3* pM1, const kmMat3* pM2);
kmMat3* kmMat3ScalarMultiply(kmMat3* pOut, const kmMat3* pM, const float pFactor);

kmMat3* kmMat3Assign(kmMat3* pOut, const kmMat3* pIn);
kmMat3* kmMat3AssignMat4(kmMat3* pOut, const struct kmMat4* pIn);
int kmMat3AreEqual(const kmMat3* pM1, const kmMat3* pM2);

struct kmVec3* kmMat3GetUpVec3(struct kmVec3* pOut, const kmMat3* pIn);
struct kmVec3* kmMat3GetRightVec3(struct kmVec3* pOut, const kmMat3* pIn);
struct kmVec3* kmMat3GetForwardVec3(struct kmVec3* pOut, const kmMat3* pIn);

kmMat3* kmMat3RotationX(kmMat3* pOut, const float radians);
kmMat3* kmMat3RotationY(kmMat3* pOut, const float radians);
kmMat3* kmMat3RotationZ(kmMat3* pOut, const float radians);

kmMat3* kmMat3Rotation(kmMat3* pOut, const float radians);
kmMat3* kmMat3Scaling(kmMat3* pOut, const float x, const float y);
kmMat3* kmMat3Translation(kmMat3* pOut, const float x, const float y);

kmMat3* kmMat3RotationQuaternion(kmMat3* pOut, const struct kmQuaternion* pIn);

kmMat3* kmMat3RotationAxisAngle(kmMat3* pOut, const struct kmVec3* axis, float radians);
struct kmVec3* kmMat3RotationToAxisAngle(struct kmVec3* pAxis, float* radians, const kmMat3* pIn);
kmMat3* kmMat3LookAt(kmMat3* pOut, const struct kmVec3* pEye, const struct kmVec3* pCenter, const struct kmVec3* pUp);
# 33 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat4.h" 1
# 31 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat4.h"
struct kmVec3;
struct kmMat3;
struct kmQuaternion;
struct kmPlane;
# 49 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat4.h"
typedef struct kmMat4 {
 float mat[16];
} kmMat4;

kmMat4* kmMat4Fill(kmMat4* pOut, const float* pMat);


kmMat4* kmMat4Identity(kmMat4* pOut);

kmMat4* kmMat4Inverse(kmMat4* pOut, const kmMat4* pM);


int kmMat4IsIdentity(const kmMat4* pIn);

kmMat4* kmMat4Transpose(kmMat4* pOut, const kmMat4* pIn);
kmMat4* kmMat4Multiply(kmMat4* pOut, const kmMat4* pM1, const kmMat4* pM2);

kmMat4* kmMat4Assign(kmMat4* pOut, const kmMat4* pIn);
kmMat4* kmMat4AssignMat3(kmMat4* pOut, const struct kmMat3* pIn);

int kmMat4AreEqual(const kmMat4* pM1, const kmMat4* pM2);

kmMat4* kmMat4RotationX(kmMat4* pOut, const float radians);
kmMat4* kmMat4RotationY(kmMat4* pOut, const float radians);
kmMat4* kmMat4RotationZ(kmMat4* pOut, const float radians);
kmMat4* kmMat4RotationYawPitchRoll(kmMat4* pOut, const float pitch, const float yaw, const float roll);
kmMat4* kmMat4RotationQuaternion(kmMat4* pOut, const struct kmQuaternion* pQ);
kmMat4* kmMat4RotationTranslation(kmMat4* pOut, const struct kmMat3* rotation, const struct kmVec3* translation);
kmMat4* kmMat4Scaling(kmMat4* pOut, const float x, const float y, const float z);
kmMat4* kmMat4Translation(kmMat4* pOut, const float x, const float y, const float z);

struct kmVec3* kmMat4GetUpVec3(struct kmVec3* pOut, const kmMat4* pIn);
struct kmVec3* kmMat4GetRightVec3(struct kmVec3* pOut, const kmMat4* pIn);
struct kmVec3* kmMat4GetForwardVec3RH(struct kmVec3* pOut, const kmMat4* pIn);
struct kmVec3* kmMat4GetForwardVec3LH(struct kmVec3* pOut, const kmMat4* pIn);

kmMat4* kmMat4PerspectiveProjection(kmMat4* pOut, float fovY, float aspect, float zNear, float zFar);
kmMat4* kmMat4OrthographicProjection(kmMat4* pOut, float left, float right, float bottom, float top, float nearVal, float farVal);
kmMat4* kmMat4LookAt(kmMat4* pOut, const struct kmVec3* pEye, const struct kmVec3* pCenter, const struct kmVec3* pUp);

kmMat4* kmMat4RotationAxisAngle(kmMat4* pOut, const struct kmVec3* axis, float radians);
struct kmMat3* kmMat4ExtractRotation(struct kmMat3* pOut, const kmMat4* pIn);
struct kmPlane* kmMat4ExtractPlane(struct kmPlane* pOut, const kmMat4* pIn, const unsigned int plane);
struct kmVec3* kmMat4RotationToAxisAngle(struct kmVec3* pAxis, float* radians, const kmMat4* pIn);
# 34 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/quaternion.h" 1
# 35 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/quaternion.h"
struct kmMat4;
struct kmMat3;
struct kmVec3;

typedef struct kmQuaternion {
 float x;
 float y;
 float z;
 float w;
} kmQuaternion;

int kmQuaternionAreEqual(const kmQuaternion* p1, const kmQuaternion* p2);
kmQuaternion* kmQuaternionFill(kmQuaternion* pOut, float x, float y, float z, float w);
float kmQuaternionDot(const kmQuaternion* q1, const kmQuaternion* q2);

kmQuaternion* kmQuaternionExp(kmQuaternion* pOut, const kmQuaternion* pIn);



kmQuaternion* kmQuaternionIdentity(kmQuaternion* pOut);



kmQuaternion* kmQuaternionInverse(kmQuaternion* pOut, const kmQuaternion* pIn);



int kmQuaternionIsIdentity(const kmQuaternion* pIn);



float kmQuaternionLength(const kmQuaternion* pIn);



float kmQuaternionLengthSq(const kmQuaternion* pIn);



kmQuaternion* kmQuaternionLn(kmQuaternion* pOut, const kmQuaternion* pIn);



kmQuaternion* kmQuaternionMultiply(kmQuaternion* pOut, const kmQuaternion* q1, const kmQuaternion* q2);



kmQuaternion* kmQuaternionNormalize(kmQuaternion* pOut, const kmQuaternion* pIn);



kmQuaternion* kmQuaternionRotationAxisAngle(kmQuaternion* pOut, const struct kmVec3* pV, float angle);



kmQuaternion* kmQuaternionRotationMatrix(kmQuaternion* pOut, const struct kmMat3* pIn);



kmQuaternion* kmQuaternionRotationPitchYawRoll(kmQuaternion* pOut, float pitch, float yaw, float roll);

kmQuaternion* kmQuaternionSlerp(kmQuaternion* pOut, const kmQuaternion* q1, const kmQuaternion* q2, float t);


void kmQuaternionToAxisAngle(const kmQuaternion* pIn, struct kmVec3* pVector, float* pAngle);


kmQuaternion* kmQuaternionScale(kmQuaternion* pOut, const kmQuaternion* pIn, float s);
kmQuaternion* kmQuaternionAssign(kmQuaternion* pOut, const kmQuaternion* pIn);
kmQuaternion* kmQuaternionAdd(kmQuaternion* pOut, const kmQuaternion* pQ1, const kmQuaternion* pQ2);
kmQuaternion* kmQuaternionSubtract(kmQuaternion* pOut, const kmQuaternion* pQ1, const kmQuaternion* pQ2);

kmQuaternion* kmQuaternionRotationBetweenVec3(kmQuaternion* pOut, const struct kmVec3* vec1, const struct kmVec3* vec2, const struct kmVec3* fallback);
struct kmVec3* kmQuaternionMultiplyVec3(struct kmVec3* pOut, const kmQuaternion* q, const struct kmVec3* v);

kmVec3* kmQuaternionGetUpVec3(kmVec3* pOut, const kmQuaternion* pIn);
kmVec3* kmQuaternionGetRightVec3(kmVec3* pOut, const kmQuaternion* pIn);
kmVec3* kmQuaternionGetForwardVec3RH(kmVec3* pOut, const kmQuaternion* pIn);
kmVec3* kmQuaternionGetForwardVec3LH(kmVec3* pOut, const kmQuaternion* pIn);

float kmQuaternionGetPitch(const kmQuaternion* q);
float kmQuaternionGetYaw(const kmQuaternion* q);
float kmQuaternionGetRoll(const kmQuaternion* q);

kmQuaternion* kmQuaternionLookRotation(kmQuaternion* pOut, const kmVec3* direction, const kmVec3* up);
# 35 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c" 2

kmMat3* kmMat3Fill(kmMat3* pOut, const float* pMat)
{
    memcpy(pOut->mat, pMat, sizeof(float) * 9);
    return pOut;
}


kmMat3* kmMat3Identity(kmMat3* pOut)
{
 memset(pOut->mat, 0, sizeof(float) * 9);
 pOut->mat[0] = pOut->mat[4] = pOut->mat[8] = 1.0f;
 return pOut;
}

float kmMat3Determinant(const kmMat3* pIn)
{
    float output;
# 62 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c"
    output = pIn->mat[0] * pIn->mat[4] * pIn->mat[8] + pIn->mat[1] * pIn->mat[5] * pIn->mat[6] + pIn->mat[2] * pIn->mat[3] * pIn->mat[7];
    output -= pIn->mat[2] * pIn->mat[4] * pIn->mat[6] + pIn->mat[0] * pIn->mat[5] * pIn->mat[7] + pIn->mat[1] * pIn->mat[3] * pIn->mat[8];

    return output;
}


kmMat3* kmMat3Adjugate(kmMat3* pOut, const kmMat3* pIn)
{
    pOut->mat[0] = pIn->mat[4] * pIn->mat[8] - pIn->mat[5] * pIn->mat[7];
    pOut->mat[1] = pIn->mat[2] * pIn->mat[7] - pIn->mat[1] * pIn->mat[8];
    pOut->mat[2] = pIn->mat[1] * pIn->mat[5] - pIn->mat[2] * pIn->mat[4];
    pOut->mat[3] = pIn->mat[5] * pIn->mat[6] - pIn->mat[3] * pIn->mat[8];
    pOut->mat[4] = pIn->mat[0] * pIn->mat[8] - pIn->mat[2] * pIn->mat[6];
    pOut->mat[5] = pIn->mat[2] * pIn->mat[3] - pIn->mat[0] * pIn->mat[5];
    pOut->mat[6] = pIn->mat[3] * pIn->mat[7] - pIn->mat[4] * pIn->mat[6];
    pOut->mat[7] = pIn->mat[1] * pIn->mat[6] - pIn->mat[0] * pIn->mat[7];
    pOut->mat[8] = pIn->mat[0] * pIn->mat[4] - pIn->mat[1] * pIn->mat[3];

    return pOut;
}

kmMat3* kmMat3Inverse(kmMat3* pOut, const kmMat3* pM)
{
    float determinate = kmMat3Determinant(pM);
    float detInv;
    kmMat3 adjugate;

    if(determinate == 0.0)
    {
        return 0;
    }

    detInv = 1.0 / determinate;

 kmMat3Adjugate(&adjugate, pM);
 kmMat3ScalarMultiply(pOut, &adjugate, detInv);

 return pOut;
}


int kmMat3IsIdentity(const kmMat3* pIn)
{
 static float identity [] = { 1.0f, 0.0f, 0.0f,
          0.0f, 1.0f, 0.0f,
          0.0f, 0.0f, 1.0f};

 return (memcmp(identity, pIn->mat, sizeof(float) * 9) == 0);
}


kmMat3* kmMat3Transpose(kmMat3* pOut, const kmMat3* pIn)
{
    float temp[9];

    temp[0] = pIn->mat[0];
    temp[1] = pIn->mat[3];
    temp[2] = pIn->mat[6];

    temp[3] = pIn->mat[1];
    temp[4] = pIn->mat[4];
    temp[5] = pIn->mat[7];

    temp[6] = pIn->mat[2];
    temp[7] = pIn->mat[5];
    temp[8] = pIn->mat[8];

    memcpy(&pOut->mat, temp, sizeof(float)*9);

 return pOut;
}


kmMat3* kmMat3Multiply(kmMat3* pOut, const kmMat3* pM1, const kmMat3* pM2)
{
 float mat[9];

 const float *m1 = pM1->mat, *m2 = pM2->mat;

 mat[0] = m1[0] * m2[0] + m1[3] * m2[1] + m1[6] * m2[2];
 mat[1] = m1[1] * m2[0] + m1[4] * m2[1] + m1[7] * m2[2];
 mat[2] = m1[2] * m2[0] + m1[5] * m2[1] + m1[8] * m2[2];

 mat[3] = m1[0] * m2[3] + m1[3] * m2[4] + m1[6] * m2[5];
 mat[4] = m1[1] * m2[3] + m1[4] * m2[4] + m1[7] * m2[5];
 mat[5] = m1[2] * m2[3] + m1[5] * m2[4] + m1[8] * m2[5];

 mat[6] = m1[0] * m2[6] + m1[3] * m2[7] + m1[6] * m2[8];
 mat[7] = m1[1] * m2[6] + m1[4] * m2[7] + m1[7] * m2[8];
 mat[8] = m1[2] * m2[6] + m1[5] * m2[7] + m1[8] * m2[8];

 memcpy(pOut->mat, mat, sizeof(float)*9);

 return pOut;
}

kmMat3* kmMat3ScalarMultiply(kmMat3* pOut, const kmMat3* pM, const float pFactor)
{
    float mat[9];
    int i;

    for(i = 0; i < 9; i++)
    {
        mat[i] = pM->mat[i] * pFactor;
    }

    memcpy(pOut->mat, mat, sizeof(float)*9);

 return pOut;
}


kmMat3* kmMat3Assign(kmMat3* pOut, const kmMat3* pIn)
{
 assert(pOut != pIn);

 memcpy(pOut->mat, pIn->mat, sizeof(float)*9);

 return pOut;
}

kmMat3* kmMat3AssignMat4(kmMat3* pOut, const kmMat4* pIn) {
    pOut->mat[0] = pIn->mat[0];
    pOut->mat[1] = pIn->mat[1];
    pOut->mat[2] = pIn->mat[2];

    pOut->mat[3] = pIn->mat[4];
    pOut->mat[4] = pIn->mat[5];
    pOut->mat[5] = pIn->mat[6];

    pOut->mat[6] = pIn->mat[8];
    pOut->mat[7] = pIn->mat[9];
    pOut->mat[8] = pIn->mat[10];
    return pOut;
}


int kmMat3AreEqual(const kmMat3* pMat1, const kmMat3* pMat2)
{
 int i;
 if (pMat1 == pMat2) {
  return 1;
 }

 for (i = 0; i < 9; ++i) {
  if (!(pMat1->mat[i] + 0.0001 > pMat2->mat[i] &&
            pMat1->mat[i] - 0.0001 < pMat2->mat[i])) {
   return 0;
        }
 }

 return 1;
}


kmMat3* kmMat3Rotation(kmMat3* pOut, const float radians)
{






 pOut->mat[0] = cosf(radians);
 pOut->mat[1] = sinf(radians);
 pOut->mat[2] = 0.0f;

 pOut->mat[3] = -sinf(radians);
 pOut->mat[4] = cosf(radians);
 pOut->mat[5] = 0.0f;

 pOut->mat[6] = 0.0f;
 pOut->mat[7] = 0.0f;
 pOut->mat[8] = 1.0f;

 return pOut;
}


kmMat3* kmMat3Scaling(kmMat3* pOut, const float x, const float y)
{

 kmMat3Identity(pOut);
 pOut->mat[0] = x;
 pOut->mat[4] = y;

 return pOut;
}

kmMat3* kmMat3Translation(kmMat3* pOut, const float x, const float y)
{

 kmMat3Identity(pOut);
 pOut->mat[6] = x;
 pOut->mat[7] = y;


    return pOut;
}


kmMat3* kmMat3RotationQuaternion(kmMat3* pOut, const kmQuaternion* pIn)
{
    if (!pIn || !pOut) {
 return 0;
    }


    pOut->mat[0] = 1.0f - 2.0f * (pIn->y * pIn->y + pIn->z * pIn->z);
    pOut->mat[1] = 2.0f * (pIn->x * pIn->y - pIn->w * pIn->z);
    pOut->mat[2] = 2.0f * (pIn->x * pIn->z + pIn->w * pIn->y);


    pOut->mat[3] = 2.0f * (pIn->x * pIn->y + pIn->w * pIn->z);
    pOut->mat[4] = 1.0f - 2.0f * (pIn->x * pIn->x + pIn->z * pIn->z);
    pOut->mat[5] = 2.0f * (pIn->y * pIn->z - pIn->w * pIn->x);


    pOut->mat[6] = 2.0f * (pIn->x * pIn->z - pIn->w * pIn->y);
    pOut->mat[7] = 2.0f * (pIn->y * pIn->z + pIn->w * pIn->x);
    pOut->mat[8] = 1.0f - 2.0f * (pIn->x * pIn->x + pIn->y * pIn->y);

    return pOut;
}

kmMat3* kmMat3RotationAxisAngle(kmMat3* pOut, const struct kmVec3* axis, float radians)
{
    float rcos = cosf(radians);
    float rsin = sinf(radians);

    pOut->mat[0] = rcos + axis->x * axis->x * (1 - rcos);
    pOut->mat[1] = axis->z * rsin + axis->y * axis->x * (1 - rcos);
    pOut->mat[2] = -axis->y * rsin + axis->z * axis->x * (1 - rcos);

    pOut->mat[3] = -axis->z * rsin + axis->x * axis->y * (1 - rcos);
    pOut->mat[4] = rcos + axis->y * axis->y * (1 - rcos);
    pOut->mat[5] = axis->x * rsin + axis->z * axis->y * (1 - rcos);

    pOut->mat[6] = axis->y * rsin + axis->x * axis->z * (1 - rcos);
    pOut->mat[7] = -axis->x * rsin + axis->y * axis->z * (1 - rcos);
    pOut->mat[8] = rcos + axis->z * axis->z * (1 - rcos);

    return pOut;
}

kmVec3* kmMat3RotationToAxisAngle(kmVec3* pAxis, float* radians, const kmMat3* pIn)
{

    kmQuaternion temp;
    kmQuaternionRotationMatrix(&temp, pIn);
    kmQuaternionToAxisAngle(&temp, pAxis, radians);
    return pAxis;
}




kmMat3* kmMat3RotationX(kmMat3* pOut, const float radians)
{







 pOut->mat[0] = 1.0f;
 pOut->mat[1] = 0.0f;
 pOut->mat[2] = 0.0f;

 pOut->mat[3] = 0.0f;
 pOut->mat[4] = cosf(radians);
 pOut->mat[5] = sinf(radians);

 pOut->mat[6] = 0.0f;
 pOut->mat[7] = -sinf(radians);
 pOut->mat[8] = cosf(radians);

 return pOut;
}





kmMat3* kmMat3RotationY(kmMat3* pOut, const float radians)
{






 pOut->mat[0] = cosf(radians);
 pOut->mat[1] = 0.0f;
 pOut->mat[2] = -sinf(radians);

 pOut->mat[3] = 0.0f;
 pOut->mat[4] = 1.0f;
 pOut->mat[5] = 0.0f;

 pOut->mat[6] = sinf(radians);
 pOut->mat[7] = 0.0f;
 pOut->mat[8] = cosf(radians);

 return pOut;
}





kmMat3* kmMat3RotationZ(kmMat3* pOut, const float radians)
{






 pOut->mat[0] = cosf(radians);
 pOut->mat[1] =-sinf(radians);
 pOut->mat[2] = 0.0f;

 pOut->mat[3] = sinf(radians);
 pOut->mat[4] = cosf(radians);
 pOut->mat[5] = 0.0f;

 pOut->mat[6] = 0.0f;
 pOut->mat[7] = 0.0f;
 pOut->mat[8] = 1.0f;

 return pOut;
}

kmVec3* kmMat3GetUpVec3(kmVec3* pOut, const kmMat3* pIn) {
 pOut->x = pIn->mat[3];
 pOut->y = pIn->mat[4];
 pOut->z = pIn->mat[5];

 kmVec3Normalize(pOut, pOut);

 return pOut;
}

kmVec3* kmMat3GetRightVec3(kmVec3* pOut, const kmMat3* pIn) {
 pOut->x = pIn->mat[0];
 pOut->y = pIn->mat[1];
 pOut->z = pIn->mat[2];

 kmVec3Normalize(pOut, pOut);

 return pOut;
}

kmVec3* kmMat3GetForwardVec3(kmVec3* pOut, const kmMat3* pIn) {
 pOut->x = pIn->mat[6];
 pOut->y = pIn->mat[7];
 pOut->z = pIn->mat[8];

 kmVec3Normalize(pOut, pOut);

 return pOut;
}

kmMat3* kmMat3LookAt(kmMat3* pOut, const kmVec3* pEye,
                     const kmVec3* pCenter, const kmVec3* pUp)
{
    kmVec3 f, up, s, u;

    kmVec3Subtract(&f, pCenter, pEye);
    kmVec3Normalize(&f, &f);

    kmVec3Assign(&up, pUp);
    kmVec3Normalize(&up, &up);

    kmVec3Cross(&s, &f, &up);
    kmVec3Normalize(&s, &s);

    kmVec3Cross(&u, &s, &f);
    kmVec3Normalize(&s, &s);

    pOut->mat[0] = s.x;
    pOut->mat[3] = s.y;
    pOut->mat[6] = s.z;

    pOut->mat[1] = u.x;
    pOut->mat[4] = u.y;
    pOut->mat[7] = u.z;

    pOut->mat[2] = -f.x;
    pOut->mat[5] = -f.y;
    pOut->mat[8] = -f.z;

    return pOut;
}
# 0 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c"
# 26 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef unsigned chtype;
typedef chtype attr_t;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 2
# 27 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/memory.h" 1
# 28 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/assert.h" 1
# 29 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c" 2

# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/utility.h" 1
# 29 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/utility.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/math.h" 1
# 30 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/utility.h" 2
# 81 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/utility.h"
extern float kmSQR(float s);
extern float kmDegreesToRadians(float degrees);
extern float kmRadiansToDegrees(float radians);

extern float kmMin(float lhs, float rhs);
extern float kmMax(float lhs, float rhs);
extern unsigned char kmAlmostEqual(float lhs, float rhs);

extern float kmClamp(float x, float min, float max);
extern float kmLerp(float x, float y, float factor);
# 31 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/vec3.h" 1
# 29 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/vec3.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/assert.h" 1
# 30 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/vec3.h" 2


struct kmMat4;
struct kmMat3;
struct kmPlane;

typedef struct kmVec3 {
 float x;
 float y;
 float z;
} kmVec3;





kmVec3* kmVec3Fill(kmVec3* pOut, float x, float y, float z);
float kmVec3Length(const kmVec3* pIn);
float kmVec3LengthSq(const kmVec3* pIn);
kmVec3* kmVec3Lerp(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2, float t);
kmVec3* kmVec3Normalize(kmVec3* pOut, const kmVec3* pIn);
kmVec3* kmVec3Cross(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2);
float kmVec3Dot(const kmVec3* pV1, const kmVec3* pV2);
kmVec3* kmVec3Add(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2);
kmVec3* kmVec3Subtract(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2);
kmVec3* kmVec3Mul( kmVec3* pOut,const kmVec3* pV1, const kmVec3* pV2 );
kmVec3* kmVec3Div( kmVec3* pOut,const kmVec3* pV1, const kmVec3* pV2 );

kmVec3* kmVec3MultiplyMat3(kmVec3 *pOut, const kmVec3 *pV, const struct kmMat3* pM);
kmVec3* kmVec3MultiplyMat4(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);

kmVec3* kmVec3Transform(kmVec3* pOut, const kmVec3* pV1, const struct kmMat4* pM);
kmVec3* kmVec3TransformNormal(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);
kmVec3* kmVec3TransformCoord(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);

kmVec3* kmVec3Scale(kmVec3* pOut, const kmVec3* pIn, const float s);
int kmVec3AreEqual(const kmVec3* p1, const kmVec3* p2);
kmVec3* kmVec3InverseTransform(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);
kmVec3* kmVec3InverseTransformNormal(kmVec3* pOut, const kmVec3* pVect, const struct kmMat4* pM);
kmVec3* kmVec3Assign(kmVec3* pOut, const kmVec3* pIn);
kmVec3* kmVec3Zero(kmVec3* pOut);
kmVec3* kmVec3GetHorizontalAngle(kmVec3* pOut, const kmVec3 *pIn);
kmVec3* kmVec3RotationToDirection(kmVec3* pOut, const kmVec3* pIn, const kmVec3* forwards);

kmVec3* kmVec3ProjectOnToPlane(kmVec3* pOut, const kmVec3* point, const struct kmPlane* plane);

kmVec3* kmVec3Reflect(kmVec3* pOut, const kmVec3* pIn, const kmVec3* normal);

extern const kmVec3 KM_VEC3_NEG_Z;
extern const kmVec3 KM_VEC3_POS_Z;
extern const kmVec3 KM_VEC3_POS_Y;
extern const kmVec3 KM_VEC3_NEG_Y;
extern const kmVec3 KM_VEC3_NEG_X;
extern const kmVec3 KM_VEC3_POS_X;
extern const kmVec3 KM_VEC3_ZERO;
# 32 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.h" 1
# 35 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.h"
struct kmVec3;
struct kmQuaternion;
struct kmMat4;

typedef struct kmMat3{
 float mat[9];
} kmMat3;





kmMat3* kmMat3Fill(kmMat3* pOut, const float* pMat);
kmMat3* kmMat3Adjugate(kmMat3* pOut, const kmMat3* pIn);
kmMat3* kmMat3Identity(kmMat3* pOut);
kmMat3* kmMat3Inverse(kmMat3* pOut, const kmMat3* pM);
int kmMat3IsIdentity(const kmMat3* pIn);
kmMat3* kmMat3Transpose(kmMat3* pOut, const kmMat3* pIn);
float kmMat3Determinant(const kmMat3* pIn);
kmMat3* kmMat3Multiply(kmMat3* pOut, const kmMat3* pM1, const kmMat3* pM2);
kmMat3* kmMat3ScalarMultiply(kmMat3* pOut, const kmMat3* pM, const float pFactor);

kmMat3* kmMat3Assign(kmMat3* pOut, const kmMat3* pIn);
kmMat3* kmMat3AssignMat4(kmMat3* pOut, const struct kmMat4* pIn);
int kmMat3AreEqual(const kmMat3* pM1, const kmMat3* pM2);

struct kmVec3* kmMat3GetUpVec3(struct kmVec3* pOut, const kmMat3* pIn);
struct kmVec3* kmMat3GetRightVec3(struct kmVec3* pOut, const kmMat3* pIn);
struct kmVec3* kmMat3GetForwardVec3(struct kmVec3* pOut, const kmMat3* pIn);

kmMat3* kmMat3RotationX(kmMat3* pOut, const float radians);
kmMat3* kmMat3RotationY(kmMat3* pOut, const float radians);
kmMat3* kmMat3RotationZ(kmMat3* pOut, const float radians);

kmMat3* kmMat3Rotation(kmMat3* pOut, const float radians);
kmMat3* kmMat3Scaling(kmMat3* pOut, const float x, const float y);
kmMat3* kmMat3Translation(kmMat3* pOut, const float x, const float y);

kmMat3* kmMat3RotationQuaternion(kmMat3* pOut, const struct kmQuaternion* pIn);

kmMat3* kmMat3RotationAxisAngle(kmMat3* pOut, const struct kmVec3* axis, float radians);
struct kmVec3* kmMat3RotationToAxisAngle(struct kmVec3* pAxis, float* radians, const kmMat3* pIn);
kmMat3* kmMat3LookAt(kmMat3* pOut, const struct kmVec3* pEye, const struct kmVec3* pCenter, const struct kmVec3* pUp);
# 33 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat4.h" 1
# 31 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat4.h"
struct kmVec3;
struct kmMat3;
struct kmQuaternion;
struct kmPlane;
# 49 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat4.h"
typedef struct kmMat4 {
 float mat[16];
} kmMat4;

kmMat4* kmMat4Fill(kmMat4* pOut, const float* pMat);


kmMat4* kmMat4Identity(kmMat4* pOut);

kmMat4* kmMat4Inverse(kmMat4* pOut, const kmMat4* pM);


int kmMat4IsIdentity(const kmMat4* pIn);

kmMat4* kmMat4Transpose(kmMat4* pOut, const kmMat4* pIn);
kmMat4* kmMat4Multiply(kmMat4* pOut, const kmMat4* pM1, const kmMat4* pM2);

kmMat4* kmMat4Assign(kmMat4* pOut, const kmMat4* pIn);
kmMat4* kmMat4AssignMat3(kmMat4* pOut, const struct kmMat3* pIn);

int kmMat4AreEqual(const kmMat4* pM1, const kmMat4* pM2);

kmMat4* kmMat4RotationX(kmMat4* pOut, const float radians);
kmMat4* kmMat4RotationY(kmMat4* pOut, const float radians);
kmMat4* kmMat4RotationZ(kmMat4* pOut, const float radians);
kmMat4* kmMat4RotationYawPitchRoll(kmMat4* pOut, const float pitch, const float yaw, const float roll);
kmMat4* kmMat4RotationQuaternion(kmMat4* pOut, const struct kmQuaternion* pQ);
kmMat4* kmMat4RotationTranslation(kmMat4* pOut, const struct kmMat3* rotation, const struct kmVec3* translation);
kmMat4* kmMat4Scaling(kmMat4* pOut, const float x, const float y, const float z);
kmMat4* kmMat4Translation(kmMat4* pOut, const float x, const float y, const float z);

struct kmVec3* kmMat4GetUpVec3(struct kmVec3* pOut, const kmMat4* pIn);
struct kmVec3* kmMat4GetRightVec3(struct kmVec3* pOut, const kmMat4* pIn);
struct kmVec3* kmMat4GetForwardVec3RH(struct kmVec3* pOut, const kmMat4* pIn);
struct kmVec3* kmMat4GetForwardVec3LH(struct kmVec3* pOut, const kmMat4* pIn);

kmMat4* kmMat4PerspectiveProjection(kmMat4* pOut, float fovY, float aspect, float zNear, float zFar);
kmMat4* kmMat4OrthographicProjection(kmMat4* pOut, float left, float right, float bottom, float top, float nearVal, float farVal);
kmMat4* kmMat4LookAt(kmMat4* pOut, const struct kmVec3* pEye, const struct kmVec3* pCenter, const struct kmVec3* pUp);

kmMat4* kmMat4RotationAxisAngle(kmMat4* pOut, const struct kmVec3* axis, float radians);
struct kmMat3* kmMat4ExtractRotation(struct kmMat3* pOut, const kmMat4* pIn);
struct kmPlane* kmMat4ExtractPlane(struct kmPlane* pOut, const kmMat4* pIn, const unsigned int plane);
struct kmVec3* kmMat4RotationToAxisAngle(struct kmVec3* pAxis, float* radians, const kmMat4* pIn);
# 34 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/quaternion.h" 1
# 35 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/quaternion.h"
struct kmMat4;
struct kmMat3;
struct kmVec3;

typedef struct kmQuaternion {
 float x;
 float y;
 float z;
 float w;
} kmQuaternion;

int kmQuaternionAreEqual(const kmQuaternion* p1, const kmQuaternion* p2);
kmQuaternion* kmQuaternionFill(kmQuaternion* pOut, float x, float y, float z, float w);
float kmQuaternionDot(const kmQuaternion* q1, const kmQuaternion* q2);

kmQuaternion* kmQuaternionExp(kmQuaternion* pOut, const kmQuaternion* pIn);



kmQuaternion* kmQuaternionIdentity(kmQuaternion* pOut);



kmQuaternion* kmQuaternionInverse(kmQuaternion* pOut, const kmQuaternion* pIn);



int kmQuaternionIsIdentity(const kmQuaternion* pIn);



float kmQuaternionLength(const kmQuaternion* pIn);



float kmQuaternionLengthSq(const kmQuaternion* pIn);



kmQuaternion* kmQuaternionLn(kmQuaternion* pOut, const kmQuaternion* pIn);



kmQuaternion* kmQuaternionMultiply(kmQuaternion* pOut, const kmQuaternion* q1, const kmQuaternion* q2);



kmQuaternion* kmQuaternionNormalize(kmQuaternion* pOut, const kmQuaternion* pIn);



kmQuaternion* kmQuaternionRotationAxisAngle(kmQuaternion* pOut, const struct kmVec3* pV, float angle);



kmQuaternion* kmQuaternionRotationMatrix(kmQuaternion* pOut, const struct kmMat3* pIn);



kmQuaternion* kmQuaternionRotationPitchYawRoll(kmQuaternion* pOut, float pitch, float yaw, float roll);

kmQuaternion* kmQuaternionSlerp(kmQuaternion* pOut, const kmQuaternion* q1, const kmQuaternion* q2, float t);


void kmQuaternionToAxisAngle(const kmQuaternion* pIn, struct kmVec3* pVector, float* pAngle);


kmQuaternion* kmQuaternionScale(kmQuaternion* pOut, const kmQuaternion* pIn, float s);
kmQuaternion* kmQuaternionAssign(kmQuaternion* pOut, const kmQuaternion* pIn);
kmQuaternion* kmQuaternionAdd(kmQuaternion* pOut, const kmQuaternion* pQ1, const kmQuaternion* pQ2);
kmQuaternion* kmQuaternionSubtract(kmQuaternion* pOut, const kmQuaternion* pQ1, const kmQuaternion* pQ2);

kmQuaternion* kmQuaternionRotationBetweenVec3(kmQuaternion* pOut, const struct kmVec3* vec1, const struct kmVec3* vec2, const struct kmVec3* fallback);
struct kmVec3* kmQuaternionMultiplyVec3(struct kmVec3* pOut, const kmQuaternion* q, const struct kmVec3* v);

kmVec3* kmQuaternionGetUpVec3(kmVec3* pOut, const kmQuaternion* pIn);
kmVec3* kmQuaternionGetRightVec3(kmVec3* pOut, const kmQuaternion* pIn);
kmVec3* kmQuaternionGetForwardVec3RH(kmVec3* pOut, const kmQuaternion* pIn);
kmVec3* kmQuaternionGetForwardVec3LH(kmVec3* pOut, const kmQuaternion* pIn);

float kmQuaternionGetPitch(const kmQuaternion* q);
float kmQuaternionGetYaw(const kmQuaternion* q);
float kmQuaternionGetRoll(const kmQuaternion* q);

kmQuaternion* kmQuaternionLookRotation(kmQuaternion* pOut, const kmVec3* direction, const kmVec3* up);
# 35 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c" 2

kmMat3* kmMat3Fill(kmMat3* pOut, const float* pMat)
{
    memcpy(pOut->mat, pMat, sizeof(float) * 9);
    return pOut;
}


kmMat3* kmMat3Identity(kmMat3* pOut)
{
 memset(pOut->mat, 0, sizeof(float) * 9);
 pOut->mat[0] = pOut->mat[4] = pOut->mat[8] = 1.0f;
 return pOut;
}

float kmMat3Determinant(const kmMat3* pIn)
{
    float output;
# 62 "/home/enumclass/Documents/C2RustTranslation/bkp/heman/kazmath/mat3.c"
    output = pIn->mat[0] * pIn->mat[4] * pIn->mat[8] + pIn->mat[1] * pIn->mat[5] * pIn->mat[6] + pIn->mat[2] * pIn->mat[3] * pIn->mat[7];
    output -= pIn->mat[2] * pIn->mat[4] * pIn->mat[6] + pIn->mat[0] * pIn->mat[5] * pIn->mat[7] + pIn->mat[1] * pIn->mat[3] * pIn->mat[8];

    return output;
}


kmMat3* kmMat3Adjugate(kmMat3* pOut, const kmMat3* pIn)
{
    pOut->mat[0] = pIn->mat[4] * pIn->mat[8] - pIn->mat[5] * pIn->mat[7];
    pOut->mat[1] = pIn->mat[2] * pIn->mat[7] - pIn->mat[1] * pIn->mat[8];
    pOut->mat[2] = pIn->mat[1] * pIn->mat[5] - pIn->mat[2] * pIn->mat[4];
    pOut->mat[3] = pIn->mat[5] * pIn->mat[6] - pIn->mat[3] * pIn->mat[8];
    pOut->mat[4] = pIn->mat[0] * pIn->mat[8] - pIn->mat[2] * pIn->mat[6];
    pOut->mat[5] = pIn->mat[2] * pIn->mat[3] - pIn->mat[0] * pIn->mat[5];
    pOut->mat[6] = pIn->mat[3] * pIn->mat[7] - pIn->mat[4] * pIn->mat[6];
    pOut->mat[7] = pIn->mat[1] * pIn->mat[6] - pIn->mat[0] * pIn->mat[7];
    pOut->mat[8] = pIn->mat[0] * pIn->mat[4] - pIn->mat[1] * pIn->mat[3];

    return pOut;
}

kmMat3* kmMat3Inverse(kmMat3* pOut, const kmMat3* pM)
{
    float determinate = kmMat3Determinant(pM);
    float detInv;
    kmMat3 adjugate;

    if(determinate == 0.0)
    {
        return 0;
    }

    detInv = 1.0 / determinate;

 kmMat3Adjugate(&adjugate, pM);
 kmMat3ScalarMultiply(pOut, &adjugate, detInv);

 return pOut;
}


int kmMat3IsIdentity(const kmMat3* pIn)
{
 static float identity [] = { 1.0f, 0.0f, 0.0f,
          0.0f, 1.0f, 0.0f,
          0.0f, 0.0f, 1.0f};

 return (memcmp(identity, pIn->mat, sizeof(float) * 9) == 0);
}


kmMat3* kmMat3Transpose(kmMat3* pOut, const kmMat3* pIn)
{
    float temp[9];

    temp[0] = pIn->mat[0];
    temp[1] = pIn->mat[3];
    temp[2] = pIn->mat[6];

    temp[3] = pIn->mat[1];
    temp[4] = pIn->mat[4];
    temp[5] = pIn->mat[7];

    temp[6] = pIn->mat[2];
    temp[7] = pIn->mat[5];
    temp[8] = pIn->mat[8];

    memcpy(&pOut->mat, temp, sizeof(float)*9);

 return pOut;
}


kmMat3* kmMat3Multiply(kmMat3* pOut, const kmMat3* pM1, const kmMat3* pM2)
{
 float mat[9];

 const float *m1 = pM1->mat, *m2 = pM2->mat;

 mat[0] = m1[0] * m2[0] + m1[3] * m2[1] + m1[6] * m2[2];
 mat[1] = m1[1] * m2[0] + m1[4] * m2[1] + m1[7] * m2[2];
 mat[2] = m1[2] * m2[0] + m1[5] * m2[1] + m1[8] * m2[2];

 mat[3] = m1[0] * m2[3] + m1[3] * m2[4] + m1[6] * m2[5];
 mat[4] = m1[1] * m2[3] + m1[4] * m2[4] + m1[7] * m2[5];
 mat[5] = m1[2] * m2[3] + m1[5] * m2[4] + m1[8] * m2[5];

 mat[6] = m1[0] * m2[6] + m1[3] * m2[7] + m1[6] * m2[8];
 mat[7] = m1[1] * m2[6] + m1[4] * m2[7] + m1[7] * m2[8];
 mat[8] = m1[2] * m2[6] + m1[5] * m2[7] + m1[8] * m2[8];

 memcpy(pOut->mat, mat, sizeof(float)*9);

 return pOut;
}

kmMat3* kmMat3ScalarMultiply(kmMat3* pOut, const kmMat3* pM, const float pFactor)
{
    float mat[9];
    int i;

    for(i = 0; i < 9; i++)
    {
        mat[i] = pM->mat[i] * pFactor;
    }

    memcpy(pOut->mat, mat, sizeof(float)*9);

 return pOut;
}


kmMat3* kmMat3Assign(kmMat3* pOut, const kmMat3* pIn)
{
 assert(pOut != pIn);

 memcpy(pOut->mat, pIn->mat, sizeof(float)*9);

 return pOut;
}

kmMat3* kmMat3AssignMat4(kmMat3* pOut, const kmMat4* pIn) {
    pOut->mat[0] = pIn->mat[0];
    pOut->mat[1] = pIn->mat[1];
    pOut->mat[2] = pIn->mat[2];

    pOut->mat[3] = pIn->mat[4];
    pOut->mat[4] = pIn->mat[5];
    pOut->mat[5] = pIn->mat[6];

    pOut->mat[6] = pIn->mat[8];
    pOut->mat[7] = pIn->mat[9];
    pOut->mat[8] = pIn->mat[10];
    return pOut;
}


int kmMat3AreEqual(const kmMat3* pMat1, const kmMat3* pMat2)
{
 int i;
 if (pMat1 == pMat2) {
  return 1;
 }

 for (i = 0; i < 9; ++i) {
  if (!(pMat1->mat[i] + 0.0001 > pMat2->mat[i] &&
            pMat1->mat[i] - 0.0001 < pMat2->mat[i])) {
   return 0;
        }
 }

 return 1;
}


kmMat3* kmMat3Rotation(kmMat3* pOut, const float radians)
{






 pOut->mat[0] = cosf(radians);
 pOut->mat[1] = sinf(radians);
 pOut->mat[2] = 0.0f;

 pOut->mat[3] = -sinf(radians);
 pOut->mat[4] = cosf(radians);
 pOut->mat[5] = 0.0f;

 pOut->mat[6] = 0.0f;
 pOut->mat[7] = 0.0f;
 pOut->mat[8] = 1.0f;

 return pOut;
}


kmMat3* kmMat3Scaling(kmMat3* pOut, const float x, const float y)
{

 kmMat3Identity(pOut);
 pOut->mat[0] = x;
 pOut->mat[4] = y;

 return pOut;
}

kmMat3* kmMat3Translation(kmMat3* pOut, const float x, const float y)
{

 kmMat3Identity(pOut);
 pOut->mat[6] = x;
 pOut->mat[7] = y;


    return pOut;
}


kmMat3* kmMat3RotationQuaternion(kmMat3* pOut, const kmQuaternion* pIn)
{
    if (!pIn || !pOut) {
 return 0;
    }


    pOut->mat[0] = 1.0f - 2.0f * (pIn->y * pIn->y + pIn->z * pIn->z);
    pOut->mat[1] = 2.0f * (pIn->x * pIn->y - pIn->w * pIn->z);
    pOut->mat[2] = 2.0f * (pIn->x * pIn->z + pIn->w * pIn->y);


    pOut->mat[3] = 2.0f * (pIn->x * pIn->y + pIn->w * pIn->z);
    pOut->mat[4] = 1.0f - 2.0f * (pIn->x * pIn->x + pIn->z * pIn->z);
    pOut->mat[5] = 2.0f * (pIn->y * pIn->z - pIn->w * pIn->x);


    pOut->mat[6] = 2.0f * (pIn->x * pIn->z - pIn->w * pIn->y);
    pOut->mat[7] = 2.0f * (pIn->y * pIn->z + pIn->w * pIn->x);
    pOut->mat[8] = 1.0f - 2.0f * (pIn->x * pIn->x + pIn->y * pIn->y);

    return pOut;
}

kmMat3* kmMat3RotationAxisAngle(kmMat3* pOut, const struct kmVec3* axis, float radians)
{
    float rcos = cosf(radians);
    float rsin = sinf(radians);

    pOut->mat[0] = rcos + axis->x * axis->x * (1 - rcos);
    pOut->mat[1] = axis->z * rsin + axis->y * axis->x * (1 - rcos);
    pOut->mat[2] = -axis->y * rsin + axis->z * axis->x * (1 - rcos);

    pOut->mat[3] = -axis->z * rsin + axis->x * axis->y * (1 - rcos);
    pOut->mat[4] = rcos + axis->y * axis->y * (1 - rcos);
    pOut->mat[5] = axis->x * rsin + axis->z * axis->y * (1 - rcos);

    pOut->mat[6] = axis->y * rsin + axis->x * axis->z * (1 - rcos);
    pOut->mat[7] = -axis->x * rsin + axis->y * axis->z * (1 - rcos);
    pOut->mat[8] = rcos + axis->z * axis->z * (1 - rcos);

    return pOut;
}

kmVec3* kmMat3RotationToAxisAngle(kmVec3* pAxis, float* radians, const kmMat3* pIn)
{

    kmQuaternion temp;
    kmQuaternionRotationMatrix(&temp, pIn);
    kmQuaternionToAxisAngle(&temp, pAxis, radians);
    return pAxis;
}




kmMat3* kmMat3RotationX(kmMat3* pOut, const float radians)
{







 pOut->mat[0] = 1.0f;
 pOut->mat[1] = 0.0f;
 pOut->mat[2] = 0.0f;

 pOut->mat[3] = 0.0f;
 pOut->mat[4] = cosf(radians);
 pOut->mat[5] = sinf(radians);

 pOut->mat[6] = 0.0f;
 pOut->mat[7] = -sinf(radians);
 pOut->mat[8] = cosf(radians);

 return pOut;
}





kmMat3* kmMat3RotationY(kmMat3* pOut, const float radians)
{






 pOut->mat[0] = cosf(radians);
 pOut->mat[1] = 0.0f;
 pOut->mat[2] = -sinf(radians);

 pOut->mat[3] = 0.0f;
 pOut->mat[4] = 1.0f;
 pOut->mat[5] = 0.0f;

 pOut->mat[6] = sinf(radians);
 pOut->mat[7] = 0.0f;
 pOut->mat[8] = cosf(radians);

 return pOut;
}





kmMat3* kmMat3RotationZ(kmMat3* pOut, const float radians)
{






 pOut->mat[0] = cosf(radians);
 pOut->mat[1] =-sinf(radians);
 pOut->mat[2] = 0.0f;

 pOut->mat[3] = sinf(radians);
 pOut->mat[4] = cosf(radians);
 pOut->mat[5] = 0.0f;

 pOut->mat[6] = 0.0f;
 pOut->mat[7] = 0.0f;
 pOut->mat[8] = 1.0f;

 return pOut;
}

kmVec3* kmMat3GetUpVec3(kmVec3* pOut, const kmMat3* pIn) {
 pOut->x = pIn->mat[3];
 pOut->y = pIn->mat[4];
 pOut->z = pIn->mat[5];

 kmVec3Normalize(pOut, pOut);

 return pOut;
}

kmVec3* kmMat3GetRightVec3(kmVec3* pOut, const kmMat3* pIn) {
 pOut->x = pIn->mat[0];
 pOut->y = pIn->mat[1];
 pOut->z = pIn->mat[2];

 kmVec3Normalize(pOut, pOut);

 return pOut;
}

kmVec3* kmMat3GetForwardVec3(kmVec3* pOut, const kmMat3* pIn) {
 pOut->x = pIn->mat[6];
 pOut->y = pIn->mat[7];
 pOut->z = pIn->mat[8];

 kmVec3Normalize(pOut, pOut);

 return pOut;
}

kmMat3* kmMat3LookAt(kmMat3* pOut, const kmVec3* pEye,
                     const kmVec3* pCenter, const kmVec3* pUp)
{
    kmVec3 f, up, s, u;

    kmVec3Subtract(&f, pCenter, pEye);
    kmVec3Normalize(&f, &f);

    kmVec3Assign(&up, pUp);
    kmVec3Normalize(&up, &up);

    kmVec3Cross(&s, &f, &up);
    kmVec3Normalize(&s, &s);

    kmVec3Cross(&u, &s, &f);
    kmVec3Normalize(&s, &s);

    pOut->mat[0] = s.x;
    pOut->mat[3] = s.y;
    pOut->mat[6] = s.z;

    pOut->mat[1] = u.x;
    pOut->mat[4] = u.y;
    pOut->mat[7] = u.z;

    pOut->mat[2] = -f.x;
    pOut->mat[5] = -f.y;
    pOut->mat[8] = -f.z;

    return pOut;
}
