use crate::*;

pub fn kmRay2Fill(/* kmRay2 *ray, float px, float py, float vx, float vy */) {
	todo!();
}
pub fn kmLine2WithLineIntersection(/* const kmVec2 *ptA, const kmVec2 *vecA, const kmVec2 *ptB, const kmVec2 *vecB, float *outTA, float *outTB, kmVec2 *outIntersection */) {
	todo!();
}
pub fn kmRay2FillWithEndpoints(/* kmRay2 *ray, const kmVec2 *start, const kmVec2 *end */) {
	todo!();
}
pub fn kmRay2IntersectCircle(/* const kmRay2 *ray, const kmVec2 centre, const float radius, kmVec2 *intersection */) {
	todo!();
}
pub fn kmSegment2WithSegmentIntersection(/* const kmRay2 *segmentA, const kmRay2 *segmentB, kmVec2 *intersection */) {
	todo!();
}
pub fn kmRay2IntersectLineSegment(/* const kmRay2 *ray, const kmVec2 *p1, const kmVec2 *p2, kmVec2 *intersection */) {
	todo!();
}
pub fn calculate_line_normal(/* kmVec2 p1, kmVec2 p2, kmVec2 other_point, kmVec2 *normal_out */) {
	todo!();
}
pub fn helper_kmRay2IntersectBox_1(/* unsigned char * const intersected_ref, float * const distance_ref, const kmRay2 * const ray, kmVec2 intersect, kmVec2 final_intersect, kmVec2 normal, const kmVec2 *points[4], unsigned int i */) {
	todo!();
}
pub fn kmRay2IntersectBox(/* const kmRay2 *ray, const kmVec2 *p1, const kmVec2 *p2, const kmVec2 *p3, const kmVec2 *p4, kmVec2 *intersection, kmVec2 *normal_out */) {
	todo!();
}
pub fn kmRay2IntersectTriangle(/* const kmRay2 *ray, const kmVec2 *p1, const kmVec2 *p2, const kmVec2 *p3, kmVec2 *intersection, kmVec2 *normal_out, float *distance_out */) {
	todo!();
}
