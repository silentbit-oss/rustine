# 0 "/app/subjects/json-c/json_object.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/app/subjects/json-c/json_object.c"
# 11 "/app/subjects/json-c/json_object.c"
# 1 "/app/subjects/json-c/build/config.h" 1
# 12 "/app/subjects/json-c/json_object.c" 2

# 1 "/app/subjects/json-c/strerror_override.h" 1
# 9 "/app/subjects/json-c/strerror_override.h"
# 1 "/app/subjects/json-c/build/config.h" 1
# 10 "/app/subjects/json-c/strerror_override.h" 2
# 1 "/app/pipeline/preprocess/fake_libc_include/errno.h" 1
# 1 "/app/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/app/pipeline/preprocess/fake_libc_include/errno.h" 2
# 1 "/app/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/app/pipeline/preprocess/fake_libc_include/errno.h" 2
# 11 "/app/subjects/json-c/strerror_override.h" 2

# 1 "/app/subjects/json-c/json_object.h" 1
# 26 "/app/subjects/json-c/json_object.h"
# 1 "/app/subjects/json-c/json_inttypes.h" 1
# 9 "/app/subjects/json-c/json_inttypes.h"
# 1 "/app/subjects/json-c/build/json_config.h" 1
# 10 "/app/subjects/json-c/json_inttypes.h" 2



# 1 "/app/pipeline/preprocess/fake_libc_include/inttypes.h" 1
# 14 "/app/subjects/json-c/json_inttypes.h" 2
# 27 "/app/subjects/json-c/json_object.h" 2
# 1 "/app/subjects/json-c/json_types.h" 1
# 28 "/app/subjects/json-c/json_types.h"
struct printbuf;





struct json_object_iter
{
 char *key;
 struct json_object *val;
 struct lh_entry *entry;
};
typedef struct json_object_iter json_object_iter;

typedef int json_bool;




typedef struct json_object json_object;




typedef void(json_object_delete_fn)(struct json_object *jso, void *userdata);




typedef int(json_object_to_json_string_fn)(struct json_object *jso, struct printbuf *pb, int level,
                                           int flags);



typedef enum json_type
{

 json_type_null,
 json_type_boolean,
 json_type_double,
 json_type_int,
 json_type_object,
 json_type_array,
 json_type_string
} json_type;
# 28 "/app/subjects/json-c/json_object.h" 2
# 1 "/app/subjects/json-c/printbuf.h" 1
# 38 "/app/subjects/json-c/printbuf.h"
struct printbuf
{
 char *buf;
 int bpos;
 int size;
};
typedef struct printbuf printbuf;

extern struct printbuf *printbuf_new(void);
# 56 "/app/subjects/json-c/printbuf.h"
extern int printbuf_memappend(struct printbuf *p, const char *buf, int size);
# 105 "/app/subjects/json-c/printbuf.h"
extern int printbuf_memset(struct printbuf *pb, int offset, int charvalue, int len);
# 121 "/app/subjects/json-c/printbuf.h"
extern int sprintbuf(struct printbuf *p, const char *msg, ...);

extern void printbuf_reset(struct printbuf *p);

extern void printbuf_free(struct printbuf *p);
# 29 "/app/subjects/json-c/json_object.h" 2

# 1 "/app/pipeline/preprocess/fake_libc_include/stddef.h" 1
# 31 "/app/subjects/json-c/json_object.h" 2
# 160 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_get(struct json_object *obj);
# 181 "/app/subjects/json-c/json_object.h"
extern int json_object_put(struct json_object *obj);
# 196 "/app/subjects/json-c/json_object.h"
extern int json_object_is_type(const struct json_object *obj, enum json_type type);
# 212 "/app/subjects/json-c/json_object.h"
extern enum json_type json_object_get_type(const struct json_object *obj);
# 223 "/app/subjects/json-c/json_object.h"
extern const char *json_object_to_json_string(struct json_object *obj);







extern const char *json_object_to_json_string_ext(struct json_object *obj, int flags);
# 240 "/app/subjects/json-c/json_object.h"
extern const char *json_object_to_json_string_length(struct json_object *obj, int flags,
                                                          size_t *length);







extern void *json_object_get_userdata(json_object *jso);
# 276 "/app/subjects/json-c/json_object.h"
extern void json_object_set_userdata(json_object *jso, void *userdata,
                                          json_object_delete_fn *user_delete);
# 309 "/app/subjects/json-c/json_object.h"
extern void json_object_set_serializer(json_object *jso,
                                            json_object_to_json_string_fn *to_string_func,
                                            void *userdata, json_object_delete_fn *user_delete);
# 330 "/app/subjects/json-c/json_object.h"
extern json_object_delete_fn json_object_free_userdata;
# 341 "/app/subjects/json-c/json_object.h"
extern json_object_to_json_string_fn json_object_userdata_to_json_string;
# 360 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_new_object(void);





extern struct lh_table *json_object_get_object(const struct json_object *obj);




extern int json_object_object_length(const struct json_object *obj);




extern size_t json_c_object_sizeof(void) ;
# 403 "/app/subjects/json-c/json_object.h"
extern int json_object_object_add(struct json_object *obj, const char *key,
                                       struct json_object *val);
# 419 "/app/subjects/json-c/json_object.h"
extern int json_object_object_add_ex(struct json_object *obj, const char *const key,
                                          struct json_object *const val, const unsigned opts);
# 443 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_object_get(const struct json_object *obj,
                                                       const char *key);
# 464 "/app/subjects/json-c/json_object.h"
extern int json_object_object_get_ex(const struct json_object *obj, const char *key,
                                                struct json_object **value);
# 476 "/app/subjects/json-c/json_object.h"
extern void json_object_object_del(struct json_object *obj, const char *key);
# 546 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_new_array(void);







extern struct json_object *json_object_new_array_ext(int initial_size);





extern struct array_list *json_object_get_array(const struct json_object *obj);





extern size_t json_object_array_length(const struct json_object *obj);
# 576 "/app/subjects/json-c/json_object.h"
extern void json_object_array_sort(struct json_object *jso,
                                        int (*sort_fn)(const void *, const void *));
# 593 "/app/subjects/json-c/json_object.h"
extern struct json_object *
json_object_array_bsearch(const struct json_object *key, const struct json_object *jso,
                          int (*sort_fn)(const void *, const void *));
# 606 "/app/subjects/json-c/json_object.h"
extern int json_object_array_add(struct json_object *obj, struct json_object *val);
# 623 "/app/subjects/json-c/json_object.h"
extern int json_object_array_put_idx(struct json_object *obj, size_t idx,
                                          struct json_object *val);
# 642 "/app/subjects/json-c/json_object.h"
extern int json_object_array_insert_idx(struct json_object *obj, size_t idx,
                                             struct json_object *val);
# 658 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_array_get_idx(const struct json_object *obj,
                                                          size_t idx);
# 672 "/app/subjects/json-c/json_object.h"
extern int json_object_array_del_idx(struct json_object *obj, size_t idx, size_t count);
# 681 "/app/subjects/json-c/json_object.h"
extern int json_object_array_shrink(struct json_object *jso, int empty_slots);







extern struct json_object *json_object_new_boolean(json_bool b);
# 703 "/app/subjects/json-c/json_object.h"
extern json_bool json_object_get_boolean(const struct json_object *obj);
# 715 "/app/subjects/json-c/json_object.h"
extern int json_object_set_boolean(struct json_object *obj, json_bool new_value);
# 725 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_new_int(int32_t i);





extern struct json_object *json_object_new_int64(int64_t i);





extern struct json_object *json_object_new_uint64(uint64_t i);
# 756 "/app/subjects/json-c/json_object.h"
extern int32_t json_object_get_int(const struct json_object *obj);
# 768 "/app/subjects/json-c/json_object.h"
extern int json_object_set_int(struct json_object *obj, int new_value);
# 784 "/app/subjects/json-c/json_object.h"
extern int json_object_int_inc(struct json_object *obj, int64_t val);
# 803 "/app/subjects/json-c/json_object.h"
extern int64_t json_object_get_int64(const struct json_object *obj);
# 822 "/app/subjects/json-c/json_object.h"
extern uint64_t json_object_get_uint64(const struct json_object *obj);
# 834 "/app/subjects/json-c/json_object.h"
extern int json_object_set_int64(struct json_object *obj, int64_t new_value);
# 846 "/app/subjects/json-c/json_object.h"
extern int json_object_set_uint64(struct json_object *obj, uint64_t new_value);
# 857 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_new_double(double d);
# 886 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_new_double_s(double d, const char *ds);
# 900 "/app/subjects/json-c/json_object.h"
extern int json_c_set_serialization_double_format(const char *double_format,
                                                       int global_or_thread);
# 922 "/app/subjects/json-c/json_object.h"
extern int json_object_double_to_json_string(struct json_object *jso, struct printbuf *pb,
                                                  int level, int flags);
# 948 "/app/subjects/json-c/json_object.h"
extern double json_object_get_double(const struct json_object *obj);
# 963 "/app/subjects/json-c/json_object.h"
extern int json_object_set_double(struct json_object *obj, double new_value);
# 975 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_new_string(const char *s);
# 987 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_new_string_len(const char *s, const int len);
# 1005 "/app/subjects/json-c/json_object.h"
extern const char *json_object_get_string(struct json_object *obj);
# 1015 "/app/subjects/json-c/json_object.h"
extern int json_object_get_string_len(const struct json_object *obj);





extern int json_object_set_string(json_object *obj, const char *new_value);
# 1034 "/app/subjects/json-c/json_object.h"
extern int json_object_set_string_len(json_object *obj, const char *new_value, int len);





extern struct json_object *json_object_new_null(void);
# 1059 "/app/subjects/json-c/json_object.h"
extern int json_object_equal(struct json_object *obj1, struct json_object *obj2);
# 1075 "/app/subjects/json-c/json_object.h"
typedef int(json_c_shallow_copy_fn)(json_object *src, json_object *parent, const char *key,
                                    size_t index, json_object **dst);
# 1090 "/app/subjects/json-c/json_object.h"
extern json_c_shallow_copy_fn json_c_shallow_copy_default;
# 1111 "/app/subjects/json-c/json_object.h"
extern int json_object_deep_copy(struct json_object *src, struct json_object **dst,
                                      json_c_shallow_copy_fn *shallow_copy);
# 13 "/app/subjects/json-c/strerror_override.h" 2





# 1 "/app/pipeline/preprocess/fake_libc_include/string.h" 1
# 19 "/app/subjects/json-c/strerror_override.h" 2

extern char *_json_c_strerror(int errno_in);
# 14 "/app/subjects/json-c/json_object.c" 2

# 1 "/app/pipeline/preprocess/fake_libc_include/assert.h" 1
# 16 "/app/subjects/json-c/json_object.c" 2

# 1 "/app/pipeline/preprocess/fake_libc_include/limits.h" 1
# 18 "/app/subjects/json-c/json_object.c" 2

# 1 "/app/pipeline/preprocess/fake_libc_include/math.h" 1
# 20 "/app/subjects/json-c/json_object.c" 2
# 1 "/app/pipeline/preprocess/fake_libc_include/stddef.h" 1
# 21 "/app/subjects/json-c/json_object.c" 2
# 1 "/app/pipeline/preprocess/fake_libc_include/stdio.h" 1
# 22 "/app/subjects/json-c/json_object.c" 2
# 1 "/app/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 23 "/app/subjects/json-c/json_object.c" 2
# 1 "/app/pipeline/preprocess/fake_libc_include/string.h" 1
# 24 "/app/subjects/json-c/json_object.c" 2

# 1 "/app/subjects/json-c/arraylist.h" 1
# 25 "/app/subjects/json-c/arraylist.h"
# 1 "/app/pipeline/preprocess/fake_libc_include/stddef.h" 1
# 26 "/app/subjects/json-c/arraylist.h" 2



typedef void(array_list_free_fn)(void *data);

struct array_list
{
 void **array;
 size_t length;
 size_t size;
 array_list_free_fn *free_fn;
};
typedef struct array_list array_list;





extern struct array_list *array_list_new(array_list_free_fn *free_fn);
# 59 "/app/subjects/json-c/arraylist.h"
extern struct array_list *array_list_new2(array_list_free_fn *free_fn, int initial_size);

extern void array_list_free(struct array_list *al);

extern void *array_list_get_idx(struct array_list *al, size_t i);

extern int array_list_insert_idx(struct array_list *al, size_t i, void *data);

extern int array_list_put_idx(struct array_list *al, size_t i, void *data);

extern int array_list_add(struct array_list *al, void *data);

extern size_t array_list_length(struct array_list *al);

extern void array_list_sort(struct array_list *arr, int (*compar)(const void *, const void *));

extern void *array_list_bsearch(const void **key, struct array_list *arr,
                                int (*compar)(const void *, const void *));

extern int array_list_del_idx(struct array_list *arr, size_t idx, size_t count);





extern int array_list_shrink(struct array_list *arr, size_t empty_slots);
# 26 "/app/subjects/json-c/json_object.c" 2
# 1 "/app/subjects/json-c/debug.h" 1
# 20 "/app/subjects/json-c/debug.h"
# 1 "/app/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 21 "/app/subjects/json-c/debug.h" 2
# 34 "/app/subjects/json-c/debug.h"
extern void mc_set_debug(int debug);
extern int mc_get_debug(void);

extern void mc_set_syslog(int syslog);

extern void mc_debug(const char *msg, ...);
extern void mc_error(const char *msg, ...);
extern void mc_info(const char *msg, ...);
# 27 "/app/subjects/json-c/json_object.c" 2


# 1 "/app/subjects/json-c/json_object_private.h" 1
# 23 "/app/subjects/json-c/json_object_private.h"
struct json_object;




# 1 "/app/pipeline/preprocess/fake_libc_include/unistd.h" 1
# 29 "/app/subjects/json-c/json_object_private.h" 2
# 37 "/app/subjects/json-c/json_object_private.h"
typedef enum json_object_int_type
{
 json_object_int_type_int64,
 json_object_int_type_uint64
} json_object_int_type;

struct json_object
{
 enum json_type o_type;
 uint32_t _ref_count;
 json_object_to_json_string_fn *_to_json_string;
 struct printbuf *_pb;
 json_object_delete_fn *_user_delete;
 void *_userdata;


};

struct json_object_object
{
 struct json_object base;
 struct lh_table *c_object;
};
struct json_object_array
{
 struct json_object base;
 struct array_list *c_array;
};

struct json_object_boolean
{
 struct json_object base;
 json_bool c_boolean;
};
struct json_object_double
{
 struct json_object base;
 double c_double;
};
struct json_object_int
{
 struct json_object base;
 enum json_object_int_type cint_type;
 union
 {
  int64_t c_int64;
  uint64_t c_uint64;
 } cint;
};
struct json_object_string
{
 struct json_object base;
 ssize_t len;


 union
 {
  char idata[1];
  char *pdata;
 } c_string;
};

void _json_c_set_last_err(const char *err_fmt, ...);

extern const char *json_hex_chars;
# 30 "/app/subjects/json-c/json_object.c" 2
# 1 "/app/subjects/json-c/json_util.h" 1
# 42 "/app/subjects/json-c/json_util.h"
extern struct json_object *json_object_from_file(const char *filename);
# 58 "/app/subjects/json-c/json_util.h"
extern struct json_object *json_object_from_fd_ex(int fd, int depth);







extern struct json_object *json_object_from_fd(int fd);







extern int json_object_to_file(const char *filename, struct json_object *obj);







extern int json_object_to_file_ext(const char *filename, struct json_object *obj, int flags);
# 94 "/app/subjects/json-c/json_util.h"
extern int json_object_to_fd(int fd, struct json_object *obj, int flags);






extern const char *json_util_get_last_err(void);







extern int json_parse_int64(const char *buf, int64_t *retval);




extern int json_parse_uint64(const char *buf, uint64_t *retval);



extern int json_parse_double(const char *buf, double *retval);





extern const char *json_type_to_name(enum json_type o_type);
# 31 "/app/subjects/json-c/json_object.c" 2
# 1 "/app/subjects/json-c/linkhash.h" 1
# 65 "/app/subjects/json-c/linkhash.h"
int json_global_set_string_hash(const int h);

struct lh_entry;




typedef void(lh_entry_free_fn)(struct lh_entry *e);



typedef unsigned long(lh_hash_fn)(const void *k);



typedef int(lh_equal_fn)(const void *k1, const void *k2);




struct lh_entry
{




 const void *k;





 int k_is_constant;




 const void *v;




 struct lh_entry *next;




 struct lh_entry *prev;
};




struct lh_table
{




 int size;




 int count;





 struct lh_entry *head;





 struct lh_entry *tail;





 struct lh_entry *table;





 lh_entry_free_fn *free_fn;



 lh_hash_fn *hash_fn;



 lh_equal_fn *equal_fn;
};
typedef struct lh_table lh_table;
# 198 "/app/subjects/json-c/linkhash.h"
extern struct lh_table *lh_table_new(int size, lh_entry_free_fn *free_fn, lh_hash_fn *hash_fn,
                                     lh_equal_fn *equal_fn);
# 209 "/app/subjects/json-c/linkhash.h"
extern struct lh_table *lh_kchar_table_new(int size, lh_entry_free_fn *free_fn);
# 219 "/app/subjects/json-c/linkhash.h"
extern struct lh_table *lh_kptr_table_new(int size, lh_entry_free_fn *free_fn);
# 229 "/app/subjects/json-c/linkhash.h"
extern void lh_table_free(struct lh_table *t);
# 241 "/app/subjects/json-c/linkhash.h"
extern int lh_table_insert(struct lh_table *t, const void *k, const void *v);
# 257 "/app/subjects/json-c/linkhash.h"
extern int lh_table_insert_w_hash(struct lh_table *t, const void *k, const void *v,
                                  const unsigned long h, const unsigned opts);
# 267 "/app/subjects/json-c/linkhash.h"
extern struct lh_entry *lh_table_lookup_entry(struct lh_table *t, const void *k);
# 281 "/app/subjects/json-c/linkhash.h"
extern struct lh_entry *lh_table_lookup_entry_w_hash(struct lh_table *t, const void *k,
                                                     const unsigned long h);
# 292 "/app/subjects/json-c/linkhash.h"
extern json_bool lh_table_lookup_ex(struct lh_table *t, const void *k, void **v);
# 304 "/app/subjects/json-c/linkhash.h"
extern int lh_table_delete_entry(struct lh_table *t, struct lh_entry *e);
# 316 "/app/subjects/json-c/linkhash.h"
extern int lh_table_delete(struct lh_table *t, const void *k);




extern int lh_table_length(struct lh_table *t);
# 332 "/app/subjects/json-c/linkhash.h"
int lh_table_resize(struct lh_table *t, int new_size);
# 349 "/app/subjects/json-c/linkhash.h"
static inline struct lh_entry *lh_table_head(const lh_table *t)
{
 return t->head;
}
# 365 "/app/subjects/json-c/linkhash.h"
static inline unsigned long lh_get_hash(const struct lh_table *t, const void *k)
{
 return t->hash_fn(k);
}
# 387 "/app/subjects/json-c/linkhash.h"
static inline void *lh_entry_k(const struct lh_entry *e)
{
 return ((void *)(uintptr_t)(const void *)(e->k));
}






static inline int lh_entry_k_is_constant(const struct lh_entry *e)
{
 return e->k_is_constant;
}







static inline void *lh_entry_v(const struct lh_entry *e)
{
 return ((void *)(uintptr_t)(const void *)(e->v));
}





static inline void lh_entry_set_val(struct lh_entry *e, void *newval)
{
 e->v = newval;
}






static inline struct lh_entry *lh_entry_next(const struct lh_entry *e)
{
 return e->next;
}






static inline struct lh_entry *lh_entry_prev(const struct lh_entry *e)
{
 return e->prev;
}
# 32 "/app/subjects/json-c/json_object.c" 2
# 1 "/app/subjects/json-c/math_compat.h" 1
# 33 "/app/subjects/json-c/json_object.c" 2

# 1 "/app/subjects/json-c/snprintf_compat.h" 1
# 14 "/app/subjects/json-c/snprintf_compat.h"
# 1 "/app/pipeline/preprocess/fake_libc_include/stdarg.h" 1
# 15 "/app/subjects/json-c/snprintf_compat.h" 2
# 35 "/app/subjects/json-c/json_object.c" 2
# 1 "/app/subjects/json-c/strdup_compat.h" 1
# 36 "/app/subjects/json-c/json_object.c" 2
# 56 "/app/subjects/json-c/json_object.c"
const char *json_number_chars = "0123456789.+-eE";
const char *json_hex_chars = "0123456789abcdefABCDEF";

static void json_object_generic_delete(struct json_object *jso);
# 77 "/app/subjects/json-c/json_object.c"
static inline struct json_object_object *JC_OBJECT(struct json_object *jso)
{
 return (void *)jso;
}
static inline const struct json_object_object *JC_OBJECT_C(const struct json_object *jso)
{
 return (const void *)jso;
}
static inline struct json_object_array *JC_ARRAY(struct json_object *jso)
{
 return (void *)jso;
}
static inline const struct json_object_array *JC_ARRAY_C(const struct json_object *jso)
{
 return (const void *)jso;
}
static inline struct json_object_boolean *JC_BOOL(struct json_object *jso)
{
 return (void *)jso;
}
static inline const struct json_object_boolean *JC_BOOL_C(const struct json_object *jso)
{
 return (const void *)jso;
}
static inline struct json_object_double *JC_DOUBLE(struct json_object *jso)
{
 return (void *)jso;
}
static inline const struct json_object_double *JC_DOUBLE_C(const struct json_object *jso)
{
 return (const void *)jso;
}
static inline struct json_object_int *JC_INT(struct json_object *jso)
{
 return (void *)jso;
}
static inline const struct json_object_int *JC_INT_C(const struct json_object *jso)
{
 return (const void *)jso;
}
static inline struct json_object_string *JC_STRING(struct json_object *jso)
{
 return (void *)jso;
}
static inline const struct json_object_string *JC_STRING_C(const struct json_object *jso)
{
 return (const void *)jso;
}
# 134 "/app/subjects/json-c/json_object.c"
static inline struct json_object *json_object_new(enum json_type o_type, size_t alloc_size,
                                                  json_object_to_json_string_fn *to_json_string);

static void json_object_object_delete(struct json_object *jso_base);
static void json_object_string_delete(struct json_object *jso);
static void json_object_array_delete(struct json_object *jso);

static json_object_to_json_string_fn json_object_object_to_json_string;
static json_object_to_json_string_fn json_object_boolean_to_json_string;
static json_object_to_json_string_fn json_object_double_to_json_string_default;
static json_object_to_json_string_fn json_object_int_to_json_string;
static json_object_to_json_string_fn json_object_string_to_json_string;
static json_object_to_json_string_fn json_object_array_to_json_string;
static json_object_to_json_string_fn _json_object_userdata_to_json_string;
# 166 "/app/subjects/json-c/json_object.c"
 static void json_abort(const char *message);



static inline char *get_string_component_mutable(struct json_object *jso)
{
 if (JC_STRING_C(jso)->len < 0)
 {

  return JC_STRING(jso)->c_string.pdata;
 }
 return JC_STRING(jso)->c_string.idata;
}
static inline const char *get_string_component(const struct json_object *jso)
{
 return get_string_component_mutable((void *)(uintptr_t)(const void *)jso);
}



static int json_escape_str(struct printbuf *pb, const char *str, size_t len, int flags)
{
 size_t pos = 0, start_offset = 0;
 unsigned char c;
 while (len)
 {
  --len;
  c = str[pos];
  switch (c)
  {
  case '\b':
  case '\n':
  case '\r':
  case '\t':
  case '\f':
  case '"':
  case '\\':
  case '/':
   if ((flags & (1 << 4)) && c == '/')
   {
    pos++;
    break;
   }

   if (pos > start_offset)
    printbuf_memappend(pb, str + start_offset, pos - start_offset);

   if (c == '\b')
    printbuf_memappend(pb, "\\b", 2);
   else if (c == '\n')
    printbuf_memappend(pb, "\\n", 2);
   else if (c == '\r')
    printbuf_memappend(pb, "\\r", 2);
   else if (c == '\t')
    printbuf_memappend(pb, "\\t", 2);
   else if (c == '\f')
    printbuf_memappend(pb, "\\f", 2);
   else if (c == '"')
    printbuf_memappend(pb, "\\\"", 2);
   else if (c == '\\')
    printbuf_memappend(pb, "\\\\", 2);
   else if (c == '/')
    printbuf_memappend(pb, "\\/", 2);

   start_offset = ++pos;
   break;
  default:
   if (c < ' ')
   {
    char sbuf[7];
    if (pos > start_offset)
     printbuf_memappend(pb, str + start_offset,
                        pos - start_offset);
    snprintf(sbuf, sizeof(sbuf), "\\u00%c%c", json_hex_chars[c >> 4],
             json_hex_chars[c & 0xf]);
    do { if ((pb->size - pb->bpos) > (int)sizeof(sbuf) - 1) { memcpy(pb->buf + pb->bpos, (sbuf), (int)sizeof(sbuf) - 1); pb->bpos += (int)sizeof(sbuf) - 1; pb->buf[pb->bpos] = '\0'; } else { printbuf_memappend(pb, (sbuf), (int)sizeof(sbuf) - 1); } } while (0);
    start_offset = ++pos;
   }
   else
    pos++;
  }
 }
 if (pos > start_offset)
  printbuf_memappend(pb, str + start_offset, pos - start_offset);
 return 0;
}



struct json_object *json_object_get(struct json_object *jso)
{
 if (!jso)
  return jso;


 assert(jso->_ref_count < UINT32_MAX);




 ++jso->_ref_count;


 return jso;
}

int json_object_put(struct json_object *jso)
{
 if (!jso)
  return 0;




 assert(jso->_ref_count > 0);
# 292 "/app/subjects/json-c/json_object.c"
 if (--jso->_ref_count > 0)
  return 0;


 if (jso->_user_delete)
  jso->_user_delete(jso, jso->_userdata);
 switch (jso->o_type)
 {
 case json_type_object: json_object_object_delete(jso); break;
 case json_type_array: json_object_array_delete(jso); break;
 case json_type_string: json_object_string_delete(jso); break;
 default: json_object_generic_delete(jso); break;
 }
 return 1;
}



static void json_object_generic_delete(struct json_object *jso)
{
 printbuf_free(jso->_pb);
 free(jso);
}

static inline struct json_object *json_object_new(enum json_type o_type, size_t alloc_size,
                                                  json_object_to_json_string_fn *to_json_string)
{
 struct json_object *jso;

 jso = (struct json_object *)malloc(alloc_size);
 if (!jso)
  return 0;

 jso->o_type = o_type;
 jso->_ref_count = 1;
 jso->_to_json_string = to_json_string;
 jso->_pb = 0;
 jso->_user_delete = 0;
 jso->_userdata = 0;


 return jso;
}



int json_object_is_type(const struct json_object *jso, enum json_type type)
{
 if (!jso)
  return (type == json_type_null);
 return (jso->o_type == type);
}

enum json_type json_object_get_type(const struct json_object *jso)
{
 if (!jso)
  return json_type_null;
 return jso->o_type;
}

void *json_object_get_userdata(json_object *jso)
{
 return jso ? jso->_userdata : 0;
}

void json_object_set_userdata(json_object *jso, void *userdata, json_object_delete_fn *user_delete)
{

 assert(jso != 0);


 if (jso->_user_delete)
  jso->_user_delete(jso, jso->_userdata);

 jso->_userdata = userdata;
 jso->_user_delete = user_delete;
}



void json_object_set_serializer(json_object *jso, json_object_to_json_string_fn *to_string_func,
                                void *userdata, json_object_delete_fn *user_delete)
{
 json_object_set_userdata(jso, userdata, user_delete);

 if (to_string_func == 0)
 {

  switch (jso->o_type)
  {
  case json_type_null: jso->_to_json_string = 0; break;
  case json_type_boolean:
   jso->_to_json_string = &json_object_boolean_to_json_string;
   break;
  case json_type_double:
   jso->_to_json_string = &json_object_double_to_json_string_default;
   break;
  case json_type_int: jso->_to_json_string = &json_object_int_to_json_string; break;
  case json_type_object:
   jso->_to_json_string = &json_object_object_to_json_string;
   break;
  case json_type_array:
   jso->_to_json_string = &json_object_array_to_json_string;
   break;
  case json_type_string:
   jso->_to_json_string = &json_object_string_to_json_string;
   break;
  }
  return;
 }

 jso->_to_json_string = to_string_func;
}



const char *json_object_to_json_string_length(struct json_object *jso, int flags, size_t *length)
{
 const char *r = 0;
 size_t s = 0;

 if (!jso)
 {
  s = 4;
  r = "null";
 }
 else if ((jso->_pb) || (jso->_pb = printbuf_new()))
 {
  printbuf_reset(jso->_pb);

  if (jso->_to_json_string(jso, jso->_pb, 0, flags) >= 0)
  {
   s = (size_t)jso->_pb->bpos;
   r = jso->_pb->buf;
  }
 }

 if (length)
  *length = s;
 return r;
}

const char *json_object_to_json_string_ext(struct json_object *jso, int flags)
{
 return json_object_to_json_string_length(jso, flags, 0);
}



const char *json_object_to_json_string(struct json_object *jso)
{
 return json_object_to_json_string_ext(jso, (1 << 0));
}

static void indent(struct printbuf *pb, int level, int flags)
{
 if (flags & (1 << 1))
 {
  if (flags & (1 << 3))
  {
   printbuf_memset(pb, -1, '\t', level);
  }
  else
  {
   printbuf_memset(pb, -1, ' ', level * 2);
  }
 }
}



static int json_object_object_to_json_string(struct json_object *jso, struct printbuf *pb,
                                             int level, int flags)
{
 int had_children = 0;
 struct json_object_iter iter;

 printbuf_memappend((pb), ("" "{"), sizeof("{") - 1);
 for (iter.entry = lh_table_head(json_object_get_object(jso)); (iter.entry ? (iter.key = (char *)lh_entry_k(iter.entry), iter.val = (struct json_object *)lh_entry_v(iter.entry), iter.entry) : 0); iter.entry = lh_entry_next(iter.entry))
 {
  if (had_children)
  {
   printbuf_memappend((pb), ("" ","), sizeof(",") - 1);
  }
  if (flags & (1 << 1))
   printbuf_memappend((pb), ("" "\n"), sizeof("\n") - 1);
  had_children = 1;
  if (flags & (1 << 0) && !(flags & (1 << 1)))
   printbuf_memappend((pb), ("" " "), sizeof(" ") - 1);
  indent(pb, level + 1, flags);
  if (flags & (1 << 5))
   printbuf_memappend((pb), ("" "\033[0;34m"), sizeof("\033[0;34m") - 1);

  printbuf_memappend((pb), ("" "\""), sizeof("\"") - 1);
  json_escape_str(pb, iter.key, strlen(iter.key), flags);
  printbuf_memappend((pb), ("" "\""), sizeof("\"") - 1);

  if (flags & (1 << 5))
   printbuf_memappend((pb), ("" "\033[0m"), sizeof("\033[0m") - 1);

  if (flags & (1 << 0))
   printbuf_memappend((pb), ("" ": "), sizeof(": ") - 1);
  else
   printbuf_memappend((pb), ("" ":"), sizeof(":") - 1);

  if (iter.val == 0) {
   if (flags & (1 << 5))
    printbuf_memappend((pb), ("" "\033[0;35m"), sizeof("\033[0;35m") - 1);
   printbuf_memappend((pb), ("" "null"), sizeof("null") - 1);
   if (flags & (1 << 5))
    printbuf_memappend((pb), ("" "\033[0m"), sizeof("\033[0m") - 1);
  } else if (iter.val->_to_json_string(iter.val, pb, level + 1, flags) < 0)
   return -1;
 }
 if ((flags & (1 << 1)) && had_children)
 {
  printbuf_memappend((pb), ("" "\n"), sizeof("\n") - 1);
  indent(pb, level, flags);
 }
 if (flags & (1 << 0) && !(flags & (1 << 1)))
  return printbuf_memappend((pb), ("" " }"), sizeof(" }") - 1);
 else
  return printbuf_memappend((pb), ("" "}"), sizeof("}") - 1);
}

static void json_object_lh_entry_free(struct lh_entry *ent)
{
 if (!lh_entry_k_is_constant(ent))
  free(lh_entry_k(ent));
 json_object_put((struct json_object *)lh_entry_v(ent));
}

static void json_object_object_delete(struct json_object *jso_base)
{
 lh_table_free(JC_OBJECT(jso_base)->c_object);
 json_object_generic_delete(jso_base);
}

struct json_object *json_object_new_object(void)
{
 struct json_object_object *jso = (struct json_object_object *)json_object_new( json_type_object, sizeof(struct json_object_object), &json_object_object_to_json_string);
 if (!jso)
  return 0;
 jso->c_object =
     lh_kchar_table_new(16, &json_object_lh_entry_free);
 if (!jso->c_object)
 {
  json_object_generic_delete(&jso->base);
  errno = ENOMEM;
  return 0;
 }
 return &jso->base;
}

struct lh_table *json_object_get_object(const struct json_object *jso)
{
 if (!jso)
  return 0;
 switch (jso->o_type)
 {
 case json_type_object: return JC_OBJECT_C(jso)->c_object;
 default: return 0;
 }
}

int json_object_object_add_ex(struct json_object *jso, const char *const key,
                              struct json_object *const val, const unsigned opts)
{
 struct json_object *existing_value = 0;
 struct lh_entry *existing_entry;
 unsigned long hash;

 assert(json_object_get_type(jso) == json_type_object);



 hash = lh_get_hash(JC_OBJECT(jso)->c_object, (const void *)key);
 existing_entry =
     (opts & (1 << 1))
         ? 0
         : lh_table_lookup_entry_w_hash(JC_OBJECT(jso)->c_object, (const void *)key, hash);



 if (jso == val)
  return -1;

 if (!existing_entry)
 {
  const void *const k =
      (opts & (1 << 2)) ? (const void *)key : strdup(key);
  if (k == 0)
   return -1;
  return lh_table_insert_w_hash(JC_OBJECT(jso)->c_object, k, val, hash, opts);
 }
 existing_value = (json_object *)lh_entry_v(existing_entry);
 if (existing_value)
  json_object_put(existing_value);
 lh_entry_set_val(existing_entry, val);
 return 0;
}

int json_object_object_add(struct json_object *jso, const char *key, struct json_object *val)
{
 return json_object_object_add_ex(jso, key, val, 0);
}

int json_object_object_length(const struct json_object *jso)
{
 assert(json_object_get_type(jso) == json_type_object);
 return lh_table_length(JC_OBJECT_C(jso)->c_object);
}

size_t json_c_object_sizeof(void)
{
 return sizeof(struct json_object);
}

struct json_object *json_object_object_get(const struct json_object *jso, const char *key)
{
 struct json_object *result = 0;
 json_object_object_get_ex(jso, key, &result);
 return result;
}

json_bool json_object_object_get_ex(const struct json_object *jso, const char *key,
                                    struct json_object **value)
{
 if (value != 0)
  *value = 0;

 if (0 == jso)
  return 0;

 switch (jso->o_type)
 {
 case json_type_object:
  return lh_table_lookup_ex(JC_OBJECT_C(jso)->c_object, (const void *)key,
                            (void **)value);
 default:
  if (value != 0)
   *value = 0;
  return 0;
 }
}

void json_object_object_del(struct json_object *jso, const char *key)
{
 assert(json_object_get_type(jso) == json_type_object);
 lh_table_delete(JC_OBJECT(jso)->c_object, key);
}



static int json_object_boolean_to_json_string(struct json_object *jso, struct printbuf *pb,
                                              int level, int flags)
{
 int ret;

 if (flags & (1 << 5))
  printbuf_memappend((pb), ("" "\033[0;35m"), sizeof("\033[0;35m") - 1);

 if (JC_BOOL(jso)->c_boolean)
  ret = printbuf_memappend((pb), ("" "true"), sizeof("true") - 1);
 else
  ret = printbuf_memappend((pb), ("" "false"), sizeof("false") - 1);
 if (ret > -1 && flags & (1 << 5))
  return printbuf_memappend((pb), ("" "\033[0m"), sizeof("\033[0m") - 1);
 return ret;
}

struct json_object *json_object_new_boolean(json_bool b)
{
 struct json_object_boolean *jso = (struct json_object_boolean *)json_object_new( json_type_boolean, sizeof(struct json_object_boolean), &json_object_boolean_to_json_string);
 if (!jso)
  return 0;
 jso->c_boolean = b;
 return &jso->base;
}

json_bool json_object_get_boolean(const struct json_object *jso)
{
 if (!jso)
  return 0;
 switch (jso->o_type)
 {
 case json_type_boolean: return JC_BOOL_C(jso)->c_boolean;
 case json_type_int:
  switch (JC_INT_C(jso)->cint_type)
  {
  case json_object_int_type_int64: return (JC_INT_C(jso)->cint.c_int64 != 0);
  case json_object_int_type_uint64: return (JC_INT_C(jso)->cint.c_uint64 != 0);
  default: json_abort("invalid cint_type");
  }
 case json_type_double: return (JC_DOUBLE_C(jso)->c_double != 0);
 case json_type_string: return (JC_STRING_C(jso)->len != 0);
 default: return 0;
 }
}

int json_object_set_boolean(struct json_object *jso, json_bool new_value)
{
 if (!jso || jso->o_type != json_type_boolean)
  return 0;
 JC_BOOL(jso)->c_boolean = new_value;
 return 1;
}



static int json_object_int_to_json_string(struct json_object *jso, struct printbuf *pb, int level,
                                          int flags)
{

 char sbuf[21];
 if (JC_INT(jso)->cint_type == json_object_int_type_int64)
  snprintf(sbuf, sizeof(sbuf), "%" "d", JC_INT(jso)->cint.c_int64);
 else
  snprintf(sbuf, sizeof(sbuf), "%" "u", JC_INT(jso)->cint.c_uint64);
 return printbuf_memappend(pb, sbuf, strlen(sbuf));
}

struct json_object *json_object_new_int(int32_t i)
{
 return json_object_new_int64(i);
}

int32_t json_object_get_int(const struct json_object *jso)
{
 int64_t cint64 = 0;
 double cdouble;
 enum json_type o_type;
 errno = 0;

 if (!jso)
  return 0;

 o_type = jso->o_type;
 if (o_type == json_type_int)
 {
  const struct json_object_int *jsoint = JC_INT_C(jso);
  if (jsoint->cint_type == json_object_int_type_int64)
  {
   cint64 = jsoint->cint.c_int64;
  }
  else
  {
   if (jsoint->cint.c_uint64 >= INT64_MAX)
    cint64 = INT64_MAX;
   else
    cint64 = (int64_t)jsoint->cint.c_uint64;
  }
 }
 else if (o_type == json_type_string)
 {




  if (json_parse_int64(get_string_component(jso), &cint64) != 0)
   return 0;
  o_type = json_type_int;
 }

 switch (o_type)
 {
 case json_type_int:

  if (cint64 < INT32_MIN)
  {
   errno = ERANGE;
   return INT32_MIN;
  }
  if (cint64 > INT32_MAX)
  {
   errno = ERANGE;
   return INT32_MAX;
  }
  return (int32_t)cint64;
 case json_type_double:
  cdouble = JC_DOUBLE_C(jso)->c_double;
  if (cdouble < INT32_MIN)
  {
   errno = ERANGE;
   return INT32_MIN;
  }
  if (cdouble > INT32_MAX)
  {
   errno = ERANGE;
   return INT32_MAX;
  }
  if (isnan(cdouble))
  {
   errno = EINVAL;
   return INT32_MIN;
  }
  return (int32_t)cdouble;
 case json_type_boolean: return JC_BOOL_C(jso)->c_boolean;
 default: return 0;
 }
}

int json_object_set_int(struct json_object *jso, int new_value)
{
 return json_object_set_int64(jso, (int64_t)new_value);
}

struct json_object *json_object_new_int64(int64_t i)
{
 struct json_object_int *jso = (struct json_object_int *)json_object_new( json_type_int, sizeof(struct json_object_int), &json_object_int_to_json_string);
 if (!jso)
  return 0;
 jso->cint.c_int64 = i;
 jso->cint_type = json_object_int_type_int64;
 return &jso->base;
}

struct json_object *json_object_new_uint64(uint64_t i)
{
 struct json_object_int *jso = (struct json_object_int *)json_object_new( json_type_int, sizeof(struct json_object_int), &json_object_int_to_json_string);
 if (!jso)
  return 0;
 jso->cint.c_uint64 = i;
 jso->cint_type = json_object_int_type_uint64;
 return &jso->base;
}

int64_t json_object_get_int64(const struct json_object *jso)
{
 int64_t cint;
 errno = 0;

 if (!jso)
  return 0;
 switch (jso->o_type)
 {
 case json_type_int:
 {
  const struct json_object_int *jsoint = JC_INT_C(jso);
  switch (jsoint->cint_type)
  {
  case json_object_int_type_int64: return jsoint->cint.c_int64;
  case json_object_int_type_uint64:
   if (jsoint->cint.c_uint64 > INT64_MAX)
   {
    errno = ERANGE;
    return INT64_MAX;
   }
   return (int64_t)jsoint->cint.c_uint64;
  default: json_abort("invalid cint_type");
  }
 }
 case json_type_double:


  if (JC_DOUBLE_C(jso)->c_double > (double)INT64_MAX)
  {
   errno = ERANGE;
   return INT64_MAX;
  }
  if (JC_DOUBLE_C(jso)->c_double < (double)INT64_MIN)
  {
   errno = ERANGE;
   return INT64_MIN;
  }
  if (isnan(JC_DOUBLE_C(jso)->c_double))
  {
   errno = EINVAL;
   return INT64_MIN;
  }
  return (int64_t)JC_DOUBLE_C(jso)->c_double;
 case json_type_boolean: return JC_BOOL_C(jso)->c_boolean;
 case json_type_string:
  if (json_parse_int64(get_string_component(jso), &cint) == 0)
   return cint;

 default: return 0;
 }
}

uint64_t json_object_get_uint64(const struct json_object *jso)
{
 uint64_t cuint;
 errno = 0;

 if (!jso)
  return 0;
 switch (jso->o_type)
 {
 case json_type_int:
 {
  const struct json_object_int *jsoint = JC_INT_C(jso);
  switch (jsoint->cint_type)
  {
  case json_object_int_type_int64:
   if (jsoint->cint.c_int64 < 0)
   {
    errno = ERANGE;
    return 0;
   }
   return (uint64_t)jsoint->cint.c_int64;
  case json_object_int_type_uint64: return jsoint->cint.c_uint64;
  default: json_abort("invalid cint_type");
  }
 }
 case json_type_double:


  if (JC_DOUBLE_C(jso)->c_double > (double)UINT64_MAX)
  {
   errno = ERANGE;
   return UINT64_MAX;
  }
  if (JC_DOUBLE_C(jso)->c_double < 0)
  {
   errno = ERANGE;
   return 0;
  }
  if (isnan(JC_DOUBLE_C(jso)->c_double))
  {
   errno = EINVAL;
   return 0;
  }
  return (uint64_t)JC_DOUBLE_C(jso)->c_double;
 case json_type_boolean: return JC_BOOL_C(jso)->c_boolean;
 case json_type_string:
  if (json_parse_uint64(get_string_component(jso), &cuint) == 0)
   return cuint;

 default: return 0;
 }
}

int json_object_set_int64(struct json_object *jso, int64_t new_value)
{
 if (!jso || jso->o_type != json_type_int)
  return 0;
 JC_INT(jso)->cint.c_int64 = new_value;
 JC_INT(jso)->cint_type = json_object_int_type_int64;
 return 1;
}

int json_object_set_uint64(struct json_object *jso, uint64_t new_value)
{
 if (!jso || jso->o_type != json_type_int)
  return 0;
 JC_INT(jso)->cint.c_uint64 = new_value;
 JC_INT(jso)->cint_type = json_object_int_type_uint64;
 return 1;
}

int json_object_int_inc(struct json_object *jso, int64_t val)
{
 struct json_object_int *jsoint;
 if (!jso || jso->o_type != json_type_int)
  return 0;
 jsoint = JC_INT(jso);
 switch (jsoint->cint_type)
 {
 case json_object_int_type_int64:
  if (val > 0 && jsoint->cint.c_int64 > INT64_MAX - val)
  {
   jsoint->cint.c_uint64 = (uint64_t)jsoint->cint.c_int64 + (uint64_t)val;
   jsoint->cint_type = json_object_int_type_uint64;
  }
  else if (val < 0 && jsoint->cint.c_int64 < INT64_MIN - val)
  {
   jsoint->cint.c_int64 = INT64_MIN;
  }
  else
  {
   jsoint->cint.c_int64 += val;
  }
  return 1;
 case json_object_int_type_uint64:
  if (val > 0 && jsoint->cint.c_uint64 > UINT64_MAX - (uint64_t)val)
  {
   jsoint->cint.c_uint64 = UINT64_MAX;
  }
  else if (val < 0 && jsoint->cint.c_uint64 < (uint64_t)(-val))
  {
   jsoint->cint.c_int64 = (int64_t)jsoint->cint.c_uint64 + val;
   jsoint->cint_type = json_object_int_type_int64;
  }
  else if (val < 0 && jsoint->cint.c_uint64 >= (uint64_t)(-val))
  {
   jsoint->cint.c_uint64 -= (uint64_t)(-val);
  }
  else
  {
   jsoint->cint.c_uint64 += val;
  }
  return 1;
 default: json_abort("invalid cint_type");
 }
}





static char *tls_serialization_float_format = 0;

static char *global_serialization_float_format = 0;

int json_c_set_serialization_double_format(const char *double_format, int global_or_thread)
{
 if (global_or_thread == (0))
 {

  if (tls_serialization_float_format)
  {
   free(tls_serialization_float_format);
   tls_serialization_float_format = 0;
  }

  if (global_serialization_float_format)
   free(global_serialization_float_format);
  if (double_format)
  {
   char *p = strdup(double_format);
   if (p == 0)
   {
    _json_c_set_last_err("json_c_set_serialization_double_format: "
                         "out of memory\n");
    return -1;
   }
   global_serialization_float_format = p;
  }
  else
  {
   global_serialization_float_format = 0;
  }
 }
 else if (global_or_thread == (1))
 {

  if (tls_serialization_float_format)
  {
   free(tls_serialization_float_format);
   tls_serialization_float_format = 0;
  }
  if (double_format)
  {
   char *p = strdup(double_format);
   if (p == 0)
   {
    _json_c_set_last_err("json_c_set_serialization_double_format: "
                         "out of memory\n");
    return -1;
   }
   tls_serialization_float_format = p;
  }
  else
  {
   tls_serialization_float_format = 0;
  }





 }
 else
 {
  _json_c_set_last_err("json_c_set_serialization_double_format: invalid "
                       "global_or_thread value: %d\n", global_or_thread);
  return -1;
 }
 return 0;
}

static int json_object_double_to_json_string_format(struct json_object *jso, struct printbuf *pb,
                                                    int level, int flags, const char *format)
{
 struct json_object_double *jsodbl = JC_DOUBLE(jso);
 char buf[128], *p, *q;
 int size;





 if (isnan(jsodbl->c_double))
 {
  size = snprintf(buf, sizeof(buf), "NaN");
 }
 else if (isinf(jsodbl->c_double))
 {
  if (jsodbl->c_double > 0)
   size = snprintf(buf, sizeof(buf), "Infinity");
  else
   size = snprintf(buf, sizeof(buf), "-Infinity");
 }
 else
 {
  const char *std_format = "%.17g";
  int format_drops_decimals = 0;
  int looks_numeric = 0;

  if (!format)
  {

   if (tls_serialization_float_format)
    format = tls_serialization_float_format;
   else

       if (global_serialization_float_format)
    format = global_serialization_float_format;
   else
    format = std_format;
  }
  size = snprintf(buf, sizeof(buf), format, jsodbl->c_double);

  if (size < 0)
   return -1;

  p = strchr(buf, ',');
  if (p)
   *p = '.';
  else
   p = strchr(buf, '.');

  if (format == std_format || strstr(format, ".0f") == 0)
   format_drops_decimals = 1;

  looks_numeric =
      ((buf[0]) >= '0' && (buf[0]) <= '9') || (size > 1 && buf[0] == '-' && ((buf[1]) >= '0' && (buf[1]) <= '9'));

  if (size < (int)sizeof(buf) - 2 && looks_numeric && !p &&
      strchr(buf, 'e') == 0 &&
      format_drops_decimals)
  {


   strcat(buf, ".0");
   size += 2;
  }
  if (p && (flags & (1 << 2)))
  {

   p++;
   for (q = p; *q; q++)
   {
    if (*q != '0')
     p = q;
   }

   if (*p != 0)
    *(++p) = 0;
   size = p - buf;
  }
 }

 if (size < 0)
  return -1;

 if (size >= (int)sizeof(buf))


  size = sizeof(buf) - 1;
 printbuf_memappend(pb, buf, size);
 return size;
}

static int json_object_double_to_json_string_default(struct json_object *jso, struct printbuf *pb,
                                                     int level, int flags)
{
 return json_object_double_to_json_string_format(jso, pb, level, flags, 0);
}

int json_object_double_to_json_string(struct json_object *jso, struct printbuf *pb, int level,
                                      int flags)
{
 return json_object_double_to_json_string_format(jso, pb, level, flags,
                                                 (const char *)jso->_userdata);
}

struct json_object *json_object_new_double(double d)
{
 struct json_object_double *jso = (struct json_object_double *)json_object_new( json_type_double, sizeof(struct json_object_double), &json_object_double_to_json_string);
 if (!jso)
  return 0;
 jso->base._to_json_string = &json_object_double_to_json_string_default;
 jso->c_double = d;
 return &jso->base;
}

struct json_object *json_object_new_double_s(double d, const char *ds)
{
 char *new_ds;
 struct json_object *jso = json_object_new_double(d);
 if (!jso)
  return 0;

 new_ds = strdup(ds);
 if (!new_ds)
 {
  json_object_generic_delete(jso);
  errno = ENOMEM;
  return 0;
 }
 json_object_set_serializer(jso, _json_object_userdata_to_json_string, new_ds,
                            json_object_free_userdata);
 return jso;
}






static int _json_object_userdata_to_json_string(struct json_object *jso, struct printbuf *pb,
                                                int level, int flags)
{
 return json_object_userdata_to_json_string(jso, pb, level, flags);
}

int json_object_userdata_to_json_string(struct json_object *jso, struct printbuf *pb, int level,
                                        int flags)
{
 int userdata_len = strlen((const char *)jso->_userdata);
 printbuf_memappend(pb, (const char *)jso->_userdata, userdata_len);
 return userdata_len;
}

void json_object_free_userdata(struct json_object *jso, void *userdata)
{
 free(userdata);
}

double json_object_get_double(const struct json_object *jso)
{
 double cdouble;
 char *errPtr = 0;

 if (!jso)
  return 0.0;
 switch (jso->o_type)
 {
 case json_type_double: return JC_DOUBLE_C(jso)->c_double;
 case json_type_int:
  switch (JC_INT_C(jso)->cint_type)
  {
  case json_object_int_type_int64: return JC_INT_C(jso)->cint.c_int64;
  case json_object_int_type_uint64: return JC_INT_C(jso)->cint.c_uint64;
  default: json_abort("invalid cint_type");
  }
 case json_type_boolean: return JC_BOOL_C(jso)->c_boolean;
 case json_type_string:
  errno = 0;
  cdouble = strtod(get_string_component(jso), &errPtr);


  if (errPtr == get_string_component(jso))
  {
   errno = EINVAL;
   return 0.0;
  }






  if (*errPtr != '\0')
  {
   errno = EINVAL;
   return 0.0;
  }
# 1274 "/app/subjects/json-c/json_object.c"
  if ((HUGE_VAL == cdouble || -HUGE_VAL == cdouble) && (ERANGE == errno))
   cdouble = 0.0;
  return cdouble;
 default: errno = EINVAL; return 0.0;
 }
}

int json_object_set_double(struct json_object *jso, double new_value)
{
 if (!jso || jso->o_type != json_type_double)
  return 0;
 JC_DOUBLE(jso)->c_double = new_value;
 if (jso->_to_json_string == &_json_object_userdata_to_json_string)
  json_object_set_serializer(jso, 0, 0, 0);
 return 1;
}



static int json_object_string_to_json_string(struct json_object *jso, struct printbuf *pb,
                                             int level, int flags)
{
 ssize_t len = JC_STRING(jso)->len;
 if (flags & (1 << 5))
  printbuf_memappend((pb), ("" "\033[0;32m"), sizeof("\033[0;32m") - 1);
 printbuf_memappend((pb), ("" "\""), sizeof("\"") - 1);
 json_escape_str(pb, get_string_component(jso), len < 0 ? -(ssize_t)len : len, flags);
 printbuf_memappend((pb), ("" "\""), sizeof("\"") - 1);
 if (flags & (1 << 5))
  printbuf_memappend((pb), ("" "\033[0m"), sizeof("\033[0m") - 1);
 return 0;
}

static void json_object_string_delete(struct json_object *jso)
{
 if (JC_STRING(jso)->len < 0)
  free(JC_STRING(jso)->c_string.pdata);
 json_object_generic_delete(jso);
}

static struct json_object *_json_object_new_string(const char *s, const size_t len)
{
 size_t objsize;
 struct json_object_string *jso;
# 1332 "/app/subjects/json-c/json_object.c"
 if (len > (9223372036854775807L - (sizeof(*jso) - sizeof(jso->c_string)) - 1))
  return 0;
 objsize = (sizeof(*jso) - sizeof(jso->c_string)) + len + 1;
 if (len < sizeof(void *))


  objsize += sizeof(void *) - len;

 jso = (struct json_object_string *)json_object_new(json_type_string, objsize,
                                                    &json_object_string_to_json_string);

 if (!jso)
  return 0;
 jso->len = len;
 memcpy(jso->c_string.idata, s, len);

 ((char *)jso->c_string.idata)[len] = '\0';
 return &jso->base;
}

struct json_object *json_object_new_string(const char *s)
{
 return _json_object_new_string(s, strlen(s));
}

struct json_object *json_object_new_string_len(const char *s, const int len)
{
 return _json_object_new_string(s, len);
}

const char *json_object_get_string(struct json_object *jso)
{
 if (!jso)
  return 0;
 switch (jso->o_type)
 {
 case json_type_string: return get_string_component(jso);
 default: return json_object_to_json_string(jso);
 }
}

static inline ssize_t _json_object_get_string_len(const struct json_object_string *jso)
{
 ssize_t len;
 len = jso->len;
 return (len < 0) ? -(ssize_t)len : len;
}
int json_object_get_string_len(const struct json_object *jso)
{
 if (!jso)
  return 0;
 switch (jso->o_type)
 {
 case json_type_string: return _json_object_get_string_len(JC_STRING_C(jso));
 default: return 0;
 }
}

static int _json_object_set_string_len(json_object *jso, const char *s, size_t len)
{
 char *dstbuf;
 ssize_t curlen;
 ssize_t newlen;
 if (jso == 0 || jso->o_type != json_type_string)
  return 0;

 if (len >= 2147483647 - 1)



  return 0;

 curlen = JC_STRING(jso)->len;
 if (curlen < 0) {
  if (len == 0) {
   free(JC_STRING(jso)->c_string.pdata);
   JC_STRING(jso)->len = curlen = 0;
  } else {
   curlen = -curlen;
  }
 }

 newlen = len;
 dstbuf = get_string_component_mutable(jso);

 if ((ssize_t)len > curlen)
 {



  dstbuf = (char *)malloc(len + 1);
  if (dstbuf == 0)
   return 0;
  if (JC_STRING(jso)->len < 0)
   free(JC_STRING(jso)->c_string.pdata);
  JC_STRING(jso)->c_string.pdata = dstbuf;
  newlen = -(ssize_t)len;
 }
 else if (JC_STRING(jso)->len < 0)
 {


  newlen = -(ssize_t)len;
 }

 memcpy(dstbuf, (const void *)s, len);
 dstbuf[len] = '\0';
 JC_STRING(jso)->len = newlen;
 return 1;
}

int json_object_set_string(json_object *jso, const char *s)
{
 return _json_object_set_string_len(jso, s, strlen(s));
}

int json_object_set_string_len(json_object *jso, const char *s, int len)
{
 return _json_object_set_string_len(jso, s, len);
}



static int json_object_array_to_json_string(struct json_object *jso, struct printbuf *pb, int level,
                                            int flags)
{
 int had_children = 0;
 size_t ii;

 printbuf_memappend((pb), ("" "["), sizeof("[") - 1);
 for (ii = 0; ii < json_object_array_length(jso); ii++)
 {
  struct json_object *val;
  if (had_children)
  {
   printbuf_memappend((pb), ("" ","), sizeof(",") - 1);
  }
  if (flags & (1 << 1))
   printbuf_memappend((pb), ("" "\n"), sizeof("\n") - 1);
  had_children = 1;
  if (flags & (1 << 0) && !(flags & (1 << 1)))
   printbuf_memappend((pb), ("" " "), sizeof(" ") - 1);
  indent(pb, level + 1, flags);
  val = json_object_array_get_idx(jso, ii);
  if (val == 0) {

   if (flags & (1 << 5))
    printbuf_memappend((pb), ("" "\033[0;35m"), sizeof("\033[0;35m") - 1);
   printbuf_memappend((pb), ("" "null"), sizeof("null") - 1);
   if (flags & (1 << 5))
    printbuf_memappend((pb), ("" "\033[0m"), sizeof("\033[0m") - 1);

  } else if (val->_to_json_string(val, pb, level + 1, flags) < 0)
   return -1;
 }
 if ((flags & (1 << 1)) && had_children)
 {
  printbuf_memappend((pb), ("" "\n"), sizeof("\n") - 1);
  indent(pb, level, flags);
 }

 if (flags & (1 << 0) && !(flags & (1 << 1)))
  return printbuf_memappend((pb), ("" " ]"), sizeof(" ]") - 1);
 return printbuf_memappend((pb), ("" "]"), sizeof("]") - 1);
}

static void json_object_array_entry_free(void *data)
{
 json_object_put((struct json_object *)data);
}

static void json_object_array_delete(struct json_object *jso)
{
 array_list_free(JC_ARRAY(jso)->c_array);
 json_object_generic_delete(jso);
}

struct json_object *json_object_new_array(void)
{
 return json_object_new_array_ext(32);
}
struct json_object *json_object_new_array_ext(int initial_size)
{
 struct json_object_array *jso = (struct json_object_array *)json_object_new( json_type_array, sizeof(struct json_object_array), &json_object_array_to_json_string);
 if (!jso)
  return 0;
 jso->c_array = array_list_new2(&json_object_array_entry_free, initial_size);
 if (jso->c_array == 0)
 {
  free(jso);
  return 0;
 }
 return &jso->base;
}

struct array_list *json_object_get_array(const struct json_object *jso)
{
 if (!jso)
  return 0;
 switch (jso->o_type)
 {
 case json_type_array: return JC_ARRAY_C(jso)->c_array;
 default: return 0;
 }
}

void json_object_array_sort(struct json_object *jso, int (*sort_fn)(const void *, const void *))
{
 assert(json_object_get_type(jso) == json_type_array);
 array_list_sort(JC_ARRAY(jso)->c_array, sort_fn);
}

struct json_object *json_object_array_bsearch(const struct json_object *key,
                                              const struct json_object *jso,
                                              int (*sort_fn)(const void *, const void *))
{
 struct json_object **result;

 assert(json_object_get_type(jso) == json_type_array);
 result = (struct json_object **)array_list_bsearch((const void **)(void *)&key,
                                                    JC_ARRAY_C(jso)->c_array, sort_fn);

 if (!result)
  return 0;
 return *result;
}

size_t json_object_array_length(const struct json_object *jso)
{
 assert(json_object_get_type(jso) == json_type_array);
 return array_list_length(JC_ARRAY_C(jso)->c_array);
}

int json_object_array_add(struct json_object *jso, struct json_object *val)
{
 assert(json_object_get_type(jso) == json_type_array);
 return array_list_add(JC_ARRAY(jso)->c_array, val);
}

int json_object_array_insert_idx(struct json_object *jso, size_t idx, struct json_object *val)
{
 assert(json_object_get_type(jso) == json_type_array);
 return array_list_insert_idx(JC_ARRAY(jso)->c_array, idx, val);
}

int json_object_array_put_idx(struct json_object *jso, size_t idx, struct json_object *val)
{
 assert(json_object_get_type(jso) == json_type_array);
 return array_list_put_idx(JC_ARRAY(jso)->c_array, idx, val);
}

int json_object_array_del_idx(struct json_object *jso, size_t idx, size_t count)
{
 assert(json_object_get_type(jso) == json_type_array);
 return array_list_del_idx(JC_ARRAY(jso)->c_array, idx, count);
}

struct json_object *json_object_array_get_idx(const struct json_object *jso, size_t idx)
{
 assert(json_object_get_type(jso) == json_type_array);
 return (struct json_object *)array_list_get_idx(JC_ARRAY_C(jso)->c_array, idx);
}

static int json_array_equal(struct json_object *jso1, struct json_object *jso2)
{
 size_t len, i;

 len = json_object_array_length(jso1);
 if (len != json_object_array_length(jso2))
  return 0;

 for (i = 0; i < len; i++)
 {
  if (!json_object_equal(json_object_array_get_idx(jso1, i),
                         json_object_array_get_idx(jso2, i)))
   return 0;
 }
 return 1;
}

int json_object_array_shrink(struct json_object *jso, int empty_slots)
{
 if (empty_slots < 0)
  json_abort("json_object_array_shrink called with negative empty_slots");
 return array_list_shrink(JC_ARRAY(jso)->c_array, empty_slots);
}

struct json_object *json_object_new_null(void)
{
 return 0;
}

static int json_object_all_values_equal(struct json_object *jso1, struct json_object *jso2)
{
 struct json_object_iter iter;
 struct json_object *sub;

 assert(json_object_get_type(jso1) == json_type_object);
 assert(json_object_get_type(jso2) == json_type_object);

 for (iter.entry = lh_table_head(json_object_get_object(jso1)); (iter.entry ? (iter.key = (char *)lh_entry_k(iter.entry), iter.val = (struct json_object *)lh_entry_v(iter.entry), iter.entry) : 0); iter.entry = lh_entry_next(iter.entry))
 {
  if (!lh_table_lookup_ex(JC_OBJECT(jso2)->c_object, (void *)iter.key,
                          (void **)(void *)&sub))
   return 0;
  if (!json_object_equal(iter.val, sub))
   return 0;
 }


 for (iter.entry = lh_table_head(json_object_get_object(jso2)); (iter.entry ? (iter.key = (char *)lh_entry_k(iter.entry), iter.val = (struct json_object *)lh_entry_v(iter.entry), iter.entry) : 0); iter.entry = lh_entry_next(iter.entry))
 {
  if (!lh_table_lookup_ex(JC_OBJECT(jso1)->c_object, (void *)iter.key,
                          (void **)(void *)&sub))
   return 0;
 }

 return 1;
}

int json_object_equal(struct json_object *jso1, struct json_object *jso2)
{
 if (jso1 == jso2)
  return 1;

 if (!jso1 || !jso2)
  return 0;

 if (jso1->o_type != jso2->o_type)
  return 0;

 switch (jso1->o_type)
 {
 case json_type_boolean: return (JC_BOOL(jso1)->c_boolean == JC_BOOL(jso2)->c_boolean);

 case json_type_double: return (JC_DOUBLE(jso1)->c_double == JC_DOUBLE(jso2)->c_double);

 case json_type_int:
 {
  struct json_object_int *int1 = JC_INT(jso1);
  struct json_object_int *int2 = JC_INT(jso2);
  if (int1->cint_type == json_object_int_type_int64)
  {
   if (int2->cint_type == json_object_int_type_int64)
    return (int1->cint.c_int64 == int2->cint.c_int64);
   if (int1->cint.c_int64 < 0)
    return 0;
   return ((uint64_t)int1->cint.c_int64 == int2->cint.c_uint64);
  }

  if (int2->cint_type == json_object_int_type_uint64)
   return (int1->cint.c_uint64 == int2->cint.c_uint64);
  if (int2->cint.c_int64 < 0)
   return 0;
  return (int1->cint.c_uint64 == (uint64_t)int2->cint.c_int64);
 }

 case json_type_string:
 {
  return (_json_object_get_string_len(JC_STRING(jso1)) ==
              _json_object_get_string_len(JC_STRING(jso2)) &&
          memcmp(get_string_component(jso1), get_string_component(jso2),
                 _json_object_get_string_len(JC_STRING(jso1))) == 0);
 }

 case json_type_object: return json_object_all_values_equal(jso1, jso2);

 case json_type_array: return json_array_equal(jso1, jso2);

 case json_type_null: return 1;
 };

 return 0;
}

static int json_object_copy_serializer_data(struct json_object *src, struct json_object *dst)
{
 if (!src->_userdata && !src->_user_delete)
  return 0;

 if (dst->_to_json_string == json_object_userdata_to_json_string ||
     dst->_to_json_string == _json_object_userdata_to_json_string)
 {
  char *p;
  assert(src->_userdata);
  p = strdup(src->_userdata);
  if (p == 0)
  {
   _json_c_set_last_err("json_object_copy_serializer_data: out of memory\n");
   return -1;
  }
  dst->_userdata = p;
 }

 else
 {
  _json_c_set_last_err(
      "json_object_copy_serializer_data: unable to copy unknown serializer data: "
      "%p\n", (void *)dst->_to_json_string);
  return -1;
 }
 dst->_user_delete = src->_user_delete;
 return 0;
}
# 1745 "/app/subjects/json-c/json_object.c"
int json_c_shallow_copy_default(json_object *src, json_object *parent, const char *key,
                                size_t index, json_object **dst)
{
 switch (src->o_type)
 {
 case json_type_boolean: *dst = json_object_new_boolean(JC_BOOL(src)->c_boolean); break;

 case json_type_double: *dst = json_object_new_double(JC_DOUBLE(src)->c_double); break;

 case json_type_int:
  switch (JC_INT(src)->cint_type)
  {
  case json_object_int_type_int64:
   *dst = json_object_new_int64(JC_INT(src)->cint.c_int64);
   break;
  case json_object_int_type_uint64:
   *dst = json_object_new_uint64(JC_INT(src)->cint.c_uint64);
   break;
  default: json_abort("invalid cint_type");
  }
  break;

 case json_type_string:
  *dst = json_object_new_string_len(get_string_component(src),
                                    _json_object_get_string_len(JC_STRING(src)));
  break;

 case json_type_object: *dst = json_object_new_object(); break;

 case json_type_array: *dst = json_object_new_array(); break;

 default: errno = EINVAL; return -1;
 }

 if (!*dst)
 {
  errno = ENOMEM;
  return -1;
 }
 (*dst)->_to_json_string = src->_to_json_string;

 return 1;
}







static int json_object_deep_copy_recursive(struct json_object *src, struct json_object *parent,
                                           const char *key_in_parent, size_t index_in_parent,
                                           struct json_object **dst,
                                           json_c_shallow_copy_fn *shallow_copy)
{
 struct json_object_iter iter;
 size_t src_array_len, ii;

 int shallow_copy_rc = 0;
 shallow_copy_rc = shallow_copy(src, parent, key_in_parent, index_in_parent, dst);

 if (shallow_copy_rc < 1)
 {
  errno = EINVAL;
  return -1;
 }
 assert(*dst != 0);

 switch (src->o_type)
 {
 case json_type_object:
  for (iter.entry = lh_table_head(json_object_get_object(src)); (iter.entry ? (iter.key = (char *)lh_entry_k(iter.entry), iter.val = (struct json_object *)lh_entry_v(iter.entry), iter.entry) : 0); iter.entry = lh_entry_next(iter.entry))
  {
   struct json_object *jso = 0;

   if (!iter.val)
    jso = 0;
   else if (json_object_deep_copy_recursive(iter.val, src, iter.key, 4294967295U,
                                            &jso, shallow_copy) < 0)
   {
    json_object_put(jso);
    return -1;
   }

   if (json_object_object_add(*dst, iter.key, jso) < 0)
   {
    json_object_put(jso);
    return -1;
   }
  }
  break;

 case json_type_array:
  src_array_len = json_object_array_length(src);
  for (ii = 0; ii < src_array_len; ii++)
  {
   struct json_object *jso = 0;
   struct json_object *jso1 = json_object_array_get_idx(src, ii);

   if (!jso1)
    jso = 0;
   else if (json_object_deep_copy_recursive(jso1, src, 0, ii, &jso,
                                            shallow_copy) < 0)
   {
    json_object_put(jso);
    return -1;
   }

   if (json_object_array_add(*dst, jso) < 0)
   {
    json_object_put(jso);
    return -1;
   }
  }
  break;

 default:
  break;

 }

 if (shallow_copy_rc != 2)
  return json_object_copy_serializer_data(src, *dst);

 return 0;
}

int json_object_deep_copy(struct json_object *src, struct json_object **dst,
                          json_c_shallow_copy_fn *shallow_copy)
{
 int rc;


 if (!src || !dst || *dst)
 {
  errno = EINVAL;
  return -1;
 }

 if (shallow_copy == 0)
  shallow_copy = json_c_shallow_copy_default;

 rc = json_object_deep_copy_recursive(src, 0, 0, 4294967295U, dst, shallow_copy);
 if (rc < 0)
 {
  json_object_put(*dst);
  *dst = 0;
 }

 return rc;
}

static void json_abort(const char *message)
{
 if (message != 0)
  fprintf(stderr, "json-c aborts with error: %s\n", message);
 abort();
}
