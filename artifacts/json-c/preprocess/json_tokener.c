# 0 "/app/subjects/json-c/json_tokener.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/app/subjects/json-c/json_tokener.c"
# 16 "/app/subjects/json-c/json_tokener.c"
# 1 "/app/subjects/json-c/build/config.h" 1
# 17 "/app/subjects/json-c/json_tokener.c" 2

# 1 "/app/subjects/json-c/math_compat.h" 1
# 19 "/app/subjects/json-c/json_tokener.c" 2
# 1 "/app/pipeline/preprocess/fake_libc_include/assert.h" 1
# 1 "/app/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/app/pipeline/preprocess/fake_libc_include/assert.h" 2
# 1 "/app/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/app/pipeline/preprocess/fake_libc_include/assert.h" 2
# 20 "/app/subjects/json-c/json_tokener.c" 2
# 1 "/app/pipeline/preprocess/fake_libc_include/errno.h" 1
# 21 "/app/subjects/json-c/json_tokener.c" 2
# 1 "/app/pipeline/preprocess/fake_libc_include/limits.h" 1
# 22 "/app/subjects/json-c/json_tokener.c" 2
# 1 "/app/pipeline/preprocess/fake_libc_include/math.h" 1
# 23 "/app/subjects/json-c/json_tokener.c" 2
# 1 "/app/pipeline/preprocess/fake_libc_include/stddef.h" 1
# 24 "/app/subjects/json-c/json_tokener.c" 2
# 1 "/app/pipeline/preprocess/fake_libc_include/stdio.h" 1
# 25 "/app/subjects/json-c/json_tokener.c" 2
# 1 "/app/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 26 "/app/subjects/json-c/json_tokener.c" 2
# 1 "/app/pipeline/preprocess/fake_libc_include/string.h" 1
# 27 "/app/subjects/json-c/json_tokener.c" 2

# 1 "/app/subjects/json-c/debug.h" 1
# 20 "/app/subjects/json-c/debug.h"
# 1 "/app/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 21 "/app/subjects/json-c/debug.h" 2
# 34 "/app/subjects/json-c/debug.h"
extern void mc_set_debug(int debug);
extern int mc_get_debug(void);

extern void mc_set_syslog(int syslog);

extern void mc_debug(const char *msg, ...);
extern void mc_error(const char *msg, ...);
extern void mc_info(const char *msg, ...);
# 29 "/app/subjects/json-c/json_tokener.c" 2
# 1 "/app/subjects/json-c/json_inttypes.h" 1
# 9 "/app/subjects/json-c/json_inttypes.h"
# 1 "/app/subjects/json-c/build/json_config.h" 1
# 10 "/app/subjects/json-c/json_inttypes.h" 2



# 1 "/app/pipeline/preprocess/fake_libc_include/inttypes.h" 1
# 14 "/app/subjects/json-c/json_inttypes.h" 2
# 30 "/app/subjects/json-c/json_tokener.c" 2
# 1 "/app/subjects/json-c/json_object.h" 1
# 27 "/app/subjects/json-c/json_object.h"
# 1 "/app/subjects/json-c/json_types.h" 1
# 28 "/app/subjects/json-c/json_types.h"
struct printbuf;





struct json_object_iter
{
 char *key;
 struct json_object *val;
 struct lh_entry *entry;
};
typedef struct json_object_iter json_object_iter;

typedef int json_bool;




typedef struct json_object json_object;




typedef void(json_object_delete_fn)(struct json_object *jso, void *userdata);




typedef int(json_object_to_json_string_fn)(struct json_object *jso, struct printbuf *pb, int level,
                                           int flags);



typedef enum json_type
{

 json_type_null,
 json_type_boolean,
 json_type_double,
 json_type_int,
 json_type_object,
 json_type_array,
 json_type_string
} json_type;
# 28 "/app/subjects/json-c/json_object.h" 2
# 1 "/app/subjects/json-c/printbuf.h" 1
# 38 "/app/subjects/json-c/printbuf.h"
struct printbuf
{
 char *buf;
 int bpos;
 int size;
};
typedef struct printbuf printbuf;

extern struct printbuf *printbuf_new(void);
# 56 "/app/subjects/json-c/printbuf.h"
extern int printbuf_memappend(struct printbuf *p, const char *buf, int size);
# 105 "/app/subjects/json-c/printbuf.h"
extern int printbuf_memset(struct printbuf *pb, int offset, int charvalue, int len);
# 121 "/app/subjects/json-c/printbuf.h"
extern int sprintbuf(struct printbuf *p, const char *msg, ...);

extern void printbuf_reset(struct printbuf *p);

extern void printbuf_free(struct printbuf *p);
# 29 "/app/subjects/json-c/json_object.h" 2

# 1 "/app/pipeline/preprocess/fake_libc_include/stddef.h" 1
# 31 "/app/subjects/json-c/json_object.h" 2
# 160 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_get(struct json_object *obj);
# 181 "/app/subjects/json-c/json_object.h"
extern int json_object_put(struct json_object *obj);
# 196 "/app/subjects/json-c/json_object.h"
extern int json_object_is_type(const struct json_object *obj, enum json_type type);
# 212 "/app/subjects/json-c/json_object.h"
extern enum json_type json_object_get_type(const struct json_object *obj);
# 223 "/app/subjects/json-c/json_object.h"
extern const char *json_object_to_json_string(struct json_object *obj);







extern const char *json_object_to_json_string_ext(struct json_object *obj, int flags);
# 240 "/app/subjects/json-c/json_object.h"
extern const char *json_object_to_json_string_length(struct json_object *obj, int flags,
                                                          size_t *length);







extern void *json_object_get_userdata(json_object *jso);
# 276 "/app/subjects/json-c/json_object.h"
extern void json_object_set_userdata(json_object *jso, void *userdata,
                                          json_object_delete_fn *user_delete);
# 309 "/app/subjects/json-c/json_object.h"
extern void json_object_set_serializer(json_object *jso,
                                            json_object_to_json_string_fn *to_string_func,
                                            void *userdata, json_object_delete_fn *user_delete);
# 330 "/app/subjects/json-c/json_object.h"
extern json_object_delete_fn json_object_free_userdata;
# 341 "/app/subjects/json-c/json_object.h"
extern json_object_to_json_string_fn json_object_userdata_to_json_string;
# 360 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_new_object(void);





extern struct lh_table *json_object_get_object(const struct json_object *obj);




extern int json_object_object_length(const struct json_object *obj);




extern size_t json_c_object_sizeof(void) ;
# 403 "/app/subjects/json-c/json_object.h"
extern int json_object_object_add(struct json_object *obj, const char *key,
                                       struct json_object *val);
# 419 "/app/subjects/json-c/json_object.h"
extern int json_object_object_add_ex(struct json_object *obj, const char *const key,
                                          struct json_object *const val, const unsigned opts);
# 443 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_object_get(const struct json_object *obj,
                                                       const char *key);
# 464 "/app/subjects/json-c/json_object.h"
extern int json_object_object_get_ex(const struct json_object *obj, const char *key,
                                                struct json_object **value);
# 476 "/app/subjects/json-c/json_object.h"
extern void json_object_object_del(struct json_object *obj, const char *key);
# 546 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_new_array(void);







extern struct json_object *json_object_new_array_ext(int initial_size);





extern struct array_list *json_object_get_array(const struct json_object *obj);





extern size_t json_object_array_length(const struct json_object *obj);
# 576 "/app/subjects/json-c/json_object.h"
extern void json_object_array_sort(struct json_object *jso,
                                        int (*sort_fn)(const void *, const void *));
# 593 "/app/subjects/json-c/json_object.h"
extern struct json_object *
json_object_array_bsearch(const struct json_object *key, const struct json_object *jso,
                          int (*sort_fn)(const void *, const void *));
# 606 "/app/subjects/json-c/json_object.h"
extern int json_object_array_add(struct json_object *obj, struct json_object *val);
# 623 "/app/subjects/json-c/json_object.h"
extern int json_object_array_put_idx(struct json_object *obj, size_t idx,
                                          struct json_object *val);
# 642 "/app/subjects/json-c/json_object.h"
extern int json_object_array_insert_idx(struct json_object *obj, size_t idx,
                                             struct json_object *val);
# 658 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_array_get_idx(const struct json_object *obj,
                                                          size_t idx);
# 672 "/app/subjects/json-c/json_object.h"
extern int json_object_array_del_idx(struct json_object *obj, size_t idx, size_t count);
# 681 "/app/subjects/json-c/json_object.h"
extern int json_object_array_shrink(struct json_object *jso, int empty_slots);







extern struct json_object *json_object_new_boolean(json_bool b);
# 703 "/app/subjects/json-c/json_object.h"
extern json_bool json_object_get_boolean(const struct json_object *obj);
# 715 "/app/subjects/json-c/json_object.h"
extern int json_object_set_boolean(struct json_object *obj, json_bool new_value);
# 725 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_new_int(int32_t i);





extern struct json_object *json_object_new_int64(int64_t i);





extern struct json_object *json_object_new_uint64(uint64_t i);
# 756 "/app/subjects/json-c/json_object.h"
extern int32_t json_object_get_int(const struct json_object *obj);
# 768 "/app/subjects/json-c/json_object.h"
extern int json_object_set_int(struct json_object *obj, int new_value);
# 784 "/app/subjects/json-c/json_object.h"
extern int json_object_int_inc(struct json_object *obj, int64_t val);
# 803 "/app/subjects/json-c/json_object.h"
extern int64_t json_object_get_int64(const struct json_object *obj);
# 822 "/app/subjects/json-c/json_object.h"
extern uint64_t json_object_get_uint64(const struct json_object *obj);
# 834 "/app/subjects/json-c/json_object.h"
extern int json_object_set_int64(struct json_object *obj, int64_t new_value);
# 846 "/app/subjects/json-c/json_object.h"
extern int json_object_set_uint64(struct json_object *obj, uint64_t new_value);
# 857 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_new_double(double d);
# 886 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_new_double_s(double d, const char *ds);
# 900 "/app/subjects/json-c/json_object.h"
extern int json_c_set_serialization_double_format(const char *double_format,
                                                       int global_or_thread);
# 922 "/app/subjects/json-c/json_object.h"
extern int json_object_double_to_json_string(struct json_object *jso, struct printbuf *pb,
                                                  int level, int flags);
# 948 "/app/subjects/json-c/json_object.h"
extern double json_object_get_double(const struct json_object *obj);
# 963 "/app/subjects/json-c/json_object.h"
extern int json_object_set_double(struct json_object *obj, double new_value);
# 975 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_new_string(const char *s);
# 987 "/app/subjects/json-c/json_object.h"
extern struct json_object *json_object_new_string_len(const char *s, const int len);
# 1005 "/app/subjects/json-c/json_object.h"
extern const char *json_object_get_string(struct json_object *obj);
# 1015 "/app/subjects/json-c/json_object.h"
extern int json_object_get_string_len(const struct json_object *obj);





extern int json_object_set_string(json_object *obj, const char *new_value);
# 1034 "/app/subjects/json-c/json_object.h"
extern int json_object_set_string_len(json_object *obj, const char *new_value, int len);





extern struct json_object *json_object_new_null(void);
# 1059 "/app/subjects/json-c/json_object.h"
extern int json_object_equal(struct json_object *obj1, struct json_object *obj2);
# 1075 "/app/subjects/json-c/json_object.h"
typedef int(json_c_shallow_copy_fn)(json_object *src, json_object *parent, const char *key,
                                    size_t index, json_object **dst);
# 1090 "/app/subjects/json-c/json_object.h"
extern json_c_shallow_copy_fn json_c_shallow_copy_default;
# 1111 "/app/subjects/json-c/json_object.h"
extern int json_object_deep_copy(struct json_object *src, struct json_object **dst,
                                      json_c_shallow_copy_fn *shallow_copy);
# 31 "/app/subjects/json-c/json_tokener.c" 2
# 1 "/app/subjects/json-c/json_object_private.h" 1
# 23 "/app/subjects/json-c/json_object_private.h"
struct json_object;




# 1 "/app/pipeline/preprocess/fake_libc_include/unistd.h" 1
# 29 "/app/subjects/json-c/json_object_private.h" 2
# 37 "/app/subjects/json-c/json_object_private.h"
typedef enum json_object_int_type
{
 json_object_int_type_int64,
 json_object_int_type_uint64
} json_object_int_type;

struct json_object
{
 enum json_type o_type;
 uint32_t _ref_count;
 json_object_to_json_string_fn *_to_json_string;
 struct printbuf *_pb;
 json_object_delete_fn *_user_delete;
 void *_userdata;


};

struct json_object_object
{
 struct json_object base;
 struct lh_table *c_object;
};
struct json_object_array
{
 struct json_object base;
 struct array_list *c_array;
};

struct json_object_boolean
{
 struct json_object base;
 json_bool c_boolean;
};
struct json_object_double
{
 struct json_object base;
 double c_double;
};
struct json_object_int
{
 struct json_object base;
 enum json_object_int_type cint_type;
 union
 {
  int64_t c_int64;
  uint64_t c_uint64;
 } cint;
};
struct json_object_string
{
 struct json_object base;
 ssize_t len;


 union
 {
  char idata[1];
  char *pdata;
 } c_string;
};

void _json_c_set_last_err(const char *err_fmt, ...);

extern const char *json_hex_chars;
# 32 "/app/subjects/json-c/json_tokener.c" 2
# 1 "/app/subjects/json-c/json_tokener.h" 1
# 20 "/app/subjects/json-c/json_tokener.h"
# 1 "/app/pipeline/preprocess/fake_libc_include/stddef.h" 1
# 21 "/app/subjects/json-c/json_tokener.h" 2





enum json_tokener_error
{
 json_tokener_success,
 json_tokener_continue,
 json_tokener_error_depth,
 json_tokener_error_parse_eof,
 json_tokener_error_parse_unexpected,
 json_tokener_error_parse_null,
 json_tokener_error_parse_boolean,
 json_tokener_error_parse_number,
 json_tokener_error_parse_array,
 json_tokener_error_parse_object_key_name,
 json_tokener_error_parse_object_key_sep,
 json_tokener_error_parse_object_value_sep,
 json_tokener_error_parse_string,
 json_tokener_error_parse_comment,
 json_tokener_error_parse_utf8_string,
 json_tokener_error_size,
 json_tokener_error_memory
};




enum json_tokener_state
{
 json_tokener_state_eatws,
 json_tokener_state_start,
 json_tokener_state_finish,
 json_tokener_state_null,
 json_tokener_state_comment_start,
 json_tokener_state_comment,
 json_tokener_state_comment_eol,
 json_tokener_state_comment_end,
 json_tokener_state_string,
 json_tokener_state_string_escape,
 json_tokener_state_escape_unicode,
 json_tokener_state_escape_unicode_need_escape,
 json_tokener_state_escape_unicode_need_u,
 json_tokener_state_boolean,
 json_tokener_state_number,
 json_tokener_state_array,
 json_tokener_state_array_add,
 json_tokener_state_array_sep,
 json_tokener_state_object_field_start,
 json_tokener_state_object_field,
 json_tokener_state_object_field_end,
 json_tokener_state_object_value,
 json_tokener_state_object_value_add,
 json_tokener_state_object_sep,
 json_tokener_state_array_after_sep,
 json_tokener_state_object_field_start_after_sep,
 json_tokener_state_inf
};




struct json_tokener_srec
{
 enum json_tokener_state state, saved_state;
 struct json_object *obj;
 struct json_object *current;
 char *obj_field_name;
};
# 101 "/app/subjects/json-c/json_tokener.h"
struct json_tokener
{



 char *str;
 struct printbuf *pb;
 int max_depth, depth, is_double, st_pos;



 int char_offset;



 enum json_tokener_error err;
 unsigned int ucs_char, high_surrogate;
 char quote_char;
 struct json_tokener_srec *stack;
 int flags;
};
# 137 "/app/subjects/json-c/json_tokener.h"
extern size_t json_tokener_get_parse_end(struct json_tokener *tok);




typedef struct json_tokener json_tokener;
# 187 "/app/subjects/json-c/json_tokener.h"
extern const char *json_tokener_error_desc(enum json_tokener_error jerr);
# 198 "/app/subjects/json-c/json_tokener.h"
extern enum json_tokener_error json_tokener_get_error(struct json_tokener *tok);






extern struct json_tokener *json_tokener_new(void);






extern struct json_tokener *json_tokener_new_ex(int depth);




extern void json_tokener_free(struct json_tokener *tok);





extern void json_tokener_reset(struct json_tokener *tok);







extern struct json_object *json_tokener_parse(const char *str);







extern struct json_object *json_tokener_parse_verbose(const char *str,
                                                           enum json_tokener_error *error);




extern void json_tokener_set_flags(struct json_tokener *tok, int flags);
# 323 "/app/subjects/json-c/json_tokener.h"
extern struct json_object *json_tokener_parse_ex(struct json_tokener *tok, const char *str,
                                                      int len);
# 33 "/app/subjects/json-c/json_tokener.c" 2
# 1 "/app/subjects/json-c/json_util.h" 1
# 42 "/app/subjects/json-c/json_util.h"
extern struct json_object *json_object_from_file(const char *filename);
# 58 "/app/subjects/json-c/json_util.h"
extern struct json_object *json_object_from_fd_ex(int fd, int depth);







extern struct json_object *json_object_from_fd(int fd);







extern int json_object_to_file(const char *filename, struct json_object *obj);







extern int json_object_to_file_ext(const char *filename, struct json_object *obj, int flags);
# 94 "/app/subjects/json-c/json_util.h"
extern int json_object_to_fd(int fd, struct json_object *obj, int flags);






extern const char *json_util_get_last_err(void);







extern int json_parse_int64(const char *buf, int64_t *retval);




extern int json_parse_uint64(const char *buf, uint64_t *retval);



extern int json_parse_double(const char *buf, double *retval);





extern const char *json_type_to_name(enum json_type o_type);
# 34 "/app/subjects/json-c/json_tokener.c" 2

# 1 "/app/subjects/json-c/strdup_compat.h" 1
# 36 "/app/subjects/json-c/json_tokener.c" 2


# 1 "/app/pipeline/preprocess/fake_libc_include/locale.h" 1
# 39 "/app/subjects/json-c/json_tokener.c" 2





# 1 "/app/pipeline/preprocess/fake_libc_include/strings.h" 1
# 45 "/app/subjects/json-c/json_tokener.c" 2
# 69 "/app/subjects/json-c/json_tokener.c"
static inline int is_ws_char(char c)
{
 return c == ' '
     || c == '\t'
     || c == '\n'
     || c == '\r';
}

static inline int is_hex_char(char c)
{
 return (c >= '0' && c <= '9')
     || (c >= 'A' && c <= 'F')
     || (c >= 'a' && c <= 'f');
}






static const char json_null_str[] = "null";
static const int json_null_str_len = sizeof(json_null_str) - 1;
static const char json_inf_str[] = "Infinity";

static const char json_inf_str_invert[] = "iNFINITY";
static const unsigned int json_inf_str_len = sizeof(json_inf_str) - 1;
static const char json_nan_str[] = "NaN";
static const int json_nan_str_len = sizeof(json_nan_str) - 1;
static const char json_true_str[] = "true";
static const int json_true_str_len = sizeof(json_true_str) - 1;
static const char json_false_str[] = "false";
static const int json_false_str_len = sizeof(json_false_str) - 1;


static const char *json_tokener_errors[] = {
 "success",
 "continue",
 "nesting too deep",
 "unexpected end of data",
 "unexpected character",
 "null expected",
 "boolean expected",
 "number expected",
 "array value separator ',' expected",
 "quoted object property name expected",
 "object property name separator ':' expected",
 "object value separator ',' expected",
 "invalid string sequence",
 "expected comment",
 "invalid utf-8 string",
 "buffer size overflow",
 "out of memory"
};






static json_bool json_tokener_validate_utf8(const char c, unsigned int *nBytes);

static int json_tokener_parse_double(const char *buf, int len, double *retval);

const char *json_tokener_error_desc(enum json_tokener_error jerr)
{
 int jerr_int = (int)jerr;
 if (jerr_int < 0 ||
     jerr_int >= (int)(sizeof(json_tokener_errors) / sizeof(json_tokener_errors[0])))
  return "Unknown error, "
         "invalid json_tokener_error value passed to json_tokener_error_desc()";
 return json_tokener_errors[jerr];
}

enum json_tokener_error json_tokener_get_error(struct json_tokener *tok)
{
 return tok->err;
}





static unsigned char utf8_replacement_char[3] = {0xEF, 0xBF, 0xBD};

struct json_tokener *json_tokener_new_ex(int depth)
{
 struct json_tokener *tok;

 if (depth < 1)
  return 0;

 tok = (struct json_tokener *)calloc(1, sizeof(struct json_tokener));
 if (!tok)
  return 0;
 tok->stack = (struct json_tokener_srec *)calloc(depth, sizeof(struct json_tokener_srec));
 if (!tok->stack)
 {
  free(tok);
  return 0;
 }
 tok->pb = printbuf_new();
 if (!tok->pb)
 {
  free(tok->stack);
  free(tok);
  return 0;
 }
 tok->max_depth = depth;
 json_tokener_reset(tok);
 return tok;
}

struct json_tokener *json_tokener_new(void)
{
 return json_tokener_new_ex(32);
}

void json_tokener_free(struct json_tokener *tok)
{
 if (!tok)
  return;
 json_tokener_reset(tok);
 if (tok->pb)
  printbuf_free(tok->pb);
 free(tok->stack);
 free(tok);
}

static void json_tokener_reset_level(struct json_tokener *tok, int depth)
{
 tok->stack[depth].state = json_tokener_state_eatws;
 tok->stack[depth].saved_state = json_tokener_state_start;
 json_object_put(tok->stack[depth].current);
 tok->stack[depth].current = 0;
 free(tok->stack[depth].obj_field_name);
 tok->stack[depth].obj_field_name = 0;
}

void json_tokener_reset(struct json_tokener *tok)
{
 int i;
 if (!tok)
  return;

 for (i = tok->depth; i >= 0; i--)
  json_tokener_reset_level(tok, i);
 tok->depth = 0;
 tok->err = json_tokener_success;
}

struct json_object *json_tokener_parse(const char *str)
{
 enum json_tokener_error jerr_ignored;
 struct json_object *obj;
 obj = json_tokener_parse_verbose(str, &jerr_ignored);
 return obj;
}

struct json_object *json_tokener_parse_verbose(const char *str, enum json_tokener_error *error)
{
 struct json_tokener *tok;
 struct json_object *obj;

 tok = json_tokener_new();
 if (!tok)
 {
  *error = json_tokener_error_memory;
  return 0;
 }
 obj = json_tokener_parse_ex(tok, str, -1);
 *error = tok->err;
 if (tok->err != json_tokener_success
# 249 "/app/subjects/json-c/json_tokener.c"
 )

 {
  if (obj != 0)
   json_object_put(obj);
  obj = 0;
 }

 json_tokener_free(tok);
 return obj;
}
# 317 "/app/subjects/json-c/json_tokener.c"
struct json_object *json_tokener_parse_ex(struct json_tokener *tok, const char *str, int len)
{
 struct json_object *obj = 0;
 char c = '\1';
 unsigned int nBytes = 0;
 unsigned int *nBytesp = &nBytes;


 locale_t oldlocale = uselocale(0);
 locale_t newloc;




 tok->char_offset = 0;
 tok->err = json_tokener_success;







 if ((len < -1) || (len == -1 && strlen(str) > INT32_MAX))
 {
  tok->err = json_tokener_error_size;
  return 0;
 }


 {

  locale_t duploc = duplocale(oldlocale);
  if (duploc == 0 && errno == ENOMEM)
  {
   tok->err = json_tokener_error_memory;
   return 0;
  }
  newloc = newlocale(LC_NUMERIC_MASK, "C", duploc);



  if (newloc == 0)
  {
   tok->err = json_tokener_error_memory;

   freelocale(duploc);

   return 0;
  }







  uselocale(newloc);
 }
# 393 "/app/subjects/json-c/json_tokener.c"
 while ((((tok)->char_offset == len) ? (((tok)->depth == 0 && tok->stack[tok->depth].state == json_tokener_state_eatws && tok->stack[tok->depth].saved_state == json_tokener_state_finish) ? (((tok)->err = json_tokener_success), 0) : (((tok)->err = json_tokener_continue), 0)) : (((tok->flags & 0x10) && (!json_tokener_validate_utf8(*str, nBytesp))) ? ((tok->err = json_tokener_error_parse_utf8_string), 0) : (((c) = *str), 1))))
 {

 redo_char:
  switch (tok->stack[tok->depth].state)
  {

  case json_tokener_state_eatws:

   while (is_ws_char(c))
   {
    if ((!(++(str), ((tok)->char_offset)++, c)) || (!(((tok)->char_offset == len) ? (((tok)->depth == 0 && tok->stack[tok->depth].state == json_tokener_state_eatws && tok->stack[tok->depth].saved_state == json_tokener_state_finish) ? (((tok)->err = json_tokener_success), 0) : (((tok)->err = json_tokener_continue), 0)) : (((tok->flags & 0x10) && (!json_tokener_validate_utf8(*str, nBytesp))) ? ((tok->err = json_tokener_error_parse_utf8_string), 0) : (((c) = *str), 1)))))
     goto out;
   }
   if (c == '/' && !(tok->flags & 0x01))
   {
    printbuf_reset(tok->pb);
    do { if (printbuf_memappend((tok->pb), (&c), (1)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
    tok->stack[tok->depth].state = json_tokener_state_comment_start;
   }
   else
   {
    tok->stack[tok->depth].state = tok->stack[tok->depth].saved_state;
    goto redo_char;
   }
   break;

  case json_tokener_state_start:
   switch (c)
   {
   case '{':
    tok->stack[tok->depth].state = json_tokener_state_eatws;
    tok->stack[tok->depth].saved_state = json_tokener_state_object_field_start;
    tok->stack[tok->depth].current = json_object_new_object();
    if (tok->stack[tok->depth].current == 0)
    {
     tok->err = json_tokener_error_memory;
     goto out;
    }
    break;
   case '[':
    tok->stack[tok->depth].state = json_tokener_state_eatws;
    tok->stack[tok->depth].saved_state = json_tokener_state_array;
    tok->stack[tok->depth].current = json_object_new_array();
    if (tok->stack[tok->depth].current == 0)
    {
     tok->err = json_tokener_error_memory;
     goto out;
    }
    break;
   case 'I':
   case 'i':
    tok->stack[tok->depth].state = json_tokener_state_inf;
    printbuf_reset(tok->pb);
    tok->st_pos = 0;
    goto redo_char;
   case 'N':
   case 'n':
    tok->stack[tok->depth].state = json_tokener_state_null;
    printbuf_reset(tok->pb);
    tok->st_pos = 0;
    goto redo_char;
   case '\'':
    if (tok->flags & 0x01)
    {

     tok->err = json_tokener_error_parse_unexpected;
     goto out;
    }

   case '"':
    tok->stack[tok->depth].state = json_tokener_state_string;
    printbuf_reset(tok->pb);
    tok->quote_char = c;
    break;
   case 'T':
   case 't':
   case 'F':
   case 'f':
    tok->stack[tok->depth].state = json_tokener_state_boolean;
    printbuf_reset(tok->pb);
    tok->st_pos = 0;
    goto redo_char;
   case '0':
   case '1':
   case '2':
   case '3':
   case '4':
   case '5':
   case '6':
   case '7':
   case '8':
   case '9':
   case '-':
    tok->stack[tok->depth].state = json_tokener_state_number;
    printbuf_reset(tok->pb);
    tok->is_double = 0;
    goto redo_char;
   default: tok->err = json_tokener_error_parse_unexpected; goto out;
   }
   break;

  case json_tokener_state_finish:
   if (tok->depth == 0)
    goto out;
   obj = json_object_get(tok->stack[tok->depth].current);
   json_tokener_reset_level(tok, tok->depth);
   tok->depth--;
   goto redo_char;

  case json_tokener_state_inf:
  {







   int is_negative = 0;


   while (tok->st_pos < (int)json_inf_str_len)
   {
    char inf_char = *str;
    if (inf_char != json_inf_str[tok->st_pos] &&
        ((tok->flags & 0x01) ||
          inf_char != json_inf_str_invert[tok->st_pos])
       )
    {
     tok->err = json_tokener_error_parse_unexpected;
     goto out;
    }
    tok->st_pos++;
    (void)(++(str), ((tok)->char_offset)++, c);
    if (!(((tok)->char_offset == len) ? (((tok)->depth == 0 && tok->stack[tok->depth].state == json_tokener_state_eatws && tok->stack[tok->depth].saved_state == json_tokener_state_finish) ? (((tok)->err = json_tokener_success), 0) : (((tok)->err = json_tokener_continue), 0)) : (((tok->flags & 0x10) && (!json_tokener_validate_utf8(*str, nBytesp))) ? ((tok->err = json_tokener_error_parse_utf8_string), 0) : (((c) = *str), 1))))
    {

     goto out;
    }
   }




   if (((tok->pb)->bpos) > 0 && *(tok->pb->buf) == '-')
   {
    is_negative = 1;
   }
   tok->stack[tok->depth].current = json_object_new_double(is_negative ? -INFINITY : INFINITY);
   if (tok->stack[tok->depth].current == 0)
   {
    tok->err = json_tokener_error_memory;
    goto out;
   }
   tok->stack[tok->depth].saved_state = json_tokener_state_finish;
   tok->stack[tok->depth].state = json_tokener_state_eatws;
   goto redo_char;
  }
  break;
  case json_tokener_state_null:
  {
   int size;
   int size_nan;
   do { if (printbuf_memappend((tok->pb), (&c), (1)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
   size = ((tok->st_pos + 1) < (json_null_str_len) ? (tok->st_pos + 1) : (json_null_str_len));
   size_nan = ((tok->st_pos + 1) < (json_nan_str_len) ? (tok->st_pos + 1) : (json_nan_str_len));
   if ((!(tok->flags & 0x01) &&
        strncasecmp(json_null_str, tok->pb->buf, size) == 0) ||
       (strncmp(json_null_str, tok->pb->buf, size) == 0))
   {
    if (tok->st_pos == json_null_str_len)
    {
     tok->stack[tok->depth].current = 0;
     tok->stack[tok->depth].saved_state = json_tokener_state_finish;
     tok->stack[tok->depth].state = json_tokener_state_eatws;
     goto redo_char;
    }
   }
   else if ((!(tok->flags & 0x01) &&
             strncasecmp(json_nan_str, tok->pb->buf, size_nan) == 0) ||
            (strncmp(json_nan_str, tok->pb->buf, size_nan) == 0))
   {
    if (tok->st_pos == json_nan_str_len)
    {
     tok->stack[tok->depth].current = json_object_new_double(nan(""));
     if (tok->stack[tok->depth].current == 0)
     {
      tok->err = json_tokener_error_memory;
      goto out;
     }
     tok->stack[tok->depth].saved_state = json_tokener_state_finish;
     tok->stack[tok->depth].state = json_tokener_state_eatws;
     goto redo_char;
    }
   }
   else
   {
    tok->err = json_tokener_error_parse_null;
    goto out;
   }
   tok->st_pos++;
  }
  break;

  case json_tokener_state_comment_start:
   if (c == '*')
   {
    tok->stack[tok->depth].state = json_tokener_state_comment;
   }
   else if (c == '/')
   {
    tok->stack[tok->depth].state = json_tokener_state_comment_eol;
   }
   else
   {
    tok->err = json_tokener_error_parse_comment;
    goto out;
   }
   do { if (printbuf_memappend((tok->pb), (&c), (1)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
   break;

  case json_tokener_state_comment:
  {

   const char *case_start = str;
   while (c != '*')
   {
    if (!(++(str), ((tok)->char_offset)++, c) || !(((tok)->char_offset == len) ? (((tok)->depth == 0 && tok->stack[tok->depth].state == json_tokener_state_eatws && tok->stack[tok->depth].saved_state == json_tokener_state_finish) ? (((tok)->err = json_tokener_success), 0) : (((tok)->err = json_tokener_continue), 0)) : (((tok->flags & 0x10) && (!json_tokener_validate_utf8(*str, nBytesp))) ? ((tok->err = json_tokener_error_parse_utf8_string), 0) : (((c) = *str), 1))))
    {
     do { if (printbuf_memappend((tok->pb), (case_start), (str - case_start)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0)
                                                 ;
     goto out;
    }
   }
   do { if (printbuf_memappend((tok->pb), (case_start), (1 + str - case_start)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
   tok->stack[tok->depth].state = json_tokener_state_comment_end;
  }
  break;

  case json_tokener_state_comment_eol:
  {

   const char *case_start = str;
   while (c != '\n')
   {
    if (!(++(str), ((tok)->char_offset)++, c) || !(((tok)->char_offset == len) ? (((tok)->depth == 0 && tok->stack[tok->depth].state == json_tokener_state_eatws && tok->stack[tok->depth].saved_state == json_tokener_state_finish) ? (((tok)->err = json_tokener_success), 0) : (((tok)->err = json_tokener_continue), 0)) : (((tok->flags & 0x10) && (!json_tokener_validate_utf8(*str, nBytesp))) ? ((tok->err = json_tokener_error_parse_utf8_string), 0) : (((c) = *str), 1))))
    {
     do { if (printbuf_memappend((tok->pb), (case_start), (str - case_start)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0)
                                                 ;
     goto out;
    }
   }
   do { if (printbuf_memappend((tok->pb), (case_start), (str - case_start)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
   if (0) mc_debug("json_tokener_comment: %s\n", tok->pb->buf);
   tok->stack[tok->depth].state = json_tokener_state_eatws;
  }
  break;

  case json_tokener_state_comment_end:
   do { if (printbuf_memappend((tok->pb), (&c), (1)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
   if (c == '/')
   {
    if (0) mc_debug("json_tokener_comment: %s\n", tok->pb->buf);
    tok->stack[tok->depth].state = json_tokener_state_eatws;
   }
   else
   {
    tok->stack[tok->depth].state = json_tokener_state_comment;
   }
   break;

  case json_tokener_state_string:
  {

   const char *case_start = str;
   while (1)
   {
    if (c == tok->quote_char)
    {
     do { if (printbuf_memappend((tok->pb), (case_start), (str - case_start)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0)
                                                 ;
     tok->stack[tok->depth].current =
         json_object_new_string_len(tok->pb->buf, tok->pb->bpos);
     if (tok->stack[tok->depth].current == 0)
     {
      tok->err = json_tokener_error_memory;
      goto out;
     }
     tok->stack[tok->depth].saved_state = json_tokener_state_finish;
     tok->stack[tok->depth].state = json_tokener_state_eatws;
     break;
    }
    else if (c == '\\')
    {
     do { if (printbuf_memappend((tok->pb), (case_start), (str - case_start)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0)
                                                 ;
     tok->stack[tok->depth].saved_state = json_tokener_state_string;
     tok->stack[tok->depth].state = json_tokener_state_string_escape;
     break;
    }
    else if ((tok->flags & 0x01) && (unsigned char)c <= 0x1f)
    {

     tok->err = json_tokener_error_parse_string;
     goto out;
    }
    if (!(++(str), ((tok)->char_offset)++, c) || !(((tok)->char_offset == len) ? (((tok)->depth == 0 && tok->stack[tok->depth].state == json_tokener_state_eatws && tok->stack[tok->depth].saved_state == json_tokener_state_finish) ? (((tok)->err = json_tokener_success), 0) : (((tok)->err = json_tokener_continue), 0)) : (((tok->flags & 0x10) && (!json_tokener_validate_utf8(*str, nBytesp))) ? ((tok->err = json_tokener_error_parse_utf8_string), 0) : (((c) = *str), 1))))
    {
     do { if (printbuf_memappend((tok->pb), (case_start), (str - case_start)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0)
                                                 ;
     goto out;
    }
   }
  }
  break;

  case json_tokener_state_string_escape:
   switch (c)
   {
   case '"':
   case '\\':
   case '/':
    do { if (printbuf_memappend((tok->pb), (&c), (1)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
    tok->stack[tok->depth].state = tok->stack[tok->depth].saved_state;
    break;
   case 'b':
   case 'n':
   case 'r':
   case 't':
   case 'f':
    if (c == 'b')
     do { if (printbuf_memappend((tok->pb), ("\b"), (1)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
    else if (c == 'n')
     do { if (printbuf_memappend((tok->pb), ("\n"), (1)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
    else if (c == 'r')
     do { if (printbuf_memappend((tok->pb), ("\r"), (1)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
    else if (c == 't')
     do { if (printbuf_memappend((tok->pb), ("\t"), (1)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
    else if (c == 'f')
     do { if (printbuf_memappend((tok->pb), ("\f"), (1)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
    tok->stack[tok->depth].state = tok->stack[tok->depth].saved_state;
    break;
   case 'u':
    tok->ucs_char = 0;
    tok->st_pos = 0;
    tok->stack[tok->depth].state = json_tokener_state_escape_unicode;
    break;
   default: tok->err = json_tokener_error_parse_string; goto out;
   }
   break;



  case json_tokener_state_escape_unicode:
  {

   while (1)
   {
    if (!c || !is_hex_char(c))
    {
     tok->err = json_tokener_error_parse_string;
     goto out;
    }
    tok->ucs_char |=
        ((unsigned int)(((c) <= '9') ? (c) - '0' : ((c)&7) + 9) << ((3 - tok->st_pos) * 4));
    tok->st_pos++;
    if (tok->st_pos >= 4)
     break;

    (void)(++(str), ((tok)->char_offset)++, c);
    if (!(((tok)->char_offset == len) ? (((tok)->depth == 0 && tok->stack[tok->depth].state == json_tokener_state_eatws && tok->stack[tok->depth].saved_state == json_tokener_state_finish) ? (((tok)->err = json_tokener_success), 0) : (((tok)->err = json_tokener_continue), 0)) : (((tok->flags & 0x10) && (!json_tokener_validate_utf8(*str, nBytesp))) ? ((tok->err = json_tokener_error_parse_utf8_string), 0) : (((c) = *str), 1))))
    {






     goto out;
    }
   }
   tok->st_pos = 0;




   if (tok->high_surrogate)
   {
    if ((((tok->ucs_char)&0xFC00) == 0xDC00))
    {

     tok->ucs_char = ((((tok->high_surrogate)&0x3FF) << 10) + ((tok->ucs_char)&0x3FF) + 0x10000)
                                                         ;
    }
    else
    {



     do { if (printbuf_memappend((tok->pb), ((char *)utf8_replacement_char), (3)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0)
                                                                 ;
    }
    tok->high_surrogate = 0;
   }

   if (tok->ucs_char < 0x80)
   {
    unsigned char unescaped_utf[1];
    unescaped_utf[0] = tok->ucs_char;
    do { if (printbuf_memappend((tok->pb), ((char *)unescaped_utf), (1)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
   }
   else if (tok->ucs_char < 0x800)
   {
    unsigned char unescaped_utf[2];
    unescaped_utf[0] = 0xc0 | (tok->ucs_char >> 6);
    unescaped_utf[1] = 0x80 | (tok->ucs_char & 0x3f);
    do { if (printbuf_memappend((tok->pb), ((char *)unescaped_utf), (2)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
   }
   else if ((((tok->ucs_char)&0xFC00) == 0xD800))
   {
# 828 "/app/subjects/json-c/json_tokener.c"
    tok->high_surrogate = tok->ucs_char;
    tok->ucs_char = 0;
    tok->stack[tok->depth].state = json_tokener_state_escape_unicode_need_escape;
    break;
   }
   else if ((((tok->ucs_char)&0xFC00) == 0xDC00))
   {

    do { if (printbuf_memappend((tok->pb), ((char *)utf8_replacement_char), (3)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
   }
   else if (tok->ucs_char < 0x10000)
   {
    unsigned char unescaped_utf[3];
    unescaped_utf[0] = 0xe0 | (tok->ucs_char >> 12);
    unescaped_utf[1] = 0x80 | ((tok->ucs_char >> 6) & 0x3f);
    unescaped_utf[2] = 0x80 | (tok->ucs_char & 0x3f);
    do { if (printbuf_memappend((tok->pb), ((char *)unescaped_utf), (3)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
   }
   else if (tok->ucs_char < 0x110000)
   {
    unsigned char unescaped_utf[4];
    unescaped_utf[0] = 0xf0 | ((tok->ucs_char >> 18) & 0x07);
    unescaped_utf[1] = 0x80 | ((tok->ucs_char >> 12) & 0x3f);
    unescaped_utf[2] = 0x80 | ((tok->ucs_char >> 6) & 0x3f);
    unescaped_utf[3] = 0x80 | (tok->ucs_char & 0x3f);
    do { if (printbuf_memappend((tok->pb), ((char *)unescaped_utf), (4)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
   }
   else
   {

    do { if (printbuf_memappend((tok->pb), ((char *)utf8_replacement_char), (3)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
   }
   tok->stack[tok->depth].state = tok->stack[tok->depth].saved_state;
  }
  break;

  case json_tokener_state_escape_unicode_need_escape:


   if (!c || c != '\\')
   {




    do { if (printbuf_memappend((tok->pb), ((char *)utf8_replacement_char), (3)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
    tok->high_surrogate = 0;
    tok->ucs_char = 0;
    tok->st_pos = 0;
    tok->stack[tok->depth].state = tok->stack[tok->depth].saved_state;
    goto redo_char;
   }
   tok->stack[tok->depth].state = json_tokener_state_escape_unicode_need_u;
   break;

  case json_tokener_state_escape_unicode_need_u:

   if (!c || c != 'u')
   {





    do { if (printbuf_memappend((tok->pb), ((char *)utf8_replacement_char), (3)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
    tok->high_surrogate = 0;
    tok->ucs_char = 0;
    tok->st_pos = 0;
    tok->stack[tok->depth].state = json_tokener_state_string_escape;
    goto redo_char;
   }
   tok->stack[tok->depth].state = json_tokener_state_escape_unicode;
   break;



  case json_tokener_state_boolean:
  {
   int size1, size2;
   do { if (printbuf_memappend((tok->pb), (&c), (1)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
   size1 = ((tok->st_pos + 1) < (json_true_str_len) ? (tok->st_pos + 1) : (json_true_str_len));
   size2 = ((tok->st_pos + 1) < (json_false_str_len) ? (tok->st_pos + 1) : (json_false_str_len));
   if ((!(tok->flags & 0x01) &&
        strncasecmp(json_true_str, tok->pb->buf, size1) == 0) ||
       (strncmp(json_true_str, tok->pb->buf, size1) == 0))
   {
    if (tok->st_pos == json_true_str_len)
    {
     tok->stack[tok->depth].current = json_object_new_boolean(1);
     if (tok->stack[tok->depth].current == 0)
     {
      tok->err = json_tokener_error_memory;
      goto out;
     }
     tok->stack[tok->depth].saved_state = json_tokener_state_finish;
     tok->stack[tok->depth].state = json_tokener_state_eatws;
     goto redo_char;
    }
   }
   else if ((!(tok->flags & 0x01) &&
             strncasecmp(json_false_str, tok->pb->buf, size2) == 0) ||
            (strncmp(json_false_str, tok->pb->buf, size2) == 0))
   {
    if (tok->st_pos == json_false_str_len)
    {
     tok->stack[tok->depth].current = json_object_new_boolean(0);
     if (tok->stack[tok->depth].current == 0)
     {
      tok->err = json_tokener_error_memory;
      goto out;
     }
     tok->stack[tok->depth].saved_state = json_tokener_state_finish;
     tok->stack[tok->depth].state = json_tokener_state_eatws;
     goto redo_char;
    }
   }
   else
   {
    tok->err = json_tokener_error_parse_boolean;
    goto out;
   }
   tok->st_pos++;
  }
  break;

  case json_tokener_state_number:
  {

   const char *case_start = str;
   int case_len = 0;
   int is_exponent = 0;
   int neg_sign_ok = 1;
   int pos_sign_ok = 0;
   if (((tok->pb)->bpos) > 0)
   {



    char *e_loc = strchr(tok->pb->buf, 'e');
    if (!e_loc)
     e_loc = strchr(tok->pb->buf, 'E');
    if (e_loc)
    {
     char *last_saved_char =
         &tok->pb->buf[((tok->pb)->bpos) - 1];
     is_exponent = 1;
     pos_sign_ok = neg_sign_ok = 1;

     if (e_loc != last_saved_char)
     {
      neg_sign_ok = 0;
      pos_sign_ok = 0;
     }

    }
   }

   while (c && ((c >= '0' && c <= '9') ||
                (!is_exponent && (c == 'e' || c == 'E')) ||
                (neg_sign_ok && c == '-') || (pos_sign_ok && c == '+') ||
                (!tok->is_double && c == '.')))
   {
    pos_sign_ok = neg_sign_ok = 0;
    ++case_len;







    switch (c)
    {
    case '.':
     tok->is_double = 1;
     pos_sign_ok = 1;
     neg_sign_ok = 1;
     break;
    case 'e':
    case 'E':
     is_exponent = 1;
     tok->is_double = 1;

     pos_sign_ok = neg_sign_ok = 1;
     break;
    default: break;
    }

    if (!(++(str), ((tok)->char_offset)++, c) || !(((tok)->char_offset == len) ? (((tok)->depth == 0 && tok->stack[tok->depth].state == json_tokener_state_eatws && tok->stack[tok->depth].saved_state == json_tokener_state_finish) ? (((tok)->err = json_tokener_success), 0) : (((tok)->err = json_tokener_continue), 0)) : (((tok->flags & 0x10) && (!json_tokener_validate_utf8(*str, nBytesp))) ? ((tok->err = json_tokener_error_parse_utf8_string), 0) : (((c) = *str), 1))))
    {
     do { if (printbuf_memappend((tok->pb), (case_start), (case_len)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);
     goto out;
    }
   }
# 1030 "/app/subjects/json-c/json_tokener.c"
   if (tok->depth > 0 && c != ',' && c != ']' && c != '}' && c != '/' &&
       c != 'I' && c != 'i' && !is_ws_char(c))
   {
    tok->err = json_tokener_error_parse_number;
    goto out;
   }
   if (case_len > 0)
    do { if (printbuf_memappend((tok->pb), (case_start), (case_len)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0);


   if (tok->pb->buf[0] == '-' && case_len <= 1 && (c == 'i' || c == 'I'))
   {
    tok->stack[tok->depth].state = json_tokener_state_inf;
    tok->st_pos = 0;
    goto redo_char;
   }
   if (tok->is_double && !(tok->flags & 0x01))
   {


    while (((tok->pb)->bpos) > 1)
    {
     char last_char = tok->pb->buf[((tok->pb)->bpos) - 1];
     if (last_char != 'e' && last_char != 'E' &&
         last_char != '-' && last_char != '+')
     {
      break;
     }
     tok->pb->buf[((tok->pb)->bpos) - 1] = '\0';
     ((tok->pb)->bpos)--;
    }
   }
  }
   {
    int64_t num64;
    uint64_t numuint64;
    double numd;
    if (!tok->is_double && tok->pb->buf[0] == '-' &&
        json_parse_int64(tok->pb->buf, &num64) == 0)
    {
     if (errno == ERANGE && (tok->flags & 0x01))
     {
      tok->err = json_tokener_error_parse_number;
      goto out;
     }
     tok->stack[tok->depth].current = json_object_new_int64(num64);
     if (tok->stack[tok->depth].current == 0)
     {
      tok->err = json_tokener_error_memory;
      goto out;
     }
    }
    else if (!tok->is_double && tok->pb->buf[0] != '-' &&
             json_parse_uint64(tok->pb->buf, &numuint64) == 0)
    {
     if (errno == ERANGE && (tok->flags & 0x01))
     {
      tok->err = json_tokener_error_parse_number;
      goto out;
     }
     if (numuint64 && tok->pb->buf[0] == '0' &&
         (tok->flags & 0x01))
     {
      tok->err = json_tokener_error_parse_number;
      goto out;
     }
     if (numuint64 <= INT64_MAX)
     {
      num64 = (uint64_t)numuint64;
      tok->stack[tok->depth].current = json_object_new_int64(num64);
      if (tok->stack[tok->depth].current == 0)
      {
       tok->err = json_tokener_error_memory;
       goto out;
      }
     }
     else
     {
      tok->stack[tok->depth].current = json_object_new_uint64(numuint64);
      if (tok->stack[tok->depth].current == 0)
      {
       tok->err = json_tokener_error_memory;
       goto out;
      }
     }
    }
    else if (tok->is_double &&
             json_tokener_parse_double(
                 tok->pb->buf, ((tok->pb)->bpos), &numd) == 0)
    {
     tok->stack[tok->depth].current = json_object_new_double_s(numd, tok->pb->buf);
     if (tok->stack[tok->depth].current == 0)
     {
      tok->err = json_tokener_error_memory;
      goto out;
     }
    }
    else
    {
     tok->err = json_tokener_error_parse_number;
     goto out;
    }
    tok->stack[tok->depth].saved_state = json_tokener_state_finish;
    tok->stack[tok->depth].state = json_tokener_state_eatws;
    goto redo_char;
   }
   break;

  case json_tokener_state_array_after_sep:
  case json_tokener_state_array:
   if (c == ']')
   {

    json_object_array_shrink(tok->stack[tok->depth].current, 0);

    if (tok->stack[tok->depth].state == json_tokener_state_array_after_sep &&
        (tok->flags & 0x01))
    {
     tok->err = json_tokener_error_parse_unexpected;
     goto out;
    }
    tok->stack[tok->depth].saved_state = json_tokener_state_finish;
    tok->stack[tok->depth].state = json_tokener_state_eatws;
   }
   else
   {
    if (tok->depth >= tok->max_depth - 1)
    {
     tok->err = json_tokener_error_depth;
     goto out;
    }
    tok->stack[tok->depth].state = json_tokener_state_array_add;
    tok->depth++;
    json_tokener_reset_level(tok, tok->depth);
    goto redo_char;
   }
   break;

  case json_tokener_state_array_add:
   if (json_object_array_add(tok->stack[tok->depth].current, obj) != 0)
   {
    tok->err = json_tokener_error_memory;
    goto out;
   }
   tok->stack[tok->depth].saved_state = json_tokener_state_array_sep;
   tok->stack[tok->depth].state = json_tokener_state_eatws;
   goto redo_char;

  case json_tokener_state_array_sep:
   if (c == ']')
   {

    json_object_array_shrink(tok->stack[tok->depth].current, 0);

    tok->stack[tok->depth].saved_state = json_tokener_state_finish;
    tok->stack[tok->depth].state = json_tokener_state_eatws;
   }
   else if (c == ',')
   {
    tok->stack[tok->depth].saved_state = json_tokener_state_array_after_sep;
    tok->stack[tok->depth].state = json_tokener_state_eatws;
   }
   else
   {
    tok->err = json_tokener_error_parse_array;
    goto out;
   }
   break;

  case json_tokener_state_object_field_start:
  case json_tokener_state_object_field_start_after_sep:
   if (c == '}')
   {
    if (tok->stack[tok->depth].state == json_tokener_state_object_field_start_after_sep &&
        (tok->flags & 0x01))
    {
     tok->err = json_tokener_error_parse_unexpected;
     goto out;
    }
    tok->stack[tok->depth].saved_state = json_tokener_state_finish;
    tok->stack[tok->depth].state = json_tokener_state_eatws;
   }
   else if (c == '"' || c == '\'')
   {
    tok->quote_char = c;
    printbuf_reset(tok->pb);
    tok->stack[tok->depth].state = json_tokener_state_object_field;
   }
   else
   {
    tok->err = json_tokener_error_parse_object_key_name;
    goto out;
   }
   break;

  case json_tokener_state_object_field:
  {

   const char *case_start = str;
   while (1)
   {
    if (c == tok->quote_char)
    {
     do { if (printbuf_memappend((tok->pb), (case_start), (str - case_start)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0)
                                                 ;
     tok->stack[tok->depth].obj_field_name = strdup(tok->pb->buf);
     if (tok->stack[tok->depth].obj_field_name == 0)
     {
      tok->err = json_tokener_error_memory;
      goto out;
     }
     tok->stack[tok->depth].saved_state = json_tokener_state_object_field_end;
     tok->stack[tok->depth].state = json_tokener_state_eatws;
     break;
    }
    else if (c == '\\')
    {
     do { if (printbuf_memappend((tok->pb), (case_start), (str - case_start)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0)
                                                 ;
     tok->stack[tok->depth].saved_state = json_tokener_state_object_field;
     tok->stack[tok->depth].state = json_tokener_state_string_escape;
     break;
    }
    if (!(++(str), ((tok)->char_offset)++, c) || !(((tok)->char_offset == len) ? (((tok)->depth == 0 && tok->stack[tok->depth].state == json_tokener_state_eatws && tok->stack[tok->depth].saved_state == json_tokener_state_finish) ? (((tok)->err = json_tokener_success), 0) : (((tok)->err = json_tokener_continue), 0)) : (((tok->flags & 0x10) && (!json_tokener_validate_utf8(*str, nBytesp))) ? ((tok->err = json_tokener_error_parse_utf8_string), 0) : (((c) = *str), 1))))
    {
     do { if (printbuf_memappend((tok->pb), (case_start), (str - case_start)) < 0) { tok->err = json_tokener_error_memory; goto out; } } while (0)
                                                 ;
     goto out;
    }
   }
  }
  break;

  case json_tokener_state_object_field_end:
   if (c == ':')
   {
    tok->stack[tok->depth].saved_state = json_tokener_state_object_value;
    tok->stack[tok->depth].state = json_tokener_state_eatws;
   }
   else
   {
    tok->err = json_tokener_error_parse_object_key_sep;
    goto out;
   }
   break;

  case json_tokener_state_object_value:
   if (tok->depth >= tok->max_depth - 1)
   {
    tok->err = json_tokener_error_depth;
    goto out;
   }
   tok->stack[tok->depth].state = json_tokener_state_object_value_add;
   tok->depth++;
   json_tokener_reset_level(tok, tok->depth);
   goto redo_char;

  case json_tokener_state_object_value_add:
   if (json_object_object_add(tok->stack[tok->depth].current, tok->stack[tok->depth].obj_field_name, obj) != 0)
   {
    tok->err = json_tokener_error_memory;
    goto out;
   }
   free(tok->stack[tok->depth].obj_field_name);
   tok->stack[tok->depth].obj_field_name = 0;
   tok->stack[tok->depth].saved_state = json_tokener_state_object_sep;
   tok->stack[tok->depth].state = json_tokener_state_eatws;
   goto redo_char;

  case json_tokener_state_object_sep:

   if (c == '}')
   {
    tok->stack[tok->depth].saved_state = json_tokener_state_finish;
    tok->stack[tok->depth].state = json_tokener_state_eatws;
   }
   else if (c == ',')
   {
    tok->stack[tok->depth].saved_state = json_tokener_state_object_field_start_after_sep;
    tok->stack[tok->depth].state = json_tokener_state_eatws;
   }
   else
   {
    tok->err = json_tokener_error_parse_object_value_sep;
    goto out;
   }
   break;
  }
  (void)(++(str), ((tok)->char_offset)++, c);
  if (!c)
   break;
 }

out:
 if ((tok->flags & 0x10) && (nBytes != 0))
 {
  tok->err = json_tokener_error_parse_utf8_string;
 }
 if (c && (tok->stack[tok->depth].state == json_tokener_state_finish) && (tok->depth == 0) &&
     (tok->flags & (0x01 | 0x02)) ==
         0x01)
 {

  tok->err = json_tokener_error_parse_unexpected;
 }
 if (!c)
 {

  if (tok->stack[tok->depth].state != json_tokener_state_finish && tok->stack[tok->depth].saved_state != json_tokener_state_finish)
   tok->err = json_tokener_error_parse_eof;
 }


 uselocale(oldlocale);
 freelocale(newloc);





 if (tok->err == json_tokener_success)
 {
  json_object *ret = json_object_get(tok->stack[tok->depth].current);
  int ii;


  for (ii = tok->depth; ii >= 0; ii--)
   json_tokener_reset_level(tok, ii);
  return ret;
 }

 if (0) mc_debug("json_tokener_parse_ex: error %s at offset %d\n", json_tokener_errors[tok->err], tok->char_offset)
                           ;
 return 0;
}

static json_bool json_tokener_validate_utf8(const char c, unsigned int *nBytes)
{
 unsigned char chr = c;
 if (*nBytes == 0)
 {
  if (chr >= 0x80)
  {
   if ((chr & 0xe0) == 0xc0)
    *nBytes = 1;
   else if ((chr & 0xf0) == 0xe0)
    *nBytes = 2;
   else if ((chr & 0xf8) == 0xf0)
    *nBytes = 3;
   else
    return 0;
  }
 }
 else
 {
  if ((chr & 0xC0) != 0x80)
   return 0;
  (*nBytes)--;
 }
 return 1;
}

void json_tokener_set_flags(struct json_tokener *tok, int flags)
{
 tok->flags = flags;
}

size_t json_tokener_get_parse_end(struct json_tokener *tok)
{
 assert(tok->char_offset >= 0);
 return (size_t)tok->char_offset;
}

static int json_tokener_parse_double(const char *buf, int len, double *retval)
{
 char *end;
 *retval = strtod(buf, &end);
 if (buf + len == end)
  return 0;
 return 1;
}
