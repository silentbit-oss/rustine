# 0 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c"
# 11 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optipng.h" 1
# 14 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optipng.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/bitset.h" 1
# 14 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/bitset.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/limits.h" 1
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/limits.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef unsigned chtype;
typedef chtype attr_t;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/limits.h" 2
# 15 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/bitset.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stddef.h" 1
# 16 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/bitset.h" 2
# 26 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/bitset.h"
typedef unsigned int opng_bitset_t;
# 45 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/bitset.h"
enum
{
    OPNG_BITSET_ELT_MIN = 0,
    OPNG_BITSET_ELT_MAX = (int)((sizeof(opng_bitset_t) * 8) - 1)
};
# 174 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/bitset.h"
unsigned int
opng_bitset_count(opng_bitset_t set);







int
opng_bitset_find_first(opng_bitset_t set);







int
opng_bitset_find_next(opng_bitset_t set, int elt);







int
opng_bitset_find_last(opng_bitset_t set);







int
opng_bitset_find_prev(opng_bitset_t set, int elt);
# 241 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/bitset.h"
int
opng_strparse_rangeset_to_bitset(opng_bitset_t *out_set,
                                 const char *rangeset_str,
                                 opng_bitset_t mask_set);
# 253 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/bitset.h"
size_t
opng_strformat_bitset_as_rangeset(char *out_buf,
                                  size_t out_buf_size,
                                  opng_bitset_t bitset);
# 15 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optipng.h" 2
# 25 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optipng.h"
struct opng_options
{

    int backup;
    int clobber;
    int debug;
    int fix;
    int force;
    int full;
    int preserve;
    int quiet;
    int simulate;
    int verbose;
    const char *out_name;
    const char *dir_name;
    const char *log_name;


    int interlace;
    int nb, nc, np, nz;
    int optim_level;
    opng_bitset_t compr_level_set;
    opng_bitset_t mem_level_set;
    opng_bitset_t strategy_set;
    opng_bitset_t filter_set;
    int window_bits;


    int snip;
    int strip_all;
};





struct opng_ui
{
    void (*printf_fn)(const char *fmt, ...);
    void (*print_cntrl_fn)(int cntrl_code);
    void (*progress_fn)(unsigned long current_step, unsigned long total_steps);
    void (*panic_fn)(const char *msg);
};





int opng_initialize(const struct opng_options *options,
                    const struct opng_ui *ui);




int opng_optimize(const char *infile_name);




int opng_finalize(void);
# 12 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/proginfo.h" 1
# 13 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2

# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/limits.h" 1
# 15 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdarg.h" 1
# 16 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 1
# 17 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 18 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/string.h" 1
# 19 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2

# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/opngreduc/opngreduc.h" 1
# 12 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/opngreduc/opngreduc.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h" 1
# 330 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pnglibconf.h" 1
# 331 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h" 2




# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h" 1
# 31 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/limits.h" 1
# 32 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stddef.h" 1
# 33 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h" 2
# 46 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 1
# 47 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h" 2
# 481 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h"
   typedef unsigned char png_byte;







   typedef short png_int_16;







   typedef unsigned short png_uint_16;





   typedef int png_int_32;







   typedef unsigned int png_uint_32;
# 523 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h"
typedef size_t png_size_t;
typedef ptrdiff_t png_ptrdiff_t;
# 557 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h"
   typedef size_t png_alloc_size_t;
# 574 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h"
typedef png_int_32 png_fixed_point;


typedef void * png_voidp;
typedef const void * png_const_voidp;
typedef png_byte * png_bytep;
typedef const png_byte * png_const_bytep;
typedef png_uint_32 * png_uint_32p;
typedef const png_uint_32 * png_const_uint_32p;
typedef png_int_32 * png_int_32p;
typedef const png_int_32 * png_const_int_32p;
typedef png_uint_16 * png_uint_16p;
typedef const png_uint_16 * png_const_uint_16p;
typedef png_int_16 * png_int_16p;
typedef const png_int_16 * png_const_int_16p;
typedef char * png_charp;
typedef const char * png_const_charp;
typedef png_fixed_point * png_fixed_point_p;
typedef const png_fixed_point * png_const_fixed_point_p;
typedef size_t * png_size_tp;
typedef const size_t * png_const_size_tp;


typedef FILE * png_FILE_p;
# 606 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h"
typedef png_byte * * png_bytepp;
typedef png_uint_32 * * png_uint_32pp;
typedef png_int_32 * * png_int_32pp;
typedef png_uint_16 * * png_uint_16pp;
typedef png_int_16 * * png_int_16pp;
typedef const char * * png_const_charpp;
typedef char * * png_charpp;
typedef png_fixed_point * * png_fixed_point_pp;





typedef char * * * png_charppp;
# 336 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h" 2
# 431 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
typedef char* png_libpng_version_1_6_40;







typedef struct png_struct_def png_struct;
typedef const png_struct * png_const_structp;
typedef png_struct * png_structp;
typedef png_struct * * png_structpp;
# 453 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
typedef struct png_info_def png_info;
typedef png_info * png_infop;
typedef const png_info * png_const_infop;
typedef png_info * * png_infopp;
# 469 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
typedef png_struct * png_structrp;
typedef const png_struct * png_const_structrp;
typedef png_info * png_inforp;
typedef const png_info * png_const_inforp;





typedef struct png_color_struct
{
   png_byte red;
   png_byte green;
   png_byte blue;
} png_color;
typedef png_color * png_colorp;
typedef const png_color * png_const_colorp;
typedef png_color * * png_colorpp;

typedef struct png_color_16_struct
{
   png_byte index;
   png_uint_16 red;
   png_uint_16 green;
   png_uint_16 blue;
   png_uint_16 gray;
} png_color_16;
typedef png_color_16 * png_color_16p;
typedef const png_color_16 * png_const_color_16p;
typedef png_color_16 * * png_color_16pp;

typedef struct png_color_8_struct
{
   png_byte red;
   png_byte green;
   png_byte blue;
   png_byte gray;
   png_byte alpha;
} png_color_8;
typedef png_color_8 * png_color_8p;
typedef const png_color_8 * png_const_color_8p;
typedef png_color_8 * * png_color_8pp;





typedef struct png_sPLT_entry_struct
{
   png_uint_16 red;
   png_uint_16 green;
   png_uint_16 blue;
   png_uint_16 alpha;
   png_uint_16 frequency;
} png_sPLT_entry;
typedef png_sPLT_entry * png_sPLT_entryp;
typedef const png_sPLT_entry * png_const_sPLT_entryp;
typedef png_sPLT_entry * * png_sPLT_entrypp;






typedef struct png_sPLT_struct
{
   png_charp name;
   png_byte depth;
   png_sPLT_entryp entries;
   png_int_32 nentries;
} png_sPLT_t;
typedef png_sPLT_t * png_sPLT_tp;
typedef const png_sPLT_t * png_const_sPLT_tp;
typedef png_sPLT_t * * png_sPLT_tpp;
# 600 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
typedef struct png_time_struct
{
   png_uint_16 year;
   png_byte month;
   png_byte day;
   png_byte hour;
   png_byte minute;
   png_byte second;
} png_time;
typedef png_time * png_timep;
typedef const png_time * png_const_timep;
typedef png_time * * png_timepp;
# 622 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
typedef struct png_unknown_chunk_t
{
   png_byte name[5];
   png_byte *data;
   size_t size;







   png_byte location;
}
png_unknown_chunk;

typedef png_unknown_chunk * png_unknown_chunkp;
typedef const png_unknown_chunk * png_const_unknown_chunkp;
typedef png_unknown_chunk * * png_unknown_chunkpp;
# 754 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
typedef struct png_row_info_struct
{
   png_uint_32 width;
   size_t rowbytes;
   png_byte color_type;
   png_byte bit_depth;
   png_byte channels;
   png_byte pixel_depth;
} png_row_info;

typedef png_row_info * png_row_infop;
typedef png_row_info * * png_row_infopp;
# 775 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
typedef void ( *png_error_ptr) (png_structp, png_const_charp);
typedef void ( *png_rw_ptr) (png_structp, png_bytep, size_t);
typedef void ( *png_flush_ptr) (png_structp);
typedef void ( *png_read_status_ptr) (png_structp, png_uint_32, int)
         ;
typedef void ( *png_write_status_ptr) (png_structp, png_uint_32, int)
         ;
# 867 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
typedef png_voidp ( *png_malloc_ptr) (png_structp, png_alloc_size_t)
                      ;
typedef void ( *png_free_ptr) (png_structp, png_voidp);
# 901 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern png_uint_32 ( png_access_version_number) (void);




extern void ( png_set_sig_bytes) (png_structrp png_ptr, int num_bytes);






extern int ( png_sig_cmp) (png_const_bytep sig, size_t start, size_t num_to_check)
                         ;







extern png_structp ( png_create_read_struct) (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn)


                  ;


extern png_structp ( png_create_write_struct) (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn)


                  ;

extern size_t ( png_get_compression_buffer_size) (png_const_structrp png_ptr)
                                 ;

extern void ( png_set_compression_buffer_size) (png_structrp png_ptr, size_t size)
                 ;
# 963 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_longjmp) (png_const_structrp png_ptr, int val)
                 ;



extern int ( png_reset_zstream) (png_structrp png_ptr);
# 986 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_write_sig) (png_structrp png_ptr);


extern void ( png_write_chunk) (png_structrp png_ptr, png_const_bytep chunk_name, png_const_bytep data, size_t length)
                                                     ;


extern void ( png_write_chunk_start) (png_structrp png_ptr, png_const_bytep chunk_name, png_uint_32 length)
                                                    ;


extern void ( png_write_chunk_data) (png_structrp png_ptr, png_const_bytep data, size_t length)
                                         ;


extern void ( png_write_chunk_end) (png_structrp png_ptr);


extern png_infop ( png_create_info_struct) (png_const_structrp png_ptr)
                  ;





extern void ( png_info_init_3) (png_infopp info_ptr, size_t png_info_struct_size)
                                                 ;


extern void ( png_write_info_before_PLTE) (png_structrp png_ptr, png_const_inforp info_ptr)
                                                      ;
extern void ( png_write_info) (png_structrp png_ptr, png_const_inforp info_ptr)
                                                      ;



extern void ( png_read_info) (png_structrp png_ptr, png_inforp info_ptr)
                                                ;
# 1285 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern int ( png_set_interlace_handling) (png_structrp png_ptr);
# 1358 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_set_flush) (png_structrp png_ptr, int nrows);

extern void ( png_write_flush) (png_structrp png_ptr);



extern void ( png_start_read_image) (png_structrp png_ptr);


extern void ( png_read_update_info) (png_structrp png_ptr, png_inforp info_ptr)
                         ;



extern void ( png_read_rows) (png_structrp png_ptr, png_bytepp row, png_bytepp display_row, png_uint_32 num_rows)
                                                  ;




extern void ( png_read_row) (png_structrp png_ptr, png_bytep row, png_bytep display_row)
                           ;




extern void ( png_read_image) (png_structrp png_ptr, png_bytepp image);



extern void ( png_write_row) (png_structrp png_ptr, png_const_bytep row)
                         ;






extern void ( png_write_rows) (png_structrp png_ptr, png_bytepp row, png_uint_32 num_rows)
                          ;


extern void ( png_write_image) (png_structrp png_ptr, png_bytepp image);


extern void ( png_write_end) (png_structrp png_ptr, png_inforp info_ptr)
                         ;



extern void ( png_read_end) (png_structrp png_ptr, png_inforp info_ptr);



extern void ( png_destroy_info_struct) (png_const_structrp png_ptr, png_infopp info_ptr_ptr)
                             ;


extern void ( png_destroy_read_struct) (png_structpp png_ptr_ptr, png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr)
                                                          ;


extern void ( png_destroy_write_struct) (png_structpp png_ptr_ptr, png_infopp info_ptr_ptr)
                             ;


extern void ( png_set_crc_action) (png_structrp png_ptr, int crit_action, int ancil_action)
                      ;
# 1455 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_set_filter) (png_structrp png_ptr, int method, int filters)
                 ;
# 1508 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_set_compression_level) (png_structrp png_ptr, int level)
               ;

extern void ( png_set_compression_mem_level) (png_structrp png_ptr, int mem_level)
                   ;

extern void ( png_set_compression_strategy) (png_structrp png_ptr, int strategy)
                  ;




extern void ( png_set_compression_window_bits) (png_structrp png_ptr, int window_bits)
                     ;

extern void ( png_set_compression_method) (png_structrp png_ptr, int method)
                ;
# 1560 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_init_io) (png_structrp png_ptr, png_FILE_p fp);
# 1571 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_set_error_fn) (png_structrp png_ptr, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warning_fn)
                                                                           ;


extern png_voidp ( png_get_error_ptr) (png_const_structrp png_ptr);
# 1587 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_set_write_fn) (png_structrp png_ptr, png_voidp io_ptr, png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn)
                                                             ;


extern void ( png_set_read_fn) (png_structrp png_ptr, png_voidp io_ptr, png_rw_ptr read_data_fn)
                             ;


extern png_voidp ( png_get_io_ptr) (png_const_structrp png_ptr);

extern void ( png_set_read_status_fn) (png_structrp png_ptr, png_read_status_ptr read_row_fn)
                                     ;

extern void ( png_set_write_status_fn) (png_structrp png_ptr, png_write_status_ptr write_row_fn)
                                       ;
# 1716 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern png_voidp ( png_malloc) (png_const_structrp png_ptr, png_alloc_size_t size)
                                          ;

extern png_voidp ( png_calloc) (png_const_structrp png_ptr, png_alloc_size_t size)
                                          ;


extern png_voidp ( png_malloc_warn) (png_const_structrp png_ptr, png_alloc_size_t size)
                                          ;


extern void ( png_free) (png_const_structrp png_ptr, png_voidp ptr);


extern void ( png_free_data) (png_const_structrp png_ptr, png_inforp info_ptr, png_uint_32 free_me, int num)
                                                       ;
# 1740 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_data_freer) (png_const_structrp png_ptr, png_inforp info_ptr, int freer, png_uint_32 mask)
                                                      ;
# 1774 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_error) (png_const_structrp png_ptr, png_const_charp error_message)
                                                 ;


extern void ( png_chunk_error) (png_const_structrp png_ptr, png_const_charp error_message)
                                                 ;
# 1790 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_warning) (png_const_structrp png_ptr, png_const_charp warning_message)
                                     ;


extern void ( png_chunk_warning) (png_const_structrp png_ptr, png_const_charp warning_message)
                                     ;
# 1804 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_benign_error) (png_const_structrp png_ptr, png_const_charp warning_message)
                                     ;



extern void ( png_chunk_benign_error) (png_const_structrp png_ptr, png_const_charp warning_message)
                                     ;


extern void ( png_set_benign_errors) (png_structrp png_ptr, int allowed)
                                        ;
# 1838 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern png_uint_32 ( png_get_valid) (png_const_structrp png_ptr, png_const_inforp info_ptr, png_uint_32 flag)
                                                 ;


extern size_t ( png_get_rowbytes) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;





extern png_bytepp ( png_get_rows) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;




extern void ( png_set_rows) (png_const_structrp png_ptr, png_inforp info_ptr, png_bytepp row_pointers)
                                                  ;



extern png_byte ( png_get_channels) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;



extern png_uint_32 ( png_get_image_width) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;


extern png_uint_32 ( png_get_image_height) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;


extern png_byte ( png_get_bit_depth) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;


extern png_byte ( png_get_color_type) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;


extern png_byte ( png_get_filter_type) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;


extern png_byte ( png_get_interlace_type) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;


extern png_byte ( png_get_compression_type) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;


extern png_uint_32 ( png_get_pixels_per_meter) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                                                            ;
extern png_uint_32 ( png_get_x_pixels_per_meter) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                                                            ;
extern png_uint_32 ( png_get_y_pixels_per_meter) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                                                            ;




extern png_fixed_point ( png_get_pixel_aspect_ratio_fixed) (png_const_structrp png_ptr, png_const_inforp info_ptr);



extern png_int_32 ( png_get_x_offset_pixels) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                                                            ;
extern png_int_32 ( png_get_y_offset_pixels) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                                                            ;
extern png_int_32 ( png_get_x_offset_microns) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                                                            ;
extern png_int_32 ( png_get_y_offset_microns) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                                                            ;





extern png_const_bytep ( png_get_signature) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;



extern png_uint_32 ( png_get_bKGD) (png_const_structrp png_ptr, png_inforp info_ptr, png_color_16p *background)
                                                    ;



extern void ( png_set_bKGD) (png_const_structrp png_ptr, png_inforp info_ptr, png_const_color_16p background)
                                                         ;
# 2009 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern png_uint_32 ( png_get_hIST) (png_const_structrp png_ptr, png_inforp info_ptr, png_uint_16p *hist)
                                             ;
extern void ( png_set_hIST) (png_const_structrp png_ptr, png_inforp info_ptr, png_const_uint_16p hist)
                                                  ;


extern png_uint_32 ( png_get_IHDR) (png_const_structrp png_ptr, png_const_inforp info_ptr, png_uint_32 *width, png_uint_32 *height, int *bit_depth, int *color_type, int *interlace_method, int *compression_method, int *filter_method)


                                                 ;

extern void ( png_set_IHDR) (png_const_structrp png_ptr, png_inforp info_ptr, png_uint_32 width, png_uint_32 height, int bit_depth, int color_type, int interlace_method, int compression_method, int filter_method)


                       ;
# 2061 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern png_uint_32 ( png_get_PLTE) (png_const_structrp png_ptr, png_inforp info_ptr, png_colorp *palette, int *num_palette)
                                                               ;

extern void ( png_set_PLTE) (png_structrp png_ptr, png_inforp info_ptr, png_const_colorp palette, int num_palette)
                                                                    ;


extern png_uint_32 ( png_get_sBIT) (png_const_structrp png_ptr, png_inforp info_ptr, png_color_8p *sig_bit)
                                                ;



extern void ( png_set_sBIT) (png_const_structrp png_ptr, png_inforp info_ptr, png_const_color_8p sig_bit)
                                                     ;
# 2140 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern png_uint_32 ( png_get_tRNS) (png_const_structrp png_ptr, png_inforp info_ptr, png_bytep *trans_alpha, int *num_trans, png_color_16p *trans_color)

                                ;



extern void ( png_set_tRNS) (png_structrp png_ptr, png_inforp info_ptr, png_const_bytep trans_alpha, int num_trans, png_const_color_16p trans_color)

                                     ;
# 2279 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_set_keep_unknown_chunks) (png_structrp png_ptr, int keep, png_const_bytep chunk_list, int num_chunks)
                                                          ;






extern int ( png_handle_as_unknown) (png_const_structrp png_ptr, png_const_bytep chunk_name)
                                ;



extern void ( png_set_unknown_chunks) (png_const_structrp png_ptr, png_inforp info_ptr, png_const_unknown_chunkp unknowns, int num_unknowns)

                      ;
# 2304 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_set_unknown_chunk_location) (png_const_structrp png_ptr, png_inforp info_ptr, int chunk, int location)
                                                                               ;

extern int ( png_get_unknown_chunks) (png_const_structrp png_ptr, png_inforp info_ptr, png_unknown_chunkpp entries)
                                                      ;






extern void ( png_set_invalid) (png_const_structrp png_ptr, png_inforp info_ptr, int mask)
                                   ;




extern void ( png_read_png) (png_structrp png_ptr, png_inforp info_ptr, int transforms, png_voidp params)
                                      ;


extern void ( png_write_png) (png_structrp png_ptr, png_inforp info_ptr, int transforms, png_voidp params)
                                      ;



extern png_const_charp ( png_get_copyright) (png_const_structrp png_ptr)
                                 ;
extern png_const_charp ( png_get_header_ver) (png_const_structrp png_ptr)
                                 ;
extern png_const_charp ( png_get_header_version) (png_const_structrp png_ptr)
                                 ;
extern png_const_charp ( png_get_libpng_ver) (png_const_structrp png_ptr)
                                 ;
# 2361 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_set_user_limits) (png_structrp png_ptr, png_uint_32 user_width_max, png_uint_32 user_height_max)
                                                             ;
extern png_uint_32 ( png_get_user_width_max) (png_const_structrp png_ptr)
                                 ;
extern png_uint_32 ( png_get_user_height_max) (png_const_structrp png_ptr)
                                 ;

extern void ( png_set_chunk_cache_max) (png_structrp png_ptr, png_uint_32 user_chunk_cache_max)
                                      ;
extern png_uint_32 ( png_get_chunk_cache_max) (png_const_structrp png_ptr)
                                 ;

extern void ( png_set_chunk_malloc_max) (png_structrp png_ptr, png_alloc_size_t user_chunk_cache_max)
                                           ;
extern png_alloc_size_t ( png_get_chunk_malloc_max) (png_const_structrp png_ptr)
                                 ;
# 2412 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern png_uint_32 ( png_get_io_state) (png_const_structrp png_ptr);





extern png_uint_32 ( png_get_io_chunk_type) (png_const_structrp png_ptr)
                                 ;
# 2544 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern png_uint_32 ( png_get_uint_32) (png_const_bytep buf);
extern png_uint_16 ( png_get_uint_16) (png_const_bytep buf);
extern png_int_32 ( png_get_int_32) (png_const_bytep buf);


extern png_uint_32 ( png_get_uint_31) (png_const_structrp png_ptr, png_const_bytep buf)
                         ;




extern void ( png_save_uint_32) (png_bytep buf, png_uint_32 i);


extern void ( png_save_int_32) (png_bytep buf, png_int_32 i);







extern void ( png_save_uint_16) (png_bytep buf, unsigned int i);
# 2612 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_set_check_for_invalid_index) (png_structrp png_ptr, int allowed)
                                        ;

extern int ( png_get_palette_max) (png_const_structp png_ptr, png_const_infop info_ptr)
                              ;
# 13 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/opngreduc/opngreduc.h" 2
# 28 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/opngreduc/opngreduc.h"
int opng_validate_image(png_structp png_ptr, png_infop info_ptr);
# 55 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/opngreduc/opngreduc.h"
png_uint_32 opng_reduce_image(png_structp png_ptr, png_infop info_ptr,
   png_uint_32 reductions);
# 21 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2

# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/pngxtern/pngxtern.h" 1
# 47 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/pngxtern/pngxtern.h"
int pngx_read_image(png_structp png_ptr, png_infop info_ptr,
                           png_const_charpp fmt_name_ptr,
                           png_const_charpp fmt_long_name_ptr);
# 23 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/pngxtern/pngxutil.h" 1
# 21 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/pngxtern/pngxutil.h"
void pngx_set_compression_type
   (png_structp png_ptr, png_infop info_ptr, int compression_type);
void pngx_set_filter_type
   (png_structp png_ptr, png_infop info_ptr, int filter_type);
void pngx_set_interlace_type
   (png_structp png_ptr, png_infop info_ptr, int interlace_type);



typedef png_alloc_size_t pngx_alloc_size_t;
# 43 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/pngxtern/pngxutil.h"
png_bytepp pngx_malloc_rows
   (png_structp png_ptr, png_infop info_ptr, int filler);
png_bytepp pngx_malloc_rows_extended
   (png_structp png_ptr, png_infop info_ptr,
    pngx_alloc_size_t min_row_size, int filler);
# 24 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h" 1
# 56 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h" 1
# 254 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stddef.h" 1
# 255 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h" 2
     typedef size_t z_size_t;
# 401 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h"
typedef unsigned char Byte;

typedef unsigned int uInt;
typedef unsigned long uLong;





   typedef Byte Bytef;

typedef char charf;
typedef int intf;
typedef uInt uIntf;
typedef uLong uLongf;


   typedef void const *voidpc;
   typedef void *voidpf;
   typedef void *voidp;







# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/limits.h" 1
# 429 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h" 2
# 439 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h"
   typedef unsigned z_crc_t;
# 454 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/sys/types.h" 1
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/sys/types.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1
# 3 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/sys/types.h" 2
# 455 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h" 2





# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdarg.h" 1
# 461 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h" 2
# 492 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/unistd.h" 1
# 493 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h" 2
# 57 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h" 2
# 103 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
typedef voidpf (*alloc_func)(voidpf opaque, uInt items, uInt size);
typedef void (*free_func)(voidpf opaque, voidpf address);

struct internal_state;

typedef struct z_stream_s {
    Bytef *next_in;
    uInt avail_in;
    uLong total_in;

    Bytef *next_out;
    uInt avail_out;
    uLong total_out;

    char *msg;
    struct internal_state *state;

    alloc_func zalloc;
    free_func zfree;
    voidpf opaque;

    int data_type;

    uLong adler;
    uLong reserved;
} z_stream;

typedef z_stream *z_streamp;





typedef struct gz_header_s {
    int text;
    uLong time;
    int xflags;
    int os;
    Bytef *extra;
    uInt extra_len;
    uInt extra_max;
    Bytef *name;
    uInt name_max;
    Bytef *comment;
    uInt comm_max;
    int hcrc;
    int done;

} gz_header;

typedef gz_header *gz_headerp;
# 242 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern const char * zlibVersion(void);
# 272 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflate(z_streamp strm, int flush);
# 385 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflateEnd(z_streamp strm);
# 423 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflate(z_streamp strm, int flush);
# 543 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflateEnd(z_streamp strm);
# 633 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflateSetDictionary(z_streamp strm,
                                         const Bytef *dictionary,
                                         uInt dictLength);
# 677 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflateGetDictionary(z_streamp strm,
                                         Bytef *dictionary,
                                         uInt *dictLength);
# 699 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflateCopy(z_streamp dest,
                                z_streamp source);
# 717 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflateReset(z_streamp strm);
# 728 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflateParams(z_streamp strm,
                                  int level,
                                  int strategy);
# 766 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflateTune(z_streamp strm,
                                int good_length,
                                int max_lazy,
                                int nice_length,
                                int max_chain);
# 783 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern uLong deflateBound(z_streamp strm,
                                   uLong sourceLen);
# 798 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflatePending(z_streamp strm,
                                   unsigned *pending,
                                   int *bits);
# 813 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflatePrime(z_streamp strm,
                                 int bits,
                                 int value);
# 830 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflateSetHeader(z_streamp strm,
                                     gz_headerp head);
# 910 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflateSetDictionary(z_streamp strm,
                                         const Bytef *dictionary,
                                         uInt dictLength);
# 933 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflateGetDictionary(z_streamp strm,
                                         Bytef *dictionary,
                                         uInt *dictLength);
# 948 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflateSync(z_streamp strm);
# 967 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflateCopy(z_streamp dest,
                                z_streamp source);
# 983 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflateReset(z_streamp strm);
# 994 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflateReset2(z_streamp strm,
                                  int windowBits);
# 1008 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflatePrime(z_streamp strm,
                                 int bits,
                                 int value);
# 1029 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern long inflateMark(z_streamp strm);
# 1057 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflateGetHeader(z_streamp strm,
                                     gz_headerp head);
# 1119 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
typedef unsigned (*in_func)(void *,
                            unsigned char * *);
typedef int (*out_func)(void *, unsigned char *, unsigned);

extern int inflateBack(z_streamp strm,
                                in_func in, void *in_desc,
                                out_func out, void *out_desc);
# 1193 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflateBackEnd(z_streamp strm);







extern uLong zlibCompileFlags(void);
# 1254 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int compress(Bytef *dest, uLongf *destLen,
                             const Bytef *source, uLong sourceLen);
# 1269 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int compress2(Bytef *dest, uLongf *destLen,
                              const Bytef *source, uLong sourceLen,
                              int level);
# 1285 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern uLong compressBound(uLong sourceLen);






extern int uncompress(Bytef *dest, uLongf *destLen,
                               const Bytef *source, uLong sourceLen);
# 1310 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int uncompress2(Bytef *dest, uLongf *destLen,
                                const Bytef *source, uLong *sourceLen);
# 1327 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
typedef struct gzFile_s *gzFile;
# 1367 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern gzFile gzdopen(int fd, const char *mode);
# 1390 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzbuffer(gzFile file, unsigned size);
# 1406 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzsetparams(gzFile file, int level, int strategy);
# 1417 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzread(gzFile file, voidp buf, unsigned len);
# 1447 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern z_size_t gzfread(voidp buf, z_size_t size, z_size_t nitems,
                                 gzFile file);
# 1473 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzwrite(gzFile file, voidpc buf, unsigned len);





extern z_size_t gzfwrite(voidpc buf, z_size_t size,
                                  z_size_t nitems, gzFile file);
# 1493 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzprintf(gzFile file, const char *format, ...);
# 1508 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzputs(gzFile file, const char *s);







extern char * gzgets(gzFile file, char *buf, int len);
# 1530 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzputc(gzFile file, int c);





extern int gzgetc(gzFile file);
# 1545 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzungetc(int c, gzFile file);
# 1557 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzflush(gzFile file, int flush);
# 1592 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzrewind(gzFile file);
# 1620 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzeof(gzFile file);
# 1635 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzdirect(gzFile file);
# 1656 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzclose(gzFile file);
# 1669 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzclose_r(gzFile file);
extern int gzclose_w(gzFile file);
# 1681 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern const char * gzerror(gzFile file, int *errnum);
# 1697 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern void gzclearerr(gzFile file);
# 1714 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern uLong adler32(uLong adler, const Bytef *buf, uInt len);
# 1734 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern uLong adler32_z(uLong adler, const Bytef *buf,
                                z_size_t len);
# 1752 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern uLong crc32(uLong crc, const Bytef *buf, uInt len);
# 1770 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern uLong crc32_z(uLong crc, const Bytef *buf,
                              z_size_t len);
# 1793 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern uLong crc32_combine_op(uLong crc1, uLong crc2, uLong op);
# 1806 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflateInit_(z_streamp strm, int level,
                                 const char *version, int stream_size);
extern int inflateInit_(z_streamp strm,
                                 const char *version, int stream_size);
extern int deflateInit2_(z_streamp strm, int level, int method,
                                  int windowBits, int memLevel,
                                  int strategy, const char *version,
                                  int stream_size);
extern int inflateInit2_(z_streamp strm, int windowBits,
                                  const char *version, int stream_size);
extern int inflateBackInit_(z_streamp strm, int windowBits,
                                     unsigned char *window,
                                     const char *version,
                                     int stream_size);
# 1859 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
struct gzFile_s {
    unsigned have;
    unsigned char *next;
    off_t pos;
};
extern int gzgetc_(gzFile file);
# 1918 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
   extern gzFile gzopen(const char *, const char *);
   extern off_t gzseek(gzFile, off_t, int);
   extern off_t gztell(gzFile);
   extern off_t gzoffset(gzFile);
   extern uLong adler32_combine(uLong, uLong, off_t);
   extern uLong crc32_combine(uLong, uLong, off_t);
   extern uLong crc32_combine_gen(off_t);
# 1936 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern const char * zError(int);
extern int inflateSyncPoint(z_streamp);
extern const z_crc_t * get_crc_table(void);
extern int inflateUndermine(z_streamp, int);
extern int inflateValidate(z_streamp, int);
extern unsigned long inflateCodesUsed(z_streamp);
extern int inflateResetKeep(z_streamp);
extern int deflateResetKeep(z_streamp);






extern int gzvprintf(gzFile file,
                                           const char *format,
                                           va_list va);
# 25 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2


# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h" 1
# 14 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 1
# 15 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h" 2
# 37 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/limits.h" 1
# 38 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h" 2


typedef long opng_foffset_t;
# 49 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
typedef unsigned long opng_fsize_t;
# 110 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
opng_foffset_t
opng_ftello(FILE *stream);





int
opng_fseeko(FILE *stream, opng_foffset_t offset, int whence);
# 127 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
size_t
opng_freado(FILE *stream, opng_foffset_t offset, int whence,
            void *block, size_t blocksize);
# 138 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
size_t
opng_fwriteo(FILE *stream, opng_foffset_t offset, int whence,
             const void *block, size_t blocksize);






int
opng_fgetsize(FILE *stream, opng_fsize_t *size);
# 161 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
char *
opng_path_replace_dir(char *buffer, size_t bufsize,
                      const char *old_path, const char *new_dirname);
# 174 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
char *
opng_path_replace_ext(char *buffer, size_t bufsize,
                      const char *old_path, const char *new_extname);






char *
opng_path_make_backup(char *buffer, size_t bufsize, const char *path);






int
opng_os_rename(const char *src_path, const char *dest_path, int clobber);







int
opng_os_create_dir(const char *dirname);







int
opng_os_copy_file_attr(const char *src_path, const char *dest_path);
# 225 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
int
opng_os_test_file_access(const char *path, const char *mode);
# 236 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
int
opng_os_test_file_equiv(const char *path1, const char *path2);







int
opng_os_unlink(const char *path);
# 28 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ratio.h" 1
# 14 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ratio.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stddef.h" 1
# 15 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ratio.h" 2
# 23 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ratio.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/limits.h" 1
# 24 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ratio.h" 2
# 69 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ratio.h"
struct opng_lratio
{
    long num;
    long denom;
};




struct opng_ulratio
{
    unsigned long num;
    unsigned long denom;
};
# 124 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ratio.h"
int
opng_ulratio_to_factor_string(char *buffer, size_t buffer_size,
                              const struct opng_ulratio *ratio);
# 140 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ratio.h"
int
opng_ulratio_to_percent_string(char *buffer, size_t buffer_size,
                               const struct opng_ulratio *ratio);
# 29 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2





# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/cexcept/cexcept.h" 1
# 196 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/cexcept/cexcept.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/setjmp.h" 1
# 197 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/cexcept/cexcept.h" 2
# 35 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2
typedef enum
{
    OPNG_STATUS_OK = 0,
    OPNG_STATUS_ERR_LIBPNG = -1,
    OPNG_STATUS_ERR_OPTIPNG = -2
} opng_status_t;
struct exception_context { jmp_buf *penv; int caught; volatile struct { opng_status_t etmp; } v; };
struct exception_context the_exception_context[1];





static const struct opng_preset_struct
{
    const char *compr_level;
    const char *mem_level;
    const char *strategy;
    const char *filter;
} k_presets[7 + 1] =
{

    { "", "", "", "" },
    { "", "", "", "" },
    { "9", "8", "0-", "0,5" },
    { "9", "8-9", "0-", "0,5" },
    { "9", "8", "0-", "0-" },
    { "9", "8-9", "0-", "0-" },
    { "1-9", "8", "0-", "0-" },
    { "1-9", "8-9", "0-", "0-" }
};




static const int k_filter_table[5 + 1] =
{
    0x08,
    0x10,
    0x20,
    0x40,
    0x80,
    ((0x08 | 0x10 | 0x20) | 0x40 | 0x80)
};




static const png_byte k_sig_PLTE[4] = { 0x50, 0x4c, 0x54, 0x45 };
static const png_byte k_sig_tRNS[4] = { 0x74, 0x52, 0x4e, 0x53 };
static const png_byte k_sig_IDAT[4] = { 0x49, 0x44, 0x41, 0x54 };
static const png_byte k_sig_IEND[4] = { 0x49, 0x45, 0x4e, 0x44 };
static const png_byte k_sig_bKGD[4] = { 0x62, 0x4b, 0x47, 0x44 };
static const png_byte k_sig_hIST[4] = { 0x68, 0x49, 0x53, 0x54 };
static const png_byte k_sig_sBIT[4] = { 0x73, 0x42, 0x49, 0x54 };
static const png_byte k_sig_dSIG[4] = { 0x64, 0x53, 0x49, 0x47 };
static const png_byte k_sig_acTL[4] = { 0x61, 0x63, 0x54, 0x4c };
static const png_byte k_sig_fcTL[4] = { 0x66, 0x63, 0x54, 0x4c };
static const png_byte k_sig_fdAT[4] = { 0x66, 0x64, 0x41, 0x54 };




static const opng_fsize_t k_idat_size_max = ((png_uint_32)0x7fffffffL);
static const char *k_idat_size_max_string = "2GB";




enum
{
    INPUT_IS_PNG_FILE = 0x0001,
    INPUT_HAS_PNG_DATASTREAM = 0x0002,
    INPUT_HAS_PNG_SIGNATURE = 0x0004,
    INPUT_HAS_DIGITAL_SIGNATURE = 0x0008,
    INPUT_HAS_MULTIPLE_IMAGES = 0x0010,
    INPUT_HAS_APNG = 0x0020,
    INPUT_HAS_STRIPPED_DATA = 0x0040,
    INPUT_HAS_JUNK = 0x0080,
    INPUT_HAS_ERRORS = 0x0100,
    OUTPUT_NEEDS_NEW_FILE = 0x1000,
    OUTPUT_NEEDS_NEW_IDAT = 0x2000,
    OUTPUT_HAS_ERRORS = 0x4000
};





static struct opng_engine_struct
{
    int started;
} s_engine;




static struct opng_process_struct
{
    unsigned int status;
    int num_iterations;
    opng_foffset_t in_datastream_offset;
    opng_fsize_t in_file_size, out_file_size;
    opng_fsize_t in_idat_size, out_idat_size;
    opng_fsize_t best_idat_size, max_idat_size;
    png_uint_32 in_plte_trns_size, out_plte_trns_size;
    png_uint_32 reductions;
    opng_bitset_t compr_level_set, mem_level_set, strategy_set, filter_set;
    int best_compr_level, best_mem_level, best_strategy, best_filter;
} s_process;




static struct opng_summary_struct
{
    unsigned int file_count;
    unsigned int err_count;
    unsigned int fix_count;
    unsigned int snip_count;
} s_summary;




static struct opng_image_struct
{
    png_uint_32 width;
    png_uint_32 height;
    int bit_depth;
    int color_type;
    int compression_type;
    int filter_type;
    int interlace_type;
    png_bytepp row_pointers;
    png_colorp palette;
    int num_palette;
    png_color_16p background_ptr;
    png_color_16 background;
    png_uint_16p hist;
    png_color_8p sig_bit_ptr;
    png_color_8 sig_bit;
    png_bytep trans_alpha;
    int num_trans;
    png_color_16p trans_color_ptr;
    png_color_16 trans_color;
    png_unknown_chunkp unknowns;
    int num_unknowns;
} s_image;




static struct opng_options s_options;




static png_structp s_read_ptr;
static png_infop s_read_info_ptr;
static png_structp s_write_ptr;
static png_infop s_write_info_ptr;





static void (*usr_printf)(const char *fmt, ...);
static void (*usr_print_cntrl)(int cntrl_code);
static void (*usr_progress)(unsigned long num, unsigned long denom);
static void (*usr_panic)(const char *msg);
# 218 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c"
static void
opng_print_fsize_ratio(opng_fsize_t num, opng_fsize_t denom)
{
# 229 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c"
    char buffer[32];
    struct opng_ulratio ratio;
    int result;

    ratio.num = num;
    ratio.denom = denom;
    result = opng_ulratio_to_factor_string(buffer, sizeof(buffer), &ratio);
    usr_printf("%s%s", buffer, (result > 0) ? "" : "...");



}




static void
opng_print_fsize_difference(opng_fsize_t init_size, opng_fsize_t final_size,
                            int show_ratio)
{
    opng_fsize_t difference;
    int sign;

    if (init_size <= final_size)
    {
        sign = 0;
        difference = final_size - init_size;
    }
    else
    {
        sign = 1;
        difference = init_size - final_size;
    }

    if (difference == 0)
    {
        usr_printf("no change");
        return;
    }
    if (difference == 1)
        usr_printf("1 byte");
    else
        usr_printf("%" "lu" " bytes", difference);
    if (show_ratio && init_size > 0)
    {
        usr_printf(" = ");
        opng_print_fsize_ratio(difference, init_size);
    }
    usr_printf((sign == 0) ? " increase" : " decrease");
}




static void
opng_print_image_info(int show_dim, int show_depth, int show_type,
                      int show_interlaced)
{
    static const int type_channels[8] = {1, 0, 3, 1, 2, 0, 4, 0};
    int channels, printed;

    printed = 0;
    if (show_dim)
    {
        printed = 1;
        usr_printf("%lux%lu pixels",
                   (unsigned long)s_image.width,
                   (unsigned long)s_image.height);
    }
    if (show_depth)
    {
        if (printed)
            usr_printf(", ");
        printed = 1;
        channels = type_channels[s_image.color_type & 7];
        if (channels != 1)
            usr_printf("%dx%d bits/pixel", channels, s_image.bit_depth);
        else if (s_image.bit_depth != 1)
            usr_printf("%d bits/pixel", s_image.bit_depth);
        else
            usr_printf("1 bit/pixel");
    }
    if (show_type)
    {
        if (printed)
            usr_printf(", ");
        printed = 1;
        if (s_image.color_type & 1)
        {
            if (s_image.num_palette == 1)
                usr_printf("1 color");
            else
                usr_printf("%d colors", s_image.num_palette);
            if (s_image.num_trans > 0)
                usr_printf(" (%d transparent)", s_image.num_trans);
            usr_printf(" in palette");
        }
        else
        {
            usr_printf((s_image.color_type & 2) ?
                       "RGB" : "grayscale");
            if (s_image.color_type & 4)
                usr_printf("+alpha");
            else if (s_image.trans_color_ptr != 0)
                usr_printf("+transparency");
        }
    }
    if (show_interlaced)
    {
        if (s_image.interlace_type != 0)
        {
            if (printed)
                usr_printf(", ");
            usr_printf("interlaced");
        }
    }
}




static void
opng_print_warning(const char *msg)
{
    usr_print_cntrl('\v');
    usr_printf("Warning: %s\n", msg);
}




static void
opng_print_error(const char *msg)
{
    usr_print_cntrl('\v');
    usr_printf("Error: %s\n", msg);
}




static void
opng_throw_error(png_const_charp msg)
{
    opng_print_error(msg);
    for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = OPNG_STATUS_ERR_OPTIPNG;
}




static void
opng_warning(png_structp png_ptr, png_const_charp msg)
{


    if (png_ptr == s_read_ptr)
        s_process.status |= (INPUT_HAS_ERRORS | OUTPUT_NEEDS_NEW_IDAT);
    opng_print_warning(msg);
}




static void
opng_error(png_structp png_ptr, png_const_charp msg)
{


    if (png_ptr == s_read_ptr)
    {
        s_process.status |= (INPUT_HAS_ERRORS | OUTPUT_NEEDS_NEW_IDAT);
        if (opng_validate_image(s_read_ptr, s_read_info_ptr))
        {



            opng_print_warning(msg);
            for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = OPNG_STATUS_OK;
        }
    }

    opng_print_error(msg);
    for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = OPNG_STATUS_ERR_LIBPNG;
}




static void
opng_free(void *ptr)
{




    free(ptr);
}




static void
opng_check_idat_size(opng_fsize_t size)
{
    if (size > k_idat_size_max)
        opng_throw_error("IDAT sizes larger than the maximum chunk size "
                         "are currently unsupported");
}




static void
opng_set_keep_unknown_chunk(png_structp png_ptr,
                            int keep, png_bytep chunk_type)
{
    png_byte chunk_name[5];


    memcpy(chunk_name, chunk_type, 4);
    chunk_name[4] = 0;
    if (!png_handle_as_unknown(png_ptr, chunk_name))
        png_set_keep_unknown_chunks(png_ptr, keep, chunk_name, 1);
}




static int
opng_is_image_chunk(png_bytep chunk_type)
{
    if ((chunk_type[0] & 0x20) == 0)
        return 1;





    if (memcmp(chunk_type, k_sig_tRNS, 4) == 0)
        return 1;
    return 0;
}




static int
opng_is_apng_chunk(png_bytep chunk_type)
{
    if (memcmp(chunk_type, k_sig_acTL, 4) == 0 ||
        memcmp(chunk_type, k_sig_fcTL, 4) == 0 ||
        memcmp(chunk_type, k_sig_fdAT, 4) == 0)
        return 1;
    return 0;
}




static int
opng_allow_chunk(png_bytep chunk_type)
{

    if (opng_is_image_chunk(chunk_type))
        return 1;

    if (s_options.strip_all)
        return 0;

    if (memcmp(chunk_type, k_sig_dSIG, 4) == 0)
        return 0;

    if (s_options.snip && opng_is_apng_chunk(chunk_type))
        return 0;

    return 1;
}




static void
opng_handle_chunk(png_structp png_ptr, png_bytep chunk_type)
{
    int keep;

    if (opng_is_image_chunk(chunk_type))
        return;

    if (s_options.strip_all)
    {
        s_process.status |= INPUT_HAS_STRIPPED_DATA | INPUT_HAS_JUNK;
        opng_set_keep_unknown_chunk(png_ptr,
                                    1, chunk_type);
        return;
    }


    if (memcmp(chunk_type, k_sig_bKGD, 4) == 0 ||
        memcmp(chunk_type, k_sig_hIST, 4) == 0 ||
        memcmp(chunk_type, k_sig_sBIT, 4) == 0)
        return;


    keep = 3;
    if (memcmp(chunk_type, k_sig_dSIG, 4) == 0)
    {

        s_process.status |= INPUT_HAS_DIGITAL_SIGNATURE;
    }
    else if (opng_is_apng_chunk(chunk_type))
    {

        s_process.status |= INPUT_HAS_APNG;
        if (memcmp(chunk_type, k_sig_fdAT, 4) == 0)
            s_process.status |= INPUT_HAS_MULTIPLE_IMAGES;
        if (s_options.snip)
        {
            s_process.status |= INPUT_HAS_JUNK;
            keep = 1;
        }
    }
    opng_set_keep_unknown_chunk(png_ptr, keep, chunk_type);
}




static void
opng_init_read_data(void)
{



}




static void
opng_init_write_data(void)
{
    s_process.out_file_size = 0;
    s_process.out_plte_trns_size = 0;
    s_process.out_idat_size = 0;
}




static void
opng_read_data(png_structp png_ptr, png_bytep data, size_t length)
{
    FILE *stream = (FILE *)png_get_io_ptr(png_ptr);
    int io_state = png_get_io_state(png_ptr);
    int io_state_loc = io_state & 0x00f0;
    png_bytep chunk_sig;


    if (fread(data, 1, length, stream) != length)
        png_error(png_ptr,
                  "Can't read the input file or unexpected end of file");

    if (s_process.in_file_size == 0)
    {

        { if (!(length == 8)) usr_panic("PNG I/O must start with the first 8 bytes"); };
        s_process.in_datastream_offset = opng_ftello(stream) - 8;
        s_process.status |= INPUT_HAS_PNG_DATASTREAM;
        if (io_state_loc == 0x0010)
            s_process.status |= INPUT_HAS_PNG_SIGNATURE;
        if (s_process.in_datastream_offset == 0)
            s_process.status |= INPUT_IS_PNG_FILE;
        else if (s_process.in_datastream_offset < 0)
            png_error(png_ptr,
                      "Can't get the file-position indicator in input file");
        s_process.in_file_size = (opng_fsize_t)s_process.in_datastream_offset;
    }
    s_process.in_file_size += length;


    { if (!((io_state & 0x0001) && (io_state_loc != 0))) usr_panic("Incorrect info in png_ptr->io_state"); }
                                                      ;
    if (io_state_loc == 0x0020)
    {




        { if (!(length == 8)) usr_panic("Reading chunk header, expecting 8 bytes"); };
        chunk_sig = data + 4;

        if (memcmp(chunk_sig, k_sig_IDAT, 4) == 0)
        {
            { if (!(png_ptr == s_read_ptr)) usr_panic("Incorrect I/O handler setup"); };
            if (png_get_rows(s_read_ptr, s_read_info_ptr) == 0)
            {

                { if (!(s_process.in_idat_size == 0)) usr_panic("Found IDAT with no rows"); }
                                                      ;




                if (png_get_image_height(s_read_ptr, s_read_info_ptr) == 0)
                {

                    return;
                }
                { if (!(pngx_malloc_rows(s_read_ptr, s_read_info_ptr, 0) != 0)) usr_panic("Failed allocation of image rows; " "unsafe libpng allocator"); }


                                                      ;
                png_data_freer(s_read_ptr, s_read_info_ptr,
                               2, 0x0040U);
            }
            else
            {

                s_process.status |= INPUT_HAS_JUNK;
            }
            s_process.in_idat_size += (((png_uint_32)(*(data)) << 24) + ((png_uint_32)(*((data) + 1)) << 16) + ((png_uint_32)(*((data) + 2)) << 8) + ((png_uint_32)(*((data) + 3))));
        }
        else if (memcmp(chunk_sig, k_sig_PLTE, 4) == 0 ||
                 memcmp(chunk_sig, k_sig_tRNS, 4) == 0)
        {

            s_process.in_plte_trns_size += (((png_uint_32)(*(data)) << 24) + ((png_uint_32)(*((data) + 1)) << 16) + ((png_uint_32)(*((data) + 2)) << 8) + ((png_uint_32)(*((data) + 3)))) + 12;
        }
        else
            opng_handle_chunk(png_ptr, chunk_sig);
    }
    else if (io_state_loc == 0x0080)
    {
        { if (!(length == 4)) usr_panic("Reading chunk CRC, expecting 4 bytes"); };
    }
}




static void
opng_write_data(png_structp png_ptr, png_bytep data, size_t length)
{
    static int allow_crt_chunk;
    static int crt_chunk_is_idat;
    static opng_foffset_t crt_idat_offset;
    static opng_fsize_t crt_idat_size;
    static png_uint_32 crt_idat_crc;
    FILE *stream = (FILE *)png_get_io_ptr(png_ptr);
    int io_state = png_get_io_state(png_ptr);
    int io_state_loc = io_state & 0x00f0;
    png_bytep chunk_sig;
    png_byte buf[4];

    { if (!((io_state & 0x0002) && (io_state_loc != 0))) usr_panic("Incorrect info in png_ptr->io_state"); }
                                                      ;


    if (io_state_loc == 0x0020)
    {
        { if (!(length == 8)) usr_panic("Writing chunk header, expecting 8 bytes"); };
        chunk_sig = data + 4;
        allow_crt_chunk = opng_allow_chunk(chunk_sig);
        if (memcmp(chunk_sig, k_sig_IDAT, 4) == 0)
        {
            crt_chunk_is_idat = 1;
            s_process.out_idat_size += (((png_uint_32)(*(data)) << 24) + ((png_uint_32)(*((data) + 1)) << 16) + ((png_uint_32)(*((data) + 2)) << 8) + ((png_uint_32)(*((data) + 3))));

            if (stream == 0)
            {
                if (s_process.out_idat_size > s_process.max_idat_size)
                {

                    for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = OPNG_STATUS_OK;
                }
            }
        }
        else
        {
            crt_chunk_is_idat = 0;
            if (memcmp(chunk_sig, k_sig_PLTE, 4) == 0 ||
                memcmp(chunk_sig, k_sig_tRNS, 4) == 0)
            {

                s_process.out_plte_trns_size += (((png_uint_32)(*(data)) << 24) + ((png_uint_32)(*((data) + 1)) << 16) + ((png_uint_32)(*((data) + 2)) << 8) + ((png_uint_32)(*((data) + 3)))) + 12;
            }
        }
    }
    else if (io_state_loc == 0x0080)
    {
        { if (!(length == 4)) usr_panic("Writing chunk CRC, expecting 4 bytes"); };
    }


    if (stream == 0)
        return;


    if (io_state_loc != 0x0010 && !allow_crt_chunk)
        return;





    switch (io_state_loc)
    {
    case 0x0020:
        if (crt_chunk_is_idat)
        {
            if (crt_idat_offset == 0)
            {

                crt_idat_offset = opng_ftello(stream);

                if (s_process.best_idat_size > 0)
                {

                    crt_idat_size = s_process.best_idat_size;
                }
                else
                {



                    crt_idat_size = length;
                }
                png_save_uint_32(data, (png_uint_32)crt_idat_size);

                crt_idat_crc = crc32(0, k_sig_IDAT, 4);
            }
            else
            {

                return;
            }
        }
        else
        {
            if (crt_idat_offset != 0)
            {



                png_save_uint_32(buf, crt_idat_crc);
                if (fwrite(buf, 1, 4, stream) != 4)
                    io_state = 0;
                s_process.out_file_size += 4;
                if (s_process.out_idat_size != crt_idat_size)
                {



                    { if (!(s_process.best_idat_size == 0)) usr_panic("Wrong guess of the output IDAT size"); }
                                                                      ;
                    opng_check_idat_size(s_process.out_idat_size);
                    png_save_uint_32(buf,
                                     (png_uint_32)s_process.out_idat_size);
                    if (opng_fwriteo(stream, crt_idat_offset, 0,
                                     buf, 4) != 4)
                        io_state = 0;
                }
                if (io_state == 0)
                    png_error(png_ptr, "Can't finalize IDAT");
                crt_idat_offset = 0;
            }
        }
        break;
    case 0x0040:
        if (crt_chunk_is_idat)
            crt_idat_crc = crc32(crt_idat_crc, data, length);
        break;
    case 0x0080:
        if (crt_chunk_is_idat)
        {

            return;
        }
        break;
    }


    if (fwrite(data, 1, length, stream) != length)
        png_error(png_ptr, "Can't write the output file");
    s_process.out_file_size += length;
}




static void
opng_clear_image_info(void)
{
    memset(&s_image, 0, sizeof(s_image));
}




static void
opng_load_image_info(png_structp png_ptr, png_infop info_ptr, int load_meta)
{
    memset(&s_image, 0, sizeof(s_image));

    png_get_IHDR(png_ptr, info_ptr,
                 &s_image.width, &s_image.height, &s_image.bit_depth,
                 &s_image.color_type, &s_image.interlace_type,
                 &s_image.compression_type, &s_image.filter_type);
    s_image.row_pointers = png_get_rows(png_ptr, info_ptr);
    png_get_PLTE(png_ptr, info_ptr, &s_image.palette, &s_image.num_palette);



    if (png_get_tRNS(png_ptr, info_ptr,
                     &s_image.trans_alpha,
                     &s_image.num_trans, &s_image.trans_color_ptr))
    {



        if (s_image.trans_color_ptr != 0)
        {
            s_image.trans_color = *s_image.trans_color_ptr;
            s_image.trans_color_ptr = &s_image.trans_color;
        }
    }

    if (!load_meta)
        return;

    if (png_get_bKGD(png_ptr, info_ptr, &s_image.background_ptr))
    {

        s_image.background = *s_image.background_ptr;
        s_image.background_ptr = &s_image.background;
    }
    png_get_hIST(png_ptr, info_ptr, &s_image.hist);
    if (png_get_sBIT(png_ptr, info_ptr, &s_image.sig_bit_ptr))
    {

        s_image.sig_bit = *s_image.sig_bit_ptr;
        s_image.sig_bit_ptr = &s_image.sig_bit;
    }
    s_image.num_unknowns =
        png_get_unknown_chunks(png_ptr, info_ptr, &s_image.unknowns);
}




static void
opng_store_image_info(png_structp png_ptr, png_infop info_ptr, int store_meta)
{
    int i;

    { if (!(s_image.row_pointers != 0)) usr_panic("No info in image"); };

    png_set_IHDR(png_ptr, info_ptr,
                 s_image.width, s_image.height, s_image.bit_depth,
                 s_image.color_type, s_image.interlace_type,
                 s_image.compression_type, s_image.filter_type);
    png_set_rows(s_write_ptr, s_write_info_ptr, s_image.row_pointers);
    if (s_image.palette != 0)
        png_set_PLTE(png_ptr, info_ptr, s_image.palette, s_image.num_palette);



    if (s_image.trans_alpha != 0 || s_image.trans_color_ptr != 0)
        png_set_tRNS(png_ptr, info_ptr,
                     s_image.trans_alpha,
                     s_image.num_trans, s_image.trans_color_ptr);

    if (!store_meta)
        return;

    if (s_image.background_ptr != 0)
        png_set_bKGD(png_ptr, info_ptr, s_image.background_ptr);
    if (s_image.hist != 0)
        png_set_hIST(png_ptr, info_ptr, s_image.hist);
    if (s_image.sig_bit_ptr != 0)
        png_set_sBIT(png_ptr, info_ptr, s_image.sig_bit_ptr);
    if (s_image.num_unknowns != 0)
    {
        png_set_unknown_chunks(png_ptr, info_ptr,
                               s_image.unknowns, s_image.num_unknowns);

        for (i = 0; i < s_image.num_unknowns; ++i)
            png_set_unknown_chunk_location(png_ptr, info_ptr,
                                           i, s_image.unknowns[i].location);
    }
}




static void
opng_destroy_image_info(void)
{
    png_uint_32 i;
    int j;

    if (s_image.row_pointers == 0)
        return;

    for (i = 0; i < s_image.height; ++i)
        opng_free(s_image.row_pointers[i]);
    opng_free(s_image.row_pointers);
    opng_free(s_image.palette);
    opng_free(s_image.trans_alpha);
    opng_free(s_image.hist);
    for (j = 0; j < s_image.num_unknowns; ++j)
        opng_free(s_image.unknowns[j].data);
    opng_free(s_image.unknowns);







    memset(&s_image, 0, sizeof(s_image));
}




static void
opng_read_file(FILE *infile)
{
    const char *fmt_name;
    int num_img;
    png_uint_32 reductions;
    volatile opng_status_t status;

    status = OPNG_STATUS_OK;
    { jmp_buf *exception__prev[1]; jmp_buf exception__env; exception__prev[0] = the_exception_context->penv; the_exception_context->penv = &exception__env; if (setjmp(exception__env) == 0) { do
    {
        s_read_ptr = png_create_read_struct("1.6.40",
                                            0, opng_error, opng_warning);
        s_read_info_ptr = png_create_info_struct(s_read_ptr);
        if (s_read_info_ptr == 0)
            opng_throw_error("Can't create image decoder");


        png_set_keep_unknown_chunks(s_read_ptr,
                                    3, 0, 0);
        png_set_user_limits(s_read_ptr, ((png_uint_32)0x7fffffffL), ((png_uint_32)0x7fffffffL));


        opng_init_read_data();
        png_set_read_fn(s_read_ptr, infile, opng_read_data);
        fmt_name = 0;
        num_img = pngx_read_image(s_read_ptr, s_read_info_ptr,
                                  &fmt_name, 0);
        if (num_img <= 0)
            opng_throw_error("Unrecognized image file format");
        if (num_img > 1)
            s_process.status |= INPUT_HAS_MULTIPLE_IMAGES;
        if ((s_process.status & INPUT_IS_PNG_FILE) &&
            (s_process.status & INPUT_HAS_MULTIPLE_IMAGES))
        {

            fmt_name = (s_process.status & INPUT_HAS_PNG_SIGNATURE) ?
                       "APNG" : "APNG datastream";
        }
        { if (!(fmt_name != 0)) usr_panic("No format name from pngxtern"); };

        if (s_process.in_file_size == 0)
        {
            if (opng_fgetsize(infile, &s_process.in_file_size) < 0)
            {
                opng_print_warning("Can't get the correct file size");
                s_process.in_file_size = 0;
            }
        }
    }
    while (the_exception_context->caught = 0, the_exception_context->caught); } else { the_exception_context->caught = 1; } the_exception_context->penv = exception__prev[0]; } if (!the_exception_context->caught || ((status) = the_exception_context->v.etmp, 0)) { } else
    {
        if (opng_validate_image(s_read_ptr, s_read_info_ptr))
            { if (!(status == OPNG_STATUS_OK)) usr_panic("Mysterious error in validated image file"); }
                                                                   ;
    }

    { jmp_buf *exception__prev[1]; jmp_buf exception__env; exception__prev[0] = the_exception_context->penv; the_exception_context->penv = &exception__env; if (setjmp(exception__env) == 0) { do
    {
        if (status != OPNG_STATUS_OK)
            for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = status;


        if (strcmp(fmt_name, "PNG") != 0)
        {
            usr_printf("Importing %s", fmt_name);
            if (s_process.status & INPUT_HAS_MULTIPLE_IMAGES)
            {
                if (!(s_process.status & INPUT_IS_PNG_FILE))
                    usr_printf(" (multi-image or animation)");
                if (s_options.snip)
                    usr_printf("; snipping...");
            }
            usr_printf("\n");
        }
        opng_load_image_info(s_read_ptr, s_read_info_ptr, 1);
        opng_print_image_info(1, 1, 1, 1);
        usr_printf("\n");


        reductions = ((0x0001 | 0x0002) | (0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040 | 0x0080) | (0x0100 | 0x0200) | 0x1000) & ~0x1000;
        if (s_options.nb)
            reductions &= ~(0x0001 | 0x0002);
        if (s_options.nc)
            reductions &= ~(0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040 | 0x0080);
        if (s_options.np)
            reductions &= ~(0x0100 | 0x0200);
        if (s_options.nz && (s_process.status & INPUT_HAS_PNG_DATASTREAM))
        {

            reductions = 0x0000;
        }
        if (s_process.status & INPUT_HAS_DIGITAL_SIGNATURE)
        {

            reductions = 0x0000;
        }
        if ((s_process.status & INPUT_IS_PNG_FILE) &&
            (s_process.status & INPUT_HAS_MULTIPLE_IMAGES) &&
            (reductions != 0x0000) &&
            !s_options.snip)
        {
            usr_printf(
                "Can't reliably reduce APNG file; disabling reductions.\n"
                "(Did you want to -snip and optimize the first frame?)\n");
            reductions = 0x0000;
        }


        s_process.reductions =
            opng_reduce_image(s_read_ptr, s_read_info_ptr, reductions);


        if (s_process.reductions != 0x0000)
        {
            opng_load_image_info(s_read_ptr, s_read_info_ptr, 1);
            usr_printf("Reducing image to ");
            opng_print_image_info(0, 1, 1, 0);
            usr_printf("\n");
        }


        if (s_options.interlace >= 0 &&
            s_image.interlace_type != s_options.interlace)
        {
            s_image.interlace_type = s_options.interlace;

            s_process.status |= OUTPUT_NEEDS_NEW_IDAT;
        }
    }
    while (the_exception_context->caught = 0, the_exception_context->caught); } else { the_exception_context->caught = 1; } the_exception_context->penv = exception__prev[0]; } if (!the_exception_context->caught || ((status) = the_exception_context->v.etmp, 0)) { } else
    {

        png_data_freer(s_read_ptr, s_read_info_ptr,
                       1, 0xffffU);
        png_destroy_read_struct(&s_read_ptr, &s_read_info_ptr, 0);
        for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = status;
    }




    png_data_freer(s_read_ptr, s_read_info_ptr,
                   2, 0xffffU);
    png_destroy_read_struct(&s_read_ptr, &s_read_info_ptr, 0);
}







static void
opng_write_file(FILE *outfile,
                int compression_level, int memory_level,
                int compression_strategy, int filter)
{
    volatile opng_status_t status;

    { if (!(compression_level >= 1 && compression_level <= 9 && memory_level >= 1 && memory_level <= 9 && compression_strategy >= 0 && compression_strategy <= 3 && filter >= 0 && filter <= 5)) usr_panic("Invalid encoding parameters"); }







                                              ;

    status = OPNG_STATUS_OK;
    { jmp_buf *exception__prev[1]; jmp_buf exception__env; exception__prev[0] = the_exception_context->penv; the_exception_context->penv = &exception__env; if (setjmp(exception__env) == 0) { do
    {
        s_write_ptr = png_create_write_struct("1.6.40",
                                              0, opng_error, opng_warning);
        s_write_info_ptr = png_create_info_struct(s_write_ptr);
        if (s_write_info_ptr == 0)
            opng_throw_error("Can't create image encoder");

        png_set_compression_level(s_write_ptr, compression_level);
        png_set_compression_mem_level(s_write_ptr, memory_level);
        png_set_compression_strategy(s_write_ptr, compression_strategy);
        png_set_filter(s_write_ptr, 0,
                       k_filter_table[filter]);
        if (compression_strategy != 2 &&
            compression_strategy != 3)
        {
            if (s_options.window_bits > 0)
                png_set_compression_window_bits(s_write_ptr,
                                                s_options.window_bits);
        }
        else
        {



            png_set_compression_window_bits(s_write_ptr, 9);

        }


        png_set_keep_unknown_chunks(s_write_ptr,
                                    3, 0, 0);
        png_set_user_limits(s_write_ptr, ((png_uint_32)0x7fffffffL), ((png_uint_32)0x7fffffffL));


        opng_store_image_info(s_write_ptr, s_write_info_ptr, outfile != 0);
        opng_init_write_data();
        png_set_write_fn(s_write_ptr, outfile, opng_write_data, 0);
        png_write_png(s_write_ptr, s_write_info_ptr, 0, 0);
    }
    while (the_exception_context->caught = 0, the_exception_context->caught); } else { the_exception_context->caught = 1; } the_exception_context->penv = exception__prev[0]; } if (!the_exception_context->caught || ((status) = the_exception_context->v.etmp, 0)) { } else
    {

        s_process.out_idat_size = k_idat_size_max + 1;
    }


    png_destroy_write_struct(&s_write_ptr, &s_write_info_ptr);

    if (status != OPNG_STATUS_OK)
        for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = status;
}




static void
opng_copy_file(FILE *infile, FILE *outfile)
{
    volatile png_bytep buf;
    const png_uint_32 buf_size_incr = 0x1000;
    png_uint_32 buf_size, length;
    png_byte chunk_hdr[8];
    volatile opng_status_t status;

    s_write_ptr = png_create_write_struct("1.6.40",
                                          0, opng_error, opng_warning);
    if (s_write_ptr == 0)
        opng_throw_error("Can't create image encoder");
    opng_init_write_data();
    png_set_write_fn(s_write_ptr, outfile, opng_write_data, 0);

    status = OPNG_STATUS_OK;
    { jmp_buf *exception__prev[1]; jmp_buf exception__env; exception__prev[0] = the_exception_context->penv; the_exception_context->penv = &exception__env; if (setjmp(exception__env) == 0) { do
    {
        buf = 0;
        buf_size = 0;


        png_write_sig(s_write_ptr);



        do
        {
            if (fread(chunk_hdr, 8, 1, infile) != 1)
                opng_throw_error("Read error");
            length = (((png_uint_32)(*(chunk_hdr)) << 24) + ((png_uint_32)(*((chunk_hdr) + 1)) << 16) + ((png_uint_32)(*((chunk_hdr) + 2)) << 8) + ((png_uint_32)(*((chunk_hdr) + 3))));
            if (length > ((png_uint_32)0x7fffffffL))
            {
                if (buf == 0 && length == 0x89504e47UL)
                {

                    continue;
                }
                opng_throw_error("Data error");
            }
            if (length + 4 > buf_size)
            {
                png_free(s_write_ptr, buf);
                buf_size =
                    (((length + 4) + (buf_size_incr - 1)) / buf_size_incr) *
                    buf_size_incr;
                buf = (png_bytep)png_malloc(s_write_ptr, buf_size);

            }
            if (fread(buf, length + 4, 1, infile) != 1)
                opng_throw_error("Read error");
            png_write_chunk(s_write_ptr, chunk_hdr + 4, buf, length);
        } while (memcmp(chunk_hdr + 4, k_sig_IEND, 4) != 0);
    }
    while (the_exception_context->caught = 0, the_exception_context->caught); } else { the_exception_context->caught = 1; } the_exception_context->penv = exception__prev[0]; } if (!the_exception_context->caught || ((status) = the_exception_context->v.etmp, 0)) { } else
    {
    }

    png_free(s_write_ptr, buf);
    png_destroy_write_struct(&s_write_ptr, 0);

    if (status != OPNG_STATUS_OK)
        for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = status;
}




static void
opng_init_iteration(opng_bitset_t cmdline_set, opng_bitset_t mask_set,
                    const char *preset, opng_bitset_t *output_set)
{
    opng_bitset_t preset_set;
    int check;

    *output_set = cmdline_set & mask_set;
    if (*output_set == 0 && cmdline_set != 0)
        opng_throw_error("Iteration parameter(s) out of range");
    if (s_options.optim_level >= 0 || *output_set == 0)
    {
        check =
            opng_strparse_rangeset_to_bitset(&preset_set, preset, mask_set);
        { if (!(check == 0)) usr_panic("[internal] Invalid preset"); };
        *output_set |= preset_set & mask_set;
    }
}




static void
opng_init_iterations(void)
{
    opng_bitset_t compr_level_set, mem_level_set, strategy_set, filter_set;
    opng_bitset_t strategy_singles_set;
    int preset_index;
    int t1, t2;





    if (s_options.full || (s_process.status & OUTPUT_NEEDS_NEW_IDAT))
        s_process.max_idat_size = k_idat_size_max;
    else
    {
        { if (!(s_process.in_idat_size > 0)) usr_panic("No IDAT in input"); };






        s_process.max_idat_size =
            s_process.in_idat_size + s_process.in_plte_trns_size;
    }





    preset_index = s_options.optim_level;
    if (preset_index < 0)
        preset_index = 2;
    else if (preset_index > 7)
        preset_index = 7;




    opng_init_iteration(s_options.compr_level_set, ((1 << (9+1)) - (1 << 1)),
                        k_presets[preset_index].compr_level, &compr_level_set);
    opng_init_iteration(s_options.mem_level_set, ((1 << (9+1)) - (1 << 1)),
                        k_presets[preset_index].mem_level, &mem_level_set);
    opng_init_iteration(s_options.strategy_set, ((1 << (3+1)) - (1 << 0)),
                        k_presets[preset_index].strategy, &strategy_set);
    opng_init_iteration(s_options.filter_set, ((1 << (5+1)) - (1 << 0)),
                        k_presets[preset_index].filter, &filter_set);


    if (compr_level_set == 0)
        (*(&compr_level_set) |= (1U << (9)));
    if (mem_level_set == 0)
        (*(&mem_level_set) |= (1U << (8)));
    if (s_image.bit_depth < 8 || s_image.palette != 0)
    {
        if (strategy_set == 0)
            (*(&strategy_set) |= (1U << (0)));
        if (filter_set == 0)
            (*(&filter_set) |= (1U << (0)));
    }
    else
    {
        if (strategy_set == 0)
            (*(&strategy_set) |= (1U << (1)));
        if (filter_set == 0)
            (*(&filter_set) |= (1U << (5)));
    }


    s_process.compr_level_set = compr_level_set;
    s_process.mem_level_set = mem_level_set;
    s_process.strategy_set = strategy_set;
    s_process.filter_set = filter_set;
    strategy_singles_set = (1 << 2) | (1 << 3);
    t1 = opng_bitset_count(compr_level_set) *
         opng_bitset_count(strategy_set & ~strategy_singles_set);
    t2 = opng_bitset_count(strategy_set & strategy_singles_set);
    s_process.num_iterations = (t1 + t2) *
                               opng_bitset_count(mem_level_set) *
                               opng_bitset_count(filter_set);
    { if (!(s_process.num_iterations > 0)) usr_panic("Invalid iteration parameters"); };
}




static void
opng_iterate(void)
{
    opng_bitset_t compr_level_set, mem_level_set, strategy_set, filter_set;
    int compr_level, mem_level, strategy, filter;
    int counter;
    int line_reused;

    { if (!(s_process.num_iterations > 0)) usr_panic("Iterations not initialized"); };

    compr_level_set = s_process.compr_level_set;
    mem_level_set = s_process.mem_level_set;
    strategy_set = s_process.strategy_set;
    filter_set = s_process.filter_set;

    if ((s_process.num_iterations == 1) &&
        (s_process.status & OUTPUT_NEEDS_NEW_IDAT))
    {

        s_process.best_idat_size = 0;
        s_process.best_compr_level = opng_bitset_find_first(compr_level_set);
        s_process.best_mem_level = opng_bitset_find_first(mem_level_set);
        s_process.best_strategy = opng_bitset_find_first(strategy_set);
        s_process.best_filter = opng_bitset_find_first(filter_set);
        return;
    }


    s_process.best_idat_size = k_idat_size_max + 1;
    s_process.best_compr_level = -1;
    s_process.best_mem_level = -1;
    s_process.best_strategy = -1;
    s_process.best_filter = -1;


    usr_printf("\nTrying:\n");
    line_reused = 0;
    counter = 0;
    for (filter = 0;
         filter <= 5;
         ++filter)
    {
        if (!(((filter_set) & (1U << (filter))) != 0))
            continue;
        for (strategy = 0;
             strategy <= 3;
             ++strategy)
        {
            if (!(((strategy_set) & (1U << (strategy))) != 0))
                continue;
            if (strategy == 2)
            {




                compr_level_set = 0;
                (*(&compr_level_set) |= (1U << (1)));
            }
            else if (strategy == 3)
            {




                compr_level_set = 0;
                (*(&compr_level_set) |= (1U << (9)));
            }
            else
            {

                compr_level_set = s_process.compr_level_set;
            }
            for (compr_level = 9;
                 compr_level >= 1;
                 --compr_level)
            {
                if (!(((compr_level_set) & (1U << (compr_level))) != 0))
                    continue;
                for (mem_level = 9;
                     mem_level >= 1;
                     --mem_level)
                {
                    if (!(((mem_level_set) & (1U << (mem_level))) != 0))
                        continue;
                    usr_printf("  zc = %d  zm = %d  zs = %d  f = %d",
                               compr_level, mem_level, strategy, filter);
                    usr_progress(counter, s_process.num_iterations);
                    ++counter;
                    opng_write_file(0,
                                    compr_level, mem_level, strategy, filter);
                    if (s_process.out_idat_size > k_idat_size_max)
                    {
                        if (s_options.verbose)
                        {
                            usr_printf("\t\tIDAT too big\n");
                            line_reused = 0;
                        }
                        else
                        {
                            usr_print_cntrl('\r');
                            line_reused = 1;
                        }
                        continue;
                    }
                    usr_printf("\t\tIDAT size = %" "lu" "\n",
                               s_process.out_idat_size);
                    line_reused = 0;
                    if (s_process.best_idat_size < s_process.out_idat_size)
                    {



                        continue;
                    }
                    if (s_process.best_idat_size == s_process.out_idat_size &&
                        (s_process.best_strategy == 2 ||
                         s_process.best_strategy == 3))
                    {




                        continue;
                    }
                    s_process.best_compr_level = compr_level;
                    s_process.best_mem_level = mem_level;
                    s_process.best_strategy = strategy;
                    s_process.best_filter = filter;
                    s_process.best_idat_size = s_process.out_idat_size;
                    if (!s_options.full)
                        s_process.max_idat_size = s_process.out_idat_size;
                }
            }
        }
    }
    if (line_reused)
        usr_print_cntrl(-31);

    { if (!(counter == s_process.num_iterations)) usr_panic("Inconsistent iteration counter"); }
                                                 ;
    usr_progress(counter, s_process.num_iterations);
}




static void
opng_finish_iterations(void)
{
    if (s_process.best_idat_size + s_process.out_plte_trns_size <
        s_process.in_idat_size + s_process.in_plte_trns_size)
        s_process.status |= OUTPUT_NEEDS_NEW_IDAT;
    if (s_process.status & OUTPUT_NEEDS_NEW_IDAT)
    {
        if (s_process.best_idat_size <= k_idat_size_max)
        {
            usr_printf("\nSelecting parameters:\n");
            usr_printf("  zc = %d  zm = %d  zs = %d  f = %d",
                       s_process.best_compr_level,
                       s_process.best_mem_level,
                       s_process.best_strategy,
                       s_process.best_filter);
            if (s_process.best_idat_size > 0)
            {

                usr_printf("\t\tIDAT size = %" "lu",
                           s_process.best_idat_size);
            }
            usr_printf("\n");
        }
        else
        {

            usr_printf("  zc = *  zm = *  zs = *  f = *\t\tIDAT size > %s\n",
                       k_idat_size_max_string);
        }
    }
}




static void
opng_optimize_impl(const char *infile_name)
{
    static FILE *infile, *outfile;
    static const char *infile_name_local;
    static const char *outfile_name, *bakfile_name;
    static int new_outfile, has_backup;
    char name_buf[1024], tmp_buf[1024];
    volatile opng_status_t status;

    memset(&s_process, 0, sizeof(s_process));
    if (s_options.force)
        s_process.status |= OUTPUT_NEEDS_NEW_IDAT;

    infile_name_local = infile_name;
    if ((infile = fopen(infile_name_local, "rb")) == 0)
        opng_throw_error("Can't open the input file");

    status = OPNG_STATUS_OK;
    { jmp_buf *exception__prev[1]; jmp_buf exception__env; exception__prev[0] = the_exception_context->penv; the_exception_context->penv = &exception__env; if (setjmp(exception__env) == 0) { do
    {
        opng_read_file(infile);
    }
    while (the_exception_context->caught = 0, the_exception_context->caught); } else { the_exception_context->caught = 1; } the_exception_context->penv = exception__prev[0]; } if (!the_exception_context->caught || ((status) = the_exception_context->v.etmp, 0)) { } else
    {
        { if (!(status != OPNG_STATUS_OK)) usr_panic("opng_read_file should throw errors only"); }
                                                              ;
    }
    fclose(infile);
    if (status != OPNG_STATUS_OK)
        for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = status;


    if (s_process.status & INPUT_HAS_ERRORS)
    {
        usr_printf("Recoverable errors found in input.");
        if (s_options.fix)
        {
            usr_printf(" Fixing...\n");
            s_process.status |= OUTPUT_NEEDS_NEW_FILE;
        }
        else
        {
            usr_printf(" Rerun " "OptiPNG" " with -fix enabled.\n");
            opng_throw_error("Previous error(s) not fixed");
        }
    }


    if (s_process.status & INPUT_HAS_JUNK)
        s_process.status |= OUTPUT_NEEDS_NEW_FILE;


    if (!(s_process.status & INPUT_HAS_PNG_SIGNATURE))
        s_process.status |= OUTPUT_NEEDS_NEW_FILE;
    if (s_process.status & INPUT_HAS_PNG_DATASTREAM)
    {
        if (s_options.nz && (s_process.status & OUTPUT_NEEDS_NEW_IDAT))
        {
            usr_printf(
                "IDAT recoding is necessary, but is disabled by the user.\n");
            opng_throw_error("Can't continue");
        }
    }
    else
        s_process.status |= OUTPUT_NEEDS_NEW_IDAT;


    if (s_process.status & INPUT_HAS_DIGITAL_SIGNATURE)
    {
        usr_printf("Digital signature found in input.");
        if (s_options.force)
        {
            usr_printf(" Erasing...\n");
            s_process.status |= OUTPUT_NEEDS_NEW_FILE;
        }
        else
        {
            usr_printf(" Rerun " "OptiPNG" " with -force enabled.\n");
            opng_throw_error("Can't optimize digitally-signed files");
        }
    }


    if (s_process.status & INPUT_HAS_MULTIPLE_IMAGES)
    {
        if (!s_options.snip && !(s_process.status & INPUT_IS_PNG_FILE))
        {
            usr_printf("Conversion to PNG requires snipping. "
                       "Rerun " "OptiPNG" " with -snip enabled.\n");
            opng_throw_error("Incompatible input format");
        }
    }
    if (s_options.snip && (s_process.status & INPUT_HAS_APNG))
        s_process.status |= OUTPUT_NEEDS_NEW_FILE;


    if (s_process.status & INPUT_HAS_STRIPPED_DATA)
        usr_printf("Stripping metadata...\n");


    outfile_name = 0;
    if (!(s_process.status & INPUT_IS_PNG_FILE))
    {
        if (opng_path_replace_ext(name_buf, sizeof(name_buf),
                                  infile_name_local, ".png") == 0)
            opng_throw_error("Can't create the output file (name too long)");
        outfile_name = name_buf;
    }
    if (s_options.out_name != 0)
    {

        outfile_name = s_options.out_name;
    }
    if (s_options.dir_name != 0)
    {
        const char *tmp_name;
        if (outfile_name != 0)
        {
            strcpy(tmp_buf, outfile_name);
            tmp_name = tmp_buf;
        }
        else
            tmp_name = infile_name_local;
        if (opng_path_replace_dir(name_buf, sizeof(name_buf),
                                  tmp_name, s_options.dir_name) == 0)
            opng_throw_error("Can't create the output file (name too long)");
        outfile_name = name_buf;
    }
    if (outfile_name == 0)
    {
        outfile_name = infile_name_local;
        new_outfile = 0;
    }
    else
    {
        int test_eq = opng_os_test_file_equiv(infile_name_local, outfile_name);
        if (test_eq >= 0)
        {



            new_outfile = (test_eq == 0);
        }
        else
        {



            new_outfile = (strcmp(infile_name_local, outfile_name) != 0);
        }
    }


    bakfile_name = tmp_buf;
    if (new_outfile)
    {
        if (opng_path_make_backup(tmp_buf, sizeof(tmp_buf),
                                  outfile_name) == 0)
            bakfile_name = 0;
    }
    else
    {
        if (opng_path_make_backup(tmp_buf, sizeof(tmp_buf),
                                  infile_name_local) == 0)
            bakfile_name = 0;
    }

    if (bakfile_name == 0)
        opng_throw_error("Can't create backup file (name too long)");

    if (!s_options.simulate &&
        opng_os_test_file_access(outfile_name, "e") == 0)
    {
        if (!s_options.backup && !s_options.clobber && new_outfile)
        {
            usr_printf("The output file exists. "
                       "Rerun " "OptiPNG" " with -backup enabled.\n");
            opng_throw_error("Can't overwrite the output file");
        }
        if (opng_os_test_file_access(outfile_name, "fw") != 0 ||
            (!s_options.clobber &&
             opng_os_test_file_access(bakfile_name, "e") == 0))
        {
            usr_printf("A backup file already exists. "
                       "Rerun " "OptiPNG" " with -clobber enabled.\n");
            opng_throw_error("Can't back up the existing output file");
        }
    }


    if (s_process.status & INPUT_HAS_PNG_DATASTREAM)
        usr_printf("Input IDAT size = %" "lu" " bytes\n",
                   s_process.in_idat_size);
    usr_printf("Input file size = %" "lu" " bytes\n",
               s_process.in_file_size);


    if (!s_options.nz || (s_process.status & OUTPUT_NEEDS_NEW_IDAT))
    {
        opng_init_iterations();
        opng_iterate();
        opng_finish_iterations();
    }
    if (s_process.status & OUTPUT_NEEDS_NEW_IDAT)
    {
        s_process.status |= OUTPUT_NEEDS_NEW_FILE;
        opng_check_idat_size(s_process.best_idat_size);
    }


    if (!(s_process.status & OUTPUT_NEEDS_NEW_FILE))
    {
        usr_printf("\n%s is already optimized.\n", infile_name_local);
        if (!new_outfile)
            return;
    }
    if (s_options.simulate)
    {
        usr_printf("\nNo output: simulation mode.\n");
        return;
    }


    if (new_outfile)
    {
        usr_printf("\nOutput file: %s\n", outfile_name);
        if (s_options.dir_name != 0)
            opng_os_create_dir(s_options.dir_name);
        has_backup = 0;
        if (opng_os_test_file_access(outfile_name, "e") == 0)
        {
            if (opng_os_rename(outfile_name, bakfile_name,
                               s_options.clobber) != 0)
                opng_throw_error("Can't back up the output file");
            has_backup = 1;
        }
    }
    else
    {
        if (opng_os_rename(infile_name_local, bakfile_name,
                           s_options.clobber) != 0)
            opng_throw_error("Can't back up the input file");
        has_backup = 1;
    }

    outfile = fopen(outfile_name, "wb");
    { jmp_buf *exception__prev[1]; jmp_buf exception__env; exception__prev[0] = the_exception_context->penv; the_exception_context->penv = &exception__env; if (setjmp(exception__env) == 0) { do
    {
        if (outfile == 0)
            opng_throw_error("Can't open the output file");
        if (s_process.status & OUTPUT_NEEDS_NEW_IDAT)
        {

            opng_write_file(outfile,
                            s_process.best_compr_level,
                            s_process.best_mem_level,
                            s_process.best_strategy,
                            s_process.best_filter);
        }
        else
        {

            infile = fopen(new_outfile ? infile_name_local : bakfile_name,
                           "rb");
            if (infile == 0)
                opng_throw_error("Can't reopen the input file");
            { jmp_buf *exception__prev[1]; jmp_buf exception__env; exception__prev[0] = the_exception_context->penv; the_exception_context->penv = &exception__env; if (setjmp(exception__env) == 0) { do
            {
                if (s_process.in_datastream_offset > 0 &&
                    opng_fseeko(infile, s_process.in_datastream_offset,
                                0) != 0)
                    opng_throw_error("Can't reposition the input file");
                s_process.best_idat_size = s_process.in_idat_size;
                opng_copy_file(infile, outfile);
            }
            while (the_exception_context->caught = 0, the_exception_context->caught); } else { the_exception_context->caught = 1; } the_exception_context->penv = exception__prev[0]; } if (!the_exception_context->caught || ((status) = the_exception_context->v.etmp, 0)) { } else
            {
                { if (!(status != OPNG_STATUS_OK)) usr_panic("opng_copy_file should throw errors only"); }
                                                                      ;
            }
            fclose(infile);
            if (status != OPNG_STATUS_OK)
                for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = status;
        }
    }
    while (the_exception_context->caught = 0, the_exception_context->caught); } else { the_exception_context->caught = 1; } the_exception_context->penv = exception__prev[0]; } if (!the_exception_context->caught || ((status) = the_exception_context->v.etmp, 0)) { } else
    {
        if (outfile != 0)
            fclose(outfile);

        if (has_backup)
        {
            if (opng_os_rename(bakfile_name,
                               new_outfile ? outfile_name : infile_name_local,
                               1) != 0)
                opng_print_warning(
                    "Can't recover the original file from backup");
        }
        else
        {
            { if (!(new_outfile)) usr_panic("Overwrote input with no temporary backup"); }
                                                                   ;
            if (opng_os_unlink(outfile_name) != 0)
                opng_print_warning("Can't remove the broken output file");
        }
        for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = status;
    }
    fclose(outfile);




    if (s_options.preserve)
        opng_os_copy_file_attr(new_outfile ? infile_name_local : bakfile_name,
                               outfile_name);


    if (!s_options.backup && !new_outfile)
    {
        if (opng_os_unlink(bakfile_name) != 0)
            opng_print_warning("Can't remove the backup file");
    }


    usr_printf("\nOutput IDAT size = %" "lu" " bytes",
               s_process.out_idat_size);
    if (s_process.status & INPUT_HAS_PNG_DATASTREAM)
    {
        usr_printf(" (");
        opng_print_fsize_difference(s_process.in_idat_size,
                                    s_process.out_idat_size, 0);
        usr_printf(")");
    }
    usr_printf("\nOutput file size = %" "lu" " bytes (",
               s_process.out_file_size);
    opng_print_fsize_difference(s_process.in_file_size,
                                s_process.out_file_size, 1);
    usr_printf(")\n");
}




int
opng_initialize(const struct opng_options *init_options,
                const struct opng_ui *init_ui)
{

    usr_printf = init_ui->printf_fn;
    usr_print_cntrl = init_ui->print_cntrl_fn;
    usr_progress = init_ui->progress_fn;
    usr_panic = init_ui->panic_fn;
    if (usr_printf == 0 ||
        usr_print_cntrl == 0 ||
        usr_progress == 0 ||
        usr_panic == 0)
        return -1;


    s_options = *init_options;
    if (s_options.optim_level == 0)
    {
        s_options.nb = s_options.nc = s_options.np = 1;
        s_options.nz = 1;
    }


    memset(&s_summary, 0, sizeof(s_summary));
    s_engine.started = 1;
    return 0;
}




int
opng_optimize(const char *infile_name)
{
    opng_status_t status;
    volatile int result;

    { if (!(s_engine.started)) usr_panic("The OptiPNG engine is not running"); };

    usr_printf("** Processing: %s\n", infile_name);
    ++s_summary.file_count;
    opng_clear_image_info();
    { jmp_buf *exception__prev[1]; jmp_buf exception__env; exception__prev[0] = the_exception_context->penv; the_exception_context->penv = &exception__env; if (setjmp(exception__env) == 0) { do
    {
        opng_optimize_impl(infile_name);
        if (s_process.status & INPUT_HAS_ERRORS)
        {
            ++s_summary.err_count;
            ++s_summary.fix_count;
        }
        if (s_process.status & INPUT_HAS_MULTIPLE_IMAGES)
        {
            if (s_options.snip)
                ++s_summary.snip_count;
        }
        result = 0;
    }
    while (the_exception_context->caught = 0, the_exception_context->caught); } else { the_exception_context->caught = 1; } the_exception_context->penv = exception__prev[0]; } if (!the_exception_context->caught || ((status) = the_exception_context->v.etmp, 0)) { } else
    {
        { if (!(status != OPNG_STATUS_OK)) usr_panic("opng_optimize_impl should throw errors only"); }
                                                                  ;
        ++s_summary.err_count;
        result = -1;
    }
    opng_destroy_image_info();
    usr_printf("\n");
    return result;
}




int
opng_finalize(void)
{

    if (s_options.verbose ||
        s_summary.snip_count > 0 ||
        s_summary.err_count > 0)
    {
        usr_printf("** Status report\n");
        usr_printf("%u file(s) have been processed.\n", s_summary.file_count);
        if (s_summary.snip_count > 0)
        {
            usr_printf("%u multi-image file(s) have been snipped.\n",
                       s_summary.snip_count);
        }
        if (s_summary.err_count > 0)
        {
            usr_printf("%u error(s) have been encountered.\n",
                       s_summary.err_count);
            if (s_summary.fix_count > 0)
                usr_printf("%u erroneous file(s) have been fixed.\n",
                           s_summary.fix_count);
        }
    }


    s_engine.started = 0;
    return 0;
}
# 0 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c"
# 11 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optipng.h" 1
# 14 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optipng.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/bitset.h" 1
# 14 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/bitset.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/limits.h" 1
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/limits.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef unsigned chtype;
typedef chtype attr_t;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/limits.h" 2
# 15 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/bitset.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stddef.h" 1
# 16 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/bitset.h" 2
# 26 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/bitset.h"
typedef unsigned int opng_bitset_t;
# 45 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/bitset.h"
enum
{
    OPNG_BITSET_ELT_MIN = 0,
    OPNG_BITSET_ELT_MAX = (int)((sizeof(opng_bitset_t) * 8) - 1)
};
# 174 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/bitset.h"
unsigned int
opng_bitset_count(opng_bitset_t set);







int
opng_bitset_find_first(opng_bitset_t set);







int
opng_bitset_find_next(opng_bitset_t set, int elt);







int
opng_bitset_find_last(opng_bitset_t set);







int
opng_bitset_find_prev(opng_bitset_t set, int elt);
# 241 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/bitset.h"
int
opng_strparse_rangeset_to_bitset(opng_bitset_t *out_set,
                                 const char *rangeset_str,
                                 opng_bitset_t mask_set);
# 253 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/bitset.h"
size_t
opng_strformat_bitset_as_rangeset(char *out_buf,
                                  size_t out_buf_size,
                                  opng_bitset_t bitset);
# 15 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optipng.h" 2
# 25 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optipng.h"
struct opng_options
{

    int backup;
    int clobber;
    int debug;
    int fix;
    int force;
    int full;
    int preserve;
    int quiet;
    int simulate;
    int verbose;
    const char *out_name;
    const char *dir_name;
    const char *log_name;


    int interlace;
    int nb, nc, np, nz;
    int optim_level;
    opng_bitset_t compr_level_set;
    opng_bitset_t mem_level_set;
    opng_bitset_t strategy_set;
    opng_bitset_t filter_set;
    int window_bits;


    int snip;
    int strip_all;
};





struct opng_ui
{
    void (*printf_fn)(const char *fmt, ...);
    void (*print_cntrl_fn)(int cntrl_code);
    void (*progress_fn)(unsigned long current_step, unsigned long total_steps);
    void (*panic_fn)(const char *msg);
};





int opng_initialize(const struct opng_options *options,
                    const struct opng_ui *ui);




int opng_optimize(const char *infile_name);




int opng_finalize(void);
# 12 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/proginfo.h" 1
# 13 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2

# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/limits.h" 1
# 15 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdarg.h" 1
# 16 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 1
# 17 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 18 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/string.h" 1
# 19 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2

# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/opngreduc/opngreduc.h" 1
# 12 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/opngreduc/opngreduc.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h" 1
# 330 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pnglibconf.h" 1
# 331 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h" 2




# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h" 1
# 31 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/limits.h" 1
# 32 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stddef.h" 1
# 33 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h" 2
# 46 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 1
# 47 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h" 2
# 481 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h"
   typedef unsigned char png_byte;







   typedef short png_int_16;







   typedef unsigned short png_uint_16;





   typedef int png_int_32;







   typedef unsigned int png_uint_32;
# 523 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h"
typedef size_t png_size_t;
typedef ptrdiff_t png_ptrdiff_t;
# 557 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h"
   typedef size_t png_alloc_size_t;
# 574 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h"
typedef png_int_32 png_fixed_point;


typedef void * png_voidp;
typedef const void * png_const_voidp;
typedef png_byte * png_bytep;
typedef const png_byte * png_const_bytep;
typedef png_uint_32 * png_uint_32p;
typedef const png_uint_32 * png_const_uint_32p;
typedef png_int_32 * png_int_32p;
typedef const png_int_32 * png_const_int_32p;
typedef png_uint_16 * png_uint_16p;
typedef const png_uint_16 * png_const_uint_16p;
typedef png_int_16 * png_int_16p;
typedef const png_int_16 * png_const_int_16p;
typedef char * png_charp;
typedef const char * png_const_charp;
typedef png_fixed_point * png_fixed_point_p;
typedef const png_fixed_point * png_const_fixed_point_p;
typedef size_t * png_size_tp;
typedef const size_t * png_const_size_tp;


typedef FILE * png_FILE_p;
# 606 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/pngconf.h"
typedef png_byte * * png_bytepp;
typedef png_uint_32 * * png_uint_32pp;
typedef png_int_32 * * png_int_32pp;
typedef png_uint_16 * * png_uint_16pp;
typedef png_int_16 * * png_int_16pp;
typedef const char * * png_const_charpp;
typedef char * * png_charpp;
typedef png_fixed_point * * png_fixed_point_pp;





typedef char * * * png_charppp;
# 336 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h" 2
# 431 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
typedef char* png_libpng_version_1_6_40;







typedef struct png_struct_def png_struct;
typedef const png_struct * png_const_structp;
typedef png_struct * png_structp;
typedef png_struct * * png_structpp;
# 453 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
typedef struct png_info_def png_info;
typedef png_info * png_infop;
typedef const png_info * png_const_infop;
typedef png_info * * png_infopp;
# 469 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
typedef png_struct * png_structrp;
typedef const png_struct * png_const_structrp;
typedef png_info * png_inforp;
typedef const png_info * png_const_inforp;





typedef struct png_color_struct
{
   png_byte red;
   png_byte green;
   png_byte blue;
} png_color;
typedef png_color * png_colorp;
typedef const png_color * png_const_colorp;
typedef png_color * * png_colorpp;

typedef struct png_color_16_struct
{
   png_byte index;
   png_uint_16 red;
   png_uint_16 green;
   png_uint_16 blue;
   png_uint_16 gray;
} png_color_16;
typedef png_color_16 * png_color_16p;
typedef const png_color_16 * png_const_color_16p;
typedef png_color_16 * * png_color_16pp;

typedef struct png_color_8_struct
{
   png_byte red;
   png_byte green;
   png_byte blue;
   png_byte gray;
   png_byte alpha;
} png_color_8;
typedef png_color_8 * png_color_8p;
typedef const png_color_8 * png_const_color_8p;
typedef png_color_8 * * png_color_8pp;





typedef struct png_sPLT_entry_struct
{
   png_uint_16 red;
   png_uint_16 green;
   png_uint_16 blue;
   png_uint_16 alpha;
   png_uint_16 frequency;
} png_sPLT_entry;
typedef png_sPLT_entry * png_sPLT_entryp;
typedef const png_sPLT_entry * png_const_sPLT_entryp;
typedef png_sPLT_entry * * png_sPLT_entrypp;






typedef struct png_sPLT_struct
{
   png_charp name;
   png_byte depth;
   png_sPLT_entryp entries;
   png_int_32 nentries;
} png_sPLT_t;
typedef png_sPLT_t * png_sPLT_tp;
typedef const png_sPLT_t * png_const_sPLT_tp;
typedef png_sPLT_t * * png_sPLT_tpp;
# 600 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
typedef struct png_time_struct
{
   png_uint_16 year;
   png_byte month;
   png_byte day;
   png_byte hour;
   png_byte minute;
   png_byte second;
} png_time;
typedef png_time * png_timep;
typedef const png_time * png_const_timep;
typedef png_time * * png_timepp;
# 622 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
typedef struct png_unknown_chunk_t
{
   png_byte name[5];
   png_byte *data;
   size_t size;







   png_byte location;
}
png_unknown_chunk;

typedef png_unknown_chunk * png_unknown_chunkp;
typedef const png_unknown_chunk * png_const_unknown_chunkp;
typedef png_unknown_chunk * * png_unknown_chunkpp;
# 754 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
typedef struct png_row_info_struct
{
   png_uint_32 width;
   size_t rowbytes;
   png_byte color_type;
   png_byte bit_depth;
   png_byte channels;
   png_byte pixel_depth;
} png_row_info;

typedef png_row_info * png_row_infop;
typedef png_row_info * * png_row_infopp;
# 775 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
typedef void ( *png_error_ptr) (png_structp, png_const_charp);
typedef void ( *png_rw_ptr) (png_structp, png_bytep, size_t);
typedef void ( *png_flush_ptr) (png_structp);
typedef void ( *png_read_status_ptr) (png_structp, png_uint_32, int)
         ;
typedef void ( *png_write_status_ptr) (png_structp, png_uint_32, int)
         ;
# 867 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
typedef png_voidp ( *png_malloc_ptr) (png_structp, png_alloc_size_t)
                      ;
typedef void ( *png_free_ptr) (png_structp, png_voidp);
# 901 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern png_uint_32 ( png_access_version_number) (void);




extern void ( png_set_sig_bytes) (png_structrp png_ptr, int num_bytes);






extern int ( png_sig_cmp) (png_const_bytep sig, size_t start, size_t num_to_check)
                         ;







extern png_structp ( png_create_read_struct) (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn)


                  ;


extern png_structp ( png_create_write_struct) (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn)


                  ;

extern size_t ( png_get_compression_buffer_size) (png_const_structrp png_ptr)
                                 ;

extern void ( png_set_compression_buffer_size) (png_structrp png_ptr, size_t size)
                 ;
# 963 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_longjmp) (png_const_structrp png_ptr, int val)
                 ;



extern int ( png_reset_zstream) (png_structrp png_ptr);
# 986 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_write_sig) (png_structrp png_ptr);


extern void ( png_write_chunk) (png_structrp png_ptr, png_const_bytep chunk_name, png_const_bytep data, size_t length)
                                                     ;


extern void ( png_write_chunk_start) (png_structrp png_ptr, png_const_bytep chunk_name, png_uint_32 length)
                                                    ;


extern void ( png_write_chunk_data) (png_structrp png_ptr, png_const_bytep data, size_t length)
                                         ;


extern void ( png_write_chunk_end) (png_structrp png_ptr);


extern png_infop ( png_create_info_struct) (png_const_structrp png_ptr)
                  ;





extern void ( png_info_init_3) (png_infopp info_ptr, size_t png_info_struct_size)
                                                 ;


extern void ( png_write_info_before_PLTE) (png_structrp png_ptr, png_const_inforp info_ptr)
                                                      ;
extern void ( png_write_info) (png_structrp png_ptr, png_const_inforp info_ptr)
                                                      ;



extern void ( png_read_info) (png_structrp png_ptr, png_inforp info_ptr)
                                                ;
# 1285 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern int ( png_set_interlace_handling) (png_structrp png_ptr);
# 1358 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_set_flush) (png_structrp png_ptr, int nrows);

extern void ( png_write_flush) (png_structrp png_ptr);



extern void ( png_start_read_image) (png_structrp png_ptr);


extern void ( png_read_update_info) (png_structrp png_ptr, png_inforp info_ptr)
                         ;



extern void ( png_read_rows) (png_structrp png_ptr, png_bytepp row, png_bytepp display_row, png_uint_32 num_rows)
                                                  ;




extern void ( png_read_row) (png_structrp png_ptr, png_bytep row, png_bytep display_row)
                           ;




extern void ( png_read_image) (png_structrp png_ptr, png_bytepp image);



extern void ( png_write_row) (png_structrp png_ptr, png_const_bytep row)
                         ;






extern void ( png_write_rows) (png_structrp png_ptr, png_bytepp row, png_uint_32 num_rows)
                          ;


extern void ( png_write_image) (png_structrp png_ptr, png_bytepp image);


extern void ( png_write_end) (png_structrp png_ptr, png_inforp info_ptr)
                         ;



extern void ( png_read_end) (png_structrp png_ptr, png_inforp info_ptr);



extern void ( png_destroy_info_struct) (png_const_structrp png_ptr, png_infopp info_ptr_ptr)
                             ;


extern void ( png_destroy_read_struct) (png_structpp png_ptr_ptr, png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr)
                                                          ;


extern void ( png_destroy_write_struct) (png_structpp png_ptr_ptr, png_infopp info_ptr_ptr)
                             ;


extern void ( png_set_crc_action) (png_structrp png_ptr, int crit_action, int ancil_action)
                      ;
# 1455 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_set_filter) (png_structrp png_ptr, int method, int filters)
                 ;
# 1508 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_set_compression_level) (png_structrp png_ptr, int level)
               ;

extern void ( png_set_compression_mem_level) (png_structrp png_ptr, int mem_level)
                   ;

extern void ( png_set_compression_strategy) (png_structrp png_ptr, int strategy)
                  ;




extern void ( png_set_compression_window_bits) (png_structrp png_ptr, int window_bits)
                     ;

extern void ( png_set_compression_method) (png_structrp png_ptr, int method)
                ;
# 1560 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_init_io) (png_structrp png_ptr, png_FILE_p fp);
# 1571 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_set_error_fn) (png_structrp png_ptr, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warning_fn)
                                                                           ;


extern png_voidp ( png_get_error_ptr) (png_const_structrp png_ptr);
# 1587 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_set_write_fn) (png_structrp png_ptr, png_voidp io_ptr, png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn)
                                                             ;


extern void ( png_set_read_fn) (png_structrp png_ptr, png_voidp io_ptr, png_rw_ptr read_data_fn)
                             ;


extern png_voidp ( png_get_io_ptr) (png_const_structrp png_ptr);

extern void ( png_set_read_status_fn) (png_structrp png_ptr, png_read_status_ptr read_row_fn)
                                     ;

extern void ( png_set_write_status_fn) (png_structrp png_ptr, png_write_status_ptr write_row_fn)
                                       ;
# 1716 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern png_voidp ( png_malloc) (png_const_structrp png_ptr, png_alloc_size_t size)
                                          ;

extern png_voidp ( png_calloc) (png_const_structrp png_ptr, png_alloc_size_t size)
                                          ;


extern png_voidp ( png_malloc_warn) (png_const_structrp png_ptr, png_alloc_size_t size)
                                          ;


extern void ( png_free) (png_const_structrp png_ptr, png_voidp ptr);


extern void ( png_free_data) (png_const_structrp png_ptr, png_inforp info_ptr, png_uint_32 free_me, int num)
                                                       ;
# 1740 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_data_freer) (png_const_structrp png_ptr, png_inforp info_ptr, int freer, png_uint_32 mask)
                                                      ;
# 1774 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_error) (png_const_structrp png_ptr, png_const_charp error_message)
                                                 ;


extern void ( png_chunk_error) (png_const_structrp png_ptr, png_const_charp error_message)
                                                 ;
# 1790 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_warning) (png_const_structrp png_ptr, png_const_charp warning_message)
                                     ;


extern void ( png_chunk_warning) (png_const_structrp png_ptr, png_const_charp warning_message)
                                     ;
# 1804 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_benign_error) (png_const_structrp png_ptr, png_const_charp warning_message)
                                     ;



extern void ( png_chunk_benign_error) (png_const_structrp png_ptr, png_const_charp warning_message)
                                     ;


extern void ( png_set_benign_errors) (png_structrp png_ptr, int allowed)
                                        ;
# 1838 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern png_uint_32 ( png_get_valid) (png_const_structrp png_ptr, png_const_inforp info_ptr, png_uint_32 flag)
                                                 ;


extern size_t ( png_get_rowbytes) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;





extern png_bytepp ( png_get_rows) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;




extern void ( png_set_rows) (png_const_structrp png_ptr, png_inforp info_ptr, png_bytepp row_pointers)
                                                  ;



extern png_byte ( png_get_channels) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;



extern png_uint_32 ( png_get_image_width) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;


extern png_uint_32 ( png_get_image_height) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;


extern png_byte ( png_get_bit_depth) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;


extern png_byte ( png_get_color_type) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;


extern png_byte ( png_get_filter_type) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;


extern png_byte ( png_get_interlace_type) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;


extern png_byte ( png_get_compression_type) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;


extern png_uint_32 ( png_get_pixels_per_meter) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                                                            ;
extern png_uint_32 ( png_get_x_pixels_per_meter) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                                                            ;
extern png_uint_32 ( png_get_y_pixels_per_meter) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                                                            ;




extern png_fixed_point ( png_get_pixel_aspect_ratio_fixed) (png_const_structrp png_ptr, png_const_inforp info_ptr);



extern png_int_32 ( png_get_x_offset_pixels) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                                                            ;
extern png_int_32 ( png_get_y_offset_pixels) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                                                            ;
extern png_int_32 ( png_get_x_offset_microns) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                                                            ;
extern png_int_32 ( png_get_y_offset_microns) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                                                            ;





extern png_const_bytep ( png_get_signature) (png_const_structrp png_ptr, png_const_inforp info_ptr)
                               ;



extern png_uint_32 ( png_get_bKGD) (png_const_structrp png_ptr, png_inforp info_ptr, png_color_16p *background)
                                                    ;



extern void ( png_set_bKGD) (png_const_structrp png_ptr, png_inforp info_ptr, png_const_color_16p background)
                                                         ;
# 2009 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern png_uint_32 ( png_get_hIST) (png_const_structrp png_ptr, png_inforp info_ptr, png_uint_16p *hist)
                                             ;
extern void ( png_set_hIST) (png_const_structrp png_ptr, png_inforp info_ptr, png_const_uint_16p hist)
                                                  ;


extern png_uint_32 ( png_get_IHDR) (png_const_structrp png_ptr, png_const_inforp info_ptr, png_uint_32 *width, png_uint_32 *height, int *bit_depth, int *color_type, int *interlace_method, int *compression_method, int *filter_method)


                                                 ;

extern void ( png_set_IHDR) (png_const_structrp png_ptr, png_inforp info_ptr, png_uint_32 width, png_uint_32 height, int bit_depth, int color_type, int interlace_method, int compression_method, int filter_method)


                       ;
# 2061 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern png_uint_32 ( png_get_PLTE) (png_const_structrp png_ptr, png_inforp info_ptr, png_colorp *palette, int *num_palette)
                                                               ;

extern void ( png_set_PLTE) (png_structrp png_ptr, png_inforp info_ptr, png_const_colorp palette, int num_palette)
                                                                    ;


extern png_uint_32 ( png_get_sBIT) (png_const_structrp png_ptr, png_inforp info_ptr, png_color_8p *sig_bit)
                                                ;



extern void ( png_set_sBIT) (png_const_structrp png_ptr, png_inforp info_ptr, png_const_color_8p sig_bit)
                                                     ;
# 2140 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern png_uint_32 ( png_get_tRNS) (png_const_structrp png_ptr, png_inforp info_ptr, png_bytep *trans_alpha, int *num_trans, png_color_16p *trans_color)

                                ;



extern void ( png_set_tRNS) (png_structrp png_ptr, png_inforp info_ptr, png_const_bytep trans_alpha, int num_trans, png_const_color_16p trans_color)

                                     ;
# 2279 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_set_keep_unknown_chunks) (png_structrp png_ptr, int keep, png_const_bytep chunk_list, int num_chunks)
                                                          ;






extern int ( png_handle_as_unknown) (png_const_structrp png_ptr, png_const_bytep chunk_name)
                                ;



extern void ( png_set_unknown_chunks) (png_const_structrp png_ptr, png_inforp info_ptr, png_const_unknown_chunkp unknowns, int num_unknowns)

                      ;
# 2304 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_set_unknown_chunk_location) (png_const_structrp png_ptr, png_inforp info_ptr, int chunk, int location)
                                                                               ;

extern int ( png_get_unknown_chunks) (png_const_structrp png_ptr, png_inforp info_ptr, png_unknown_chunkpp entries)
                                                      ;






extern void ( png_set_invalid) (png_const_structrp png_ptr, png_inforp info_ptr, int mask)
                                   ;




extern void ( png_read_png) (png_structrp png_ptr, png_inforp info_ptr, int transforms, png_voidp params)
                                      ;


extern void ( png_write_png) (png_structrp png_ptr, png_inforp info_ptr, int transforms, png_voidp params)
                                      ;



extern png_const_charp ( png_get_copyright) (png_const_structrp png_ptr)
                                 ;
extern png_const_charp ( png_get_header_ver) (png_const_structrp png_ptr)
                                 ;
extern png_const_charp ( png_get_header_version) (png_const_structrp png_ptr)
                                 ;
extern png_const_charp ( png_get_libpng_ver) (png_const_structrp png_ptr)
                                 ;
# 2361 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_set_user_limits) (png_structrp png_ptr, png_uint_32 user_width_max, png_uint_32 user_height_max)
                                                             ;
extern png_uint_32 ( png_get_user_width_max) (png_const_structrp png_ptr)
                                 ;
extern png_uint_32 ( png_get_user_height_max) (png_const_structrp png_ptr)
                                 ;

extern void ( png_set_chunk_cache_max) (png_structrp png_ptr, png_uint_32 user_chunk_cache_max)
                                      ;
extern png_uint_32 ( png_get_chunk_cache_max) (png_const_structrp png_ptr)
                                 ;

extern void ( png_set_chunk_malloc_max) (png_structrp png_ptr, png_alloc_size_t user_chunk_cache_max)
                                           ;
extern png_alloc_size_t ( png_get_chunk_malloc_max) (png_const_structrp png_ptr)
                                 ;
# 2412 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern png_uint_32 ( png_get_io_state) (png_const_structrp png_ptr);





extern png_uint_32 ( png_get_io_chunk_type) (png_const_structrp png_ptr)
                                 ;
# 2544 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern png_uint_32 ( png_get_uint_32) (png_const_bytep buf);
extern png_uint_16 ( png_get_uint_16) (png_const_bytep buf);
extern png_int_32 ( png_get_int_32) (png_const_bytep buf);


extern png_uint_32 ( png_get_uint_31) (png_const_structrp png_ptr, png_const_bytep buf)
                         ;




extern void ( png_save_uint_32) (png_bytep buf, png_uint_32 i);


extern void ( png_save_int_32) (png_bytep buf, png_int_32 i);







extern void ( png_save_uint_16) (png_bytep buf, unsigned int i);
# 2612 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/libpng/png.h"
extern void ( png_set_check_for_invalid_index) (png_structrp png_ptr, int allowed)
                                        ;

extern int ( png_get_palette_max) (png_const_structp png_ptr, png_const_infop info_ptr)
                              ;
# 13 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/opngreduc/opngreduc.h" 2
# 28 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/opngreduc/opngreduc.h"
int opng_validate_image(png_structp png_ptr, png_infop info_ptr);
# 55 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/opngreduc/opngreduc.h"
png_uint_32 opng_reduce_image(png_structp png_ptr, png_infop info_ptr,
   png_uint_32 reductions);
# 21 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2

# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/pngxtern/pngxtern.h" 1
# 47 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/pngxtern/pngxtern.h"
int pngx_read_image(png_structp png_ptr, png_infop info_ptr,
                           png_const_charpp fmt_name_ptr,
                           png_const_charpp fmt_long_name_ptr);
# 23 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/pngxtern/pngxutil.h" 1
# 21 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/pngxtern/pngxutil.h"
void pngx_set_compression_type
   (png_structp png_ptr, png_infop info_ptr, int compression_type);
void pngx_set_filter_type
   (png_structp png_ptr, png_infop info_ptr, int filter_type);
void pngx_set_interlace_type
   (png_structp png_ptr, png_infop info_ptr, int interlace_type);



typedef png_alloc_size_t pngx_alloc_size_t;
# 43 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../src/pngxtern/pngxutil.h"
png_bytepp pngx_malloc_rows
   (png_structp png_ptr, png_infop info_ptr, int filler);
png_bytepp pngx_malloc_rows_extended
   (png_structp png_ptr, png_infop info_ptr,
    pngx_alloc_size_t min_row_size, int filler);
# 24 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h" 1
# 56 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h" 1
# 254 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stddef.h" 1
# 255 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h" 2
     typedef size_t z_size_t;
# 401 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h"
typedef unsigned char Byte;

typedef unsigned int uInt;
typedef unsigned long uLong;





   typedef Byte Bytef;

typedef char charf;
typedef int intf;
typedef uInt uIntf;
typedef uLong uLongf;


   typedef void const *voidpc;
   typedef void *voidpf;
   typedef void *voidp;







# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/limits.h" 1
# 429 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h" 2
# 439 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h"
   typedef unsigned z_crc_t;
# 454 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/sys/types.h" 1
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/sys/types.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1
# 3 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/sys/types.h" 2
# 455 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h" 2





# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdarg.h" 1
# 461 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h" 2
# 492 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/unistd.h" 1
# 493 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zconf.h" 2
# 57 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h" 2
# 103 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
typedef voidpf (*alloc_func)(voidpf opaque, uInt items, uInt size);
typedef void (*free_func)(voidpf opaque, voidpf address);

struct internal_state;

typedef struct z_stream_s {
    Bytef *next_in;
    uInt avail_in;
    uLong total_in;

    Bytef *next_out;
    uInt avail_out;
    uLong total_out;

    char *msg;
    struct internal_state *state;

    alloc_func zalloc;
    free_func zfree;
    voidpf opaque;

    int data_type;

    uLong adler;
    uLong reserved;
} z_stream;

typedef z_stream *z_streamp;





typedef struct gz_header_s {
    int text;
    uLong time;
    int xflags;
    int os;
    Bytef *extra;
    uInt extra_len;
    uInt extra_max;
    Bytef *name;
    uInt name_max;
    Bytef *comment;
    uInt comm_max;
    int hcrc;
    int done;

} gz_header;

typedef gz_header *gz_headerp;
# 242 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern const char * zlibVersion(void);
# 272 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflate(z_streamp strm, int flush);
# 385 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflateEnd(z_streamp strm);
# 423 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflate(z_streamp strm, int flush);
# 543 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflateEnd(z_streamp strm);
# 633 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflateSetDictionary(z_streamp strm,
                                         const Bytef *dictionary,
                                         uInt dictLength);
# 677 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflateGetDictionary(z_streamp strm,
                                         Bytef *dictionary,
                                         uInt *dictLength);
# 699 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflateCopy(z_streamp dest,
                                z_streamp source);
# 717 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflateReset(z_streamp strm);
# 728 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflateParams(z_streamp strm,
                                  int level,
                                  int strategy);
# 766 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflateTune(z_streamp strm,
                                int good_length,
                                int max_lazy,
                                int nice_length,
                                int max_chain);
# 783 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern uLong deflateBound(z_streamp strm,
                                   uLong sourceLen);
# 798 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflatePending(z_streamp strm,
                                   unsigned *pending,
                                   int *bits);
# 813 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflatePrime(z_streamp strm,
                                 int bits,
                                 int value);
# 830 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflateSetHeader(z_streamp strm,
                                     gz_headerp head);
# 910 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflateSetDictionary(z_streamp strm,
                                         const Bytef *dictionary,
                                         uInt dictLength);
# 933 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflateGetDictionary(z_streamp strm,
                                         Bytef *dictionary,
                                         uInt *dictLength);
# 948 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflateSync(z_streamp strm);
# 967 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflateCopy(z_streamp dest,
                                z_streamp source);
# 983 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflateReset(z_streamp strm);
# 994 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflateReset2(z_streamp strm,
                                  int windowBits);
# 1008 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflatePrime(z_streamp strm,
                                 int bits,
                                 int value);
# 1029 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern long inflateMark(z_streamp strm);
# 1057 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflateGetHeader(z_streamp strm,
                                     gz_headerp head);
# 1119 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
typedef unsigned (*in_func)(void *,
                            unsigned char * *);
typedef int (*out_func)(void *, unsigned char *, unsigned);

extern int inflateBack(z_streamp strm,
                                in_func in, void *in_desc,
                                out_func out, void *out_desc);
# 1193 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int inflateBackEnd(z_streamp strm);







extern uLong zlibCompileFlags(void);
# 1254 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int compress(Bytef *dest, uLongf *destLen,
                             const Bytef *source, uLong sourceLen);
# 1269 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int compress2(Bytef *dest, uLongf *destLen,
                              const Bytef *source, uLong sourceLen,
                              int level);
# 1285 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern uLong compressBound(uLong sourceLen);






extern int uncompress(Bytef *dest, uLongf *destLen,
                               const Bytef *source, uLong sourceLen);
# 1310 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int uncompress2(Bytef *dest, uLongf *destLen,
                                const Bytef *source, uLong *sourceLen);
# 1327 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
typedef struct gzFile_s *gzFile;
# 1367 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern gzFile gzdopen(int fd, const char *mode);
# 1390 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzbuffer(gzFile file, unsigned size);
# 1406 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzsetparams(gzFile file, int level, int strategy);
# 1417 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzread(gzFile file, voidp buf, unsigned len);
# 1447 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern z_size_t gzfread(voidp buf, z_size_t size, z_size_t nitems,
                                 gzFile file);
# 1473 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzwrite(gzFile file, voidpc buf, unsigned len);





extern z_size_t gzfwrite(voidpc buf, z_size_t size,
                                  z_size_t nitems, gzFile file);
# 1493 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzprintf(gzFile file, const char *format, ...);
# 1508 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzputs(gzFile file, const char *s);







extern char * gzgets(gzFile file, char *buf, int len);
# 1530 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzputc(gzFile file, int c);





extern int gzgetc(gzFile file);
# 1545 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzungetc(int c, gzFile file);
# 1557 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzflush(gzFile file, int flush);
# 1592 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzrewind(gzFile file);
# 1620 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzeof(gzFile file);
# 1635 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzdirect(gzFile file);
# 1656 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzclose(gzFile file);
# 1669 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int gzclose_r(gzFile file);
extern int gzclose_w(gzFile file);
# 1681 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern const char * gzerror(gzFile file, int *errnum);
# 1697 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern void gzclearerr(gzFile file);
# 1714 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern uLong adler32(uLong adler, const Bytef *buf, uInt len);
# 1734 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern uLong adler32_z(uLong adler, const Bytef *buf,
                                z_size_t len);
# 1752 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern uLong crc32(uLong crc, const Bytef *buf, uInt len);
# 1770 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern uLong crc32_z(uLong crc, const Bytef *buf,
                              z_size_t len);
# 1793 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern uLong crc32_combine_op(uLong crc1, uLong crc2, uLong op);
# 1806 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern int deflateInit_(z_streamp strm, int level,
                                 const char *version, int stream_size);
extern int inflateInit_(z_streamp strm,
                                 const char *version, int stream_size);
extern int deflateInit2_(z_streamp strm, int level, int method,
                                  int windowBits, int memLevel,
                                  int strategy, const char *version,
                                  int stream_size);
extern int inflateInit2_(z_streamp strm, int windowBits,
                                  const char *version, int stream_size);
extern int inflateBackInit_(z_streamp strm, int windowBits,
                                     unsigned char *window,
                                     const char *version,
                                     int stream_size);
# 1859 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
struct gzFile_s {
    unsigned have;
    unsigned char *next;
    off_t pos;
};
extern int gzgetc_(gzFile file);
# 1918 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
   extern gzFile gzopen(const char *, const char *);
   extern off_t gzseek(gzFile, off_t, int);
   extern off_t gztell(gzFile);
   extern off_t gzoffset(gzFile);
   extern uLong adler32_combine(uLong, uLong, off_t);
   extern uLong crc32_combine(uLong, uLong, off_t);
   extern uLong crc32_combine_gen(off_t);
# 1936 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/zlib/zlib.h"
extern const char * zError(int);
extern int inflateSyncPoint(z_streamp);
extern const z_crc_t * get_crc_table(void);
extern int inflateUndermine(z_streamp, int);
extern int inflateValidate(z_streamp, int);
extern unsigned long inflateCodesUsed(z_streamp);
extern int inflateResetKeep(z_streamp);
extern int deflateResetKeep(z_streamp);






extern int gzvprintf(gzFile file,
                                           const char *format,
                                           va_list va);
# 25 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2


# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h" 1
# 14 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 1
# 15 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h" 2
# 37 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/limits.h" 1
# 38 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h" 2


typedef long opng_foffset_t;
# 49 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
typedef unsigned long opng_fsize_t;
# 110 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
opng_foffset_t
opng_ftello(FILE *stream);





int
opng_fseeko(FILE *stream, opng_foffset_t offset, int whence);
# 127 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
size_t
opng_freado(FILE *stream, opng_foffset_t offset, int whence,
            void *block, size_t blocksize);
# 138 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
size_t
opng_fwriteo(FILE *stream, opng_foffset_t offset, int whence,
             const void *block, size_t blocksize);






int
opng_fgetsize(FILE *stream, opng_fsize_t *size);
# 161 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
char *
opng_path_replace_dir(char *buffer, size_t bufsize,
                      const char *old_path, const char *new_dirname);
# 174 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
char *
opng_path_replace_ext(char *buffer, size_t bufsize,
                      const char *old_path, const char *new_extname);






char *
opng_path_make_backup(char *buffer, size_t bufsize, const char *path);






int
opng_os_rename(const char *src_path, const char *dest_path, int clobber);







int
opng_os_create_dir(const char *dirname);







int
opng_os_copy_file_attr(const char *src_path, const char *dest_path);
# 225 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
int
opng_os_test_file_access(const char *path, const char *mode);
# 236 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ioutil.h"
int
opng_os_test_file_equiv(const char *path1, const char *path2);







int
opng_os_unlink(const char *path);
# 28 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ratio.h" 1
# 14 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ratio.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stddef.h" 1
# 15 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ratio.h" 2
# 23 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ratio.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/limits.h" 1
# 24 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ratio.h" 2
# 69 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ratio.h"
struct opng_lratio
{
    long num;
    long denom;
};




struct opng_ulratio
{
    unsigned long num;
    unsigned long denom;
};
# 124 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ratio.h"
int
opng_ulratio_to_factor_string(char *buffer, size_t buffer_size,
                              const struct opng_ulratio *ratio);
# 140 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/ratio.h"
int
opng_ulratio_to_percent_string(char *buffer, size_t buffer_size,
                               const struct opng_ulratio *ratio);
# 29 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2





# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/cexcept/cexcept.h" 1
# 196 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/cexcept/cexcept.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/setjmp.h" 1
# 197 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/../../third_party/cexcept/cexcept.h" 2
# 35 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c" 2
typedef enum
{
    OPNG_STATUS_OK = 0,
    OPNG_STATUS_ERR_LIBPNG = -1,
    OPNG_STATUS_ERR_OPTIPNG = -2
} opng_status_t;
struct exception_context { jmp_buf *penv; int caught; volatile struct { opng_status_t etmp; } v; };
struct exception_context the_exception_context[1];





static const struct opng_preset_struct
{
    const char *compr_level;
    const char *mem_level;
    const char *strategy;
    const char *filter;
} k_presets[7 + 1] =
{

    { "", "", "", "" },
    { "", "", "", "" },
    { "9", "8", "0-", "0,5" },
    { "9", "8-9", "0-", "0,5" },
    { "9", "8", "0-", "0-" },
    { "9", "8-9", "0-", "0-" },
    { "1-9", "8", "0-", "0-" },
    { "1-9", "8-9", "0-", "0-" }
};




static const int k_filter_table[5 + 1] =
{
    0x08,
    0x10,
    0x20,
    0x40,
    0x80,
    ((0x08 | 0x10 | 0x20) | 0x40 | 0x80)
};




static const png_byte k_sig_PLTE[4] = { 0x50, 0x4c, 0x54, 0x45 };
static const png_byte k_sig_tRNS[4] = { 0x74, 0x52, 0x4e, 0x53 };
static const png_byte k_sig_IDAT[4] = { 0x49, 0x44, 0x41, 0x54 };
static const png_byte k_sig_IEND[4] = { 0x49, 0x45, 0x4e, 0x44 };
static const png_byte k_sig_bKGD[4] = { 0x62, 0x4b, 0x47, 0x44 };
static const png_byte k_sig_hIST[4] = { 0x68, 0x49, 0x53, 0x54 };
static const png_byte k_sig_sBIT[4] = { 0x73, 0x42, 0x49, 0x54 };
static const png_byte k_sig_dSIG[4] = { 0x64, 0x53, 0x49, 0x47 };
static const png_byte k_sig_acTL[4] = { 0x61, 0x63, 0x54, 0x4c };
static const png_byte k_sig_fcTL[4] = { 0x66, 0x63, 0x54, 0x4c };
static const png_byte k_sig_fdAT[4] = { 0x66, 0x64, 0x41, 0x54 };




static const opng_fsize_t k_idat_size_max = ((png_uint_32)0x7fffffffL);
static const char *k_idat_size_max_string = "2GB";




enum
{
    INPUT_IS_PNG_FILE = 0x0001,
    INPUT_HAS_PNG_DATASTREAM = 0x0002,
    INPUT_HAS_PNG_SIGNATURE = 0x0004,
    INPUT_HAS_DIGITAL_SIGNATURE = 0x0008,
    INPUT_HAS_MULTIPLE_IMAGES = 0x0010,
    INPUT_HAS_APNG = 0x0020,
    INPUT_HAS_STRIPPED_DATA = 0x0040,
    INPUT_HAS_JUNK = 0x0080,
    INPUT_HAS_ERRORS = 0x0100,
    OUTPUT_NEEDS_NEW_FILE = 0x1000,
    OUTPUT_NEEDS_NEW_IDAT = 0x2000,
    OUTPUT_HAS_ERRORS = 0x4000
};





static struct opng_engine_struct
{
    int started;
} s_engine;




static struct opng_process_struct
{
    unsigned int status;
    int num_iterations;
    opng_foffset_t in_datastream_offset;
    opng_fsize_t in_file_size, out_file_size;
    opng_fsize_t in_idat_size, out_idat_size;
    opng_fsize_t best_idat_size, max_idat_size;
    png_uint_32 in_plte_trns_size, out_plte_trns_size;
    png_uint_32 reductions;
    opng_bitset_t compr_level_set, mem_level_set, strategy_set, filter_set;
    int best_compr_level, best_mem_level, best_strategy, best_filter;
} s_process;




static struct opng_summary_struct
{
    unsigned int file_count;
    unsigned int err_count;
    unsigned int fix_count;
    unsigned int snip_count;
} s_summary;




static struct opng_image_struct
{
    png_uint_32 width;
    png_uint_32 height;
    int bit_depth;
    int color_type;
    int compression_type;
    int filter_type;
    int interlace_type;
    png_bytepp row_pointers;
    png_colorp palette;
    int num_palette;
    png_color_16p background_ptr;
    png_color_16 background;
    png_uint_16p hist;
    png_color_8p sig_bit_ptr;
    png_color_8 sig_bit;
    png_bytep trans_alpha;
    int num_trans;
    png_color_16p trans_color_ptr;
    png_color_16 trans_color;
    png_unknown_chunkp unknowns;
    int num_unknowns;
} s_image;




static struct opng_options s_options;




static png_structp s_read_ptr;
static png_infop s_read_info_ptr;
static png_structp s_write_ptr;
static png_infop s_write_info_ptr;





static void (*usr_printf)(const char *fmt, ...);
static void (*usr_print_cntrl)(int cntrl_code);
static void (*usr_progress)(unsigned long num, unsigned long denom);
static void (*usr_panic)(const char *msg);
# 218 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c"
static void
opng_print_fsize_ratio(opng_fsize_t num, opng_fsize_t denom)
{
# 229 "/home/enumclass/Documents/C2RustTranslation/bkp/optipng-0.7.8/src/optipng/optim.c"
    char buffer[32];
    struct opng_ulratio ratio;
    int result;

    ratio.num = num;
    ratio.denom = denom;
    result = opng_ulratio_to_factor_string(buffer, sizeof(buffer), &ratio);
    usr_printf("%s%s", buffer, (result > 0) ? "" : "...");



}




static void
opng_print_fsize_difference(opng_fsize_t init_size, opng_fsize_t final_size,
                            int show_ratio)
{
    opng_fsize_t difference;
    int sign;

    if (init_size <= final_size)
    {
        sign = 0;
        difference = final_size - init_size;
    }
    else
    {
        sign = 1;
        difference = init_size - final_size;
    }

    if (difference == 0)
    {
        usr_printf("no change");
        return;
    }
    if (difference == 1)
        usr_printf("1 byte");
    else
        usr_printf("%" "lu" " bytes", difference);
    if (show_ratio && init_size > 0)
    {
        usr_printf(" = ");
        opng_print_fsize_ratio(difference, init_size);
    }
    usr_printf((sign == 0) ? " increase" : " decrease");
}




static void
opng_print_image_info(int show_dim, int show_depth, int show_type,
                      int show_interlaced)
{
    static const int type_channels[8] = {1, 0, 3, 1, 2, 0, 4, 0};
    int channels, printed;

    printed = 0;
    if (show_dim)
    {
        printed = 1;
        usr_printf("%lux%lu pixels",
                   (unsigned long)s_image.width,
                   (unsigned long)s_image.height);
    }
    if (show_depth)
    {
        if (printed)
            usr_printf(", ");
        printed = 1;
        channels = type_channels[s_image.color_type & 7];
        if (channels != 1)
            usr_printf("%dx%d bits/pixel", channels, s_image.bit_depth);
        else if (s_image.bit_depth != 1)
            usr_printf("%d bits/pixel", s_image.bit_depth);
        else
            usr_printf("1 bit/pixel");
    }
    if (show_type)
    {
        if (printed)
            usr_printf(", ");
        printed = 1;
        if (s_image.color_type & 1)
        {
            if (s_image.num_palette == 1)
                usr_printf("1 color");
            else
                usr_printf("%d colors", s_image.num_palette);
            if (s_image.num_trans > 0)
                usr_printf(" (%d transparent)", s_image.num_trans);
            usr_printf(" in palette");
        }
        else
        {
            usr_printf((s_image.color_type & 2) ?
                       "RGB" : "grayscale");
            if (s_image.color_type & 4)
                usr_printf("+alpha");
            else if (s_image.trans_color_ptr != 0)
                usr_printf("+transparency");
        }
    }
    if (show_interlaced)
    {
        if (s_image.interlace_type != 0)
        {
            if (printed)
                usr_printf(", ");
            usr_printf("interlaced");
        }
    }
}




static void
opng_print_warning(const char *msg)
{
    usr_print_cntrl('\v');
    usr_printf("Warning: %s\n", msg);
}




static void
opng_print_error(const char *msg)
{
    usr_print_cntrl('\v');
    usr_printf("Error: %s\n", msg);
}




static void
opng_throw_error(png_const_charp msg)
{
    opng_print_error(msg);
    for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = OPNG_STATUS_ERR_OPTIPNG;
}




static void
opng_warning(png_structp png_ptr, png_const_charp msg)
{


    if (png_ptr == s_read_ptr)
        s_process.status |= (INPUT_HAS_ERRORS | OUTPUT_NEEDS_NEW_IDAT);
    opng_print_warning(msg);
}




static void
opng_error(png_structp png_ptr, png_const_charp msg)
{


    if (png_ptr == s_read_ptr)
    {
        s_process.status |= (INPUT_HAS_ERRORS | OUTPUT_NEEDS_NEW_IDAT);
        if (opng_validate_image(s_read_ptr, s_read_info_ptr))
        {



            opng_print_warning(msg);
            for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = OPNG_STATUS_OK;
        }
    }

    opng_print_error(msg);
    for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = OPNG_STATUS_ERR_LIBPNG;
}




static void
opng_free(void *ptr)
{




    free(ptr);
}




static void
opng_check_idat_size(opng_fsize_t size)
{
    if (size > k_idat_size_max)
        opng_throw_error("IDAT sizes larger than the maximum chunk size "
                         "are currently unsupported");
}




static void
opng_set_keep_unknown_chunk(png_structp png_ptr,
                            int keep, png_bytep chunk_type)
{
    png_byte chunk_name[5];


    memcpy(chunk_name, chunk_type, 4);
    chunk_name[4] = 0;
    if (!png_handle_as_unknown(png_ptr, chunk_name))
        png_set_keep_unknown_chunks(png_ptr, keep, chunk_name, 1);
}




static int
opng_is_image_chunk(png_bytep chunk_type)
{
    if ((chunk_type[0] & 0x20) == 0)
        return 1;





    if (memcmp(chunk_type, k_sig_tRNS, 4) == 0)
        return 1;
    return 0;
}




static int
opng_is_apng_chunk(png_bytep chunk_type)
{
    if (memcmp(chunk_type, k_sig_acTL, 4) == 0 ||
        memcmp(chunk_type, k_sig_fcTL, 4) == 0 ||
        memcmp(chunk_type, k_sig_fdAT, 4) == 0)
        return 1;
    return 0;
}




static int
opng_allow_chunk(png_bytep chunk_type)
{

    if (opng_is_image_chunk(chunk_type))
        return 1;

    if (s_options.strip_all)
        return 0;

    if (memcmp(chunk_type, k_sig_dSIG, 4) == 0)
        return 0;

    if (s_options.snip && opng_is_apng_chunk(chunk_type))
        return 0;

    return 1;
}




static void
opng_handle_chunk(png_structp png_ptr, png_bytep chunk_type)
{
    int keep;

    if (opng_is_image_chunk(chunk_type))
        return;

    if (s_options.strip_all)
    {
        s_process.status |= INPUT_HAS_STRIPPED_DATA | INPUT_HAS_JUNK;
        opng_set_keep_unknown_chunk(png_ptr,
                                    1, chunk_type);
        return;
    }


    if (memcmp(chunk_type, k_sig_bKGD, 4) == 0 ||
        memcmp(chunk_type, k_sig_hIST, 4) == 0 ||
        memcmp(chunk_type, k_sig_sBIT, 4) == 0)
        return;


    keep = 3;
    if (memcmp(chunk_type, k_sig_dSIG, 4) == 0)
    {

        s_process.status |= INPUT_HAS_DIGITAL_SIGNATURE;
    }
    else if (opng_is_apng_chunk(chunk_type))
    {

        s_process.status |= INPUT_HAS_APNG;
        if (memcmp(chunk_type, k_sig_fdAT, 4) == 0)
            s_process.status |= INPUT_HAS_MULTIPLE_IMAGES;
        if (s_options.snip)
        {
            s_process.status |= INPUT_HAS_JUNK;
            keep = 1;
        }
    }
    opng_set_keep_unknown_chunk(png_ptr, keep, chunk_type);
}




static void
opng_init_read_data(void)
{



}




static void
opng_init_write_data(void)
{
    s_process.out_file_size = 0;
    s_process.out_plte_trns_size = 0;
    s_process.out_idat_size = 0;
}




static void
opng_read_data(png_structp png_ptr, png_bytep data, size_t length)
{
    FILE *stream = (FILE *)png_get_io_ptr(png_ptr);
    int io_state = png_get_io_state(png_ptr);
    int io_state_loc = io_state & 0x00f0;
    png_bytep chunk_sig;


    if (fread(data, 1, length, stream) != length)
        png_error(png_ptr,
                  "Can't read the input file or unexpected end of file");

    if (s_process.in_file_size == 0)
    {

        { if (!(length == 8)) usr_panic("PNG I/O must start with the first 8 bytes"); };
        s_process.in_datastream_offset = opng_ftello(stream) - 8;
        s_process.status |= INPUT_HAS_PNG_DATASTREAM;
        if (io_state_loc == 0x0010)
            s_process.status |= INPUT_HAS_PNG_SIGNATURE;
        if (s_process.in_datastream_offset == 0)
            s_process.status |= INPUT_IS_PNG_FILE;
        else if (s_process.in_datastream_offset < 0)
            png_error(png_ptr,
                      "Can't get the file-position indicator in input file");
        s_process.in_file_size = (opng_fsize_t)s_process.in_datastream_offset;
    }
    s_process.in_file_size += length;


    { if (!((io_state & 0x0001) && (io_state_loc != 0))) usr_panic("Incorrect info in png_ptr->io_state"); }
                                                      ;
    if (io_state_loc == 0x0020)
    {




        { if (!(length == 8)) usr_panic("Reading chunk header, expecting 8 bytes"); };
        chunk_sig = data + 4;

        if (memcmp(chunk_sig, k_sig_IDAT, 4) == 0)
        {
            { if (!(png_ptr == s_read_ptr)) usr_panic("Incorrect I/O handler setup"); };
            if (png_get_rows(s_read_ptr, s_read_info_ptr) == 0)
            {

                { if (!(s_process.in_idat_size == 0)) usr_panic("Found IDAT with no rows"); }
                                                      ;




                if (png_get_image_height(s_read_ptr, s_read_info_ptr) == 0)
                {

                    return;
                }
                { if (!(pngx_malloc_rows(s_read_ptr, s_read_info_ptr, 0) != 0)) usr_panic("Failed allocation of image rows; " "unsafe libpng allocator"); }


                                                      ;
                png_data_freer(s_read_ptr, s_read_info_ptr,
                               2, 0x0040U);
            }
            else
            {

                s_process.status |= INPUT_HAS_JUNK;
            }
            s_process.in_idat_size += (((png_uint_32)(*(data)) << 24) + ((png_uint_32)(*((data) + 1)) << 16) + ((png_uint_32)(*((data) + 2)) << 8) + ((png_uint_32)(*((data) + 3))));
        }
        else if (memcmp(chunk_sig, k_sig_PLTE, 4) == 0 ||
                 memcmp(chunk_sig, k_sig_tRNS, 4) == 0)
        {

            s_process.in_plte_trns_size += (((png_uint_32)(*(data)) << 24) + ((png_uint_32)(*((data) + 1)) << 16) + ((png_uint_32)(*((data) + 2)) << 8) + ((png_uint_32)(*((data) + 3)))) + 12;
        }
        else
            opng_handle_chunk(png_ptr, chunk_sig);
    }
    else if (io_state_loc == 0x0080)
    {
        { if (!(length == 4)) usr_panic("Reading chunk CRC, expecting 4 bytes"); };
    }
}




static void
opng_write_data(png_structp png_ptr, png_bytep data, size_t length)
{
    static int allow_crt_chunk;
    static int crt_chunk_is_idat;
    static opng_foffset_t crt_idat_offset;
    static opng_fsize_t crt_idat_size;
    static png_uint_32 crt_idat_crc;
    FILE *stream = (FILE *)png_get_io_ptr(png_ptr);
    int io_state = png_get_io_state(png_ptr);
    int io_state_loc = io_state & 0x00f0;
    png_bytep chunk_sig;
    png_byte buf[4];

    { if (!((io_state & 0x0002) && (io_state_loc != 0))) usr_panic("Incorrect info in png_ptr->io_state"); }
                                                      ;


    if (io_state_loc == 0x0020)
    {
        { if (!(length == 8)) usr_panic("Writing chunk header, expecting 8 bytes"); };
        chunk_sig = data + 4;
        allow_crt_chunk = opng_allow_chunk(chunk_sig);
        if (memcmp(chunk_sig, k_sig_IDAT, 4) == 0)
        {
            crt_chunk_is_idat = 1;
            s_process.out_idat_size += (((png_uint_32)(*(data)) << 24) + ((png_uint_32)(*((data) + 1)) << 16) + ((png_uint_32)(*((data) + 2)) << 8) + ((png_uint_32)(*((data) + 3))));

            if (stream == 0)
            {
                if (s_process.out_idat_size > s_process.max_idat_size)
                {

                    for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = OPNG_STATUS_OK;
                }
            }
        }
        else
        {
            crt_chunk_is_idat = 0;
            if (memcmp(chunk_sig, k_sig_PLTE, 4) == 0 ||
                memcmp(chunk_sig, k_sig_tRNS, 4) == 0)
            {

                s_process.out_plte_trns_size += (((png_uint_32)(*(data)) << 24) + ((png_uint_32)(*((data) + 1)) << 16) + ((png_uint_32)(*((data) + 2)) << 8) + ((png_uint_32)(*((data) + 3)))) + 12;
            }
        }
    }
    else if (io_state_loc == 0x0080)
    {
        { if (!(length == 4)) usr_panic("Writing chunk CRC, expecting 4 bytes"); };
    }


    if (stream == 0)
        return;


    if (io_state_loc != 0x0010 && !allow_crt_chunk)
        return;





    switch (io_state_loc)
    {
    case 0x0020:
        if (crt_chunk_is_idat)
        {
            if (crt_idat_offset == 0)
            {

                crt_idat_offset = opng_ftello(stream);

                if (s_process.best_idat_size > 0)
                {

                    crt_idat_size = s_process.best_idat_size;
                }
                else
                {



                    crt_idat_size = length;
                }
                png_save_uint_32(data, (png_uint_32)crt_idat_size);

                crt_idat_crc = crc32(0, k_sig_IDAT, 4);
            }
            else
            {

                return;
            }
        }
        else
        {
            if (crt_idat_offset != 0)
            {



                png_save_uint_32(buf, crt_idat_crc);
                if (fwrite(buf, 1, 4, stream) != 4)
                    io_state = 0;
                s_process.out_file_size += 4;
                if (s_process.out_idat_size != crt_idat_size)
                {



                    { if (!(s_process.best_idat_size == 0)) usr_panic("Wrong guess of the output IDAT size"); }
                                                                      ;
                    opng_check_idat_size(s_process.out_idat_size);
                    png_save_uint_32(buf,
                                     (png_uint_32)s_process.out_idat_size);
                    if (opng_fwriteo(stream, crt_idat_offset, 0,
                                     buf, 4) != 4)
                        io_state = 0;
                }
                if (io_state == 0)
                    png_error(png_ptr, "Can't finalize IDAT");
                crt_idat_offset = 0;
            }
        }
        break;
    case 0x0040:
        if (crt_chunk_is_idat)
            crt_idat_crc = crc32(crt_idat_crc, data, length);
        break;
    case 0x0080:
        if (crt_chunk_is_idat)
        {

            return;
        }
        break;
    }


    if (fwrite(data, 1, length, stream) != length)
        png_error(png_ptr, "Can't write the output file");
    s_process.out_file_size += length;
}




static void
opng_clear_image_info(void)
{
    memset(&s_image, 0, sizeof(s_image));
}




static void
opng_load_image_info(png_structp png_ptr, png_infop info_ptr, int load_meta)
{
    memset(&s_image, 0, sizeof(s_image));

    png_get_IHDR(png_ptr, info_ptr,
                 &s_image.width, &s_image.height, &s_image.bit_depth,
                 &s_image.color_type, &s_image.interlace_type,
                 &s_image.compression_type, &s_image.filter_type);
    s_image.row_pointers = png_get_rows(png_ptr, info_ptr);
    png_get_PLTE(png_ptr, info_ptr, &s_image.palette, &s_image.num_palette);



    if (png_get_tRNS(png_ptr, info_ptr,
                     &s_image.trans_alpha,
                     &s_image.num_trans, &s_image.trans_color_ptr))
    {



        if (s_image.trans_color_ptr != 0)
        {
            s_image.trans_color = *s_image.trans_color_ptr;
            s_image.trans_color_ptr = &s_image.trans_color;
        }
    }

    if (!load_meta)
        return;

    if (png_get_bKGD(png_ptr, info_ptr, &s_image.background_ptr))
    {

        s_image.background = *s_image.background_ptr;
        s_image.background_ptr = &s_image.background;
    }
    png_get_hIST(png_ptr, info_ptr, &s_image.hist);
    if (png_get_sBIT(png_ptr, info_ptr, &s_image.sig_bit_ptr))
    {

        s_image.sig_bit = *s_image.sig_bit_ptr;
        s_image.sig_bit_ptr = &s_image.sig_bit;
    }
    s_image.num_unknowns =
        png_get_unknown_chunks(png_ptr, info_ptr, &s_image.unknowns);
}




static void
opng_store_image_info(png_structp png_ptr, png_infop info_ptr, int store_meta)
{
    int i;

    { if (!(s_image.row_pointers != 0)) usr_panic("No info in image"); };

    png_set_IHDR(png_ptr, info_ptr,
                 s_image.width, s_image.height, s_image.bit_depth,
                 s_image.color_type, s_image.interlace_type,
                 s_image.compression_type, s_image.filter_type);
    png_set_rows(s_write_ptr, s_write_info_ptr, s_image.row_pointers);
    if (s_image.palette != 0)
        png_set_PLTE(png_ptr, info_ptr, s_image.palette, s_image.num_palette);



    if (s_image.trans_alpha != 0 || s_image.trans_color_ptr != 0)
        png_set_tRNS(png_ptr, info_ptr,
                     s_image.trans_alpha,
                     s_image.num_trans, s_image.trans_color_ptr);

    if (!store_meta)
        return;

    if (s_image.background_ptr != 0)
        png_set_bKGD(png_ptr, info_ptr, s_image.background_ptr);
    if (s_image.hist != 0)
        png_set_hIST(png_ptr, info_ptr, s_image.hist);
    if (s_image.sig_bit_ptr != 0)
        png_set_sBIT(png_ptr, info_ptr, s_image.sig_bit_ptr);
    if (s_image.num_unknowns != 0)
    {
        png_set_unknown_chunks(png_ptr, info_ptr,
                               s_image.unknowns, s_image.num_unknowns);

        for (i = 0; i < s_image.num_unknowns; ++i)
            png_set_unknown_chunk_location(png_ptr, info_ptr,
                                           i, s_image.unknowns[i].location);
    }
}




static void
opng_destroy_image_info(void)
{
    png_uint_32 i;
    int j;

    if (s_image.row_pointers == 0)
        return;

    for (i = 0; i < s_image.height; ++i)
        opng_free(s_image.row_pointers[i]);
    opng_free(s_image.row_pointers);
    opng_free(s_image.palette);
    opng_free(s_image.trans_alpha);
    opng_free(s_image.hist);
    for (j = 0; j < s_image.num_unknowns; ++j)
        opng_free(s_image.unknowns[j].data);
    opng_free(s_image.unknowns);







    memset(&s_image, 0, sizeof(s_image));
}




static void
opng_read_file(FILE *infile)
{
    const char *fmt_name;
    int num_img;
    png_uint_32 reductions;
    volatile opng_status_t status;

    status = OPNG_STATUS_OK;
    { jmp_buf *exception__prev[1]; jmp_buf exception__env; exception__prev[0] = the_exception_context->penv; the_exception_context->penv = &exception__env; if (setjmp(exception__env) == 0) { do
    {
        s_read_ptr = png_create_read_struct("1.6.40",
                                            0, opng_error, opng_warning);
        s_read_info_ptr = png_create_info_struct(s_read_ptr);
        if (s_read_info_ptr == 0)
            opng_throw_error("Can't create image decoder");


        png_set_keep_unknown_chunks(s_read_ptr,
                                    3, 0, 0);
        png_set_user_limits(s_read_ptr, ((png_uint_32)0x7fffffffL), ((png_uint_32)0x7fffffffL));


        opng_init_read_data();
        png_set_read_fn(s_read_ptr, infile, opng_read_data);
        fmt_name = 0;
        num_img = pngx_read_image(s_read_ptr, s_read_info_ptr,
                                  &fmt_name, 0);
        if (num_img <= 0)
            opng_throw_error("Unrecognized image file format");
        if (num_img > 1)
            s_process.status |= INPUT_HAS_MULTIPLE_IMAGES;
        if ((s_process.status & INPUT_IS_PNG_FILE) &&
            (s_process.status & INPUT_HAS_MULTIPLE_IMAGES))
        {

            fmt_name = (s_process.status & INPUT_HAS_PNG_SIGNATURE) ?
                       "APNG" : "APNG datastream";
        }
        { if (!(fmt_name != 0)) usr_panic("No format name from pngxtern"); };

        if (s_process.in_file_size == 0)
        {
            if (opng_fgetsize(infile, &s_process.in_file_size) < 0)
            {
                opng_print_warning("Can't get the correct file size");
                s_process.in_file_size = 0;
            }
        }
    }
    while (the_exception_context->caught = 0, the_exception_context->caught); } else { the_exception_context->caught = 1; } the_exception_context->penv = exception__prev[0]; } if (!the_exception_context->caught || ((status) = the_exception_context->v.etmp, 0)) { } else
    {
        if (opng_validate_image(s_read_ptr, s_read_info_ptr))
            { if (!(status == OPNG_STATUS_OK)) usr_panic("Mysterious error in validated image file"); }
                                                                   ;
    }

    { jmp_buf *exception__prev[1]; jmp_buf exception__env; exception__prev[0] = the_exception_context->penv; the_exception_context->penv = &exception__env; if (setjmp(exception__env) == 0) { do
    {
        if (status != OPNG_STATUS_OK)
            for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = status;


        if (strcmp(fmt_name, "PNG") != 0)
        {
            usr_printf("Importing %s", fmt_name);
            if (s_process.status & INPUT_HAS_MULTIPLE_IMAGES)
            {
                if (!(s_process.status & INPUT_IS_PNG_FILE))
                    usr_printf(" (multi-image or animation)");
                if (s_options.snip)
                    usr_printf("; snipping...");
            }
            usr_printf("\n");
        }
        opng_load_image_info(s_read_ptr, s_read_info_ptr, 1);
        opng_print_image_info(1, 1, 1, 1);
        usr_printf("\n");


        reductions = ((0x0001 | 0x0002) | (0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040 | 0x0080) | (0x0100 | 0x0200) | 0x1000) & ~0x1000;
        if (s_options.nb)
            reductions &= ~(0x0001 | 0x0002);
        if (s_options.nc)
            reductions &= ~(0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040 | 0x0080);
        if (s_options.np)
            reductions &= ~(0x0100 | 0x0200);
        if (s_options.nz && (s_process.status & INPUT_HAS_PNG_DATASTREAM))
        {

            reductions = 0x0000;
        }
        if (s_process.status & INPUT_HAS_DIGITAL_SIGNATURE)
        {

            reductions = 0x0000;
        }
        if ((s_process.status & INPUT_IS_PNG_FILE) &&
            (s_process.status & INPUT_HAS_MULTIPLE_IMAGES) &&
            (reductions != 0x0000) &&
            !s_options.snip)
        {
            usr_printf(
                "Can't reliably reduce APNG file; disabling reductions.\n"
                "(Did you want to -snip and optimize the first frame?)\n");
            reductions = 0x0000;
        }


        s_process.reductions =
            opng_reduce_image(s_read_ptr, s_read_info_ptr, reductions);


        if (s_process.reductions != 0x0000)
        {
            opng_load_image_info(s_read_ptr, s_read_info_ptr, 1);
            usr_printf("Reducing image to ");
            opng_print_image_info(0, 1, 1, 0);
            usr_printf("\n");
        }


        if (s_options.interlace >= 0 &&
            s_image.interlace_type != s_options.interlace)
        {
            s_image.interlace_type = s_options.interlace;

            s_process.status |= OUTPUT_NEEDS_NEW_IDAT;
        }
    }
    while (the_exception_context->caught = 0, the_exception_context->caught); } else { the_exception_context->caught = 1; } the_exception_context->penv = exception__prev[0]; } if (!the_exception_context->caught || ((status) = the_exception_context->v.etmp, 0)) { } else
    {

        png_data_freer(s_read_ptr, s_read_info_ptr,
                       1, 0xffffU);
        png_destroy_read_struct(&s_read_ptr, &s_read_info_ptr, 0);
        for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = status;
    }




    png_data_freer(s_read_ptr, s_read_info_ptr,
                   2, 0xffffU);
    png_destroy_read_struct(&s_read_ptr, &s_read_info_ptr, 0);
}







static void
opng_write_file(FILE *outfile,
                int compression_level, int memory_level,
                int compression_strategy, int filter)
{
    volatile opng_status_t status;

    { if (!(compression_level >= 1 && compression_level <= 9 && memory_level >= 1 && memory_level <= 9 && compression_strategy >= 0 && compression_strategy <= 3 && filter >= 0 && filter <= 5)) usr_panic("Invalid encoding parameters"); }







                                              ;

    status = OPNG_STATUS_OK;
    { jmp_buf *exception__prev[1]; jmp_buf exception__env; exception__prev[0] = the_exception_context->penv; the_exception_context->penv = &exception__env; if (setjmp(exception__env) == 0) { do
    {
        s_write_ptr = png_create_write_struct("1.6.40",
                                              0, opng_error, opng_warning);
        s_write_info_ptr = png_create_info_struct(s_write_ptr);
        if (s_write_info_ptr == 0)
            opng_throw_error("Can't create image encoder");

        png_set_compression_level(s_write_ptr, compression_level);
        png_set_compression_mem_level(s_write_ptr, memory_level);
        png_set_compression_strategy(s_write_ptr, compression_strategy);
        png_set_filter(s_write_ptr, 0,
                       k_filter_table[filter]);
        if (compression_strategy != 2 &&
            compression_strategy != 3)
        {
            if (s_options.window_bits > 0)
                png_set_compression_window_bits(s_write_ptr,
                                                s_options.window_bits);
        }
        else
        {



            png_set_compression_window_bits(s_write_ptr, 9);

        }


        png_set_keep_unknown_chunks(s_write_ptr,
                                    3, 0, 0);
        png_set_user_limits(s_write_ptr, ((png_uint_32)0x7fffffffL), ((png_uint_32)0x7fffffffL));


        opng_store_image_info(s_write_ptr, s_write_info_ptr, outfile != 0);
        opng_init_write_data();
        png_set_write_fn(s_write_ptr, outfile, opng_write_data, 0);
        png_write_png(s_write_ptr, s_write_info_ptr, 0, 0);
    }
    while (the_exception_context->caught = 0, the_exception_context->caught); } else { the_exception_context->caught = 1; } the_exception_context->penv = exception__prev[0]; } if (!the_exception_context->caught || ((status) = the_exception_context->v.etmp, 0)) { } else
    {

        s_process.out_idat_size = k_idat_size_max + 1;
    }


    png_destroy_write_struct(&s_write_ptr, &s_write_info_ptr);

    if (status != OPNG_STATUS_OK)
        for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = status;
}




static void
opng_copy_file(FILE *infile, FILE *outfile)
{
    volatile png_bytep buf;
    const png_uint_32 buf_size_incr = 0x1000;
    png_uint_32 buf_size, length;
    png_byte chunk_hdr[8];
    volatile opng_status_t status;

    s_write_ptr = png_create_write_struct("1.6.40",
                                          0, opng_error, opng_warning);
    if (s_write_ptr == 0)
        opng_throw_error("Can't create image encoder");
    opng_init_write_data();
    png_set_write_fn(s_write_ptr, outfile, opng_write_data, 0);

    status = OPNG_STATUS_OK;
    { jmp_buf *exception__prev[1]; jmp_buf exception__env; exception__prev[0] = the_exception_context->penv; the_exception_context->penv = &exception__env; if (setjmp(exception__env) == 0) { do
    {
        buf = 0;
        buf_size = 0;


        png_write_sig(s_write_ptr);



        do
        {
            if (fread(chunk_hdr, 8, 1, infile) != 1)
                opng_throw_error("Read error");
            length = (((png_uint_32)(*(chunk_hdr)) << 24) + ((png_uint_32)(*((chunk_hdr) + 1)) << 16) + ((png_uint_32)(*((chunk_hdr) + 2)) << 8) + ((png_uint_32)(*((chunk_hdr) + 3))));
            if (length > ((png_uint_32)0x7fffffffL))
            {
                if (buf == 0 && length == 0x89504e47UL)
                {

                    continue;
                }
                opng_throw_error("Data error");
            }
            if (length + 4 > buf_size)
            {
                png_free(s_write_ptr, buf);
                buf_size =
                    (((length + 4) + (buf_size_incr - 1)) / buf_size_incr) *
                    buf_size_incr;
                buf = (png_bytep)png_malloc(s_write_ptr, buf_size);

            }
            if (fread(buf, length + 4, 1, infile) != 1)
                opng_throw_error("Read error");
            png_write_chunk(s_write_ptr, chunk_hdr + 4, buf, length);
        } while (memcmp(chunk_hdr + 4, k_sig_IEND, 4) != 0);
    }
    while (the_exception_context->caught = 0, the_exception_context->caught); } else { the_exception_context->caught = 1; } the_exception_context->penv = exception__prev[0]; } if (!the_exception_context->caught || ((status) = the_exception_context->v.etmp, 0)) { } else
    {
    }

    png_free(s_write_ptr, buf);
    png_destroy_write_struct(&s_write_ptr, 0);

    if (status != OPNG_STATUS_OK)
        for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = status;
}




static void
opng_init_iteration(opng_bitset_t cmdline_set, opng_bitset_t mask_set,
                    const char *preset, opng_bitset_t *output_set)
{
    opng_bitset_t preset_set;
    int check;

    *output_set = cmdline_set & mask_set;
    if (*output_set == 0 && cmdline_set != 0)
        opng_throw_error("Iteration parameter(s) out of range");
    if (s_options.optim_level >= 0 || *output_set == 0)
    {
        check =
            opng_strparse_rangeset_to_bitset(&preset_set, preset, mask_set);
        { if (!(check == 0)) usr_panic("[internal] Invalid preset"); };
        *output_set |= preset_set & mask_set;
    }
}




static void
opng_init_iterations(void)
{
    opng_bitset_t compr_level_set, mem_level_set, strategy_set, filter_set;
    opng_bitset_t strategy_singles_set;
    int preset_index;
    int t1, t2;





    if (s_options.full || (s_process.status & OUTPUT_NEEDS_NEW_IDAT))
        s_process.max_idat_size = k_idat_size_max;
    else
    {
        { if (!(s_process.in_idat_size > 0)) usr_panic("No IDAT in input"); };






        s_process.max_idat_size =
            s_process.in_idat_size + s_process.in_plte_trns_size;
    }





    preset_index = s_options.optim_level;
    if (preset_index < 0)
        preset_index = 2;
    else if (preset_index > 7)
        preset_index = 7;




    opng_init_iteration(s_options.compr_level_set, ((1 << (9+1)) - (1 << 1)),
                        k_presets[preset_index].compr_level, &compr_level_set);
    opng_init_iteration(s_options.mem_level_set, ((1 << (9+1)) - (1 << 1)),
                        k_presets[preset_index].mem_level, &mem_level_set);
    opng_init_iteration(s_options.strategy_set, ((1 << (3+1)) - (1 << 0)),
                        k_presets[preset_index].strategy, &strategy_set);
    opng_init_iteration(s_options.filter_set, ((1 << (5+1)) - (1 << 0)),
                        k_presets[preset_index].filter, &filter_set);


    if (compr_level_set == 0)
        (*(&compr_level_set) |= (1U << (9)));
    if (mem_level_set == 0)
        (*(&mem_level_set) |= (1U << (8)));
    if (s_image.bit_depth < 8 || s_image.palette != 0)
    {
        if (strategy_set == 0)
            (*(&strategy_set) |= (1U << (0)));
        if (filter_set == 0)
            (*(&filter_set) |= (1U << (0)));
    }
    else
    {
        if (strategy_set == 0)
            (*(&strategy_set) |= (1U << (1)));
        if (filter_set == 0)
            (*(&filter_set) |= (1U << (5)));
    }


    s_process.compr_level_set = compr_level_set;
    s_process.mem_level_set = mem_level_set;
    s_process.strategy_set = strategy_set;
    s_process.filter_set = filter_set;
    strategy_singles_set = (1 << 2) | (1 << 3);
    t1 = opng_bitset_count(compr_level_set) *
         opng_bitset_count(strategy_set & ~strategy_singles_set);
    t2 = opng_bitset_count(strategy_set & strategy_singles_set);
    s_process.num_iterations = (t1 + t2) *
                               opng_bitset_count(mem_level_set) *
                               opng_bitset_count(filter_set);
    { if (!(s_process.num_iterations > 0)) usr_panic("Invalid iteration parameters"); };
}




static void
opng_iterate(void)
{
    opng_bitset_t compr_level_set, mem_level_set, strategy_set, filter_set;
    int compr_level, mem_level, strategy, filter;
    int counter;
    int line_reused;

    { if (!(s_process.num_iterations > 0)) usr_panic("Iterations not initialized"); };

    compr_level_set = s_process.compr_level_set;
    mem_level_set = s_process.mem_level_set;
    strategy_set = s_process.strategy_set;
    filter_set = s_process.filter_set;

    if ((s_process.num_iterations == 1) &&
        (s_process.status & OUTPUT_NEEDS_NEW_IDAT))
    {

        s_process.best_idat_size = 0;
        s_process.best_compr_level = opng_bitset_find_first(compr_level_set);
        s_process.best_mem_level = opng_bitset_find_first(mem_level_set);
        s_process.best_strategy = opng_bitset_find_first(strategy_set);
        s_process.best_filter = opng_bitset_find_first(filter_set);
        return;
    }


    s_process.best_idat_size = k_idat_size_max + 1;
    s_process.best_compr_level = -1;
    s_process.best_mem_level = -1;
    s_process.best_strategy = -1;
    s_process.best_filter = -1;


    usr_printf("\nTrying:\n");
    line_reused = 0;
    counter = 0;
    for (filter = 0;
         filter <= 5;
         ++filter)
    {
        if (!(((filter_set) & (1U << (filter))) != 0))
            continue;
        for (strategy = 0;
             strategy <= 3;
             ++strategy)
        {
            if (!(((strategy_set) & (1U << (strategy))) != 0))
                continue;
            if (strategy == 2)
            {




                compr_level_set = 0;
                (*(&compr_level_set) |= (1U << (1)));
            }
            else if (strategy == 3)
            {




                compr_level_set = 0;
                (*(&compr_level_set) |= (1U << (9)));
            }
            else
            {

                compr_level_set = s_process.compr_level_set;
            }
            for (compr_level = 9;
                 compr_level >= 1;
                 --compr_level)
            {
                if (!(((compr_level_set) & (1U << (compr_level))) != 0))
                    continue;
                for (mem_level = 9;
                     mem_level >= 1;
                     --mem_level)
                {
                    if (!(((mem_level_set) & (1U << (mem_level))) != 0))
                        continue;
                    usr_printf("  zc = %d  zm = %d  zs = %d  f = %d",
                               compr_level, mem_level, strategy, filter);
                    usr_progress(counter, s_process.num_iterations);
                    ++counter;
                    opng_write_file(0,
                                    compr_level, mem_level, strategy, filter);
                    if (s_process.out_idat_size > k_idat_size_max)
                    {
                        if (s_options.verbose)
                        {
                            usr_printf("\t\tIDAT too big\n");
                            line_reused = 0;
                        }
                        else
                        {
                            usr_print_cntrl('\r');
                            line_reused = 1;
                        }
                        continue;
                    }
                    usr_printf("\t\tIDAT size = %" "lu" "\n",
                               s_process.out_idat_size);
                    line_reused = 0;
                    if (s_process.best_idat_size < s_process.out_idat_size)
                    {



                        continue;
                    }
                    if (s_process.best_idat_size == s_process.out_idat_size &&
                        (s_process.best_strategy == 2 ||
                         s_process.best_strategy == 3))
                    {




                        continue;
                    }
                    s_process.best_compr_level = compr_level;
                    s_process.best_mem_level = mem_level;
                    s_process.best_strategy = strategy;
                    s_process.best_filter = filter;
                    s_process.best_idat_size = s_process.out_idat_size;
                    if (!s_options.full)
                        s_process.max_idat_size = s_process.out_idat_size;
                }
            }
        }
    }
    if (line_reused)
        usr_print_cntrl(-31);

    { if (!(counter == s_process.num_iterations)) usr_panic("Inconsistent iteration counter"); }
                                                 ;
    usr_progress(counter, s_process.num_iterations);
}




static void
opng_finish_iterations(void)
{
    if (s_process.best_idat_size + s_process.out_plte_trns_size <
        s_process.in_idat_size + s_process.in_plte_trns_size)
        s_process.status |= OUTPUT_NEEDS_NEW_IDAT;
    if (s_process.status & OUTPUT_NEEDS_NEW_IDAT)
    {
        if (s_process.best_idat_size <= k_idat_size_max)
        {
            usr_printf("\nSelecting parameters:\n");
            usr_printf("  zc = %d  zm = %d  zs = %d  f = %d",
                       s_process.best_compr_level,
                       s_process.best_mem_level,
                       s_process.best_strategy,
                       s_process.best_filter);
            if (s_process.best_idat_size > 0)
            {

                usr_printf("\t\tIDAT size = %" "lu",
                           s_process.best_idat_size);
            }
            usr_printf("\n");
        }
        else
        {

            usr_printf("  zc = *  zm = *  zs = *  f = *\t\tIDAT size > %s\n",
                       k_idat_size_max_string);
        }
    }
}




static void
opng_optimize_impl(const char *infile_name)
{
    static FILE *infile, *outfile;
    static const char *infile_name_local;
    static const char *outfile_name, *bakfile_name;
    static int new_outfile, has_backup;
    char name_buf[1024], tmp_buf[1024];
    volatile opng_status_t status;

    memset(&s_process, 0, sizeof(s_process));
    if (s_options.force)
        s_process.status |= OUTPUT_NEEDS_NEW_IDAT;

    infile_name_local = infile_name;
    if ((infile = fopen(infile_name_local, "rb")) == 0)
        opng_throw_error("Can't open the input file");

    status = OPNG_STATUS_OK;
    { jmp_buf *exception__prev[1]; jmp_buf exception__env; exception__prev[0] = the_exception_context->penv; the_exception_context->penv = &exception__env; if (setjmp(exception__env) == 0) { do
    {
        opng_read_file(infile);
    }
    while (the_exception_context->caught = 0, the_exception_context->caught); } else { the_exception_context->caught = 1; } the_exception_context->penv = exception__prev[0]; } if (!the_exception_context->caught || ((status) = the_exception_context->v.etmp, 0)) { } else
    {
        { if (!(status != OPNG_STATUS_OK)) usr_panic("opng_read_file should throw errors only"); }
                                                              ;
    }
    fclose(infile);
    if (status != OPNG_STATUS_OK)
        for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = status;


    if (s_process.status & INPUT_HAS_ERRORS)
    {
        usr_printf("Recoverable errors found in input.");
        if (s_options.fix)
        {
            usr_printf(" Fixing...\n");
            s_process.status |= OUTPUT_NEEDS_NEW_FILE;
        }
        else
        {
            usr_printf(" Rerun " "OptiPNG" " with -fix enabled.\n");
            opng_throw_error("Previous error(s) not fixed");
        }
    }


    if (s_process.status & INPUT_HAS_JUNK)
        s_process.status |= OUTPUT_NEEDS_NEW_FILE;


    if (!(s_process.status & INPUT_HAS_PNG_SIGNATURE))
        s_process.status |= OUTPUT_NEEDS_NEW_FILE;
    if (s_process.status & INPUT_HAS_PNG_DATASTREAM)
    {
        if (s_options.nz && (s_process.status & OUTPUT_NEEDS_NEW_IDAT))
        {
            usr_printf(
                "IDAT recoding is necessary, but is disabled by the user.\n");
            opng_throw_error("Can't continue");
        }
    }
    else
        s_process.status |= OUTPUT_NEEDS_NEW_IDAT;


    if (s_process.status & INPUT_HAS_DIGITAL_SIGNATURE)
    {
        usr_printf("Digital signature found in input.");
        if (s_options.force)
        {
            usr_printf(" Erasing...\n");
            s_process.status |= OUTPUT_NEEDS_NEW_FILE;
        }
        else
        {
            usr_printf(" Rerun " "OptiPNG" " with -force enabled.\n");
            opng_throw_error("Can't optimize digitally-signed files");
        }
    }


    if (s_process.status & INPUT_HAS_MULTIPLE_IMAGES)
    {
        if (!s_options.snip && !(s_process.status & INPUT_IS_PNG_FILE))
        {
            usr_printf("Conversion to PNG requires snipping. "
                       "Rerun " "OptiPNG" " with -snip enabled.\n");
            opng_throw_error("Incompatible input format");
        }
    }
    if (s_options.snip && (s_process.status & INPUT_HAS_APNG))
        s_process.status |= OUTPUT_NEEDS_NEW_FILE;


    if (s_process.status & INPUT_HAS_STRIPPED_DATA)
        usr_printf("Stripping metadata...\n");


    outfile_name = 0;
    if (!(s_process.status & INPUT_IS_PNG_FILE))
    {
        if (opng_path_replace_ext(name_buf, sizeof(name_buf),
                                  infile_name_local, ".png") == 0)
            opng_throw_error("Can't create the output file (name too long)");
        outfile_name = name_buf;
    }
    if (s_options.out_name != 0)
    {

        outfile_name = s_options.out_name;
    }
    if (s_options.dir_name != 0)
    {
        const char *tmp_name;
        if (outfile_name != 0)
        {
            strcpy(tmp_buf, outfile_name);
            tmp_name = tmp_buf;
        }
        else
            tmp_name = infile_name_local;
        if (opng_path_replace_dir(name_buf, sizeof(name_buf),
                                  tmp_name, s_options.dir_name) == 0)
            opng_throw_error("Can't create the output file (name too long)");
        outfile_name = name_buf;
    }
    if (outfile_name == 0)
    {
        outfile_name = infile_name_local;
        new_outfile = 0;
    }
    else
    {
        int test_eq = opng_os_test_file_equiv(infile_name_local, outfile_name);
        if (test_eq >= 0)
        {



            new_outfile = (test_eq == 0);
        }
        else
        {



            new_outfile = (strcmp(infile_name_local, outfile_name) != 0);
        }
    }


    bakfile_name = tmp_buf;
    if (new_outfile)
    {
        if (opng_path_make_backup(tmp_buf, sizeof(tmp_buf),
                                  outfile_name) == 0)
            bakfile_name = 0;
    }
    else
    {
        if (opng_path_make_backup(tmp_buf, sizeof(tmp_buf),
                                  infile_name_local) == 0)
            bakfile_name = 0;
    }

    if (bakfile_name == 0)
        opng_throw_error("Can't create backup file (name too long)");

    if (!s_options.simulate &&
        opng_os_test_file_access(outfile_name, "e") == 0)
    {
        if (!s_options.backup && !s_options.clobber && new_outfile)
        {
            usr_printf("The output file exists. "
                       "Rerun " "OptiPNG" " with -backup enabled.\n");
            opng_throw_error("Can't overwrite the output file");
        }
        if (opng_os_test_file_access(outfile_name, "fw") != 0 ||
            (!s_options.clobber &&
             opng_os_test_file_access(bakfile_name, "e") == 0))
        {
            usr_printf("A backup file already exists. "
                       "Rerun " "OptiPNG" " with -clobber enabled.\n");
            opng_throw_error("Can't back up the existing output file");
        }
    }


    if (s_process.status & INPUT_HAS_PNG_DATASTREAM)
        usr_printf("Input IDAT size = %" "lu" " bytes\n",
                   s_process.in_idat_size);
    usr_printf("Input file size = %" "lu" " bytes\n",
               s_process.in_file_size);


    if (!s_options.nz || (s_process.status & OUTPUT_NEEDS_NEW_IDAT))
    {
        opng_init_iterations();
        opng_iterate();
        opng_finish_iterations();
    }
    if (s_process.status & OUTPUT_NEEDS_NEW_IDAT)
    {
        s_process.status |= OUTPUT_NEEDS_NEW_FILE;
        opng_check_idat_size(s_process.best_idat_size);
    }


    if (!(s_process.status & OUTPUT_NEEDS_NEW_FILE))
    {
        usr_printf("\n%s is already optimized.\n", infile_name_local);
        if (!new_outfile)
            return;
    }
    if (s_options.simulate)
    {
        usr_printf("\nNo output: simulation mode.\n");
        return;
    }


    if (new_outfile)
    {
        usr_printf("\nOutput file: %s\n", outfile_name);
        if (s_options.dir_name != 0)
            opng_os_create_dir(s_options.dir_name);
        has_backup = 0;
        if (opng_os_test_file_access(outfile_name, "e") == 0)
        {
            if (opng_os_rename(outfile_name, bakfile_name,
                               s_options.clobber) != 0)
                opng_throw_error("Can't back up the output file");
            has_backup = 1;
        }
    }
    else
    {
        if (opng_os_rename(infile_name_local, bakfile_name,
                           s_options.clobber) != 0)
            opng_throw_error("Can't back up the input file");
        has_backup = 1;
    }

    outfile = fopen(outfile_name, "wb");
    { jmp_buf *exception__prev[1]; jmp_buf exception__env; exception__prev[0] = the_exception_context->penv; the_exception_context->penv = &exception__env; if (setjmp(exception__env) == 0) { do
    {
        if (outfile == 0)
            opng_throw_error("Can't open the output file");
        if (s_process.status & OUTPUT_NEEDS_NEW_IDAT)
        {

            opng_write_file(outfile,
                            s_process.best_compr_level,
                            s_process.best_mem_level,
                            s_process.best_strategy,
                            s_process.best_filter);
        }
        else
        {

            infile = fopen(new_outfile ? infile_name_local : bakfile_name,
                           "rb");
            if (infile == 0)
                opng_throw_error("Can't reopen the input file");
            { jmp_buf *exception__prev[1]; jmp_buf exception__env; exception__prev[0] = the_exception_context->penv; the_exception_context->penv = &exception__env; if (setjmp(exception__env) == 0) { do
            {
                if (s_process.in_datastream_offset > 0 &&
                    opng_fseeko(infile, s_process.in_datastream_offset,
                                0) != 0)
                    opng_throw_error("Can't reposition the input file");
                s_process.best_idat_size = s_process.in_idat_size;
                opng_copy_file(infile, outfile);
            }
            while (the_exception_context->caught = 0, the_exception_context->caught); } else { the_exception_context->caught = 1; } the_exception_context->penv = exception__prev[0]; } if (!the_exception_context->caught || ((status) = the_exception_context->v.etmp, 0)) { } else
            {
                { if (!(status != OPNG_STATUS_OK)) usr_panic("opng_copy_file should throw errors only"); }
                                                                      ;
            }
            fclose(infile);
            if (status != OPNG_STATUS_OK)
                for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = status;
        }
    }
    while (the_exception_context->caught = 0, the_exception_context->caught); } else { the_exception_context->caught = 1; } the_exception_context->penv = exception__prev[0]; } if (!the_exception_context->caught || ((status) = the_exception_context->v.etmp, 0)) { } else
    {
        if (outfile != 0)
            fclose(outfile);

        if (has_backup)
        {
            if (opng_os_rename(bakfile_name,
                               new_outfile ? outfile_name : infile_name_local,
                               1) != 0)
                opng_print_warning(
                    "Can't recover the original file from backup");
        }
        else
        {
            { if (!(new_outfile)) usr_panic("Overwrote input with no temporary backup"); }
                                                                   ;
            if (opng_os_unlink(outfile_name) != 0)
                opng_print_warning("Can't remove the broken output file");
        }
        for (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp = status;
    }
    fclose(outfile);




    if (s_options.preserve)
        opng_os_copy_file_attr(new_outfile ? infile_name_local : bakfile_name,
                               outfile_name);


    if (!s_options.backup && !new_outfile)
    {
        if (opng_os_unlink(bakfile_name) != 0)
            opng_print_warning("Can't remove the backup file");
    }


    usr_printf("\nOutput IDAT size = %" "lu" " bytes",
               s_process.out_idat_size);
    if (s_process.status & INPUT_HAS_PNG_DATASTREAM)
    {
        usr_printf(" (");
        opng_print_fsize_difference(s_process.in_idat_size,
                                    s_process.out_idat_size, 0);
        usr_printf(")");
    }
    usr_printf("\nOutput file size = %" "lu" " bytes (",
               s_process.out_file_size);
    opng_print_fsize_difference(s_process.in_file_size,
                                s_process.out_file_size, 1);
    usr_printf(")\n");
}




int
opng_initialize(const struct opng_options *init_options,
                const struct opng_ui *init_ui)
{

    usr_printf = init_ui->printf_fn;
    usr_print_cntrl = init_ui->print_cntrl_fn;
    usr_progress = init_ui->progress_fn;
    usr_panic = init_ui->panic_fn;
    if (usr_printf == 0 ||
        usr_print_cntrl == 0 ||
        usr_progress == 0 ||
        usr_panic == 0)
        return -1;


    s_options = *init_options;
    if (s_options.optim_level == 0)
    {
        s_options.nb = s_options.nc = s_options.np = 1;
        s_options.nz = 1;
    }


    memset(&s_summary, 0, sizeof(s_summary));
    s_engine.started = 1;
    return 0;
}




int
opng_optimize(const char *infile_name)
{
    opng_status_t status;
    volatile int result;

    { if (!(s_engine.started)) usr_panic("The OptiPNG engine is not running"); };

    usr_printf("** Processing: %s\n", infile_name);
    ++s_summary.file_count;
    opng_clear_image_info();
    { jmp_buf *exception__prev[1]; jmp_buf exception__env; exception__prev[0] = the_exception_context->penv; the_exception_context->penv = &exception__env; if (setjmp(exception__env) == 0) { do
    {
        opng_optimize_impl(infile_name);
        if (s_process.status & INPUT_HAS_ERRORS)
        {
            ++s_summary.err_count;
            ++s_summary.fix_count;
        }
        if (s_process.status & INPUT_HAS_MULTIPLE_IMAGES)
        {
            if (s_options.snip)
                ++s_summary.snip_count;
        }
        result = 0;
    }
    while (the_exception_context->caught = 0, the_exception_context->caught); } else { the_exception_context->caught = 1; } the_exception_context->penv = exception__prev[0]; } if (!the_exception_context->caught || ((status) = the_exception_context->v.etmp, 0)) { } else
    {
        { if (!(status != OPNG_STATUS_OK)) usr_panic("opng_optimize_impl should throw errors only"); }
                                                                  ;
        ++s_summary.err_count;
        result = -1;
    }
    opng_destroy_image_info();
    usr_printf("\n");
    return result;
}




int
opng_finalize(void)
{

    if (s_options.verbose ||
        s_summary.snip_count > 0 ||
        s_summary.err_count > 0)
    {
        usr_printf("** Status report\n");
        usr_printf("%u file(s) have been processed.\n", s_summary.file_count);
        if (s_summary.snip_count > 0)
        {
            usr_printf("%u multi-image file(s) have been snipped.\n",
                       s_summary.snip_count);
        }
        if (s_summary.err_count > 0)
        {
            usr_printf("%u error(s) have been encountered.\n",
                       s_summary.err_count);
            if (s_summary.fix_count > 0)
                usr_printf("%u erroneous file(s) have been fixed.\n",
                           s_summary.fix_count);
        }
    }


    s_engine.started = 0;
    return 0;
}
