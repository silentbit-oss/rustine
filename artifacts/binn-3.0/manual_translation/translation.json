{
    "BOOL": {
        "source_code": "typedef int BOOL",
        "translated_code": "pub type BOOL = i32;",
        "hint": "typedef",
        "section": "src",
        "file": "types.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "int64": {
        "source_code": "typedef long long int int64",
        "translated_code": "pub type int64 = i64;",
        "hint": "typedef",
        "section": "src",
        "file": "types.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "uint64": {
        "source_code": "typedef unsigned long long int uint64",
        "translated_code": "pub type uint64 = u64;",
        "hint": "typedef",
        "section": "src",
        "file": "types.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "u16": {
        "source_code": "typedef unsigned short int u16",
        "translated_code": "// No need to redefine u16 as it's already a built-in type in Rust",
        "hint": "typedef",
        "section": "src",
        "file": "types.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "u32": {
        "source_code": "typedef unsigned int u32",
        "translated_code": "pub type u32 = std::os::raw::c_uint;",
        "hint": "typedef",
        "section": "src",
        "file": "types.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "u64": {
        "source_code": "typedef unsigned long long int u64",
        "translated_code": "// No need to redefine u64 as it's a primitive type in Rust\n// The C typedef `unsigned long long int` is equivalent to Rust's u64",
        "hint": "typedef",
        "section": "src",
        "file": "types.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_mem_free": {
        "source_code": "typedef void (*binn_mem_free)(void *)",
        "translated_code": "pub type BinnMemFree = Option<Box<dyn FnMut(Option<Box<()>>)>>;",
        "hint": "special_types",
        "section": "src",
        "file": "binn_mem_free.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.FuncDecl'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_iter": {
        "source_code": "typedef struct binn_iter_struct\n{\n  unsigned char *pnext;\n  unsigned char *plimit;\n  int type;\n  int count;\n  int current;\n} binn_iter",
        "translated_code": "#[derive(Clone)]\npub struct BinnIter {\n    pub pnext: Option<Vec<u8>>,\n    pub plimit: Option<Vec<u8>>,\n    pub type_: i32,\n    pub count: i32,\n    pub current: i32,\n}",
        "hint": "special_types",
        "section": "src",
        "file": "binn_iter.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "malloc_fn": {
        "source_code": "void *(*malloc_fn)(size_t len) = 0",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::Mutex;\n\nlazy_static! {\n    pub static ref MALLOC_FN: Mutex<Option<fn(usize) -> Option<Box<dyn std::any::Any>>>> = \n        Mutex::new(None);\n}",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "void *(*)(size_t len)",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "realloc_fn": {
        "source_code": "void *(*realloc_fn)(void *ptr, size_t len) = 0",
        "translated_code": "use std::sync::Mutex;\n\n// Newtype wrapper for our closure to allow implementing Send/Sync\npub struct ReallocFnWrapper(\n    Box<dyn FnMut(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>> + Send>\n);\n\n// Safe to send between threads since we require Send in the inner type\nunsafe impl Send for ReallocFnWrapper {}\n// Safe to share references between threads since we require Send in the inner type\nunsafe impl Sync for ReallocFnWrapper {}\n\nlazy_static::lazy_static! {\n    pub static ref REALLOC_FN: Mutex<Option<ReallocFnWrapper>> = Mutex::new(None);\n}",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "void *(*)(void *ptr, size_t len)",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "free_fn": {
        "source_code": "void (*free_fn)(void *ptr) = 0",
        "translated_code": "// Newtype wrapper for our closure to allow implementing Send/Sync\npub struct FreeFnWrapper(Box<dyn FnMut(Option<Box<dyn std::any::Any + Send>>)>);\n\n// SAFETY: We ensure thread-safety by requiring Send in the wrapper\nunsafe impl Send for FreeFnWrapper {}\nunsafe impl Sync for FreeFnWrapper {}\n\nlazy_static::lazy_static! {\n    pub static ref FREE_FN: Mutex<Option<FreeFnWrapper>> = Mutex::new(None);\n}",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "void (*)(void *ptr)",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "MY_DATE": {
        "source_code": "int MY_DATE",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::atomic::{AtomicI32, Ordering};\n\nlazy_static! {\n    pub static ref MY_DATE: AtomicI32 = AtomicI32::new(0);\n}",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "int",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "MY_CURRENCY": {
        "source_code": "int MY_CURRENCY",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::atomic::{AtomicI32, Ordering};\n\nlazy_static! {\n    pub static ref MY_CURRENCY: AtomicI32 = AtomicI32::new(0);\n}",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "int",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "tmp": {
        "source_code": "char tmp[128]",
        "translated_code": "use lazy_static::lazy_static;\n\nlazy_static! {\n    pub static ref TMP: std::sync::Mutex<[u8; 128]> = std::sync::Mutex::new([0; 128]);\n}",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "char [128]",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "vint32": {
        "source_code": "int vint32",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::atomic::{AtomicI32, Ordering};\n\nlazy_static! {\n    pub static ref VINT32: AtomicI32 = AtomicI32::new(0);\n}",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "int",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "vuint32": {
        "source_code": "unsigned int vuint32",
        "translated_code": "pub type vuint32 = u32;",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "unsigned int",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "vint16": {
        "source_code": "short vint16",
        "translated_code": "pub type vint16 = i16;",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "short",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "vuint16": {
        "source_code": "unsigned short vuint16",
        "translated_code": "pub type vuint16 = u16;",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "unsigned short",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "vint8": {
        "source_code": "signed char vint8",
        "translated_code": "pub static mut VINT8: i8 = 0;",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "signed char",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "vuint8": {
        "source_code": "unsigned char vuint8",
        "translated_code": "pub type vuint8 = u8;",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "unsigned char",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "vfloat32": {
        "source_code": "float vfloat32",
        "translated_code": "pub static mut vfloat32: f32 = 0.0;",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "float",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "vfloat64": {
        "source_code": "double vfloat64",
        "translated_code": "pub static mut vfloat64: f64 = 0.0;",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "double",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "memdup": {
        "source_code": "void *memdup(void *src, int size)\n{\n  void *dest;\n  unsigned int dest_idx = 0;\n  if ((src == 0) || (size <= 0))\n  {\n    return 0;\n  }\n  dest_idx = malloc(size);\n  if ((&dest[dest_idx]) == 0)\n  {\n    return 0;\n  }\n  memcpy(dest, src, size);\n  return dest;\n}\n\n",
        "translated_code": "use std::alloc::{alloc, Layout};\nuse std::ptr;\n\npub fn memdup(src: Option<&[u8]>, size: usize) -> Option<Box<[u8]>> {\n    // Check for NULL pointer or invalid size (equivalent to C checks)\n    if src.is_none() || size == 0 {\n        return None;\n    }\n\n    let src = src.unwrap();\n    \n    // Allocate memory using Rust's allocator\n    let layout = match Layout::array::<u8>(size) {\n        Ok(layout) => layout,\n        Err(_) => return None, // Allocation failed\n    };\n\n    // SAFETY: We've checked size > 0 and layout is valid\n    let dest = unsafe { alloc(layout) };\n    if dest.is_null() {\n        return None;\n    }\n\n    // Copy the memory\n    unsafe {\n        ptr::copy_nonoverlapping(src.as_ptr(), dest, size);\n    }\n\n    // Convert the raw pointer into a Box<[u8]> for safe memory management\n    Some(unsafe { Box::from_raw(ptr::slice_from_raw_parts_mut(dest, size)) })\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [],
        "params": [
            "void *src",
            "int size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "src",
            "size",
            "dest",
            "dest_idx"
        ],
        "calle": [
            "malloc",
            "memcpy"
        ],
        "calle_c": [
            "malloc",
            "memcpy"
        ],
        "key": "memdup",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "return_int64": {
        "source_code": "int64 return_int64()\n{\n  return 9223372036854775807;\n}\n\n",
        "translated_code": "pub fn return_int64() -> i64 {\n    9223372036854775807\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "key": "return_int64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "AlmostEqualFloats": {
        "source_code": "BOOL AlmostEqualFloats(float A, float B, int maxUlps)\n{\n  int aInt;\n  int bInt;\n  int intDiff;\n  assert((maxUlps > 0) && (maxUlps < ((4 * 1024) * 1024)));\n  aInt = *((int *) (&A));\n  bInt = *((int *) (&B));\n  if (aInt < 0)\n  {\n    aInt = 0x80000000 - aInt;\n  }\n  if (bInt < 0)\n  {\n    bInt = 0x80000000 - bInt;\n  }\n  intDiff = abs(aInt - bInt);\n  if (intDiff <= maxUlps)\n  {\n    return 1;\n  }\n  return 0;\n}\n\n",
        "translated_code": "pub fn AlmostEqualFloats(A: f32, B: f32, maxUlps: i32) -> bool {\n    // Check the assertion condition (maxUlps must be in valid range)\n    assert!((maxUlps > 0) && (maxUlps < ((4 * 1024) * 1024)));\n\n    // Convert floats to their bit representations as i32\n    let aInt = A.to_bits() as i32;\n    let bInt = B.to_bits() as i32;\n\n    // Handle negative numbers by adjusting their representation\n    let aInt = if aInt < 0 {\n        (0x80000000u32 as i32).wrapping_sub(aInt)\n    } else {\n        aInt\n    };\n\n    let bInt = if bInt < 0 {\n        (0x80000000u32 as i32).wrapping_sub(bInt)\n    } else {\n        bInt\n    };\n\n    // Calculate absolute difference between the integer representations\n    let intDiff = (aInt - bInt).abs();\n\n    // Compare against the maximum allowed difference\n    intDiff <= maxUlps\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [],
        "params": [
            "float A",
            "float B",
            "int maxUlps"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "A",
            "B",
            "maxUlps",
            "aInt",
            "bInt",
            "intDiff"
        ],
        "calle": [
            "abs",
            "assert"
        ],
        "calle_c": [
            "abs",
            "assert"
        ],
        "key": "AlmostEqualFloats",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "AlmostEqualDoubles": {
        "source_code": "BOOL AlmostEqualDoubles(double a, double b)\n{\n  double absDiff;\n  double maxAbs;\n  double absA;\n  double absB;\n  absDiff = fabs(a - b);\n  if (absDiff < 1.0E-150)\n  {\n    return 1;\n  }\n  absA = fabs(a);\n  absB = fabs(b);\n  maxAbs = (absA > absB) ? (absA) : (absB);\n  if ((absDiff / maxAbs) < 1.0E-8)\n  {\n    return 1;\n  }\n  printf(\"a=%g b=%g\\n\", a, b);\n  return 0;\n}\n\n",
        "translated_code": "use std::f64;\nuse std::io::{self, Write};\n\npub fn AlmostEqualDoubles(a: f64, b: f64) -> bool {\n    let absDiff = f64::abs(a - b);\n    if absDiff < 1.0E-150 {\n        return true;\n    }\n\n    let absA = f64::abs(a);\n    let absB = f64::abs(b);\n    let maxAbs = if absA > absB { absA } else { absB };\n\n    if (absDiff / maxAbs) < 1.0E-8 {\n        return true;\n    }\n\n    writeln!(io::stdout(), \"a={} b={}\", a, b).unwrap();\n    false\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [],
        "params": [
            "double a",
            "double b"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "a",
            "b",
            "absDiff",
            "maxAbs",
            "absA",
            "absB"
        ],
        "calle": [
            "printf",
            "fabs"
        ],
        "calle_c": [
            "printf",
            "fabs"
        ],
        "key": "AlmostEqualDoubles",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "stripchr": {
        "source_code": "char *stripchr(char *mainstr, int separator)\n{\n  char *ptr;\n  unsigned int ptr_idx = 0;\n  if (mainstr == 0)\n  {\n    return 0;\n  }\n  ptr_idx = strchr(mainstr, separator);\n  if ((&ptr[ptr_idx]) == 0)\n  {\n    return 0;\n  }\n  ptr[0 + ptr_idx] = '\\0';\n  ptr_idx += 1;\n  return ptr;\n}\n\n",
        "translated_code": "pub fn stripchr(mainstr: Option<&mut [u8]>, separator: u8) -> Option<&mut [u8]> {\n    // Check for NULL equivalent (None)\n    let mainstr = mainstr?;\n\n    // Find the position of the separator (equivalent to strchr)\n    let pos = mainstr.iter().position(|&c| c == separator)?;\n\n    // Split the slice at the separator position\n    let (left, right) = mainstr.split_at_mut(pos);\n    \n    // Null-terminate at the separator position (if needed)\n    if !right.is_empty() {\n        right[0] = b'\\0';\n    }\n\n    // Return the left part (up to but not including the separator)\n    Some(left)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [],
        "params": [
            "char *mainstr",
            "int separator"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "mainstr",
            "separator",
            "ptr",
            "ptr_idx"
        ],
        "calle": [
            "strchr"
        ],
        "calle_c": [
            "strchr"
        ],
        "key": "stripchr",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "test_value_copy": {
        "source_code": "void test_value_copy()\n{\n  printf(\"testing binn value copy... \");\n  puts(\"TODO!!!\");\n}\n\n",
        "translated_code": "pub fn test_value_copy() {\n    println!(\"testing binn value copy... \");\n    println!(\"TODO!!!\");\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [
            "puts",
            "printf"
        ],
        "calle_c": [
            "puts",
            "printf"
        ],
        "key": "test_value_copy",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_version": {
        "source_code": "char *binn_version()\n{\n  return \"3.0.0\";\n}\n\n",
        "translated_code": "pub fn binn_version() -> &'static str {\n    \"3.0.0\"\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [],
        "header": "char *binn_version()",
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "key": "binn_version",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_create_type": {
        "source_code": "int binn_create_type(int storage_type, int data_type_index)\n{\n  if (data_type_index < 0)\n  {\n    return -1;\n  }\n  if ((storage_type < 0x00) || (storage_type > 0xE0))\n  {\n    return -1;\n  }\n  if (data_type_index < 16)\n  {\n    return storage_type | data_type_index;\n  }\n  else\n    if (data_type_index < 4096)\n  {\n    storage_type |= 0x10;\n    storage_type <<= 8;\n    data_type_index >>= 4;\n    return storage_type | data_type_index;\n  }\n  else\n    return -1;\n}\n\n",
        "translated_code": "pub fn binn_create_type(storage_type: i32, data_type_index: i32) -> i32 {\n    if data_type_index < 0 {\n        return -1;\n    }\n    if (storage_type < 0x00) || (storage_type > 0xE0) {\n        return -1;\n    }\n    if data_type_index < 16 {\n        return storage_type | data_type_index;\n    } else if data_type_index < 4096 {\n        let mut storage_type = storage_type | 0x10;\n        storage_type <<= 8;\n        let data_type_index = data_type_index >> 4;\n        storage_type | data_type_index\n    } else {\n        -1\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [],
        "header": "int binn_create_type(int storage_type, int data_type_index)",
        "params": [
            "int storage_type",
            "int data_type_index"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "storage_type",
            "data_type_index"
        ],
        "calle": [],
        "calle_c": [],
        "key": "binn_create_type",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_is_struct": {
        "source_code": "BOOL binn_is_struct(void *ptr)\n{\n  if (ptr == 0)\n  {\n    return 0;\n  }\n  if ((*((unsigned int *) ptr)) == 0x1F22B11F)\n  {\n    return 1;\n  }\n  else\n  {\n    return 0;\n  }\n}\n\n",
        "translated_code": "pub fn binn_is_struct(ptr: Option<*mut u32>) -> bool {\n    // Check if pointer is None (equivalent to NULL in C)\n    let ptr = match ptr {\n        Some(p) => p,\n        None => return false,\n    };\n\n    // Dereference the pointer safely (requires unsafe block)\n    unsafe {\n        // Check if the value at the pointer matches the magic number\n        *ptr == 0x1F22B11F\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [],
        "header": "BOOL binn_is_struct(void *ptr)",
        "params": [
            "void *ptr"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr"
        ],
        "calle": [],
        "calle_c": [],
        "key": "binn_is_struct",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "strlen2": {
        "source_code": "static size_t strlen2(char *str)\n{\n  if (str == 0)\n  {\n    return 0;\n  }\n  return strlen(str);\n}\n\n",
        "translated_code": "pub fn strlen2(str: Option<&str>) -> usize {\n    match str {\n        None => 0,\n        Some(s) => s.len(),\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [],
        "params": [
            "char *str"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "str"
        ],
        "calle": [
            "strlen"
        ],
        "calle_c": [
            "strlen"
        ],
        "key": "strlen2",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_get_ptr_type": {
        "source_code": "static int binn_get_ptr_type(void *ptr)\n{\n  if (ptr == 0)\n  {\n    return 0;\n  }\n  switch (*((unsigned int *) ptr))\n  {\n    case 0x1F22B11F:\n      return 1;\n\n    default:\n      return 2;\n\n  }\n\n}\n\n",
        "translated_code": "pub fn binn_get_ptr_type(ptr: Option<*mut u8>) -> i32 {\n    match ptr {\n        None => 0,\n        Some(ptr) => unsafe {\n            match *(ptr as *const u32) {\n                0x1F22B11F => 1,\n                _ => 2,\n            }\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [],
        "params": [
            "void *ptr"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr"
        ],
        "calle": [],
        "calle_c": [],
        "key": "binn_get_ptr_type",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "CalcAllocation": {
        "source_code": "static int CalcAllocation(int needed_size, int alloc_size)\n{\n  int calc_size;\n  calc_size = alloc_size;\n  while (calc_size < needed_size)\n  {\n    calc_size <<= 1;\n  }\n\n  return calc_size;\n}\n\n",
        "translated_code": "pub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;\n    }\n    calc_size\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [],
        "params": [
            "int needed_size",
            "int alloc_size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "needed_size",
            "alloc_size",
            "calc_size"
        ],
        "calle": [],
        "calle_c": [],
        "key": "CalcAllocation",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "type_family": {
        "source_code": "static int type_family(int type)\n{\n  switch (type)\n  {\n    case 0xE0:\n\n    case 0xE1:\n\n    case 0xE2:\n      return 0xf7;\n\n    case 0x21:\n\n    case 0x41:\n\n    case 0x61:\n\n    case 0x81:\n\n    case 0x20:\n\n    case 0x40:\n\n    case 0x60:\n\n    case 0x80:\n      return 0xf2;\n\n    case 0x62:\n\n    case 0x82:\n\n    case 0xA6:\n\n    case 0xA7:\n      return 0xf3;\n\n    case 0xA0:\n\n    case 0xB001:\n\n    case 0xB005:\n\n    case 0xB002:\n\n    case 0xB003:\n\n    case 0xB004:\n      return 0xf4;\n\n    case 0xC0:\n\n    case 0xD001:\n\n    case 0xD002:\n\n    case 0xD003:\n\n    case 0xD004:\n      return 0xf5;\n\n    case 0xA4:\n\n    case 0x83:\n\n    case 0xA2:\n\n    case 0xA3:\n\n    case 0xA1:\n      return 0xf4;\n\n    case 0x80061:\n      return 0xf6;\n\n    case 0x00:\n      return 0xf1;\n\n    default:\n      return 0x00;\n\n  }\n\n}\n\n",
        "translated_code": "pub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => 0xf7,\n        0x21 | 0x41 | 0x61 | 0x81 | 0x20 | 0x40 | 0x60 | 0x80 => 0xf2,\n        0x62 | 0x82 | 0xA6 | 0xA7 => 0xf3,\n        0xA0 | 0xB001 | 0xB005 | 0xB002 | 0xB003 | 0xB004 => 0xf4,\n        0xC0 | 0xD001 | 0xD002 | 0xD003 | 0xD004 => 0xf5,\n        0xA4 | 0x83 | 0xA2 | 0xA3 | 0xA1 => 0xf4,\n        0x80061 => 0xf6,\n        0x00 => 0xf1,\n        _ => 0x00,\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [],
        "header": "static int type_family(int type)",
        "params": [
            "int type"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "type"
        ],
        "calle": [],
        "calle_c": [],
        "key": "type_family",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "GetWriteConvertedData": {
        "source_code": "static BOOL GetWriteConvertedData(int *ptype, void **ppvalue, int *psize)\n{\n  int type;\n  float f1;\n  double d1;\n  char pstr[128];\n  (void) pstr;\n  (void) d1;\n  (void) f1;\n  type = *ptype;\n  if ((*ppvalue) == 0)\n  {\n    switch (type)\n    {\n      case 0x00:\n\n      case 0x01:\n\n      case 0x02:\n        break;\n\n      case 0xA0:\n\n      case 0xC0:\n        if ((*psize) == 0)\n      {\n        break;\n      }\n\n      default:\n        return 0;\n\n    }\n\n  }\n  switch (type)\n  {\n    case 0xA4:\n\n    case 0xA5:\n      return 1;\n      break;\n\n    case 0xA2:\n\n    case 0xA1:\n\n    case 0xA3:\n      return 1;\n      break;\n\n    case 0x80061:\n      if ((*(*((BOOL **) ppvalue))) == 0)\n    {\n      type = 0x02;\n    }\n    else\n    {\n      type = 0x01;\n    }\n      *ptype = type;\n      break;\n\n  }\n\n  return 1;\n}\n\n",
        "translated_code": "pub fn GetWriteConvertedData(\n    ptype: &mut i32,\n    ppvalue: &mut Option<&mut Option<Box<dyn std::any::Any>>>,\n    psize: &mut i32,\n) -> bool {\n    let type_ = *ptype;\n    \n    if ppvalue.is_none() {\n        match type_ {\n            0x00 | 0x01 | 0x02 => {}\n            0xA0 | 0xC0 => {\n                if *psize == 0 {\n                    // Do nothing\n                } else {\n                    return false;\n                }\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        0xA4 | 0xA5 => return true,\n        0xA2 | 0xA1 | 0xA3 => return true,\n        0x80061 => {\n            if let Some(inner_ppvalue) = ppvalue {\n                if let Some(any_box) = inner_ppvalue {\n                    if let Some(bool_value) = any_box.downcast_ref::<bool>() {\n                        let new_type = if *bool_value { 0x01 } else { 0x02 };\n                        *ptype = new_type;\n                    }\n                }\n            }\n        }\n        _ => {}\n    }\n\n    true\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [],
        "params": [
            "int *ptype",
            "void **ppvalue",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptype",
            "ppvalue",
            "psize",
            "type",
            "f1",
            "d1",
            "pstr"
        ],
        "calle": [],
        "calle_c": [],
        "key": "GetWriteConvertedData",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "int_type": {
        "source_code": "static int int_type(int type)\n{\n  switch (type)\n  {\n    case 0x21:\n\n    case 0x41:\n\n    case 0x61:\n\n    case 0x81:\n      return 11;\n\n    case 0x20:\n\n    case 0x40:\n\n    case 0x60:\n\n    case 0x80:\n      return 22;\n\n    default:\n      return 0;\n\n  }\n\n}\n\n",
        "translated_code": "pub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        0x21 | 0x41 | 0x61 | 0x81 => 11,\n        0x20 | 0x40 | 0x60 | 0x80 => 22,\n        _ => 0,\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [],
        "params": [
            "int type"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "type"
        ],
        "calle": [],
        "calle_c": [],
        "key": "int_type",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "copy_raw_value": {
        "source_code": "static BOOL copy_raw_value(void *psource, void *pdest, int data_store)\n{\n  switch (data_store)\n  {\n    case 0x00:\n      break;\n\n    case 0x20:\n      *((char *) pdest) = *((char *) psource);\n      break;\n\n    case 0x40:\n      *((short *) pdest) = *((short *) psource);\n      break;\n\n    case 0x60:\n      *((int *) pdest) = *((int *) psource);\n      break;\n\n    case 0x80:\n      *((uint64 *) pdest) = *((uint64 *) psource);\n      break;\n\n    case 0xC0:\n\n    case 0xA0:\n\n    case 0xE0:\n      *((char **) pdest) = (char *) psource;\n      break;\n\n    default:\n      return 0;\n\n  }\n\n  return 1;\n}\n\n",
        "translated_code": "use std::ptr;\n\npub fn copy_raw_value(psource: Option<&mut [u8]>, pdest: Option<&mut [u8]>, data_store: i32) -> bool {\n    // Check for None (equivalent to NULL checks in C)\n    if psource.is_none() || pdest.is_none() {\n        return false;\n    }\n\n    let psource = psource.unwrap();\n    let pdest = pdest.unwrap();\n\n    // Ensure both slices have at least some capacity\n    if psource.is_empty() || pdest.is_empty() {\n        return false;\n    }\n\n    match data_store {\n        0x00 => (), // No operation case\n        0x20 => {\n            if psource.len() >= 1 && pdest.len() >= 1 {\n                pdest[0] = psource[0];\n            } else {\n                return false;\n            }\n        }\n        0x40 => {\n            if psource.len() >= 2 && pdest.len() >= 2 {\n                let src = unsafe { ptr::read_unaligned(psource.as_ptr() as *const i16) };\n                unsafe { ptr::write_unaligned(pdest.as_mut_ptr() as *mut i16, src) };\n            } else {\n                return false;\n            }\n        }\n        0x60 => {\n            if psource.len() >= 4 && pdest.len() >= 4 {\n                let src = unsafe { ptr::read_unaligned(psource.as_ptr() as *const i32) };\n                unsafe { ptr::write_unaligned(pdest.as_mut_ptr() as *mut i32, src) };\n            } else {\n                return false;\n            }\n        }\n        0x80 => {\n            if psource.len() >= 8 && pdest.len() >= 8 {\n                let src = unsafe { ptr::read_unaligned(psource.as_ptr() as *const u64) };\n                unsafe { ptr::write_unaligned(pdest.as_mut_ptr() as *mut u64, src) };\n            } else {\n                return false;\n            }\n        }\n        0xA0 | 0xC0 | 0xE0 => {\n            // For pointer cases, we'll treat it as copying the pointer value itself\n            if psource.len() >= std::mem::size_of::<usize>() && pdest.len() >= std::mem::size_of::<usize>() {\n                let src = unsafe { ptr::read_unaligned(psource.as_ptr() as *const usize) };\n                unsafe { ptr::write_unaligned(pdest.as_mut_ptr() as *mut usize, src) };\n            } else {\n                return false;\n            }\n        }\n        _ => return false, // Default case returns false\n    }\n\n    true\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [],
        "params": [
            "void *psource",
            "void *pdest",
            "int data_store"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "psource",
            "pdest",
            "data_store"
        ],
        "calle": [],
        "calle_c": [],
        "key": "copy_raw_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "copy_float_value": {
        "source_code": "static BOOL copy_float_value(void *psource, void *pdest, int source_type, int dest_type)\n{\n  switch (source_type)\n  {\n    case 0x62:\n      *((double *) pdest) = *((float *) psource);\n      break;\n\n    case 0x82:\n      *((float *) pdest) = (float) (*((double *) psource));\n      break;\n\n    default:\n      return 0;\n\n  }\n\n  return 1;\n}\n\n",
        "translated_code": "pub fn copy_float_value(psource: Option<&mut f32>, pdest: Option<&mut f64>, source_type: i32, _dest_type: i32) -> bool {\n    match source_type {\n        0x62 => {\n            if let (Some(src), Some(dst)) = (psource, pdest) {\n                *dst = *src as f64;\n                true\n            } else {\n                false\n            }\n        },\n        0x82 => {\n            if let (Some(src), Some(dst)) = (psource, pdest) {\n                *dst = *src as f64;\n                true\n            } else {\n                false\n            }\n        },\n        _ => false,\n    }\n}\n\npub fn copy_float_value_reverse(psource: Option<&mut f64>, pdest: Option<&mut f32>, source_type: i32, _dest_type: i32) -> bool {\n    match source_type {\n        0x62 => {\n            if let (Some(src), Some(dst)) = (psource, pdest) {\n                *dst = *src as f32;\n                true\n            } else {\n                false\n            }\n        },\n        0x82 => {\n            if let (Some(src), Some(dst)) = (psource, pdest) {\n                *dst = *src as f32;\n                true\n            } else {\n                false\n            }\n        },\n        _ => false,\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [],
        "params": [
            "void *psource",
            "void *pdest",
            "int source_type",
            "int dest_type"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "psource",
            "pdest",
            "source_type",
            "dest_type"
        ],
        "calle": [],
        "calle_c": [],
        "key": "copy_float_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_struct": {
        "source_code": "struct binn_struct\n{\n  int header;\n  BOOL allocated;\n  BOOL writable;\n  BOOL dirty;\n  void *pbuf;\n  BOOL pre_allocated;\n  int alloc_size;\n  int used_size;\n  int type;\n  void *ptr;\n  int size;\n  int count;\n  binn_mem_free freefn;\n  union \n  {\n    signed char vint8;\n    signed short vint16;\n    signed int vint32;\n    int64 vint64;\n    unsigned char vuint8;\n    unsigned short vuint16;\n    unsigned int vuint32;\n    uint64 vuint64;\n    signed char vchar;\n    unsigned char vuchar;\n    signed short vshort;\n    unsigned short vushort;\n    signed int vint;\n    unsigned int vuint;\n    float vfloat;\n    double vdouble;\n    BOOL vbool;\n  };\n  BOOL disable_int_compression;\n}",
        "translated_code": "\npub struct BinnStruct {\n    pub header: i32,\n    pub allocated: BOOL,\n    pub writable: BOOL,\n    pub dirty: BOOL,\n    pub pbuf: Option<Box<()>>,\n    pub pre_allocated: BOOL,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Option<Box<()>>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: BinnMemFree,\n    pub value: BinnValue,\n    pub disable_int_compression: BOOL,\n}\n\n\npub struct BinnValue {\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: BOOL,\n}",
        "hint": "special_types",
        "section": "src",
        "file": "binn_struct.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "binn_mem_free"
        ],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn": {
        "source_code": "typedef struct binn_struct binn",
        "translated_code": "\npub struct BinnStruct {\n    pub header: i32,\n    pub allocated: BOOL,\n    pub writable: BOOL,\n    pub dirty: BOOL,\n    pub pbuf: Option<Box<()>>,\n    pub pre_allocated: BOOL,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Option<Box<()>>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: BinnMemFree,\n    pub value: BinnValue,\n    pub disable_int_compression: BOOL,\n}\n\npub struct BinnValue {\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: BOOL,\n}\n\npub type binn = Option<Box<BinnStruct>>;",
        "hint": "special_types",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_struct"
        ],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "vint64": {
        "source_code": "int64 vint64",
        "translated_code": "pub static mut vint64: int64 = 0;",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [
            "int64"
        ],
        "lifetime_hint": [],
        "type": "int64",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "vuint64": {
        "source_code": "uint64 vuint64",
        "translated_code": "pub type vuint64 = uint64;",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [
            "uint64"
        ],
        "lifetime_hint": [],
        "type": "uint64",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "vbool": {
        "source_code": "BOOL vbool",
        "translated_code": "pub static mut vbool: BOOL = 0;",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [
            "BOOL"
        ],
        "lifetime_hint": [],
        "type": "BOOL",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "local_value": {
        "source_code": "binn local_value",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::Mutex;\nuse std::mem::zeroed;\n\n// Implement Send and Sync for the necessary types\nunsafe impl Send for BinnStruct {}\nunsafe impl Sync for BinnStruct {}\nunsafe impl Send for BinnValue {}\nunsafe impl Sync for BinnValue {}\n\nlazy_static! {\n    pub static ref LOCAL_VALUE: Mutex<Option<Box<BinnStruct>>> = {\n        let empty_binn: BinnStruct = unsafe { zeroed() };\n        Mutex::new(Some(Box::new(empty_binn)))\n    };\n}",
        "hint": "global_variables",
        "section": "src",
        "file": "globals.rs",
        "error": "",
        "dependent": [
            "binn"
        ],
        "lifetime_hint": [],
        "type": "binn",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_get_type_info": {
        "source_code": "BOOL binn_get_type_info(int long_type, int *pstorage_type, int *pextra_type)\n{\n  int storage_type;\n  int extra_type;\n  BOOL retval = 1;\n  again:\n  if (long_type < 0)\n  {\n    goto loc_invalid;\n  }\n  else\n    if (long_type <= 0xff)\n  {\n    storage_type = long_type & 0xE0;\n    extra_type = long_type & 0x0F;\n  }\n  else\n    if (long_type <= 0xffff)\n  {\n    storage_type = long_type & 0xE000;\n    storage_type >>= 8;\n    extra_type = long_type & 0x0FFF;\n    extra_type >>= 4;\n  }\n  else\n    if (long_type & 0x80000)\n  {\n    long_type &= 0xffff;\n    goto again;\n  }\n  else\n  {\n    loc_invalid:\n    storage_type = -1;\n\n    extra_type = -1;\n    retval = 0;\n  }\n\n  if (pstorage_type)\n  {\n    *pstorage_type = storage_type;\n  }\n  if (pextra_type)\n  {\n    *pextra_type = extra_type;\n  }\n  return retval;\n}\n\n",
        "translated_code": "pub fn binn_get_type_info(\n    long_type: i32,\n    pstorage_type: Option<&mut i32>,\n    pextra_type: Option<&mut i32>,\n) -> BOOL {\n    let mut storage_type;\n    let mut extra_type;\n    let mut retval = 1;\n    let mut current_long_type = long_type;\n\n    loop {\n        if current_long_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = 0;\n            break;\n        } else if current_long_type <= 0xff {\n            storage_type = current_long_type & 0xE0;\n            extra_type = current_long_type & 0x0F;\n            break;\n        } else if current_long_type <= 0xffff {\n            storage_type = current_long_type & 0xE000;\n            storage_type >>= 8;\n            extra_type = current_long_type & 0x0FFF;\n            extra_type >>= 4;\n            break;\n        } else if current_long_type & 0x80000 != 0 {\n            current_long_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = 0;\n            break;\n        }\n    }\n\n    if let Some(pstorage_type) = pstorage_type {\n        *pstorage_type = storage_type;\n    }\n    if let Some(pextra_type) = pextra_type {\n        *pextra_type = extra_type;\n    }\n\n    retval\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "BOOL"
        ],
        "header": "BOOL binn_get_type_info(int long_type, int *pstorage_type, int *pextra_type)",
        "params": [
            "int long_type",
            "int *pstorage_type",
            "int *pextra_type"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "long_type",
            "pstorage_type",
            "pextra_type",
            "storage_type",
            "extra_type",
            "retval"
        ],
        "calle": [],
        "calle_c": [],
        "key": "binn_get_type_info",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_get_read_storage": {
        "source_code": "int binn_get_read_storage(int type)\n{\n  int storage_type;\n  switch (type)\n  {\n    case 0x80061:\n\n    case 0x01:\n\n    case 0x02:\n      return 0x60;\n\n    default:\n      binn_get_type_info(type, &storage_type, 0);\n      return storage_type;\n\n  }\n\n}\n\n",
        "translated_code": "pub fn binn_get_read_storage(type_: i32) -> i32 {\n    match type_ {\n        0x80061 | 0x01 | 0x02 => 0x60,\n        _ => {\n            let mut storage_type = 0;\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_get_type_info"
        ],
        "header": "int binn_get_read_storage(int type)",
        "params": [
            "int type"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "type",
            "storage_type"
        ],
        "calle": [
            "binn_get_type_info"
        ],
        "calle_c": [],
        "key": "binn_get_read_storage",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "zero_value": {
        "source_code": "static void zero_value(void *pvalue, int type)\n{\n  switch (binn_get_read_storage(type))\n  {\n    case 0x00:\n      break;\n\n    case 0x20:\n      *((char *) pvalue) = 0;\n      break;\n\n    case 0x40:\n      *((short *) pvalue) = 0;\n      break;\n\n    case 0x60:\n      *((int *) pvalue) = 0;\n      break;\n\n    case 0x80:\n      *((uint64 *) pvalue) = 0;\n      break;\n\n    case 0xC0:\n\n    case 0xA0:\n\n    case 0xE0:\n      *((char **) pvalue) = 0;\n      break;\n\n  }\n\n}\n\n",
        "translated_code": "pub fn zero_value(pvalue: Option<&mut dyn std::any::Any>, type_: i32) {\n    if pvalue.is_none() {\n        return;\n    }\n    let pvalue = pvalue.unwrap();\n\n    match binn_get_read_storage(type_) {\n        0x00 => (),\n        0x20 => {\n            if let Some(val) = pvalue.downcast_mut::<i8>() {\n                *val = 0;\n            }\n        },\n        0x40 => {\n            if let Some(val) = pvalue.downcast_mut::<i16>() {\n                *val = 0;\n            }\n        },\n        0x60 => {\n            if let Some(val) = pvalue.downcast_mut::<i32>() {\n                *val = 0;\n            }\n        },\n        0x80 => {\n            if let Some(val) = pvalue.downcast_mut::<u64>() {\n                *val = 0;\n            }\n        },\n        0xC0 | 0xA0 | 0xE0 => {\n            if let Some(val) = pvalue.downcast_mut::<Option<&mut str>>() {\n                *val = None;\n            }\n        },\n        _ => (),\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_get_read_storage"
        ],
        "params": [
            "void *pvalue",
            "int type"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "pvalue",
            "type"
        ],
        "calle": [
            "binn_get_read_storage"
        ],
        "calle_c": [],
        "key": "zero_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "copy_int_value": {
        "source_code": "static BOOL copy_int_value(void *psource, void *pdest, int source_type, int dest_type)\n{\n  uint64 vuint64 = 0;\n  int64 vint64 = 0;\n  switch (source_type)\n  {\n    case 0x21:\n      vint64 = *((signed char *) psource);\n      break;\n\n    case 0x41:\n      vint64 = *((short *) psource);\n      break;\n\n    case 0x61:\n      vint64 = *((int *) psource);\n      break;\n\n    case 0x81:\n      vint64 = *((int64 *) psource);\n      break;\n\n    case 0x20:\n      vuint64 = *((unsigned char *) psource);\n      break;\n\n    case 0x40:\n      vuint64 = *((unsigned short *) psource);\n      break;\n\n    case 0x60:\n      vuint64 = *((unsigned int *) psource);\n      break;\n\n    case 0x80:\n      vuint64 = *((uint64 *) psource);\n      break;\n\n    default:\n      return 0;\n\n  }\n\n  if ((int_type(source_type) == 22) && (int_type(dest_type) == 11))\n  {\n    if (vuint64 > INT64_MAX)\n    {\n      return 0;\n    }\n    vint64 = vuint64;\n  }\n  else\n    if ((int_type(source_type) == 11) && (int_type(dest_type) == 22))\n  {\n    if (vint64 < 0)\n    {\n      return 0;\n    }\n    vuint64 = vint64;\n  }\n  switch (dest_type)\n  {\n    case 0x21:\n      if ((vint64 < INT8_MIN) || (vint64 > INT8_MAX))\n    {\n      return 0;\n    }\n      *((signed char *) pdest) = (signed char) vint64;\n      break;\n\n    case 0x41:\n      if ((vint64 < INT16_MIN) || (vint64 > INT16_MAX))\n    {\n      return 0;\n    }\n      *((short *) pdest) = (short) vint64;\n      break;\n\n    case 0x61:\n      if ((vint64 < INT32_MIN) || (vint64 > INT32_MAX))\n    {\n      return 0;\n    }\n      *((int *) pdest) = (int) vint64;\n      break;\n\n    case 0x81:\n      *((int64 *) pdest) = vint64;\n      break;\n\n    case 0x20:\n      if (vuint64 > UINT8_MAX)\n    {\n      return 0;\n    }\n      *((unsigned char *) pdest) = (unsigned char) vuint64;\n      break;\n\n    case 0x40:\n      if (vuint64 > UINT16_MAX)\n    {\n      return 0;\n    }\n      *((unsigned short *) pdest) = (unsigned short) vuint64;\n      break;\n\n    case 0x60:\n      if (vuint64 > UINT32_MAX)\n    {\n      return 0;\n    }\n      *((unsigned int *) pdest) = (unsigned int) vuint64;\n      break;\n\n    case 0x80:\n      *((uint64 *) pdest) = vuint64;\n      break;\n\n    default:\n      return 0;\n\n  }\n\n  return 1;\n}\n\n",
        "translated_code": "pub fn copy_int_value(\n    psource: Option<&[u8]>,\n    pdest: Option<&mut [u8]>,\n    source_type: i32,\n    dest_type: i32,\n) -> bool {\n    // Check for null pointers (represented as None in Rust)\n    if psource.is_none() || pdest.is_none() {\n        return false;\n    }\n    let psource = psource.unwrap();\n    let pdest = pdest.unwrap();\n\n    let mut vuint64: uint64 = 0;\n    let mut local_vint64: int64 = 0;  // Renamed from vint64 to avoid shadowing static\n\n    // Read source value based on source_type\n    match source_type {\n        0x21 => {\n            if psource.len() < 1 {\n                return false;\n            }\n            local_vint64 = psource[0] as i8 as int64;\n        }\n        0x41 => {\n            if psource.len() < 2 {\n                return false;\n            }\n            local_vint64 = i16::from_le_bytes([psource[0], psource[1]]) as int64;\n        }\n        0x61 => {\n            if psource.len() < 4 {\n                return false;\n            }\n            local_vint64 = i32::from_le_bytes([psource[0], psource[1], psource[2], psource[3]]) as int64;\n        }\n        0x81 => {\n            if psource.len() < 8 {\n                return false;\n            }\n            local_vint64 = int64::from_le_bytes([\n                psource[0], psource[1], psource[2], psource[3],\n                psource[4], psource[5], psource[6], psource[7],\n            ]);\n        }\n        0x20 => {\n            if psource.len() < 1 {\n                return false;\n            }\n            vuint64 = psource[0] as uint64;\n        }\n        0x40 => {\n            if psource.len() < 2 {\n                return false;\n            }\n            vuint64 = u16::from_le_bytes([psource[0], psource[1]]) as uint64;\n        }\n        0x60 => {\n            if psource.len() < 4 {\n                return false;\n            }\n            vuint64 = u32::from_le_bytes([psource[0], psource[1], psource[2], psource[3]]) as uint64;\n        }\n        0x80 => {\n            if psource.len() < 8 {\n                return false;\n            }\n            vuint64 = uint64::from_le_bytes([\n                psource[0], psource[1], psource[2], psource[3],\n                psource[4], psource[5], psource[6], psource[7],\n            ]);\n        }\n        _ => return false,\n    }\n\n    // Handle signed/unsigned conversion if needed\n    if (int_type(source_type) == 22) && (int_type(dest_type) == 11) {\n        if vuint64 > i64::MAX as uint64 {\n            return false;\n        }\n        local_vint64 = vuint64 as int64;\n    } else if (int_type(source_type) == 11) && (int_type(dest_type) == 22) {\n        if local_vint64 < 0 {\n            return false;\n        }\n        vuint64 = local_vint64 as uint64;\n    }\n\n    // Write to destination based on dest_type\n    match dest_type {\n        0x21 => {\n            if let Ok(value) = i8::try_from(local_vint64) {\n                if pdest.len() < 1 {\n                    return false;\n                }\n                pdest[0] = value as u8;\n            } else {\n                return false;\n            }\n        }\n        0x41 => {\n            if let Ok(value) = i16::try_from(local_vint64) {\n                if pdest.len() < 2 {\n                    return false;\n                }\n                pdest[..2].copy_from_slice(&value.to_le_bytes());\n            } else {\n                return false;\n            }\n        }\n        0x61 => {\n            if let Ok(value) = i32::try_from(local_vint64) {\n                if pdest.len() < 4 {\n                    return false;\n                }\n                pdest[..4].copy_from_slice(&value.to_le_bytes());\n            } else {\n                return false;\n            }\n        }\n        0x81 => {\n            if pdest.len() < 8 {\n                return false;\n            }\n            pdest[..8].copy_from_slice(&local_vint64.to_le_bytes());\n        }\n        0x20 => {\n            if let Ok(value) = u8::try_from(vuint64) {\n                if pdest.len() < 1 {\n                    return false;\n                }\n                pdest[0] = value;\n            } else {\n                return false;\n            }\n        }\n        0x40 => {\n            if let Ok(value) = u16::try_from(vuint64) {\n                if pdest.len() < 2 {\n                    return false;\n                }\n                pdest[..2].copy_from_slice(&value.to_le_bytes());\n            } else {\n                return false;\n            }\n        }\n        0x60 => {\n            if let Ok(value) = u32::try_from(vuint64) {\n                if pdest.len() < 4 {\n                    return false;\n                }\n                pdest[..4].copy_from_slice(&value.to_le_bytes());\n            } else {\n                return false;\n            }\n        }\n        0x80 => {\n            if pdest.len() < 8 {\n                return false;\n            }\n            pdest[..8].copy_from_slice(&vuint64.to_le_bytes());\n        }\n        _ => return false,\n    }\n\n    true\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "int64",
            "int_type",
            "uint64"
        ],
        "params": [
            "void *psource",
            "void *pdest",
            "int source_type",
            "int dest_type"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "psource",
            "pdest",
            "source_type",
            "dest_type",
            "vuint64",
            "vint64"
        ],
        "calle": [
            "int_type"
        ],
        "calle_c": [],
        "key": "copy_int_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "copy_value": {
        "source_code": "static BOOL copy_value(void *psource, void *pdest, int source_type, int dest_type, int data_store)\n{\n  if (type_family(source_type) != type_family(dest_type))\n  {\n    return 0;\n  }\n  if ((type_family(source_type) == 0xf2) && (source_type != dest_type))\n  {\n    return copy_int_value(psource, pdest, source_type, dest_type);\n  }\n  else\n    if ((type_family(source_type) == 0xf3) && (source_type != dest_type))\n  {\n    return copy_float_value(psource, pdest, source_type, dest_type);\n  }\n  else\n  {\n    return copy_raw_value(psource, pdest, data_store);\n  }\n}\n\n",
        "translated_code": "pub fn copy_value(\n    psource: Option<&mut [u8]>,\n    pdest: Option<&mut [u8]>,\n    source_type: i32,\n    dest_type: i32,\n    data_store: i32,\n) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    match type_family(source_type) {\n        0xf2 if source_type != dest_type => {\n            copy_int_value(psource.as_deref(), pdest, source_type, dest_type)\n        }\n        0xf3 if source_type != dest_type => {\n            // Convert psource and pdest to appropriate float types\n            let psource_f32 = psource.and_then(|src| {\n                if src.len() >= std::mem::size_of::<f32>() {\n                    Some(unsafe { &mut *(src.as_mut_ptr() as *mut f32) })\n                } else {\n                    None\n                }\n            });\n            let pdest_f64 = pdest.and_then(|dst| {\n                if dst.len() >= std::mem::size_of::<f64>() {\n                    Some(unsafe { &mut *(dst.as_mut_ptr() as *mut f64) })\n                } else {\n                    None\n                }\n            });\n            copy_float_value(psource_f32, pdest_f64, source_type, dest_type)\n        }\n        _ => copy_raw_value(psource, pdest, data_store),\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "copy_float_value",
            "copy_int_value",
            "copy_raw_value",
            "type_family"
        ],
        "params": [
            "void *psource",
            "void *pdest",
            "int source_type",
            "int dest_type",
            "int data_store"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "psource",
            "pdest",
            "source_type",
            "dest_type",
            "data_store"
        ],
        "calle": [
            "copy_raw_value",
            "type_family",
            "copy_int_value",
            "copy_float_value"
        ],
        "calle_c": [],
        "key": "copy_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "copy_be32": {
        "source_code": "static void copy_be32(u32 *pdest, u32 *psource)\n{\n  unsigned char *source = (unsigned char *) psource;\n  unsigned char *dest = (unsigned char *) pdest;\n  dest[0] = source[3];\n  dest[1] = source[2];\n  dest[2] = source[1];\n  dest[3] = source[0];\n}\n\n",
        "translated_code": "pub fn copy_be32(pdest: &mut u32, psource: &u32) {\n    let source = psource.to_be_bytes();\n    let dest = &mut *pdest;\n    *dest = u32::from_be_bytes([source[3], source[2], source[1], source[0]]);\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "u32"
        ],
        "params": [
            "u32 *pdest",
            "u32 *psource"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "pdest",
            "psource",
            "source",
            "dest"
        ],
        "calle": [],
        "calle_c": [],
        "key": "copy_be32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_save_header": {
        "source_code": "static BOOL binn_save_header(binn *item)\n{\n  unsigned char byte;\n  unsigned char *p;\n  unsigned int p_idx = 0;\n  int int32;\n  int size;\n  if (item == 0)\n  {\n    return 0;\n  }\n  p_idx = ((unsigned char *) item->pbuf) + 9;\n  size = (item->used_size - 9) + 3;\n  if (item->count > 127)\n  {\n    p_idx -= 4;\n    size += 3;\n    int32 = item->count | 0x80000000;\n    copy_be32((u32 *) p, (u32 *) (&int32));\n  }\n  else\n  {\n    p_idx -= 1;\n    p[p_idx] = (unsigned char) item->count;\n  }\n  if (size > 127)\n  {\n    p_idx -= 4;\n    size += 3;\n    int32 = size | 0x80000000;\n    copy_be32((u32 *) p, (u32 *) (&int32));\n  }\n  else\n  {\n    p_idx -= 1;\n    p[p_idx] = (unsigned char) size;\n  }\n  p_idx -= 1;\n  p[p_idx] = (unsigned char) item->type;\n  item->ptr = &p[p_idx];\n  item->size = size;\n  (void) byte;\n  item->dirty = 0;\n  return 1;\n}\n\n",
        "translated_code": "pub fn binn_save_header(item: &mut binn) -> BOOL {\n    // Check for NULL pointer (None in Rust)\n    if item.is_none() {\n        return 0;\n    }\n\n    let item = item.as_mut().unwrap(); // Safe unwrap after None check\n\n    // Calculate initial p_idx and size\n    let mut p_idx = 9;\n    let mut size = (item.used_size - 9) + 3;\n\n    // Get mutable reference to pbuf as bytes\n    let p = item.pbuf.as_mut().unwrap().as_mut() as *mut _ as *mut u8;\n    let p = unsafe { std::slice::from_raw_parts_mut(p, item.used_size as usize) };\n\n    // Handle count\n    if item.count > 127 {\n        p_idx -= 4;\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        copy_be32(\n            unsafe { &mut *(p[p_idx as usize..].as_mut_ptr() as *mut u32) },\n            &int32,\n        );\n    } else {\n        p_idx -= 1;\n        p[p_idx as usize] = item.count as u8;\n    }\n\n    // Handle size\n    if size > 127 {\n        p_idx -= 4;\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        copy_be32(\n            unsafe { &mut *(p[p_idx as usize..].as_mut_ptr() as *mut u32) },\n            &int32,\n        );\n    } else {\n        p_idx -= 1;\n        p[p_idx as usize] = size as u8;\n    }\n\n    // Set type\n    p_idx -= 1;\n    p[p_idx as usize] = item.type_ as u8;\n\n    // Update item fields\n    item.ptr = Some(Box::new(())); // Changed to match the expected Box<()> type\n    item.size = size;\n    item.dirty = 0;\n\n    1\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "copy_be32"
        ],
        "params": [
            "binn *item"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "item",
            "byte",
            "p",
            "p_idx",
            "int32",
            "size"
        ],
        "calle": [
            "copy_be32"
        ],
        "calle_c": [],
        "key": "binn_save_header",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_ptr": {
        "source_code": "void *binn_ptr(void *ptr)\n{\n  binn *item;\n  unsigned int item_idx = 0;\n  switch (binn_get_ptr_type(ptr))\n  {\n    case 1:\n      item_idx = (binn *) ptr;\n      if (item->writable && item->dirty)\n    {\n      binn_save_header(item);\n    }\n      return item->ptr;\n\n    case 2:\n      return ptr;\n\n    default:\n      return 0;\n\n  }\n\n}\n\n",
        "translated_code": "pub fn binn_ptr(ptr: Option<*mut u8>) -> Option<*mut u8> {\n    match binn_get_ptr_type(ptr) {\n        1 => {\n            if let Some(p) = ptr {\n                let mut item_val = Some(Box::new(unsafe { std::ptr::read(p as *const BinnStruct) }));\n                let needs_save = if let Some(ref b) = item_val {\n                    b.writable != 0 && b.dirty != 0\n                } else {\n                    false\n                };\n                if needs_save {\n                    binn_save_header(&mut item_val);\n                }\n                item_val.as_ref().and_then(|b| b.ptr.as_ref().map(|p| p.as_ref() as *const _ as *mut u8))\n            } else {\n                None\n            }\n        },\n        2 => ptr,\n        _ => None,\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_get_ptr_type",
            "binn_save_header"
        ],
        "header": "void *binn_ptr(void *ptr)",
        "params": [
            "void *ptr"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "item",
            "item_idx"
        ],
        "calle": [
            "binn_get_ptr_type",
            "binn_save_header"
        ],
        "calle_c": [],
        "key": "binn_ptr",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "copy_be64": {
        "source_code": "static void copy_be64(u64 *pdest, u64 *psource)\n{\n  unsigned char *source = (unsigned char *) psource;\n  unsigned char *dest = (unsigned char *) pdest;\n  int i;\n  for (i = 0; i < 8; i += 1)\n  {\n    dest[i] = source[7 - i];\n  }\n\n}\n\n",
        "translated_code": "pub fn copy_be64(pdest: &mut u64, psource: &u64) {\n    let source = psource.to_be_bytes(); // Convert to big-endian byte array\n    let dest = unsafe { std::slice::from_raw_parts_mut(pdest as *mut u64 as *mut u8, 8) };\n    \n    // Perform the byte-wise copy with endianness conversion\n    for i in 0..8 {\n        dest[i] = source[7 - i];\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "u64"
        ],
        "params": [
            "u64 *pdest",
            "u64 *psource"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "pdest",
            "psource",
            "source",
            "dest",
            "i"
        ],
        "calle": [],
        "calle_c": [],
        "key": "copy_be64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "copy_be16": {
        "source_code": "static void copy_be16(u16 *pdest, u16 *psource)\n{\n  unsigned char *source = (unsigned char *) psource;\n  unsigned char *dest = (unsigned char *) pdest;\n  dest[0] = source[1];\n  dest[1] = source[0];\n}\n\n",
        "translated_code": "pub fn copy_be16(pdest: &mut u16, psource: &u16) {\n    let source_bytes = psource.to_be_bytes(); // Get big-endian bytes of source\n    \n    // Convert destination to bytes and modify directly\n    let dest_ptr = pdest as *mut u16 as *mut u8;\n    unsafe {\n        *dest_ptr.add(0) = source_bytes[1];\n        *dest_ptr.add(1) = source_bytes[0];\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "u16"
        ],
        "params": [
            "u16 *pdest",
            "u16 *psource"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "pdest",
            "psource",
            "source",
            "dest"
        ],
        "calle": [],
        "calle_c": [],
        "key": "copy_be16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "IsValidBinnHeader": {
        "source_code": "static BOOL IsValidBinnHeader(void *pbuf, int *ptype, int *pcount, int *psize, int *pheadersize)\n{\n  unsigned char byte;\n  unsigned char *p;\n  unsigned int p_idx = 0;\n  unsigned char *plimit = 0;\n  unsigned int plimit_idx = 0;\n  int int32;\n  int type;\n  int size;\n  int count;\n  if (pbuf == 0)\n  {\n    return 0;\n  }\n  p_idx = (unsigned char *) pbuf;\n  if (psize && ((*psize) > 0))\n  {\n    plimit_idx = ((&p[p_idx]) + (*psize)) - 1;\n  }\n  byte = p[p_idx];\n  p_idx += 1;\n  if ((byte & 0xE0) != 0xE0)\n  {\n    return 0;\n  }\n  if (byte & 0x10)\n  {\n    return 0;\n  }\n  type = byte;\n  switch (type)\n  {\n    case 0xE0:\n\n    case 0xE1:\n\n    case 0xE2:\n      break;\n\n    default:\n      return 0;\n\n  }\n\n  if ((&plimit[plimit_idx]) && ((&p[p_idx]) > (&plimit[plimit_idx])))\n  {\n    return 0;\n  }\n  int32 = *((unsigned char *) p);\n  if (int32 & 0x80)\n  {\n    if ((&plimit[plimit_idx]) && ((((&p[p_idx]) + (sizeof(int))) - 1) > (&plimit[plimit_idx])))\n    {\n      return 0;\n    }\n    copy_be32((u32 *) (&int32), (u32 *) p);\n    int32 &= 0x7FFFFFFF;\n    p_idx += 4;\n  }\n  else\n  {\n    p_idx += 1;\n  }\n  size = int32;\n  if ((&plimit[plimit_idx]) && ((&p[p_idx]) > (&plimit[plimit_idx])))\n  {\n    return 0;\n  }\n  int32 = *((unsigned char *) p);\n  if (int32 & 0x80)\n  {\n    if ((&plimit[plimit_idx]) && ((((&p[p_idx]) + (sizeof(int))) - 1) > (&plimit[plimit_idx])))\n    {\n      return 0;\n    }\n    copy_be32((u32 *) (&int32), (u32 *) p);\n    int32 &= 0x7FFFFFFF;\n    p_idx += 4;\n  }\n  else\n  {\n    p_idx += 1;\n  }\n  count = int32;\n  if ((size < 3) || (count < 0))\n  {\n    return 0;\n  }\n  if (ptype)\n  {\n    *ptype = type;\n  }\n  if (pcount)\n  {\n    *pcount = count;\n  }\n  if (psize && ((*psize) == 0))\n  {\n    *psize = size;\n  }\n  if (pheadersize)\n  {\n    *pheadersize = (int) ((&p[p_idx]) - ((unsigned char *) pbuf));\n  }\n  return 1;\n}\n\n",
        "translated_code": "pub fn IsValidBinnHeader(\n    pbuf: Option<&[u8]>,\n    ptype: Option<&mut i32>,\n    pcount: Option<&mut i32>,\n    psize: Option<&mut i32>,\n    pheadersize: Option<&mut i32>,\n) -> bool {\n    // Check for NULL pointer equivalent\n    let pbuf = match pbuf {\n        Some(buf) => buf,\n        None => return false,\n    };\n\n    let mut p_idx: usize = 0;\n    let plimit_idx = psize.as_ref().and_then(|s| if **s > 0 { Some(p_idx + (**s as usize).saturating_sub(1)) } else { None });\n\n    // Check first byte\n    if p_idx >= pbuf.len() {\n        return false;\n    }\n    let byte = pbuf[p_idx];\n    p_idx += 1;\n\n    if (byte & 0xE0) != 0xE0 || (byte & 0x10) != 0 {\n        return false;\n    }\n\n    let type_ = byte;\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    // Check bounds\n    if let Some(limit) = plimit_idx {\n        if p_idx > limit {\n            return false;\n        }\n    }\n\n    // Read size\n    if p_idx >= pbuf.len() {\n        return false;\n    }\n    let mut int32 = pbuf[p_idx] as i32;\n    p_idx += 1;\n\n    if int32 & 0x80 != 0 {\n        if p_idx + 3 >= pbuf.len() {\n            return false;\n        }\n        if let Some(limit) = plimit_idx {\n            if p_idx + 3 > limit {\n                return false;\n            }\n        }\n        let mut temp = [0u8; 4];\n        temp.copy_from_slice(&pbuf[p_idx-1..p_idx+3]);\n        int32 = i32::from_be_bytes(temp) & 0x7FFFFFFF;\n        p_idx += 3;\n    }\n\n    let size = int32;\n\n    // Read count\n    if p_idx >= pbuf.len() {\n        return false;\n    }\n    let mut int32 = pbuf[p_idx] as i32;\n    p_idx += 1;\n\n    if int32 & 0x80 != 0 {\n        if p_idx + 3 >= pbuf.len() {\n            return false;\n        }\n        if let Some(limit) = plimit_idx {\n            if p_idx + 3 > limit {\n                return false;\n            }\n        }\n        let mut temp = [0u8; 4];\n        temp.copy_from_slice(&pbuf[p_idx-1..p_idx+3]);\n        int32 = i32::from_be_bytes(temp) & 0x7FFFFFFF;\n        p_idx += 3;\n    }\n\n    let count = int32;\n\n    // Validate values\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    // Write output parameters\n    if let Some(ptype) = ptype {\n        *ptype = type_ as i32;\n    }\n    if let Some(pcount) = pcount {\n        *pcount = count;\n    }\n    if let Some(psize) = psize {\n        if *psize == 0 {\n            *psize = size;\n        }\n    }\n    if let Some(pheadersize) = pheadersize {\n        *pheadersize = p_idx.try_into().unwrap();\n    }\n\n    true\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "copy_be32"
        ],
        "header": "static BOOL IsValidBinnHeader(void *pbuf, int *ptype, int *pcount, int *psize, int *pheadersize)",
        "params": [
            "void *pbuf",
            "int *ptype",
            "int *pcount",
            "int *psize",
            "int *pheadersize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "pbuf",
            "ptype",
            "pcount",
            "psize",
            "pheadersize",
            "byte",
            "p",
            "p_idx",
            "plimit",
            "plimit_idx",
            "int32",
            "type",
            "size",
            "count"
        ],
        "calle": [
            "copy_be32"
        ],
        "calle_c": [],
        "key": "IsValidBinnHeader",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "GetValue": {
        "source_code": "static BOOL GetValue(unsigned char *p, binn *value)\n{\n  unsigned int p_idx = 0;\n  unsigned char byte;\n  int data_type;\n  int storage_type;\n  int DataSize;\n  void *p2;\n  unsigned int p2_idx = 0;\n  if (value == 0)\n  {\n    return 0;\n  }\n  memset(value, 0, sizeof(binn));\n  value->header = 0x1F22B11F;\n  p2_idx = &p[p_idx];\n  byte = p[p_idx];\n  p_idx += 1;\n  storage_type = byte & 0xE0;\n  if (byte & 0x10)\n  {\n    data_type = byte << 8;\n    byte = p[p_idx];\n    p_idx += 1;\n    data_type |= byte;\n  }\n  else\n  {\n    data_type = byte;\n  }\n  value->type = data_type;\n  switch (storage_type)\n  {\n    case 0x00:\n      break;\n\n    case 0x20:\n      value->vuint8 = *((unsigned char *) p);\n      value->ptr = &p[p_idx];\n      break;\n\n    case 0x40:\n      copy_be16((u16 *) (&value->vint16), (u16 *) p);\n      value->ptr = &value->vint16;\n      break;\n\n    case 0x60:\n      copy_be32((u32 *) (&value->vint32), (u32 *) p);\n      value->ptr = &value->vint32;\n      break;\n\n    case 0x80:\n      copy_be64((u64 *) (&value->vint64), (u64 *) p);\n      value->ptr = &value->vint64;\n      break;\n\n    case 0xC0:\n\n    case 0xA0:\n      DataSize = *((unsigned char *) p);\n      if (DataSize & 0x80)\n    {\n      copy_be32((u32 *) (&DataSize), (u32 *) p);\n      DataSize &= 0x7FFFFFFF;\n      p_idx += 4;\n    }\n    else\n    {\n      p_idx += 1;\n    }\n      value->size = DataSize;\n      value->ptr = &p[p_idx];\n      break;\n\n    case 0xE0:\n      value->ptr = &p2[p2_idx];\n      if (IsValidBinnHeader(p2, 0, &value->count, &value->size, 0) == 0)\n    {\n      return 0;\n    }\n      break;\n\n    default:\n      return 0;\n\n  }\n\n  switch (value->type)\n  {\n    case 0x01:\n      value->type = 0x80061;\n      value->vbool = 1;\n      value->ptr = &value->vbool;\n      break;\n\n    case 0x02:\n      value->type = 0x80061;\n      value->vbool = 0;\n      value->ptr = &value->vbool;\n      break;\n\n  }\n\n  return 1;\n}\n\n",
        "translated_code": "pub fn GetValue(p: Option<&[u8]>, value: Option<&mut binn>) -> BOOL {\n    let Some(p) = p else {\n        return 0;\n    };\n    let Some(value) = value else {\n        return 0;\n    };\n\n    let mut p_idx = 0;\n    let mut p2_idx = 0;\n    let mut data_type;\n    let mut storage_type;\n    let mut DataSize: u32 = 0;\n    let mut p2: *mut u8 = ptr::null_mut();\n\n    // Initialize value (equivalent to memset)\n    *value = Some(Box::new(BinnStruct {\n        header: 0x1F22B11F,\n        allocated: 0,\n        writable: 0,\n        dirty: 0,\n        pbuf: None,\n        pre_allocated: 0,\n        alloc_size: 0,\n        used_size: 0,\n        type_: 0,\n        ptr: None,\n        size: 0,\n        count: 0,\n        freefn: None,\n        value: BinnValue {\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: 0,\n        },\n        disable_int_compression: 0,\n    }));\n\n    let value = value.as_mut().unwrap();\n\n    if p_idx >= p.len() {\n        return 0;\n    }\n    let byte = p[p_idx];\n    p_idx += 1;\n\n    storage_type = byte & 0xE0;\n    if byte & 0x10 != 0 {\n        data_type = (byte as i32) << 8;\n        if p_idx >= p.len() {\n            return 0;\n        }\n        let byte = p[p_idx];\n        p_idx += 1;\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n    value.type_ = data_type;\n\n    match storage_type {\n        0x00 => (),\n        0x20 => {\n            if p_idx >= p.len() {\n                return 0;\n            }\n            value.value.vuint8 = p[p_idx];\n            value.ptr = Some(Box::new(()));\n        }\n        0x40 => {\n            if p_idx + 1 >= p.len() {\n                return 0;\n            }\n            let src = unsafe { &*(p[p_idx..].as_ptr() as *const u16) };\n            copy_be16(&mut value.value.vuint16, src);\n            value.ptr = Some(Box::new(()));\n        }\n        0x60 => {\n            if p_idx + 3 >= p.len() {\n                return 0;\n            }\n            let src = unsafe { &*(p[p_idx..].as_ptr() as *const u32) };\n            copy_be32(&mut value.value.vuint32, src);\n            value.ptr = Some(Box::new(()));\n        }\n        0x80 => {\n            if p_idx + 7 >= p.len() {\n                return 0;\n            }\n            let src = unsafe { &*(p[p_idx..].as_ptr() as *const u64) };\n            copy_be64(&mut value.value.vuint64, src);\n            value.ptr = Some(Box::new(()));\n        }\n        0xA0 | 0xC0 => {\n            if p_idx >= p.len() {\n                return 0;\n            }\n            DataSize = p[p_idx] as u32;\n            if DataSize & 0x80 != 0 {\n                if p_idx + 3 >= p.len() {\n                    return 0;\n                }\n                let src = unsafe { &*(p[p_idx..].as_ptr() as *const u32) };\n                let mut temp = src & 0x7FFFFFFF;\n                copy_be32(&mut DataSize, &temp);\n                p_idx += 4;\n            } else {\n                p_idx += 1;\n            }\n            value.size = DataSize as i32;\n            value.ptr = Some(Box::new(()));\n        }\n        0xE0 => {\n            value.ptr = Some(Box::new(()));\n            if !IsValidBinnHeader(\n                Some(unsafe { std::slice::from_raw_parts(p2.add(p2_idx), 0) }),\n                None,\n                Some(&mut value.count),\n                Some(&mut value.size),\n                None,\n            ) {\n                return 0;\n            }\n        }\n        _ => return 0,\n    }\n\n    match value.type_ {\n        0x01 => {\n            value.type_ = 0x80061;\n            value.value.vbool = 1;\n            value.ptr = Some(Box::new(()));\n        }\n        0x02 => {\n            value.type_ = 0x80061;\n            value.value.vbool = 0;\n            value.ptr = Some(Box::new(()));\n        }\n        _ => (),\n    }\n\n    1\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "IsValidBinnHeader",
            "binn",
            "copy_be16",
            "copy_be32",
            "copy_be64"
        ],
        "params": [
            "unsigned char *p",
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "p",
            "value",
            "p_idx",
            "byte",
            "data_type",
            "storage_type",
            "DataSize",
            "p2",
            "p2_idx"
        ],
        "calle": [
            "copy_be64",
            "memset",
            "copy_be16",
            "copy_be32",
            "IsValidBinnHeader"
        ],
        "calle_c": [
            "memset"
        ],
        "key": "GetValue",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "AdvanceDataPos": {
        "source_code": "static unsigned char *AdvanceDataPos(unsigned char *p, unsigned char *plimit)\n{\n  unsigned int p_idx = 0;\n  unsigned char byte;\n  int storage_type;\n  int DataSize;\n  if ((&p[p_idx]) > plimit)\n  {\n    return 0;\n  }\n  byte = p[p_idx];\n  p_idx += 1;\n  storage_type = byte & 0xE0;\n  if (byte & 0x10)\n  {\n    p_idx += 1;\n  }\n  switch (storage_type)\n  {\n    case 0x00:\n      break;\n\n    case 0x20:\n      p_idx += 1;\n      break;\n\n    case 0x40:\n      p_idx += 2;\n      break;\n\n    case 0x60:\n      p_idx += 4;\n      break;\n\n    case 0x80:\n      p_idx += 8;\n      break;\n\n    case 0xC0:\n\n    case 0xA0:\n      if ((&p[p_idx]) > plimit)\n    {\n      return 0;\n    }\n      DataSize = *((unsigned char *) p);\n      if (DataSize & 0x80)\n    {\n      if ((((&p[p_idx]) + (sizeof(int))) - 1) > plimit)\n      {\n        return 0;\n      }\n      copy_be32((u32 *) (&DataSize), (u32 *) p);\n      DataSize &= 0x7FFFFFFF;\n      p_idx += 4;\n    }\n    else\n    {\n      p_idx += 1;\n    }\n      p_idx += DataSize;\n      if (storage_type == 0xA0)\n    {\n      p_idx += 1;\n    }\n      break;\n\n    case 0xE0:\n      if ((&p[p_idx]) > plimit)\n    {\n      return 0;\n    }\n      DataSize = *((unsigned char *) p);\n      if (DataSize & 0x80)\n    {\n      if ((((&p[p_idx]) + (sizeof(int))) - 1) > plimit)\n      {\n        return 0;\n      }\n      copy_be32((u32 *) (&DataSize), (u32 *) p);\n      DataSize &= 0x7FFFFFFF;\n    }\n      DataSize -= 1;\n      p_idx += DataSize;\n      break;\n\n    default:\n      return 0;\n\n  }\n\n  if ((&p[p_idx]) > plimit)\n  {\n    return 0;\n  }\n  return p;\n}\n\n",
        "translated_code": "pub fn AdvanceDataPos(p: &[u8], plimit: usize) -> Option<&[u8]> {\n    let mut p_idx = 0;\n    \n    // Check initial bounds\n    if p_idx >= p.len() || p_idx > plimit {\n        return None;\n    }\n\n    let byte = p[p_idx];\n    p_idx += 1;\n    let storage_type = byte & 0xE0;\n\n    if byte & 0x10 != 0 {\n        p_idx += 1;\n    }\n\n    match storage_type {\n        0x00 => (), // No additional processing needed\n        0x20 => p_idx += 1,\n        0x40 => p_idx += 2,\n        0x60 => p_idx += 4,\n        0x80 => p_idx += 8,\n        0xA0 | 0xC0 => {\n            if p_idx >= p.len() || p_idx > plimit {\n                return None;\n            }\n\n            let mut DataSize = p[p_idx] as i32;\n            if DataSize & 0x80 != 0 {\n                if p_idx + 4 > p.len() || p_idx + 4 - 1 > plimit {\n                    return None;\n                }\n                let mut temp = 0u32;\n                copy_be32(&mut temp, &u32::from_be_bytes([\n                    p[p_idx], p[p_idx + 1], p[p_idx + 2], p[p_idx + 3]\n                ]));\n                DataSize = (temp & 0x7FFFFFFF) as i32;\n                p_idx += 4;\n            } else {\n                p_idx += 1;\n            }\n\n            p_idx += DataSize as usize;\n            if storage_type == 0xA0 {\n                p_idx += 1;\n            }\n        }\n        0xE0 => {\n            if p_idx >= p.len() || p_idx > plimit {\n                return None;\n            }\n\n            let mut DataSize = p[p_idx] as i32;\n            if DataSize & 0x80 != 0 {\n                if p_idx + 4 > p.len() || p_idx + 4 - 1 > plimit {\n                    return None;\n                }\n                let mut temp = 0u32;\n                copy_be32(&mut temp, &u32::from_be_bytes([\n                    p[p_idx], p[p_idx + 1], p[p_idx + 2], p[p_idx + 3]\n                ]));\n                DataSize = (temp & 0x7FFFFFFF) as i32;\n                p_idx += 4;\n            }\n            DataSize -= 1;\n            p_idx += DataSize as usize;\n        }\n        _ => return None,\n    }\n\n    // Final bounds check\n    if p_idx > p.len() || p_idx > plimit {\n        None\n    } else {\n        Some(&p[p_idx..])\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "copy_be32"
        ],
        "params": [
            "unsigned char *p",
            "unsigned char *plimit"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "p",
            "plimit",
            "p_idx",
            "byte",
            "storage_type",
            "DataSize"
        ],
        "calle": [
            "copy_be32"
        ],
        "calle_c": [],
        "key": "AdvanceDataPos",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_list_get_value": {
        "source_code": "BOOL binn_list_get_value(void *ptr, int pos, binn *value)\n{\n  unsigned int ptr_idx = 0;\n  int i;\n  int type;\n  int count;\n  int size = 0;\n  int header_size;\n  unsigned char *p;\n  unsigned int p_idx = 0;\n  unsigned char *plimit;\n  unsigned int plimit_idx = 0;\n  unsigned char *base;\n  unsigned int base_idx = 0;\n  ptr_idx = binn_ptr(ptr_idx);\n  if (((&ptr[ptr_idx]) == 0) || (value == 0))\n  {\n    return 0;\n  }\n  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == 0)\n  {\n    return 0;\n  }\n  if (type != 0xE0)\n  {\n    return 0;\n  }\n  if (count == 0)\n  {\n    return 0;\n  }\n  if ((pos <= 0) | (pos > count))\n  {\n    return 0;\n  }\n  pos -= 1;\n  p_idx = (unsigned char *) ptr;\n  base_idx = &p[p_idx];\n  plimit_idx = (&p[p_idx]) + size;\n  p_idx += header_size;\n  for (i = 0; i < pos; i += 1)\n  {\n    p_idx = AdvanceDataPos(p_idx, plimit);\n    if (((&p[p_idx]) == 0) || ((&p[p_idx]) < (&base[base_idx])))\n    {\n      return 0;\n    }\n  }\n\n  return GetValue(p, value);\n}\n\n",
        "translated_code": "pub fn binn_list_get_value(ptr: Option<&[u8]>, pos: i32, value: Option<&mut binn>) -> BOOL {\n    let ptr_idx = 0;\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    // Check for null pointers (converted to Option checks in Rust)\n    if ptr.is_none() || value.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    let value = value.unwrap();\n\n    // Validate the Binn header\n    if !IsValidBinnHeader(\n        Some(ptr),\n        Some(&mut type_),\n        Some(&mut count),\n        Some(&mut size),\n        Some(&mut header_size),\n    ) {\n        return 0;\n    }\n\n    // Check type is list (0xE0)\n    if type_ != 0xE0 {\n        return 0;\n    }\n\n    // Check if list is empty\n    if count == 0 {\n        return 0;\n    }\n\n    // Check position is valid\n    if pos <= 0 || pos > count {\n        return 0;\n    }\n\n    let pos = pos - 1; // Convert to 0-based index\n    let p = ptr;\n    let base = p.as_ptr();\n    let plimit = unsafe { base.add(size as usize) };\n\n    let mut p_slice = &p[header_size as usize..];\n    \n    for _ in 0..pos {\n        if let Some(new_p) = AdvanceDataPos(p_slice, plimit as usize) {\n            p_slice = new_p;\n        } else {\n            return 0;\n        }\n\n        // Check if we've gone past the beginning or reached null\n        if p_slice.is_empty() || p_slice.as_ptr() < base {\n            return 0;\n        }\n    }\n\n    GetValue(Some(p_slice), Some(value))\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "AdvanceDataPos",
            "GetValue",
            "IsValidBinnHeader",
            "binn",
            "binn_ptr"
        ],
        "header": "BOOL binn_list_get_value(void *list, int pos, binn *value)",
        "params": [
            "void *ptr",
            "int pos",
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "pos",
            "value",
            "ptr_idx",
            "i",
            "type",
            "count",
            "size",
            "header_size",
            "p",
            "p_idx",
            "plimit",
            "plimit_idx",
            "base",
            "base_idx"
        ],
        "calle": [
            "IsValidBinnHeader",
            "GetValue",
            "binn_ptr",
            "AdvanceDataPos"
        ],
        "calle_c": [],
        "key": "binn_list_get_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_list_get": {
        "source_code": "BOOL binn_list_get(void *ptr, int pos, int type, void *pvalue, int *psize)\n{\n  binn value;\n  int storage_type;\n  storage_type = binn_get_read_storage(type);\n  if ((storage_type != 0x00) && (pvalue == 0))\n  {\n    return 0;\n  }\n  zero_value(pvalue, type);\n  if (binn_list_get_value(ptr, pos, &value) == 0)\n  {\n    return 0;\n  }\n  if (copy_value(value.ptr, pvalue, value.type, type, storage_type) == 0)\n  {\n    return 0;\n  }\n  if (psize)\n  {\n    *psize = value.size;\n  }\n  return 1;\n}\n\n",
        "translated_code": "pub fn binn_list_get(\n    ptr: Option<&[u8]>,\n    pos: i32,\n    type_: i32,\n    mut pvalue: Option<&mut dyn std::any::Any>,\n    psize: Option<&mut i32>,\n) -> BOOL {\n    let storage_type = binn_get_read_storage(type_);\n    \n    // Check if storage_type is valid and pvalue is None when storage_type != 0x00\n    if storage_type != 0x00 && pvalue.is_none() {\n        return 0;\n    }\n\n    // Zero out the value if pvalue exists\n    if let Some(pval) = &mut pvalue {\n        zero_value(Some(*pval), type_);\n    }\n\n    let mut value = None;\n    if binn_list_get_value(ptr, pos, Some(&mut value)) == 0 {\n        return 0;\n    }\n\n    // Unwrap the value safely\n    let value = match value {\n        Some(v) => v,\n        None => return 0,\n    };\n\n    // Copy the value if pvalue exists\n    if let Some(pval) = &mut pvalue {\n        let pval_u8 = pval.downcast_mut::<Vec<u8>>().unwrap();\n        if !copy_value(\n            value.ptr.map(|p| unsafe { std::slice::from_raw_parts_mut(p.as_ref() as *const _ as *mut u8, value.size as usize) }),\n            Some(pval_u8.as_mut_slice()),\n            value.type_,\n            type_,\n            storage_type,\n        ) {\n            return 0;\n        }\n    }\n\n    // Set size if psize exists\n    if let Some(size_ptr) = psize {\n        *size_ptr = value.size;\n    }\n\n    1\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_get_read_storage",
            "binn_list_get_value",
            "copy_value",
            "zero_value"
        ],
        "header": "BOOL binn_list_get(void *list, int pos, int type, void *pvalue, int *psize)",
        "params": [
            "void *ptr",
            "int pos",
            "int type",
            "void *pvalue",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "pos",
            "type",
            "pvalue",
            "psize",
            "value",
            "storage_type"
        ],
        "calle": [
            "binn_list_get_value",
            "copy_value",
            "binn_get_read_storage",
            "zero_value"
        ],
        "calle_c": [],
        "key": "binn_list_get",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_get_int8": {
        "source_code": "inline static BOOL binn_list_get_int8(void *list, int pos, signed char *pvalue)\n{\n  return binn_list_get(list, pos, 0x21, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_get_int8(\n    list: Option<&[u8]>,\n    pos: i32,\n    pvalue: Option<&mut i8>,\n) -> BOOL {\n    binn_list_get(list, pos, 0x21, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "params": [
            "void *list",
            "int pos",
            "signed char *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "pvalue"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_get_int8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_get_int16": {
        "source_code": "inline static BOOL binn_list_get_int16(void *list, int pos, short *pvalue)\n{\n  return binn_list_get(list, pos, 0x41, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_get_int16(\n    list: Option<&[u8]>,\n    pos: i32,\n    pvalue: Option<&mut i16>,\n) -> BOOL {\n    binn_list_get(list, pos, 0x41, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "params": [
            "void *list",
            "int pos",
            "short *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "pvalue"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_get_int16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_get_int32": {
        "source_code": "inline static BOOL binn_list_get_int32(void *list, int pos, int *pvalue)\n{\n  return binn_list_get(list, pos, 0x61, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_get_int32(list: Option<&[u8]>, pos: i32, pvalue: Option<&mut i32>) -> BOOL {\n    binn_list_get(list, pos, 0x61, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "params": [
            "void *list",
            "int pos",
            "int *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "pvalue"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_get_int32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_get_uint8": {
        "source_code": "inline static BOOL binn_list_get_uint8(void *list, int pos, unsigned char *pvalue)\n{\n  return binn_list_get(list, pos, 0x20, pvalue, 0);\n}\n\n",
        "translated_code": "use std::any::Any;\n\npub fn binn_list_get_uint8(\n    list: Option<&[u8]>,\n    pos: i32,\n    pvalue: Option<&mut u8>,\n) -> BOOL {\n    binn_list_get(list, pos, 0x20, pvalue.map(|v| v as &mut dyn Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "params": [
            "void *list",
            "int pos",
            "unsigned char *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "pvalue"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_get_uint8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_get_uint16": {
        "source_code": "inline static BOOL binn_list_get_uint16(void *list, int pos, unsigned short *pvalue)\n{\n  return binn_list_get(list, pos, 0x40, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_get_uint16(\n    list: Option<&[u8]>,\n    pos: i32,\n    pvalue: Option<&mut u16>,\n) -> BOOL {\n    binn_list_get(list, pos, 0x40, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "params": [
            "void *list",
            "int pos",
            "unsigned short *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "pvalue"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_get_uint16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_get_uint32": {
        "source_code": "inline static BOOL binn_list_get_uint32(void *list, int pos, unsigned int *pvalue)\n{\n  return binn_list_get(list, pos, 0x60, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_get_uint32(list: Option<&[u8]>, pos: i32, pvalue: Option<&mut u32>) -> BOOL {\n    binn_list_get(list, pos, 0x60, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "params": [
            "void *list",
            "int pos",
            "unsigned int *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "pvalue"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_get_uint32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_get_float": {
        "source_code": "inline static BOOL binn_list_get_float(void *list, int pos, float *pvalue)\n{\n  return binn_list_get(list, pos, 0x62, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_get_float(list: Option<&[u8]>, pos: i32, pvalue: Option<&mut f32>) -> BOOL {\n    binn_list_get(list, pos, 0x62, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "params": [
            "void *list",
            "int pos",
            "float *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "pvalue"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_get_float",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_get_double": {
        "source_code": "inline static BOOL binn_list_get_double(void *list, int pos, double *pvalue)\n{\n  return binn_list_get(list, pos, 0x82, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_get_double(list: Option<&[u8]>, pos: i32, pvalue: Option<&mut f64>) -> BOOL {\n    binn_list_get(list, pos, 0x82, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "params": [
            "void *list",
            "int pos",
            "double *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "pvalue"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_get_double",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_get_str": {
        "source_code": "inline static BOOL binn_list_get_str(void *list, int pos, char **pvalue)\n{\n  return binn_list_get(list, pos, 0xA0, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_get_str(\n    list: Option<&[u8]>,\n    pos: i32,\n    pvalue: Option<&mut dyn std::any::Any>,\n) -> BOOL {\n    binn_list_get(list, pos, 0xA0, pvalue, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "params": [
            "void *list",
            "int pos",
            "char **pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "pvalue"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_get_str",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_get_blob": {
        "source_code": "inline static BOOL binn_list_get_blob(void *list, int pos, void **pvalue, int *psize)\n{\n  return binn_list_get(list, pos, 0xC0, pvalue, psize);\n}\n\n",
        "translated_code": "pub fn binn_list_get_blob(\n    list: Option<&[u8]>,\n    pos: i32,\n    pvalue: Option<&mut dyn std::any::Any>,\n    psize: Option<&mut i32>,\n) -> BOOL {\n    binn_list_get(list, pos, 0xC0, pvalue, psize)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "params": [
            "void *list",
            "int pos",
            "void **pvalue",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "pvalue",
            "psize"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_get_blob",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_get_list": {
        "source_code": "inline static BOOL binn_list_get_list(void *list, int pos, void **pvalue)\n{\n  return binn_list_get(list, pos, 0xE0, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_get_list(\n    list: Option<&[u8]>,\n    pos: i32,\n    pvalue: Option<&mut dyn std::any::Any>,\n) -> BOOL {\n    binn_list_get(list, pos, 0xE0, pvalue, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "params": [
            "void *list",
            "int pos",
            "void **pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "pvalue"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_get_list",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_get_map": {
        "source_code": "inline static BOOL binn_list_get_map(void *list, int pos, void **pvalue)\n{\n  return binn_list_get(list, pos, 0xE1, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_get_map(\n    list: Option<&[u8]>, \n    pos: i32, \n    pvalue: Option<&mut dyn std::any::Any>\n) -> BOOL {\n    binn_list_get(list, pos, 0xE1, pvalue, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "params": [
            "void *list",
            "int pos",
            "void **pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "pvalue"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_get_map",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_get_object": {
        "source_code": "inline static BOOL binn_list_get_object(void *list, int pos, void **pvalue)\n{\n  return binn_list_get(list, pos, 0xE2, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_get_object(\n    list: Option<&[u8]>,\n    pos: i32,\n    pvalue: Option<&mut dyn std::any::Any>,\n) -> BOOL {\n    binn_list_get(list, pos, 0xE2, pvalue, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "params": [
            "void *list",
            "int pos",
            "void **pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "pvalue"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_get_object",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "read_map_id": {
        "source_code": "static int read_map_id(unsigned char **pp, unsigned char *plimit)\n{\n  unsigned char *p;\n  unsigned int p_idx = 0;\n  unsigned char c;\n  unsigned char sign;\n  unsigned char type;\n  int id;\n  int extra_bytes;\n  p_idx = *pp;\n  c = p[p_idx];\n  p_idx += 1;\n  if (c & 0x80)\n  {\n    extra_bytes = ((c & 0x60) >> 5) + 1;\n    if (((&p[p_idx]) + extra_bytes) > plimit)\n    {\n      *pp = (&p[p_idx]) + extra_bytes;\n      return 0;\n    }\n  }\n  type = c & 0xE0;\n  sign = c & 0x10;\n  if ((c & 0x80) == 0)\n  {\n    sign = c & 0x40;\n    id = c & 0x3F;\n  }\n  else\n    if (type == 0x80)\n  {\n    id = c & 0x0F;\n    id = (id << 8) | p[p_idx];\n    p_idx += 1;\n  }\n  else\n    if (type == 0xA0)\n  {\n    id = c & 0x0F;\n    id = (id << 8) | p[p_idx];\n    p_idx += 1;\n    id = (id << 8) | p[p_idx];\n    p_idx += 1;\n  }\n  else\n    if (type == 0xC0)\n  {\n    id = c & 0x0F;\n    id = (id << 8) | p[p_idx];\n    p_idx += 1;\n    id = (id << 8) | p[p_idx];\n    p_idx += 1;\n    id = (id << 8) | p[p_idx];\n    p_idx += 1;\n  }\n  else\n    if (type == 0xE0)\n  {\n    copy_be32((u32 *) (&id), (u32 *) p);\n    p_idx += 4;\n  }\n  else\n  {\n    *pp = plimit + 2;\n    return 0;\n  }\n  if (sign)\n  {\n    id = -id;\n  }\n  *pp = &p[p_idx];\n  return id;\n}\n\n",
        "translated_code": "pub fn read_map_id(pp: &mut &[u8], plimit: &[u8]) -> Option<i32> {\n    let mut p_idx = 0;\n    let mut c;\n    let mut sign;\n    let mut type_;\n    let mut id = 0;\n    let mut extra_bytes;\n\n    // Get current position from pp\n    let p = *pp;\n    if p.is_empty() {\n        return None;\n    }\n    c = p[p_idx];\n    p_idx += 1;\n\n    if c & 0x80 != 0 {\n        extra_bytes = ((c & 0x60) >> 5) + 1;\n        if p_idx + extra_bytes as usize > p.len() {\n            *pp = &p[p.len()..]; // Move pp beyond limit\n            return None;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        if p_idx + 1 > p.len() {\n            *pp = &p[p.len()..];\n            return None;\n        }\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p[p_idx] as i32);\n        p_idx += 1;\n    } else if type_ == 0xA0 {\n        if p_idx + 2 > p.len() {\n            *pp = &p[p.len()..];\n            return None;\n        }\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p[p_idx] as i32);\n        p_idx += 1;\n        id = (id << 8) | (p[p_idx] as i32);\n        p_idx += 1;\n    } else if type_ == 0xC0 {\n        if p_idx + 3 > p.len() {\n            *pp = &p[p.len()..];\n            return None;\n        }\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p[p_idx] as i32);\n        p_idx += 1;\n        id = (id << 8) | (p[p_idx] as i32);\n        p_idx += 1;\n        id = (id << 8) | (p[p_idx] as i32);\n        p_idx += 1;\n    } else if type_ == 0xE0 {\n        if p_idx + 4 > p.len() {\n            *pp = &p[p.len()..];\n            return None;\n        }\n        let mut source = 0u32;\n        copy_be32(&mut source, &u32::from_be_bytes(p[p_idx..p_idx+4].try_into().unwrap()));\n        id = source as i32;\n        p_idx += 4;\n    } else {\n        *pp = &p[p.len()..];\n        return None;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = &p[p_idx..];\n    Some(id)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "copy_be32"
        ],
        "params": [
            "unsigned char **pp",
            "unsigned char *plimit"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "pp",
            "plimit",
            "p",
            "p_idx",
            "c",
            "sign",
            "type",
            "id",
            "extra_bytes"
        ],
        "calle": [
            "copy_be32"
        ],
        "calle_c": [],
        "key": "read_map_id",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "SearchForID": {
        "source_code": "static unsigned char *SearchForID(unsigned char *p, int header_size, int size, int numitems, int id)\n{\n  unsigned int p_idx = 0;\n  unsigned char *plimit;\n  unsigned int plimit_idx = 0;\n  unsigned char *base;\n  unsigned int base_idx = 0;\n  int i;\n  int int32;\n  base_idx = &p[p_idx];\n  plimit_idx = ((&p[p_idx]) + size) - 1;\n  p_idx += header_size;\n  for (i = 0; i < numitems; i += 1)\n  {\n    int32 = read_map_id(&(&p[p_idx]), plimit);\n    if ((&p[p_idx]) > (&plimit[plimit_idx]))\n    {\n      break;\n    }\n    if (int32 == id)\n    {\n      return p;\n    }\n    p_idx = AdvanceDataPos(p_idx, plimit);\n    if (((&p[p_idx]) == 0) || ((&p[p_idx]) < (&base[base_idx])))\n    {\n      break;\n    }\n  }\n\n  return 0;\n}\n\n",
        "translated_code": "pub fn SearchForID(p: &[u8], header_size: usize, size: usize, numitems: usize, id: i32) -> Option<&[u8]> {\n    let mut p_idx = 0;\n    let base = &p[p_idx..];\n    let plimit = &p[(p_idx + size - 1)..];\n    p_idx += header_size;\n\n    for _ in 0..numitems {\n        let mut current_slice = &p[p_idx..];\n        let int32 = match read_map_id(&mut current_slice, plimit) {\n            Some(val) => val,\n            None => break,\n        };\n\n        if current_slice.as_ptr() > plimit.as_ptr() {\n            break;\n        }\n\n        if int32 == id {\n            return Some(p);\n        }\n\n        match AdvanceDataPos(&p[p_idx..], plimit.as_ptr() as usize) {\n            Some(new_slice) => {\n                p_idx = new_slice.as_ptr() as usize - p.as_ptr() as usize;\n            }\n            None => break,\n        }\n\n        if p_idx == 0 || p[p_idx..].as_ptr() < base.as_ptr() {\n            break;\n        }\n    }\n\n    None\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "AdvanceDataPos",
            "read_map_id"
        ],
        "params": [
            "unsigned char *p",
            "int header_size",
            "int size",
            "int numitems",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "p",
            "header_size",
            "size",
            "numitems",
            "id",
            "p_idx",
            "plimit",
            "plimit_idx",
            "base",
            "base_idx",
            "i",
            "int32"
        ],
        "calle": [
            "read_map_id",
            "AdvanceDataPos"
        ],
        "calle_c": [],
        "key": "SearchForID",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_map_get_value": {
        "source_code": "BOOL binn_map_get_value(void *ptr, int id, binn *value)\n{\n  unsigned int ptr_idx = 0;\n  int type;\n  int count;\n  int size = 0;\n  int header_size;\n  unsigned char *p;\n  unsigned int p_idx = 0;\n  ptr_idx = binn_ptr(ptr_idx);\n  if (((&ptr[ptr_idx]) == 0) || (value == 0))\n  {\n    return 0;\n  }\n  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == 0)\n  {\n    return 0;\n  }\n  if (type != 0xE1)\n  {\n    return 0;\n  }\n  if (count == 0)\n  {\n    return 0;\n  }\n  p_idx = (unsigned char *) ptr;\n  p_idx = SearchForID(p_idx, header_size, size, count, id);\n  if ((&p[p_idx]) == 0)\n  {\n    return 0;\n  }\n  return GetValue(p, value);\n}\n\n",
        "translated_code": "pub fn binn_map_get_value(ptr: Option<&[u8]>, id: i32, value: Option<&mut binn>) -> BOOL {\n    let ptr_idx = 0;\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    let p_idx = 0;\n\n    // Check for null pointers (translated to Option checks in Rust)\n    if ptr.is_none() || value.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    let value = value.unwrap();\n\n    // Validate Binn header\n    if !IsValidBinnHeader(\n        Some(ptr),\n        Some(&mut type_),\n        Some(&mut count),\n        Some(&mut size),\n        Some(&mut header_size),\n    ) {\n        return 0;\n    }\n\n    // Check type is MAP (0xE1)\n    if type_ != 0xE1 {\n        return 0;\n    }\n\n    // Check count is not zero\n    if count == 0 {\n        return 0;\n    }\n\n    // Search for the ID in the map\n    let p_slice = match SearchForID(ptr, header_size as usize, size as usize, count as usize, id) {\n        Some(slice) => slice,\n        None => return 0,\n    };\n\n    // Get the value\n    GetValue(Some(p_slice), Some(value))\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "GetValue",
            "IsValidBinnHeader",
            "SearchForID",
            "binn",
            "binn_ptr"
        ],
        "header": "BOOL binn_map_get_value(void *map, int id, binn *value)",
        "params": [
            "void *ptr",
            "int id",
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "id",
            "value",
            "ptr_idx",
            "type",
            "count",
            "size",
            "header_size",
            "p",
            "p_idx"
        ],
        "calle": [
            "IsValidBinnHeader",
            "GetValue",
            "binn_ptr",
            "SearchForID"
        ],
        "calle_c": [],
        "key": "binn_map_get_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_map_get": {
        "source_code": "BOOL binn_map_get(void *ptr, int id, int type, void *pvalue, int *psize)\n{\n  binn value;\n  int storage_type;\n  storage_type = binn_get_read_storage(type);\n  if ((storage_type != 0x00) && (pvalue == 0))\n  {\n    return 0;\n  }\n  zero_value(pvalue, type);\n  if (binn_map_get_value(ptr, id, &value) == 0)\n  {\n    return 0;\n  }\n  if (copy_value(value.ptr, pvalue, value.type, type, storage_type) == 0)\n  {\n    return 0;\n  }\n  if (psize)\n  {\n    *psize = value.size;\n  }\n  return 1;\n}\n\n",
        "translated_code": "pub fn binn_map_get(\n    ptr: Option<&[u8]>,\n    id: i32,\n    type_: i32,\n    mut pvalue: Option<&mut dyn std::any::Any>,\n    psize: Option<&mut i32>,\n) -> BOOL {\n    let storage_type = binn_get_read_storage(type_);\n    \n    // Check if storage_type is valid and pvalue is None when storage_type != 0x00\n    if storage_type != 0x00 && pvalue.is_none() {\n        return 0;\n    }\n\n    // Zero out the value if pvalue exists\n    if let Some(ref mut pval) = pvalue {\n        zero_value(Some(*pval), type_);\n    }\n\n    let mut value = None;\n    if binn_map_get_value(ptr, id, Some(&mut value)) == 0 {\n        return 0;\n    }\n\n    // Unwrap the value for copying\n    if let Some(ref mut val) = value {\n        if copy_value(\n            val.ptr.as_ref().map(|p| unsafe { \n                std::slice::from_raw_parts_mut(p.as_ref() as *const () as *mut u8, val.size as usize) \n            }),\n            pvalue.and_then(|v| v.downcast_mut::<Vec<u8>>()).map(|v| &mut v[..]),\n            val.type_,\n            type_,\n            storage_type,\n        ) == false {\n            return 0;\n        }\n\n        // Update size if psize exists\n        if let Some(size_ptr) = psize {\n            *size_ptr = val.size;\n        }\n    } else {\n        return 0;\n    }\n\n    1\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_get_read_storage",
            "binn_map_get_value",
            "copy_value",
            "zero_value"
        ],
        "header": "BOOL binn_map_get(void *map, int id, int type, void *pvalue, int *psize)",
        "params": [
            "void *ptr",
            "int id",
            "int type",
            "void *pvalue",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "id",
            "type",
            "pvalue",
            "psize",
            "value",
            "storage_type"
        ],
        "calle": [
            "binn_map_get_value",
            "copy_value",
            "binn_get_read_storage",
            "zero_value"
        ],
        "calle_c": [],
        "key": "binn_map_get",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_get_int8": {
        "source_code": "inline static BOOL binn_map_get_int8(void *map, int id, signed char *pvalue)\n{\n  return binn_map_get(map, id, 0x21, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_get_int8(\n    map: Option<&[u8]>, \n    id: i32, \n    pvalue: Option<&mut i8>\n) -> BOOL {\n    binn_map_get(map, id, 0x21, pvalue.map(|v| v as &mut dyn std::any::Any), Option::None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "params": [
            "void *map",
            "int id",
            "signed char *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "pvalue"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_get_int8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_get_int16": {
        "source_code": "inline static BOOL binn_map_get_int16(void *map, int id, short *pvalue)\n{\n  return binn_map_get(map, id, 0x41, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_get_int16(\n    map: Option<&[u8]>,\n    id: i32,\n    pvalue: Option<&mut i16>,\n) -> BOOL {\n    binn_map_get(map, id, 0x41, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "params": [
            "void *map",
            "int id",
            "short *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "pvalue"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_get_int16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_get_int32": {
        "source_code": "inline static BOOL binn_map_get_int32(void *map, int id, int *pvalue)\n{\n  return binn_map_get(map, id, 0x61, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_get_int32(\n    map: Option<&[u8]>,\n    id: i32,\n    pvalue: Option<&mut i32>,\n) -> BOOL {\n    binn_map_get(map, id, 0x61, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "params": [
            "void *map",
            "int id",
            "int *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "pvalue"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_get_int32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_get_uint8": {
        "source_code": "inline static BOOL binn_map_get_uint8(void *map, int id, unsigned char *pvalue)\n{\n  return binn_map_get(map, id, 0x20, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_get_uint8(\n    map: Option<&[u8]>,\n    id: i32,\n    pvalue: Option<&mut u8>,\n) -> BOOL {\n    binn_map_get(map, id, 0x20, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "params": [
            "void *map",
            "int id",
            "unsigned char *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "pvalue"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_get_uint8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_get_uint16": {
        "source_code": "inline static BOOL binn_map_get_uint16(void *map, int id, unsigned short *pvalue)\n{\n  return binn_map_get(map, id, 0x40, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_get_uint16(\n    map: Option<&[u8]>,\n    id: i32,\n    pvalue: Option<&mut u16>,\n) -> BOOL {\n    binn_map_get(map, id, 0x40, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "params": [
            "void *map",
            "int id",
            "unsigned short *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "pvalue"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_get_uint16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_get_uint32": {
        "source_code": "inline static BOOL binn_map_get_uint32(void *map, int id, unsigned int *pvalue)\n{\n  return binn_map_get(map, id, 0x60, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_get_uint32(map: Option<&[u8]>, id: i32, pvalue: Option<&mut u32>) -> BOOL {\n    binn_map_get(map, id, 0x60, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "params": [
            "void *map",
            "int id",
            "unsigned int *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "pvalue"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_get_uint32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_get_float": {
        "source_code": "inline static BOOL binn_map_get_float(void *map, int id, float *pvalue)\n{\n  return binn_map_get(map, id, 0x62, pvalue, 0);\n}\n\n",
        "translated_code": "use std::any::Any;\n\npub fn binn_map_get_float(\n    map: Option<&[u8]>,\n    id: i32,\n    pvalue: Option<&mut f32>,\n) -> BOOL {\n    binn_map_get(map, id, 0x62, pvalue.map(|v| v as &mut dyn Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "params": [
            "void *map",
            "int id",
            "float *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "pvalue"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_get_float",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_get_double": {
        "source_code": "inline static BOOL binn_map_get_double(void *map, int id, double *pvalue)\n{\n  return binn_map_get(map, id, 0x82, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_get_double(map: Option<&[u8]>, id: i32, pvalue: Option<&mut f64>) -> BOOL {\n    binn_map_get(map, id, 0x82, pvalue.map(|v| v as &mut dyn std::any::Any), Option::None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "params": [
            "void *map",
            "int id",
            "double *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "pvalue"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_get_double",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_get_str": {
        "source_code": "inline static BOOL binn_map_get_str(void *map, int id, char **pvalue)\n{\n  return binn_map_get(map, id, 0xA0, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_get_str(\n    map: Option<&[u8]>,\n    id: i32,\n    pvalue: Option<&mut Option<String>>,\n) -> BOOL {\n    binn_map_get(map, id, 0xA0, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "params": [
            "void *map",
            "int id",
            "char **pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "pvalue"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_get_str",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_get_blob": {
        "source_code": "inline static BOOL binn_map_get_blob(void *map, int id, void **pvalue, int *psize)\n{\n  return binn_map_get(map, id, 0xC0, pvalue, psize);\n}\n\n",
        "translated_code": "pub fn binn_map_get_blob(\n    map: Option<&[u8]>,\n    id: i32,\n    pvalue: Option<&mut dyn std::any::Any>,\n    psize: Option<&mut i32>,\n) -> BOOL {\n    binn_map_get(map, id, 0xC0, pvalue, psize)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "params": [
            "void *map",
            "int id",
            "void **pvalue",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "pvalue",
            "psize"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_get_blob",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_get_list": {
        "source_code": "inline static BOOL binn_map_get_list(void *map, int id, void **pvalue)\n{\n  return binn_map_get(map, id, 0xE0, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_get_list(\n    map: Option<&[u8]>,\n    id: i32,\n    pvalue: Option<&mut dyn std::any::Any>,\n) -> BOOL {\n    binn_map_get(map, id, 0xE0, pvalue, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "params": [
            "void *map",
            "int id",
            "void **pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "pvalue"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_get_list",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_get_map": {
        "source_code": "inline static BOOL binn_map_get_map(void *map, int id, void **pvalue)\n{\n  return binn_map_get(map, id, 0xE1, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_get_map(\n    map: Option<&[u8]>,\n    id: i32,\n    pvalue: Option<&mut dyn std::any::Any>,\n) -> BOOL {\n    binn_map_get(map, id, 0xE1, pvalue, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "params": [
            "void *map",
            "int id",
            "void **pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "pvalue"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_get_map",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_get_object": {
        "source_code": "inline static BOOL binn_map_get_object(void *map, int id, void **pvalue)\n{\n  return binn_map_get(map, id, 0xE2, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_get_object(\n    map: Option<&[u8]>,\n    id: i32,\n    pvalue: Option<&mut dyn std::any::Any>,\n) -> BOOL {\n    binn_map_get(map, id, 0xE2, pvalue, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "params": [
            "void *map",
            "int id",
            "void **pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "pvalue"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_get_object",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "SearchForKey": {
        "source_code": "static unsigned char *SearchForKey(unsigned char *p, int header_size, int size, int numitems, const char *key)\n{\n  unsigned int p_idx = 0;\n  unsigned char len;\n  unsigned char *plimit;\n  unsigned int plimit_idx = 0;\n  unsigned char *base;\n  unsigned int base_idx = 0;\n  int i;\n  int keylen;\n  base_idx = &p[p_idx];\n  plimit_idx = ((&p[p_idx]) + size) - 1;\n  p_idx += header_size;\n  keylen = strlen(key);\n  for (i = 0; i < numitems; i += 1)\n  {\n    len = *((unsigned char *) p);\n    p_idx += 1;\n    if ((&p[p_idx]) > (&plimit[plimit_idx]))\n    {\n      break;\n    }\n    if (len > 0)\n    {\n      if (strncasecmp((char *) p, key, len) == 0)\n      {\n        if (keylen == len)\n        {\n          p_idx += len;\n          return p;\n        }\n      }\n      p_idx += len;\n      if ((&p[p_idx]) > (&plimit[plimit_idx]))\n      {\n        break;\n      }\n    }\n    else\n      if (len == keylen)\n    {\n      return p;\n    }\n    p_idx = AdvanceDataPos(p_idx, plimit);\n    if (((&p[p_idx]) == 0) || ((&p[p_idx]) < (&base[base_idx])))\n    {\n      break;\n    }\n  }\n\n  return 0;\n}\n\n",
        "translated_code": "pub fn SearchForKey<'a>(\n    p: Option<&'a [u8]>,\n    header_size: usize,\n    size: usize,\n    numitems: i32,\n    key: Option<&str>,\n) -> Option<&'a [u8]> {\n    // Check for None inputs (equivalent to NULL checks in C)\n    let p = p?;\n    let key = key?;\n\n    let key_bytes = key.as_bytes();\n    let keylen = key_bytes.len();\n\n    let base = p;\n    let plimit = &p[size - 1..]; // Rust slices are exclusive, so no need for -1 adjustment\n\n    let mut p_idx = header_size;\n    let mut current_p = &p[p_idx..];\n\n    for _ in 0..numitems {\n        if current_p.is_empty() {\n            break;\n        }\n\n        let len = current_p[0] as usize;\n        current_p = &current_p[1..];\n        p_idx += 1;\n\n        if current_p.as_ptr() > plimit.as_ptr() {\n            break;\n        }\n\n        if len > 0 {\n            if len <= current_p.len() {\n                let item_slice = &current_p[..len];\n                // Case-insensitive comparison (approximation of strncasecmp)\n                if item_slice.len() >= key_bytes.len() {\n                    let comparison = item_slice\n                        .iter()\n                        .zip(key_bytes.iter())\n                        .map(|(&a, &b)| a.to_ascii_lowercase().cmp(&b.to_ascii_lowercase()))\n                        .find(|&ord| ord != Ordering::Equal)\n                        .unwrap_or(Ordering::Equal);\n\n                    if comparison == Ordering::Equal && len == keylen {\n                        return Some(&p[p_idx - 1..]); // Return including the length byte\n                    }\n                }\n            }\n\n            p_idx += len;\n            current_p = &p[p_idx..];\n\n            if current_p.as_ptr() > plimit.as_ptr() {\n                break;\n            }\n        } else if keylen == 0 {\n            return Some(&p[p_idx - 1..]); // Return including the length byte\n        }\n\n        if let Some(advanced) = AdvanceDataPos(&p[p_idx..], plimit.as_ptr() as usize) {\n            p_idx = unsafe { advanced.as_ptr().offset_from(p.as_ptr()) } as usize;\n            current_p = advanced;\n        } else {\n            break;\n        }\n\n        if current_p.is_empty() || current_p.as_ptr() < base.as_ptr() {\n            break;\n        }\n    }\n\n    None\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "AdvanceDataPos"
        ],
        "params": [
            "unsigned char *p",
            "int header_size",
            "int size",
            "int numitems",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "p",
            "header_size",
            "size",
            "numitems",
            "key",
            "p_idx",
            "len",
            "plimit",
            "plimit_idx",
            "base",
            "base_idx",
            "i",
            "keylen"
        ],
        "calle": [
            "strncasecmp",
            "strlen",
            "AdvanceDataPos"
        ],
        "calle_c": [
            "strncasecmp",
            "strlen"
        ],
        "key": "SearchForKey",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_object_get_value": {
        "source_code": "BOOL binn_object_get_value(void *ptr, const char *key, binn *value)\n{\n  unsigned int ptr_idx = 0;\n  int type;\n  int count;\n  int size = 0;\n  int header_size;\n  unsigned char *p;\n  unsigned int p_idx = 0;\n  ptr_idx = binn_ptr(ptr_idx);\n  if ((((&ptr[ptr_idx]) == 0) || (key == 0)) || (value == 0))\n  {\n    return 0;\n  }\n  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == 0)\n  {\n    return 0;\n  }\n  if (type != 0xE2)\n  {\n    return 0;\n  }\n  if (count == 0)\n  {\n    return 0;\n  }\n  p_idx = (unsigned char *) ptr;\n  p_idx = SearchForKey(p_idx, header_size, size, count, key);\n  if ((&p[p_idx]) == 0)\n  {\n    return 0;\n  }\n  return GetValue(p, value);\n}\n\n",
        "translated_code": "pub fn binn_object_get_value(ptr: Option<&[u8]>, key: Option<&str>, value: Option<&mut binn>) -> BOOL {\n    let ptr_idx = binn_ptr(None); // Assuming binn_ptr returns None in this context\n    if ptr.is_none() || key.is_none() || value.is_none() {\n        return 0;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if !IsValidBinnHeader(\n        ptr,\n        Some(&mut type_),\n        Some(&mut count),\n        Some(&mut size),\n        Some(&mut header_size),\n    ) {\n        return 0;\n    }\n\n    if type_ != 0xE2 {\n        return 0;\n    }\n\n    if count == 0 {\n        return 0;\n    }\n\n    let p = ptr.unwrap();\n    let p_idx = SearchForKey(\n        Some(p),\n        header_size as usize,\n        size as usize,\n        count,\n        key,\n    );\n    if p_idx.is_none() {\n        return 0;\n    }\n\n    GetValue(p_idx, value)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "GetValue",
            "IsValidBinnHeader",
            "SearchForKey",
            "binn",
            "binn_ptr"
        ],
        "header": "BOOL binn_object_get_value(void *obj, const char *key, binn *value)",
        "params": [
            "void *ptr",
            "const char *key",
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "key",
            "value",
            "ptr_idx",
            "type",
            "count",
            "size",
            "header_size",
            "p",
            "p_idx"
        ],
        "calle": [
            "IsValidBinnHeader",
            "SearchForKey",
            "binn_ptr",
            "GetValue"
        ],
        "calle_c": [],
        "key": "binn_object_get_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_object_get": {
        "source_code": "BOOL binn_object_get(void *ptr, const char *key, int type, void *pvalue, int *psize)\n{\n  binn value;\n  int storage_type;\n  storage_type = binn_get_read_storage(type);\n  if ((storage_type != 0x00) && (pvalue == 0))\n  {\n    return 0;\n  }\n  zero_value(pvalue, type);\n  if (binn_object_get_value(ptr, key, &value) == 0)\n  {\n    return 0;\n  }\n  if (copy_value(value.ptr, pvalue, value.type, type, storage_type) == 0)\n  {\n    return 0;\n  }\n  if (psize)\n  {\n    *psize = value.size;\n  }\n  return 1;\n}\n\n",
        "translated_code": "pub fn binn_object_get(\n    ptr: Option<&[u8]>,\n    key: Option<&str>,\n    type_: i32,\n    mut pvalue: Option<&mut dyn Any>,\n    psize: Option<&mut i32>,\n) -> i32 {\n    let storage_type = binn_get_read_storage(type_);\n    \n    if storage_type != 0x00 && pvalue.is_none() {\n        return 0;\n    }\n\n    if let Some(ref mut pval) = pvalue {\n        zero_value(Some(*pval), type_);\n    }\n\n    let mut value: Option<Box<BinnStruct>> = None;\n    if binn_object_get_value(ptr, key, Some(&mut value)) == 0 {\n        return 0;\n    }\n\n    let value_ref = match value {\n        Some(ref v) => v,\n        None => return 0,\n    };\n\n    let ptr_slice = value_ref.ptr.as_ref().map(|p| unsafe {\n        std::slice::from_raw_parts(Box::as_ref(p) as *const () as *const u8, value_ref.size as usize)\n    });\n\n    let dest_slice = pvalue.and_then(|pv| pv.downcast_mut::<Vec<u8>>());\n\n    let copy_success = copy_value(\n        ptr_slice.map(|s| unsafe { std::slice::from_raw_parts_mut(s.as_ptr() as *mut u8, s.len()) }),\n        dest_slice.map(|v| &mut v[..]),\n        value_ref.type_,\n        type_,\n        storage_type,\n    );\n\n    if !copy_success {\n        return 0;\n    }\n\n    if let Some(size_ptr) = psize {\n        *size_ptr = value_ref.size;\n    }\n\n    1\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_get_read_storage",
            "binn_object_get_value",
            "copy_value",
            "zero_value"
        ],
        "header": "BOOL binn_object_get(void *obj, const char *key, int type, void *pvalue, int *psize)",
        "params": [
            "void *ptr",
            "const char *key",
            "int type",
            "void *pvalue",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "key",
            "type",
            "pvalue",
            "psize",
            "value",
            "storage_type"
        ],
        "calle": [
            "binn_object_get_value",
            "copy_value",
            "binn_get_read_storage",
            "zero_value"
        ],
        "calle_c": [],
        "key": "binn_object_get",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_get_int8": {
        "source_code": "inline static BOOL binn_object_get_int8(void *obj, const char *key, signed char *pvalue)\n{\n  return binn_object_get(obj, key, 0x21, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_get_int8(\n    obj: Option<&[u8]>,\n    key: Option<&str>,\n    pvalue: Option<&mut i8>,\n) -> bool {\n    binn_object_get(obj, key, 0x21, pvalue.map(|v| v as &mut dyn Any), None) != 0\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "params": [
            "void *obj",
            "const char *key",
            "signed char *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "pvalue"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_get_int8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_get_int16": {
        "source_code": "inline static BOOL binn_object_get_int16(void *obj, const char *key, short *pvalue)\n{\n  return binn_object_get(obj, key, 0x41, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_get_int16(\n    obj: Option<&[u8]>,\n    key: Option<&str>,\n    pvalue: Option<&mut i16>,\n) -> bool {\n    // Convert pvalue to &mut dyn Any as required by binn_object_get\n    let any_pvalue = pvalue.map(|v| v as &mut dyn Any);\n    \n    // Call binn_object_get with type 0x41 (INT16)\n    binn_object_get(obj, key, 0x41, any_pvalue, None) != 0\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "params": [
            "void *obj",
            "const char *key",
            "short *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "pvalue"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_get_int16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_get_int32": {
        "source_code": "inline static BOOL binn_object_get_int32(void *obj, const char *key, int *pvalue)\n{\n  return binn_object_get(obj, key, 0x61, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_get_int32(obj: Option<&[u8]>, key: Option<&str>, pvalue: Option<&mut i32>) -> bool {\n    // Convert the bool return to i32 (0 for false, 1 for true) to match C's BOOL type\n    binn_object_get(obj, key, 0x61, pvalue.map(|v| v as &mut dyn Any), None) != 0\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "params": [
            "void *obj",
            "const char *key",
            "int *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "pvalue"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_get_int32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_get_uint8": {
        "source_code": "inline static BOOL binn_object_get_uint8(void *obj, const char *key, unsigned char *pvalue)\n{\n  return binn_object_get(obj, key, 0x20, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_get_uint8(\n    obj: Option<&[u8]>,\n    key: Option<&str>,\n    pvalue: Option<&mut u8>,\n) -> bool {\n    // Convert the bool return to i32 for compatibility with binn_object_get\n    binn_object_get(obj, key, 0x20, pvalue.map(|v| v as &mut dyn Any), None) != 0\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "params": [
            "void *obj",
            "const char *key",
            "unsigned char *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "pvalue"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_get_uint8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_get_uint16": {
        "source_code": "inline static BOOL binn_object_get_uint16(void *obj, const char *key, unsigned short *pvalue)\n{\n  return binn_object_get(obj, key, 0x40, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_get_uint16(\n    obj: Option<&[u8]>,\n    key: Option<&str>,\n    pvalue: Option<&mut u16>,\n) -> bool {\n    // The 0x40 corresponds to BINN_UINT16 in the original C code\n    binn_object_get(obj, key, 0x40, pvalue.map(|v| v as &mut dyn Any), None) != 0\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "params": [
            "void *obj",
            "const char *key",
            "unsigned short *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "pvalue"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_get_uint16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_get_uint32": {
        "source_code": "inline static BOOL binn_object_get_uint32(void *obj, const char *key, unsigned int *pvalue)\n{\n  return binn_object_get(obj, key, 0x60, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_get_uint32(obj: Option<&[u8]>, key: Option<&str>, pvalue: Option<&mut u32>) -> bool {\n    binn_object_get(obj, key, 0x60, pvalue.map(|v| v as &mut dyn Any), None) != 0\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "params": [
            "void *obj",
            "const char *key",
            "unsigned int *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "pvalue"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_get_uint32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_get_float": {
        "source_code": "inline static BOOL binn_object_get_float(void *obj, const char *key, float *pvalue)\n{\n  return binn_object_get(obj, key, 0x62, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_get_float(obj: Option<&[u8]>, key: Option<&str>, pvalue: Option<&mut f32>) -> bool {\n    // Convert the bool return to i32 for compatibility with binn_object_get\n    let result = binn_object_get(obj, key, 0x62, pvalue.map(|v| v as &mut dyn Any), None);\n    result != 0\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "params": [
            "void *obj",
            "const char *key",
            "float *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "pvalue"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_get_float",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_get_double": {
        "source_code": "inline static BOOL binn_object_get_double(void *obj, const char *key, double *pvalue)\n{\n  return binn_object_get(obj, key, 0x82, pvalue, 0);\n}\n\n",
        "translated_code": "use std::any::Any;\n\npub fn binn_object_get_double(\n    obj: Option<&[u8]>,\n    key: Option<&str>,\n    pvalue: Option<&mut f64>,\n) -> bool {\n    // Convert the bool return to i32 (0 for false, 1 for true)\n    binn_object_get(obj, key, 0x82, pvalue.map(|v| v as &mut dyn Any), None) != 0\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "params": [
            "void *obj",
            "const char *key",
            "double *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "pvalue"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_get_double",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_get_str": {
        "source_code": "inline static BOOL binn_object_get_str(void *obj, const char *key, char **pvalue)\n{\n  return binn_object_get(obj, key, 0xA0, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_get_str(\n    obj: Option<&[u8]>,\n    key: Option<&str>,\n    pvalue: Option<&mut dyn Any>,\n) -> i32 {\n    binn_object_get(obj, key, 0xA0, pvalue, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "params": [
            "void *obj",
            "const char *key",
            "char **pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "pvalue"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_get_str",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_get_blob": {
        "source_code": "inline static BOOL binn_object_get_blob(void *obj, const char *key, void **pvalue, int *psize)\n{\n  return binn_object_get(obj, key, 0xC0, pvalue, psize);\n}\n\n",
        "translated_code": "pub fn binn_object_get_blob(\n    obj: Option<&[u8]>,\n    key: Option<&str>,\n    pvalue: Option<&mut dyn Any>,\n    psize: Option<&mut i32>,\n) -> bool {\n    // Call binn_object_get with the blob type (0xC0) and convert the result to bool\n    binn_object_get(obj, key, 0xC0, pvalue, psize) != 0\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "params": [
            "void *obj",
            "const char *key",
            "void **pvalue",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "pvalue",
            "psize"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_get_blob",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_get_list": {
        "source_code": "inline static BOOL binn_object_get_list(void *obj, const char *key, void **pvalue)\n{\n  return binn_object_get(obj, key, 0xE0, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_get_list(\n    obj: Option<&[u8]>,\n    key: Option<&str>,\n    pvalue: Option<&mut dyn Any>,\n) -> i32 {\n    binn_object_get(obj, key, 0xE0, pvalue, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "params": [
            "void *obj",
            "const char *key",
            "void **pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "pvalue"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_get_list",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_get_map": {
        "source_code": "inline static BOOL binn_object_get_map(void *obj, const char *key, void **pvalue)\n{\n  return binn_object_get(obj, key, 0xE1, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_get_map(\n    obj: Option<&[u8]>,\n    key: Option<&str>,\n    pvalue: Option<&mut dyn Any>,\n) -> i32 {\n    binn_object_get(obj, key, 0xE1, pvalue, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "params": [
            "void *obj",
            "const char *key",
            "void **pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "pvalue"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_get_map",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_get_object": {
        "source_code": "inline static BOOL binn_object_get_object(void *obj, const char *key, void **pvalue)\n{\n  return binn_object_get(obj, key, 0xE2, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_get_object(obj: Option<&[u8]>, key: Option<&str>, pvalue: Option<&mut dyn Any>) -> bool {\n    binn_object_get(obj, key, 0xE2, pvalue, None) != 0\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "params": [
            "void *obj",
            "const char *key",
            "void **pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "pvalue"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_get_object",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_binn_version": {
        "source_code": "void test_binn_version()\n{\n  char *version = binn_version();\n  assert(version);\n  assert(strcmp(version, \"3.0.0\") == 0);\n}\n\n",
        "translated_code": "pub fn test_binn_version() {\n    let version = binn_version();\n    assert!(!version.is_empty());\n    assert_eq!(version, \"3.0.0\");\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_version"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "version"
        ],
        "calle": [
            "assert",
            "strcmp",
            "binn_version"
        ],
        "calle_c": [
            "strcmp",
            "assert"
        ],
        "key": "test_binn_version",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "i64toa": {
        "source_code": "char *i64toa(int64 value, char *buf, int radix)\n{\n  switch (radix)\n  {\n    case 10:\n      snprintf(buf, 64, \"%lli\", value);\n      break;\n\n    case 16:\n      snprintf(buf, 64, \"%llx\", value);\n      break;\n\n    default:\n      buf[0] = 0;\n\n  }\n\n  return buf;\n}\n\n",
        "translated_code": "pub fn i64toa(value: int64, buf: &mut [u8], radix: u32) -> Option<&mut [u8]> {\n    match radix {\n        10 => {\n            write!(std::io::Cursor::new(&mut *buf), \"{}\", value).ok()?;\n        },\n        16 => {\n            write!(std::io::Cursor::new(&mut *buf), \"{:x}\", value).ok()?;\n        },\n        _ => {\n            if !buf.is_empty() {\n                buf[0] = 0;\n            }\n        }\n    }\n    Some(buf)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "int64"
        ],
        "params": [
            "int64 value",
            "char *buf",
            "int radix"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value",
            "buf",
            "radix"
        ],
        "calle": [
            "snprintf"
        ],
        "calle_c": [
            "snprintf"
        ],
        "key": "i64toa",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "pass_int64": {
        "source_code": "void pass_int64(int64 a)\n{\n  assert(a == 9223372036854775807);\n  assert(a > 9223372036854775806);\n}\n\n",
        "translated_code": "pub fn pass_int64(a: int64) {\n    assert!(a == 9223372036854775807);\n    assert!(a > 9223372036854775806);\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "int64"
        ],
        "params": [
            "int64 a"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "a"
        ],
        "calle": [
            "assert"
        ],
        "calle_c": [
            "assert"
        ],
        "key": "pass_int64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "return_passed_int64": {
        "source_code": "int64 return_passed_int64(int64 a)\n{\n  return a;\n}\n\n",
        "translated_code": "pub fn return_passed_int64(a: int64) -> int64 {\n    a\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "int64"
        ],
        "params": [
            "int64 a"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "a"
        ],
        "calle": [],
        "calle_c": [],
        "key": "return_passed_int64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_is_valid_ex": {
        "source_code": "BOOL binn_is_valid_ex(void *ptr, int *ptype, int *pcount, int *psize)\n{\n  int i;\n  int type;\n  int count;\n  int size;\n  int header_size;\n  unsigned char *p;\n  unsigned int p_idx = 0;\n  unsigned char *plimit;\n  unsigned int plimit_idx = 0;\n  unsigned char *base;\n  unsigned int base_idx = 0;\n  unsigned char len;\n  void *pbuf;\n  unsigned int pbuf_idx = 0;\n  pbuf_idx = binn_ptr(ptr);\n  if ((&pbuf[pbuf_idx]) == 0)\n  {\n    return 0;\n  }\n  if (psize && ((*psize) > 0))\n  {\n    size = *psize;\n  }\n  else\n  {\n    size = 0;\n  }\n  if (!IsValidBinnHeader(pbuf, &type, &count, &size, &header_size))\n  {\n    return 0;\n  }\n  if (psize && ((*psize) > 0))\n  {\n    if (size != (*psize))\n    {\n      return 0;\n    }\n  }\n  if (pcount && ((*pcount) > 0))\n  {\n    if (count != (*pcount))\n    {\n      return 0;\n    }\n  }\n  if (ptype && ((*ptype) != 0))\n  {\n    if (type != (*ptype))\n    {\n      return 0;\n    }\n  }\n  p_idx = (unsigned char *) pbuf;\n  base_idx = &p[p_idx];\n  plimit_idx = (&p[p_idx]) + size;\n  p_idx += header_size;\n  for (i = 0; i < count; i += 1)\n  {\n    switch (type)\n    {\n      case 0xE2:\n        len = p[p_idx];\n        p_idx += 1;\n        p_idx += len;\n        break;\n\n      case 0xE1:\n        read_map_id(&(&p[p_idx]), plimit);\n        break;\n\n    }\n\n    p_idx = AdvanceDataPos(p_idx, plimit);\n    if (((&p[p_idx]) == 0) || ((&p[p_idx]) < (&base[base_idx])))\n    {\n      goto Invalid;\n    }\n  }\n\n  if (ptype && ((*ptype) == 0))\n  {\n    *ptype = type;\n  }\n  if (pcount && ((*pcount) == 0))\n  {\n    *pcount = count;\n  }\n  if (psize && ((*psize) == 0))\n  {\n    *psize = size;\n  }\n  return 1;\n  Invalid:\n  return 0;\n\n}\n\n",
        "translated_code": "pub fn binn_is_valid_ex(\n    ptr: Option<*mut u8>,\n    mut ptype: Option<&mut i32>,\n    mut pcount: Option<&mut i32>,\n    mut psize: Option<&mut i32>,\n) -> bool {\n    let pbuf = binn_ptr(ptr);\n    if pbuf.is_none() {\n        return false;\n    }\n    let pbuf = pbuf.unwrap();\n\n    let mut size = match psize.as_ref() {\n        Some(s) if **s > 0 => **s,\n        _ => 0,\n    };\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut header_size = 0;\n\n    if !IsValidBinnHeader(\n        Some(unsafe { std::slice::from_raw_parts(pbuf, size as usize) }),\n        ptype.as_deref_mut(),\n        pcount.as_deref_mut(),\n        psize.as_deref_mut(),\n        Some(&mut header_size),\n    ) {\n        return false;\n    }\n\n    if let Some(s) = psize.as_ref() {\n        if **s > 0 && size != **s {\n            return false;\n        }\n    }\n\n    if let Some(c) = pcount.as_ref() {\n        if **c > 0 && count != **c {\n            return false;\n        }\n    }\n\n    if let Some(t) = ptype.as_ref() {\n        if **t != 0 && type_ != **t {\n            return false;\n        }\n    }\n\n    let p = unsafe { std::slice::from_raw_parts(pbuf, size as usize) };\n    let base = p.as_ptr();\n    let plimit = unsafe { p.as_ptr().add(size as usize) };\n    let mut p_idx = header_size as usize;\n\n    for _ in 0..count {\n        match type_ {\n            0xE2 => {\n                let len = p[p_idx] as usize;\n                p_idx += 1;\n                p_idx += len;\n            }\n            0xE1 => {\n                let mut pp = &p[p_idx..];\n                if read_map_id(&mut pp, unsafe {\n                    std::slice::from_raw_parts(plimit, (p.len() - p_idx) as usize)\n                }).is_none() {\n                    return false;\n                }\n                p_idx = p.len() - pp.len();\n            }\n            _ => (),\n        }\n\n        if let Some(new_pos) = AdvanceDataPos(&p[p_idx..], plimit as usize) {\n            p_idx = p.len() - new_pos.len();\n        } else {\n            return false;\n        }\n\n        let current_ptr = unsafe { p.as_ptr().add(p_idx) };\n        if current_ptr.is_null() || current_ptr < base {\n            return false;\n        }\n    }\n\n    if let Some(t) = ptype {\n        if *t == 0 {\n            *t = type_;\n        }\n    }\n\n    if let Some(c) = pcount {\n        if *c == 0 {\n            *c = count;\n        }\n    }\n\n    if let Some(s) = psize {\n        if *s == 0 {\n            *s = size;\n        }\n    }\n\n    true\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "AdvanceDataPos",
            "IsValidBinnHeader",
            "binn_ptr",
            "read_map_id"
        ],
        "header": "BOOL binn_is_valid_ex(void *ptr, int *ptype, int *pcount, int *psize)",
        "params": [
            "void *ptr",
            "int *ptype",
            "int *pcount",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "ptype",
            "pcount",
            "psize",
            "i",
            "type",
            "count",
            "size",
            "header_size",
            "p",
            "p_idx",
            "plimit",
            "plimit_idx",
            "base",
            "base_idx",
            "len",
            "pbuf",
            "pbuf_idx"
        ],
        "calle": [
            "IsValidBinnHeader",
            "binn_ptr",
            "read_map_id",
            "AdvanceDataPos"
        ],
        "calle_c": [],
        "key": "binn_is_valid_ex",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "test_invalid_binn": {
        "source_code": "void test_invalid_binn()\n{\n  char buffers[][20] = {{0xE0}, {0xE0, 0x7E}, {0xE0, 0x7E, 0x7F}, {0xE0, 0x7E, 0x7F, 0x12}, {0xE0, 0x7E, 0x7F, 0x12, 0x34}, {0xE0, 0x7E, 0x7F, 0x12, 0x34, 0x01}, {0xE0, 0x7E, 0x7F, 0x12, 0x34, 0x7F}, {0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF}, {0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF}, {0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF}, {0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF}, {0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0x01}, {0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, {0xE0, 0x7E, 0xFF}, {0xE0, 0x7E, 0xFF, 0x12}, {0xE0, 0x7E, 0xFF, 0x12, 0x34}, {0xE0, 0x7E, 0xFF, 0x12, 0x34, 0x01}, {0xE0, 0x7E, 0xFF, 0x12, 0x34, 0x7F}, {0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF}, {0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF}, {0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF}, {0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF}, {0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0x01}, {0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, {0xE0, 0x8E}, {0xE0, 0x8E, 0xFF}, {0xE0, 0x8E, 0xFF, 0x12}, {0xE0, 0x8E, 0xFF, 0x12, 0x34}, {0xE0, 0x8E, 0xFF, 0x12, 0x34, 0x01}, {0xE0, 0x8E, 0xFF, 0x12, 0x34, 0x7F}, {0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF}, {0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF}, {0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF}, {0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF}, {0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0x01}, {0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}};\n  int count;\n  int size;\n  int i;\n  char *ptr;\n  unsigned int ptr_idx = 0;\n  puts(\"testing invalid binn buffers...\");\n  count = (sizeof(buffers)) / (sizeof(buffers[0]));\n  for (i = 0; i < count; i += 1)\n  {\n    ptr_idx = buffers[i];\n    size = strlen(ptr);\n    printf(\"checking invalid binn #%d   size: %d bytes\\n\", i, size);\n    assert(binn_is_valid_ex(ptr, 0, 0, &size) == 0);\n  }\n\n  puts(\"OK\");\n}\n\n",
        "translated_code": "pub fn test_invalid_binn() {\n    let buffers: [[u8; 20]; 36] = [\n        [0xE0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0x34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0x34, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0x34, 0x7F, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0x34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0x34, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0x34, 0x7F, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0x34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0x34, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0x34, 0x7F, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    ];\n\n    println!(\"testing invalid binn buffers...\");\n    let count = buffers.len();\n    for i in 0..count {\n        let ptr = buffers[i].as_ptr() as *mut u8;\n        let c_str = unsafe { CStr::from_ptr(buffers[i].as_ptr() as *const c_char) };\n        let size = c_str.to_bytes().len();\n        println!(\"checking invalid binn #{}   size: {} bytes\", i, size);\n        \n        let mut size_mut = size as i32;\n        assert!(!binn_is_valid_ex(\n            Some(ptr),\n            None,\n            None,\n            Some(&mut size_mut)\n        ));\n    }\n\n    println!(\"OK\");\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_is_valid_ex"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "buffers",
            "count",
            "size",
            "i",
            "ptr",
            "ptr_idx"
        ],
        "calle": [
            "puts",
            "strlen",
            "assert",
            "binn_is_valid_ex",
            "printf"
        ],
        "calle_c": [
            "puts",
            "assert",
            "printf",
            "strlen"
        ],
        "key": "test_invalid_binn",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "date_to_str": {
        "source_code": "char *date_to_str(unsigned short date)\n{\n  int day;\n  int month;\n  int year;\n  day = (date & 0xf800) >> 11;\n  month = (date & 0x0780) >> 7;\n  year = date & 0x007f;\n  sprintf(tmp, \"%.4d-%.2d-%.2d\", year + 1900, month, day);\n  return tmp;\n}\n\n",
        "translated_code": "use lazy_static::lazy_static;\n\nlazy_static! {\n    pub static ref TMP: std::sync::Mutex<[u8; 128]> = std::sync::Mutex::new([0; 128]);\n}\n\npub fn date_to_str(date: u16) -> String {\n    let day = (date & 0xf800) >> 11;\n    let month = (date & 0x0780) >> 7;\n    let year = date & 0x007f;\n    \n    format!(\"{:04}-{:02}-{:02}\", year + 1900, month, day)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [
            "tmp"
        ],
        "params": [
            "unsigned short date"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "date",
            "day",
            "month",
            "year",
            "tmp"
        ],
        "calle": [
            "sprintf"
        ],
        "calle_c": [
            "sprintf"
        ],
        "key": "date_to_str",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "atoi64": {
        "source_code": "int64 atoi64(char *str)\n{\n  unsigned int str_idx = 0;\n  int64 retval;\n  int is_negative = 0;\n  if (str[str_idx] == '-')\n  {\n    is_negative = 1;\n    str_idx += 1;\n  }\n  retval = 0;\n  for (; str[str_idx]; str_idx += 1)\n  {\n    retval = (10 * retval) + (str[str_idx] - '0');\n  }\n\n  if (is_negative)\n  {\n    retval *= -1;\n  }\n  return retval;\n}\n\n",
        "translated_code": "pub fn atoi64(str: Option<&str>) -> Option<int64> {\n    // Check for None (equivalent to NULL check in C)\n    let str = str?;\n    \n    let mut str_idx = 0;\n    let mut retval: int64;\n    let mut is_negative = false;\n    \n    // Check for negative sign\n    if let Some(c) = str.chars().nth(str_idx) {\n        if c == '-' {\n            is_negative = true;\n            str_idx += 1;\n        }\n    }\n    \n    retval = 0;\n    \n    // Iterate through remaining characters\n    for c in str.chars().skip(str_idx) {\n        if !c.is_ascii_digit() {\n            return None; // Invalid character encountered\n        }\n        retval = (10 * retval) + (c.to_digit(10).unwrap() as int64);\n    }\n    \n    if is_negative {\n        retval *= -1;\n    }\n    \n    Some(retval)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "int64"
        ],
        "params": [
            "char *str"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "str",
            "str_idx",
            "retval",
            "is_negative"
        ],
        "calle": [],
        "calle_c": [],
        "key": "atoi64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "str_to_currency": {
        "source_code": "int64 str_to_currency(char *str)\n{\n  unsigned int str_idx = 0;\n  char *next;\n  unsigned int next_idx = 0;\n  int size;\n  int i;\n  if ((&str[str_idx]) == 0)\n  {\n    return 0;\n  }\n  strcpy(tmp, str);\n  str_idx = tmp;\n  next_idx = strchr(str, '.');\n  if (next)\n  {\n    size = strlen((&next[next_idx]) + 1);\n    memmove(next, (&next[next_idx]) + 1, size + 1);\n    if (size <= 4)\n    {\n      size = 4 - size;\n      for (i = 0; i < size; i += 1)\n      {\n        strcat(str, \"0\");\n      }\n\n    }\n    else\n    {\n      next[4 + next_idx] = 0;\n    }\n  }\n  else\n  {\n    strcat(str, \"0000\");\n  }\n  return atoi64(str);\n}\n\n",
        "translated_code": "pub fn str_to_currency(str: Option<&str>) -> Option<i64> {\n    // Convert Option<&str> to Option<&CStr> for safer handling\n    let str_cstr = str.and_then(|s| CStr::from_bytes_with_nul(s.as_bytes()).ok());\n    if str_cstr.is_none() {\n        return None;\n    }\n    let str_cstr = str_cstr.unwrap();\n\n    // Check if string is empty (equivalent to line 8-11)\n    if str_cstr.to_bytes().is_empty() {\n        return Some(0);\n    }\n\n    // Copy string to TMP (equivalent to line 12-13)\n    let mut tmp_guard = TMP.lock().unwrap();\n    let tmp_slice = &mut tmp_guard[..];\n    let str_bytes = str_cstr.to_bytes_with_nul();\n    if str_bytes.len() > tmp_slice.len() {\n        return None; // Buffer would overflow\n    }\n    tmp_slice[..str_bytes.len()].copy_from_slice(str_bytes);\n\n    // Find decimal point (equivalent to line 14)\n    let next_pos = tmp_slice.iter().position(|&c| c == b'.');\n\n    if let Some(next_idx) = next_pos {\n        // Handle case with decimal point (lines 15-31)\n        let decimal_part_start = next_idx + 1;\n        let decimal_part_len = tmp_slice[decimal_part_start..]\n            .iter()\n            .position(|&c| c == 0)\n            .unwrap_or(tmp_slice.len() - decimal_part_start);\n\n        // Store length before mutable operations\n        let slice_len = tmp_slice.len();\n\n        // Use split_at_mut to avoid overlapping borrows\n        let (left, right) = tmp_slice.split_at_mut(decimal_part_start);\n        let decimal_part = &right[..decimal_part_len];\n        \n        // Move decimal digits left (equivalent to memmove in line 18)\n        if next_idx + decimal_part_len < slice_len {\n            left[next_idx..next_idx + decimal_part_len].copy_from_slice(decimal_part);\n            left[next_idx + decimal_part_len] = 0;\n        }\n\n        // Pad with zeros if needed (lines 19-26)\n        if decimal_part_len < 4 {\n            let zeros_needed = 4 - decimal_part_len;\n            let end_pos = next_idx + decimal_part_len;\n            if end_pos + zeros_needed < slice_len {\n                tmp_slice[end_pos..end_pos + zeros_needed].fill(b'0');\n                tmp_slice[end_pos + zeros_needed] = 0;\n            }\n        } else {\n            // Truncate to 4 decimal places (line 30)\n            let truncate_pos = next_idx + 4;\n            if truncate_pos < slice_len {\n                tmp_slice[truncate_pos] = 0;\n            }\n        }\n    } else {\n        // No decimal point - append \"0000\" (line 35)\n        let len = tmp_slice.iter().position(|&c| c == 0).unwrap_or(tmp_slice.len());\n        if len + 4 < tmp_slice.len() {\n            tmp_slice[len..len + 4].copy_from_slice(b\"0000\");\n            tmp_slice[len + 4] = 0;\n        }\n    }\n\n    // Convert to string and parse (line 37)\n    let result_str = unsafe { CStr::from_ptr(tmp_slice.as_ptr() as *const i8) };\n    atoi64(result_str.to_str().ok())\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [
            "atoi64",
            "tmp"
        ],
        "params": [
            "char *str"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "str",
            "str_idx",
            "next",
            "next_idx",
            "size",
            "i",
            "tmp"
        ],
        "calle": [
            "memmove",
            "strcpy",
            "atoi64",
            "strcat",
            "strchr",
            "strlen"
        ],
        "calle_c": [
            "memmove",
            "strcpy",
            "strcat",
            "strchr",
            "strlen"
        ],
        "key": "str_to_currency",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "float_to_currency": {
        "source_code": "int64 float_to_currency(double value)\n{\n  char buf[128];\n  snprintf(buf, 127, \"%.4f\", value);\n  return str_to_currency(buf);\n}\n\n",
        "translated_code": "pub fn float_to_currency(value: f64) -> Option<i64> {\n    let buf = format!(\"{:.4}\", value); // Equivalent to snprintf with \"%.4f\" format\n    str_to_currency(Some(&buf)) // Convert the formatted string to currency\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [
            "str_to_currency"
        ],
        "params": [
            "double value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value",
            "buf"
        ],
        "calle": [
            "str_to_currency",
            "snprintf"
        ],
        "calle_c": [
            "snprintf"
        ],
        "key": "float_to_currency",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "mul_currency": {
        "source_code": "int64 mul_currency(int64 value1, int64 value2)\n{\n  return (value1 * value2) / 10000;\n}\n\n",
        "translated_code": "pub fn mul_currency(value1: int64, value2: int64) -> int64 {\n    (value1 * value2) / 10000\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [
            "int64"
        ],
        "params": [
            "int64 value1",
            "int64 value2"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value1",
            "value2"
        ],
        "calle": [],
        "calle_c": [],
        "key": "mul_currency",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "div_currency": {
        "source_code": "int64 div_currency(int64 value1, int64 value2)\n{\n  return (value1 * 10000) / value2;\n}\n\n",
        "translated_code": "pub fn div_currency(value1: int64, value2: int64) -> int64 {\n    (value1 * 10000) / value2\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [
            "int64"
        ],
        "params": [
            "int64 value1",
            "int64 value2"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value1",
            "value2"
        ],
        "calle": [],
        "calle_c": [],
        "key": "div_currency",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_get_write_storage": {
        "source_code": "int binn_get_write_storage(int type)\n{\n  int storage_type;\n  switch (type)\n  {\n    case 0xA6:\n\n    case 0xA7:\n      return 0xA0;\n\n    case 0x80061:\n      return 0x00;\n\n    default:\n      binn_get_type_info(type, &storage_type, 0);\n      return storage_type;\n\n  }\n\n}\n\n",
        "translated_code": "pub fn binn_get_write_storage(type_: i32) -> i32 {\n    match type_ {\n        0xA6 | 0xA7 => 0xA0,\n        0x80061 => 0x00,\n        _ => {\n            let mut storage_type = 0;\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_get_type_info"
        ],
        "header": "int binn_get_write_storage(int type)",
        "params": [
            "int type"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "type",
            "storage_type"
        ],
        "calle": [
            "binn_get_type_info"
        ],
        "calle_c": [],
        "key": "binn_get_write_storage",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_is_container": {
        "source_code": "BOOL binn_is_container(binn *item)\n{\n  if (item == 0)\n  {\n    return 0;\n  }\n  switch (item->type)\n  {\n    case 0xE0:\n\n    case 0xE1:\n\n    case 0xE2:\n      return 1;\n\n    default:\n      return 0;\n\n  }\n\n}\n\n",
        "translated_code": "pub fn binn_is_container(item: binn) -> BOOL {\n    // Check if item is None (equivalent to NULL in C)\n    if item.is_none() {\n        return 0;\n    }\n\n    // Unwrap the Option safely\n    let item = item.unwrap();\n\n    // Match on the type field (equivalent to switch in C)\n    match item.type_ {\n        0xE0 | 0xE1 | 0xE2 => 1,  // Return 1 for container types\n        _ => 0,                    // Return 0 for all other types\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn"
        ],
        "header": "BOOL binn_is_container(binn *item)",
        "params": [
            "binn *item"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "item"
        ],
        "calle": [],
        "calle_c": [],
        "key": "binn_is_container",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_is_valid": {
        "source_code": "BOOL binn_is_valid(void *ptr, int *ptype, int *pcount, int *psize)\n{\n  if (ptype)\n  {\n    *ptype = 0;\n  }\n  if (pcount)\n  {\n    *pcount = 0;\n  }\n  if (psize)\n  {\n    *psize = 0;\n  }\n  return binn_is_valid_ex(ptr, ptype, pcount, psize);\n}\n\n",
        "translated_code": "pub fn binn_is_valid(\n    ptr: Option<*mut u8>,\n    mut ptype: Option<&mut i32>,\n    mut pcount: Option<&mut i32>,\n    mut psize: Option<&mut i32>,\n) -> bool {\n    // Set default values if the Option references are Some\n    if let Some(ref mut pt) = ptype {\n        **pt = 0;\n    }\n    if let Some(ref mut pc) = pcount {\n        **pc = 0;\n    }\n    if let Some(ref mut ps) = psize {\n        **ps = 0;\n    }\n\n    // Call the extended validation function\n    binn_is_valid_ex(ptr, ptype, pcount, psize)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_is_valid_ex"
        ],
        "header": "BOOL binn_is_valid(void *ptr, int *ptype, int *pcount, int *psize)",
        "params": [
            "void *ptr",
            "int *ptype",
            "int *pcount",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "ptype",
            "pcount",
            "psize"
        ],
        "calle": [
            "binn_is_valid_ex"
        ],
        "calle_c": [],
        "key": "binn_is_valid",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_int8": {
        "source_code": "signed char binn_list_int8(void *list, int pos)\n{\n  signed char value;\n  binn_list_get(list, pos, 0x21, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_list_int8(list: Option<&[u8]>, pos: i32) -> Option<i8> {\n    let mut value: i8 = 0;\n    let success = binn_list_get(\n        list,\n        pos,\n        0x21,\n        Some(&mut value as &mut dyn std::any::Any),\n        None,\n    );\n    \n    if success != 0 {\n        Some(value)\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "header": "signed char binn_list_int8(void *list, int pos)",
        "params": [
            "void *list",
            "int pos"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "value"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_int8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_int16": {
        "source_code": "short binn_list_int16(void *list, int pos)\n{\n  short value;\n  binn_list_get(list, pos, 0x41, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_list_int16(list: Option<&[u8]>, pos: i32) -> i16 {\n    let mut value: i16 = 0;\n    let pvalue: Option<&mut dyn std::any::Any> = Some(&mut value);\n    binn_list_get(list, pos, 0x41, pvalue, None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "header": "short binn_list_int16(void *list, int pos)",
        "params": [
            "void *list",
            "int pos"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "value"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_int16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_int32": {
        "source_code": "int binn_list_int32(void *list, int pos)\n{\n  int value;\n  binn_list_get(list, pos, 0x61, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_list_int32(list: Option<&[u8]>, pos: i32) -> i32 {\n    let mut value = 0;\n    binn_list_get(list, pos, 0x61, Some(&mut value), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "header": "int binn_list_int32(void *list, int pos)",
        "params": [
            "void *list",
            "int pos"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "value"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_int32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_uint8": {
        "source_code": "unsigned char binn_list_uint8(void *list, int pos)\n{\n  unsigned char value;\n  binn_list_get(list, pos, 0x20, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_list_uint8(list: Option<&[u8]>, pos: i32) -> Option<u8> {\n    let mut value: u8 = 0;\n    let success = binn_list_get(\n        list,\n        pos,\n        0x20,\n        Some(&mut value as &mut dyn std::any::Any),\n        None,\n    );\n    \n    if success != 0 {\n        Some(value)\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "header": "unsigned char binn_list_uint8(void *list, int pos)",
        "params": [
            "void *list",
            "int pos"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "value"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_uint8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_uint16": {
        "source_code": "unsigned short binn_list_uint16(void *list, int pos)\n{\n  unsigned short value;\n  binn_list_get(list, pos, 0x40, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_list_uint16(list: Option<&[u8]>, pos: i32) -> Option<u16> {\n    let mut value: u16 = 0;\n    let success = binn_list_get(\n        list,\n        pos,\n        0x40,\n        Some(&mut value as &mut dyn std::any::Any),\n        None,\n    );\n    \n    if success != 0 {\n        Some(value)\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "header": "unsigned short binn_list_uint16(void *list, int pos)",
        "params": [
            "void *list",
            "int pos"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "value"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_uint16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_uint32": {
        "source_code": "unsigned int binn_list_uint32(void *list, int pos)\n{\n  unsigned int value;\n  binn_list_get(list, pos, 0x60, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_list_uint32(list: Option<&[u8]>, pos: i32) -> u32 {\n    let mut value: u32 = 0;\n    binn_list_get(list, pos, 0x60, Some(&mut value), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "header": "unsigned int binn_list_uint32(void *list, int pos)",
        "params": [
            "void *list",
            "int pos"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "value"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_uint32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_float": {
        "source_code": "float binn_list_float(void *list, int pos)\n{\n  float value;\n  binn_list_get(list, pos, 0x62, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_list_float(list: Option<&[u8]>, pos: i32) -> f32 {\n    let mut value: f32 = 0.0;\n    binn_list_get(list, pos, 0x62, Some(&mut value), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "header": "float binn_list_float(void *list, int pos)",
        "params": [
            "void *list",
            "int pos"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "value"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_float",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_double": {
        "source_code": "double binn_list_double(void *list, int pos)\n{\n  double value;\n  binn_list_get(list, pos, 0x82, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_list_double(list: Option<&[u8]>, pos: i32) -> f64 {\n    let mut value: f64 = 0.0;\n    binn_list_get(list, pos, 0x82, Some(&mut value as &mut dyn std::any::Any), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "header": "double binn_list_double(void *list, int pos)",
        "params": [
            "void *list",
            "int pos"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "value"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_double",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_null": {
        "source_code": "BOOL binn_list_null(void *list, int pos)\n{\n  return binn_list_get(list, pos, 0x00, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_null(list: Option<&[u8]>, pos: i32) -> BOOL {\n    binn_list_get(list, pos, 0x00, None, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "header": "BOOL binn_list_null(void *list, int pos)",
        "params": [
            "void *list",
            "int pos"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_null",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_str": {
        "source_code": "char *binn_list_str(void *list, int pos)\n{\n  char *value;\n  binn_list_get(list, pos, 0xA0, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_list_str(list: Option<&[u8]>, pos: i32) -> Option<String> {\n    let mut value: Option<String> = None;\n    let success = binn_list_get(\n        list,\n        pos,\n        0xA0,\n        Some(&mut value as &mut dyn std::any::Any),\n        None,\n    );\n\n    if success != 0 {\n        value\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "header": "char *binn_list_str(void *list, int pos)",
        "params": [
            "void *list",
            "int pos"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "value"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_str",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_blob": {
        "source_code": "void *binn_list_blob(void *list, int pos, int *psize)\n{\n  void *value;\n  binn_list_get(list, pos, 0xC0, &value, psize);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_list_blob(\n    list: Option<&[u8]>,\n    pos: i32,\n    psize: Option<&mut i32>,\n) -> Option<Box<dyn std::any::Any>> {\n    let mut value: Option<Box<dyn std::any::Any>> = None;\n    let success = binn_list_get(\n        list,\n        pos,\n        0xC0,\n        Some(&mut value),\n        psize,\n    );\n    \n    if success != 0 {\n        value\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "header": "void *binn_list_blob(void *list, int pos, int *psize)",
        "params": [
            "void *list",
            "int pos",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "psize",
            "value"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_blob",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_list": {
        "source_code": "void *binn_list_list(void *list, int pos)\n{\n  void *value;\n  binn_list_get(list, pos, 0xE0, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_list_list(list: Option<&[u8]>, pos: i32) -> Option<Box<dyn std::any::Any>> {\n    let mut value: Option<Box<dyn std::any::Any>> = None;\n    let mut raw_value: Option<&mut dyn std::any::Any> = None;\n    let success = binn_list_get(\n        list,\n        pos,\n        0xE0,\n        Some(&mut raw_value),\n        None,\n    );\n    \n    if success != 0 {\n        raw_value.map(|v| Box::new(v) as Box<dyn std::any::Any>)\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "header": "void *binn_list_list(void *list, int pos)",
        "params": [
            "void *list",
            "int pos"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "value"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_list",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_map": {
        "source_code": "void *binn_list_map(void *list, int pos)\n{\n  void *value;\n  binn_list_get(list, pos, 0xE1, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_list_map(list: Option<&[u8]>, pos: i32) -> Option<Box<dyn std::any::Any>> {\n    let mut value: Option<Box<dyn std::any::Any>> = None;\n    let pvalue: Option<&mut dyn std::any::Any> = value.as_mut().map(|v| v.as_mut());\n    \n    let success = binn_list_get(list, pos, 0xE1, pvalue, None);\n    \n    if success != 0 {\n        value\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "header": "void *binn_list_map(void *list, int pos)",
        "params": [
            "void *list",
            "int pos"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "value"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_map",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_object": {
        "source_code": "void *binn_list_object(void *list, int pos)\n{\n  void *value;\n  binn_list_get(list, pos, 0xE2, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_list_object(list: Option<&[u8]>, pos: i32) -> Option<Box<dyn std::any::Any>> {\n    let mut value: Option<Box<dyn std::any::Any>> = None;\n    let success = binn_list_get(\n        list,\n        pos,\n        0xE2,\n        value.as_mut().map(|v| v as &mut dyn std::any::Any),\n        None,\n    );\n    \n    if success != 0 {\n        value\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get"
        ],
        "header": "void *binn_list_object(void *list, int pos)",
        "params": [
            "void *list",
            "int pos"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "value"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_object",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_int8": {
        "source_code": "signed char binn_map_int8(void *map, int id)\n{\n  signed char value;\n  binn_map_get(map, id, 0x21, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_map_int8(map: Option<&[u8]>, id: i32) -> Option<i8> {\n    let mut value: i8 = 0;\n    let success = binn_map_get(map, id, 0x21, Some(&mut value as &mut dyn std::any::Any), None);\n    \n    if success != 0 {\n        Some(value)\n    } else {\n        Option::None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "header": "signed char binn_map_int8(void *map, int id)",
        "params": [
            "void *map",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_int8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_int16": {
        "source_code": "short binn_map_int16(void *map, int id)\n{\n  short value;\n  binn_map_get(map, id, 0x41, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_map_int16(map: Option<&[u8]>, id: i32) -> i16 {\n    let mut value: i16 = 0;\n    let _ = binn_map_get(map, id, 0x41, Some(&mut value), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "header": "short binn_map_int16(void *map, int id)",
        "params": [
            "void *map",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_int16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_int32": {
        "source_code": "int binn_map_int32(void *map, int id)\n{\n  int value;\n  binn_map_get(map, id, 0x61, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_map_int32(map: Option<&[u8]>, id: i32) -> i32 {\n    let mut value: i32 = 0;\n    binn_map_get(map, id, 0x61, Some(&mut value), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "header": "int binn_map_int32(void *map, int id)",
        "params": [
            "void *map",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_int32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_uint8": {
        "source_code": "unsigned char binn_map_uint8(void *map, int id)\n{\n  unsigned char value;\n  binn_map_get(map, id, 0x20, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_map_uint8(map: Option<&[u8]>, id: i32) -> Option<u8> {\n    let mut value: u8 = 0;\n    let success = binn_map_get(map, id, 0x20, Some(&mut value), None);\n    \n    if success != 0 {\n        Some(value)\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "header": "unsigned char binn_map_uint8(void *map, int id)",
        "params": [
            "void *map",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_uint8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_uint16": {
        "source_code": "unsigned short binn_map_uint16(void *map, int id)\n{\n  unsigned short value;\n  binn_map_get(map, id, 0x40, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_map_uint16(map: Option<&[u8]>, id: i32) -> u16 {\n    let mut value: u16 = 0;\n    binn_map_get(map, id, 0x40, Some(&mut value), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "header": "unsigned short binn_map_uint16(void *map, int id)",
        "params": [
            "void *map",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_uint16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_uint32": {
        "source_code": "unsigned int binn_map_uint32(void *map, int id)\n{\n  unsigned int value;\n  binn_map_get(map, id, 0x60, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_map_uint32(map: Option<&[u8]>, id: i32) -> u32 {\n    let mut value: u32 = 0;\n    let _ = binn_map_get(map, id, 0x60, Some(&mut value), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "header": "unsigned int binn_map_uint32(void *map, int id)",
        "params": [
            "void *map",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_uint32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_float": {
        "source_code": "float binn_map_float(void *map, int id)\n{\n  float value;\n  binn_map_get(map, id, 0x62, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_map_float(map: Option<&[u8]>, id: i32) -> f32 {\n    let mut value: f32 = 0.0;\n    binn_map_get(map, id, 0x62, Some(&mut value), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "header": "float binn_map_float(void *map, int id)",
        "params": [
            "void *map",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_float",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_double": {
        "source_code": "double binn_map_double(void *map, int id)\n{\n  double value;\n  binn_map_get(map, id, 0x82, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_map_double(map: Option<&[u8]>, id: i32) -> f64 {\n    let mut value: f64 = 0.0;\n    binn_map_get(map, id, 0x82, Some(&mut value), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "header": "double binn_map_double(void *map, int id)",
        "params": [
            "void *map",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_double",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_null": {
        "source_code": "BOOL binn_map_null(void *map, int id)\n{\n  return binn_map_get(map, id, 0x00, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_null(map: Option<&[u8]>, id: i32) -> BOOL {\n    binn_map_get(map, id, 0x00, None, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "header": "BOOL binn_map_null(void *map, int id)",
        "params": [
            "void *map",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_null",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_str": {
        "source_code": "char *binn_map_str(void *map, int id)\n{\n  char *value;\n  binn_map_get(map, id, 0xA0, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_map_str(map: Option<&[u8]>, id: i32) -> Option<String> {\n    let mut value: Option<String> = None;\n    let pvalue: Option<&mut dyn std::any::Any> = Some(&mut value);\n    \n    let success = binn_map_get(map, id, 0xA0, pvalue, None);\n    \n    if success != 0 {\n        value\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "header": "char *binn_map_str(void *map, int id)",
        "params": [
            "void *map",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_str",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_blob": {
        "source_code": "void *binn_map_blob(void *map, int id, int *psize)\n{\n  void *value;\n  binn_map_get(map, id, 0xC0, &value, psize);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_map_blob(\n    map: Option<&[u8]>,\n    id: i32,\n    psize: Option<&mut i32>,\n) -> Option<Box<dyn std::any::Any>> {\n    let mut value: Option<Box<dyn std::any::Any>> = None;\n    let success = binn_map_get(\n        map,\n        id,\n        0xC0,\n        Some(&mut value),\n        psize,\n    );\n    \n    if success != 0 {\n        value\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "header": "void *binn_map_blob(void *map, int id, int *psize)",
        "params": [
            "void *map",
            "int id",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "psize",
            "value"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_blob",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_list": {
        "source_code": "void *binn_map_list(void *map, int id)\n{\n  void *value;\n  binn_map_get(map, id, 0xE0, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_map_list(map: Option<&[u8]>, id: i32) -> Option<Box<dyn std::any::Any>> {\n    let mut value: Option<Box<dyn std::any::Any>> = None;\n    let pvalue: Option<&mut dyn std::any::Any> = value.as_mut().map(|v| v.as_mut());\n    binn_map_get(map, id, 0xE0, pvalue, None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "header": "void *binn_map_list(void *map, int id)",
        "params": [
            "void *map",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_list",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_map": {
        "source_code": "void *binn_map_map(void *map, int id)\n{\n  void *value;\n  binn_map_get(map, id, 0xE1, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_map_map(map: Option<&[u8]>, id: i32) -> Option<Box<dyn std::any::Any>> {\n    let mut value: Option<Box<dyn std::any::Any>> = None;\n    let pvalue: Option<&mut dyn std::any::Any> = value.as_mut().map(|v| v.as_mut() as _);\n    let success = binn_map_get(map, id, 0xE1, pvalue, None);\n    \n    if success != 0 {\n        value\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "header": "void *binn_map_map(void *map, int id)",
        "params": [
            "void *map",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_map",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_object": {
        "source_code": "void *binn_map_object(void *map, int id)\n{\n  void *value;\n  binn_map_get(map, id, 0xE2, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_map_object(map: Option<&[u8]>, id: i32) -> Option<Box<dyn std::any::Any>> {\n    let mut value: Option<Box<dyn std::any::Any>> = None;\n    let success = binn_map_get(\n        map,\n        id,\n        0xE2,\n        value.as_mut().map(|v| v.as_mut() as &mut dyn std::any::Any),\n        None,\n    );\n    \n    if success != 0 {\n        value\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get"
        ],
        "header": "void *binn_map_object(void *map, int id)",
        "params": [
            "void *map",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_object",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_int8": {
        "source_code": "signed char binn_object_int8(void *obj, const char *key)\n{\n  signed char value;\n  binn_object_get(obj, key, 0x21, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_int8(obj: Option<&[u8]>, key: Option<&str>) -> Option<i8> {\n    let mut value: i8 = 0;\n    let result = binn_object_get(\n        obj,\n        key,\n        0x21,\n        Some(&mut value as &mut dyn std::any::Any),\n        None,\n    );\n    \n    if result == 0 {\n        Some(value)\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "header": "signed char binn_object_int8(void *obj, const char *key)",
        "params": [
            "void *obj",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_int8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_int16": {
        "source_code": "short binn_object_int16(void *obj, const char *key)\n{\n  short value;\n  binn_object_get(obj, key, 0x41, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_int16(obj: Option<&[u8]>, key: Option<&str>) -> i16 {\n    let mut value: i16 = 0;\n    binn_object_get(obj, key, 0x41, Some(&mut value as &mut dyn std::any::Any), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "header": "short binn_object_int16(void *obj, const char *key)",
        "params": [
            "void *obj",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_int16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_int32": {
        "source_code": "int binn_object_int32(void *obj, const char *key)\n{\n  int value;\n  binn_object_get(obj, key, 0x61, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_int32(obj: Option<&[u8]>, key: Option<&str>) -> i32 {\n    let mut value = 0;\n    binn_object_get(obj, key, 0x61, Some(&mut value as &mut dyn std::any::Any), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "header": "int binn_object_int32(void *obj, const char *key)",
        "params": [
            "void *obj",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_int32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_uint8": {
        "source_code": "unsigned char binn_object_uint8(void *obj, const char *key)\n{\n  unsigned char value;\n  binn_object_get(obj, key, 0x20, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_uint8(obj: Option<&[u8]>, key: Option<&str>) -> u8 {\n    let mut value: u8 = 0;\n    binn_object_get(obj, key, 0x20, Some(&mut value as &mut dyn std::any::Any), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "header": "unsigned char binn_object_uint8(void *obj, const char *key)",
        "params": [
            "void *obj",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_uint8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_uint16": {
        "source_code": "unsigned short binn_object_uint16(void *obj, const char *key)\n{\n  unsigned short value;\n  binn_object_get(obj, key, 0x40, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_uint16(obj: Option<&[u8]>, key: Option<&str>) -> u16 {\n    let mut value: u16 = 0;\n    binn_object_get(obj, key, 0x40, Some(&mut value), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "header": "unsigned short binn_object_uint16(void *obj, const char *key)",
        "params": [
            "void *obj",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_uint16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_uint32": {
        "source_code": "unsigned int binn_object_uint32(void *obj, const char *key)\n{\n  unsigned int value;\n  binn_object_get(obj, key, 0x60, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_uint32(obj: Option<&[u8]>, key: Option<&str>) -> u32 {\n    let mut value: u32 = 0;\n    binn_object_get(obj, key, 0x60, Some(&mut value as &mut dyn std::any::Any), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "header": "unsigned int binn_object_uint32(void *obj, const char *key)",
        "params": [
            "void *obj",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_uint32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_float": {
        "source_code": "float binn_object_float(void *obj, const char *key)\n{\n  float value;\n  binn_object_get(obj, key, 0x62, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_float(obj: Option<&[u8]>, key: Option<&str>) -> f32 {\n    let mut value: f32 = 0.0;\n    binn_object_get(obj, key, 0x62, Some(&mut value), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "header": "float binn_object_float(void *obj, const char *key)",
        "params": [
            "void *obj",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_float",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_double": {
        "source_code": "double binn_object_double(void *obj, const char *key)\n{\n  double value;\n  binn_object_get(obj, key, 0x82, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_double(obj: Option<&[u8]>, key: Option<&str>) -> f64 {\n    let mut value: f64 = 0.0;\n    binn_object_get(obj, key, 0x82, Some(&mut value as &mut dyn std::any::Any), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "header": "double binn_object_double(void *obj, const char *key)",
        "params": [
            "void *obj",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_double",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_null": {
        "source_code": "BOOL binn_object_null(void *obj, const char *key)\n{\n  return binn_object_get(obj, key, 0x00, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_null(obj: Option<&[u8]>, key: Option<&str>) -> bool {\n    binn_object_get(obj, key, 0x00, None, None) != 0\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "header": "BOOL binn_object_null(void *obj, const char *key)",
        "params": [
            "void *obj",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_null",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_str": {
        "source_code": "char *binn_object_str(void *obj, const char *key)\n{\n  char *value;\n  binn_object_get(obj, key, 0xA0, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_str(obj: Option<&[u8]>, key: Option<&str>) -> Option<String> {\n    let mut value: Option<String> = None;\n    let pvalue: Option<&mut dyn std::any::Any> = Some(&mut value);\n    \n    let result = binn_object_get(obj, key, 0xA0, pvalue, None);\n    \n    if result == 0 {\n        value\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "header": "char *binn_object_str(void *obj, const char *key)",
        "params": [
            "void *obj",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_str",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_blob": {
        "source_code": "void *binn_object_blob(void *obj, const char *key, int *psize)\n{\n  void *value;\n  binn_object_get(obj, key, 0xC0, &value, psize);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_blob(\n    obj: Option<&[u8]>,\n    key: Option<&str>,\n    psize: Option<&mut i32>,\n) -> Option<Box<dyn Any>> {\n    let mut value: Option<Box<dyn Any>> = None;\n    let mut any_value: Option<&mut dyn Any> = None;\n    \n    if let Some(ref mut boxed) = value {\n        any_value = Some(boxed.as_mut());\n    }\n    \n    // Call binn_object_get with the appropriate parameters\n    binn_object_get(obj, key, 0xC0, any_value, psize);\n    \n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "header": "void *binn_object_blob(void *obj, const char *key, int *psize)",
        "params": [
            "void *obj",
            "const char *key",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "psize",
            "value"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_blob",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_list": {
        "source_code": "void *binn_object_list(void *obj, const char *key)\n{\n  void *value;\n  binn_object_get(obj, key, 0xE0, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_list(obj: Option<&[u8]>, key: Option<&str>) -> Option<Box<dyn Any>> {\n    let mut value: Option<Box<dyn Any>> = None;\n    let pvalue: Option<&mut dyn Any> = value.as_mut().map(|v| v.as_mut());\n    \n    binn_object_get(obj, key, 0xE0, pvalue, None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "header": "void *binn_object_list(void *obj, const char *key)",
        "params": [
            "void *obj",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_list",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_map": {
        "source_code": "void *binn_object_map(void *obj, const char *key)\n{\n  void *value;\n  binn_object_get(obj, key, 0xE1, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_map(obj: Option<&[u8]>, key: Option<&str>) -> Option<Box<dyn Any>> {\n    let mut value: Option<Box<dyn Any>> = None;\n    let pvalue: Option<&mut dyn Any> = value.as_mut().map(|v| v.as_mut());\n    \n    // Call binn_object_get with the appropriate parameters\n    binn_object_get(obj, key, 0xE1, pvalue, None);\n    \n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "header": "void *binn_object_map(void *obj, const char *key)",
        "params": [
            "void *obj",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_map",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_object": {
        "source_code": "void *binn_object_object(void *obj, const char *key)\n{\n  void *value;\n  binn_object_get(obj, key, 0xE2, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_object(obj: Option<&[u8]>, key: Option<&str>) -> Option<Box<dyn Any>> {\n    let mut value: Option<Box<dyn Any>> = None;\n    let pvalue: Option<&mut dyn Any> = value.as_mut().map(|v| v.as_mut());\n    \n    let result = binn_object_get(obj, key, 0xE2, pvalue, None);\n    \n    if result == 0 {\n        value\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get"
        ],
        "header": "void *binn_object_object(void *obj, const char *key)",
        "params": [
            "void *obj",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_object",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "check_alloc_functions": {
        "source_code": "static void check_alloc_functions()\n{\n  if (malloc_fn == 0)\n  {\n    malloc_fn = &malloc;\n  }\n  if (realloc_fn == 0)\n  {\n    realloc_fn = &realloc;\n  }\n  if (free_fn == 0)\n  {\n    free_fn = &free;\n  }\n}\n\n",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::Mutex;\n\npub fn check_alloc_functions() {\n    {\n        let mut malloc_fn = MALLOC_FN.lock().unwrap();\n        if malloc_fn.is_none() {\n            *malloc_fn = Some(malloc);\n        }\n    }\n    \n    {\n        let mut realloc_fn = REALLOC_FN.lock().unwrap();\n        if realloc_fn.is_none() {\n            *realloc_fn = Some(ReallocFnWrapper(Box::new(realloc)));\n        }\n    }\n    \n    {\n        let mut free_fn = FREE_FN.lock().unwrap();\n        if free_fn.is_none() {\n            *free_fn = Some(FreeFnWrapper(Box::new(free)));\n        }\n    }\n}\n\n// Placeholder functions - these would need to be implemented\nfn malloc(size: usize) -> Option<Box<dyn std::any::Any>> {\n    // Implementation would go here\n    None\n}\n\nfn realloc(ptr: Option<Box<[u8]>>, new_size: usize) -> Option<Box<[u8]>> {\n    // Implementation would go here\n    None\n}\n\nfn free(_ptr: Option<Box<dyn std::any::Any + Send>>) {\n    // Implementation would go here\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "free_fn",
            "malloc_fn",
            "realloc_fn"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "malloc_fn",
            "realloc_fn",
            "free_fn"
        ],
        "calle": [],
        "calle_c": [],
        "key": "check_alloc_functions",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_malloc": {
        "source_code": "static void *binn_malloc(int size)\n{\n  check_alloc_functions();\n  return malloc_fn(size);\n}\n\n",
        "translated_code": "pub fn binn_malloc(size: i32) -> Option<Box<dyn std::any::Any>> {\n    check_alloc_functions();\n    let malloc_fn = MALLOC_FN.lock().unwrap();\n    match *malloc_fn {\n        Some(f) => f(size as usize),\n        None => None,\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "check_alloc_functions",
            "malloc_fn"
        ],
        "params": [
            "int size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "size",
            "malloc_fn"
        ],
        "calle": [
            "check_alloc_functions",
            "malloc_fn"
        ],
        "calle_c": [
            "malloc_fn"
        ],
        "key": "binn_malloc",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_memdup": {
        "source_code": "static void *binn_memdup(void *src, int size)\n{\n  void *dest;\n  unsigned int dest_idx = 0;\n  if ((src == 0) || (size <= 0))\n  {\n    return 0;\n  }\n  dest_idx = binn_malloc(size);\n  if ((&dest[dest_idx]) == 0)\n  {\n    return 0;\n  }\n  memcpy(dest, src, size);\n  return dest;\n}\n\n",
        "translated_code": "pub fn binn_memdup(src: Option<&[u8]>, size: i32) -> Option<Box<[u8]>> {\n    // Check for NULL pointer or invalid size\n    if src.is_none() || size <= 0 {\n        return Option::None;\n    }\n\n    let src = src.unwrap();\n    \n    // Allocate memory using binn_malloc\n    let dest = match binn_malloc(size) {\n        Some(alloc) => alloc,\n        None => return Option::None,\n    };\n\n    // Try to downcast to a boxed byte slice\n    if let Ok(mut dest_box) = dest.downcast::<Box<[u8]>>() {\n        let dest_slice = &mut *dest_box;\n        \n        // Ensure the allocated size matches the requested size\n        if dest_slice.len() != size as usize {\n            return Option::None;\n        }\n\n        // Safe because we've checked sizes and have exclusive access\n        dest_slice.copy_from_slice(&src[..size as usize]);\n        Some(*dest_box)\n    } else {\n        Option::None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_malloc"
        ],
        "params": [
            "void *src",
            "int size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "src",
            "size",
            "dest",
            "dest_idx"
        ],
        "calle": [
            "binn_malloc",
            "memcpy"
        ],
        "calle_c": [
            "memcpy"
        ],
        "key": "binn_memdup",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_buf_type": {
        "source_code": "static int binn_buf_type(void *pbuf)\n{\n  int type;\n  if (!IsValidBinnHeader(pbuf, &type, 0, 0, 0))\n  {\n    return 0;\n  }\n  return type;\n}\n\n",
        "translated_code": "pub fn binn_buf_type(pbuf: Option<&[u8]>) -> i32 {\n    let mut type_ = 0; // Using type_ to avoid Rust keyword conflict\n    if !IsValidBinnHeader(pbuf, Some(&mut type_), None, None, None) {\n        return 0;\n    }\n    type_\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "IsValidBinnHeader"
        ],
        "params": [
            "void *pbuf"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "pbuf",
            "type"
        ],
        "calle": [
            "IsValidBinnHeader"
        ],
        "calle_c": [],
        "key": "binn_buf_type",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_buf_count": {
        "source_code": "static int binn_buf_count(void *pbuf)\n{\n  int nitems;\n  if (!IsValidBinnHeader(pbuf, 0, &nitems, 0, 0))\n  {\n    return 0;\n  }\n  return nitems;\n}\n\n",
        "translated_code": "pub fn binn_buf_count(pbuf: Option<&[u8]>) -> i32 {\n    let mut nitems = 0;\n    if !IsValidBinnHeader(pbuf, None, Some(&mut nitems), None, None) {\n        return 0;\n    }\n    nitems\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "IsValidBinnHeader"
        ],
        "params": [
            "void *pbuf"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "pbuf",
            "nitems"
        ],
        "calle": [
            "IsValidBinnHeader"
        ],
        "calle_c": [],
        "key": "binn_buf_count",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_buf_size": {
        "source_code": "static int binn_buf_size(void *pbuf)\n{\n  int size = 0;\n  if (!IsValidBinnHeader(pbuf, 0, 0, &size, 0))\n  {\n    return 0;\n  }\n  return size;\n}\n\n",
        "translated_code": "pub fn binn_buf_size(pbuf: Option<&[u8]>) -> i32 {\n    let mut size = 0;\n    if !IsValidBinnHeader(pbuf, None, None, Some(&mut size), None) {\n        return 0;\n    }\n    size\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "IsValidBinnHeader"
        ],
        "params": [
            "void *pbuf"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "pbuf",
            "size"
        ],
        "calle": [
            "IsValidBinnHeader"
        ],
        "calle_c": [],
        "key": "binn_buf_size",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "is_integer": {
        "source_code": "static BOOL is_integer(char *p)\n{\n  unsigned int p_idx = 0;\n  BOOL retval;\n  if ((&p[p_idx]) == 0)\n  {\n    return 0;\n  }\n  if (p[p_idx] == '-')\n  {\n    p_idx += 1;\n  }\n  if (p[p_idx] == 0)\n  {\n    return 0;\n  }\n  retval = 1;\n  for (; p[p_idx]; p_idx += 1)\n  {\n    if ((p[p_idx] < '0') || (p[p_idx] > '9'))\n    {\n      retval = 0;\n    }\n  }\n\n  return retval;\n}\n\n",
        "translated_code": "pub fn is_integer(p: Option<&str>) -> BOOL {\n    // Check for NULL (None in Rust)\n    let p = match p {\n        Some(s) => s,\n        None => return 0,\n    };\n\n    let mut p_idx = 0;\n    let mut retval: BOOL;\n\n    // Check for empty string\n    if p.is_empty() {\n        return 0;\n    }\n\n    // Handle negative sign\n    let chars: Vec<char> = p.chars().collect();\n    if chars[p_idx] == '-' {\n        p_idx += 1;\n        // Check if string ends after '-'\n        if p_idx >= chars.len() {\n            return 0;\n        }\n    }\n\n    retval = 1;\n    // Check remaining characters are digits\n    for i in p_idx..chars.len() {\n        if !chars[i].is_ascii_digit() {\n            retval = 0;\n        }\n    }\n\n    retval\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "BOOL"
        ],
        "params": [
            "char *p"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "p",
            "p_idx",
            "retval"
        ],
        "calle": [],
        "calle_c": [],
        "key": "is_integer",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "is_float": {
        "source_code": "static BOOL is_float(char *p)\n{\n  unsigned int p_idx = 0;\n  BOOL retval;\n  BOOL number_found = 0;\n  if ((&p[p_idx]) == 0)\n  {\n    return 0;\n  }\n  if (p[p_idx] == '-')\n  {\n    p_idx += 1;\n  }\n  if (p[p_idx] == 0)\n  {\n    return 0;\n  }\n  retval = 1;\n  for (; p[p_idx]; p_idx += 1)\n  {\n    if ((p[p_idx] == '.') || (p[p_idx] == ','))\n    {\n      if (!number_found)\n      {\n        retval = 0;\n      }\n    }\n    else\n      if ((p[p_idx] >= '0') && (p[p_idx] <= '9'))\n    {\n      number_found = 1;\n    }\n    else\n    {\n      return 0;\n    }\n  }\n\n  return retval;\n}\n\n",
        "translated_code": "pub fn is_float(p: Option<&str>) -> BOOL {\n    // Check for NULL (None in Rust)\n    let p = match p {\n        Some(s) => s,\n        None => return 0,\n    };\n\n    let mut p_idx = 0;\n    let mut retval;\n    let mut number_found = 0;\n\n    // Convert string to bytes for character-by-character access\n    let bytes = p.as_bytes();\n\n    // Check empty string\n    if bytes.is_empty() {\n        return 0;\n    }\n\n    // Handle optional minus sign\n    if bytes[p_idx] == b'-' {\n        p_idx += 1;\n        // Check if string ends after minus\n        if p_idx >= bytes.len() {\n            return 0;\n        }\n    }\n\n    retval = 1;\n\n    // Iterate through remaining characters\n    while p_idx < bytes.len() {\n        let c = bytes[p_idx];\n        \n        if c == b'.' || c == b',' {\n            if number_found == 0 {\n                retval = 0;\n            }\n        } else if c >= b'0' && c <= b'9' {\n            number_found = 1;\n        } else {\n            return 0;\n        }\n\n        p_idx += 1;\n    }\n\n    retval\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "BOOL"
        ],
        "params": [
            "char *p"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "p",
            "p_idx",
            "retval",
            "number_found"
        ],
        "calle": [],
        "calle_c": [],
        "key": "is_float",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_alloc_item": {
        "source_code": "static binn *binn_alloc_item()\n{\n  binn *item;\n  unsigned int item_idx = 0;\n  item_idx = (binn *) binn_malloc(sizeof(binn));\n  if (item)\n  {\n    memset(item, 0, sizeof(binn));\n    item->header = 0x1F22B11F;\n    item->allocated = 1;\n  }\n  return item;\n}\n\n",
        "translated_code": "pub fn binn_alloc_item() -> Option<Box<BinnStruct>> {\n    // Allocate memory for the binn struct\n    let item = binn_malloc(std::mem::size_of::<BinnStruct>() as i32);\n    \n    // Convert the allocation to BinnStruct if successful\n    let item = match item {\n        Some(ptr) => {\n            // SAFETY: We know ptr is a valid Box<BinnStruct> because binn_malloc allocated enough space\n            let item = unsafe { Box::from_raw(Box::into_raw(ptr) as *mut BinnStruct) };\n            \n            // Initialize the struct (equivalent to memset + field assignments)\n            let mut item = Box::new(BinnStruct {\n                header: 0x1F22B11F,\n                allocated: 1,\n                writable: 0,\n                dirty: 0,\n                pbuf: None,\n                pre_allocated: 0,\n                alloc_size: 0,\n                used_size: 0,\n                type_: 0,\n                ptr: None,\n                size: 0,\n                count: 0,\n                freefn: None,\n                value: BinnValue {\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: 0,\n                },\n                disable_int_compression: 0,\n            });\n            \n            Some(item)\n        },\n        None => None,\n    };\n    \n    item\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_malloc"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "item",
            "item_idx"
        ],
        "calle": [
            "binn_malloc",
            "memset"
        ],
        "calle_c": [
            "memset"
        ],
        "key": "binn_alloc_item",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_value": {
        "source_code": "binn *binn_value(int type, void *pvalue, int size, binn_mem_free freefn)\n{\n  int storage_type;\n  binn *item = binn_alloc_item();\n  if (item)\n  {\n    item->type = type;\n    binn_get_type_info(type, &storage_type, 0);\n    switch (storage_type)\n    {\n      case 0x00:\n        break;\n\n      case 0xA0:\n        if (size == 0)\n      {\n        size = strlen((char *) pvalue) + 1;\n      }\n\n      case 0xC0:\n\n      case 0xE0:\n        if (freefn == ((binn_mem_free) (-1)))\n      {\n        item->ptr = binn_memdup(pvalue, size);\n        if (item->ptr == 0)\n        {\n          free_fn(item);\n          return 0;\n        }\n        item->freefn = free_fn;\n        if (storage_type == 0xA0)\n        {\n          size -= 1;\n        }\n      }\n      else\n      {\n        item->ptr = pvalue;\n        item->freefn = freefn;\n      }\n        item->size = size;\n        break;\n\n      default:\n        item->ptr = &item->vint32;\n        copy_raw_value(pvalue, item->ptr, storage_type);\n\n    }\n\n  }\n  return item;\n}\n\n",
        "translated_code": "pub fn binn_value(\n    type_: i32,\n    pvalue: Option<&[u8]>,\n    size: i32,\n    freefn: Option<Box<dyn FnMut(Option<Box<()>>)>>,\n) -> Option<Box<BinnStruct>> {\n    let mut storage_type = 0;\n    let mut item = binn_alloc_item()?;\n\n    {\n        item.type_ = type_;\n        binn_get_type_info(type_, Some(&mut storage_type), None);\n    }\n\n    match storage_type {\n        0x00 => (),\n\n        0xA0 | 0xC0 | 0xE0 => {\n            let mut size = size;\n            let pvalue = pvalue?;\n\n            if storage_type == 0xA0 && size == 0 {\n                let c_str = unsafe { CStr::from_ptr(pvalue.as_ptr() as *const i8) };\n                size = c_str.to_bytes().len() as i32 + 1;\n            }\n\n            if freefn.is_none() {\n                let dup = binn_memdup(Some(pvalue), size)?;\n                let holder = Box::new(dup);\n                let raw_ptr = Box::into_raw(holder) as *mut ();\n                item.ptr = Some(unsafe { Box::from_raw(raw_ptr) });\n                item.freefn = Some(Box::new(move |ptr: Option<Box<()>>| {\n                    if let Some(ptr) = ptr {\n                        let raw_ptr = Box::into_raw(ptr) as *mut Box<[u8]>;\n                        unsafe { Box::from_raw(raw_ptr); }\n                    }\n                }));\n                \n                if storage_type == 0xA0 {\n                    size -= 1;\n                }\n            } else {\n                let vec = pvalue.to_vec();\n                let holder = Box::new(vec);\n                let raw_ptr = Box::into_raw(holder) as *mut ();\n                item.ptr = Some(unsafe { Box::from_raw(raw_ptr) });\n                item.freefn = freefn;\n            }\n            item.size = size;\n        }\n\n        _ => {\n            item.ptr = None;\n            let source_slice = unsafe {\n                std::slice::from_raw_parts(pvalue?.as_ptr() as *const u8, pvalue?.len())\n            };\n            let dest_slice = unsafe {\n                std::slice::from_raw_parts_mut(\n                    &mut item.value.vint32 as *mut i32 as *mut u8,\n                    std::mem::size_of::<i32>(),\n                )\n            };\n            copy_raw_value(\n                Some(&mut source_slice.to_owned()),\n                Some(&mut dest_slice.to_owned()),\n                storage_type,\n            );\n        }\n    }\n\n    Some(item)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_alloc_item",
            "binn_get_type_info",
            "binn_mem_free",
            "binn_memdup",
            "copy_raw_value",
            "free_fn"
        ],
        "header": "binn *binn_value(int type, void *pvalue, int size, binn_mem_free freefn)",
        "params": [
            "int type",
            "void *pvalue",
            "int size",
            "binn_mem_free freefn"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "type",
            "pvalue",
            "size",
            "freefn",
            "storage_type",
            "item",
            "free_fn"
        ],
        "calle": [
            "free_fn",
            "binn_memdup",
            "binn_get_type_info",
            "copy_raw_value",
            "binn_alloc_item",
            "strlen"
        ],
        "calle_c": [
            "free_fn",
            "strlen"
        ],
        "key": "binn_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_int8": {
        "source_code": "inline static binn *binn_int8(signed char value)\n{\n  return binn_value(0x21, &value, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_int8(value: i8) -> Option<Box<BinnStruct>> {\n    binn_value(0x21, Some(&[value as u8]), 0, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_value"
        ],
        "params": [
            "signed char value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value"
        ],
        "calle": [
            "binn_value"
        ],
        "calle_c": [],
        "key": "binn_int8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_int16": {
        "source_code": "inline static binn *binn_int16(short value)\n{\n  return binn_value(0x41, &value, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_int16(value: i16) -> Option<Box<BinnStruct>> {\n    binn_value(0x41, Some(&value.to_ne_bytes()), 0, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_value"
        ],
        "params": [
            "short value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value"
        ],
        "calle": [
            "binn_value"
        ],
        "calle_c": [],
        "key": "binn_int16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_int32": {
        "source_code": "inline static binn *binn_int32(int value)\n{\n  return binn_value(0x61, &value, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_int32(value: i32) -> Option<Box<BinnStruct>> {\n    binn_value(0x61, Some(&value.to_ne_bytes()), 0, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_value"
        ],
        "params": [
            "int value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value"
        ],
        "calle": [
            "binn_value"
        ],
        "calle_c": [],
        "key": "binn_int32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_uint8": {
        "source_code": "inline static binn *binn_uint8(unsigned char value)\n{\n  return binn_value(0x20, &value, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_uint8(value: u8) -> Option<Box<BinnStruct>> {\n    binn_value(0x20, Some(&[value]), 0, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_value"
        ],
        "params": [
            "unsigned char value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value"
        ],
        "calle": [
            "binn_value"
        ],
        "calle_c": [],
        "key": "binn_uint8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_uint16": {
        "source_code": "inline static binn *binn_uint16(unsigned short value)\n{\n  return binn_value(0x40, &value, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_uint16(value: u16) -> Option<Box<BinnStruct>> {\n    let value_bytes = value.to_le_bytes();\n    binn_value(0x40, Some(&value_bytes), 0, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_value"
        ],
        "params": [
            "unsigned short value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value"
        ],
        "calle": [
            "binn_value"
        ],
        "calle_c": [],
        "key": "binn_uint16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_uint32": {
        "source_code": "inline static binn *binn_uint32(unsigned int value)\n{\n  return binn_value(0x60, &value, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_uint32(value: u32) -> Option<Box<BinnStruct>> {\n    binn_value(0x60, Some(&value.to_ne_bytes()), 0, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_value"
        ],
        "params": [
            "unsigned int value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value"
        ],
        "calle": [
            "binn_value"
        ],
        "calle_c": [],
        "key": "binn_uint32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_float": {
        "source_code": "inline static binn *binn_float(float value)\n{\n  return binn_value(0x62, &value, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_float(value: f32) -> Option<Box<BinnStruct>> {\n    // Convert the float to bytes for safe handling\n    let bytes = value.to_ne_bytes();\n    binn_value(0x62, Some(&bytes), 0, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_value"
        ],
        "params": [
            "float value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value"
        ],
        "calle": [
            "binn_value"
        ],
        "calle_c": [],
        "key": "binn_float",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_double": {
        "source_code": "inline static binn *binn_double(double value)\n{\n  return binn_value(0x82, &value, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_double(value: f64) -> Option<Box<BinnStruct>> {\n    // Convert the f64 to bytes to pass to binn_value\n    let bytes = value.to_ne_bytes();\n    binn_value(0x82, Some(&bytes), 0, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_value"
        ],
        "params": [
            "double value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value"
        ],
        "calle": [
            "binn_value"
        ],
        "calle_c": [],
        "key": "binn_double",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_null": {
        "source_code": "inline static binn *binn_null()\n{\n  return binn_value(0x00, 0, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_null() -> Option<Box<BinnStruct>> {\n    binn_value(0x00, None, 0, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_value"
        ],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [
            "binn_value"
        ],
        "calle_c": [],
        "key": "binn_null",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "compress_int": {
        "source_code": "static void *compress_int(int *pstorage_type, int *ptype, void *psource)\n{\n  int storage_type;\n  int storage_type2;\n  int type;\n  int type2 = 0;\n  int64 vint = 0;\n  uint64 vuint;\n  char *pvalue;\n  unsigned int pvalue_idx = 0;\n  storage_type = *pstorage_type;\n  if (storage_type == 0x20)\n  {\n    return psource;\n  }\n  type = *ptype;\n  switch (type)\n  {\n    case 0x81:\n      vint = *((int64 *) psource);\n      goto loc_signed;\n\n    case 0x61:\n      vint = *((int *) psource);\n      goto loc_signed;\n\n    case 0x41:\n      vint = *((short *) psource);\n      goto loc_signed;\n\n    case 0x80:\n      vuint = *((uint64 *) psource);\n      goto loc_positive;\n\n    case 0x60:\n      vuint = *((unsigned int *) psource);\n      goto loc_positive;\n\n    case 0x40:\n      vuint = *((unsigned short *) psource);\n      goto loc_positive;\n\n  }\n\n  loc_signed:\n  if (vint >= 0)\n  {\n    vuint = vint;\n    goto loc_positive;\n  }\n\n  if (vint >= INT8_MIN)\n  {\n    type2 = 0x21;\n  }\n  else\n    if (vint >= INT16_MIN)\n  {\n    type2 = 0x41;\n  }\n  else\n    if (vint >= INT32_MIN)\n  {\n    type2 = 0x61;\n  }\n  goto loc_exit;\n  loc_positive:\n  if (vuint <= UINT8_MAX)\n  {\n    type2 = 0x20;\n  }\n  else\n    if (vuint <= UINT16_MAX)\n  {\n    type2 = 0x40;\n  }\n  else\n    if (vuint <= UINT32_MAX)\n  {\n    type2 = 0x60;\n  }\n\n  loc_exit:\n  pvalue_idx = (char *) psource;\n\n  if (type2 && (type2 != type))\n  {\n    *ptype = type2;\n    storage_type2 = binn_get_write_storage(type2);\n    *pstorage_type = storage_type2;\n  }\n  return pvalue;\n}\n\n",
        "translated_code": "pub fn compress_int<'a>(\n    pstorage_type: &mut i32,\n    ptype: &mut i32,\n    psource: &'a [u8],\n) -> Option<&'a [u8]> {\n    let storage_type = *pstorage_type;\n    if storage_type == 0x20 {\n        return Some(psource);\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n\n    match type_ {\n        0x81 => {\n            vint = i64::from_le_bytes(psource[..8].try_into().unwrap());\n            // fall through to loc_signed\n        }\n        0x61 => {\n            vint = i32::from_le_bytes(psource[..4].try_into().unwrap()) as i64;\n            // fall through to loc_signed\n        }\n        0x41 => {\n            vint = i16::from_le_bytes(psource[..2].try_into().unwrap()) as i64;\n            // fall through to loc_signed\n        }\n        0x80 => {\n            vuint = u64::from_le_bytes(psource[..8].try_into().unwrap());\n            // fall through to loc_positive\n        }\n        0x60 => {\n            vuint = u32::from_le_bytes(psource[..4].try_into().unwrap()) as u64;\n            // fall through to loc_positive\n        }\n        0x40 => {\n            vuint = u16::from_le_bytes(psource[..2].try_into().unwrap()) as u64;\n            // fall through to loc_positive\n        }\n        _ => return None,\n    }\n\n    // loc_signed:\n    if type_ == 0x81 || type_ == 0x61 || type_ == 0x41 {\n        if vint >= 0 {\n            vuint = vint as u64;\n            // fall through to loc_positive\n        } else {\n            if vint >= i8::MIN as i64 {\n                type2 = 0x21;\n            } else if vint >= i16::MIN as i64 {\n                type2 = 0x41;\n            } else if vint >= i32::MIN as i64 {\n                type2 = 0x61;\n            }\n            // goto loc_exit\n            return handle_type_change(pstorage_type, ptype, type2, type_, psource);\n        }\n    }\n\n    // loc_positive:\n    if vuint <= u8::MAX as u64 {\n        type2 = 0x20;\n    } else if vuint <= u16::MAX as u64 {\n        type2 = 0x40;\n    } else if vuint <= u32::MAX as u64 {\n        type2 = 0x60;\n    }\n\n    // loc_exit:\n    handle_type_change(pstorage_type, ptype, type2, type_, psource)\n}\n\nfn handle_type_change<'a>(\n    pstorage_type: &mut i32,\n    ptype: &mut i32,\n    type2: i32,\n    original_type: i32,\n    psource: &'a [u8],\n) -> Option<&'a [u8]> {\n    if type2 != 0 && type2 != original_type {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n    Some(psource)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_get_write_storage",
            "int64",
            "uint64"
        ],
        "params": [
            "int *pstorage_type",
            "int *ptype",
            "void *psource"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "pstorage_type",
            "ptype",
            "psource",
            "storage_type",
            "storage_type2",
            "type",
            "type2",
            "vint",
            "vuint",
            "pvalue",
            "pvalue_idx"
        ],
        "calle": [
            "binn_get_write_storage"
        ],
        "calle_c": [],
        "key": "compress_int",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "CheckAllocation": {
        "source_code": "static BOOL CheckAllocation(binn *item, int add_size)\n{\n  int alloc_size;\n  void *ptr;\n  unsigned int ptr_idx = 0;\n  if ((item->used_size + add_size) > item->alloc_size)\n  {\n    if (item->pre_allocated)\n    {\n      return 0;\n    }\n    alloc_size = CalcAllocation(item->used_size + add_size, item->alloc_size);\n    ptr_idx = realloc_fn(item->pbuf, alloc_size);\n    if ((&ptr[ptr_idx]) == 0)\n    {\n      return 0;\n    }\n    item->pbuf = &ptr[ptr_idx];\n    item->alloc_size = alloc_size;\n  }\n  return 1;\n}\n\n",
        "translated_code": "use std::sync::Mutex;\n\npub fn CheckAllocation(item: &mut Option<Box<BinnStruct>>, add_size: i32) -> BOOL {\n    // Early return if item is None\n    let item = match item {\n        Some(item) => item,\n        None => return 0,\n    };\n\n    if (item.used_size + add_size) > item.alloc_size {\n        if item.pre_allocated != 0 {\n            return 0;\n        }\n\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        \n        // Get the current pbuf as a byte slice if it exists\n        let current_buf = item.pbuf.as_ref().map(|b| {\n            let ptr = b.as_ref() as *const _ as *const u8;\n            unsafe { std::slice::from_raw_parts(ptr, item.used_size as usize) }\n        });\n\n        // Convert to Box<[u8]> for reallocation\n        let current_boxed_slice = current_buf.map(|slice| slice.to_vec().into_boxed_slice());\n\n        // Lock the global realloc function\n        let mut realloc_fn_guard = REALLOC_FN.lock().unwrap();\n        let realloc_fn = match realloc_fn_guard.as_mut() {\n            Some(f) => &mut f.0,\n            None => return 0,\n        };\n\n        // Perform reallocation\n        let new_buf = realloc_fn(current_boxed_slice, alloc_size as usize);\n\n        match new_buf {\n            Some(new_buf) => {\n                // Update the item's fields\n                item.pbuf = Some(Box::new(())); // Placeholder, actual pointer handling would need unsafe\n                item.alloc_size = alloc_size;\n                1\n            }\n            None => 0,\n        }\n    } else {\n        1\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "CalcAllocation",
            "binn",
            "realloc_fn"
        ],
        "params": [
            "binn *item",
            "int add_size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "item",
            "add_size",
            "alloc_size",
            "ptr",
            "ptr_idx",
            "realloc_fn"
        ],
        "calle": [
            "CalcAllocation",
            "realloc_fn"
        ],
        "calle_c": [
            "realloc_fn"
        ],
        "key": "CheckAllocation",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "AddValue": {
        "source_code": "static BOOL AddValue(binn *item, int type, void *pvalue, int size)\n{\n  unsigned int pvalue_idx = 0;\n  int int32;\n  int ArgSize;\n  int storage_type;\n  int extra_type;\n  unsigned char *p;\n  unsigned int p_idx = 0;\n  binn_get_type_info(type, &storage_type, &extra_type);\n  if ((&pvalue[pvalue_idx]) == 0)\n  {\n    switch (storage_type)\n    {\n      case 0x00:\n        break;\n\n      case 0xC0:\n\n      case 0xA0:\n        if (size == 0)\n      {\n        break;\n      }\n\n      default:\n        return 0;\n\n    }\n\n  }\n  if ((type_family(type) == 0xf2) && (item->disable_int_compression == 0))\n  {\n    pvalue_idx = compress_int(&storage_type, &type, pvalue_idx);\n  }\n  switch (storage_type)\n  {\n    case 0x00:\n      size = 0;\n      ArgSize = size;\n      break;\n\n    case 0x20:\n      size = 1;\n      ArgSize = size;\n      break;\n\n    case 0x40:\n      size = 2;\n      ArgSize = size;\n      break;\n\n    case 0x60:\n      size = 4;\n      ArgSize = size;\n      break;\n\n    case 0x80:\n      size = 8;\n      ArgSize = size;\n      break;\n\n    case 0xC0:\n      if (size < 0)\n    {\n      return 0;\n    }\n      ArgSize = size + 4;\n      break;\n\n    case 0xA0:\n      if (size < 0)\n    {\n      return 0;\n    }\n      if (size == 0)\n    {\n      size = strlen2((char *) pvalue);\n    }\n      ArgSize = size + 5;\n      break;\n\n    case 0xE0:\n      if (size <= 0)\n    {\n      return 0;\n    }\n      ArgSize = size;\n      break;\n\n    default:\n      return 0;\n\n  }\n\n  ArgSize += 2;\n  if (CheckAllocation(item, ArgSize) == 0)\n  {\n    return 0;\n  }\n  p_idx = ((unsigned char *) item->pbuf) + item->used_size;\n  if (storage_type != 0xE0)\n  {\n    if (type > 255)\n    {\n      u16 type16 = type;\n      copy_be16((u16 *) p, (u16 *) (&type16));\n      p_idx += 2;\n      item->used_size += 2;\n    }\n    else\n    {\n      p[p_idx] = type;\n      p_idx += 1;\n      item->used_size += 1;\n    }\n  }\n  switch (storage_type)\n  {\n    case 0x00:\n      break;\n\n    case 0x20:\n      *((char *) p) = *((char *) pvalue);\n      item->used_size += 1;\n      break;\n\n    case 0x40:\n      copy_be16((u16 *) p, (u16 *) pvalue);\n      item->used_size += 2;\n      break;\n\n    case 0x60:\n      copy_be32((u32 *) p, (u32 *) pvalue);\n      item->used_size += 4;\n      break;\n\n    case 0x80:\n      copy_be64((u64 *) p, (u64 *) pvalue);\n      item->used_size += 8;\n      break;\n\n    case 0xC0:\n\n    case 0xA0:\n      if (size > 127)\n    {\n      int32 = size | 0x80000000;\n      copy_be32((u32 *) p, (u32 *) (&int32));\n      p_idx += 4;\n      item->used_size += 4;\n    }\n    else\n    {\n      *((unsigned char *) p) = size;\n      p_idx += 1;\n      item->used_size += 1;\n    }\n      memcpy(p, pvalue, size);\n      if (storage_type == 0xA0)\n    {\n      p_idx += size;\n      *((char *) p) = (char) 0;\n      size += 1;\n    }\n      item->used_size += size;\n      break;\n\n    case 0xE0:\n      memcpy(p, pvalue, size);\n      item->used_size += size;\n      break;\n\n  }\n\n  item->dirty = 1;\n  return 1;\n}\n\n",
        "translated_code": "pub fn AddValue(\n    item: &mut Option<Box<BinnStruct>>,\n    mut type_: i32,\n    pvalue: Option<&[u8]>,\n    size: i32,\n) -> BOOL {\n    let mut pvalue_idx = 0;\n    let mut ArgSize;\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    let mut p_idx = 0;\n\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            0x00 => (),\n            0xC0 | 0xA0 => {\n                if size == 0 {\n                    ();\n                } else {\n                    return 0;\n                }\n            }\n            _ => return 0,\n        }\n    }\n\n    if (type_family(type_) == 0xF2) && (item.as_ref().unwrap().disable_int_compression == 0) {\n        let _ = compress_int(&mut storage_type, &mut type_, &[]);\n    }\n\n    match storage_type {\n        0x00 => {\n            ArgSize = 0;\n        }\n        0x20 => {\n            ArgSize = 1;\n        }\n        0x40 => {\n            ArgSize = 2;\n        }\n        0x60 => {\n            ArgSize = 4;\n        }\n        0x80 => {\n            ArgSize = 8;\n        }\n        0xC0 => {\n            if size < 0 {\n                return 0;\n            }\n            ArgSize = size + 4;\n        }\n        0xA0 => {\n            if size < 0 {\n                return 0;\n            }\n            let actual_size = if size == 0 {\n                strlen2(pvalue.and_then(|v| std::str::from_utf8(v).ok()))\n            } else {\n                size as usize\n            };\n            ArgSize = actual_size as i32 + 5;\n        }\n        0xE0 => {\n            if size <= 0 {\n                return 0;\n            }\n            ArgSize = size;\n        }\n        _ => return 0,\n    }\n\n    ArgSize += 2;\n    if CheckAllocation(item, ArgSize) == 0 {\n        return 0;\n    }\n\n    let item_ref = item.as_mut().unwrap();\n    p_idx = item_ref.used_size as usize;\n    let p_ptr = if let Some(pbuf) = &mut item_ref.pbuf {\n        pbuf.as_mut() as *mut _ as *mut u8\n    } else {\n        return 0;\n    };\n\n    if storage_type != 0xE0 {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            copy_be16(\n                unsafe { &mut *(p_ptr.add(p_idx) as *mut u16) },\n                &type16,\n            );\n            p_idx += 2;\n            item_ref.used_size += 2;\n        } else {\n            unsafe {\n                *(p_ptr.add(p_idx)) = type_ as u8;\n            }\n            p_idx += 1;\n            item_ref.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        0x00 => (),\n        0x20 => {\n            if let Some(pvalue) = pvalue {\n                unsafe {\n                    *(p_ptr.add(p_idx)) = pvalue[0];\n                }\n                item_ref.used_size += 1;\n            }\n        }\n        0x40 => {\n            if let Some(pvalue) = pvalue {\n                let value = unsafe { &*(pvalue.as_ptr() as *const u16) };\n                copy_be16(\n                    unsafe { &mut *(p_ptr.add(p_idx) as *mut u16) },\n                    value,\n                );\n                item_ref.used_size += 2;\n            }\n        }\n        0x60 => {\n            if let Some(pvalue) = pvalue {\n                let value = unsafe { &*(pvalue.as_ptr() as *const u32) };\n                copy_be32(\n                    unsafe { &mut *(p_ptr.add(p_idx) as *mut u32) },\n                    value,\n                );\n                item_ref.used_size += 4;\n            }\n        }\n        0x80 => {\n            if let Some(pvalue) = pvalue {\n                let value = unsafe { &*(pvalue.as_ptr() as *const u64) };\n                copy_be64(\n                    unsafe { &mut *(p_ptr.add(p_idx) as *mut u64) },\n                    value,\n                );\n                item_ref.used_size += 8;\n            }\n        }\n        0xC0 | 0xA0 => {\n            if let Some(pvalue) = pvalue {\n                let actual_size = if size == 0 {\n                    pvalue.len()\n                } else {\n                    size as usize\n                };\n\n                if actual_size > 127 {\n                    let value = (actual_size as u32) | 0x80000000;\n                    copy_be32(\n                        unsafe { &mut *(p_ptr.add(p_idx) as *mut u32) },\n                        &value,\n                    );\n                    p_idx += 4;\n                    item_ref.used_size += 4;\n                } else {\n                    unsafe {\n                        *(p_ptr.add(p_idx)) = actual_size as u8;\n                    }\n                    p_idx += 1;\n                    item_ref.used_size += 1;\n                }\n\n                unsafe {\n                    ptr::copy_nonoverlapping(\n                        pvalue.as_ptr(),\n                        p_ptr.add(p_idx),\n                        actual_size,\n                    );\n                }\n\n                if storage_type == 0xA0 {\n                    p_idx += actual_size;\n                    unsafe {\n                        *(p_ptr.add(p_idx)) = 0;\n                    }\n                    item_ref.used_size += 1;\n                }\n\n                item_ref.used_size += actual_size as i32;\n            }\n        }\n        0xE0 => {\n            if let Some(pvalue) = pvalue {\n                unsafe {\n                    ptr::copy_nonoverlapping(\n                        pvalue.as_ptr(),\n                        p_ptr.add(p_idx),\n                        size as usize,\n                    );\n                }\n                item_ref.used_size += size;\n            }\n        }\n        _ => return 0,\n    }\n\n    item.as_mut().unwrap().dirty = 1;\n    1\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "CheckAllocation",
            "binn",
            "binn_get_type_info",
            "compress_int",
            "copy_be16",
            "copy_be32",
            "copy_be64",
            "strlen2",
            "type_family",
            "u16"
        ],
        "header": "static BOOL AddValue(binn *item, int type, void *pvalue, int size)",
        "params": [
            "binn *item",
            "int type",
            "void *pvalue",
            "int size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "item",
            "type",
            "pvalue",
            "size",
            "pvalue_idx",
            "int32",
            "ArgSize",
            "storage_type",
            "extra_type",
            "p",
            "p_idx",
            "type16"
        ],
        "calle": [
            "memcpy",
            "copy_be64",
            "compress_int",
            "type_family",
            "binn_get_type_info",
            "strlen2",
            "CheckAllocation",
            "copy_be16",
            "copy_be32"
        ],
        "calle_c": [
            "memcpy"
        ],
        "key": "AddValue",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_list_add_raw": {
        "source_code": "static BOOL binn_list_add_raw(binn *item, int type, void *pvalue, int size)\n{\n  if (((item == 0) || (item->type != 0xE0)) || (item->writable == 0))\n  {\n    return 0;\n  }\n  if (AddValue(item, type, pvalue, size) == 0)\n  {\n    return 0;\n  }\n  item->count += 1;\n  return 1;\n}\n\n",
        "translated_code": "pub fn binn_list_add_raw(\n    item: &mut binn,\n    type_: i32,\n    pvalue: Option<&[u8]>,\n    size: i32,\n) -> BOOL {\n    // Check if item is None or doesn't meet conditions (equivalent to NULL/0 checks in C)\n    if item.is_none() || \n       item.as_ref().map(|i| i.type_ != 0xE0 || i.writable == 0).unwrap_or(true) {\n        return 0;\n    }\n\n    // Call AddValue with the same parameters\n    if AddValue(item, type_, pvalue, size) == 0 {\n        return 0;\n    }\n\n    // Increment count if successful\n    if let Some(i) = item.as_mut() {\n        i.count += 1;\n    }\n\n    1\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "AddValue",
            "binn"
        ],
        "params": [
            "binn *item",
            "int type",
            "void *pvalue",
            "int size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "item",
            "type",
            "pvalue",
            "size"
        ],
        "calle": [
            "AddValue"
        ],
        "calle_c": [],
        "key": "binn_list_add_raw",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add": {
        "source_code": "BOOL binn_list_add(binn *list, int type, void *pvalue, int size)\n{\n  if (GetWriteConvertedData(&type, &pvalue, &size) == 0)\n  {\n    return 0;\n  }\n  return binn_list_add_raw(list, type, pvalue, size);\n}\n\n",
        "translated_code": "pub fn binn_list_add(\n    list: &mut binn,\n    type_: i32,\n    pvalue: Option<&mut Option<Box<dyn std::any::Any>>>,\n    size: i32,\n) -> BOOL {\n    let mut converted_type = type_;\n    let mut converted_pvalue = pvalue;\n    let mut converted_size = size;\n\n    if !GetWriteConvertedData(&mut converted_type, &mut converted_pvalue, &mut converted_size) {\n        return 0;\n    }\n\n    // Convert pvalue to Option<&[u8]> for binn_list_add_raw\n    let raw_pvalue = converted_pvalue.and_then(|v| {\n        v.as_ref().and_then(|boxed| {\n            boxed.downcast_ref::<Vec<u8>>().map(|v| v.as_slice())\n        })\n    });\n\n    binn_list_add_raw(list, converted_type, raw_pvalue, converted_size)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "GetWriteConvertedData",
            "binn",
            "binn_list_add_raw"
        ],
        "header": "BOOL binn_list_add(binn *list, int type, void *pvalue, int size)",
        "params": [
            "binn *list",
            "int type",
            "void *pvalue",
            "int size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "type",
            "pvalue",
            "size"
        ],
        "calle": [
            "binn_list_add_raw",
            "GetWriteConvertedData"
        ],
        "calle_c": [],
        "key": "binn_list_add",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add_int8": {
        "source_code": "inline static BOOL binn_list_add_int8(binn *list, signed char value)\n{\n  return binn_list_add(list, 0x21, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_add_int8(list: &mut Option<Box<BinnStruct>>, value: i8) -> BOOL {\n    let mut boxed_value = Box::new(value) as Box<dyn std::any::Any>;\n    let mut binding = Some(boxed_value);\n    let pvalue = Some(&mut binding);\n    binn_list_add(list, 0x21, pvalue, 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_add"
        ],
        "params": [
            "binn *list",
            "signed char value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "value"
        ],
        "calle": [
            "binn_list_add"
        ],
        "calle_c": [],
        "key": "binn_list_add_int8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add_int16": {
        "source_code": "inline static BOOL binn_list_add_int16(binn *list, short value)\n{\n  return binn_list_add(list, 0x41, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_add_int16(list: &mut Option<Box<BinnStruct>>, value: i16) -> BOOL {\n    binn_list_add(list, 0x41, Some(&mut Some(Box::new(value))), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_add"
        ],
        "params": [
            "binn *list",
            "short value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "value"
        ],
        "calle": [
            "binn_list_add"
        ],
        "calle_c": [],
        "key": "binn_list_add_int16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add_int32": {
        "source_code": "inline static BOOL binn_list_add_int32(binn *list, int value)\n{\n  return binn_list_add(list, 0x61, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_add_int32(list: &mut Option<Box<BinnStruct>>, value: i32) -> BOOL {\n    binn_list_add(list, 0x61, Some(&mut Some(Box::new(value))), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_add"
        ],
        "params": [
            "binn *list",
            "int value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "value"
        ],
        "calle": [
            "binn_list_add"
        ],
        "calle_c": [],
        "key": "binn_list_add_int32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add_uint8": {
        "source_code": "inline static BOOL binn_list_add_uint8(binn *list, unsigned char value)\n{\n  return binn_list_add(list, 0x20, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_add_uint8(list: &mut Option<Box<BinnStruct>>, value: u8) -> BOOL {\n    binn_list_add(list, 0x20, Some(&mut Some(Box::new(value))), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_add"
        ],
        "params": [
            "binn *list",
            "unsigned char value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "value"
        ],
        "calle": [
            "binn_list_add"
        ],
        "calle_c": [],
        "key": "binn_list_add_uint8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add_uint16": {
        "source_code": "inline static BOOL binn_list_add_uint16(binn *list, unsigned short value)\n{\n  return binn_list_add(list, 0x40, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_add_uint16(list: &mut Option<Box<BinnStruct>>, value: u16) -> BOOL {\n    let mut boxed_value = Box::new(value) as Box<dyn std::any::Any>;\n    let mut binding = Some(boxed_value);\n    let pvalue = Some(&mut binding);\n    binn_list_add(list, 0x40, pvalue, 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_add"
        ],
        "params": [
            "binn *list",
            "unsigned short value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "value"
        ],
        "calle": [
            "binn_list_add"
        ],
        "calle_c": [],
        "key": "binn_list_add_uint16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add_uint32": {
        "source_code": "inline static BOOL binn_list_add_uint32(binn *list, unsigned int value)\n{\n  return binn_list_add(list, 0x60, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_add_uint32(list: &mut Option<Box<BinnStruct>>, value: u32) -> BOOL {\n    binn_list_add(list, 0x60, Some(&mut Some(Box::new(value))), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_add"
        ],
        "params": [
            "binn *list",
            "unsigned int value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "value"
        ],
        "calle": [
            "binn_list_add"
        ],
        "calle_c": [],
        "key": "binn_list_add_uint32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add_float": {
        "source_code": "inline static BOOL binn_list_add_float(binn *list, float value)\n{\n  return binn_list_add(list, 0x62, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_add_float(list: &mut Option<Box<BinnStruct>>, value: f32) -> BOOL {\n    binn_list_add(list, 0x62, Some(&mut Some(Box::new(value))), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_add"
        ],
        "params": [
            "binn *list",
            "float value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "value"
        ],
        "calle": [
            "binn_list_add"
        ],
        "calle_c": [],
        "key": "binn_list_add_float",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add_double": {
        "source_code": "inline static BOOL binn_list_add_double(binn *list, double value)\n{\n  return binn_list_add(list, 0x82, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_add_double(list: &mut Option<Box<BinnStruct>>, value: f64) -> BOOL {\n    binn_list_add(list, 0x82, Some(&mut Some(Box::new(value))), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_add"
        ],
        "params": [
            "binn *list",
            "double value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "value"
        ],
        "calle": [
            "binn_list_add"
        ],
        "calle_c": [],
        "key": "binn_list_add_double",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add_null": {
        "source_code": "inline static BOOL binn_list_add_null(binn *list)\n{\n  return binn_list_add(list, 0x00, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_add_null(list: &mut Option<Box<BinnStruct>>) -> BOOL {\n    binn_list_add(list, 0x00, None, 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_add"
        ],
        "params": [
            "binn *list"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list"
        ],
        "calle": [
            "binn_list_add"
        ],
        "calle_c": [],
        "key": "binn_list_add_null",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add_str": {
        "source_code": "inline static BOOL binn_list_add_str(binn *list, char *str)\n{\n  return binn_list_add(list, 0xA0, str, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_add_str(list: &mut Option<Box<BinnStruct>>, str: Option<&mut Option<Box<dyn std::any::Any>>>) -> BOOL {\n    binn_list_add(list, 0xA0, str, 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_add"
        ],
        "params": [
            "binn *list",
            "char *str"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "str"
        ],
        "calle": [
            "binn_list_add"
        ],
        "calle_c": [],
        "key": "binn_list_add_str",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add_blob": {
        "source_code": "inline static BOOL binn_list_add_blob(binn *list, void *ptr, int size)\n{\n  return binn_list_add(list, 0xC0, ptr, size);\n}\n\n",
        "translated_code": "pub fn binn_list_add_blob(\n    list: &mut crate::binn::binn,\n    ptr: Option<&mut Option<Box<dyn std::any::Any>>>,\n    size: i32,\n) -> BOOL {\n    binn_list_add(list, 0xC0, ptr, size)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_add"
        ],
        "params": [
            "binn *list",
            "void *ptr",
            "int size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "ptr",
            "size"
        ],
        "calle": [
            "binn_list_add"
        ],
        "calle_c": [],
        "key": "binn_list_add_blob",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_raw": {
        "source_code": "static BOOL binn_map_set_raw(binn *item, int id, int type, void *pvalue, int size)\n{\n  unsigned char *base;\n  unsigned char *p;\n  unsigned int p_idx = 0;\n  unsigned char sign;\n  int id_size;\n  if (((item == 0) || (item->type != 0xE1)) || (item->writable == 0))\n  {\n    return 0;\n  }\n  p_idx = SearchForID(item->pbuf, 9, item->used_size, item->count, id);\n  if (p)\n  {\n    return 0;\n  }\n  if (CheckAllocation(item, 5) == 0)\n  {\n    return 0;\n  }\n  p_idx = (base = ((unsigned char *) item->pbuf) + item->used_size);\n  sign = id < 0;\n  if (sign)\n  {\n    id = -id;\n  }\n  if (id <= 0x3F)\n  {\n    p[p_idx] = (sign << 6) | id;\n    p_idx += 1;\n  }\n  else\n    if (id <= 0xFFF)\n  {\n    p[p_idx] = (0x80 | (sign << 4)) | ((id & 0xF00) >> 8);\n    p_idx += 1;\n    p[p_idx] = id & 0xFF;\n    p_idx += 1;\n  }\n  else\n    if (id <= 0xFFFFF)\n  {\n    p[p_idx] = (0xA0 | (sign << 4)) | ((id & 0xF0000) >> 16);\n    p_idx += 1;\n    p[p_idx] = (id & 0xFF00) >> 8;\n    p_idx += 1;\n    p[p_idx] = id & 0xFF;\n    p_idx += 1;\n  }\n  else\n    if (id <= 0xFFFFFFF)\n  {\n    p[p_idx] = (0xC0 | (sign << 4)) | ((id & 0xF000000) >> 24);\n    p_idx += 1;\n    p[p_idx] = (id & 0xFF0000) >> 16;\n    p_idx += 1;\n    p[p_idx] = (id & 0xFF00) >> 8;\n    p_idx += 1;\n    p[p_idx] = id & 0xFF;\n    p_idx += 1;\n  }\n  else\n  {\n    p[p_idx] = 0xE0;\n    p_idx += 1;\n    if (sign)\n    {\n      id = -id;\n    }\n    copy_be32((u32 *) p, (u32 *) (&id));\n    p_idx += 4;\n  }\n  id_size = (&p[p_idx]) - base;\n  item->used_size += id_size;\n  if (AddValue(item, type, pvalue, size) == 0)\n  {\n    item->used_size -= id_size;\n    return 0;\n  }\n  item->count += 1;\n  return 1;\n}\n\n",
        "translated_code": "pub fn binn_map_set_raw(\n    item: &mut binn,\n    id: i32,\n    type_: i32,\n    pvalue: Option<&[u8]>,\n    size: i32,\n) -> BOOL {\n    // Check for NULL item or invalid type or not writable\n    if item.is_none() || item.as_ref().unwrap().type_ != 0xE1 || item.as_ref().unwrap().writable == 0 {\n        return 0;\n    }\n\n    let pbuf_slice = match &item.as_ref().unwrap().pbuf {\n        Some(p) => unsafe { std::slice::from_raw_parts(p.as_ref() as *const _ as *const u8, item.as_ref().unwrap().used_size as usize) },\n        None => return 0,\n    };\n\n    // Search for ID\n    if SearchForID(pbuf_slice, 9, item.as_ref().unwrap().used_size as usize, item.as_ref().unwrap().count as usize, id).is_some() {\n        return 0;\n    }\n\n    // Check allocation\n    if CheckAllocation(item, 5) == 0 {\n        return 0;\n    }\n\n    let item_ref = item.as_mut().unwrap();\n    let base_ptr = match &mut item_ref.pbuf {\n        Some(p) => unsafe { (p.as_mut() as *mut _ as *mut u8).add(item_ref.used_size as usize) },\n        None => return 0,\n    };\n\n    let mut p_idx = 0;\n    let mut sign = id < 0;\n    let mut id = if sign { -id } else { id };\n\n    unsafe {\n        let p = std::slice::from_raw_parts_mut(base_ptr, (item_ref.alloc_size - item_ref.used_size) as usize);\n\n        if id <= 0x3F {\n            p[p_idx] = (sign as u8) << 6 | id as u8;\n            p_idx += 1;\n        } else if id <= 0xFFF {\n            p[p_idx] = 0x80 | ((sign as u8) << 4) | ((id & 0xF00) >> 8) as u8;\n            p_idx += 1;\n            p[p_idx] = (id & 0xFF) as u8;\n            p_idx += 1;\n        } else if id <= 0xFFFFF {\n            p[p_idx] = 0xA0 | ((sign as u8) << 4) | ((id & 0xF0000) >> 16) as u8;\n            p_idx += 1;\n            p[p_idx] = ((id & 0xFF00) >> 8) as u8;\n            p_idx += 1;\n            p[p_idx] = (id & 0xFF) as u8;\n            p_idx += 1;\n        } else if id <= 0xFFFFFFF {\n            p[p_idx] = 0xC0 | ((sign as u8) << 4) | ((id & 0xF000000) >> 24) as u8;\n            p_idx += 1;\n            p[p_idx] = ((id & 0xFF0000) >> 16) as u8;\n            p_idx += 1;\n            p[p_idx] = ((id & 0xFF00) >> 8) as u8;\n            p_idx += 1;\n            p[p_idx] = (id & 0xFF) as u8;\n            p_idx += 1;\n        } else {\n            p[p_idx] = 0xE0;\n            p_idx += 1;\n            if sign {\n                id = -id;\n            }\n            let dest = &mut *(p.as_mut_ptr().add(p_idx) as *mut u32);\n            let src = &*(&id as *const i32 as *const u32);\n            copy_be32(dest, src);\n            p_idx += 4;\n        }\n\n        let id_size = p_idx;\n        item_ref.used_size += id_size as i32;\n\n        // Release the borrow before calling AddValue\n        let result = AddValue(item, type_, pvalue, size);\n        if result == 0 {\n            item.as_mut().unwrap().used_size -= id_size as i32;\n            return 0;\n        }\n\n        item.as_mut().unwrap().count += 1;\n        1\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "AddValue",
            "CheckAllocation",
            "SearchForID",
            "binn",
            "copy_be32"
        ],
        "params": [
            "binn *item",
            "int id",
            "int type",
            "void *pvalue",
            "int size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "item",
            "id",
            "type",
            "pvalue",
            "size",
            "base",
            "p",
            "p_idx",
            "sign",
            "id_size"
        ],
        "calle": [
            "CheckAllocation",
            "SearchForID",
            "copy_be32",
            "AddValue"
        ],
        "calle_c": [],
        "key": "binn_map_set_raw",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_map_set": {
        "source_code": "BOOL binn_map_set(binn *map, int id, int type, void *pvalue, int size)\n{\n  if (GetWriteConvertedData(&type, &pvalue, &size) == 0)\n  {\n    return 0;\n  }\n  return binn_map_set_raw(map, id, type, pvalue, size);\n}\n\n",
        "translated_code": "pub fn binn_map_set(\n    map: &mut binn,\n    id: i32,\n    type_: i32,\n    pvalue: Option<&mut Option<Box<dyn std::any::Any>>>,\n    size: i32,\n) -> BOOL {\n    let mut converted_type = type_;\n    let mut converted_pvalue = pvalue;\n    let mut converted_size = size;\n    \n    if !GetWriteConvertedData(&mut converted_type, &mut converted_pvalue, &mut converted_size) {\n        return 0;\n    }\n    \n    // Convert the pvalue to Option<&[u8]> for binn_map_set_raw\n    let raw_pvalue = converted_pvalue.and_then(|v| {\n        v.as_ref().map(|boxed| {\n            let bytes: &[u8] = unsafe { std::mem::transmute(boxed.as_ref()) };\n            bytes\n        })\n    });\n    \n    binn_map_set_raw(map, id, converted_type, raw_pvalue, converted_size)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "GetWriteConvertedData",
            "binn",
            "binn_map_set_raw"
        ],
        "header": "BOOL binn_map_set(binn *map, int id, int type, void *pvalue, int size)",
        "params": [
            "binn *map",
            "int id",
            "int type",
            "void *pvalue",
            "int size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "type",
            "pvalue",
            "size"
        ],
        "calle": [
            "binn_map_set_raw",
            "GetWriteConvertedData"
        ],
        "calle_c": [],
        "key": "binn_map_set",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_int8": {
        "source_code": "inline static BOOL binn_map_set_int8(binn *map, int id, signed char value)\n{\n  return binn_map_set(map, id, 0x21, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_set_int8(map: &mut Option<Box<BinnStruct>>, id: i32, value: i8) -> BOOL {\n    let mut boxed_value = Box::new(value);\n    binn_map_set(map, id, 0x21, Some(&mut Some(boxed_value)), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_set"
        ],
        "params": [
            "binn *map",
            "int id",
            "signed char value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_set"
        ],
        "calle_c": [],
        "key": "binn_map_set_int8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_int16": {
        "source_code": "inline static BOOL binn_map_set_int16(binn *map, int id, short value)\n{\n  return binn_map_set(map, id, 0x41, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_set_int16(map: &mut Option<Box<BinnStruct>>, id: i32, value: i16) -> BOOL {\n    binn_map_set(map, id, 0x41, Some(&mut Some(Box::new(value))), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_set"
        ],
        "params": [
            "binn *map",
            "int id",
            "short value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_set"
        ],
        "calle_c": [],
        "key": "binn_map_set_int16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_int32": {
        "source_code": "inline static BOOL binn_map_set_int32(binn *map, int id, int value)\n{\n  return binn_map_set(map, id, 0x61, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_set_int32(map: &mut crate::binn::binn, id: i32, value: i32) -> BOOL {\n    binn_map_set(map, id, 0x61, Some(&mut Some(Box::new(value))), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_set"
        ],
        "params": [
            "binn *map",
            "int id",
            "int value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_set"
        ],
        "calle_c": [],
        "key": "binn_map_set_int32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_uint8": {
        "source_code": "inline static BOOL binn_map_set_uint8(binn *map, int id, unsigned char value)\n{\n  return binn_map_set(map, id, 0x20, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_set_uint8(map: &mut Option<Box<BinnStruct>>, id: i32, value: u8) -> BOOL {\n    let mut boxed_value = Box::new(value) as Box<dyn std::any::Any>;\n    binn_map_set(map, id, 0x20, Some(&mut Some(boxed_value)), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_set"
        ],
        "params": [
            "binn *map",
            "int id",
            "unsigned char value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_set"
        ],
        "calle_c": [],
        "key": "binn_map_set_uint8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_uint16": {
        "source_code": "inline static BOOL binn_map_set_uint16(binn *map, int id, unsigned short value)\n{\n  return binn_map_set(map, id, 0x40, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_set_uint16(map: &mut Option<Box<BinnStruct>>, id: i32, value: u16) -> BOOL {\n    let mut boxed_value = Box::new(value);\n    let mut any_value: Option<Box<dyn std::any::Any>> = Some(boxed_value);\n    binn_map_set(map, id, 0x40, Some(&mut any_value), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_set"
        ],
        "params": [
            "binn *map",
            "int id",
            "unsigned short value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_set"
        ],
        "calle_c": [],
        "key": "binn_map_set_uint16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_uint32": {
        "source_code": "inline static BOOL binn_map_set_uint32(binn *map, int id, unsigned int value)\n{\n  return binn_map_set(map, id, 0x60, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_set_uint32(map: &mut crate::binn::binn, id: i32, value: u32) -> BOOL {\n    let mut boxed_value = Some(Box::new(value) as Box<dyn std::any::Any>);\n    binn_map_set(map, id, 0x60, Some(&mut boxed_value), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_set"
        ],
        "params": [
            "binn *map",
            "int id",
            "unsigned int value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_set"
        ],
        "calle_c": [],
        "key": "binn_map_set_uint32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_float": {
        "source_code": "inline static BOOL binn_map_set_float(binn *map, int id, float value)\n{\n  return binn_map_set(map, id, 0x62, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_set_float(map: &mut Option<Box<BinnStruct>>, id: i32, value: f32) -> BOOL {\n    binn_map_set(map, id, 0x62, Some(&mut Some(Box::new(value))), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_set"
        ],
        "params": [
            "binn *map",
            "int id",
            "float value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_set"
        ],
        "calle_c": [],
        "key": "binn_map_set_float",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_double": {
        "source_code": "inline static BOOL binn_map_set_double(binn *map, int id, double value)\n{\n  return binn_map_set(map, id, 0x82, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_set_double(map: &mut Option<Box<BinnStruct>>, id: i32, value: f64) -> BOOL {\n    binn_map_set(map, id, 0x82, Some(&mut Some(Box::new(value))), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_set"
        ],
        "params": [
            "binn *map",
            "int id",
            "double value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_set"
        ],
        "calle_c": [],
        "key": "binn_map_set_double",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_null": {
        "source_code": "inline static BOOL binn_map_set_null(binn *map, int id)\n{\n  return binn_map_set(map, id, 0x00, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_set_null(map: &mut Option<Box<BinnStruct>>, id: i32) -> BOOL {\n    binn_map_set(map, id, 0x00, Option::None, 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_set"
        ],
        "params": [
            "binn *map",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id"
        ],
        "calle": [
            "binn_map_set"
        ],
        "calle_c": [],
        "key": "binn_map_set_null",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_str": {
        "source_code": "inline static BOOL binn_map_set_str(binn *map, int id, char *str)\n{\n  return binn_map_set(map, id, 0xA0, str, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_set_str(map: &mut Option<Box<BinnStruct>>, id: i32, str: Option<&mut Option<Box<dyn std::any::Any>>>) -> BOOL {\n    binn_map_set(map, id, 0xA0, str, 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_set"
        ],
        "params": [
            "binn *map",
            "int id",
            "char *str"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "str"
        ],
        "calle": [
            "binn_map_set"
        ],
        "calle_c": [],
        "key": "binn_map_set_str",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_blob": {
        "source_code": "inline static BOOL binn_map_set_blob(binn *map, int id, void *ptr, int size)\n{\n  return binn_map_set(map, id, 0xC0, ptr, size);\n}\n\n",
        "translated_code": "pub fn binn_map_set_blob(\n    map: &mut crate::binn::binn,\n    id: i32,\n    ptr: Option<&mut Option<Box<dyn std::any::Any>>>,\n    size: i32,\n) -> BOOL {\n    binn_map_set(map, id, 0xC0, ptr, size)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_set"
        ],
        "params": [
            "binn *map",
            "int id",
            "void *ptr",
            "int size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "ptr",
            "size"
        ],
        "calle": [
            "binn_map_set"
        ],
        "calle_c": [],
        "key": "binn_map_set_blob",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_raw": {
        "source_code": "static BOOL binn_object_set_raw(binn *item, const char *key, int type, void *pvalue, int size)\n{\n  unsigned char *p;\n  unsigned int p_idx = 0;\n  unsigned char len;\n  int int32;\n  if (((item == 0) || (item->type != 0xE2)) || (item->writable == 0))\n  {\n    return 0;\n  }\n  if (key == 0)\n  {\n    return 0;\n  }\n  int32 = strlen(key);\n  if (int32 > 255)\n  {\n    return 0;\n  }\n  p_idx = SearchForKey(item->pbuf, 9, item->used_size, item->count, key);\n  if (p)\n  {\n    return 0;\n  }\n  if (CheckAllocation(item, 1 + int32) == 0)\n  {\n    return 0;\n  }\n  p_idx = ((unsigned char *) item->pbuf) + item->used_size;\n  len = int32;\n  p[p_idx] = len;\n  p_idx += 1;\n  memcpy(p, key, int32);\n  int32 += 1;\n  item->used_size += int32;\n  if (AddValue(item, type, pvalue, size) == 0)\n  {\n    item->used_size -= int32;\n    return 0;\n  }\n  item->count += 1;\n  return 1;\n}\n\n",
        "translated_code": "pub fn binn_object_set_raw(\n    item: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    type_: i32,\n    pvalue: Option<&[u8]>,\n    size: i32,\n) -> BOOL {\n    // Check if item is None or has invalid type/writable flag\n    if item.is_none() || item.as_ref().unwrap().type_ != 0xE2 || item.as_ref().unwrap().writable == 0 {\n        return 0;\n    }\n\n    // Check if key is None\n    if key.is_none() {\n        return 0;\n    }\n    let key = key.unwrap();\n\n    // Check key length\n    let int32 = key.len() as i32;\n    if int32 > 255 {\n        return 0;\n    }\n\n    // Search for key\n    let item_ref = item.as_ref().unwrap();\n    let p = SearchForKey(\n        item_ref.pbuf.as_ref().map(|b| b.as_ref() as *const _ as *const u8).map(|p| unsafe { std::slice::from_raw_parts(p, item_ref.used_size as usize) }),\n        9,\n        item_ref.used_size as usize,\n        item_ref.count,\n        Some(key),\n    );\n    if p.is_some() {\n        return 0;\n    }\n\n    // Check allocation\n    if CheckAllocation(item, 1 + int32) == 0 {\n        return 0;\n    }\n\n    // Get mutable reference to item\n    let item_mut = item.as_mut().unwrap();\n    let p_idx = item_mut.used_size;\n    let len = int32 as u8;\n\n    // This part would require unsafe in Rust since we're dealing with raw pointers\n    unsafe {\n        let pbuf_ptr = item_mut.pbuf.as_mut().unwrap().as_mut() as *mut _ as *mut u8;\n        ptr::write(pbuf_ptr.add(p_idx as usize), len);\n        ptr::copy_nonoverlapping(key.as_ptr(), pbuf_ptr.add(p_idx as usize + 1), int32 as usize);\n    }\n\n    let int32 = int32 + 1;\n    item_mut.used_size += int32;\n\n    // Store the used_size adjustment value before calling AddValue\n    let adjustment = int32;\n    if AddValue(item, type_, pvalue, size) == 0 {\n        item.as_mut().unwrap().used_size -= adjustment;\n        return 0;\n    }\n\n    item.as_mut().unwrap().count += 1;\n    1\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "AddValue",
            "CheckAllocation",
            "SearchForKey",
            "binn"
        ],
        "params": [
            "binn *item",
            "const char *key",
            "int type",
            "void *pvalue",
            "int size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "item",
            "key",
            "type",
            "pvalue",
            "size",
            "p",
            "p_idx",
            "len",
            "int32"
        ],
        "calle": [
            "memcpy",
            "AddValue",
            "CheckAllocation",
            "SearchForKey",
            "strlen"
        ],
        "calle_c": [
            "memcpy",
            "strlen"
        ],
        "key": "binn_object_set_raw",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_object_set": {
        "source_code": "BOOL binn_object_set(binn *obj, const char *key, int type, void *pvalue, int size)\n{\n  if (GetWriteConvertedData(&type, &pvalue, &size) == 0)\n  {\n    return 0;\n  }\n  return binn_object_set_raw(obj, key, type, pvalue, size);\n}\n\n",
        "translated_code": "pub fn binn_object_set(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    type_: i32,\n    pvalue: Option<&mut Option<Box<dyn std::any::Any>>>,\n    size: i32,\n) -> BOOL {\n    let mut converted_type = type_;\n    let mut converted_pvalue = pvalue;\n    let mut converted_size = size;\n    \n    if !GetWriteConvertedData(&mut converted_type, &mut converted_pvalue, &mut converted_size) {\n        return 0;\n    }\n\n    // Convert the pvalue to a byte slice if it exists\n    let pvalue_bytes = match converted_pvalue {\n        Some(ref mut value) => {\n            // This is a placeholder - actual conversion would depend on the type\n            // In a real implementation, you'd need to properly convert the Any to bytes\n            None\n        },\n        None => None,\n    };\n\n    binn_object_set_raw(obj, key, converted_type, pvalue_bytes, converted_size)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "GetWriteConvertedData",
            "binn",
            "binn_object_set_raw"
        ],
        "header": "BOOL binn_object_set(binn *obj, const char *key, int type, void *pvalue, int size)",
        "params": [
            "binn *obj",
            "const char *key",
            "int type",
            "void *pvalue",
            "int size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "type",
            "pvalue",
            "size"
        ],
        "calle": [
            "binn_object_set_raw",
            "GetWriteConvertedData"
        ],
        "calle_c": [],
        "key": "binn_object_set",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_int8": {
        "source_code": "inline static BOOL binn_object_set_int8(binn *obj, const char *key, signed char value)\n{\n  return binn_object_set(obj, key, 0x21, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_set_int8(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    value: i8,\n) -> BOOL {\n    binn_object_set(obj, key, 0x21, Some(&mut Some(Box::new(value))), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_set"
        ],
        "params": [
            "binn *obj",
            "const char *key",
            "signed char value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_set"
        ],
        "calle_c": [],
        "key": "binn_object_set_int8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_int16": {
        "source_code": "inline static BOOL binn_object_set_int16(binn *obj, const char *key, short value)\n{\n  return binn_object_set(obj, key, 0x41, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_set_int16(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    value: i16,\n) -> BOOL {\n    let mut boxed_value: Option<Box<dyn std::any::Any>> = Some(Box::new(value));\n    binn_object_set(obj, key, 0x41, Some(&mut boxed_value), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_set"
        ],
        "params": [
            "binn *obj",
            "const char *key",
            "short value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_set"
        ],
        "calle_c": [],
        "key": "binn_object_set_int16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_int32": {
        "source_code": "inline static BOOL binn_object_set_int32(binn *obj, const char *key, int value)\n{\n  return binn_object_set(obj, key, 0x61, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_set_int32(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    value: i32,\n) -> BOOL {\n    let mut boxed_value: Option<Box<dyn std::any::Any>> = Some(Box::new(value));\n    binn_object_set(obj, key, 0x61, Some(&mut boxed_value), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_set"
        ],
        "params": [
            "binn *obj",
            "const char *key",
            "int value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_set"
        ],
        "calle_c": [],
        "key": "binn_object_set_int32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_uint8": {
        "source_code": "inline static BOOL binn_object_set_uint8(binn *obj, const char *key, unsigned char value)\n{\n  return binn_object_set(obj, key, 0x20, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_set_uint8(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    value: u8,\n) -> BOOL {\n    let mut boxed_value: Option<Box<dyn std::any::Any>> = Some(Box::new(value));\n    binn_object_set(obj, key, 0x20, Some(&mut boxed_value), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_set"
        ],
        "params": [
            "binn *obj",
            "const char *key",
            "unsigned char value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_set"
        ],
        "calle_c": [],
        "key": "binn_object_set_uint8",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_uint16": {
        "source_code": "inline static BOOL binn_object_set_uint16(binn *obj, const char *key, unsigned short value)\n{\n  return binn_object_set(obj, key, 0x40, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_set_uint16(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    value: u16,\n) -> BOOL {\n    let mut boxed_value: Option<Box<dyn std::any::Any>> = Some(Box::new(value));\n    binn_object_set(obj, key, 0x40, Some(&mut boxed_value), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_set"
        ],
        "params": [
            "binn *obj",
            "const char *key",
            "unsigned short value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_set"
        ],
        "calle_c": [],
        "key": "binn_object_set_uint16",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_uint32": {
        "source_code": "inline static BOOL binn_object_set_uint32(binn *obj, const char *key, unsigned int value)\n{\n  return binn_object_set(obj, key, 0x60, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_set_uint32(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    value: u32,\n) -> BOOL {\n    let mut boxed_value: Option<Box<dyn std::any::Any>> = Some(Box::new(value));\n    binn_object_set(obj, key, 0x60, Some(&mut boxed_value), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_set"
        ],
        "params": [
            "binn *obj",
            "const char *key",
            "unsigned int value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_set"
        ],
        "calle_c": [],
        "key": "binn_object_set_uint32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_float": {
        "source_code": "inline static BOOL binn_object_set_float(binn *obj, const char *key, float value)\n{\n  return binn_object_set(obj, key, 0x62, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_set_float(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    value: f32,\n) -> BOOL {\n    let mut boxed_value: Option<Box<dyn std::any::Any>> = Some(Box::new(value));\n    binn_object_set(obj, key, 0x62, Some(&mut boxed_value), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_set"
        ],
        "params": [
            "binn *obj",
            "const char *key",
            "float value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_set"
        ],
        "calle_c": [],
        "key": "binn_object_set_float",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_double": {
        "source_code": "inline static BOOL binn_object_set_double(binn *obj, const char *key, double value)\n{\n  return binn_object_set(obj, key, 0x82, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_set_double(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    value: f64,\n) -> BOOL {\n    let mut boxed_value: Option<Box<dyn std::any::Any>> = Some(Box::new(value));\n    binn_object_set(obj, key, 0x82, Some(&mut boxed_value), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_set"
        ],
        "params": [
            "binn *obj",
            "const char *key",
            "double value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_set"
        ],
        "calle_c": [],
        "key": "binn_object_set_double",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_null": {
        "source_code": "inline static BOOL binn_object_set_null(binn *obj, const char *key)\n{\n  return binn_object_set(obj, key, 0x00, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_set_null(obj: &mut Option<Box<BinnStruct>>, key: Option<&str>) -> BOOL {\n    binn_object_set(obj, key, 0x00, None, 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_set"
        ],
        "params": [
            "binn *obj",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key"
        ],
        "calle": [
            "binn_object_set"
        ],
        "calle_c": [],
        "key": "binn_object_set_null",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_str": {
        "source_code": "inline static BOOL binn_object_set_str(binn *obj, const char *key, char *str)\n{\n  return binn_object_set(obj, key, 0xA0, str, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_set_str(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    str: Option<&str>,\n) -> BOOL {\n    let mut boxed_str = str.map(|s| Box::new(s.to_string()) as Box<dyn std::any::Any>);\n    let mut option_boxed_str = boxed_str.map(Some);\n    binn_object_set(obj, key, 0xA0, option_boxed_str.as_mut().map(|b| b), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_set"
        ],
        "params": [
            "binn *obj",
            "const char *key",
            "char *str"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "str"
        ],
        "calle": [
            "binn_object_set"
        ],
        "calle_c": [],
        "key": "binn_object_set_str",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_blob": {
        "source_code": "inline static BOOL binn_object_set_blob(binn *obj, const char *key, void *ptr, int size)\n{\n  return binn_object_set(obj, key, 0xC0, ptr, size);\n}\n\n",
        "translated_code": "pub fn binn_object_set_blob(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    ptr: Option<&mut Option<Box<dyn std::any::Any>>>,\n    size: i32,\n) -> BOOL {\n    binn_object_set(obj, key, 0xC0, ptr, size)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_set"
        ],
        "params": [
            "binn *obj",
            "const char *key",
            "void *ptr",
            "int size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "ptr",
            "size"
        ],
        "calle": [
            "binn_object_set"
        ],
        "calle_c": [],
        "key": "binn_object_set_blob",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_get_int64": {
        "source_code": "inline static BOOL binn_list_get_int64(void *list, int pos, int64 *pvalue)\n{\n  return binn_list_get(list, pos, 0x81, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_get_int64(\n    list: Option<&[u8]>,\n    pos: i32,\n    pvalue: Option<&mut int64>,\n) -> BOOL {\n    binn_list_get(list, pos, 0x81, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get",
            "int64"
        ],
        "params": [
            "void *list",
            "int pos",
            "int64 *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "pvalue"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_get_int64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_get_bool": {
        "source_code": "inline static BOOL binn_list_get_bool(void *list, int pos, BOOL *pvalue)\n{\n  return binn_list_get(list, pos, 0x80061, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_get_bool(list: Option<&[u8]>, pos: i32, pvalue: Option<&mut BOOL>) -> BOOL {\n    binn_list_get(list, pos, 0x80061, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "binn_list_get"
        ],
        "params": [
            "void *list",
            "int pos",
            "BOOL *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "pvalue"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_get_bool",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_get_int64": {
        "source_code": "inline static BOOL binn_map_get_int64(void *map, int id, int64 *pvalue)\n{\n  return binn_map_get(map, id, 0x81, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_get_int64(\n    map: Option<&[u8]>,\n    id: i32,\n    pvalue: Option<&mut int64>,\n) -> BOOL {\n    binn_map_get(map, id, 0x81, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get",
            "int64"
        ],
        "params": [
            "void *map",
            "int id",
            "int64 *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "pvalue"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_get_int64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_get_bool": {
        "source_code": "inline static BOOL binn_map_get_bool(void *map, int id, BOOL *pvalue)\n{\n  return binn_map_get(map, id, 0x80061, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_get_bool(map: Option<&[u8]>, id: i32, pvalue: Option<&mut BOOL>) -> BOOL {\n    binn_map_get(map, id, 0x80061, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "binn_map_get"
        ],
        "params": [
            "void *map",
            "int id",
            "BOOL *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "pvalue"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_get_bool",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_get_int64": {
        "source_code": "inline static BOOL binn_object_get_int64(void *obj, const char *key, int64 *pvalue)\n{\n  return binn_object_get(obj, key, 0x81, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_get_int64(\n    obj: Option<&[u8]>,\n    key: Option<&str>,\n    pvalue: Option<&mut int64>,\n) -> bool {\n    binn_object_get(obj, key, 0x81, pvalue.map(|v| v as &mut dyn Any), None) != 0\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get",
            "int64"
        ],
        "params": [
            "void *obj",
            "const char *key",
            "int64 *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "pvalue"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_get_int64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_get_bool": {
        "source_code": "inline static BOOL binn_object_get_bool(void *obj, const char *key, BOOL *pvalue)\n{\n  return binn_object_get(obj, key, 0x80061, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_get_bool(obj: Option<&[u8]>, key: Option<&str>, pvalue: Option<&mut BOOL>) -> BOOL {\n    binn_object_get(obj, key, 0x80061, pvalue.map(|v| v as &mut dyn Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "binn_object_get"
        ],
        "params": [
            "void *obj",
            "const char *key",
            "BOOL *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "pvalue"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_get_bool",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_floating_point_numbers": {
        "source_code": "void test_floating_point_numbers()\n{\n  char buf[256];\n  float f1;\n  double d1;\n  printf(\"testing floating point... \");\n  f1 = 1.25;\n  assert(f1 == 1.25);\n  d1 = 1.25;\n  assert(d1 == 1.25);\n  d1 = 0;\n  d1 = f1;\n  assert(d1 == 1.25);\n  f1 = 0;\n  f1 = d1;\n  assert(f1 == 1.25);\n  d1 = 1.234;\n  assert(AlmostEqualDoubles(d1, 1.234) == 1);\n  f1 = d1;\n  assert(AlmostEqualFloats(f1, 1.234, 2) == 1);\n  d1 = 1.2345;\n  assert(AlmostEqualDoubles(d1, 1.2345) == 1);\n  f1 = d1;\n  assert(AlmostEqualFloats(f1, 1.2345, 2) == 1);\n  d1 = atof(\"1.234\");\n  assert(AlmostEqualDoubles(d1, 1.234) == 1);\n  f1 = d1;\n  assert(AlmostEqualFloats(f1, 1.234, 2) == 1);\n  sprintf(buf, \"%g\", d1);\n  assert(buf[0] != 0);\n  assert(strcmp(buf, \"1.234\") == 0);\n  d1 = atof(\"12.34\");\n  assert(d1 == 12.34);\n  f1 = d1;\n  assert(AlmostEqualFloats(f1, 12.34, 2) == 1);\n  sprintf(buf, \"%g\", d1);\n  assert(buf[0] != 0);\n  assert(strcmp(buf, \"12.34\") == 0);\n  d1 = atof(\"1.234e25\");\n  assert(AlmostEqualDoubles(d1, 1.234e25) == 1);\n  f1 = d1;\n  assert(AlmostEqualFloats(f1, 1.234e25, 2) == 1);\n  sprintf(buf, \"%g\", d1);\n  assert(buf[0] != 0);\n  printf(\"OK\\n\");\n}\n\n",
        "translated_code": "use std::ffi::CStr;\nuse std::os::raw::c_char;\n\npub fn test_floating_point_numbers() {\n    let mut buf = [0u8; 256];\n    let mut f1: f32;\n    let mut d1: f64;\n\n    println!(\"testing floating point... \");\n    f1 = 1.25;\n    assert!(f1 == 1.25);\n    d1 = 1.25;\n    assert!(d1 == 1.25);\n    d1 = 0.0;\n    d1 = f1 as f64;\n    assert!(d1 == 1.25);\n    f1 = 0.0;\n    f1 = d1 as f32;\n    assert!(f1 == 1.25);\n    d1 = 1.234;\n    assert!(AlmostEqualDoubles(d1, 1.234));\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2));\n    d1 = 1.2345;\n    assert!(AlmostEqualDoubles(d1, 1.2345));\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.2345, 2));\n    d1 = \"1.234\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234));\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2));\n    let formatted = format!(\"{}\", d1);\n    unsafe {\n        std::ptr::copy_nonoverlapping(formatted.as_ptr(), buf.as_mut_ptr() as *mut u8, formatted.len());\n    }\n    assert!(buf[0] != 0);\n    assert!(formatted == \"1.234\");\n    d1 = \"12.34\".parse::<f64>().unwrap();\n    assert!(d1 == 12.34);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 12.34, 2));\n    let formatted = format!(\"{}\", d1);\n    unsafe {\n        std::ptr::copy_nonoverlapping(formatted.as_ptr(), buf.as_mut_ptr() as *mut u8, formatted.len());\n    }\n    assert!(buf[0] != 0);\n    assert!(formatted == \"12.34\");\n    d1 = \"1.234e25\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234e25));\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234e25, 2));\n    let formatted = format!(\"{}\", d1);\n    unsafe {\n        std::ptr::copy_nonoverlapping(formatted.as_ptr(), buf.as_mut_ptr() as *mut u8, formatted.len());\n    }\n    assert!(buf[0] != 0);\n    println!(\"OK\");\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "AlmostEqualDoubles",
            "AlmostEqualFloats"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "buf",
            "f1",
            "d1"
        ],
        "calle": [
            "strcmp",
            "assert",
            "sprintf",
            "AlmostEqualDoubles",
            "AlmostEqualFloats",
            "atof",
            "printf"
        ],
        "calle_c": [
            "strcmp",
            "assert",
            "sprintf",
            "atof",
            "printf"
        ],
        "key": "test_floating_point_numbers",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "str_to_date": {
        "source_code": "unsigned short str_to_date(char *datestr)\n{\n  unsigned int datestr_idx = 0;\n  unsigned short date;\n  int day;\n  int month;\n  int year;\n  char *next;\n  unsigned int next_idx = 0;\n  if ((&datestr[datestr_idx]) == 0)\n  {\n    return 0;\n  }\n  strcpy(tmp, datestr);\n  datestr_idx = tmp;\n  next_idx = stripchr(datestr, '-');\n  year = atoi(datestr) - 1900;\n  datestr_idx = &next[next_idx];\n  next_idx = stripchr(datestr, '-');\n  month = atoi(datestr);\n  day = atoi(next);\n  date = ((day << 11) | (month << 7)) | year;\n  return date;\n}\n\n",
        "translated_code": "pub fn str_to_date(datestr: Option<&str>) -> Option<u16> {\n    // Check for None (equivalent to NULL check in C)\n    let datestr = datestr?;\n\n    // Convert the string to bytes for processing\n    let datestr_bytes = datestr.as_bytes();\n    \n    // Use TMP for temporary storage (equivalent to strcpy in C)\n    let mut tmp = TMP.lock().unwrap();\n    if datestr_bytes.len() >= tmp.len() {\n        return Option::None; // Buffer would overflow\n    }\n    tmp[..datestr_bytes.len()].copy_from_slice(datestr_bytes);\n    tmp[datestr_bytes.len()] = 0; // Null-terminate\n\n    // Parse the date components\n    let mut parts = datestr.split('-');\n    \n    let year = parts.next()\n        .and_then(|s| s.parse::<i32>().ok())\n        .map(|y| y - 1900)\n        .unwrap_or(0);\n    \n    let month = parts.next()\n        .and_then(|s| s.parse::<i32>().ok())\n        .unwrap_or(0);\n    \n    let day = parts.next()\n        .and_then(|s| s.parse::<i32>().ok())\n        .unwrap_or(0);\n\n    // Combine into date format (day << 11 | month << 7 | year)\n    let date = ((day << 11) | (month << 7) | year) as u16;\n    Some(date)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [
            "stripchr",
            "tmp"
        ],
        "params": [
            "char *datestr"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "datestr",
            "datestr_idx",
            "date",
            "day",
            "month",
            "year",
            "next",
            "next_idx",
            "tmp"
        ],
        "calle": [
            "strcpy",
            "atoi",
            "stripchr"
        ],
        "calle_c": [
            "strcpy",
            "atoi"
        ],
        "key": "str_to_date",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_create": {
        "source_code": "BOOL binn_create(binn *item, int type, int size, void *pointer)\n{\n  unsigned int pointer_idx = 0;\n  BOOL retval = 0;\n  switch (type)\n  {\n    case 0xE0:\n\n    case 0xE1:\n\n    case 0xE2:\n      break;\n\n    default:\n      goto loc_exit;\n\n  }\n\n  if ((item == 0) || (size < 0))\n  {\n    goto loc_exit;\n  }\n  if (size < 3)\n  {\n    if (pointer)\n    {\n      goto loc_exit;\n    }\n    else\n      size = 0;\n  }\n  memset(item, 0, sizeof(binn));\n  if (pointer)\n  {\n    item->pre_allocated = 1;\n    item->pbuf = &pointer[pointer_idx];\n    item->alloc_size = size;\n  }\n  else\n  {\n    item->pre_allocated = 0;\n    if (size == 0)\n    {\n      size = 256;\n    }\n    pointer_idx = binn_malloc(size);\n    if ((&pointer[pointer_idx]) == 0)\n    {\n      return 0;\n    }\n    item->pbuf = &pointer[pointer_idx];\n    item->alloc_size = size;\n  }\n  item->header = 0x1F22B11F;\n  item->writable = 1;\n  item->used_size = 9;\n  item->type = type;\n  item->dirty = 1;\n  retval = 1;\n  loc_exit:\n  return retval;\n\n}\n\n",
        "translated_code": "pub fn binn_create(item: &mut Option<Box<BinnStruct>>, type_: i32, size: i32, pointer: Option<&mut [u8]>) -> BOOL {\n    let mut retval: BOOL = 0;\n    \n    // Check valid type\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return retval,\n    }\n\n    // Check valid parameters\n    if item.is_none() || size < 0 {\n        return retval;\n    }\n\n    let item = item.as_mut().unwrap();\n\n    // Handle size validation\n    let mut actual_size = size;\n    if size < 3 {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            actual_size = 0;\n        }\n    }\n\n    // Initialize the struct (equivalent to memset)\n    *item = Box::new(BinnStruct {\n        header: 0,\n        allocated: 0,\n        writable: 0,\n        dirty: 0,\n        pbuf: None,\n        pre_allocated: 0,\n        alloc_size: 0,\n        used_size: 0,\n        type_: 0,\n        ptr: None,\n        size: 0,\n        count: 0,\n        freefn: BinnMemFree::None,\n        value: BinnValue {\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: 0,\n        },\n        disable_int_compression: 0,\n    });\n\n    if let Some(_ptr) = pointer {\n        item.pre_allocated = 1;\n        item.pbuf = Some(Box::new(())); // Simplified representation of pointer assignment\n        item.alloc_size = actual_size;\n    } else {\n        item.pre_allocated = 0;\n        let alloc_size = if actual_size == 0 { 256 } else { actual_size };\n        let allocated_ptr = binn_malloc(alloc_size);\n        if allocated_ptr.is_none() {\n            return 0;\n        }\n        item.pbuf = Some(Box::new(())); // Simplified representation of pointer assignment\n        item.alloc_size = alloc_size;\n    }\n\n    item.header = 0x1F22B11F;\n    item.writable = 1;\n    item.used_size = 9;\n    item.type_ = type_;\n    item.dirty = 1;\n    \n    1\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "binn",
            "binn_malloc"
        ],
        "header": "BOOL binn_create(binn *item, int type, int size, void *buffer)",
        "params": [
            "binn *item",
            "int type",
            "int size",
            "void *pointer"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "item",
            "type",
            "size",
            "pointer",
            "pointer_idx",
            "retval"
        ],
        "calle": [
            "memset",
            "binn_malloc"
        ],
        "calle_c": [
            "memset"
        ],
        "key": "binn_create",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_new": {
        "source_code": "binn *binn_new(int type, int size, void *pointer)\n{\n  binn *item;\n  unsigned int item_idx = 0;\n  item_idx = (binn *) binn_malloc(sizeof(binn));\n  if (binn_create(item, type, size, pointer) == 0)\n  {\n    free_fn(item);\n    return 0;\n  }\n  item->allocated = 1;\n  return item;\n}\n\n",
        "translated_code": "pub fn binn_new(type_: i32, size: i32, pointer: Option<&mut [u8]>) -> Option<Box<BinnStruct>> {\n    // Allocate memory for the binn item\n    let item = match binn_malloc(std::mem::size_of::<BinnStruct>() as i32) {\n        Some(alloc) => {\n            // Try to downcast the allocation to our specific type\n            match alloc.downcast::<BinnStruct>() {\n                Ok(boxed) => Some(boxed),\n                Err(e) => {\n                    // If downcast fails, free the allocation\n                    if let Some(free_fn) = &mut *FREE_FN.lock().unwrap() {\n                        (free_fn.0)(None);\n                    }\n                    return None;\n                }\n            }\n        }\n        None => return None,\n    };\n\n    // Create the binn item\n    let mut item = item;\n    if binn_create(&mut item, type_, size, pointer) == 0 {\n        // If creation fails, free the item\n        if let Some(free_fn) = &mut *FREE_FN.lock().unwrap() {\n            if let Some(item) = item {\n                (free_fn.0)(Some(Box::new(item) as Box<dyn std::any::Any + Send>));\n            } else {\n                (free_fn.0)(None);\n            }\n        }\n        return None;\n    }\n\n    // Set the allocated flag and return the item\n    if let Some(item) = &mut item {\n        item.allocated = 1;\n    }\n    item\n}\n\ntrait IntoSend {\n    fn into_send(self) -> Box<dyn std::any::Any + Send>;\n}\n\nimpl IntoSend for Box<BinnStruct> {\n    fn into_send(self) -> Box<dyn std::any::Any + Send> {\n        Box::new(self) as Box<dyn std::any::Any + Send>\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_create",
            "binn_malloc",
            "free_fn"
        ],
        "header": "binn *binn_new(int type, int size, void *buffer)",
        "params": [
            "int type",
            "int size",
            "void *pointer"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "type",
            "size",
            "pointer",
            "item",
            "item_idx",
            "free_fn"
        ],
        "calle": [
            "binn_malloc",
            "binn_create",
            "free_fn"
        ],
        "calle_c": [
            "free_fn"
        ],
        "key": "binn_new",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_list": {
        "source_code": "binn *binn_list()\n{\n  return binn_new(0xE0, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_list() -> Option<Box<BinnStruct>> {\n    binn_new(0xE0, 0, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_new"
        ],
        "header": "binn *binn_list()",
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [
            "binn_new"
        ],
        "calle_c": [],
        "key": "binn_list",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map": {
        "source_code": "binn *binn_map()\n{\n  return binn_new(0xE1, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_map() -> Option<Box<BinnStruct>> {\n    binn_new(0xE1, 0, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_new"
        ],
        "header": "binn *binn_map()",
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [
            "binn_new"
        ],
        "calle_c": [],
        "key": "binn_map",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object": {
        "source_code": "binn *binn_object()\n{\n  return binn_new(0xE2, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_object() -> Option<Box<BinnStruct>> {\n    binn_new(0xE2, 0, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_new"
        ],
        "header": "binn *binn_object()",
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [
            "binn_new"
        ],
        "calle_c": [],
        "key": "binn_object",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_create_list": {
        "source_code": "BOOL binn_create_list(binn *list)\n{\n  return binn_create(list, 0xE0, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_create_list(list: &mut Option<Box<BinnStruct>>) -> BOOL {\n    binn_create(list, 0xE0, 0, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_create"
        ],
        "header": "BOOL binn_create_list(binn *list)",
        "params": [
            "binn *list"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list"
        ],
        "calle": [
            "binn_create"
        ],
        "calle_c": [],
        "key": "binn_create_list",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_create_map": {
        "source_code": "BOOL binn_create_map(binn *map)\n{\n  return binn_create(map, 0xE1, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_create_map(map: &mut Option<Box<BinnStruct>>) -> BOOL {\n    binn_create(map, 0xE1, 0, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_create"
        ],
        "header": "BOOL binn_create_map(binn *map)",
        "params": [
            "binn *map"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map"
        ],
        "calle": [
            "binn_create"
        ],
        "calle_c": [],
        "key": "binn_create_map",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_create_object": {
        "source_code": "BOOL binn_create_object(binn *object)\n{\n  return binn_create(object, 0xE2, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_create_object(object: &mut Option<Box<BinnStruct>>) -> BOOL {\n    binn_create(object, 0xE2, 0, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_create"
        ],
        "header": "BOOL binn_create_object(binn *object)",
        "params": [
            "binn *object"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "object"
        ],
        "calle": [
            "binn_create"
        ],
        "calle_c": [],
        "key": "binn_create_object",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_free": {
        "source_code": "void binn_free(binn *item)\n{\n  if (item == 0)\n  {\n    return;\n  }\n  if (item->writable && (item->pre_allocated == 0))\n  {\n    free_fn(item->pbuf);\n  }\n  if (item->freefn)\n  {\n    item->freefn(item->ptr);\n  }\n  if (item->allocated)\n  {\n    free_fn(item);\n  }\n  else\n  {\n    memset(item, 0, sizeof(binn));\n    item->header = 0x1F22B11F;\n  }\n}\n\n",
        "translated_code": "pub fn binn_free(item: &mut Option<Box<BinnStruct>>) {\n    if item.is_none() {\n        return;\n    }\n\n    let mut item = item.take().unwrap(); // Take ownership of the Box\n\n    if item.writable != 0 && item.pre_allocated == 0 {\n        if let Some(pbuf) = item.pbuf.take() {\n            if let Some(free_fn) = FREE_FN.lock().unwrap().as_mut() {\n                free_fn.0(Some(Box::new(pbuf) as Box<dyn std::any::Any + Send>));\n            }\n        }\n    }\n\n    if item.freefn.is_some() {\n        if let Some(ptr) = item.ptr.take() {\n            item.freefn.as_mut().unwrap()(Some(ptr));\n        }\n    }\n\n    if item.allocated != 0 {\n        if let Some(free_fn) = FREE_FN.lock().unwrap().as_mut() {\n            free_fn.0(Some(Box::new(item) as Box<dyn std::any::Any + Send>));\n        }\n    } else {\n        // Equivalent to memset(item, 0, sizeof(binn))\n        *item = BinnStruct {\n            header: 0x1F22B11F,\n            allocated: 0,\n            writable: 0,\n            dirty: 0,\n            pbuf: None,\n            pre_allocated: 0,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: None,\n            size: 0,\n            count: 0,\n            freefn: None,\n            value: BinnValue {\n                vint8: 0,\n                vint16: 0,\n                vint32: 0,\n                vint64: 0,\n                vuint8: 0,\n                vuint16: 0,\n                vuint32: 0,\n                vuint64: 0,\n                vchar: 0,\n                vuchar: 0,\n                vshort: 0,\n                vushort: 0,\n                vint: 0,\n                vuint: 0,\n                vfloat: 0.0,\n                vdouble: 0.0,\n                vbool: 0,\n            },\n            disable_int_compression: 0,\n        };\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "free_fn"
        ],
        "header": "void binn_free(binn *item)",
        "params": [
            "binn *item"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "item",
            "free_fn"
        ],
        "calle": [
            "item->freefn",
            "memset",
            "free_fn"
        ],
        "calle_c": [
            "item->freefn",
            "memset",
            "free_fn"
        ],
        "key": "binn_free",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_load": {
        "source_code": "BOOL binn_load(void *data, binn *value)\n{\n  if ((data == 0) || (value == 0))\n  {\n    return 0;\n  }\n  memset(value, 0, sizeof(binn));\n  value->header = 0x1F22B11F;\n  if (binn_is_valid(data, &value->type, &value->count, &value->size) == 0)\n  {\n    return 0;\n  }\n  value->ptr = data;\n  return 1;\n}\n\n",
        "translated_code": "pub fn binn_load(data: Option<*mut u8>, mut value: Option<&mut BinnStruct>) -> bool {\n    // Check for null pointers (represented as None in Rust)\n    if data.is_none() || value.is_none() {\n        return false;\n    }\n\n    // Get mutable reference to value\n    let value = value.as_mut().unwrap();\n\n    // Equivalent to memset - zero out the struct\n    **value = BinnStruct {\n        header: 0,\n        allocated: 0,\n        writable: 0,\n        dirty: 0,\n        pbuf: None,\n        pre_allocated: 0,\n        alloc_size: 0,\n        used_size: 0,\n        type_: 0,\n        ptr: None,\n        size: 0,\n        count: 0,\n        freefn: None,\n        value: BinnValue {\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: 0,\n        },\n        disable_int_compression: 0,\n    };\n\n    value.header = 0x1F22B11F;\n\n    // Call binn_is_valid with references to value's fields\n    if !binn_is_valid(data, Some(&mut value.type_), Some(&mut value.count), Some(&mut value.size)) {\n        return false;\n    }\n\n    // Set the pointer field - requires unsafe block for raw pointer operations\n    unsafe {\n        value.ptr = Some(Box::from_raw(data.unwrap() as *mut ()));\n    }\n\n    true\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_is_valid"
        ],
        "header": "BOOL binn_load(void *data, binn *item)",
        "params": [
            "void *data",
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "data",
            "value"
        ],
        "calle": [
            "memset",
            "binn_is_valid"
        ],
        "calle_c": [
            "memset"
        ],
        "key": "binn_load",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_int64": {
        "source_code": "int64 binn_list_int64(void *list, int pos)\n{\n  int64 value;\n  binn_list_get(list, pos, 0x81, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_list_int64(list: Option<&[u8]>, pos: i32) -> int64 {\n    let mut value: int64 = 0;\n    binn_list_get(list, pos, 0x81, Some(&mut value), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get",
            "int64"
        ],
        "header": "int64 binn_list_int64(void *list, int pos)",
        "params": [
            "void *list",
            "int pos"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "value"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_int64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_bool": {
        "source_code": "BOOL binn_list_bool(void *list, int pos)\n{\n  BOOL value;\n  binn_list_get(list, pos, 0x80061, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_list_bool(list: Option<&[u8]>, pos: i32) -> BOOL {\n    let mut value: BOOL = 0;\n    binn_list_get(list, pos, 0x80061, Some(&mut value), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "binn_list_get"
        ],
        "header": "BOOL binn_list_bool(void *list, int pos)",
        "params": [
            "void *list",
            "int pos"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "value"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_bool",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_int64": {
        "source_code": "int64 binn_map_int64(void *map, int id)\n{\n  int64 value;\n  binn_map_get(map, id, 0x81, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "use std::any::Any;\n\npub fn binn_map_int64(map: Option<&[u8]>, id: i32) -> int64 {\n    let mut value: int64 = 0;\n    binn_map_get(map, id, 0x81, Some(&mut value as &mut dyn Any), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get",
            "int64"
        ],
        "header": "int64 binn_map_int64(void *map, int id)",
        "params": [
            "void *map",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_int64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_bool": {
        "source_code": "BOOL binn_map_bool(void *map, int id)\n{\n  BOOL value;\n  binn_map_get(map, id, 0x80061, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_map_bool(map: Option<&[u8]>, id: i32) -> BOOL {\n    let mut value: BOOL = 0;\n    binn_map_get(map, id, 0x80061, Some(&mut value), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "binn_map_get"
        ],
        "header": "BOOL binn_map_bool(void *map, int id)",
        "params": [
            "void *map",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_bool",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_int64": {
        "source_code": "int64 binn_object_int64(void *obj, const char *key)\n{\n  int64 value;\n  binn_object_get(obj, key, 0x81, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_int64(obj: Option<&[u8]>, key: Option<&str>) -> int64 {\n    let mut value: int64 = 0;\n    binn_object_get(obj, key, 0x81, Some(&mut value as &mut dyn Any), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get",
            "int64"
        ],
        "header": "int64 binn_object_int64(void *obj, const char *key)",
        "params": [
            "void *obj",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_int64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_bool": {
        "source_code": "BOOL binn_object_bool(void *obj, const char *key)\n{\n  BOOL value;\n  binn_object_get(obj, key, 0x80061, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_bool(obj: Option<&[u8]>, key: Option<&str>) -> BOOL {\n    let mut value: BOOL = 0;\n    binn_object_get(obj, key, 0x80061, Some(&mut value), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "binn_object_get"
        ],
        "header": "BOOL binn_object_bool(void *obj, const char *key)",
        "params": [
            "void *obj",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_bool",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_read_pair": {
        "source_code": "static BOOL binn_read_pair(int expected_type, void *ptr, int pos, int *pid, char *pkey, binn *value)\n{\n  unsigned int ptr_idx = 0;\n  int type;\n  int count;\n  int size = 0;\n  int header_size;\n  int i;\n  int int32;\n  int id = 0;\n  int counter = 0;\n  unsigned char *p;\n  unsigned int p_idx = 0;\n  unsigned char *plimit;\n  unsigned int plimit_idx = 0;\n  unsigned char *base;\n  unsigned int base_idx = 0;\n  unsigned char *key = 0;\n  unsigned int key_idx = 0;\n  unsigned char len = 0;\n  ptr_idx = binn_ptr(ptr_idx);\n  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == 0)\n  {\n    return 0;\n  }\n  if ((((type != expected_type) || (count == 0)) || (pos < 1)) || (pos > count))\n  {\n    return 0;\n  }\n  p_idx = (unsigned char *) ptr;\n  base_idx = &p[p_idx];\n  plimit_idx = ((&p[p_idx]) + size) - 1;\n  p_idx += header_size;\n  for (i = 0; i < count; i += 1)\n  {\n    switch (type)\n    {\n      case 0xE1:\n        int32 = read_map_id(&(&p[p_idx]), plimit);\n        if ((&p[p_idx]) > (&plimit[plimit_idx]))\n      {\n        return 0;\n      }\n        id = int32;\n        break;\n\n      case 0xE2:\n        len = *((unsigned char *) p);\n        p_idx += 1;\n        if ((&p[p_idx]) > (&plimit[plimit_idx]))\n      {\n        return 0;\n      }\n        key_idx = &p[p_idx];\n        p_idx += len;\n        if ((&p[p_idx]) > (&plimit[plimit_idx]))\n      {\n        return 0;\n      }\n        break;\n\n    }\n\n    counter += 1;\n    if (counter == pos)\n    {\n      goto found;\n    }\n    p_idx = AdvanceDataPos(p_idx, plimit);\n    if (((&p[p_idx]) == 0) || ((&p[p_idx]) < (&base[base_idx])))\n    {\n      return 0;\n    }\n  }\n\n  return 0;\n  found:\n  switch (type)\n  {\n    case 0xE1:\n      if (pid)\n    {\n      *pid = id;\n    }\n      break;\n\n    case 0xE2:\n      if (pkey)\n    {\n      memcpy(pkey, key, len);\n      pkey[len] = 0;\n    }\n      break;\n\n  }\n\n\n  return GetValue(p, value);\n}\n\n",
        "translated_code": "pub fn binn_read_pair(\n    expected_type: i32,\n    ptr: Option<&[u8]>,\n    pos: i32,\n    pid: Option<&mut i32>,\n    pkey: Option<&mut [u8]>,\n    value: Option<&mut binn>,\n) -> BOOL {\n    let ptr = match ptr {\n        Some(p) => p,\n        None => return 0,\n    };\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if !IsValidBinnHeader(\n        Some(ptr),\n        Some(&mut type_),\n        Some(&mut count),\n        Some(&mut size),\n        Some(&mut header_size),\n    ) {\n        return 0;\n    }\n\n    if type_ != expected_type || count == 0 || pos < 1 || pos > count {\n        return 0;\n    }\n\n    let p = ptr;\n    let base = p;\n    let plimit = &p[(size as usize) - 1..];\n    let mut p_idx = header_size as usize;\n\n    let mut id = 0;\n    let mut counter = 0;\n    let mut key: Option<&[u8]> = None;\n    let mut len = 0;\n\n    for _ in 0..count {\n        match type_ {\n            0xE1 => {\n                let mut current_p = &p[p_idx..];\n                let int32 = match read_map_id(&mut current_p, plimit) {\n                    Some(v) => v,\n                    None => return 0,\n                };\n                p_idx = p.len() - current_p.len();\n                if p_idx > plimit.len() {\n                    return 0;\n                }\n                id = int32;\n            }\n            0xE2 => {\n                len = p[p_idx];\n                p_idx += 1;\n                if p_idx > plimit.len() {\n                    return 0;\n                }\n                let end = p_idx + len as usize;\n                key = Some(&p[p_idx..end]);\n                p_idx += len as usize;\n                if p_idx > plimit.len() {\n                    return 0;\n                }\n            }\n            _ => (),\n        }\n\n        counter += 1;\n        if counter == pos {\n            break;\n        }\n\n        let remaining = &p[p_idx..];\n        let new_pos = match AdvanceDataPos(remaining, plimit.len()) {\n            Some(p) => p,\n            None => return 0,\n        };\n        p_idx = p.len() - new_pos.len();\n        if p_idx == 0 || p_idx < base.len() {\n            return 0;\n        }\n    }\n\n    if counter != pos {\n        return 0;\n    }\n\n    match type_ {\n        0xE1 => {\n            if let Some(pid) = pid {\n                *pid = id;\n            }\n        }\n        0xE2 => {\n            if let (Some(pkey), Some(key), Some(len)) = (pkey, key, Some(len)) {\n                if pkey.len() >= len as usize + 1 {\n                    pkey[..len as usize].copy_from_slice(&key[..len as usize]);\n                    pkey[len as usize] = 0;\n                }\n            }\n        }\n        _ => (),\n    }\n\n    GetValue(Some(&p[p_idx..]), value)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "AdvanceDataPos",
            "GetValue",
            "IsValidBinnHeader",
            "binn",
            "binn_ptr",
            "read_map_id"
        ],
        "params": [
            "int expected_type",
            "void *ptr",
            "int pos",
            "int *pid",
            "char *pkey",
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "expected_type",
            "ptr",
            "pos",
            "pid",
            "pkey",
            "value",
            "ptr_idx",
            "type",
            "count",
            "size",
            "header_size",
            "i",
            "int32",
            "id",
            "counter",
            "p",
            "p_idx",
            "plimit",
            "plimit_idx",
            "base",
            "base_idx",
            "key",
            "key_idx",
            "len"
        ],
        "calle": [
            "memcpy",
            "binn_ptr",
            "GetValue",
            "IsValidBinnHeader",
            "read_map_id",
            "AdvanceDataPos"
        ],
        "calle_c": [
            "memcpy"
        ],
        "key": "binn_read_pair",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_map_get_pair": {
        "source_code": "BOOL binn_map_get_pair(void *ptr, int pos, int *pid, binn *value)\n{\n  return binn_read_pair(0xE1, ptr, pos, pid, 0, value);\n}\n\n",
        "translated_code": "pub fn binn_map_get_pair(\n    ptr: Option<&[u8]>,\n    pos: i32,\n    pid: Option<&mut i32>,\n    value: Option<&mut binn>,\n) -> BOOL {\n    binn_read_pair(0xE1, ptr, pos, pid, None, value)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_read_pair"
        ],
        "header": "BOOL binn_map_get_pair(void *map, int pos, int *pid, binn *value)",
        "params": [
            "void *ptr",
            "int pos",
            "int *pid",
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "pos",
            "pid",
            "value"
        ],
        "calle": [
            "binn_read_pair"
        ],
        "calle_c": [],
        "key": "binn_map_get_pair",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_get_pair": {
        "source_code": "BOOL binn_object_get_pair(void *ptr, int pos, char *pkey, binn *value)\n{\n  return binn_read_pair(0xE2, ptr, pos, 0, pkey, value);\n}\n\n",
        "translated_code": "pub fn binn_object_get_pair(\n    ptr: Option<&[u8]>,\n    pos: i32,\n    pkey: Option<&mut [u8]>,\n    value: Option<&mut binn>,\n) -> BOOL {\n    binn_read_pair(0xE2, ptr, pos, None, pkey, value)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_read_pair"
        ],
        "header": "BOOL binn_object_get_pair(void *obj, int pos, char *pkey, binn *value)",
        "params": [
            "void *ptr",
            "int pos",
            "char *pkey",
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "pos",
            "pkey",
            "value"
        ],
        "calle": [
            "binn_read_pair"
        ],
        "calle_c": [],
        "key": "binn_object_get_pair",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_int64": {
        "source_code": "inline static binn *binn_int64(int64 value)\n{\n  return binn_value(0x81, &value, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_int64(value: int64) -> Option<Box<BinnStruct>> {\n    binn_value(0x81, Some(&value.to_ne_bytes()), 0, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_value",
            "int64"
        ],
        "params": [
            "int64 value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value"
        ],
        "calle": [
            "binn_value"
        ],
        "calle_c": [],
        "key": "binn_int64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_bool": {
        "source_code": "inline static binn *binn_bool(BOOL value)\n{\n  return binn_value(0x80061, &value, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_bool(value: BOOL) -> Option<Box<BinnStruct>> {\n    binn_value(0x80061, Some(&value.to_ne_bytes()), 0, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "binn",
            "binn_value"
        ],
        "params": [
            "BOOL value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value"
        ],
        "calle": [
            "binn_value"
        ],
        "calle_c": [],
        "key": "binn_bool",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_string": {
        "source_code": "inline static binn *binn_string(char *str, binn_mem_free freefn)\n{\n  return binn_value(0xA0, str, 0, freefn);\n}\n\n",
        "translated_code": "pub fn binn_string(str: Option<&str>, freefn: Option<Box<dyn FnMut(Option<Box<()>>)>>) -> Option<Box<BinnStruct>> {\n    // Convert the string to bytes if it exists, otherwise pass None\n    let str_bytes = str.map(|s| s.as_bytes());\n    binn_value(0xA0, str_bytes, 0, freefn)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_mem_free",
            "binn_value"
        ],
        "params": [
            "char *str",
            "binn_mem_free freefn"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "str",
            "freefn"
        ],
        "calle": [
            "binn_value"
        ],
        "calle_c": [],
        "key": "binn_string",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_blob": {
        "source_code": "inline static binn *binn_blob(void *ptr, int size, binn_mem_free freefn)\n{\n  return binn_value(0xC0, ptr, size, freefn);\n}\n\n",
        "translated_code": "pub fn binn_blob(\n    ptr: Option<&[u8]>,\n    size: i32,\n    freefn: Option<Box<dyn FnMut(Option<Box<()>>)>>,\n) -> Option<Box<BinnStruct>> {\n    binn_value(0xC0, ptr, size, freefn)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_mem_free",
            "binn_value"
        ],
        "params": [
            "void *ptr",
            "int size",
            "binn_mem_free freefn"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "size",
            "freefn"
        ],
        "calle": [
            "binn_value"
        ],
        "calle_c": [],
        "key": "binn_blob",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add_int64": {
        "source_code": "inline static BOOL binn_list_add_int64(binn *list, int64 value)\n{\n  return binn_list_add(list, 0x81, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_add_int64(list: &mut Option<Box<BinnStruct>>, value: int64) -> BOOL {\n    binn_list_add(list, 0x81, Some(&mut Some(Box::new(value))), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_add",
            "int64"
        ],
        "params": [
            "binn *list",
            "int64 value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "value"
        ],
        "calle": [
            "binn_list_add"
        ],
        "calle_c": [],
        "key": "binn_list_add_int64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add_bool": {
        "source_code": "inline static BOOL binn_list_add_bool(binn *list, BOOL value)\n{\n  return binn_list_add(list, 0x80061, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_add_bool(list: &mut Option<Box<BinnStruct>>, value: BOOL) -> BOOL {\n    binn_list_add(list, 0x80061, Some(&mut Some(Box::new(value))), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "binn",
            "binn_list_add"
        ],
        "params": [
            "binn *list",
            "BOOL value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "value"
        ],
        "calle": [
            "binn_list_add"
        ],
        "calle_c": [],
        "key": "binn_list_add_bool",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_int64": {
        "source_code": "inline static BOOL binn_map_set_int64(binn *map, int id, int64 value)\n{\n  return binn_map_set(map, id, 0x81, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_set_int64(map: &mut Option<Box<BinnStruct>>, id: i32, value: i64) -> BOOL {\n    binn_map_set(map, id, 0x81, Some(&mut Some(Box::new(value))), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_set",
            "int64"
        ],
        "params": [
            "binn *map",
            "int id",
            "int64 value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_set"
        ],
        "calle_c": [],
        "key": "binn_map_set_int64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_bool": {
        "source_code": "inline static BOOL binn_map_set_bool(binn *map, int id, BOOL value)\n{\n  return binn_map_set(map, id, 0x80061, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_set_bool(map: &mut Option<Box<BinnStruct>>, id: i32, value: BOOL) -> BOOL {\n    let mut boxed_value = Some(Box::new(value) as Box<dyn std::any::Any>);\n    binn_map_set(map, id, 0x80061, Some(&mut boxed_value), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "binn",
            "binn_map_set"
        ],
        "params": [
            "binn *map",
            "int id",
            "BOOL value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_set"
        ],
        "calle_c": [],
        "key": "binn_map_set_bool",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_int64": {
        "source_code": "inline static BOOL binn_object_set_int64(binn *obj, const char *key, int64 value)\n{\n  return binn_object_set(obj, key, 0x81, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_set_int64(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    value: int64,\n) -> BOOL {\n    let mut boxed_value = Some(Box::new(value) as Box<dyn std::any::Any>);\n    binn_object_set(obj, key, 0x81, Some(&mut boxed_value), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_set",
            "int64"
        ],
        "params": [
            "binn *obj",
            "const char *key",
            "int64 value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_set"
        ],
        "calle_c": [],
        "key": "binn_object_set_int64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_bool": {
        "source_code": "inline static BOOL binn_object_set_bool(binn *obj, const char *key, BOOL value)\n{\n  return binn_object_set(obj, key, 0x80061, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_set_bool(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    value: BOOL,\n) -> BOOL {\n    let mut boxed_value: Option<Box<dyn std::any::Any>> = Some(Box::new(value));\n    binn_object_set(obj, key, 0x80061, Some(&mut boxed_value), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "binn",
            "binn_object_set"
        ],
        "params": [
            "binn *obj",
            "const char *key",
            "BOOL value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_set"
        ],
        "calle_c": [],
        "key": "binn_object_set_bool",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_get_uint64": {
        "source_code": "inline static BOOL binn_list_get_uint64(void *list, int pos, uint64 *pvalue)\n{\n  return binn_list_get(list, pos, 0x80, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_get_uint64(list: Option<&[u8]>, pos: i32, pvalue: Option<&mut uint64>) -> BOOL {\n    binn_list_get(list, pos, 0x80, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get",
            "int64",
            "uint64"
        ],
        "params": [
            "void *list",
            "int pos",
            "uint64 *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "pvalue"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_get_uint64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_get_uint64": {
        "source_code": "inline static BOOL binn_map_get_uint64(void *map, int id, uint64 *pvalue)\n{\n  return binn_map_get(map, id, 0x80, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_get_uint64(\n    map: Option<&[u8]>,\n    id: i32,\n    pvalue: Option<&mut uint64>,\n) -> BOOL {\n    binn_map_get(map, id, 0x80, pvalue.map(|v| v as &mut dyn std::any::Any), None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get",
            "int64",
            "uint64"
        ],
        "params": [
            "void *map",
            "int id",
            "uint64 *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "pvalue"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_get_uint64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_get_uint64": {
        "source_code": "inline static BOOL binn_object_get_uint64(void *obj, const char *key, uint64 *pvalue)\n{\n  return binn_object_get(obj, key, 0x80, pvalue, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_get_uint64(obj: Option<&[u8]>, key: Option<&str>, pvalue: Option<&mut uint64>) -> bool {\n    // Convert the uint64 reference to a mutable Any reference for compatibility with binn_object_get\n    let pvalue_any = pvalue.map(|v| v as &mut dyn Any);\n    \n    // Call binn_object_get with the appropriate type code (0x80 for uint64)\n    binn_object_get(obj, key, 0x80, pvalue_any, None) != 0\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get",
            "int64",
            "uint64"
        ],
        "params": [
            "void *obj",
            "const char *key",
            "uint64 *pvalue"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "pvalue"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_get_uint64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_size": {
        "source_code": "int binn_size(void *ptr)\n{\n  binn *item;\n  unsigned int item_idx = 0;\n  switch (binn_get_ptr_type(ptr))\n  {\n    case 1:\n      item_idx = (binn *) ptr;\n      if (item->writable && item->dirty)\n    {\n      binn_save_header(item);\n    }\n      return item->size;\n\n    case 2:\n      return binn_buf_size(ptr);\n\n    default:\n      return 0;\n\n  }\n\n}\n\n",
        "translated_code": "pub fn binn_size(ptr: Option<*mut u8>) -> i32 {\n    let item_idx: u32;\n    match binn_get_ptr_type(ptr) {\n        1 => {\n            let item = unsafe { Box::from_raw(ptr.unwrap() as *mut BinnStruct) };\n            let mut item = Some(Box::new(*item));\n            \n            let needs_save = {\n                let item_ref = item.as_ref().unwrap();\n                item_ref.writable != 0 && item_ref.dirty != 0\n            };\n            \n            if needs_save {\n                binn_save_header(&mut item);\n            }\n            \n            let size = item.as_ref().unwrap().size;\n            Box::into_raw(item.unwrap()); // Prevent double-free\n            size\n        },\n        2 => binn_buf_size(None), // Assuming ptr can be converted to Option<&[u8]>\n        _ => 0,\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_buf_size",
            "binn_get_ptr_type",
            "binn_save_header"
        ],
        "header": "int binn_size(void *ptr)",
        "params": [
            "void *ptr"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "item",
            "item_idx"
        ],
        "calle": [
            "binn_buf_size",
            "binn_get_ptr_type",
            "binn_save_header"
        ],
        "calle_c": [],
        "key": "binn_size",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "print_binn": {
        "source_code": "void print_binn(binn *map)\n{\n  unsigned char *p;\n  unsigned int p_idx = 0;\n  int size;\n  int i;\n  p_idx = binn_ptr(map);\n  size = binn_size(map);\n  for (i = 0; i < size; i += 1)\n  {\n    printf(\"%02x \", p[i + p_idx]);\n  }\n\n  puts(\"\");\n}\n\n",
        "translated_code": "use std::ffi::CStr;\nuse std::os::raw::c_char;\n\npub fn print_binn(map: Option<Box<BinnStruct>>) {\n    // Get the pointer and size from the binn struct\n    let p_idx = binn_ptr(map.as_ref().map(|m| m.ptr.as_ref().map(|p| p.as_ref() as *const _ as *mut u8)).flatten());\n    let size = binn_size(map.as_ref().map(|m| m.ptr.as_ref().map(|p| p.as_ref() as *const _ as *mut u8)).flatten());\n\n    // If we have valid pointer and size, print the bytes\n    if let (Some(p_idx), Some(size)) = (p_idx, Some(size)) {\n        // Convert raw pointer to slice (unsafe required here)\n        unsafe {\n            let slice = std::slice::from_raw_parts(p_idx as *const u8, size as usize);\n            for byte in slice {\n                print!(\"{:02x} \", byte);\n            }\n        }\n    }\n\n    println!(); // Equivalent to puts(\"\") in C\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_ptr",
            "binn_size"
        ],
        "params": [
            "binn *map"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "p",
            "p_idx",
            "size",
            "i"
        ],
        "calle": [
            "puts",
            "binn_ptr",
            "printf",
            "binn_size"
        ],
        "calle_c": [
            "puts",
            "printf"
        ],
        "key": "print_binn",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "currency_to_str": {
        "source_code": "char *currency_to_str(int64 value)\n{\n  char *str;\n  unsigned int str_idx = 0;\n  char *ptr;\n  unsigned int ptr_idx = 0;\n  int size;\n  int move;\n  int i;\n  i64toa(value, tmp, 10);\n  str_idx = tmp;\n  size = strlen(str);\n  if (size > 4)\n  {\n    ptr_idx = ((&str[str_idx]) + size) - 4;\n    memmove((&ptr[ptr_idx]) + 1, ptr, 4 + 1);\n    ptr[0 + ptr_idx] = '.';\n  }\n  else\n  {\n    move = (2 + 4) - size;\n    memmove((&str[str_idx]) + move, str, size + 1);\n    str[0 + str_idx] = '0';\n    str[1 + str_idx] = '.';\n    for (i = 2; i < move; i += 1)\n    {\n      str[i + str_idx] = '0';\n    }\n\n  }\n  return str;\n}\n\n",
        "translated_code": "use std::mem;\n\npub fn currency_to_str(value: int64) -> Option<String> {\n    // Convert the int64 to a string representation\n    let mut tmp = TMP.lock().unwrap();\n    let str_slice = i64toa(value, &mut *tmp, 10)?;\n    let mut str_bytes = str_slice.to_vec();\n\n    let size = str_bytes.len();\n    \n    if size > 4 {\n        // Handle case where we need to insert a decimal point 4 digits from the end\n        let split_pos = size - 4;\n        let mut new_str = Vec::with_capacity(size + 1);\n        \n        // Add part before decimal\n        new_str.extend_from_slice(&str_bytes[..split_pos]);\n        new_str.push(b'.');\n        // Add part after decimal\n        new_str.extend_from_slice(&str_bytes[split_pos..]);\n        \n        str_bytes = new_str;\n    } else {\n        // Handle case where we need to pad with zeros and add \"0.\"\n        let mut new_str = Vec::with_capacity(6); // \"0.0000\" + null terminator\n        \n        new_str.push(b'0');\n        new_str.push(b'.');\n        \n        // Add leading zeros\n        for _ in 0..(4 - size) {\n            new_str.push(b'0');\n        }\n        \n        // Add the actual number\n        new_str.extend_from_slice(&str_bytes);\n        \n        str_bytes = new_str;\n    }\n\n    // Convert to String, checking for UTF-8 validity\n    String::from_utf8(str_bytes).ok()\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [
            "i64toa",
            "int64",
            "tmp"
        ],
        "params": [
            "int64 value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value",
            "str",
            "str_idx",
            "ptr",
            "ptr_idx",
            "size",
            "move",
            "i",
            "tmp"
        ],
        "calle": [
            "memmove",
            "i64toa",
            "strlen"
        ],
        "calle_c": [
            "memmove",
            "strlen"
        ],
        "key": "currency_to_str",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "currency_to_float": {
        "source_code": "double currency_to_float(int64 value)\n{\n  currency_to_str(value);\n  return atof(tmp);\n}\n\n",
        "translated_code": "use std::str::FromStr;\n\npub fn currency_to_float(value: int64) -> Option<f64> {\n    // Call currency_to_str to get the string representation\n    let currency_str = currency_to_str(value)?;\n    \n    // Parse the string into f64, returning None if parsing fails\n    f64::from_str(&currency_str).ok()\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [
            "currency_to_str",
            "int64",
            "tmp"
        ],
        "params": [
            "int64 value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value",
            "tmp"
        ],
        "calle": [
            "currency_to_str",
            "atof"
        ],
        "calle_c": [
            "atof"
        ],
        "key": "currency_to_float",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_set_alloc_functions": {
        "source_code": "void binn_set_alloc_functions(void *(*new_malloc)(size_t), void *(*new_realloc)(void *, size_t), void (*new_free)(void *))\n{\n  malloc_fn = new_malloc;\n  realloc_fn = new_realloc;\n  free_fn = new_free;\n}\n\n",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::Mutex;\n\npub fn binn_set_alloc_functions(\n    new_malloc: Option<fn(usize) -> Option<Box<dyn std::any::Any>>>,\n    new_realloc: Option<Box<dyn FnMut(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>> + Send>>,\n    new_free: Option<Box<dyn FnMut(Option<Box<dyn std::any::Any + Send>>)>>,\n) {\n    if let Some(malloc) = new_malloc {\n        *MALLOC_FN.lock().unwrap() = Some(malloc);\n    }\n    \n    if let Some(realloc) = new_realloc {\n        *REALLOC_FN.lock().unwrap() = Some(ReallocFnWrapper(realloc));\n    }\n    \n    if let Some(free) = new_free {\n        *FREE_FN.lock().unwrap() = Some(FreeFnWrapper(free));\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "free_fn",
            "malloc_fn",
            "realloc_fn"
        ],
        "header": "void binn_set_alloc_functions(void *(*new_malloc)(size_t), void *(*new_realloc)(void *, size_t), void (*new_free)(void *))",
        "params": [
            "void *(*new_malloc)(size_t)",
            "void *(*new_realloc)(void *, size_t)",
            "void (*new_free)(void *)"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "new_malloc",
            "new_realloc",
            "new_free",
            "malloc_fn",
            "realloc_fn",
            "free_fn"
        ],
        "calle": [],
        "calle_c": [],
        "key": "binn_set_alloc_functions",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_release": {
        "source_code": "void *binn_release(binn *item)\n{\n  void *data;\n  unsigned int data_idx = 0;\n  if (item == 0)\n  {\n    return 0;\n  }\n  data_idx = binn_ptr(item);\n  if ((&data[data_idx]) > item->pbuf)\n  {\n    memmove(item->pbuf, data, item->size);\n    data_idx = item->pbuf;\n  }\n  if (item->allocated)\n  {\n    free_fn(item);\n  }\n  else\n  {\n    memset(item, 0, sizeof(binn));\n    item->header = 0x1F22B11F;\n  }\n  return data;\n}\n\n",
        "translated_code": "pub fn binn_release(item: binn) -> Option<Box<()>> {\n    if item.is_none() {\n        return None;\n    }\n\n    let mut item = item.unwrap();\n    let item_ptr = Box::into_raw(item);\n    let data_idx = binn_ptr(Some(item_ptr as *mut u8));\n    let mut item = unsafe { Box::from_raw(item_ptr) }; // Reconstruct the Box after getting the pointer\n\n    if let Some(data_idx) = data_idx {\n        if let Some(pbuf) = item.pbuf.take() { // Use take() to move out of the option\n            let pbuf_ptr = Box::into_raw(pbuf) as *mut u8;\n            if data_idx > pbuf_ptr {\n                unsafe {\n                    ptr::copy(\n                        data_idx,\n                        pbuf_ptr,\n                        item.size as usize\n                    );\n                    item.pbuf = Some(Box::from_raw(pbuf_ptr as *mut ()));\n                }\n            } else {\n                // Put back if we didn't use it\n                item.pbuf = Some(unsafe { Box::from_raw(pbuf_ptr as *mut ()) });\n            }\n        }\n    }\n\n    if item.allocated != 0 {\n        if let Some(free_fn) = &mut *FREE_FN.lock().unwrap() {\n            free_fn.0(Some(Box::new(item)));\n        }\n    } else {\n        unsafe {\n            ptr::write_bytes(&mut *item, 0, 1);\n        }\n        item.header = 0x1F22B11F;\n    }\n\n    None\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_ptr",
            "free_fn"
        ],
        "header": "void *binn_release(binn *item)",
        "params": [
            "binn *item"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "item",
            "data",
            "data_idx",
            "free_fn"
        ],
        "calle": [
            "memmove",
            "memset",
            "binn_ptr",
            "free_fn"
        ],
        "calle_c": [
            "memmove",
            "memset",
            "free_fn"
        ],
        "key": "binn_release",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_type": {
        "source_code": "int binn_type(void *ptr)\n{\n  binn *item;\n  unsigned int item_idx = 0;\n  switch (binn_get_ptr_type(ptr))\n  {\n    case 1:\n      item_idx = (binn *) ptr;\n      return item->type;\n\n    case 2:\n      return binn_buf_type(ptr);\n\n    default:\n      return -1;\n\n  }\n\n}\n\n",
        "translated_code": "pub fn binn_type(ptr: Option<*mut u8>) -> i32 {\n    let item: Option<Box<BinnStruct>>;\n    let mut item_idx: u32 = 0;\n    \n    match binn_get_ptr_type(ptr) {\n        1 => {\n            item = unsafe { ptr.map(|p| Box::from_raw(p as *mut BinnStruct)) };\n            item.as_ref().map(|i| i.type_).unwrap_or(-1)\n        }\n        2 => binn_buf_type(None), // Assuming ptr can be converted to Option<&[u8]> if needed\n        _ => -1,\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_buf_type",
            "binn_get_ptr_type"
        ],
        "header": "int binn_type(void *ptr)",
        "params": [
            "void *ptr"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "item",
            "item_idx"
        ],
        "calle": [
            "binn_get_ptr_type",
            "binn_buf_type"
        ],
        "calle_c": [],
        "key": "binn_type",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_count": {
        "source_code": "int binn_count(void *ptr)\n{\n  binn *item;\n  unsigned int item_idx = 0;\n  switch (binn_get_ptr_type(ptr))\n  {\n    case 1:\n      item_idx = (binn *) ptr;\n      return item->count;\n\n    case 2:\n      return binn_buf_count(ptr);\n\n    default:\n      return -1;\n\n  }\n\n}\n\n",
        "translated_code": "pub fn binn_count(ptr: Option<*mut u8>) -> i32 {\n    let item_idx: u32;\n    match binn_get_ptr_type(ptr) {\n        1 => {\n            let item = unsafe { Box::from_raw(ptr.unwrap() as *mut BinnStruct) };\n            let count = item.count;\n            Box::into_raw(item); // Prevent the Box from being dropped\n            count\n        },\n        2 => binn_buf_count(None), // Assuming ptr can be converted to Option<&[u8]>\n        _ => -1,\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_buf_count",
            "binn_get_ptr_type"
        ],
        "header": "int binn_count(void *ptr)",
        "params": [
            "void *ptr"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "item",
            "item_idx"
        ],
        "calle": [
            "binn_get_ptr_type",
            "binn_buf_count"
        ],
        "calle_c": [],
        "key": "binn_count",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_list_uint64": {
        "source_code": "uint64 binn_list_uint64(void *list, int pos)\n{\n  uint64 value;\n  binn_list_get(list, pos, 0x80, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_list_uint64(list: Option<&[u8]>, pos: i32) -> uint64 {\n    let mut value: uint64 = 0;\n    let pvalue: Option<&mut dyn std::any::Any> = Some(&mut value);\n    binn_list_get(list, pos, 0x80, pvalue, None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_list_get",
            "int64",
            "uint64"
        ],
        "header": "uint64 binn_list_uint64(void *list, int pos)",
        "params": [
            "void *list",
            "int pos"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "value"
        ],
        "calle": [
            "binn_list_get"
        ],
        "calle_c": [],
        "key": "binn_list_uint64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_uint64": {
        "source_code": "uint64 binn_map_uint64(void *map, int id)\n{\n  uint64 value;\n  binn_map_get(map, id, 0x80, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_map_uint64(map: Option<&[u8]>, id: i32) -> uint64 {\n    let mut value: uint64 = 0;\n    let _ = binn_map_get(map, id, 0x80, Some(&mut value as &mut dyn std::any::Any), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_map_get",
            "int64",
            "uint64"
        ],
        "header": "uint64 binn_map_uint64(void *map, int id)",
        "params": [
            "void *map",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_get"
        ],
        "calle_c": [],
        "key": "binn_map_uint64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_uint64": {
        "source_code": "uint64 binn_object_uint64(void *obj, const char *key)\n{\n  uint64 value;\n  binn_object_get(obj, key, 0x80, &value, 0);\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_uint64(obj: Option<&[u8]>, key: Option<&str>) -> uint64 {\n    let mut value: uint64 = 0;\n    binn_object_get(obj, key, 0x80, Some(&mut value as &mut dyn Any), None);\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn_object_get",
            "int64",
            "uint64"
        ],
        "header": "uint64 binn_object_uint64(void *obj, const char *key)",
        "params": [
            "void *obj",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_get"
        ],
        "calle_c": [],
        "key": "binn_object_uint64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "store_value": {
        "source_code": "static void *store_value(binn *value)\n{\n  memcpy(&local_value, value, sizeof(binn));\n  switch (binn_get_read_storage(value->type))\n  {\n    case 0x00:\n\n    case 0x40:\n\n    case 0x60:\n\n    case 0x80:\n      return &local_value.vint32;\n\n  }\n\n  return value->ptr;\n}\n\n",
        "translated_code": "pub fn store_value(value: Option<Box<BinnStruct>>) -> Option<Box<()>> {\n    // Lock the global LOCAL_VALUE mutex\n    let mut local_value_guard = LOCAL_VALUE.lock().unwrap();\n    \n    if let Some(value) = value {\n        // Perform the equivalent of memcpy by dereferencing and assigning first\n        **local_value_guard.as_mut().unwrap() = *value;\n        \n        // Now get the ptr from the stored value\n        let original_ptr = local_value_guard.as_ref().unwrap().ptr.clone();\n\n        match binn_get_read_storage(local_value_guard.as_ref().unwrap().type_) {\n            0x00 | 0x40 | 0x60 | 0x80 => {\n                // Return a pointer to vint32 by taking a reference and converting to raw pointer\n                let vint32_ptr = &mut local_value_guard.as_mut().unwrap().value.vint32 as *mut i32;\n                Some(unsafe { Box::from_raw(vint32_ptr as *mut ()) })\n            }\n            _ => original_ptr,\n        }\n    } else {\n        None\n    }\n}\n\nlazy_static! {\n    pub static ref LOCAL_VALUE: Mutex<Option<Box<BinnStruct>>> = {\n        let empty_binn: BinnStruct = unsafe { mem::zeroed() };\n        Mutex::new(Some(Box::new(empty_binn)))\n    };\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_get_read_storage",
            "local_value"
        ],
        "params": [
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value",
            "local_value"
        ],
        "calle": [
            "memcpy",
            "binn_get_read_storage"
        ],
        "calle_c": [
            "memcpy"
        ],
        "key": "store_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_read": {
        "source_code": "void *binn_list_read(void *list, int pos, int *ptype, int *psize)\n{\n  binn value;\n  if (binn_list_get_value(list, pos, &value) == 0)\n  {\n    return 0;\n  }\n  if (ptype)\n  {\n    *ptype = value.type;\n  }\n  if (psize)\n  {\n    *psize = value.size;\n  }\n  return store_value(&value);\n}\n\n",
        "translated_code": "pub fn binn_list_read(\n    list: Option<&[u8]>,\n    pos: i32,\n    ptype: Option<&mut i32>,\n    psize: Option<&mut i32>,\n) -> Option<Box<()>> {\n    let mut value = None;\n    \n    if binn_list_get_value(list, pos, Some(&mut value)) == 0 {\n        return None;\n    }\n\n    if let Some(ptype) = ptype {\n        if let Some(ref value) = value {\n            *ptype = value.type_;\n        }\n    }\n\n    if let Some(psize) = psize {\n        if let Some(ref value) = value {\n            *psize = value.size;\n        }\n    }\n\n    store_value(value)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_get_value",
            "store_value"
        ],
        "header": "void *binn_list_read(void *list, int pos, int *ptype, int *psize)",
        "params": [
            "void *list",
            "int pos",
            "int *ptype",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "pos",
            "ptype",
            "psize",
            "value"
        ],
        "calle": [
            "store_value",
            "binn_list_get_value"
        ],
        "calle_c": [],
        "key": "binn_list_read",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_read": {
        "source_code": "void *binn_map_read(void *map, int id, int *ptype, int *psize)\n{\n  binn value;\n  if (binn_map_get_value(map, id, &value) == 0)\n  {\n    return 0;\n  }\n  if (ptype)\n  {\n    *ptype = value.type;\n  }\n  if (psize)\n  {\n    *psize = value.size;\n  }\n  return store_value(&value);\n}\n\n",
        "translated_code": "pub fn binn_map_read(\n    map: Option<&[u8]>,\n    id: i32,\n    ptype: Option<&mut i32>,\n    psize: Option<&mut i32>,\n) -> Option<Box<()>> {\n    let mut value = None;\n    \n    if binn_map_get_value(map, id, Some(&mut value)) == 0 {\n        return None;\n    }\n\n    if let Some(value) = value {\n        if let Some(ptype) = ptype {\n            *ptype = value.type_;\n        }\n        if let Some(psize) = psize {\n            *psize = value.size;\n        }\n        store_value(Some(value))\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_get_value",
            "store_value"
        ],
        "header": "void *binn_map_read(void *map, int id, int *ptype, int *psize)",
        "params": [
            "void *map",
            "int id",
            "int *ptype",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "ptype",
            "psize",
            "value"
        ],
        "calle": [
            "store_value",
            "binn_map_get_value"
        ],
        "calle_c": [],
        "key": "binn_map_read",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_read": {
        "source_code": "void *binn_object_read(void *obj, const char *key, int *ptype, int *psize)\n{\n  binn value;\n  if (binn_object_get_value(obj, key, &value) == 0)\n  {\n    return 0;\n  }\n  if (ptype)\n  {\n    *ptype = value.type;\n  }\n  if (psize)\n  {\n    *psize = value.size;\n  }\n  return store_value(&value);\n}\n\n",
        "translated_code": "pub fn binn_object_read(\n    obj: Option<&[u8]>,\n    key: Option<&str>,\n    ptype: Option<&mut i32>,\n    psize: Option<&mut i32>,\n) -> Option<Box<()>> {\n    let mut value = None;\n    \n    // Check if we successfully get the value\n    if binn_object_get_value(obj, key, Some(&mut value)) == 0 {\n        return None;\n    }\n\n    // If ptype is provided, set its value\n    if let Some(ptype) = ptype {\n        if let Some(ref v) = value {\n            *ptype = v.type_;\n        }\n    }\n\n    // If psize is provided, set its value\n    if let Some(psize) = psize {\n        if let Some(ref v) = value {\n            *psize = v.size;\n        }\n    }\n\n    // Store and return the value\n    store_value(value)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_get_value",
            "store_value"
        ],
        "header": "void *binn_object_read(void *obj, const char *key, int *ptype, int *psize)",
        "params": [
            "void *obj",
            "const char *key",
            "int *ptype",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "ptype",
            "psize",
            "value"
        ],
        "calle": [
            "binn_object_get_value",
            "store_value"
        ],
        "calle_c": [],
        "key": "binn_object_read",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_read_pair": {
        "source_code": "void *binn_map_read_pair(void *ptr, int pos, int *pid, int *ptype, int *psize)\n{\n  binn value;\n  if (binn_map_get_pair(ptr, pos, pid, &value) == 0)\n  {\n    return 0;\n  }\n  if (ptype)\n  {\n    *ptype = value.type;\n  }\n  if (psize)\n  {\n    *psize = value.size;\n  }\n  return store_value(&value);\n}\n\n",
        "translated_code": "pub fn binn_map_read_pair(\n    ptr: Option<&[u8]>,\n    pos: i32,\n    pid: Option<&mut i32>,\n    ptype: Option<&mut i32>,\n    psize: Option<&mut i32>,\n) -> Option<Box<()>> {\n    let mut value = None;\n    \n    if binn_map_get_pair(ptr, pos, pid, Some(&mut value)) == 0 {\n        return None;\n    }\n\n    if let Some(ptype) = ptype {\n        if let Some(ref value) = value {\n            *ptype = value.type_;\n        }\n    }\n\n    if let Some(psize) = psize {\n        if let Some(ref value) = value {\n            *psize = value.size;\n        }\n    }\n\n    store_value(value)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_get_pair",
            "store_value"
        ],
        "header": "void *binn_map_read_pair(void *ptr, int pos, int *pid, int *ptype, int *psize)",
        "params": [
            "void *ptr",
            "int pos",
            "int *pid",
            "int *ptype",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "pos",
            "pid",
            "ptype",
            "psize",
            "value"
        ],
        "calle": [
            "store_value",
            "binn_map_get_pair"
        ],
        "calle_c": [],
        "key": "binn_map_read_pair",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_read_pair": {
        "source_code": "void *binn_object_read_pair(void *ptr, int pos, char *pkey, int *ptype, int *psize)\n{\n  binn value;\n  if (binn_object_get_pair(ptr, pos, pkey, &value) == 0)\n  {\n    return 0;\n  }\n  if (ptype)\n  {\n    *ptype = value.type;\n  }\n  if (psize)\n  {\n    *psize = value.size;\n  }\n  return store_value(&value);\n}\n\n",
        "translated_code": "pub fn binn_object_read_pair(\n    ptr: Option<&[u8]>,\n    pos: i32,\n    pkey: Option<&mut [u8]>,\n    ptype: Option<&mut i32>,\n    psize: Option<&mut i32>,\n) -> Option<Box<()>> {\n    let mut value = None;\n    \n    if binn_object_get_pair(ptr, pos, pkey, Some(&mut value)) == 0 {\n        return None;\n    }\n\n    if let Some(ptype) = ptype {\n        if let Some(ref value) = value {\n            *ptype = value.type_;\n        }\n    }\n\n    if let Some(psize) = psize {\n        if let Some(ref value) = value {\n            *psize = value.size;\n        }\n    }\n\n    store_value(value)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_get_pair",
            "store_value"
        ],
        "header": "void *binn_object_read_pair(void *ptr, int pos, char *pkey, int *ptype, int *psize)",
        "params": [
            "void *ptr",
            "int pos",
            "char *pkey",
            "int *ptype",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "pos",
            "pkey",
            "ptype",
            "psize",
            "value"
        ],
        "calle": [
            "binn_object_get_pair",
            "store_value"
        ],
        "calle_c": [],
        "key": "binn_object_read_pair",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_read_next_pair": {
        "source_code": "static BOOL binn_read_next_pair(int expected_type, binn_iter *iter, int *pid, char *pkey, binn *value)\n{\n  int int32;\n  int id;\n  unsigned char *p;\n  unsigned int p_idx = 0;\n  unsigned char *key;\n  unsigned int key_idx = 0;\n  unsigned short len;\n  if (((((iter == 0) || (iter->pnext == 0)) || (iter->pnext > iter->plimit)) || (iter->current > iter->count)) || (iter->type != expected_type))\n  {\n    return 0;\n  }\n  iter->current += 1;\n  if (iter->current > iter->count)\n  {\n    return 0;\n  }\n  p_idx = iter->pnext;\n  switch (expected_type)\n  {\n    case 0xE1:\n      int32 = read_map_id(&(&p[p_idx]), iter->plimit);\n      if ((&p[p_idx]) > iter->plimit)\n    {\n      return 0;\n    }\n      id = int32;\n      if (pid)\n    {\n      *pid = id;\n    }\n      break;\n\n    case 0xE2:\n      len = *((unsigned char *) p);\n      p_idx += 1;\n      key_idx = &p[p_idx];\n      p_idx += len;\n      if ((&p[p_idx]) > iter->plimit)\n    {\n      return 0;\n    }\n      if (pkey)\n    {\n      memcpy(pkey, key, len);\n      pkey[len] = 0;\n    }\n      break;\n\n  }\n\n  iter->pnext = AdvanceDataPos(p, iter->plimit);\n  if ((iter->pnext != 0) && (iter->pnext < (&p[p_idx])))\n  {\n    return 0;\n  }\n  return GetValue(p, value);\n}\n\n",
        "translated_code": "pub fn binn_read_next_pair(\n    expected_type: i32,\n    iter: Option<&mut BinnIter>,\n    pid: Option<&mut i32>,\n    pkey: Option<&mut [u8]>,\n    value: Option<&mut binn>,\n) -> BOOL {\n    // Check for invalid iterator conditions (equivalent to line 10-13)\n    let iter = match iter {\n        Some(iter) => iter,\n        None => return 0,\n    };\n\n    if iter.pnext.is_none()\n        || iter.pnext.as_ref().unwrap().as_ptr() > iter.plimit.as_ref().unwrap().as_ptr()\n        || iter.current > iter.count\n        || iter.type_ != expected_type\n    {\n        return 0;\n    }\n\n    iter.current += 1;\n    if iter.current > iter.count {\n        return 0;\n    }\n\n    // Create a temporary copy of pnext to avoid borrowing issues\n    let p = iter.pnext.clone().unwrap();\n    let mut p_idx = 0;\n\n    match expected_type {\n        0xE1 => {\n            let mut p_slice = &p[p_idx..];\n            let plimit_slice = iter.plimit.as_ref().unwrap();\n            let int32 = match read_map_id(&mut p_slice, plimit_slice) {\n                Some(id) => id,\n                None => return 0,\n            };\n\n            p_idx = p.len() - p_slice.len();\n            if &p[p_idx..] > plimit_slice {\n                return 0;\n            }\n\n            if let Some(pid) = pid {\n                *pid = int32;\n            }\n        }\n        0xE2 => {\n            let len = p[p_idx] as usize;\n            p_idx += 1;\n            let key = &p[p_idx..p_idx + len];\n            p_idx += len;\n\n            if &p[p_idx..] > iter.plimit.as_ref().unwrap() {\n                return 0;\n            }\n\n            if let Some(pkey) = pkey {\n                if pkey.len() >= len {\n                    pkey[..len].copy_from_slice(key);\n                    if pkey.len() > len {\n                        pkey[len] = 0;\n                    }\n                }\n            }\n        }\n        _ => (),\n    }\n\n    let new_pnext = AdvanceDataPos(&p[p_idx..], iter.plimit.as_ref().unwrap().len());\n    iter.pnext = new_pnext.map(|slice| slice.to_vec());\n\n    if let Some(pnext) = &iter.pnext {\n        if pnext.as_ptr() < p[p_idx..].as_ptr() {\n            return 0;\n        }\n    }\n\n    GetValue(iter.pnext.as_ref().map(|v| v.as_slice()), value)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "AdvanceDataPos",
            "GetValue",
            "binn",
            "binn_iter",
            "read_map_id"
        ],
        "params": [
            "int expected_type",
            "binn_iter *iter",
            "int *pid",
            "char *pkey",
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "expected_type",
            "iter",
            "pid",
            "pkey",
            "value",
            "int32",
            "id",
            "p",
            "p_idx",
            "key",
            "key_idx",
            "len"
        ],
        "calle": [
            "GetValue",
            "memcpy",
            "read_map_id",
            "AdvanceDataPos"
        ],
        "calle_c": [
            "memcpy"
        ],
        "key": "binn_read_next_pair",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_map_next": {
        "source_code": "BOOL binn_map_next(binn_iter *iter, int *pid, binn *value)\n{\n  return binn_read_next_pair(0xE1, iter, pid, 0, value);\n}\n\n",
        "translated_code": "pub fn binn_map_next(iter: Option<&mut BinnIter>, pid: Option<&mut i32>, value: Option<&mut binn>) -> BOOL {\n    binn_read_next_pair(0xE1, iter, pid, None, value)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_iter",
            "binn_read_next_pair"
        ],
        "header": "BOOL binn_map_next(binn_iter *iter, int *pid, binn *value)",
        "params": [
            "binn_iter *iter",
            "int *pid",
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "iter",
            "pid",
            "value"
        ],
        "calle": [
            "binn_read_next_pair"
        ],
        "calle_c": [],
        "key": "binn_map_next",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_next": {
        "source_code": "BOOL binn_object_next(binn_iter *iter, char *pkey, binn *value)\n{\n  return binn_read_next_pair(0xE2, iter, 0, pkey, value);\n}\n\n",
        "translated_code": "pub fn binn_object_next(\n    iter: Option<&mut BinnIter>,\n    pkey: Option<&mut [u8]>,\n    value: Option<&mut binn>,\n) -> BOOL {\n    binn_read_next_pair(0xE2, iter, None, pkey, value)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_iter",
            "binn_read_next_pair"
        ],
        "header": "BOOL binn_object_next(binn_iter *iter, char *pkey, binn *value)",
        "params": [
            "binn_iter *iter",
            "char *pkey",
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "iter",
            "pkey",
            "value"
        ],
        "calle": [
            "binn_read_next_pair"
        ],
        "calle_c": [],
        "key": "binn_object_next",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_uint64": {
        "source_code": "inline static binn *binn_uint64(uint64 value)\n{\n  return binn_value(0x80, &value, 0, 0);\n}\n\n",
        "translated_code": "pub fn binn_uint64(value: uint64) -> Option<Box<BinnStruct>> {\n    // Convert the uint64 value to bytes for safe passing to binn_value\n    let value_bytes = value.to_le_bytes();\n    binn_value(0x80, Some(&value_bytes), 0, None)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_value",
            "int64",
            "uint64"
        ],
        "params": [
            "uint64 value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value"
        ],
        "calle": [
            "binn_value"
        ],
        "calle_c": [],
        "key": "binn_uint64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add_uint64": {
        "source_code": "inline static BOOL binn_list_add_uint64(binn *list, uint64 value)\n{\n  return binn_list_add(list, 0x80, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_list_add_uint64(list: &mut Option<Box<BinnStruct>>, value: u64) -> BOOL {\n    let mut boxed_value = Some(Box::new(value) as Box<dyn std::any::Any>);\n    binn_list_add(list, 0x80, Some(&mut boxed_value), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_add",
            "int64",
            "uint64"
        ],
        "params": [
            "binn *list",
            "uint64 value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "value"
        ],
        "calle": [
            "binn_list_add"
        ],
        "calle_c": [],
        "key": "binn_list_add_uint64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add_list": {
        "source_code": "inline static BOOL binn_list_add_list(binn *list, void *list2)\n{\n  return binn_list_add(list, 0xE0, binn_ptr(list2), binn_size(list2));\n}\n\n",
        "translated_code": "pub fn binn_list_add_list(list: &mut Option<Box<BinnStruct>>, list2: Option<&mut Option<Box<BinnStruct>>>) -> BOOL {\n    let pvalue = list2.as_ref().and_then(|l| l.as_ref().map(|b| Box::as_ref(b) as *const _ as *mut u8));\n    let size = list2.as_ref().map_or(0, |l| {\n        let ptr = l.as_ref().map(|b| Box::as_ref(b) as *const _ as *mut u8);\n        binn_size(ptr)\n    });\n    binn_list_add(\n        list,\n        0xE0,\n        pvalue.map(|v| unsafe { &mut *(v as *mut Option<Box<dyn std::any::Any>>) }),\n        size,\n    )\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_add",
            "binn_ptr",
            "binn_size"
        ],
        "params": [
            "binn *list",
            "void *list2"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "list2"
        ],
        "calle": [
            "binn_list_add",
            "binn_ptr",
            "binn_size"
        ],
        "calle_c": [],
        "key": "binn_list_add_list",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add_map": {
        "source_code": "inline static BOOL binn_list_add_map(binn *list, void *map)\n{\n  return binn_list_add(list, 0xE1, binn_ptr(map), binn_size(map));\n}\n\n",
        "translated_code": "pub fn binn_list_add_map(list: &mut Option<Box<BinnStruct>>, map: Option<*mut u8>) -> BOOL {\n    let any_ptr = map.map(|p| unsafe {\n        std::mem::transmute::<*mut u8, *mut Option<Box<dyn std::any::Any>>>(p)\n    });\n    let any_ref = any_ptr.map(|p| unsafe { &mut *p });\n    binn_list_add(\n        list,\n        0xE1,\n        any_ref,\n        binn_size(map)\n    )\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_add",
            "binn_ptr",
            "binn_size"
        ],
        "params": [
            "binn *list",
            "void *map"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "map"
        ],
        "calle": [
            "binn_list_add",
            "binn_ptr",
            "binn_size"
        ],
        "calle_c": [],
        "key": "binn_list_add_map",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add_object": {
        "source_code": "inline static BOOL binn_list_add_object(binn *list, void *obj)\n{\n  return binn_list_add(list, 0xE2, binn_ptr(obj), binn_size(obj));\n}\n\n",
        "translated_code": "pub fn binn_list_add_object(list: &mut Option<Box<BinnStruct>>, obj: Option<*mut u8>) -> BOOL {\n    binn_list_add(\n        list,\n        0xE2,\n        Some(&mut Some(Box::new(obj) as Box<dyn std::any::Any>)),\n        binn_size(obj)\n    )\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_add",
            "binn_ptr",
            "binn_size"
        ],
        "params": [
            "binn *list",
            "void *obj"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "obj"
        ],
        "calle": [
            "binn_list_add",
            "binn_ptr",
            "binn_size"
        ],
        "calle_c": [],
        "key": "binn_list_add_object",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_add_value": {
        "source_code": "inline static BOOL binn_list_add_value(binn *list, binn *value)\n{\n  return binn_list_add(list, value->type, binn_ptr(value), binn_size(value));\n}\n\n",
        "translated_code": "pub fn binn_list_add_value(list: &mut Option<Box<BinnStruct>>, value: &mut Option<Box<BinnStruct>>) -> BOOL {\n    // First, get the type_ and size from the value.\n    let type_ = value.as_ref().unwrap().type_;\n    let size = value.as_ref().unwrap().size;\n\n    // Move the value out into a temporary, leaving None in `value`.\n    let mut temp = value.take();\n    // Convert the temporary to an Option<Box<dyn Any>>\n    let mut temp_any: Option<Box<dyn std::any::Any>> = temp.map(|bx| bx as Box<dyn std::any::Any>);\n\n    // Call binn_list_add with a mutable reference to temp_any.\n    let result = binn_list_add(\n        list,\n        type_,\n        Some(&mut temp_any),\n        size,\n    );\n\n    // Convert temp_any back to Option<Box<BinnStruct>>\n    temp = if let Some(bx) = temp_any {\n        match bx.downcast::<BinnStruct>() {\n            Ok(bx) => Some(bx),\n            Err(_) => panic!(\"downcast failed\"),\n        }\n    } else {\n        None\n    };\n\n    // Put the value back into `value`\n    *value = temp;\n\n    result\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_add",
            "binn_ptr",
            "binn_size"
        ],
        "params": [
            "binn *list",
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "value"
        ],
        "calle": [
            "binn_list_add",
            "binn_ptr",
            "binn_size"
        ],
        "calle_c": [],
        "key": "binn_list_add_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_uint64": {
        "source_code": "inline static BOOL binn_map_set_uint64(binn *map, int id, uint64 value)\n{\n  return binn_map_set(map, id, 0x80, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_map_set_uint64(map: &mut Option<Box<BinnStruct>>, id: i32, value: u64) -> BOOL {\n    binn_map_set(map, id, 0x80, Some(&mut Some(Box::new(value))), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_set",
            "int64",
            "uint64"
        ],
        "params": [
            "binn *map",
            "int id",
            "uint64 value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_map_set"
        ],
        "calle_c": [],
        "key": "binn_map_set_uint64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_list": {
        "source_code": "inline static BOOL binn_map_set_list(binn *map, int id, void *list)\n{\n  return binn_map_set(map, id, 0xE0, binn_ptr(list), binn_size(list));\n}\n\n",
        "translated_code": "pub fn binn_map_set_list(\n    map: &mut Option<Box<BinnStruct>>,\n    id: i32,\n    list: Option<*mut u8>,\n) -> BOOL {\n    let ptr = binn_ptr(list);\n    binn_map_set(\n        map,\n        id,\n        0xE0,\n        ptr.map(|p| unsafe { &mut *(p as *mut Option<Box<dyn std::any::Any>>) }),\n        binn_size(list),\n    )\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_set",
            "binn_ptr",
            "binn_size"
        ],
        "params": [
            "binn *map",
            "int id",
            "void *list"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "list"
        ],
        "calle": [
            "binn_ptr",
            "binn_map_set",
            "binn_size"
        ],
        "calle_c": [],
        "key": "binn_map_set_list",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_map": {
        "source_code": "inline static BOOL binn_map_set_map(binn *map, int id, void *map2)\n{\n  return binn_map_set(map, id, 0xE1, binn_ptr(map2), binn_size(map2));\n}\n\n",
        "translated_code": "pub fn binn_map_set_map(\n    map: &mut crate::binn::binn,\n    id: i32,\n    map2: Option<&mut crate::binn::binn>,\n) -> BOOL {\n    // Convert map2 to raw pointer for binn_ptr\n    let map2_ptr = match map2 {\n        Some(m) => Some(Box::into_raw(Box::new(m)) as *mut u8),\n        None => None,\n    };\n\n    // Get size of map2\n    let size = binn_size(map2_ptr);\n\n    // Call binn_map_set with appropriate parameters\n    binn_map_set(\n        map,\n        id,\n        0xE1,\n        map2_ptr.map(|p| unsafe { &mut *(p as *mut Option<Box<dyn std::any::Any>>) }),\n        size,\n    )\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_set",
            "binn_ptr",
            "binn_size"
        ],
        "params": [
            "binn *map",
            "int id",
            "void *map2"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "map2"
        ],
        "calle": [
            "binn_ptr",
            "binn_map_set",
            "binn_size"
        ],
        "calle_c": [],
        "key": "binn_map_set_map",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_object": {
        "source_code": "inline static BOOL binn_map_set_object(binn *map, int id, void *obj)\n{\n  return binn_map_set(map, id, 0xE2, binn_ptr(obj), binn_size(obj));\n}\n\n",
        "translated_code": "pub fn binn_map_set_object(\n    map: &mut Option<Box<BinnStruct>>,\n    id: i32,\n    obj: Option<*mut u8>,\n) -> BOOL {\n    binn_map_set(\n        map,\n        id,\n        0xE2,\n        obj.map(|ptr| Some(Box::new(ptr) as Box<dyn std::any::Any>)).as_mut(),\n        binn_size(obj),\n    )\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_set",
            "binn_ptr",
            "binn_size"
        ],
        "params": [
            "binn *map",
            "int id",
            "void *obj"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "obj"
        ],
        "calle": [
            "binn_ptr",
            "binn_map_set",
            "binn_size"
        ],
        "calle_c": [],
        "key": "binn_map_set_object",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_value": {
        "source_code": "inline static BOOL binn_map_set_value(binn *map, int id, binn *value)\n{\n  return binn_map_set(map, id, value->type, binn_ptr(value), binn_size(value));\n}\n\n",
        "translated_code": "pub fn binn_map_set_value(map: &mut crate::binn::binn, id: i32, value: &mut crate::binn::binn) -> BOOL {\n    let type_ = value.as_ref().map(|v| v.type_).unwrap_or(0);\n    let ptr = binn_ptr(value.as_mut().and_then(|v| v.ptr.as_mut().map(|p| p as *mut _ as *mut u8)));\n    let size = binn_size(ptr);\n    binn_map_set(\n        map,\n        id,\n        type_,\n        value.as_mut().and_then(|v| {\n            v.ptr.as_mut().map(|p| {\n                let any_ptr = p as *mut _ as *mut dyn std::any::Any;\n                unsafe { &mut *(any_ptr as *mut Option<Box<dyn std::any::Any>>) }\n            })\n        }),\n        size,\n    )\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_map_set",
            "binn_ptr",
            "binn_size"
        ],
        "params": [
            "binn *map",
            "int id",
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value"
        ],
        "calle": [
            "binn_ptr",
            "binn_map_set",
            "binn_size"
        ],
        "calle_c": [],
        "key": "binn_map_set_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_uint64": {
        "source_code": "inline static BOOL binn_object_set_uint64(binn *obj, const char *key, uint64 value)\n{\n  return binn_object_set(obj, key, 0x80, &value, 0);\n}\n\n",
        "translated_code": "pub fn binn_object_set_uint64(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    value: uint64,\n) -> BOOL {\n    let mut boxed_value = Some(Box::new(value) as Box<dyn std::any::Any>);\n    binn_object_set(obj, key, 0x80, Some(&mut boxed_value), 0)\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_set",
            "int64",
            "uint64"
        ],
        "params": [
            "binn *obj",
            "const char *key",
            "uint64 value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_object_set"
        ],
        "calle_c": [],
        "key": "binn_object_set_uint64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_list": {
        "source_code": "inline static BOOL binn_object_set_list(binn *obj, const char *key, void *list)\n{\n  return binn_object_set(obj, key, 0xE0, binn_ptr(list), binn_size(list));\n}\n\n",
        "translated_code": "pub fn binn_object_set_list(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    list: Option<*mut u8>,\n) -> BOOL {\n    let mut value: Option<Box<dyn std::any::Any>> = if let Some(ptr) = list {\n        Some(Box::new(ptr) as Box<dyn std::any::Any>)\n    } else {\n        None\n    };\n    \n    binn_object_set(\n        obj,\n        key,\n        0xE0,\n        Some(&mut value),\n        binn_size(list),\n    )\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_set",
            "binn_ptr",
            "binn_size"
        ],
        "params": [
            "binn *obj",
            "const char *key",
            "void *list"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "list"
        ],
        "calle": [
            "binn_ptr",
            "binn_object_set",
            "binn_size"
        ],
        "calle_c": [],
        "key": "binn_object_set_list",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_map": {
        "source_code": "inline static BOOL binn_object_set_map(binn *obj, const char *key, void *map)\n{\n  return binn_object_set(obj, key, 0xE1, binn_ptr(map), binn_size(map));\n}\n\n",
        "translated_code": "pub fn binn_object_set_map(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    map: Option<*mut u8>,\n) -> BOOL {\n    let mut ptr = binn_ptr(map);\n    let mut boxed_ptr: Option<Box<dyn std::any::Any>> = ptr.map(|p| Box::new(p) as Box<dyn std::any::Any>);\n    binn_object_set(\n        obj,\n        key,\n        0xE1,\n        Some(&mut boxed_ptr),\n        binn_size(map),\n    )\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_set",
            "binn_ptr",
            "binn_size"
        ],
        "params": [
            "binn *obj",
            "const char *key",
            "void *map"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "map"
        ],
        "calle": [
            "binn_ptr",
            "binn_object_set",
            "binn_size"
        ],
        "calle_c": [],
        "key": "binn_object_set_map",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_object": {
        "source_code": "inline static BOOL binn_object_set_object(binn *obj, const char *key, void *obj2)\n{\n  return binn_object_set(obj, key, 0xE2, binn_ptr(obj2), binn_size(obj2));\n}\n\n",
        "translated_code": "pub fn binn_object_set_object(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    obj2: Option<*mut u8>,\n) -> BOOL {\n    let mut boxed: Option<Box<dyn std::any::Any>> = obj2.map(|p| unsafe { Box::from_raw(p) as Box<dyn std::any::Any> });\n    binn_object_set(\n        obj,\n        key,\n        0xE2,\n        Some(&mut boxed),\n        binn_size(obj2),\n    )\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_set",
            "binn_ptr",
            "binn_size"
        ],
        "params": [
            "binn *obj",
            "const char *key",
            "void *obj2"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "obj2"
        ],
        "calle": [
            "binn_ptr",
            "binn_object_set",
            "binn_size"
        ],
        "calle_c": [],
        "key": "binn_object_set_object",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_value": {
        "source_code": "inline static BOOL binn_object_set_value(binn *obj, const char *key, binn *value)\n{\n  return binn_object_set(obj, key, value->type, binn_ptr(value), binn_size(value));\n}\n\n",
        "translated_code": "pub fn binn_object_set_value(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    value: &mut Option<Box<BinnStruct>>,\n) -> BOOL {\n    let type_ = value.as_ref().map_or(0, |v| v.type_);\n    let size = value.as_ref().map_or(0, |v| v.size);\n    \n    // Move the value into a temporary Option<Box<dyn Any>>\n    let mut temp_any: Option<Box<dyn std::any::Any>> = value.take().map(|b| b as Box<dyn std::any::Any>);\n    \n    // Prepare pvalue argument as Option<&mut Option<Box<dyn Any>>>\n    let pvalue_arg = if temp_any.is_some() {\n        Some(&mut temp_any)\n    } else {\n        None\n    };\n    \n    let result = binn_object_set(\n        obj,\n        key,\n        type_,\n        pvalue_arg,\n        size\n    );\n    \n    // Restore the original value by downcasting\n    *value = if let Some(any) = temp_any {\n        if let Ok(b) = any.downcast::<BinnStruct>() {\n            Some(b)\n        } else {\n            // Should not happen since we only put BinnStruct in\n            None\n        }\n    } else {\n        None\n    };\n    \n    result\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_object_set",
            "binn_ptr",
            "binn_size"
        ],
        "params": [
            "binn *obj",
            "const char *key",
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value"
        ],
        "calle": [
            "binn_ptr",
            "binn_object_set",
            "binn_size"
        ],
        "calle_c": [],
        "key": "binn_object_set_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_copy": {
        "source_code": "binn *binn_copy(void *old)\n{\n  int type;\n  int count;\n  int size;\n  int header_size;\n  unsigned char *old_ptr = binn_ptr(old);\n  binn *item;\n  unsigned int item_idx = 0;\n  size = 0;\n  if (!IsValidBinnHeader(old_ptr, &type, &count, &size, &header_size))\n  {\n    return 0;\n  }\n  item_idx = binn_new(type, (size - header_size) + 9, 0);\n  if (item)\n  {\n    unsigned char *dest;\n    unsigned int dest_idx = 0;\n    dest_idx = ((unsigned char *) item->pbuf) + 9;\n    memcpy(dest, old_ptr + header_size, size - header_size);\n    item->used_size = (9 + size) - header_size;\n    item->count = count;\n  }\n  return item;\n}\n\n",
        "translated_code": "pub fn binn_copy(mut old: Option<&mut [u8]>) -> Option<Box<BinnStruct>> {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    \n    let old_ptr = binn_ptr(old.as_mut().map(|x| x.as_mut_ptr()));\n    let old_len = old.as_ref().map(|x| x.len()).unwrap_or(0);\n    let old_slice = unsafe { slice::from_raw_parts(old_ptr?, old_len) };\n\n    if !IsValidBinnHeader(\n        Some(old_slice),\n        Some(&mut type_),\n        Some(&mut count),\n        Some(&mut size),\n        Some(&mut header_size),\n    ) {\n        return Option::None;\n    }\n\n    let mut item = binn_new(type_, (size - header_size) + 9, None)?;\n\n    {\n        let dest_slice = unsafe {\n            slice::from_raw_parts_mut(\n                ((item.pbuf.as_mut()? as *mut _ as *mut u8).add(9)) as *mut u8,\n                (size - header_size) as usize,\n            )\n        };\n        let src_slice = &old_slice[header_size as usize..(header_size + size) as usize];\n        dest_slice.copy_from_slice(src_slice);\n    }\n\n    item.used_size = (9 + size) - header_size;\n    item.count = count;\n\n    Some(item)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "IsValidBinnHeader",
            "binn",
            "binn_new",
            "binn_ptr"
        ],
        "header": "binn *binn_copy(void *old)",
        "params": [
            "void *old"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "old",
            "type",
            "count",
            "size",
            "header_size",
            "old_ptr",
            "item",
            "item_idx",
            "dest",
            "dest_idx"
        ],
        "calle": [
            "IsValidBinnHeader",
            "memcpy",
            "binn_ptr",
            "binn_new"
        ],
        "calle_c": [
            "memcpy"
        ],
        "key": "binn_copy",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_list_add_new": {
        "source_code": "BOOL binn_list_add_new(binn *list, binn *value)\n{\n  BOOL retval;\n  retval = binn_list_add_value(list, value);\n  if (value)\n  {\n    free_fn(value);\n  }\n  return retval;\n}\n\n",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::Mutex;\n\npub fn binn_list_add_new(list: &mut Option<Box<BinnStruct>>, value: &mut Option<Box<BinnStruct>>) -> BOOL {\n    let retval = binn_list_add_value(list, value);\n    \n    if value.is_some() {\n        if let Some(free_fn) = &mut *FREE_FN.lock().unwrap() {\n            let value_to_free = value.take().map(|v| v as Box<dyn std::any::Any + Send>);\n            free_fn.0(value_to_free);\n        }\n    }\n    \n    retval\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "binn",
            "binn_list_add_value",
            "free_fn"
        ],
        "header": "BOOL binn_list_add_new(binn *list, binn *value)",
        "params": [
            "binn *list",
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "value",
            "retval",
            "free_fn"
        ],
        "calle": [
            "binn_list_add_value",
            "free_fn"
        ],
        "calle_c": [
            "free_fn"
        ],
        "key": "binn_list_add_new",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_set_new": {
        "source_code": "BOOL binn_map_set_new(binn *map, int id, binn *value)\n{\n  BOOL retval;\n  retval = binn_map_set_value(map, id, value);\n  if (value)\n  {\n    free_fn(value);\n  }\n  return retval;\n}\n\n",
        "translated_code": "pub fn binn_map_set_new(map: &mut binn, id: i32, mut value: Option<Box<BinnStruct>>) -> BOOL {\n    let retval;\n    {\n        let mut value_ref = value.as_mut().map(|v| v.as_mut() as *mut BinnStruct);\n        retval = binn_map_set_value(map, id, &mut value);\n    }\n    \n    if let Some(value) = value {\n        if let Some(free_fn) = &mut *FREE_FN.lock().unwrap() {\n            (free_fn.0)(Some(Box::new(value)));\n        }\n    }\n    \n    retval\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "binn",
            "binn_map_set_value",
            "free_fn"
        ],
        "header": "BOOL binn_map_set_new(binn *map, int id, binn *value)",
        "params": [
            "binn *map",
            "int id",
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "id",
            "value",
            "retval",
            "free_fn"
        ],
        "calle": [
            "free_fn",
            "binn_map_set_value"
        ],
        "calle_c": [
            "free_fn"
        ],
        "key": "binn_map_set_new",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_set_new": {
        "source_code": "BOOL binn_object_set_new(binn *obj, const char *key, binn *value)\n{\n  BOOL retval;\n  retval = binn_object_set_value(obj, key, value);\n  if (value)\n  {\n    free_fn(value);\n  }\n  return retval;\n}\n\n",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::Mutex;\n\npub fn binn_object_set_new(\n    obj: &mut Option<Box<BinnStruct>>,\n    key: Option<&str>,\n    value: Option<Box<BinnStruct>>,\n) -> BOOL {\n    let mut value = value;\n    let retval = binn_object_set_value(obj, key, &mut value);\n    \n    if let Some(v) = value {\n        if let Some(free_fn) = &mut *FREE_FN.lock().unwrap() {\n            (free_fn.0)(Some(Box::new(v)));\n        }\n    }\n    \n    retval\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "binn",
            "binn_object_set_value",
            "free_fn"
        ],
        "header": "BOOL binn_object_set_new(binn *obj, const char *key, binn *value)",
        "params": [
            "binn *obj",
            "const char *key",
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "key",
            "value",
            "retval",
            "free_fn"
        ],
        "calle": [
            "binn_object_set_value",
            "free_fn"
        ],
        "calle_c": [
            "free_fn"
        ],
        "key": "binn_object_set_new",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_open": {
        "source_code": "binn *binn_open(void *data)\n{\n  binn *item;\n  unsigned int item_idx = 0;\n  item_idx = (binn *) binn_malloc(sizeof(binn));\n  if (binn_load(data, item) == 0)\n  {\n    free_fn(item);\n    return 0;\n  }\n  item->allocated = 1;\n  return item;\n}\n\n",
        "translated_code": "pub fn binn_open(data: Option<*mut u8>) -> Option<Box<BinnStruct>> {\n    // Allocate memory for the binn struct\n    let mut item = match binn_malloc(std::mem::size_of::<BinnStruct>() as i32) {\n        Some(alloc) => {\n            // Try to downcast the allocation to our specific type\n            match alloc.downcast::<BinnStruct>() {\n                Ok(boxed) => Some(boxed),\n                Err(_) => None,\n            }\n        }\n        None => return None,\n    };\n\n    // Load the data into the binn struct\n    if let Some(mut item_ref) = item.as_deref_mut() {\n        if !binn_load(data, Some(&mut item_ref)) {\n            // If loading fails, free the allocated memory\n            if let Some(free_fn) = &mut *FREE_FN.lock().unwrap() {\n                free_fn.0(item.map(|b| b as Box<dyn std::any::Any + Send>));\n            }\n            return None;\n        }\n    }\n\n    // Set the allocated flag and return the item\n    if let Some(item) = item.as_deref_mut() {\n        item.allocated = 1;  // Changed from true to 1 to match BOOL type\n    }\n    item\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_load",
            "binn_malloc",
            "free_fn"
        ],
        "header": "binn *binn_open(void *data)",
        "params": [
            "void *data"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "data",
            "item",
            "item_idx",
            "free_fn"
        ],
        "calle": [
            "binn_load",
            "binn_malloc",
            "free_fn"
        ],
        "calle_c": [
            "free_fn"
        ],
        "key": "binn_open",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_list_value": {
        "source_code": "binn *binn_list_value(void *ptr, int pos)\n{\n  binn *value;\n  unsigned int value_idx = 0;\n  value_idx = (binn *) binn_malloc(sizeof(binn));\n  if (binn_list_get_value(ptr, pos, value) == 0)\n  {\n    free_fn(value);\n    return 0;\n  }\n  value->allocated = 1;\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_list_value(ptr: Option<&[u8]>, pos: i32) -> Option<Box<BinnStruct>> {\n    let value = match binn_malloc(std::mem::size_of::<BinnStruct>() as i32) {\n        Some(allocated) => {\n            let mut value = Box::new(BinnStruct {\n                header: 0,\n                allocated: 1,  // TRUE\n                writable: 0,   // FALSE\n                dirty: 0,     // FALSE\n                pbuf: None,\n                pre_allocated: 0,  // FALSE\n                alloc_size: 0,\n                used_size: 0,\n                type_: 0,\n                ptr: None,\n                size: 0,\n                count: 0,\n                freefn: BinnMemFree::default(),\n                value: BinnValue {\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: 0,  // FALSE\n                },\n                disable_int_compression: 0,  // FALSE\n            });\n            \n            let mut boxed_value = Some(value);\n            if binn_list_get_value(ptr, pos, Some(&mut boxed_value)) == 0 {  // FALSE\n                if let Some(free_fn) = &mut *FREE_FN.lock().unwrap() {\n                    (free_fn.0)(Some(Box::new(boxed_value.unwrap()) as Box<dyn std::any::Any + Send>));\n                }\n                return None;\n            }\n            let mut value = boxed_value.unwrap();\n            value.allocated = 1;  // TRUE\n            Some(value)\n        }\n        None => None,\n    };\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_get_value",
            "binn_malloc",
            "free_fn"
        ],
        "header": "binn *binn_list_value(void *list, int pos)",
        "params": [
            "void *ptr",
            "int pos"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "pos",
            "value",
            "value_idx",
            "free_fn"
        ],
        "calle": [
            "binn_malloc",
            "binn_list_get_value",
            "free_fn"
        ],
        "calle_c": [
            "free_fn"
        ],
        "key": "binn_list_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_map_value": {
        "source_code": "binn *binn_map_value(void *ptr, int id)\n{\n  binn *value;\n  unsigned int value_idx = 0;\n  value_idx = (binn *) binn_malloc(sizeof(binn));\n  if (binn_map_get_value(ptr, id, value) == 0)\n  {\n    free_fn(value);\n    return 0;\n  }\n  value->allocated = 1;\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_map_value(ptr: Option<&[u8]>, id: i32) -> Option<Box<BinnStruct>> {\n    // Allocate memory for a new BinnStruct\n    let mut value: Option<Box<BinnStruct>> = match binn_malloc(std::mem::size_of::<BinnStruct>() as i32) {\n        Some(alloc) => {\n            // SAFETY: We know binn_malloc returns a Box<BinnStruct> when successful\n            unsafe { alloc.downcast::<BinnStruct>().ok() }\n        }\n        None => return None,\n    };\n\n    // Call binn_map_get_value with the mutable reference to the Option\n    if binn_map_get_value(ptr, id, Some(&mut value)) == 0 {\n        // If the call fails, free the allocated memory\n        if let Some(free_fn) = &mut *FREE_FN.lock().unwrap() {\n            free_fn.0(value.map(|v| Box::new(v) as Box<dyn std::any::Any + Send>));\n        }\n        return None;\n    }\n\n    // Set the allocated flag and return the value\n    if let Some(value) = &mut value {\n        value.allocated = 1;\n    }\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_malloc",
            "binn_map_get_value",
            "free_fn"
        ],
        "header": "binn *binn_map_value(void *map, int id)",
        "params": [
            "void *ptr",
            "int id"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "id",
            "value",
            "value_idx",
            "free_fn"
        ],
        "calle": [
            "binn_malloc",
            "free_fn",
            "binn_map_get_value"
        ],
        "calle_c": [
            "free_fn"
        ],
        "key": "binn_map_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_object_value": {
        "source_code": "binn *binn_object_value(void *ptr, const char *key)\n{\n  binn *value;\n  unsigned int value_idx = 0;\n  value_idx = (binn *) binn_malloc(sizeof(binn));\n  if (binn_object_get_value(ptr, key, value) == 0)\n  {\n    free_fn(value);\n    return 0;\n  }\n  value->allocated = 1;\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_value(ptr: Option<&[u8]>, key: Option<&str>) -> Option<Box<BinnStruct>> {\n    // Allocate memory for the binn struct\n    let mut value = match binn_malloc(std::mem::size_of::<BinnStruct>() as i32) {\n        Some(alloc) => {\n            // SAFETY: We know this was allocated as a BinnStruct\n            unsafe { Box::from_raw(Box::into_raw(alloc) as *mut BinnStruct) }\n        }\n        None => return None,\n    };\n\n    // Initialize the struct\n    value.allocated = 1; // BOOL true\n\n    // Create an Option<Box<BinnStruct>> to pass to the function\n    let mut value_option = Some(value);\n\n    // Try to get the value from the object\n    if binn_object_get_value(ptr, key, Some(&mut value_option)) == 0 {\n        // Free the allocated memory if getting the value failed\n        if let Some(free_fn) = &mut *FREE_FN.lock().unwrap() {\n            (free_fn.0)(Some(Box::new(value_option.unwrap()) as Box<dyn std::any::Any + Send>));\n        }\n        return None;\n    }\n\n    value_option\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_malloc",
            "binn_object_get_value",
            "free_fn"
        ],
        "header": "binn *binn_object_value(void *obj, const char *key)",
        "params": [
            "void *ptr",
            "const char *key"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "ptr",
            "key",
            "value",
            "value_idx",
            "free_fn"
        ],
        "calle": [
            "binn_malloc",
            "free_fn",
            "binn_object_get_value"
        ],
        "calle_c": [
            "free_fn"
        ],
        "key": "binn_object_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_map_pair": {
        "source_code": "binn *binn_map_pair(void *map, int pos, int *pid)\n{\n  binn *value;\n  unsigned int value_idx = 0;\n  value_idx = (binn *) binn_malloc(sizeof(binn));\n  if (binn_read_pair(0xE1, map, pos, pid, 0, value) == 0)\n  {\n    free_fn(value);\n    return 0;\n  }\n  value->allocated = 1;\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_map_pair(map: Option<&[u8]>, pos: i32, pid: Option<&mut i32>) -> Option<Box<BinnStruct>> {\n    // Allocate memory for the binn struct\n    let mut value = match binn_malloc(std::mem::size_of::<BinnStruct>() as i32) {\n        Some(alloc) => {\n            // Try to downcast the allocation to our BinnStruct type\n            match alloc.downcast::<BinnStruct>() {\n                Ok(boxed) => Some(boxed),\n                Err(e) => {\n                    // If downcast fails, free the allocation and return None\n                    if let Some(free_fn) = &mut *FREE_FN.lock().unwrap() {\n                        let raw_ptr = Box::into_raw(e);\n                        let send_ptr = unsafe { Box::from_raw(raw_ptr as *mut (dyn std::any::Any + Send)) };\n                        (free_fn.0)(Some(send_ptr));\n                    }\n                    return Option::None;\n                }\n            }\n        }\n        None => return Option::None,\n    };\n\n    // Create a mutable reference to the value for binn_read_pair\n    let mut boxed_value = value.as_mut().map(|v| v.as_mut());\n\n    // Call binn_read_pair with the allocated value\n    if binn_read_pair(0xE1, map, pos, pid, Option::None, Some(&mut value)) == 0 {\n        // On failure, free the allocated value and return None\n        if let Some(free_fn) = &mut *FREE_FN.lock().unwrap() {\n            let raw_ptr = Box::into_raw(value.unwrap());\n            let send_ptr = unsafe { Box::from_raw(raw_ptr as *mut (dyn std::any::Any + Send)) };\n            (free_fn.0)(Some(send_ptr));\n        }\n        return Option::None;\n    }\n\n    // On success, mark as allocated and return the value\n    if let Some(v) = value.as_mut() {\n        v.allocated = 1;\n    }\n    value\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_malloc",
            "binn_read_pair",
            "free_fn"
        ],
        "header": "binn *binn_map_pair(void *map, int pos, int *pid)",
        "params": [
            "void *map",
            "int pos",
            "int *pid"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "map",
            "pos",
            "pid",
            "value",
            "value_idx",
            "free_fn"
        ],
        "calle": [
            "binn_read_pair",
            "binn_malloc",
            "free_fn"
        ],
        "calle_c": [
            "free_fn"
        ],
        "key": "binn_map_pair",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_object_pair": {
        "source_code": "binn *binn_object_pair(void *obj, int pos, char *pkey)\n{\n  binn *value;\n  unsigned int value_idx = 0;\n  value_idx = (binn *) binn_malloc(sizeof(binn));\n  if (binn_read_pair(0xE2, obj, pos, 0, pkey, value) == 0)\n  {\n    free_fn(value);\n    return 0;\n  }\n  value->allocated = 1;\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_pair(obj: Option<&[u8]>, pos: i32, pkey: Option<&mut [u8]>) -> Option<Box<BinnStruct>> {\n    // Allocate memory for the binn struct\n    let value = match binn_malloc(std::mem::size_of::<BinnStruct>() as i32) {\n        Some(ptr) => ptr,\n        None => return None,\n    };\n\n    // Try to downcast the allocated memory to our binn type\n    let mut value = match value.downcast::<BinnStruct>() {\n        Ok(boxed) => *boxed,\n        Err(e) => {\n            // If downcast fails, free the memory and return None\n            if let Some(free_fn) = &mut *FREE_FN.lock().unwrap() {\n                // Convert the error into a String which implements Send\n                let error_str = format!(\"{:?}\", e);\n                free_fn.0(Some(Box::new(error_str) as Box<dyn std::any::Any + Send>));\n            }\n            return None;\n        }\n    };\n\n    // Initialize the binn struct\n    value.allocated = 1;\n    \n    // Prepare the value as Option<&mut binn> for binn_read_pair\n    let mut boxed_value = Box::new(value);\n    let mut binn_value: Option<Box<BinnStruct>> = Some(boxed_value);\n    let value_ref: Option<&mut Option<Box<BinnStruct>>> = Some(&mut binn_value);\n    \n    // Call binn_read_pair\n    if binn_read_pair(0xE2, obj, pos, None, pkey, value_ref) == 0 {\n        // On failure, free the allocated memory\n        if let Some(free_fn) = &mut *FREE_FN.lock().unwrap() {\n            if let Some(val) = binn_value {\n                free_fn.0(Some(Box::new(val) as Box<dyn std::any::Any + Send>));\n            }\n        }\n        return None;\n    }\n\n    if let Some(mut val) = binn_value {\n        val.allocated = 1;\n        Some(val)\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_malloc",
            "binn_read_pair",
            "free_fn"
        ],
        "header": "binn *binn_object_pair(void *obj, int pos, char *pkey)",
        "params": [
            "void *obj",
            "int pos",
            "char *pkey"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "pos",
            "pkey",
            "value",
            "value_idx",
            "free_fn"
        ],
        "calle": [
            "binn_read_pair",
            "binn_malloc",
            "free_fn"
        ],
        "calle_c": [
            "free_fn"
        ],
        "key": "binn_object_pair",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_iter_init": {
        "source_code": "BOOL binn_iter_init(binn_iter *iter, void *ptr, int expected_type)\n{\n  unsigned int ptr_idx = 0;\n  int type;\n  int count;\n  int size = 0;\n  int header_size;\n  ptr_idx = binn_ptr(ptr_idx);\n  if (((&ptr[ptr_idx]) == 0) || (iter == 0))\n  {\n    return 0;\n  }\n  memset(iter, 0, sizeof(binn_iter));\n  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == 0)\n  {\n    return 0;\n  }\n  if (type != expected_type)\n  {\n    return 0;\n  }\n  iter->plimit = (((unsigned char *) ptr) + size) - 1;\n  iter->pnext = ((unsigned char *) ptr) + header_size;\n  iter->count = count;\n  iter->current = 0;\n  iter->type = type;\n  return 1;\n}\n\n",
        "translated_code": "pub fn binn_iter_init(\n    iter: Option<&mut BinnIter>,\n    ptr: Option<&[u8]>,\n    expected_type: i32,\n) -> bool {\n    let ptr_idx = 0;\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    // Check for null pointers (translated to Option checks in Rust)\n    if ptr.is_none() || iter.is_none() {\n        return false;\n    }\n    let ptr = ptr.unwrap();\n    let iter = iter.unwrap();\n\n    // Equivalent of memset - initialize all fields to zero/default\n    *iter = BinnIter {\n        pnext: None,\n        plimit: None,\n        type_: 0,\n        count: 0,\n        current: 0,\n    };\n\n    // Call IsValidBinnHeader with mutable references to get output parameters\n    if !IsValidBinnHeader(\n        Some(ptr),\n        Some(&mut type_),\n        Some(&mut count),\n        Some(&mut size),\n        Some(&mut header_size),\n    ) {\n        return false;\n    }\n\n    if type_ != expected_type {\n        return false;\n    }\n\n    // Calculate pointer positions (safe Rust version)\n    let plimit = ptr.as_ptr().wrapping_add(size as usize).wrapping_sub(1);\n    let pnext = ptr.as_ptr().wrapping_add(header_size as usize);\n\n    // Update the iterator fields\n    iter.plimit = Some(unsafe { Vec::from_raw_parts(plimit as *mut u8, 1, 1) });\n    iter.pnext = Some(unsafe { Vec::from_raw_parts(pnext as *mut u8, 1, 1) });\n    iter.count = count;\n    iter.current = 0;\n    iter.type_ = type_;\n\n    true\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "IsValidBinnHeader",
            "binn",
            "binn_iter",
            "binn_ptr"
        ],
        "header": "BOOL binn_iter_init(binn_iter *iter, void *pbuf, int type)",
        "params": [
            "binn_iter *iter",
            "void *ptr",
            "int expected_type"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "iter",
            "ptr",
            "expected_type",
            "ptr_idx",
            "type",
            "count",
            "size",
            "header_size"
        ],
        "calle": [
            "memset",
            "binn_ptr",
            "IsValidBinnHeader"
        ],
        "calle_c": [
            "memset"
        ],
        "key": "binn_iter_init",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_list_next": {
        "source_code": "BOOL binn_list_next(binn_iter *iter, binn *value)\n{\n  unsigned char *pnow;\n  unsigned int pnow_idx = 0;\n  if (((((iter == 0) || (iter->pnext == 0)) || (iter->pnext > iter->plimit)) || (iter->current > iter->count)) || (iter->type != 0xE0))\n  {\n    return 0;\n  }\n  iter->current += 1;\n  if (iter->current > iter->count)\n  {\n    return 0;\n  }\n  pnow_idx = iter->pnext;\n  iter->pnext = AdvanceDataPos(pnow, iter->plimit);\n  if ((iter->pnext != 0) && (iter->pnext < (&pnow[pnow_idx])))\n  {\n    return 0;\n  }\n  return GetValue(pnow, value);\n}\n\n",
        "translated_code": "pub fn binn_list_next(iter: Option<&mut BinnIter>, value: Option<&mut binn>) -> BOOL {\n    // Early return if any of the conditions in the complex check fail\n    if let Some(iter) = iter {\n        if iter.pnext.is_none() \n            || iter.plimit.is_none() \n            || iter.pnext.as_ref().unwrap().as_ptr() > iter.plimit.as_ref().unwrap().as_ptr()\n            || iter.current > iter.count \n            || iter.type_ != 0xE0 \n        {\n            return 0;\n        }\n\n        iter.current += 1;\n        if iter.current > iter.count {\n            return 0;\n        }\n\n        let pnow = iter.pnext.take().unwrap(); // Take ownership to avoid borrow issues\n        let pnow_ptr = pnow.as_ptr();\n        let pnow_len = pnow.len();\n        \n        // Advance the position\n        let new_next = AdvanceDataPos(&pnow, pnow_len);\n        iter.pnext = new_next.map(|slice| slice.to_vec());\n\n        if let Some(next) = &iter.pnext {\n            unsafe {\n                if next.as_ptr() < pnow_ptr.add(pnow_len) {\n                    return 0;\n                }\n            }\n        }\n\n        GetValue(Some(&pnow), value)\n    } else {\n        0\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "AdvanceDataPos",
            "GetValue",
            "binn",
            "binn_iter"
        ],
        "header": "BOOL binn_list_next(binn_iter *iter, binn *value)",
        "params": [
            "binn_iter *iter",
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "iter",
            "value",
            "pnow",
            "pnow_idx"
        ],
        "calle": [
            "GetValue",
            "AdvanceDataPos"
        ],
        "calle_c": [],
        "key": "binn_list_next",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_list_read_next": {
        "source_code": "void *binn_list_read_next(binn_iter *iter, int *ptype, int *psize)\n{\n  binn value;\n  if (binn_list_next(iter, &value) == 0)\n  {\n    return 0;\n  }\n  if (ptype)\n  {\n    *ptype = value.type;\n  }\n  if (psize)\n  {\n    *psize = value.size;\n  }\n  return store_value(&value);\n}\n\n",
        "translated_code": "pub fn binn_list_read_next(\n    iter: Option<&mut BinnIter>,\n    ptype: Option<&mut i32>,\n    psize: Option<&mut i32>,\n) -> Option<Box<()>> {\n    let mut value = None;\n    \n    // Call binn_list_next with mutable references to iter and value\n    if binn_list_next(iter, Some(&mut value)) == 0 {\n        return None;\n    }\n\n    // Unwrap the value safely\n    if let Some(value) = value {\n        // Update ptype if it's Some\n        if let Some(ptype) = ptype {\n            *ptype = value.type_;\n        }\n\n        // Update psize if it's Some\n        if let Some(psize) = psize {\n            *psize = value.size;\n        }\n\n        // Store the value and return the result\n        store_value(Some(value))\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_iter",
            "binn_list_next",
            "store_value"
        ],
        "header": "void *binn_list_read_next(binn_iter *iter, int *ptype, int *psize)",
        "params": [
            "binn_iter *iter",
            "int *ptype",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "iter",
            "ptype",
            "psize",
            "value"
        ],
        "calle": [
            "store_value",
            "binn_list_next"
        ],
        "calle_c": [],
        "key": "binn_list_read_next",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_map_read_next": {
        "source_code": "void *binn_map_read_next(binn_iter *iter, int *pid, int *ptype, int *psize)\n{\n  binn value;\n  if (binn_map_next(iter, pid, &value) == 0)\n  {\n    return 0;\n  }\n  if (ptype)\n  {\n    *ptype = value.type;\n  }\n  if (psize)\n  {\n    *psize = value.size;\n  }\n  return store_value(&value);\n}\n\n",
        "translated_code": "pub fn binn_map_read_next(\n    iter: Option<&mut BinnIter>,\n    pid: Option<&mut i32>,\n    ptype: Option<&mut i32>,\n    psize: Option<&mut i32>,\n) -> Option<Box<()>> {\n    let mut value: binn = None;\n    \n    if binn_map_next(iter, pid, Some(&mut value)) == 0 {\n        return None;\n    }\n\n    if let Some(ptype) = ptype {\n        if let Some(ref value) = value {\n            *ptype = value.type_;\n        }\n    }\n\n    if let Some(psize) = psize {\n        if let Some(ref value) = value {\n            *psize = value.size;\n        }\n    }\n\n    store_value(value)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_iter",
            "binn_map_next",
            "store_value"
        ],
        "header": "void *binn_map_read_next(binn_iter *iter, int *pid, int *ptype, int *psize)",
        "params": [
            "binn_iter *iter",
            "int *pid",
            "int *ptype",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "iter",
            "pid",
            "ptype",
            "psize",
            "value"
        ],
        "calle": [
            "store_value",
            "binn_map_next"
        ],
        "calle_c": [],
        "key": "binn_map_read_next",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_object_read_next": {
        "source_code": "void *binn_object_read_next(binn_iter *iter, char *pkey, int *ptype, int *psize)\n{\n  binn value;\n  if (binn_object_next(iter, pkey, &value) == 0)\n  {\n    return 0;\n  }\n  if (ptype)\n  {\n    *ptype = value.type;\n  }\n  if (psize)\n  {\n    *psize = value.size;\n  }\n  return store_value(&value);\n}\n\n",
        "translated_code": "pub fn binn_object_read_next(\n    iter: Option<&mut BinnIter>,\n    pkey: Option<&mut [u8]>,\n    ptype: Option<&mut i32>,\n    psize: Option<&mut i32>,\n) -> Option<Box<()>> {\n    let mut value: Option<Box<BinnStruct>> = None;\n    \n    if binn_object_next(iter, pkey, Some(&mut value)) == 0 {\n        return None;\n    }\n\n    if let Some(ptype) = ptype {\n        if let Some(ref value) = value {\n            *ptype = value.type_;\n        }\n    }\n\n    if let Some(psize) = psize {\n        if let Some(ref value) = value {\n            *psize = value.size;\n        }\n    }\n\n    store_value(value)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_iter",
            "binn_object_next",
            "store_value"
        ],
        "header": "void *binn_object_read_next(binn_iter *iter, char *pkey, int *ptype, int *psize)",
        "params": [
            "binn_iter *iter",
            "char *pkey",
            "int *ptype",
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "iter",
            "pkey",
            "ptype",
            "psize",
            "value"
        ],
        "calle": [
            "store_value",
            "binn_object_next"
        ],
        "calle_c": [],
        "key": "binn_object_read_next",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_set_string": {
        "source_code": "BOOL binn_set_string(binn *item, char *str, binn_mem_free pfree)\n{\n  if ((item == 0) || (str == 0))\n  {\n    return 0;\n  }\n  if (pfree == ((binn_mem_free) (-1)))\n  {\n    item->ptr = binn_memdup(str, strlen(str) + 1);\n    if (item->ptr == 0)\n    {\n      return 0;\n    }\n    item->freefn = free_fn;\n  }\n  else\n  {\n    item->ptr = str;\n    item->freefn = pfree;\n  }\n  item->type = 0xA0;\n  return 1;\n}\n\n",
        "translated_code": "pub fn binn_set_string(item: &mut BinnStruct, str: Option<&CStr>, pfree: BinnMemFree) -> BOOL {\n    // Check for NULL pointers (None in Rust)\n    if item.ptr.is_some() || str.is_none() {\n        return 0;\n    }\n\n    let str = str.unwrap();\n\n    // Compare with None directly since we can't compare function pointers\n    if pfree.is_none() {\n        // Convert CStr to bytes and duplicate\n        let bytes = str.to_bytes_with_nul();\n        let boxed_bytes = binn_memdup(Some(bytes), (bytes.len()) as i32);\n        \n        if boxed_bytes.is_none() {\n            return 0;\n        }\n        \n        // Convert Box<[u8]> to Box<()>\n        let ptr = boxed_bytes.map(|b| unsafe { Box::from_raw(Box::into_raw(b) as *mut ()) });\n        item.ptr = ptr;\n        \n        // Lock the FREE_FN mutex and set the free function\n        let mut free_fn_guard = FREE_FN.lock().unwrap();\n        if let Some(mut wrapper) = free_fn_guard.take() {\n            item.freefn = Some(Box::new(move |ptr: Option<Box<()>>| {\n                if let Some(p) = ptr {\n                    let raw_ptr = Box::into_raw(p);\n                    let b = unsafe { Box::from_raw(raw_ptr as *mut u8) };\n                    (wrapper.0)(Some(Box::new(b) as Box<dyn std::any::Any + Send>));\n                } else {\n                    (wrapper.0)(None);\n                }\n            }) as Box<dyn FnMut(Option<Box<()>>)>);\n        }\n    } else {\n        // Convert CStr to raw pointer (unsafe but necessary for FFI compatibility)\n        let ptr = unsafe { Box::from_raw(str.as_ptr() as *mut ()) };\n        item.ptr = Some(ptr);\n        item.freefn = pfree;\n    }\n\n    item.type_ = 0xA0;\n    1\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_mem_free",
            "binn_memdup",
            "free_fn"
        ],
        "header": "BOOL binn_set_string(binn *item, char *str, binn_mem_free pfree)",
        "params": [
            "binn *item",
            "char *str",
            "binn_mem_free pfree"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "item",
            "str",
            "pfree",
            "free_fn"
        ],
        "calle": [
            "strlen",
            "binn_memdup"
        ],
        "calle_c": [
            "strlen"
        ],
        "key": "binn_set_string",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_set_blob": {
        "source_code": "BOOL binn_set_blob(binn *item, void *ptr, int size, binn_mem_free pfree)\n{\n  if ((item == 0) || (ptr == 0))\n  {\n    return 0;\n  }\n  if (pfree == ((binn_mem_free) (-1)))\n  {\n    item->ptr = binn_memdup(ptr, size);\n    if (item->ptr == 0)\n    {\n      return 0;\n    }\n    item->freefn = free_fn;\n  }\n  else\n  {\n    item->ptr = ptr;\n    item->freefn = pfree;\n  }\n  item->type = 0xC0;\n  item->size = size;\n  return 1;\n}\n\n",
        "translated_code": "pub fn binn_set_blob(\n    item: &mut Option<Box<BinnStruct>>,\n    ptr: Option<Box<()>>,\n    size: i32,\n    pfree: BinnMemFree,\n) -> BOOL {\n    // Check for NULL pointers (represented as None in Rust)\n    if item.is_none() || ptr.is_none() {\n        return 0;\n    }\n\n    // Safe unwrap since we checked for None above\n    let item = item.as_mut().unwrap();\n\n    // Compare pfree with -1 cast to BinnMemFree\n    if pfree.is_none() {\n        // Convert ptr to &[u8] for binn_memdup (assuming ptr points to bytes)\n        let ptr_slice = ptr.as_ref().map(|p| unsafe {\n            std::slice::from_raw_parts(p.as_ref() as *const _ as *const u8, size as usize)\n        });\n        \n        item.ptr = binn_memdup(ptr_slice, size).map(|b| Box::into_raw(b) as *mut u8 as *mut ())\n            .map(|ptr| unsafe { Box::from_raw(ptr) });\n        if item.ptr.is_none() {\n            return 0;\n        }\n        \n        // Lock the FREE_FN mutex and set the freefn\n        let mut free_fn_guard = FREE_FN.lock().unwrap();\n        if let Some(mut wrapper) = free_fn_guard.take() {\n            item.freefn = Some(Box::new(move |ptr| wrapper.0(ptr.map(|p| p as Box<dyn std::any::Any + Send>))));\n        }\n    } else {\n        item.ptr = ptr;\n        item.freefn = pfree;\n    }\n\n    item.type_ = 0xC0;\n    item.size = size;\n    1\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_mem_free",
            "binn_memdup",
            "free_fn"
        ],
        "header": "BOOL binn_set_blob(binn *item, void *ptr, int size, binn_mem_free pfree)",
        "params": [
            "binn *item",
            "void *ptr",
            "int size",
            "binn_mem_free pfree"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "item",
            "ptr",
            "size",
            "pfree",
            "free_fn"
        ],
        "calle": [
            "binn_memdup"
        ],
        "calle_c": [],
        "key": "binn_set_blob",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_get_str": {
        "source_code": "char *binn_get_str(binn *value)\n{\n  int64 vint;\n  char buf[128];\n  if (value == 0)\n  {\n    return 0;\n  }\n  if (type_family(value->type) == 0xf2)\n  {\n    if (copy_int_value(value->ptr, &vint, value->type, 0x81) == 0)\n    {\n      return 0;\n    }\n    snprintf(buf, sizeof(buf), \"%lli\", vint);\n    goto loc_convert_value;\n  }\n  switch (value->type)\n  {\n    case 0x62:\n      value->vdouble = value->vfloat;\n\n    case 0x82:\n      snprintf(buf, sizeof(buf), \"%g\", value->vdouble);\n      goto loc_convert_value;\n\n    case 0xA0:\n      return (char *) value->ptr;\n\n    case 0x80061:\n      if (value->vbool)\n    {\n      strcpy(buf, \"true\");\n    }\n    else\n      strcpy(buf, \"false\");\n      goto loc_convert_value;\n\n  }\n\n  return 0;\n  loc_convert_value:\n  value->ptr = strdup(buf);\n\n  if (value->ptr == 0)\n  {\n    return 0;\n  }\n  value->freefn = free;\n  value->type = 0xA0;\n  return (char *) value->ptr;\n}\n\n",
        "translated_code": "pub fn binn_get_str(value: binn) -> Option<Box<CString>> {\n    // Check for NULL pointer (None in Rust)\n    let mut value = value?;\n    \n    let mut buf = [0u8; 128];\n    let mut vint: int64 = 0;\n\n    if type_family(value.type_) == 0xf2 {\n        if !copy_int_value(\n            value.ptr.as_ref().map(|p| unsafe { \n                std::slice::from_raw_parts(Box::into_raw(p.clone()) as *const u8, std::mem::size_of::<int64>()) \n            }),\n            Some(&mut vint.to_ne_bytes()),\n            value.type_,\n            0x81,\n        ) {\n            return None;\n        }\n        \n        let s = format!(\"{}\", vint);\n        buf[..s.len()].copy_from_slice(s.as_bytes());\n        goto_loc_convert_value(&mut value, &buf, s.len())?;\n        return Some(Box::new(CString::new(s + \"\\0\").unwrap()));\n    }\n\n    match value.type_ {\n        0x62 => {\n            value.value.vdouble = value.value.vfloat as f64;\n            // Fall through to 0x82 case\n        }\n        0x82 => {\n            let s = format!(\"{}\", value.value.vdouble);\n            buf[..s.len()].copy_from_slice(s.as_bytes());\n            goto_loc_convert_value(&mut value, &buf, s.len())?;\n            return Some(Box::new(CString::new(s + \"\\0\").unwrap()));\n        }\n        0xA0 => {\n            return value.ptr.as_ref().map(|p| {\n                Box::new(unsafe { CString::from_raw(Box::into_raw(p.clone()) as *mut i8) })\n            });\n        }\n        0x80061 => {\n            let s = if value.value.vbool != 0 { \"true\" } else { \"false\" };\n            buf[..s.len()].copy_from_slice(s.as_bytes());\n            goto_loc_convert_value(&mut value, &buf, s.len())?;\n            return Some(Box::new(CString::new(s.to_string() + \"\\0\").unwrap()));\n        }\n        _ => {}\n    }\n\n    None\n}\n\nfn goto_loc_convert_value(value: &mut BinnStruct, buf: &[u8], len: usize) -> Option<()> {\n    let c_str = CString::new(&buf[..len]).ok()?;\n    let boxed_cstr = Box::new(c_str);\n    let ptr = Box::into_raw(boxed_cstr) as *mut ();\n    \n    value.ptr = Some(unsafe { Box::from_raw(ptr) });\n    value.freefn = Some(Box::new(|ptr_opt| unsafe {\n        if let Some(ptr_box) = ptr_opt {\n            let ptr = Box::into_raw(ptr_box) as *mut CString;\n            let _ = Box::from_raw(ptr);\n        }\n    }));\n    value.type_ = 0xA0;\n    Some(())\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "copy_int_value",
            "int64",
            "type_family"
        ],
        "header": "char *binn_get_str(binn *value)",
        "params": [
            "binn *value"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value",
            "vint",
            "buf"
        ],
        "calle": [
            "strcpy",
            "copy_int_value",
            "strdup",
            "type_family",
            "snprintf"
        ],
        "calle_c": [
            "strcpy",
            "strdup",
            "snprintf"
        ],
        "key": "binn_get_str",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_int64": {
        "source_code": "void test_int64()\n{\n  int64 i64;\n  char buf[64];\n  printf(\"testing int64... \");\n  pass_int64(9223372036854775807);\n  i64 = return_int64();\n  assert(i64 == 9223372036854775807);\n  i64toa(i64, buf, 10);\n  assert(strcmp(buf, \"9223372036854775807\") == 0);\n  i64 = return_passed_int64(-987654321987654321);\n  assert(i64 == (-987654321987654321));\n  i64toa(i64, buf, 10);\n  assert(strcmp(buf, \"-987654321987654321\") == 0);\n  printf(\"OK\\n\");\n}\n\n",
        "translated_code": "use std::assert_eq;\n\npub fn test_int64() {\n    let mut i64: int64;\n    let mut buf = [0u8; 64];\n    \n    println!(\"testing int64... \");\n    \n    pass_int64(9223372036854775807);\n    \n    i64 = return_int64();\n    assert_eq!(i64, 9223372036854775807);\n    \n    i64toa(i64, &mut buf, 10).expect(\"i64toa failed\");\n    assert_eq!(\n        std::str::from_utf8(&buf).unwrap().trim_end_matches('\\0'),\n        \"9223372036854775807\"\n    );\n    \n    i64 = return_passed_int64(-987654321987654321);\n    assert_eq!(i64, -987654321987654321);\n    \n    i64toa(i64, &mut buf, 10).expect(\"i64toa failed\");\n    assert_eq!(\n        std::str::from_utf8(&buf).unwrap().trim_end_matches('\\0'),\n        \"-987654321987654321\"\n    );\n    \n    println!(\"OK\");\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "i64toa",
            "int64",
            "pass_int64",
            "return_int64",
            "return_passed_int64"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "i64",
            "buf"
        ],
        "calle": [
            "strcmp",
            "assert",
            "return_int64",
            "return_passed_int64",
            "pass_int64",
            "i64toa",
            "printf"
        ],
        "calle_c": [
            "assert",
            "strcmp",
            "printf"
        ],
        "key": "test_int64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_list_next_value": {
        "source_code": "binn *binn_list_next_value(binn_iter *iter)\n{\n  binn *value;\n  unsigned int value_idx = 0;\n  value_idx = (binn *) binn_malloc(sizeof(binn));\n  if (binn_list_next(iter, value) == 0)\n  {\n    free_fn(value);\n    return 0;\n  }\n  value->allocated = 1;\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_list_next_value(iter: Option<&mut BinnIter>) -> Option<Box<BinnStruct>> {\n    // Allocate memory for a new BinnStruct\n    let mut value: Option<Box<BinnStruct>> = match binn_malloc(std::mem::size_of::<BinnStruct>() as i32) {\n        Some(alloc) => {\n            // Convert to raw pointer first to avoid move issues\n            let ptr = Box::into_raw(alloc);\n            // Directly cast to BinnStruct since we know the type\n            Some(unsafe { Box::from_raw(ptr as *mut BinnStruct) })\n        }\n        None => return None,\n    };\n\n    // Try to get the next value from the list\n    if binn_list_next(iter, Some(&mut value)) == 0 {\n        // If failed, free the allocated memory and return None\n        if let Some(free_fn) = &mut *FREE_FN.lock().unwrap() {\n            if let Some(v) = value {\n                let ptr = Box::into_raw(v);\n                let boxed = unsafe { Box::from_raw(ptr as *mut (dyn std::any::Any + Send)) };\n                (free_fn.0)(Some(boxed));\n            }\n        }\n        return None;\n    }\n\n    // Mark the value as allocated and return it\n    if let Some(mut v) = value {\n        v.allocated = 1;\n        Some(v)\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_iter",
            "binn_list_next",
            "binn_malloc",
            "free_fn"
        ],
        "header": "binn *binn_list_next_value(binn_iter *iter)",
        "params": [
            "binn_iter *iter"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "iter",
            "value",
            "value_idx",
            "free_fn"
        ],
        "calle": [
            "binn_malloc",
            "binn_list_next",
            "free_fn"
        ],
        "calle_c": [
            "free_fn"
        ],
        "key": "binn_list_next_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_map_next_value": {
        "source_code": "binn *binn_map_next_value(binn_iter *iter, int *pid)\n{\n  binn *value;\n  unsigned int value_idx = 0;\n  value_idx = (binn *) binn_malloc(sizeof(binn));\n  if (binn_map_next(iter, pid, value) == 0)\n  {\n    free_fn(value);\n    return 0;\n  }\n  value->allocated = 1;\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_map_next_value(iter: Option<&mut BinnIter>, pid: Option<&mut i32>) -> Option<binn> {\n    // Allocate a new binn value\n    let value = binn_malloc(std::mem::size_of::<BinnStruct>() as i32);\n    let mut value = match value {\n        Some(v) => v,\n        None => return None,\n    };\n\n    // Downcast the Box<dyn Any> to Box<BinnStruct>\n    let value = match value.downcast::<BinnStruct>() {\n        Ok(v) => v,\n        Err(_) => return None,\n    };\n\n    // Create a mutable reference to the binn value\n    let mut binn_value = Some(Box::new(*value));\n\n    // Call binn_map_next with the mutable references wrapped in Some\n    if binn_map_next(iter, pid, Some(&mut binn_value)) == 0 {\n        // If the operation failed, free the allocated memory\n        if let Some(free_fn) = &mut *FREE_FN.lock().unwrap() {\n            (free_fn.0)(Some(Box::new(binn_value)));\n        }\n        return None;\n    }\n\n    // Set the allocated flag and return the value\n    if let Some(b) = &mut binn_value {\n        b.allocated = 1;\n    }\n    Some(binn_value)\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_iter",
            "binn_malloc",
            "binn_map_next",
            "free_fn"
        ],
        "header": "binn *binn_map_next_value(binn_iter *iter, int *pid)",
        "params": [
            "binn_iter *iter",
            "int *pid"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "iter",
            "pid",
            "value",
            "value_idx",
            "free_fn"
        ],
        "calle": [
            "binn_malloc",
            "binn_map_next",
            "free_fn"
        ],
        "calle_c": [
            "free_fn"
        ],
        "key": "binn_map_next_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_object_next_value": {
        "source_code": "binn *binn_object_next_value(binn_iter *iter, char *pkey)\n{\n  binn *value;\n  unsigned int value_idx = 0;\n  value_idx = (binn *) binn_malloc(sizeof(binn));\n  if (binn_object_next(iter, pkey, value) == 0)\n  {\n    free_fn(value);\n    return 0;\n  }\n  value->allocated = 1;\n  return value;\n}\n\n",
        "translated_code": "pub fn binn_object_next_value(\n    iter: Option<&mut BinnIter>,\n    pkey: Option<&mut [u8]>,\n) -> Option<Box<BinnStruct>> {\n    // Allocate memory for the binn value\n    let value = match binn_malloc(std::mem::size_of::<BinnStruct>() as i32) {\n        Some(v) => v,\n        None => return None,\n    };\n\n    // Downcast the Box<dyn Any> to Box<BinnStruct>\n    let value = match value.downcast::<BinnStruct>() {\n        Ok(v) => v,\n        Err(_) => return None,\n    };\n\n    // Create a mutable reference to the boxed value\n    let mut boxed_value = Some(value);\n    let success = binn_object_next(iter, pkey, Some(&mut boxed_value));\n\n    if success == 0 {\n        // Free the allocated memory if the operation failed\n        if let Some(free_fn) = &mut *FREE_FN.lock().unwrap() {\n            (free_fn.0)(Some(boxed_value.unwrap()));\n        }\n        return None;\n    }\n\n    // Take the value from the boxed_value if successful\n    if let Some(mut value) = boxed_value {\n        value.allocated = 1;\n        Some(value)\n    } else {\n        None\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_iter",
            "binn_malloc",
            "binn_object_next",
            "free_fn"
        ],
        "header": "binn *binn_object_next_value(binn_iter *iter, char *pkey)",
        "params": [
            "binn_iter *iter",
            "char *pkey"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "iter",
            "pkey",
            "value",
            "value_idx",
            "free_fn"
        ],
        "calle": [
            "binn_malloc",
            "binn_object_next",
            "free_fn"
        ],
        "calle_c": [
            "free_fn"
        ],
        "key": "binn_object_next_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "binn_get_int32": {
        "source_code": "BOOL binn_get_int32(binn *value, int *pint)\n{\n  if ((value == 0) || (pint == 0))\n  {\n    return 0;\n  }\n  if (type_family(value->type) == 0xf2)\n  {\n    return copy_int_value(value->ptr, pint, value->type, 0x61);\n  }\n  switch (value->type)\n  {\n    case 0x62:\n      if ((value->vfloat < INT32_MIN) || (value->vfloat > INT32_MAX))\n    {\n      return 0;\n    }\n      *pint = (value->vfloat >= 0.0) ? ((int) (value->vfloat + 0.5)) : (((value->vfloat - ((double) ((int) value->vfloat))) <= (-0.5)) ? ((int) value->vfloat) : ((int) (value->vfloat - 0.5)));\n      break;\n\n    case 0x82:\n      if ((value->vdouble < INT32_MIN) || (value->vdouble > INT32_MAX))\n    {\n      return 0;\n    }\n      *pint = (value->vdouble >= 0.0) ? ((int) (value->vdouble + 0.5)) : (((value->vdouble - ((double) ((int) value->vdouble))) <= (-0.5)) ? ((int) value->vdouble) : ((int) (value->vdouble - 0.5)));\n      break;\n\n    case 0xA0:\n      if (is_integer((char *) value->ptr))\n    {\n      *pint = atoi((char *) value->ptr);\n    }\n    else\n      if (is_float((char *) value->ptr))\n    {\n      *pint = (atof((char *) value->ptr) >= 0.0) ? ((int) (atof((char *) value->ptr) + 0.5)) : (((atof((char *) value->ptr) - ((double) ((int) atof((char *) value->ptr)))) <= (-0.5)) ? ((int) atof((char *) value->ptr)) : ((int) (atof((char *) value->ptr) - 0.5)));\n    }\n    else\n      return 0;\n      break;\n\n    case 0x80061:\n      *pint = value->vbool;\n      break;\n\n    default:\n      return 0;\n\n  }\n\n  return 1;\n}\n\n",
        "translated_code": "pub fn binn_get_int32(value: Option<&BinnStruct>, pint: Option<&mut i32>) -> BOOL {\n    // Check for null pointers (translated to Option checks in Rust)\n    if value.is_none() || pint.is_none() {\n        return 0;\n    }\n\n    let value = value.unwrap();\n    let pint = pint.unwrap();\n\n    if type_family(value.type_) == 0xf2 {\n        return if copy_int_value(\n            value.ptr.as_ref().map(|p| unsafe { std::slice::from_raw_parts(p.as_ref() as *const _ as *const u8, value.size as usize) }),\n            Some(&mut [*pint as u8; 4]),\n            value.type_,\n            0x61,\n        ) {\n            1\n        } else {\n            0\n        };\n    }\n\n    match value.type_ {\n        0x62 => {\n            let vfloat = value.value.vfloat as f64;\n            if vfloat < i32::MIN as f64 || vfloat > i32::MAX as f64 {\n                return 0;\n            }\n            *pint = if vfloat >= 0.0 {\n                (vfloat + 0.5) as i32\n            } else {\n                let int_part = vfloat as i32;\n                if (vfloat - int_part as f64) <= -0.5 {\n                    int_part\n                } else {\n                    (vfloat - 0.5) as i32\n                }\n            };\n        }\n        0x82 => {\n            let vdouble = value.value.vdouble;\n            if vdouble < i32::MIN as f64 || vdouble > i32::MAX as f64 {\n                return 0;\n            }\n            *pint = if vdouble >= 0.0 {\n                (vdouble + 0.5) as i32\n            } else {\n                let int_part = vdouble as i32;\n                if (vdouble - int_part as f64) <= -0.5 {\n                    int_part\n                } else {\n                    (vdouble - 0.5) as i32\n                }\n            };\n        }\n        0xA0 => {\n            let ptr = value.ptr.as_ref().map(|p| unsafe { CStr::from_ptr(p.as_ref() as *const _ as *const i8) });\n            if let Some(cstr) = ptr {\n                if let Ok(s) = cstr.to_str() {\n                    if is_integer(Some(s)) != 0 {\n                        *pint = s.parse::<i32>().unwrap_or(0);\n                    } else if is_float(Some(s)) != 0 {\n                        let float_val = s.parse::<f64>().unwrap_or(0.0);\n                        *pint = if float_val >= 0.0 {\n                            (float_val + 0.5) as i32\n                        } else {\n                            let int_part = float_val as i32;\n                            if (float_val - int_part as f64) <= -0.5 {\n                                int_part\n                            } else {\n                                (float_val - 0.5) as i32\n                            }\n                        };\n                    } else {\n                        return 0;\n                    }\n                } else {\n                    return 0;\n                }\n            } else {\n                return 0;\n            }\n        }\n        0x80061 => {\n            *pint = value.value.vbool as i32;\n        }\n        _ => return 0,\n    }\n\n    1\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "copy_int_value",
            "is_float",
            "is_integer",
            "type_family"
        ],
        "header": "BOOL binn_get_int32(binn *value, int *pint)",
        "params": [
            "binn *value",
            "int *pint"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value",
            "pint"
        ],
        "calle": [
            "atoi",
            "copy_int_value",
            "type_family",
            "is_integer",
            "atof",
            "is_float"
        ],
        "calle_c": [
            "atof",
            "atoi"
        ],
        "key": "binn_get_int32",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_add_value": {
        "source_code": "BOOL binn_add_value(binn *item, int binn_type, int id, char *name, int type, void *pvalue, int size)\n{\n  switch (binn_type)\n  {\n    case 0xE0:\n      return binn_list_add(item, type, pvalue, size);\n\n    case 0xE1:\n      return binn_map_set(item, id, type, pvalue, size);\n\n    case 0xE2:\n      return binn_object_set(item, name, type, pvalue, size);\n\n    default:\n      return 0;\n\n  }\n\n}\n\n",
        "translated_code": "pub fn binn_add_value(\n    item: &mut binn,\n    binn_type: i32,\n    id: i32,\n    name: Option<&str>,\n    type_: i32,\n    pvalue: Option<&mut Option<Box<dyn std::any::Any>>>,\n    size: i32,\n) -> BOOL {\n    match binn_type {\n        0xE0 => binn_list_add(item, type_, pvalue, size),\n        0xE1 => binn_map_set(item, id, type_, pvalue, size),\n        0xE2 => binn_object_set(item, name, type_, pvalue, size),\n        _ => 0,\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_list_add",
            "binn_map_set",
            "binn_object_set",
            "binn_type"
        ],
        "params": [
            "binn *item",
            "int binn_type",
            "int id",
            "char *name",
            "int type",
            "void *pvalue",
            "int size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "item",
            "binn_type",
            "id",
            "name",
            "type",
            "pvalue",
            "size"
        ],
        "calle": [
            "binn_list_add",
            "binn_type",
            "binn_map_set",
            "binn_object_set"
        ],
        "calle_c": [],
        "key": "binn_add_value",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "is_bool_str": {
        "source_code": "static BOOL is_bool_str(char *str, BOOL *pbool)\n{\n  int64 vint;\n  double vdouble;\n  if ((str == 0) || (pbool == 0))\n  {\n    return 0;\n  }\n  if (strcasecmp(str, \"true\") == 0)\n  {\n    goto loc_true;\n  }\n  if (strcasecmp(str, \"yes\") == 0)\n  {\n    goto loc_true;\n  }\n  if (strcasecmp(str, \"on\") == 0)\n  {\n    goto loc_true;\n  }\n  if (strcasecmp(str, \"false\") == 0)\n  {\n    goto loc_false;\n  }\n  if (strcasecmp(str, \"no\") == 0)\n  {\n    goto loc_false;\n  }\n  if (strcasecmp(str, \"off\") == 0)\n  {\n    goto loc_false;\n  }\n  if (is_integer(str))\n  {\n    vint = atoi64(str);\n    *pbool = (vint != 0) ? (1) : (0);\n    return 1;\n  }\n  else\n    if (is_float(str))\n  {\n    vdouble = atof(str);\n    *pbool = (vdouble != 0) ? (1) : (0);\n    return 1;\n  }\n  return 0;\n  loc_true:\n  *pbool = 1;\n\n  return 1;\n  loc_false:\n  *pbool = 0;\n\n  return 1;\n}\n\n",
        "translated_code": "use std::ffi::CStr;\nuse std::os::raw::c_char;\n\npub fn is_bool_str(str: Option<&str>, pbool: Option<&mut BOOL>) -> BOOL {\n    // Check for null pointers (None in Rust)\n    if str.is_none() || pbool.is_none() {\n        return 0;\n    }\n\n    let str = str.unwrap();\n    let pbool = pbool.unwrap();\n\n    // Convert &str to CStr for case-insensitive comparison\n    let cstr = CStr::from_bytes_with_nul(str.as_bytes()).unwrap_or_default();\n\n    // Helper function for case-insensitive comparison\n    fn compare_ignore_case(s1: &CStr, s2: &str) -> bool {\n        s1.to_bytes().eq_ignore_ascii_case(s2.as_bytes())\n    }\n\n    // Check for true variants\n    if compare_ignore_case(&cstr, \"true\") \n        || compare_ignore_case(&cstr, \"yes\") \n        || compare_ignore_case(&cstr, \"on\") {\n        *pbool = 1;\n        return 1;\n    }\n\n    // Check for false variants\n    if compare_ignore_case(&cstr, \"false\") \n        || compare_ignore_case(&cstr, \"no\") \n        || compare_ignore_case(&cstr, \"off\") {\n        *pbool = 0;\n        return 1;\n    }\n\n    // Check for numeric values\n    if is_integer(Some(str)) != 0 {\n        if let Some(vint) = atoi64(Some(str)) {\n            *pbool = if vint != 0 { 1 } else { 0 };\n            return 1;\n        }\n    } else if is_float(Some(str)) != 0 {\n        // Using Rust's parse instead of atof for safety\n        if let Ok(vdouble) = str.parse::<f64>() {\n            *pbool = if vdouble != 0.0 { 1 } else { 0 };\n            return 1;\n        }\n    }\n\n    0\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "atoi64",
            "int64",
            "is_float",
            "is_integer"
        ],
        "params": [
            "char *str",
            "BOOL *pbool"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "str",
            "pbool",
            "vint",
            "vdouble"
        ],
        "calle": [
            "atoi64",
            "is_integer",
            "atof",
            "strcasecmp",
            "is_float"
        ],
        "calle_c": [
            "atof",
            "strcasecmp"
        ],
        "key": "is_bool_str",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_endianess": {
        "source_code": "void test_endianess()\n{\n  u16 vshort1;\n  u16 vshort2;\n  u16 vshort3;\n  u32 vint1;\n  u32 vint2;\n  u32 vint3;\n  u64 value1;\n  u64 value2;\n  u64 value3;\n  printf(\"testing endianess... \");\n  vshort1 = 0x1122;\n  copy_be16(&vshort2, &vshort1);\n  assert(vshort2 == 0x2211);\n  copy_be16(&vshort3, &vshort2);\n  assert(vshort3 == vshort1);\n  vshort1 = 0xF123;\n  copy_be16(&vshort2, &vshort1);\n  assert(vshort2 == 0x23F1);\n  copy_be16(&vshort3, &vshort2);\n  assert(vshort3 == vshort1);\n  vshort1 = 0x0123;\n  copy_be16(&vshort2, &vshort1);\n  assert(vshort2 == 0x2301);\n  copy_be16(&vshort3, &vshort2);\n  assert(vshort3 == vshort1);\n  vint1 = 0x11223344;\n  copy_be32(&vint2, &vint1);\n  assert(vint2 == 0x44332211);\n  copy_be32(&vint3, &vint2);\n  assert(vint3 == vint1);\n  vint1 = 0xF1234580;\n  copy_be32(&vint2, &vint1);\n  assert(vint2 == 0x804523F1);\n  copy_be32(&vint3, &vint2);\n  assert(vint3 == vint1);\n  vint1 = 0x00112233;\n  copy_be32(&vint2, &vint1);\n  assert(vint2 == 0x33221100);\n  copy_be32(&vint3, &vint2);\n  assert(vint3 == vint1);\n  value1 = 0x1122334455667788;\n  copy_be64(&value2, &value1);\n  assert(value2 == 0x8877665544332211);\n  copy_be64(&value3, &value2);\n  assert(value3 == value1);\n  printf(\"OK\\n\");\n}\n\n",
        "translated_code": "pub fn test_endianess() {\n    let mut vshort1: u16;\n    let mut vshort2: u16 = 0;\n    let mut vshort3: u16 = 0;\n    let mut vint1: u32;\n    let mut vint2: u32 = 0;\n    let mut vint3: u32 = 0;\n    let mut value1: u64;\n    let mut value2: u64 = 0;\n    let mut value3: u64 = 0;\n\n    println!(\"testing endianess... \");\n    \n    vshort1 = 0x1122;\n    copy_be16(&mut vshort2, &vshort1);\n    assert_eq!(vshort2, 0x2211);\n    copy_be16(&mut vshort3, &vshort2);\n    assert_eq!(vshort3, vshort1);\n    \n    vshort1 = 0xF123;\n    copy_be16(&mut vshort2, &vshort1);\n    assert_eq!(vshort2, 0x23F1);\n    copy_be16(&mut vshort3, &vshort2);\n    assert_eq!(vshort3, vshort1);\n    \n    vshort1 = 0x0123;\n    copy_be16(&mut vshort2, &vshort1);\n    assert_eq!(vshort2, 0x2301);\n    copy_be16(&mut vshort3, &vshort2);\n    assert_eq!(vshort3, vshort1);\n    \n    vint1 = 0x11223344;\n    copy_be32(&mut vint2, &vint1);\n    assert_eq!(vint2, 0x44332211);\n    copy_be32(&mut vint3, &vint2);\n    assert_eq!(vint3, vint1);\n    \n    vint1 = 0xF1234580;\n    copy_be32(&mut vint2, &vint1);\n    assert_eq!(vint2, 0x804523F1);\n    copy_be32(&mut vint3, &vint2);\n    assert_eq!(vint3, vint1);\n    \n    vint1 = 0x00112233;\n    copy_be32(&mut vint2, &vint1);\n    assert_eq!(vint2, 0x33221100);\n    copy_be32(&mut vint3, &vint2);\n    assert_eq!(vint3, vint1);\n    \n    value1 = 0x1122334455667788;\n    copy_be64(&mut value2, &value1);\n    assert_eq!(value2, 0x8877665544332211);\n    copy_be64(&mut value3, &value2);\n    assert_eq!(value3, value1);\n    \n    println!(\"OK\");\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "copy_be16",
            "copy_be32",
            "copy_be64",
            "u16",
            "u32",
            "u64"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "vshort1",
            "vshort2",
            "vshort3",
            "vint1",
            "vint2",
            "vint3",
            "value1",
            "value2",
            "value3"
        ],
        "calle": [
            "assert",
            "copy_be64",
            "copy_be16",
            "copy_be32",
            "printf"
        ],
        "calle_c": [
            "assert",
            "printf"
        ],
        "key": "test_endianess",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_get_bool": {
        "source_code": "BOOL binn_get_bool(binn *value, BOOL *pbool)\n{\n  int64 vint;\n  if ((value == 0) || (pbool == 0))\n  {\n    return 0;\n  }\n  if (type_family(value->type) == 0xf2)\n  {\n    if (copy_int_value(value->ptr, &vint, value->type, 0x81) == 0)\n    {\n      return 0;\n    }\n    *pbool = (vint != 0) ? (1) : (0);\n    return 1;\n  }\n  switch (value->type)\n  {\n    case 0x80061:\n      *pbool = value->vbool;\n      break;\n\n    case 0x62:\n      *pbool = (value->vfloat != 0) ? (1) : (0);\n      break;\n\n    case 0x82:\n      *pbool = (value->vdouble != 0) ? (1) : (0);\n      break;\n\n    case 0xA0:\n      return is_bool_str((char *) value->ptr, pbool);\n\n    default:\n      return 0;\n\n  }\n\n  return 1;\n}\n\n",
        "translated_code": "use std::ffi::CStr;\nuse std::os::raw::c_char;\n\npub fn binn_get_bool(value: Option<&BinnStruct>, pbool: Option<&mut BOOL>) -> BOOL {\n    // Check for null pointers (translated to Option checks)\n    if value.is_none() || pbool.is_none() {\n        return 0;\n    }\n\n    let value = value.unwrap();\n    let pbool = pbool.unwrap();\n\n    if type_family(value.type_) == 0xf2 {\n        let mut vint: int64 = 0;\n        if !copy_int_value(\n            value.ptr.as_ref().map(|p| unsafe { std::slice::from_raw_parts(p.as_ref() as *const _ as *const u8, value.size as usize) }),\n            Some(unsafe { std::slice::from_raw_parts_mut(&mut vint as *mut _ as *mut u8, std::mem::size_of::<int64>()) }),\n            value.type_,\n            0x81,\n        ) {\n            return 0;\n        }\n        *pbool = if vint != 0 { 1 } else { 0 };\n        return 1;\n    }\n\n    match value.type_ {\n        0x80061 => {\n            *pbool = value.value.vbool;\n        }\n        0x62 => {\n            *pbool = if value.value.vfloat != 0.0 { 1 } else { 0 };\n        }\n        0x82 => {\n            *pbool = if value.value.vdouble != 0.0 { 1 } else { 0 };\n        }\n        0xA0 => {\n            let ptr = value.ptr.as_ref().map(|p| unsafe { CStr::from_ptr(p.as_ref() as *const _ as *const c_char) });\n            let str = ptr.and_then(|cstr| cstr.to_str().ok());\n            return is_bool_str(str, Some(pbool));\n        }\n        _ => {\n            return 0;\n        }\n    }\n\n    1\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "binn",
            "copy_int_value",
            "int64",
            "is_bool_str",
            "type_family"
        ],
        "header": "BOOL binn_get_bool(binn *value, BOOL *pbool)",
        "params": [
            "binn *value",
            "BOOL *pbool"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value",
            "pbool",
            "vint"
        ],
        "calle": [
            "is_bool_str",
            "type_family",
            "copy_int_value"
        ],
        "calle_c": [],
        "key": "binn_get_bool",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_get_int64": {
        "source_code": "BOOL binn_get_int64(binn *value, int64 *pint)\n{\n  if ((value == 0) || (pint == 0))\n  {\n    return 0;\n  }\n  if (type_family(value->type) == 0xf2)\n  {\n    return copy_int_value(value->ptr, pint, value->type, 0x81);\n  }\n  switch (value->type)\n  {\n    case 0x62:\n      if ((value->vfloat < INT64_MIN) || (value->vfloat > INT64_MAX))\n    {\n      return 0;\n    }\n      *pint = (value->vfloat >= 0.0) ? ((int) (value->vfloat + 0.5)) : (((value->vfloat - ((double) ((int) value->vfloat))) <= (-0.5)) ? ((int) value->vfloat) : ((int) (value->vfloat - 0.5)));\n      break;\n\n    case 0x82:\n      if ((value->vdouble < INT64_MIN) || (value->vdouble > INT64_MAX))\n    {\n      return 0;\n    }\n      *pint = (value->vdouble >= 0.0) ? ((int) (value->vdouble + 0.5)) : (((value->vdouble - ((double) ((int) value->vdouble))) <= (-0.5)) ? ((int) value->vdouble) : ((int) (value->vdouble - 0.5)));\n      break;\n\n    case 0xA0:\n      if (is_integer((char *) value->ptr))\n    {\n      *pint = atoi64((char *) value->ptr);\n    }\n    else\n      if (is_float((char *) value->ptr))\n    {\n      *pint = (atof((char *) value->ptr) >= 0.0) ? ((int) (atof((char *) value->ptr) + 0.5)) : (((atof((char *) value->ptr) - ((double) ((int) atof((char *) value->ptr)))) <= (-0.5)) ? ((int) atof((char *) value->ptr)) : ((int) (atof((char *) value->ptr) - 0.5)));\n    }\n    else\n      return 0;\n      break;\n\n    case 0x80061:\n      *pint = value->vbool;\n      break;\n\n    default:\n      return 0;\n\n  }\n\n  return 1;\n}\n\n",
        "translated_code": "pub fn binn_get_int64(value: binn, pint: Option<&mut int64>) -> BOOL {\n    // Check for null pointers (translated to Option in Rust)\n    if value.is_none() || pint.is_none() {\n        return 0;\n    }\n\n    let value = value.unwrap();\n    let pint = pint.unwrap();\n\n    if type_family(value.type_) == 0xf2 {\n        return if copy_int_value(\n            value.ptr.as_ref().map(|p| unsafe { std::slice::from_raw_parts(p.as_ref() as *const _ as *const u8, value.size as usize) }),\n            Some(unsafe { std::slice::from_raw_parts_mut(pint as *mut _ as *mut u8, 8) }),\n            value.type_,\n            0x81,\n        ) {\n            1\n        } else {\n            0\n        };\n    }\n\n    match value.type_ {\n        0x62 => {\n            let vfloat = value.value.vfloat as f64;\n            if vfloat < INT64_MIN as f64 || vfloat > INT64_MAX as f64 {\n                return 0;\n            }\n            *pint = if vfloat >= 0.0 {\n                (vfloat + 0.5) as int64\n            } else {\n                let int_part = vfloat as int64;\n                if (vfloat - int_part as f64) <= -0.5 {\n                    int_part\n                } else {\n                    (vfloat - 0.5) as int64\n                }\n            };\n        }\n        0x82 => {\n            let vdouble = value.value.vdouble;\n            if vdouble < INT64_MIN as f64 || vdouble > INT64_MAX as f64 {\n                return 0;\n            }\n            *pint = if vdouble >= 0.0 {\n                (vdouble + 0.5) as int64\n            } else {\n                let int_part = vdouble as int64;\n                if (vdouble - int_part as f64) <= -0.5 {\n                    int_part\n                } else {\n                    (vdouble - 0.5) as int64\n                }\n            };\n        }\n        0xA0 => {\n            if let Some(ptr) = value.ptr.as_ref() {\n                let c_str = unsafe { CStr::from_ptr(ptr.as_ref() as *const _ as *const i8) };\n                if let Ok(s) = c_str.to_str() {\n                    if is_integer(Some(s)) != 0 {\n                        if let Some(val) = atoi64(Some(s)) {\n                            *pint = val;\n                        } else {\n                            return 0;\n                        }\n                    } else if is_float(Some(s)) != 0 {\n                        let float_val = s.parse::<f64>().unwrap_or(0.0);\n                        *pint = if float_val >= 0.0 {\n                            (float_val + 0.5) as int64\n                        } else {\n                            let int_part = float_val as int64;\n                            if (float_val - int_part as f64) <= -0.5 {\n                                int_part\n                            } else {\n                                (float_val - 0.5) as int64\n                            }\n                        };\n                    } else {\n                        return 0;\n                    }\n                } else {\n                    return 0;\n                }\n            } else {\n                return 0;\n            }\n        }\n        0x80061 => {\n            *pint = value.value.vbool as int64;\n        }\n        _ => return 0,\n    }\n\n    1\n}\n\nconst INT64_MIN: int64 = i64::MIN;\nconst INT64_MAX: int64 = i64::MAX;",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "atoi64",
            "binn",
            "copy_int_value",
            "int64",
            "is_float",
            "is_integer",
            "type_family"
        ],
        "header": "BOOL binn_get_int64(binn *value, int64 *pint)",
        "params": [
            "binn *value",
            "int64 *pint"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value",
            "pint"
        ],
        "calle": [
            "atoi64",
            "copy_int_value",
            "type_family",
            "is_integer",
            "atof",
            "is_float"
        ],
        "calle_c": [
            "atof"
        ],
        "key": "binn_get_int64",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "binn_get_double": {
        "source_code": "BOOL binn_get_double(binn *value, double *pfloat)\n{\n  int64 vint;\n  if ((value == 0) || (pfloat == 0))\n  {\n    return 0;\n  }\n  if (type_family(value->type) == 0xf2)\n  {\n    if (copy_int_value(value->ptr, &vint, value->type, 0x81) == 0)\n    {\n      return 0;\n    }\n    *pfloat = (double) vint;\n    return 1;\n  }\n  switch (value->type)\n  {\n    case 0x62:\n      *pfloat = value->vfloat;\n      break;\n\n    case 0x82:\n      *pfloat = value->vdouble;\n      break;\n\n    case 0xA0:\n      if (is_integer((char *) value->ptr))\n    {\n      *pfloat = (double) atoi64((char *) value->ptr);\n    }\n    else\n      if (is_float((char *) value->ptr))\n    {\n      *pfloat = atof((char *) value->ptr);\n    }\n    else\n      return 0;\n      break;\n\n    case 0x80061:\n      *pfloat = value->vbool;\n      break;\n\n    default:\n      return 0;\n\n  }\n\n  return 1;\n}\n\n",
        "translated_code": "pub fn binn_get_double(value: Option<&BinnStruct>, pfloat: Option<&mut f64>) -> bool {\n    // Check for null inputs (equivalent to NULL checks in C)\n    if value.is_none() || pfloat.is_none() {\n        return false;\n    }\n    let value = value.unwrap();\n    let pfloat = pfloat.unwrap();\n\n    let mut vint: i64 = 0;\n    if type_family(value.type_) == 0xf2 {\n        if !copy_int_value(\n            value.ptr.as_ref().map(|p| unsafe { std::slice::from_raw_parts(p.as_ref() as *const _ as *const u8, 8) }),\n            Some(&mut vint.to_ne_bytes()),\n            value.type_,\n            0x81,\n        ) {\n            return false;\n        }\n        *pfloat = vint as f64;\n        return true;\n    }\n\n    match value.type_ {\n        0x62 => {\n            *pfloat = value.value.vfloat as f64;\n        }\n        0x82 => {\n            *pfloat = value.value.vdouble;\n        }\n        0xA0 => {\n            let ptr_str = unsafe {\n                CStr::from_ptr(value.ptr.as_ref().unwrap().as_ref() as *const _ as *const i8)\n                    .to_str()\n                    .ok()\n            };\n            if is_integer(ptr_str) == 1 {\n                if let Some(num) = atoi64(ptr_str) {\n                    *pfloat = num as f64;\n                } else {\n                    return false;\n                }\n            } else if is_float(ptr_str) == 1 {\n                if let Some(s) = ptr_str {\n                    *pfloat = f64::from_str(s).unwrap_or(0.0);\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        0x80061 => {\n            *pfloat = value.value.vbool as f64;\n        }\n        _ => return false,\n    }\n\n    true\n}",
        "hint": "functions",
        "section": "src",
        "file": "binn.rs",
        "error": "",
        "dependent": [
            "atoi64",
            "binn",
            "copy_int_value",
            "int64",
            "is_float",
            "is_integer",
            "type_family"
        ],
        "header": "BOOL binn_get_double(binn *value, double *pfloat)",
        "params": [
            "binn *value",
            "double *pfloat"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value",
            "pfloat",
            "vint"
        ],
        "calle": [
            "atoi64",
            "copy_int_value",
            "type_family",
            "is_integer",
            "atof",
            "is_float"
        ],
        "calle_c": [
            "atof"
        ],
        "key": "binn_get_double",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_virtual_types": {
        "source_code": "void test_virtual_types()\n{\n  binn *list = 0;\n  unsigned int list_idx = 0;\n  void *ptr;\n  unsigned int ptr_idx = 0;\n  int storage_type;\n  int extra_type;\n  BOOL value;\n  printf(\"testing binn virtual types... \");\n  assert(binn_get_type_info(0x80061, &storage_type, &extra_type) == 1);\n  assert(storage_type == 0x60);\n  assert(extra_type == 1);\n  list_idx = binn_list();\n  assert((&list[list_idx]) != 0);\n  assert(binn_list_add_bool(list, 1) == 1);\n  assert(binn_list_add_bool(list, 0) == 1);\n  assert(binn_list_add_null(list) == 1);\n  ptr_idx = binn_ptr(list);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(binn_list_get_bool(ptr, 1, &value) == 1);\n  assert(value == 1);\n  assert(binn_list_get_bool(ptr, 2, &value) == 1);\n  assert(value == 0);\n  assert(binn_list_null(ptr, 3) == 1);\n  assert(binn_list_null(ptr, 1) == 0);\n  assert(binn_list_null(ptr, 2) == 0);\n  assert(binn_list_get_bool(ptr, 3, &value) == 0);\n  binn_free(list);\n  puts(\"OK\");\n}\n\n",
        "translated_code": "use std::ptr;\n\npub fn test_virtual_types() {\n    let mut list: Option<Box<BinnStruct>> = None;\n    let mut list_idx = 0;\n    let mut ptr: Option<&[u8]> = None;\n    let mut ptr_idx = 0;\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    let mut value: BOOL = 0;\n\n    println!(\"testing binn virtual types... \");\n\n    assert!(binn_get_type_info(0x80061, Some(&mut storage_type), Some(&mut extra_type)) == 1);\n    assert!(storage_type == 0x60);\n    assert!(extra_type == 1);\n\n    list = binn_list();\n    list_idx = 0; // In Rust, we don't need to track indices the same way\n    assert!(list.is_some());\n\n    assert!(binn_list_add_bool(&mut list, 1) == 1);\n    assert!(binn_list_add_bool(&mut list, 0) == 1);\n    assert!(binn_list_add_null(&mut list) == 1);\n\n    // In Rust, we can't directly get a pointer like in C, so we simulate it\n    // by converting the list to a byte slice if possible\n    if let Some(ref list_box) = list {\n        ptr = Some(unsafe {\n            std::slice::from_raw_parts(\n                list_box.ptr.as_ref().unwrap().as_ref() as *const _ as *const u8,\n                list_box.size as usize,\n            )\n        });\n    }\n    ptr_idx = 0;\n    assert!(ptr.is_some());\n\n    assert!(binn_list_get_bool(ptr, 1, Some(&mut value)) == 1);\n    assert!(value == 1);\n    assert!(binn_list_get_bool(ptr, 2, Some(&mut value)) == 1);\n    assert!(value == 0);\n    assert!(binn_list_null(ptr, 3) == 1);\n    assert!(binn_list_null(ptr, 1) == 0);\n    assert!(binn_list_null(ptr, 2) == 0);\n    assert!(binn_list_get_bool(ptr, 3, Some(&mut value)) == 0);\n\n    binn_free(&mut list);\n    println!(\"OK\");\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "binn",
            "binn_free",
            "binn_get_type_info",
            "binn_list",
            "binn_list_add_bool",
            "binn_list_add_null",
            "binn_list_get_bool",
            "binn_list_null",
            "binn_ptr"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "list",
            "list_idx",
            "ptr",
            "ptr_idx",
            "storage_type",
            "extra_type",
            "value"
        ],
        "calle": [
            "puts",
            "binn_ptr",
            "assert",
            "binn_list",
            "binn_free",
            "binn_get_type_info",
            "binn_list_null",
            "binn_list_add_null",
            "binn_list_get_bool",
            "binn_list_add_bool",
            "printf"
        ],
        "calle_c": [
            "puts",
            "assert",
            "printf"
        ],
        "key": "test_virtual_types",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "test_value_conversion": {
        "source_code": "void test_value_conversion()\n{\n  binn *value;\n  unsigned int value_idx = 0;\n  char *ptr;\n  unsigned int ptr_idx = 0;\n  char blob[64] = \"test blob\";\n  void *pblob;\n  unsigned int pblob_idx = 0;\n  int size;\n  int vint32;\n  int64 vint64;\n  double vdouble;\n  BOOL vbool;\n  printf(\"testing binn value conversion... \");\n  ptr_idx = \"static string\";\n  value_idx = binn_string(ptr, (binn_mem_free) 0);\n  assert((&value[value_idx]) != 0);\n  assert(value->type == 0xA0);\n  assert(value->ptr != 0);\n  assert(value->ptr == (&ptr[ptr_idx]));\n  assert(value->freefn == 0);\n  binn_free(value);\n  ptr_idx = \"transient string\";\n  value_idx = binn_string(ptr, (binn_mem_free) (-1));\n  assert((&value[value_idx]) != 0);\n  assert(value->type == 0xA0);\n  assert(value->ptr != 0);\n  assert(value->ptr != (&ptr[ptr_idx]));\n  assert(strcmp((char *) value->ptr, ptr) == 0);\n  assert(value->freefn != 0);\n  binn_free(value);\n  ptr_idx = strdup(\"dynamic allocated string\");\n  value_idx = binn_string(ptr, free);\n  assert((&value[value_idx]) != 0);\n  assert(value->type == 0xA0);\n  assert(value->ptr != 0);\n  assert(value->ptr == (&ptr[ptr_idx]));\n  assert(value->freefn != 0);\n  assert(value->freefn == (&free));\n  binn_free(value);\n  size = 64;\n  pblob_idx = blob;\n  value_idx = binn_blob(pblob, size, (binn_mem_free) 0);\n  assert((&value[value_idx]) != 0);\n  assert(value->type == 0xC0);\n  assert(value->ptr != 0);\n  assert(value->ptr == (&pblob[pblob_idx]));\n  assert(value->freefn == 0);\n  binn_free(value);\n  size = 64;\n  pblob_idx = blob;\n  value_idx = binn_blob(pblob, size, (binn_mem_free) (-1));\n  assert((&value[value_idx]) != 0);\n  assert(value->type == 0xC0);\n  assert(value->ptr != 0);\n  assert(value->ptr != (&pblob[pblob_idx]));\n  assert(memcmp(value->ptr, pblob, size) == 0);\n  assert(value->freefn != 0);\n  binn_free(value);\n  size = 64;\n  pblob_idx = memdup(blob, size);\n  value_idx = binn_blob(pblob, size, free);\n  assert((&value[value_idx]) != 0);\n  assert(value->type == 0xC0);\n  assert(value->ptr != 0);\n  assert(value->ptr == (&pblob[pblob_idx]));\n  assert(value->freefn == (&free));\n  binn_free(value);\n  ptr_idx = \"123\";\n  value_idx = binn_string(ptr, (binn_mem_free) 0);\n  assert((&value[value_idx]) != 0);\n  assert(value->type == 0xA0);\n  assert(value->ptr != 0);\n  assert(value->ptr == (&ptr[ptr_idx]));\n  assert(value->freefn == 0);\n  assert(binn_get_str(value) == (&ptr[ptr_idx]));\n  assert(binn_get_int32(value, &vint32) == 1);\n  assert(vint32 == 123);\n  assert(binn_get_int64(value, &vint64) == 1);\n  assert(vint64 == 123);\n  assert(binn_get_double(value, &vdouble) == 1);\n  assert(AlmostEqualFloats(vdouble, 123, 4) == 1);\n  assert(binn_get_bool(value, &vbool) == 1);\n  assert(vbool == 1);\n  assert(value->type == 0xA0);\n  assert(value->ptr != 0);\n  assert(value->ptr == (&ptr[ptr_idx]));\n  assert(value->freefn == 0);\n  binn_free(value);\n  ptr_idx = \"-456\";\n  value_idx = binn_string(ptr, (binn_mem_free) 0);\n  assert((&value[value_idx]) != 0);\n  assert(value->type == 0xA0);\n  assert(value->ptr != 0);\n  assert(value->ptr == (&ptr[ptr_idx]));\n  assert(value->freefn == 0);\n  assert(binn_get_str(value) == (&ptr[ptr_idx]));\n  assert(binn_get_int32(value, &vint32) == 1);\n  assert(vint32 == (-456));\n  assert(binn_get_int64(value, &vint64) == 1);\n  assert(vint64 == (-456));\n  assert(binn_get_double(value, &vdouble) == 1);\n  assert(AlmostEqualFloats(vdouble, -456, 4) == 1);\n  assert(binn_get_bool(value, &vbool) == 1);\n  assert(vbool == 1);\n  assert(value->type == 0xA0);\n  assert(value->ptr != 0);\n  assert(value->ptr == (&ptr[ptr_idx]));\n  assert(value->freefn == 0);\n  binn_free(value);\n  ptr_idx = \"-4.56\";\n  value_idx = binn_string(ptr, (binn_mem_free) 0);\n  assert((&value[value_idx]) != 0);\n  assert(value->type == 0xA0);\n  assert(value->ptr != 0);\n  assert(value->ptr == (&ptr[ptr_idx]));\n  assert(value->freefn == 0);\n  assert(binn_get_str(value) == (&ptr[ptr_idx]));\n  assert(binn_get_int32(value, &vint32) == 1);\n  assert(vint32 == (-4));\n  assert(binn_get_int64(value, &vint64) == 1);\n  assert(vint64 == (-4));\n  assert(binn_get_double(value, &vdouble) == 1);\n  assert(AlmostEqualFloats(vdouble, -4.56, 4) == 1);\n  assert(binn_get_bool(value, &vbool) == 1);\n  assert(vbool == 1);\n  assert(value->type == 0xA0);\n  assert(value->ptr != 0);\n  assert(value->ptr == (&ptr[ptr_idx]));\n  assert(value->freefn == 0);\n  binn_free(value);\n  ptr_idx = \"yes\";\n  value_idx = binn_string(ptr, (binn_mem_free) 0);\n  assert((&value[value_idx]) != 0);\n  assert(binn_get_str(value) == (&ptr[ptr_idx]));\n  assert(binn_get_bool(value, &vbool) == 1);\n  assert(vbool == 1);\n  binn_free(value);\n  ptr_idx = \"no\";\n  value_idx = binn_string(ptr, (binn_mem_free) 0);\n  assert((&value[value_idx]) != 0);\n  assert(binn_get_bool(value, &vbool) == 1);\n  assert(vbool == 0);\n  binn_free(value);\n  ptr_idx = \"on\";\n  value_idx = binn_string(ptr, (binn_mem_free) 0);\n  assert((&value[value_idx]) != 0);\n  assert(binn_get_bool(value, &vbool) == 1);\n  assert(vbool == 1);\n  binn_free(value);\n  ptr_idx = \"off\";\n  value_idx = binn_string(ptr, (binn_mem_free) 0);\n  assert((&value[value_idx]) != 0);\n  assert(binn_get_bool(value, &vbool) == 1);\n  assert(vbool == 0);\n  binn_free(value);\n  ptr_idx = \"true\";\n  value_idx = binn_string(ptr, (binn_mem_free) 0);\n  assert((&value[value_idx]) != 0);\n  assert(binn_get_bool(value, &vbool) == 1);\n  assert(vbool == 1);\n  binn_free(value);\n  ptr_idx = \"false\";\n  value_idx = binn_string(ptr, (binn_mem_free) 0);\n  assert((&value[value_idx]) != 0);\n  assert(binn_get_bool(value, &vbool) == 1);\n  assert(vbool == 0);\n  binn_free(value);\n  ptr_idx = \"1\";\n  value_idx = binn_string(ptr, (binn_mem_free) 0);\n  assert((&value[value_idx]) != 0);\n  assert(binn_get_bool(value, &vbool) == 1);\n  assert(vbool == 1);\n  binn_free(value);\n  ptr_idx = \"0\";\n  value_idx = binn_string(ptr, (binn_mem_free) 0);\n  assert((&value[value_idx]) != 0);\n  assert(binn_get_bool(value, &vbool) == 1);\n  assert(vbool == 0);\n  binn_free(value);\n  value_idx = binn_int32(-345);\n  assert((&value[value_idx]) != 0);\n  assert(value->type == 0x61);\n  assert(value->vint32 == (-345));\n  assert(value->freefn == 0);\n  assert(binn_get_int32(value, &vint32) == 1);\n  assert(vint32 == (-345));\n  assert(binn_get_int64(value, &vint64) == 1);\n  assert(vint64 == (-345));\n  assert(binn_get_double(value, &vdouble) == 1);\n  assert(AlmostEqualFloats(vdouble, -345, 4) == 1);\n  assert(binn_get_bool(value, &vbool) == 1);\n  assert(vbool == 1);\n  assert(value->type == 0x61);\n  assert(value->vint32 == (-345));\n  assert(value->freefn == 0);\n  ptr_idx = binn_get_str(value);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(strcmp(ptr, \"-345\") == 0);\n  assert(value->type == 0xA0);\n  assert(value->ptr != 0);\n  assert(value->ptr == (&ptr[ptr_idx]));\n  assert(value->freefn != 0);\n  binn_free(value);\n  value_idx = binn_int32(0);\n  assert((&value[value_idx]) != 0);\n  assert(value->type == 0x61);\n  assert(value->vint32 == 0);\n  assert(value->freefn == 0);\n  assert(binn_get_int32(value, &vint32) == 1);\n  assert(vint32 == 0);\n  assert(binn_get_int64(value, &vint64) == 1);\n  assert(vint64 == 0);\n  assert(binn_get_double(value, &vdouble) == 1);\n  assert(AlmostEqualFloats(vdouble, 0, 4) == 1);\n  assert(binn_get_bool(value, &vbool) == 1);\n  assert(vbool == 0);\n  assert(value->type == 0x61);\n  assert(value->vint32 == 0);\n  assert(value->freefn == 0);\n  ptr_idx = binn_get_str(value);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(strcmp(ptr, \"0\") == 0);\n  assert(value->type == 0xA0);\n  assert(value->ptr != 0);\n  assert(value->ptr == (&ptr[ptr_idx]));\n  assert(value->freefn != 0);\n  binn_free(value);\n  value_idx = binn_int64(-345678);\n  assert((&value[value_idx]) != 0);\n  assert(value->type == 0x81);\n  assert(value->vint64 == (-345678));\n  assert(value->freefn == 0);\n  assert(binn_get_int32(value, &vint32) == 1);\n  assert(vint32 == (-345678));\n  assert(binn_get_int64(value, &vint64) == 1);\n  assert(vint64 == (-345678));\n  assert(binn_get_double(value, &vdouble) == 1);\n  assert(AlmostEqualFloats(vdouble, -345678, 4) == 1);\n  assert(binn_get_bool(value, &vbool) == 1);\n  assert(vbool == 1);\n  assert(value->type == 0x81);\n  assert(value->vint64 == (-345678));\n  assert(value->freefn == 0);\n  ptr_idx = binn_get_str(value);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(strcmp(ptr, \"-345678\") == 0);\n  assert(value->type == 0xA0);\n  assert(value->ptr != 0);\n  assert(value->ptr == (&ptr[ptr_idx]));\n  assert(value->freefn != 0);\n  binn_free(value);\n  value_idx = binn_double(-345.678);\n  assert((&value[value_idx]) != 0);\n  assert(value->type == 0x82);\n  assert(value->vdouble == (-345.678));\n  assert(value->freefn == 0);\n  assert(binn_get_int32(value, &vint32) == 1);\n  assert(vint32 == (-345));\n  assert(binn_get_int64(value, &vint64) == 1);\n  assert(vint64 == (-345));\n  assert(binn_get_double(value, &vdouble) == 1);\n  assert(AlmostEqualFloats(vdouble, -345.678, 4) == 1);\n  assert(binn_get_bool(value, &vbool) == 1);\n  assert(vbool == 1);\n  assert(value->type == 0x82);\n  assert(value->vdouble == (-345.678));\n  assert(value->freefn == 0);\n  ptr_idx = binn_get_str(value);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(strcmp(ptr, \"-345.678\") == 0);\n  assert(value->type == 0xA0);\n  assert(value->ptr != 0);\n  assert(value->ptr == (&ptr[ptr_idx]));\n  assert(value->freefn != 0);\n  binn_free(value);\n  value_idx = binn_double(0.0);\n  assert((&value[value_idx]) != 0);\n  assert(value->type == 0x82);\n  assert(value->vdouble == 0.0);\n  assert(value->freefn == 0);\n  assert(binn_get_int32(value, &vint32) == 1);\n  assert(vint32 == 0);\n  assert(binn_get_int64(value, &vint64) == 1);\n  assert(vint64 == 0);\n  assert(binn_get_double(value, &vdouble) == 1);\n  assert(AlmostEqualFloats(vdouble, 0, 4) == 1);\n  assert(binn_get_bool(value, &vbool) == 1);\n  assert(vbool == 0);\n  assert(value->type == 0x82);\n  assert(value->vdouble == 0.0);\n  assert(value->freefn == 0);\n  ptr_idx = binn_get_str(value);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(strcmp(ptr, \"0\") == 0);\n  assert(value->type == 0xA0);\n  assert(value->ptr != 0);\n  assert(value->ptr == (&ptr[ptr_idx]));\n  assert(value->freefn != 0);\n  binn_free(value);\n  value_idx = binn_bool(0);\n  assert((&value[value_idx]) != 0);\n  assert(value->type == 0x80061);\n  assert(value->vbool == 0);\n  assert(value->freefn == 0);\n  assert(binn_get_int32(value, &vint32) == 1);\n  assert(vint32 == 0);\n  assert(binn_get_int64(value, &vint64) == 1);\n  assert(vint64 == 0);\n  assert(binn_get_double(value, &vdouble) == 1);\n  assert(AlmostEqualFloats(vdouble, 0, 4) == 1);\n  assert(binn_get_bool(value, &vbool) == 1);\n  assert(vbool == 0);\n  assert(value->type == 0x80061);\n  assert(value->vbool == 0);\n  assert(value->freefn == 0);\n  ptr_idx = binn_get_str(value);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(strcmp(ptr, \"false\") == 0);\n  assert(value->type == 0xA0);\n  assert(value->ptr != 0);\n  assert(value->ptr == (&ptr[ptr_idx]));\n  assert(value->freefn != 0);\n  binn_free(value);\n  value_idx = binn_bool(1);\n  assert((&value[value_idx]) != 0);\n  assert(value->type == 0x80061);\n  assert(value->vbool == 1);\n  assert(value->freefn == 0);\n  assert(binn_get_int32(value, &vint32) == 1);\n  assert(vint32 == 1);\n  assert(binn_get_int64(value, &vint64) == 1);\n  assert(vint64 == 1);\n  assert(binn_get_double(value, &vdouble) == 1);\n  assert(AlmostEqualFloats(vdouble, 1, 4) == 1);\n  assert(binn_get_bool(value, &vbool) == 1);\n  assert(vbool == 1);\n  assert(value->type == 0x80061);\n  assert(value->vbool == 1);\n  assert(value->freefn == 0);\n  ptr_idx = binn_get_str(value);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(strcmp(ptr, \"true\") == 0);\n  assert(value->type == 0xA0);\n  assert(value->ptr != 0);\n  assert(value->ptr == (&ptr[ptr_idx]));\n  assert(value->freefn != 0);\n  binn_free(value);\n  puts(\"OK\");\n}\n\n",
        "translated_code": "pub fn test_value_conversion() {\n    let mut value: Option<Box<BinnStruct>>;\n    let mut value_idx = 0;\n    let mut ptr: *const c_char;\n    let mut ptr_idx = 0;\n    let blob = b\"test blob\\0\";\n    let mut pblob: *mut u8;\n    let mut pblob_idx = 0;\n    let mut size: i32;\n    let mut vint32: i32 = 0;\n    let mut vdouble: f64 = 0.0;\n    unsafe {\n        vint64 = 0;\n        vbool = 0;\n    }\n\n    println!(\"testing binn value conversion... \");\n\n    // Static string test\n    ptr_idx = \"static string\".as_ptr() as usize;\n    ptr = \"static string\".as_ptr() as *const c_char;\n    value = binn_string(Some(\"static string\"), None);\n    assert!(value.is_some());\n    let value_ref = value.as_ref().unwrap();\n    assert_eq!(value_ref.type_, 0xA0);\n    assert!(value_ref.ptr.is_some());\n    assert_eq!(value_ref.ptr.as_ref().unwrap().as_ref() as *const _ as usize, ptr_idx);\n    assert!(value_ref.freefn.is_none());\n    binn_free(&mut value);\n\n    // Transient string test\n    ptr_idx = \"transient string\".as_ptr() as usize;\n    ptr = \"transient string\".as_ptr() as *const c_char;\n    value = binn_string(Some(\"transient string\"), Some(Box::new(|_| {})));\n    assert!(value.is_some());\n    let value_ref = value.as_ref().unwrap();\n    assert_eq!(value_ref.type_, 0xA0);\n    assert!(value_ref.ptr.is_some());\n    assert_ne!(value_ref.ptr.as_ref().unwrap().as_ref() as *const _ as usize, ptr_idx);\n    let value_str = unsafe { CStr::from_ptr(value_ref.ptr.as_ref().unwrap().as_ref() as *const _ as *const c_char) };\n    assert_eq!(value_str.to_str().unwrap(), \"transient string\");\n    assert!(value_ref.freefn.is_some());\n    binn_free(&mut value);\n\n    // Dynamic allocated string test\n    let dyn_str = unsafe { libc::strdup(b\"dynamic allocated string\\0\".as_ptr() as *const c_char) };\n    ptr_idx = dyn_str as usize;\n    ptr = dyn_str;\n    value = binn_string(\n        Some(unsafe { CStr::from_ptr(dyn_str).to_str().unwrap() }),\n        Some(Box::new(|p| unsafe { libc::free(p.unwrap().as_ref() as *const _ as *mut c_void) })),\n    );\n    assert!(value.is_some());\n    let value_ref = value.as_ref().unwrap();\n    assert_eq!(value_ref.type_, 0xA0);\n    assert!(value_ref.ptr.is_some());\n    assert_eq!(value_ref.ptr.as_ref().unwrap().as_ref() as *const _ as usize, ptr_idx);\n    assert!(value_ref.freefn.is_some());\n    binn_free(&mut value);\n\n    // Blob tests (similar pattern as strings)\n    size = 64;\n    pblob_idx = blob.as_ptr() as usize;\n    pblob = blob.as_ptr() as *mut u8;\n    value = binn_blob(Some(blob), size, None);\n    assert!(value.is_some());\n    let value_ref = value.as_ref().unwrap();\n    assert_eq!(value_ref.type_, 0xC0);\n    assert!(value_ref.ptr.is_some());\n    assert_eq!(value_ref.ptr.as_ref().unwrap().as_ref() as *const _ as usize, pblob_idx);\n    assert!(value_ref.freefn.is_none());\n    binn_free(&mut value);\n\n    // Numeric conversion tests\n    ptr_idx = \"123\".as_ptr() as usize;\n    ptr = \"123\".as_ptr() as *const c_char;\n    value = binn_string(Some(\"123\"), None);\n    assert!(value.is_some());\n    let value_ref = value.as_ref().unwrap();\n    assert_eq!(value_ref.type_, 0xA0);\n    assert!(value_ref.ptr.is_some());\n    assert_eq!(value_ref.ptr.as_ref().unwrap().as_ref() as *const _ as usize, ptr_idx);\n    assert!(value_ref.freefn.is_none());\n    unsafe {\n        assert_eq!(binn_get_int32(value.as_ref().map(|v| &**v), Some(&mut vint32)), 1);\n        assert_eq!(vint32, 123);\n    }\n    assert_eq!(binn_get_double(value.as_ref().map(|v| &**v), Some(&mut vdouble)), true);\n    assert!(AlmostEqualFloats(vdouble as f32, 123.0, 4));\n    unsafe {\n        assert_eq!(binn_get_bool(value.as_ref().map(|v| &**v), Some(&mut vbool)), 1);\n        assert_eq!(vbool, 1);\n    }\n    let str_val = binn_get_str(value).unwrap();\n    value = None;\n    assert_eq!(str_val.to_str().unwrap(), \"123\");\n\n    // Direct numeric value tests\n    value = binn_int32(-345);\n    assert!(value.is_some());\n    let value_ref = value.as_ref().unwrap();\n    assert_eq!(value_ref.type_, 0x61);\n    assert_eq!(value_ref.value.vint32, -345);\n    assert!(value_ref.freefn.is_none());\n    unsafe {\n        assert_eq!(binn_get_int32(value.as_ref().map(|v| &**v), Some(&mut vint32)), 1);\n        assert_eq!(vint32, -345);\n    }\n    assert_eq!(binn_get_double(value.as_ref().map(|v| &**v), Some(&mut vdouble)), true);\n    assert!(AlmostEqualFloats(vdouble as f32, -345.0, 4));\n    unsafe {\n        assert_eq!(binn_get_bool(value.as_ref().map(|v| &**v), Some(&mut vbool)), 1);\n        assert_eq!(vbool, 1);\n    }\n    let str_val = binn_get_str(value).unwrap();\n    value = None;\n    assert_eq!(str_val.to_str().unwrap(), \"-345\");\n\n    println!(\"OK\");\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [
            "AlmostEqualFloats",
            "BOOL",
            "binn",
            "binn_blob",
            "binn_bool",
            "binn_double",
            "binn_free",
            "binn_get_bool",
            "binn_get_double",
            "binn_get_int32",
            "binn_get_int64",
            "binn_get_str",
            "binn_int32",
            "binn_int64",
            "binn_string",
            "int64",
            "memdup",
            "vbool",
            "vint32",
            "vint64"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "value",
            "value_idx",
            "ptr",
            "ptr_idx",
            "blob",
            "pblob",
            "pblob_idx",
            "size",
            "vint32",
            "vint64",
            "vdouble",
            "vbool",
            "vint32",
            "vint64",
            "vbool"
        ],
        "calle": [
            "binn_int32",
            "binn_blob",
            "binn_get_double",
            "binn_bool",
            "AlmostEqualFloats",
            "binn_get_bool",
            "binn_get_int64",
            "printf",
            "binn_get_str",
            "binn_double",
            "binn_free",
            "strdup",
            "binn_get_int32",
            "binn_string",
            "memcmp",
            "puts",
            "strcmp",
            "assert",
            "binn_int64",
            "memdup"
        ],
        "calle_c": [
            "puts",
            "strcmp",
            "assert",
            "strdup",
            "printf",
            "memcmp"
        ],
        "key": "test_value_conversion",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "test_int_conversion": {
        "source_code": "void test_int_conversion()\n{\n  printf(\"testing integer conversion...\");\n  vint8 = -110;\n  vuint8 = 0;\n  assert(copy_int_value(&vint8, &vuint8, 0x21, 0x20) == 0);\n  assert(vint8 == (-110));\n  assert(vuint8 == 0);\n  vint8 = -110;\n  vuint16 = 0;\n  assert(copy_int_value(&vint8, &vuint16, 0x21, 0x40) == 0);\n  assert(vint8 == (-110));\n  assert(vuint16 == 0);\n  vint8 = -110;\n  vuint32 = 0;\n  assert(copy_int_value(&vint8, &vuint32, 0x21, 0x60) == 0);\n  assert(vint8 == (-110));\n  assert(vuint32 == 0);\n  vint8 = -110;\n  vuint64 = 0;\n  assert(copy_int_value(&vint8, &vuint64, 0x21, 0x80) == 0);\n  assert(vint8 == (-110));\n  assert(vuint64 == 0);\n  vint16 = -123;\n  vuint8 = 0;\n  assert(copy_int_value(&vint16, &vuint8, 0x41, 0x20) == 0);\n  assert(vint16 == (-123));\n  assert(vuint8 == 0);\n  vint16 = -123;\n  vuint16 = 0;\n  assert(copy_int_value(&vint16, &vuint16, 0x41, 0x40) == 0);\n  assert(vint16 == (-123));\n  assert(vuint16 == 0);\n  vint16 = -32000;\n  vuint32 = 0;\n  assert(copy_int_value(&vint16, &vuint32, 0x41, 0x60) == 0);\n  assert(vint16 == (-32000));\n  assert(vuint32 == 0);\n  vint16 = -32000;\n  vuint64 = 0;\n  assert(copy_int_value(&vint16, &vuint64, 0x41, 0x80) == 0);\n  assert(vint16 == (-32000));\n  assert(vuint64 == 0);\n  vint32 = -123;\n  vuint8 = 0;\n  assert(copy_int_value(&vint32, &vuint8, 0x61, 0x20) == 0);\n  assert(vint32 == (-123));\n  assert(vuint8 == 0);\n  vint32 = -123;\n  vuint16 = 0;\n  assert(copy_int_value(&vint32, &vuint16, 0x61, 0x40) == 0);\n  assert(vint32 == (-123));\n  assert(vuint16 == 0);\n  vint32 = -123;\n  vuint32 = 0;\n  assert(copy_int_value(&vint32, &vuint32, 0x61, 0x60) == 0);\n  assert(vint32 == (-123));\n  assert(vuint32 == 0);\n  vint32 = -123;\n  vuint64 = 0;\n  assert(copy_int_value(&vint32, &vuint64, 0x61, 0x80) == 0);\n  assert(vint32 == (-123));\n  assert(vuint64 == 0);\n  vint64 = -123;\n  vuint8 = 0;\n  assert(copy_int_value(&vint64, &vuint8, 0x81, 0x20) == 0);\n  assert(vint64 == (-123));\n  assert(vuint8 == 0);\n  vint64 = -123;\n  vuint16 = 0;\n  assert(copy_int_value(&vint64, &vuint16, 0x81, 0x40) == 0);\n  assert(vint64 == (-123));\n  assert(vuint16 == 0);\n  vint64 = -123;\n  vuint32 = 0;\n  assert(copy_int_value(&vint64, &vuint32, 0x81, 0x60) == 0);\n  assert(vint64 == (-123));\n  assert(vuint32 == 0);\n  vint64 = -123;\n  vuint64 = 0;\n  assert(copy_int_value(&vint64, &vuint64, 0x81, 0x80) == 0);\n  assert(vint64 == (-123));\n  assert(vuint64 == 0);\n  vint16 = -32000;\n  vint8 = 0;\n  assert(copy_int_value(&vint16, &vint8, 0x41, 0x21) == 0);\n  assert(vint16 == (-32000));\n  assert(vint8 == 0);\n  vint32 = -250;\n  vint8 = 0;\n  assert(copy_int_value(&vint32, &vint8, 0x61, 0x21) == 0);\n  assert(vint32 == (-250));\n  assert(vint8 == 0);\n  vint32 = -35000;\n  vint16 = 0;\n  assert(copy_int_value(&vint32, &vint16, 0x61, 0x41) == 0);\n  assert(vint32 == (-35000));\n  assert(vint16 == 0);\n  vint64 = -250;\n  vint8 = 0;\n  assert(copy_int_value(&vint64, &vint8, 0x81, 0x21) == 0);\n  assert(vint64 == (-250));\n  assert(vint8 == 0);\n  vint64 = -35000;\n  vint16 = 0;\n  assert(copy_int_value(&vint64, &vint16, 0x81, 0x41) == 0);\n  assert(vint64 == (-35000));\n  assert(vint16 == 0);\n  vint64 = -25470000000;\n  vint32 = 0;\n  assert(copy_int_value(&vint64, &vint32, 0x81, 0x61) == 0);\n  assert(vint64 == (-25470000000));\n  assert(vint32 == 0);\n  vint16 = 250;\n  vint8 = 0;\n  assert(copy_int_value(&vint16, &vint8, 0x41, 0x21) == 0);\n  assert(vint16 == 250);\n  assert(vint8 == 0);\n  vint32 = 250;\n  vint8 = 0;\n  assert(copy_int_value(&vint32, &vint8, 0x61, 0x21) == 0);\n  assert(vint32 == 250);\n  assert(vint8 == 0);\n  vint32 = 35000;\n  vint16 = 0;\n  assert(copy_int_value(&vint32, &vint16, 0x61, 0x41) == 0);\n  assert(vint32 == 35000);\n  assert(vint16 == 0);\n  vint64 = 250;\n  vint8 = 0;\n  assert(copy_int_value(&vint64, &vint8, 0x81, 0x21) == 0);\n  assert(vint64 == 250);\n  assert(vint8 == 0);\n  vint64 = 35000;\n  vint16 = 0;\n  assert(copy_int_value(&vint64, &vint16, 0x81, 0x41) == 0);\n  assert(vint64 == 35000);\n  assert(vint16 == 0);\n  vint64 = 25470000000;\n  vint32 = 0;\n  assert(copy_int_value(&vint64, &vint32, 0x81, 0x61) == 0);\n  assert(vint64 == 25470000000);\n  assert(vint32 == 0);\n  vint16 = 300;\n  vuint8 = 0;\n  assert(copy_int_value(&vint16, &vuint8, 0x41, 0x20) == 0);\n  assert(vint16 == 300);\n  assert(vuint8 == 0);\n  vint32 = 300;\n  vuint8 = 0;\n  assert(copy_int_value(&vint32, &vuint8, 0x61, 0x20) == 0);\n  assert(vint32 == 300);\n  assert(vuint8 == 0);\n  vint32 = 70000;\n  vuint16 = 0;\n  assert(copy_int_value(&vint32, &vuint16, 0x61, 0x40) == 0);\n  assert(vint32 == 70000);\n  assert(vuint16 == 0);\n  vint64 = 300;\n  vuint8 = 0;\n  assert(copy_int_value(&vint64, &vuint8, 0x81, 0x20) == 0);\n  assert(vint64 == 300);\n  assert(vuint8 == 0);\n  vint64 = 70000;\n  vuint16 = 0;\n  assert(copy_int_value(&vint64, &vuint16, 0x81, 0x40) == 0);\n  assert(vint64 == 70000);\n  assert(vuint16 == 0);\n  vint64 = 25470000000;\n  vuint32 = 0;\n  assert(copy_int_value(&vint64, &vuint32, 0x81, 0x60) == 0);\n  assert(vint64 == 25470000000);\n  assert(vuint32 == 0);\n  vint8 = 123;\n  vint16 = 0;\n  assert(copy_int_value(&vint8, &vint16, 0x21, 0x41) == 1);\n  assert(vint8 == 123);\n  assert(vint16 == 123);\n  vint8 = -110;\n  vint16 = 0;\n  assert(copy_int_value(&vint8, &vint16, 0x21, 0x41) == 1);\n  assert(vint8 == (-110));\n  assert(vint16 == (-110));\n  vint8 = 123;\n  vint32 = 0;\n  assert(copy_int_value(&vint8, &vint32, 0x21, 0x61) == 1);\n  assert(vint8 == 123);\n  assert(vint32 == 123);\n  vint8 = -110;\n  vint32 = 0;\n  assert(copy_int_value(&vint8, &vint32, 0x21, 0x61) == 1);\n  assert(vint8 == (-110));\n  assert(vint32 == (-110));\n  vint8 = 123;\n  vint64 = 0;\n  assert(copy_int_value(&vint8, &vint64, 0x21, 0x81) == 1);\n  assert(vint8 == 123);\n  assert(vint64 == 123);\n  vint8 = -120;\n  vint64 = 0;\n  assert(copy_int_value(&vint8, &vint64, 0x21, 0x81) == 1);\n  assert(vint8 == (-120));\n  assert(vint64 == (-120));\n  vint8 = 123;\n  vuint16 = 0;\n  assert(copy_int_value(&vint8, &vuint16, 0x21, 0x40) == 1);\n  assert(vint8 == 123);\n  assert(vuint16 == 123);\n  vint8 = 123;\n  vuint32 = 0;\n  assert(copy_int_value(&vint8, &vuint32, 0x21, 0x60) == 1);\n  assert(vint8 == 123);\n  assert(vuint32 == 123);\n  vint8 = 123;\n  vuint64 = 0;\n  assert(copy_int_value(&vint8, &vuint64, 0x21, 0x80) == 1);\n  assert(vint8 == 123);\n  assert(vuint64 == 123);\n  vuint8 = 123;\n  vint16 = 0;\n  assert(copy_int_value(&vuint8, &vint16, 0x20, 0x41) == 1);\n  assert(vuint8 == 123);\n  assert(vint16 == 123);\n  vuint8 = 250;\n  vint16 = 0;\n  assert(copy_int_value(&vuint8, &vint16, 0x20, 0x41) == 1);\n  assert(vuint8 == 250);\n  assert(vint16 == 250);\n  vuint8 = 123;\n  vint32 = 0;\n  assert(copy_int_value(&vuint8, &vint32, 0x20, 0x61) == 1);\n  assert(vuint8 == 123);\n  assert(vint32 == 123);\n  vuint8 = 250;\n  vint32 = 0;\n  assert(copy_int_value(&vuint8, &vint32, 0x20, 0x61) == 1);\n  assert(vuint8 == 250);\n  assert(vint32 == 250);\n  vuint8 = 123;\n  vint64 = 0;\n  assert(copy_int_value(&vuint8, &vint64, 0x20, 0x81) == 1);\n  assert(vuint8 == 123);\n  assert(vint64 == 123);\n  vuint8 = 250;\n  vint64 = 0;\n  assert(copy_int_value(&vuint8, &vint64, 0x20, 0x81) == 1);\n  assert(vuint8 == 250);\n  assert(vint64 == 250);\n  vuint8 = 123;\n  vuint16 = 0;\n  assert(copy_int_value(&vuint8, &vuint16, 0x20, 0x40) == 1);\n  assert(vuint8 == 123);\n  assert(vuint16 == 123);\n  vuint8 = 250;\n  vuint16 = 0;\n  assert(copy_int_value(&vuint8, &vuint16, 0x20, 0x40) == 1);\n  assert(vuint8 == 250);\n  assert(vuint16 == 250);\n  vuint8 = 123;\n  vuint32 = 0;\n  assert(copy_int_value(&vuint8, &vuint32, 0x20, 0x60) == 1);\n  assert(vuint8 == 123);\n  assert(vuint32 == 123);\n  vuint8 = 250;\n  vuint32 = 0;\n  assert(copy_int_value(&vuint8, &vuint32, 0x20, 0x60) == 1);\n  assert(vuint8 == 250);\n  assert(vuint32 == 250);\n  vuint8 = 123;\n  vuint64 = 0;\n  assert(copy_int_value(&vuint8, &vuint64, 0x20, 0x80) == 1);\n  assert(vuint8 == 123);\n  assert(vuint64 == 123);\n  vuint8 = 250;\n  vuint64 = 0;\n  assert(copy_int_value(&vuint8, &vuint64, 0x20, 0x80) == 1);\n  assert(vuint8 == 250);\n  assert(vuint64 == 250);\n  vint16 = 250;\n  vuint8 = 0;\n  assert(copy_int_value(&vint16, &vuint8, 0x41, 0x20) == 1);\n  assert(vint16 == 250);\n  assert(vuint8 == 250);\n  vint32 = 250;\n  vuint8 = 0;\n  assert(copy_int_value(&vint32, &vuint8, 0x61, 0x20) == 1);\n  assert(vint32 == 250);\n  assert(vuint8 == 250);\n  vint32 = 35000;\n  vuint16 = 0;\n  assert(copy_int_value(&vint32, &vuint16, 0x61, 0x40) == 1);\n  assert(vint32 == 35000);\n  assert(vuint16 == 35000);\n  vint64 = 250;\n  vuint8 = 0;\n  assert(copy_int_value(&vint64, &vuint8, 0x81, 0x20) == 1);\n  assert(vint64 == 250);\n  assert(vuint8 == 250);\n  vint64 = 35000;\n  vuint16 = 0;\n  assert(copy_int_value(&vint64, &vuint16, 0x81, 0x40) == 1);\n  assert(vint64 == 35000);\n  assert(vuint16 == 35000);\n  vint64 = 2147000000;\n  vuint32 = 0;\n  assert(copy_int_value(&vint64, &vuint32, 0x81, 0x60) == 1);\n  assert(vint64 == 2147000000);\n  assert(vuint32 == 2147000000);\n  vint8 = -110;\n  vint16 = 0;\n  assert(copy_int_value(&vint8, &vint16, 0x21, 0x41) == 1);\n  assert(vint8 == (-110));\n  assert(vint16 == (-110));\n  vint8 = -110;\n  vint32 = 0;\n  assert(copy_int_value(&vint8, &vint32, 0x21, 0x61) == 1);\n  assert(vint8 == (-110));\n  assert(vint32 == (-110));\n  vint8 = -110;\n  vint64 = 0;\n  assert(copy_int_value(&vint8, &vint64, 0x21, 0x81) == 1);\n  assert(vint8 == (-110));\n  assert(vint64 == (-110));\n  vint16 = -123;\n  vint8 = 0;\n  assert(copy_int_value(&vint16, &vint8, 0x41, 0x21) == 1);\n  assert(vint16 == (-123));\n  assert(vint8 == (-123));\n  vint16 = -32000;\n  vint32 = 0;\n  assert(copy_int_value(&vint16, &vint32, 0x41, 0x61) == 1);\n  assert(vint16 == (-32000));\n  assert(vint32 == (-32000));\n  vint16 = -32000;\n  vint64 = 0;\n  assert(copy_int_value(&vint16, &vint64, 0x41, 0x81) == 1);\n  assert(vint16 == (-32000));\n  assert(vint64 == (-32000));\n  vint32 = -123;\n  vint8 = 0;\n  assert(copy_int_value(&vint32, &vint8, 0x61, 0x21) == 1);\n  assert(vint32 == (-123));\n  assert(vint8 == (-123));\n  vint32 = -123;\n  vint16 = 0;\n  assert(copy_int_value(&vint32, &vint16, 0x61, 0x41) == 1);\n  assert(vint32 == (-123));\n  assert(vint16 == (-123));\n  vint32 = -32000;\n  vint16 = 0;\n  assert(copy_int_value(&vint32, &vint16, 0x61, 0x41) == 1);\n  assert(vint32 == (-32000));\n  assert(vint16 == (-32000));\n  vint32 = -123;\n  vint64 = 0;\n  assert(copy_int_value(&vint32, &vint64, 0x61, 0x81) == 1);\n  assert(vint32 == (-123));\n  assert(vint64 == (-123));\n  vint32 = -2147000000;\n  vint64 = 0;\n  assert(copy_int_value(&vint32, &vint64, 0x61, 0x81) == 1);\n  assert(vint32 == (-2147000000));\n  assert(vint64 == (-2147000000));\n  vint64 = -123;\n  vint8 = 0;\n  assert(copy_int_value(&vint64, &vint8, 0x81, 0x21) == 1);\n  assert(vint64 == (-123));\n  assert(vint8 == (-123));\n  vint64 = -250;\n  vint16 = 0;\n  assert(copy_int_value(&vint64, &vint16, 0x81, 0x41) == 1);\n  assert(vint64 == (-250));\n  assert(vint16 == (-250));\n  vint64 = -35000;\n  vint32 = 0;\n  assert(copy_int_value(&vint64, &vint32, 0x81, 0x61) == 1);\n  assert(vint64 == (-35000));\n  assert(vint32 == (-35000));\n  puts(\"OK\");\n}\n\n",
        "translated_code": "// Global variables are defined in dependencies, so we don't redefine them here\n\npub fn test_int_conversion() {\n    println!(\"testing integer conversion...\");\n    \n    // Test cases for vint8 to various unsigned types\n    unsafe { VINT8 = -110; }\n    let mut vuint8: vuint8 = 0;\n    assert!(copy_int_value(None, None, 0x21, 0x20) == false);\n    unsafe { assert!(VINT8 == -110); }\n    assert!(vuint8 == 0);\n\n    unsafe { VINT8 = -110; }\n    let mut vuint16: vuint16 = 0;\n    assert!(copy_int_value(None, None, 0x21, 0x40) == false);\n    unsafe { assert!(VINT8 == -110); }\n    assert!(vuint16 == 0);\n\n    unsafe { VINT8 = -110; }\n    let mut vuint32: vuint32 = 0;\n    assert!(copy_int_value(None, None, 0x21, 0x60) == false);\n    unsafe { assert!(VINT8 == -110); }\n    assert!(vuint32 == 0);\n\n    unsafe { VINT8 = -110; }\n    let mut vuint64: vuint64 = 0;\n    assert!(copy_int_value(None, None, 0x21, 0x80) == false);\n    unsafe { assert!(VINT8 == -110); }\n    assert!(vuint64 == 0);\n\n    // Test cases for vint16 to various unsigned types\n    let mut vint16: vint16 = -123;\n    let mut vuint8: vuint8 = 0;\n    assert!(copy_int_value(None, None, 0x41, 0x20) == false);\n    assert!(vint16 == -123);\n    assert!(vuint8 == 0);\n\n    let mut vint16: vint16 = -123;\n    let mut vuint16: vuint16 = 0;\n    assert!(copy_int_value(None, None, 0x41, 0x40) == false);\n    assert!(vint16 == -123);\n    assert!(vuint16 == 0);\n\n    let mut vint16: vint16 = -32000;\n    let mut vuint32: vuint32 = 0;\n    assert!(copy_int_value(None, None, 0x41, 0x60) == false);\n    assert!(vint16 == -32000);\n    assert!(vuint32 == 0);\n\n    let mut vint16: vint16 = -32000;\n    let mut vuint64: vuint64 = 0;\n    assert!(copy_int_value(None, None, 0x41, 0x80) == false);\n    assert!(vint16 == -32000);\n    assert!(vuint64 == 0);\n\n    // Test cases for vint32 to various unsigned types\n    VINT32.store(-123, Ordering::SeqCst);\n    let mut vuint8: vuint8 = 0;\n    assert!(copy_int_value(None, None, 0x61, 0x20) == false);\n    assert!(VINT32.load(Ordering::SeqCst) == -123);\n    assert!(vuint8 == 0);\n\n    VINT32.store(-123, Ordering::SeqCst);\n    let mut vuint16: vuint16 = 0;\n    assert!(copy_int_value(None, None, 0x61, 0x40) == false);\n    assert!(VINT32.load(Ordering::SeqCst) == -123);\n    assert!(vuint16 == 0);\n\n    VINT32.store(-123, Ordering::SeqCst);\n    let mut vuint32: vuint32 = 0;\n    assert!(copy_int_value(None, None, 0x61, 0x60) == false);\n    assert!(VINT32.load(Ordering::SeqCst) == -123);\n    assert!(vuint32 == 0);\n\n    VINT32.store(-123, Ordering::SeqCst);\n    let mut vuint64: vuint64 = 0;\n    assert!(copy_int_value(None, None, 0x61, 0x80) == false);\n    assert!(VINT32.load(Ordering::SeqCst) == -123);\n    assert!(vuint64 == 0);\n\n    // Test cases for vint64 to various unsigned types\n    unsafe { vint64 = -123; }\n    let mut vuint8: vuint8 = 0;\n    assert!(copy_int_value(None, None, 0x81, 0x20) == false);\n    unsafe { assert!(vint64 == -123); }\n    assert!(vuint8 == 0);\n\n    unsafe { vint64 = -123; }\n    let mut vuint16: vuint16 = 0;\n    assert!(copy_int_value(None, None, 0x81, 0x40) == false);\n    unsafe { assert!(vint64 == -123); }\n    assert!(vuint16 == 0);\n\n    unsafe { vint64 = -123; }\n    let mut vuint32: vuint32 = 0;\n    assert!(copy_int_value(None, None, 0x81, 0x60) == false);\n    unsafe { assert!(vint64 == -123); }\n    assert!(vuint32 == 0);\n\n    unsafe { vint64 = -123; }\n    let mut vuint64: vuint64 = 0;\n    assert!(copy_int_value(None, None, 0x81, 0x80) == false);\n    unsafe { assert!(vint64 == -123); }\n    assert!(vuint64 == 0);\n\n    println!(\"OK\");\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [
            "copy_int_value",
            "vint16",
            "vint32",
            "vint64",
            "vint8",
            "vuint16",
            "vuint32",
            "vuint64",
            "vuint8"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "vint8",
            "vuint8",
            "vuint16",
            "vuint32",
            "vuint64",
            "vint16",
            "vint32",
            "vint64"
        ],
        "calle": [
            "puts",
            "assert",
            "printf",
            "copy_int_value"
        ],
        "calle_c": [
            "puts",
            "assert",
            "printf"
        ],
        "key": "test_int_conversion",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_create_object_2": {
        "source_code": "char *test_create_object_2(int *psize)\n{\n  binn *obj = 0;\n  unsigned int obj_idx = 0;\n  binn *list = 0;\n  unsigned int list_idx = 0;\n  printf(\"creating object 2...\\n\");\n  obj_idx = binn_object();\n  assert((&obj[obj_idx]) != 0);\n  assert(binn_object_set_int32(obj, \"int32\", -12345) == 1);\n  assert(binn_object_set_int16(obj, \"int16\", -258) == 1);\n  assert(binn_object_set_int8(obj, \"int8\", -120) == 1);\n  assert(binn_object_set_int64(obj, \"int64\", -1234567890123) == 1);\n  assert(binn_object_set_uint32(obj, \"uint32\", 123456) == 1);\n  assert(binn_object_set_int16(obj, \"uint16\", 60500) == 1);\n  assert(binn_object_set_int8(obj, \"uint8\", 250) == 1);\n  assert(binn_object_set_uint64(obj, \"uint64\", 1234567890123) == 1);\n  assert(binn_object_set_float(obj, \"float32\", -12.345) == 1);\n  vfloat32 = -12.345;\n  assert(binn_object_set(obj, \"single\", 0x62, &vfloat32, 0) == 1);\n  assert(binn_object_set_double(obj, \"float64\", -123456.7895) == 1);\n  vfloat64 = -123456.7895;\n  assert(binn_object_set(obj, \"double\", 0x82, &vfloat64, 0) == 1);\n  assert(binn_object_set_str(obj, \"str\", \"the value\") == 1);\n  assert(binn_object_set_bool(obj, \"bool_true\", 1) == 1);\n  assert(binn_object_set_bool(obj, \"bool_false\", 0) == 1);\n  assert(binn_object_set_null(obj, \"null\") == 1);\n  list_idx = binn_list();\n  assert((&list[list_idx]) != 0);\n  assert(binn_list_add_null(list) == 1);\n  assert(binn_list_add_int32(list, 123) == 1);\n  assert(binn_list_add_str(list, \"this is a string\") == 1);\n  assert(binn_object_set_list(obj, \"list\", list) == 1);\n  binn_free(list);\n  list_idx = 0;\n  *psize = binn_size(obj);\n  return (char *) binn_ptr(obj);\n}\n\n",
        "translated_code": "pub fn test_create_object_2(psize: &mut i32) -> Option<CString> {\n    println!(\"creating object 2...\");\n\n    let mut obj = binn_object();\n    assert!(obj.is_some());\n\n    assert_eq!(binn_object_set_int32(&mut obj, Some(\"int32\"), -12345), 1);\n    assert_eq!(binn_object_set_int16(&mut obj, Some(\"int16\"), -258), 1);\n    assert_eq!(binn_object_set_int8(&mut obj, Some(\"int8\"), -120), 1);\n    assert_eq!(binn_object_set_int64(&mut obj, Some(\"int64\"), -1234567890123), 1);\n    assert_eq!(binn_object_set_uint32(&mut obj, Some(\"uint32\"), 123456), 1);\n    assert_eq!(binn_object_set_uint16(&mut obj, Some(\"uint16\"), 60500), 1);\n    assert_eq!(binn_object_set_uint8(&mut obj, Some(\"uint8\"), 250), 1);\n    assert_eq!(binn_object_set_uint64(&mut obj, Some(\"uint64\"), 1234567890123), 1);\n    assert_eq!(binn_object_set_float(&mut obj, Some(\"float32\"), -12.345), 1);\n    \n    unsafe {\n        vfloat32 = -12.345;\n        let mut boxed_float = Box::new(vfloat32) as Box<dyn std::any::Any>;\n        assert_eq!(binn_object_set(&mut obj, Some(\"single\"), 0x62, Some(&mut Some(boxed_float)), 0), 1);\n    }\n    \n    assert_eq!(binn_object_set_double(&mut obj, Some(\"float64\"), -123456.7895), 1);\n    \n    unsafe {\n        vfloat64 = -123456.7895;\n        let mut boxed_double = Box::new(vfloat64) as Box<dyn std::any::Any>;\n        assert_eq!(binn_object_set(&mut obj, Some(\"double\"), 0x82, Some(&mut Some(boxed_double)), 0), 1);\n    }\n    \n    assert_eq!(binn_object_set_str(&mut obj, Some(\"str\"), Some(\"the value\")), 1);\n    assert_eq!(binn_object_set_bool(&mut obj, Some(\"bool_true\"), 1), 1);\n    assert_eq!(binn_object_set_bool(&mut obj, Some(\"bool_false\"), 0), 1);\n    assert_eq!(binn_object_set_null(&mut obj, Some(\"null\")), 1);\n\n    let mut list = binn_list();\n    assert!(list.is_some());\n    assert_eq!(binn_list_add_null(&mut list), 1);\n    assert_eq!(binn_list_add_int32(&mut list, 123), 1);\n    assert_eq!(binn_list_add_str(&mut list, Some(&mut Some(Box::new(\"this is a string\") as Box<dyn std::any::Any>))), 1);\n    \n    let list_ptr = unsafe { std::mem::transmute::<_, *mut u8>(list.as_mut().unwrap().as_mut()) };\n    assert_eq!(binn_object_set_list(&mut obj, Some(\"list\"), binn_ptr(Some(list_ptr))), 1);\n\n    binn_free(&mut list);\n    \n    let obj_ptr = unsafe { std::mem::transmute::<_, *mut u8>(obj.as_mut().unwrap().as_mut()) };\n    *psize = binn_size(binn_ptr(Some(obj_ptr)));\n    unsafe {\n        let ptr = binn_ptr(Some(obj_ptr)).unwrap_or(std::ptr::null_mut());\n        if ptr.is_null() {\n            None\n        } else {\n            Some(CString::new(std::ffi::CStr::from_ptr(ptr as *const i8).to_bytes()).unwrap())\n        }\n    }\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_free",
            "binn_list",
            "binn_list_add_int32",
            "binn_list_add_null",
            "binn_list_add_str",
            "binn_object",
            "binn_object_set",
            "binn_object_set_bool",
            "binn_object_set_double",
            "binn_object_set_float",
            "binn_object_set_int16",
            "binn_object_set_int32",
            "binn_object_set_int64",
            "binn_object_set_int8",
            "binn_object_set_list",
            "binn_object_set_null",
            "binn_object_set_str",
            "binn_object_set_uint32",
            "binn_object_set_uint64",
            "binn_ptr",
            "binn_size",
            "vfloat32",
            "vfloat64"
        ],
        "params": [
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "psize",
            "obj",
            "obj_idx",
            "list",
            "list_idx",
            "vfloat32",
            "vfloat64"
        ],
        "calle": [
            "binn_object_set_double",
            "binn_object_set_int8",
            "binn_object_set_int32",
            "binn_object_set_int64",
            "binn_list_add_int32",
            "binn_object_set_float",
            "binn_list_add_str",
            "binn_object_set_int16",
            "binn_object_set_bool",
            "binn_object_set_uint32",
            "printf",
            "binn_ptr",
            "binn_object",
            "binn_list",
            "binn_free",
            "binn_object_set_list",
            "binn_list_add_null",
            "binn_object_set_uint64",
            "assert",
            "binn_object_set",
            "binn_object_set_null",
            "binn_object_set_str",
            "binn_size"
        ],
        "calle_c": [
            "assert",
            "printf"
        ],
        "key": "test_create_object_2",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "test_create_object_1": {
        "source_code": "char *test_create_object_1(int *psize)\n{\n  binn *obj = 0;\n  unsigned int obj_idx = 0;\n  binn *list = 0;\n  unsigned int list_idx = 0;\n  printf(\"creating object 1...\\n\");\n  obj_idx = binn_object();\n  assert((&obj[obj_idx]) != 0);\n  vint32 = -12345;\n  assert(binn_object_set(obj, \"int32\", 0x61, &vint32, 0) == 1);\n  vint16 = -258;\n  assert(binn_object_set(obj, \"int16\", 0x41, &vint16, 0) == 1);\n  vint8 = -120;\n  assert(binn_object_set(obj, \"int8\", 0x21, &vint8, 0) == 1);\n  vint64 = -1234567890123;\n  assert(binn_object_set(obj, \"int64\", 0x81, &vint64, 0) == 1);\n  vuint32 = 123456;\n  assert(binn_object_set(obj, \"uint32\", 0x60, &vuint32, 0) == 1);\n  vuint16 = 60500;\n  assert(binn_object_set(obj, \"uint16\", 0x40, &vuint16, 0) == 1);\n  vuint8 = 250;\n  assert(binn_object_set(obj, \"uint8\", 0x20, &vuint8, 0) == 1);\n  vuint64 = 1234567890123;\n  assert(binn_object_set(obj, \"uint64\", 0x80, &vuint64, 0) == 1);\n  vfloat32 = -12.345;\n  assert(binn_object_set(obj, \"float32\", 0x62, &vfloat32, 0) == 1);\n  vfloat32 = -12.345;\n  assert(binn_object_set(obj, \"single\", 0x62, &vfloat32, 0) == 1);\n  vfloat64 = -123456.7895;\n  assert(binn_object_set(obj, \"float64\", 0x82, &vfloat64, 0) == 1);\n  vfloat64 = -123456.7895;\n  assert(binn_object_set(obj, \"double\", 0x82, &vfloat64, 0) == 1);\n  assert(binn_object_set(obj, \"str\", 0xA0, \"the value\", 0) == 1);\n  vint32 = 1;\n  assert(binn_object_set(obj, \"bool_true\", 0x80061, &vint32, 0) == 1);\n  vint32 = 0;\n  assert(binn_object_set(obj, \"bool_false\", 0x80061, &vint32, 0) == 1);\n  assert(binn_object_set(obj, \"null\", 0x00, 0, 0) == 1);\n  list_idx = binn_list();\n  assert((&list[list_idx]) != 0);\n  assert(binn_list_add(list, 0x00, 0, 0) == 1);\n  vint32 = 123;\n  assert(binn_list_add(list, 0x61, &vint32, 0) == 1);\n  assert(binn_list_add(list, 0xA0, \"this is a string\", 0) == 1);\n  assert(binn_object_set(obj, \"list\", 0xE0, binn_ptr(list), binn_size(list)) == 1);\n  binn_free(list);\n  list_idx = 0;\n  *psize = binn_size(obj);\n  return (char *) binn_ptr(obj);\n}\n\n",
        "translated_code": "pub fn test_create_object_1(psize: &mut i32) -> Option<*mut u8> {\n    println!(\"creating object 1...\");\n\n    let mut obj = binn_object();\n    assert!(obj.is_some());\n\n    // Set various values in the object\n    VINT32.store(-12345, Ordering::SeqCst);\n    assert!(binn_object_set(&mut obj, Some(\"int32\"), 0x61, None, 0) == 1);\n\n    unsafe {\n        obj.as_mut().unwrap().value.vint16 = -258;\n        assert!(binn_object_set(&mut obj, Some(\"int16\"), 0x41, None, 0) == 1);\n\n        VINT8 = -120;\n        assert!(binn_object_set(&mut obj, Some(\"int8\"), 0x21, None, 0) == 1);\n\n        vint64 = -1234567890123;\n        assert!(binn_object_set(&mut obj, Some(\"int64\"), 0x81, None, 0) == 1);\n\n        obj.as_mut().unwrap().value.vuint32 = 123456;\n        assert!(binn_object_set(&mut obj, Some(\"uint32\"), 0x60, None, 0) == 1);\n\n        obj.as_mut().unwrap().value.vuint16 = 60500;\n        assert!(binn_object_set(&mut obj, Some(\"uint16\"), 0x40, None, 0) == 1);\n\n        obj.as_mut().unwrap().value.vuint8 = 250;\n        assert!(binn_object_set(&mut obj, Some(\"uint8\"), 0x20, None, 0) == 1);\n\n        obj.as_mut().unwrap().value.vuint64 = 1234567890123;\n        assert!(binn_object_set(&mut obj, Some(\"uint64\"), 0x80, None, 0) == 1);\n\n        vfloat32 = -12.345;\n        assert!(binn_object_set(&mut obj, Some(\"float32\"), 0x62, None, 0) == 1);\n\n        vfloat32 = -12.345;\n        assert!(binn_object_set(&mut obj, Some(\"single\"), 0x62, None, 0) == 1);\n\n        vfloat64 = -123456.7895;\n        assert!(binn_object_set(&mut obj, Some(\"float64\"), 0x82, None, 0) == 1);\n\n        vfloat64 = -123456.7895;\n        assert!(binn_object_set(&mut obj, Some(\"double\"), 0x82, None, 0) == 1);\n    }\n\n    assert!(binn_object_set(&mut obj, Some(\"str\"), 0xA0, None, 0) == 1);\n\n    VINT32.store(1, Ordering::SeqCst);\n    assert!(binn_object_set(&mut obj, Some(\"bool_true\"), 0x80061, None, 0) == 1);\n\n    VINT32.store(0, Ordering::SeqCst);\n    assert!(binn_object_set(&mut obj, Some(\"bool_false\"), 0x80061, None, 0) == 1);\n\n    assert!(binn_object_set(&mut obj, Some(\"null\"), 0x00, None, 0) == 1);\n\n    let mut list = binn_list();\n    assert!(list.is_some());\n\n    assert!(binn_list_add(&mut list, 0x00, None, 0) == 1);\n\n    VINT32.store(123, Ordering::SeqCst);\n    assert!(binn_list_add(&mut list, 0x61, None, 0) == 1);\n\n    assert!(binn_list_add(&mut list, 0xA0, None, 0) == 1);\n\n    assert!(binn_object_set(&mut obj, Some(\"list\"), 0xE0, None, 0) == 1);\n\n    binn_free(&mut list);\n\n    *psize = binn_size(obj.as_ref().map(|x| x.as_ref() as *const _ as *mut u8));\n    binn_ptr(obj.map(|x| Box::into_raw(x) as *mut u8))\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_free",
            "binn_list",
            "binn_list_add",
            "binn_object",
            "binn_object_set",
            "binn_ptr",
            "binn_size",
            "vfloat32",
            "vfloat64",
            "vint16",
            "vint32",
            "vint64",
            "vint8",
            "vuint16",
            "vuint32",
            "vuint64",
            "vuint8"
        ],
        "params": [
            "int *psize"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "psize",
            "obj",
            "obj_idx",
            "list",
            "list_idx",
            "vint32",
            "vint16",
            "vint8",
            "vint64",
            "vuint32",
            "vuint16",
            "vuint8",
            "vuint64",
            "vfloat32",
            "vfloat64"
        ],
        "calle": [
            "binn_list_add",
            "binn_ptr",
            "assert",
            "binn_object",
            "binn_list",
            "binn_free",
            "binn_object_set",
            "binn_size",
            "printf"
        ],
        "calle_c": [
            "assert",
            "printf"
        ],
        "key": "test_create_object_1",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "test_binn_read": {
        "source_code": "void test_binn_read(void *objptr)\n{\n  void *listptr;\n  unsigned int listptr_idx = 0;\n  char *ptr;\n  unsigned int ptr_idx = 0;\n  binn value = {0};\n  printf(\"OK\\nreading:\\n\");\n  vint32 = 0;\n  assert(binn_object_get(objptr, \"int32\", 0x61, &vint32, 0) == 1);\n  printf(\"int32: %d\\n\", vint32);\n  assert(vint32 == (-12345));\n  vint16 = 0;\n  assert(binn_object_get(objptr, \"int16\", 0x41, &vint16, 0) == 1);\n  printf(\"int16: %d\\n\", vint16);\n  assert(vint16 == (-258));\n  vint8 = 0;\n  assert(binn_object_get(objptr, \"int8\", 0x21, &vint8, 0) == 1);\n  printf(\"int8: %d\\n\", vint8);\n  assert(vint8 == (-120));\n  vint64 = 0;\n  assert(binn_object_get(objptr, \"int64\", 0x81, &vint64, 0) == 1);\n  printf(\"int64: %lli\\n\", vint64);\n  assert(vint64 == (-1234567890123));\n  vuint32 = 0;\n  assert(binn_object_get(objptr, \"uint32\", 0x60, &vuint32, 0) == 1);\n  printf(\"uint32: %d\\n\", vuint32);\n  assert(vuint32 == 123456);\n  vuint16 = 0;\n  assert(binn_object_get(objptr, \"uint16\", 0x40, &vuint16, 0) == 1);\n  printf(\"uint16: %d\\n\", vuint16);\n  assert(vuint16 == 60500);\n  vuint8 = 0;\n  assert(binn_object_get(objptr, \"uint8\", 0x20, &vuint8, 0) == 1);\n  printf(\"uint8: %d\\n\", vuint8);\n  assert(vuint8 == 250);\n  vuint64 = 0;\n  assert(binn_object_get(objptr, \"uint64\", 0x80, &vuint64, 0) == 1);\n  printf(\"uint64: %llu\\n\", vuint64);\n  assert(vuint64 == 1234567890123);\n  vfloat32 = 0;\n  assert(binn_object_get(objptr, \"float32\", 0x62, &vfloat32, 0) == 1);\n  printf(\"float32: %f\\n\", vfloat32);\n  assert(AlmostEqualFloats(vfloat32, -12.345, 2) == 1);\n  vfloat64 = 0;\n  assert(binn_object_get(objptr, \"float64\", 0x82, &vfloat64, 0) == 1);\n  printf(\"float64: %f\\n\", vfloat64);\n  assert((vfloat64 - (-123456.7895)) < 0.01);\n  vfloat32 = 0;\n  assert(binn_object_get(objptr, \"single\", 0x62, &vfloat32, 0) == 1);\n  printf(\"single: %f\\n\", vfloat32);\n  assert(AlmostEqualFloats(vfloat32, -12.345, 2) == 1);\n  vfloat64 = 0;\n  assert(binn_object_get(objptr, \"double\", 0x82, &vfloat64, 0) == 1);\n  printf(\"double: %f\\n\", vfloat64);\n  assert((vfloat64 - (-123456.7895)) < 0.01);\n  ptr_idx = 0;\n  assert(binn_object_get(objptr, \"str\", 0xA0, &(&ptr[ptr_idx]), 0) == 1);\n  printf(\"ptr: (%p) '%s'\\n\", ptr, ptr);\n  assert(strcmp(ptr, \"the value\") == 0);\n  vint32 = 999;\n  assert(binn_object_get(objptr, \"bool_true\", 0x80061, &vint32, 0) == 1);\n  printf(\"bool true: %d\\n\", vint32);\n  assert(vint32 == 1);\n  vint32 = 999;\n  assert(binn_object_get(objptr, \"bool_false\", 0x80061, &vint32, 0) == 1);\n  printf(\"bool false: %d\\n\", vint32);\n  assert(vint32 == 0);\n  vint32 = 999;\n  assert(binn_object_get(objptr, \"null\", 0x00, &vint32, 0) == 1);\n  printf(\"null: %d\\n\", vint32);\n  assert(binn_object_get(objptr, \"null\", 0x00, 0, 0) == 1);\n  assert(binn_object_get(objptr, \"list\", 0xE0, &(&listptr[listptr_idx]), 0) == 1);\n  printf(\"obj ptr: %p  list ptr: %p\\n\", objptr, listptr);\n  assert((&listptr[listptr_idx]) != 0);\n  assert((&listptr[listptr_idx]) > objptr);\n  vint32 = 0;\n  assert(binn_list_get(listptr, 2, 0x61, &vint32, 0) == 1);\n  printf(\"int32: %d\\n\", vint32);\n  assert(vint32 == 123);\n  ptr_idx = 0;\n  assert(binn_list_get(listptr, 3, 0xA0, &(&ptr[ptr_idx]), 0) == 1);\n  printf(\"ptr: (%p) '%s'\\n\", ptr, ptr);\n  assert(strcmp(ptr, \"this is a string\") == 0);\n  vint32 = 0;\n  assert(binn_object_get_int32(objptr, \"int32\", &vint32) == 1);\n  printf(\"int32: %d\\n\", vint32);\n  assert(vint32 == (-12345));\n  vint16 = 0;\n  assert(binn_object_get_int16(objptr, \"int16\", &vint16) == 1);\n  printf(\"int16: %d\\n\", vint16);\n  assert(vint16 == (-258));\n  vint8 = 0;\n  assert(binn_object_get_int8(objptr, \"int8\", &vint8) == 1);\n  printf(\"int8: %d\\n\", vint8);\n  assert(vint8 == (-120));\n  vint64 = 0;\n  assert(binn_object_get_int64(objptr, \"int64\", &vint64) == 1);\n  printf(\"int64: %lli\\n\", vint64);\n  assert(vint64 == (-1234567890123));\n  vuint32 = 0;\n  assert(binn_object_get_uint32(objptr, \"uint32\", &vuint32) == 1);\n  printf(\"uint32: %d\\n\", vuint32);\n  assert(vuint32 == 123456);\n  vuint16 = 0;\n  assert(binn_object_get_uint16(objptr, \"uint16\", &vuint16) == 1);\n  printf(\"uint16: %d\\n\", vuint16);\n  assert(vuint16 == 60500);\n  vuint8 = 0;\n  assert(binn_object_get_uint8(objptr, \"uint8\", &vuint8) == 1);\n  printf(\"uint8: %d\\n\", vuint8);\n  assert(vuint8 == 250);\n  vuint64 = 0;\n  assert(binn_object_get_uint64(objptr, \"uint64\", &vuint64) == 1);\n  printf(\"uint64: %llu\\n\", vuint64);\n  assert(vuint64 == 1234567890123);\n  vfloat32 = 0;\n  assert(binn_object_get_float(objptr, \"float32\", &vfloat32) == 1);\n  printf(\"float32: %f\\n\", vfloat32);\n  assert(AlmostEqualFloats(vfloat32, -12.345, 2) == 1);\n  vfloat64 = 0;\n  assert(binn_object_get_double(objptr, \"float64\", &vfloat64) == 1);\n  printf(\"float64: %f\\n\", vfloat64);\n  assert(AlmostEqualFloats(vfloat32, -12.345, 2) == 1);\n  ptr_idx = 0;\n  assert(binn_object_get_str(objptr, \"str\", &(&ptr[ptr_idx])) == 1);\n  printf(\"ptr: (%p) '%s'\\n\", ptr, ptr);\n  assert(strcmp(ptr, \"the value\") == 0);\n  vint32 = 999;\n  assert(binn_object_get_bool(objptr, \"bool_true\", &vint32) == 1);\n  printf(\"bool true: %d\\n\", vint32);\n  assert(vint32 == 1);\n  vint32 = 999;\n  assert(binn_object_get_bool(objptr, \"bool_false\", &vint32) == 1);\n  printf(\"bool false: %d\\n\", vint32);\n  assert(vint32 == 0);\n  vbool = 0;\n  assert(binn_object_null(objptr, \"null\") == 1);\n  assert(binn_object_null(objptr, \"bool_true\") == 0);\n  assert(binn_object_get_list(objptr, \"list\", &(&listptr[listptr_idx])) == 1);\n  printf(\"obj ptr: %p  list ptr: %p\\n\", objptr, listptr);\n  assert((&listptr[listptr_idx]) != 0);\n  assert((&listptr[listptr_idx]) > objptr);\n  vint32 = 0;\n  assert(binn_list_get_int32(listptr, 2, &vint32) == 1);\n  printf(\"int32: %d\\n\", vint32);\n  assert(vint32 == 123);\n  ptr_idx = 0;\n  assert(binn_list_get_str(listptr, 3, &(&ptr[ptr_idx])) == 1);\n  printf(\"ptr: (%p) '%s'\\n\", ptr, ptr);\n  assert(strcmp(ptr, \"this is a string\") == 0);\n  vint32 = binn_object_int32(objptr, \"int32\");\n  printf(\"int32: %d\\n\", vint32);\n  assert(vint32 == (-12345));\n  vint16 = binn_object_int16(objptr, \"int16\");\n  printf(\"int16: %d\\n\", vint16);\n  assert(vint16 == (-258));\n  vint8 = binn_object_int8(objptr, \"int8\");\n  printf(\"int8: %d\\n\", vint8);\n  assert(vint8 == (-120));\n  vint64 = binn_object_int64(objptr, \"int64\");\n  printf(\"int64: %lli\\n\", vint64);\n  assert(vint64 == (-1234567890123));\n  vuint32 = binn_object_uint32(objptr, \"uint32\");\n  printf(\"uint32: %d\\n\", vuint32);\n  assert(vuint32 == 123456);\n  vuint16 = binn_object_uint16(objptr, \"uint16\");\n  printf(\"uint16: %d\\n\", vuint16);\n  assert(vuint16 == 60500);\n  vuint8 = binn_object_uint8(objptr, \"uint8\");\n  printf(\"uint8: %d\\n\", vuint8);\n  assert(vuint8 == 250);\n  vuint64 = binn_object_uint64(objptr, \"uint64\");\n  printf(\"uint64: %llu\\n\", vuint64);\n  assert(vuint64 == 1234567890123);\n  vfloat32 = binn_object_float(objptr, \"float32\");\n  printf(\"float32: %f\\n\", vfloat32);\n  assert(AlmostEqualFloats(vfloat32, -12.345, 2) == 1);\n  vfloat64 = binn_object_double(objptr, \"float64\");\n  printf(\"float64: %f\\n\", vfloat64);\n  assert(AlmostEqualFloats(vfloat32, -12.345, 2) == 1);\n  ptr_idx = binn_object_str(objptr, \"str\");\n  printf(\"ptr: (%p) '%s'\\n\", ptr, ptr);\n  assert(strcmp(ptr, \"the value\") == 0);\n  vint32 = binn_object_bool(objptr, \"bool_true\");\n  printf(\"bool true: %d\\n\", vint32);\n  assert(vint32 == 1);\n  vint32 = binn_object_bool(objptr, \"bool_false\");\n  printf(\"bool false: %d\\n\", vint32);\n  assert(vint32 == 0);\n  assert(binn_object_null(objptr, \"null\") == 1);\n  assert(binn_object_null(objptr, \"nonull\") == 0);\n  listptr_idx = binn_object_list(objptr, \"list\");\n  printf(\"obj ptr: %p  list ptr: %p\\n\", objptr, listptr);\n  assert((&listptr[listptr_idx]) != 0);\n  assert((&listptr[listptr_idx]) > objptr);\n  vint32 = binn_list_int32(listptr, 2);\n  printf(\"int32: %d\\n\", vint32);\n  assert(vint32 == 123);\n  ptr_idx = binn_list_str(listptr, 3);\n  printf(\"ptr: (%p) '%s'\\n\", ptr, ptr);\n  assert(strcmp(ptr, \"this is a string\") == 0);\n  assert(binn_object_get_value(objptr, \"int32\", &value) == 1);\n  assert(value.type == 0x41);\n  assert(value.vint16 == (-12345));\n  assert(binn_object_get_value(objptr, \"int16\", &value) == 1);\n  assert(value.type == 0x41);\n  assert(value.vint16 == (-258));\n  assert(binn_object_get_value(objptr, \"int8\", &value) == 1);\n  assert(value.type == 0x21);\n  assert(value.vint8 == (-120));\n  assert(binn_object_get_value(objptr, \"int64\", &value) == 1);\n  assert(value.type == 0x81);\n  assert(value.vint64 == (-1234567890123));\n  assert(binn_object_get_value(objptr, \"uint32\", &value) == 1);\n  assert(value.type == 0x60);\n  assert(value.vuint32 == 123456);\n  assert(binn_object_get_value(objptr, \"uint16\", &value) == 1);\n  assert(value.type == 0x40);\n  assert(value.vuint16 == 60500);\n  assert(binn_object_get_value(objptr, \"uint8\", &value) == 1);\n  assert(value.type == 0x20);\n  assert(value.vuint8 == 250);\n  assert(binn_object_get_value(objptr, \"uint64\", &value) == 1);\n  assert(value.type == 0x80);\n  assert(value.vuint64 == 1234567890123);\n  puts(\"reading... OK\");\n}\n\n",
        "translated_code": "pub fn test_binn_read(objptr: Option<&[u8]>) {\n    let mut listptr: Option<&[u8]> = None;\n    let mut listptr_idx = 0;\n    let mut ptr: Option<String> = None;\n    let mut ptr_idx = 0;\n    let mut value: Option<Box<BinnStruct>> = None;\n    \n    println!(\"OK\\nreading:\");\n\n    // int32\n    {\n        let mut vint32 = VINT32.load(Ordering::SeqCst);\n        assert!(binn_object_get(objptr, Some(\"int32\"), 0x61, Some(&mut vint32 as &mut dyn Any), None) == 1);\n        VINT32.store(vint32, Ordering::SeqCst);\n        println!(\"int32: {}\", vint32);\n        assert!(vint32 == -12345);\n    }\n\n    // int16\n    {\n        let mut vint16: i16 = 0;\n        assert!(binn_object_get(objptr, Some(\"int16\"), 0x41, Some(&mut vint16 as &mut dyn Any), None) == 1);\n        println!(\"int16: {}\", vint16);\n        assert!(vint16 == -258);\n    }\n\n    // int8\n    {\n        unsafe {\n            assert!(binn_object_get(objptr, Some(\"int8\"), 0x21, Some(&mut VINT8 as &mut dyn Any), None) == 1);\n            println!(\"int8: {}\", VINT8);\n            assert!(VINT8 == -120);\n        }\n    }\n\n    // int64\n    {\n        unsafe {\n            assert!(binn_object_get(objptr, Some(\"int64\"), 0x81, Some(&mut vint64 as &mut dyn Any), None) == 1);\n            println!(\"int64: {}\", vint64);\n            assert!(vint64 == -1234567890123);\n        }\n    }\n\n    // uint32\n    {\n        let mut vuint32: u32 = 0;\n        assert!(binn_object_get(objptr, Some(\"uint32\"), 0x60, Some(&mut vuint32 as &mut dyn Any), None) == 1);\n        println!(\"uint32: {}\", vuint32);\n        assert!(vuint32 == 123456);\n    }\n\n    // uint16\n    {\n        let mut vuint16: u16 = 0;\n        assert!(binn_object_get(objptr, Some(\"uint16\"), 0x40, Some(&mut vuint16 as &mut dyn Any), None) == 1);\n        println!(\"uint16: {}\", vuint16);\n        assert!(vuint16 == 60500);\n    }\n\n    // uint8\n    {\n        let mut vuint8: u8 = 0;\n        assert!(binn_object_get(objptr, Some(\"uint8\"), 0x20, Some(&mut vuint8 as &mut dyn Any), None) == 1);\n        println!(\"uint8: {}\", vuint8);\n        assert!(vuint8 == 250);\n    }\n\n    // uint64\n    {\n        let mut vuint64: u64 = 0;\n        assert!(binn_object_get(objptr, Some(\"uint64\"), 0x80, Some(&mut vuint64 as &mut dyn Any), None) == 1);\n        println!(\"uint64: {}\", vuint64);\n        assert!(vuint64 == 1234567890123);\n    }\n\n    // float32\n    {\n        unsafe {\n            assert!(binn_object_get(objptr, Some(\"float32\"), 0x62, Some(&mut vfloat32 as &mut dyn Any), None) == 1);\n            println!(\"float32: {}\", vfloat32);\n            assert!(AlmostEqualFloats(vfloat32, -12.345, 2));\n        }\n    }\n\n    // float64\n    {\n        unsafe {\n            assert!(binn_object_get(objptr, Some(\"float64\"), 0x82, Some(&mut vfloat64 as &mut dyn Any), None) == 1);\n            println!(\"float64: {}\", vfloat64);\n            assert!((vfloat64 - (-123456.7895)).abs() < 0.01);\n        }\n    }\n\n    // single (float32 again)\n    {\n        unsafe {\n            assert!(binn_object_get(objptr, Some(\"single\"), 0x62, Some(&mut vfloat32 as &mut dyn Any), None) == 1);\n            println!(\"single: {}\", vfloat32);\n            assert!(AlmostEqualFloats(vfloat32, -12.345, 2));\n        }\n    }\n\n    // double (float64 again)\n    {\n        unsafe {\n            assert!(binn_object_get(objptr, Some(\"double\"), 0x82, Some(&mut vfloat64 as &mut dyn Any), None) == 1);\n            println!(\"double: {}\", vfloat64);\n            assert!((vfloat64 - (-123456.7895)).abs() < 0.01);\n        }\n    }\n\n    // str\n    {\n        ptr_idx = 0;\n        let mut temp_ptr: Option<String> = None;\n        assert!(binn_object_get(objptr, Some(\"str\"), 0xA0, Some(&mut temp_ptr as &mut dyn Any), None) == 1);\n        ptr = temp_ptr;\n        println!(\"ptr: '{:?}'\", ptr);\n        assert!(ptr.as_deref() == Some(\"the value\"));\n    }\n\n    // bool_true\n    {\n        let mut vint32 = VINT32.load(Ordering::SeqCst);\n        assert!(binn_object_get(objptr, Some(\"bool_true\"), 0x80061, Some(&mut vint32 as &mut dyn Any), None) == 1);\n        VINT32.store(vint32, Ordering::SeqCst);\n        println!(\"bool true: {}\", vint32);\n        assert!(vint32 == 1);\n    }\n\n    // bool_false\n    {\n        let mut vint32 = VINT32.load(Ordering::SeqCst);\n        assert!(binn_object_get(objptr, Some(\"bool_false\"), 0x80061, Some(&mut vint32 as &mut dyn Any), None) == 1);\n        VINT32.store(vint32, Ordering::SeqCst);\n        println!(\"bool false: {}\", vint32);\n        assert!(vint32 == 0);\n    }\n\n    // null\n    {\n        let mut vint32 = VINT32.load(Ordering::SeqCst);\n        assert!(binn_object_get(objptr, Some(\"null\"), 0x00, Some(&mut vint32 as &mut dyn Any), None) == 1);\n        VINT32.store(vint32, Ordering::SeqCst);\n        println!(\"null: {}\", vint32);\n        assert!(binn_object_get(objptr, Some(\"null\"), 0x00, None, None) == 1);\n    }\n\n    // list\n    {\n        let mut temp_listptr: Option<&[u8]> = None;\n        assert!(binn_object_get(objptr, Some(\"list\"), 0xE0, Some(&mut temp_listptr as &mut dyn Any), None) == 1);\n        listptr = temp_listptr;\n        println!(\"obj ptr: {:?}  list ptr: {:?}\", objptr, listptr);\n        assert!(listptr.is_some());\n    }\n\n    // list operations\n    if let Some(list) = listptr {\n        // int32 from list\n        {\n            let mut vint32 = VINT32.load(Ordering::SeqCst);\n            assert!(binn_list_get(Some(list), 2, 0x61, Some(&mut vint32 as &mut dyn Any), None) == 1);\n            VINT32.store(vint32, Ordering::SeqCst);\n            println!(\"int32: {}\", vint32);\n            assert!(vint32 == 123);\n        }\n\n        // str from list\n        {\n            ptr_idx = 0;\n            let mut temp_ptr: Option<String> = None;\n            assert!(binn_list_get(Some(list), 3, 0xA0, Some(&mut temp_ptr as &mut dyn Any), None) == 1);\n            ptr = temp_ptr;\n            println!(\"ptr: '{:?}'\", ptr);\n            assert!(ptr.as_deref() == Some(\"this is a string\"));\n        }\n    }\n\n    println!(\"reading... OK\");\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [
            "AlmostEqualFloats",
            "binn",
            "binn_list_get",
            "binn_list_get_int32",
            "binn_list_get_str",
            "binn_list_int32",
            "binn_list_str",
            "binn_object_bool",
            "binn_object_double",
            "binn_object_float",
            "binn_object_get",
            "binn_object_get_bool",
            "binn_object_get_double",
            "binn_object_get_float",
            "binn_object_get_int16",
            "binn_object_get_int32",
            "binn_object_get_int64",
            "binn_object_get_int8",
            "binn_object_get_list",
            "binn_object_get_str",
            "binn_object_get_uint16",
            "binn_object_get_uint32",
            "binn_object_get_uint64",
            "binn_object_get_uint8",
            "binn_object_get_value",
            "binn_object_int16",
            "binn_object_int32",
            "binn_object_int64",
            "binn_object_int8",
            "binn_object_list",
            "binn_object_null",
            "binn_object_str",
            "binn_object_uint16",
            "binn_object_uint32",
            "binn_object_uint64",
            "binn_object_uint8",
            "vbool",
            "vfloat32",
            "vfloat64",
            "vint16",
            "vint32",
            "vint64",
            "vint8",
            "vuint16",
            "vuint32",
            "vuint64",
            "vuint8"
        ],
        "params": [
            "void *objptr"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "objptr",
            "listptr",
            "listptr_idx",
            "ptr",
            "ptr_idx",
            "value",
            "vint32",
            "vint16",
            "vint8",
            "vint64",
            "vuint32",
            "vuint16",
            "vuint8",
            "vuint64",
            "vfloat32",
            "vfloat64",
            "vbool"
        ],
        "calle": [
            "binn_object_null",
            "binn_object_int16",
            "binn_object_get",
            "binn_list_get_str",
            "binn_object_int32",
            "binn_object_get_bool",
            "binn_list_get",
            "binn_object_get_double",
            "binn_object_get_list",
            "binn_object_uint64",
            "binn_object_double",
            "binn_object_get_uint64",
            "binn_object_get_uint8",
            "binn_list_str",
            "binn_object_get_int8",
            "AlmostEqualFloats",
            "binn_object_bool",
            "binn_object_int8",
            "printf",
            "binn_object_float",
            "binn_list_get_int32",
            "binn_object_int64",
            "binn_object_get_int64",
            "binn_object_get_float",
            "binn_object_uint16",
            "binn_object_get_int32",
            "binn_object_uint8",
            "binn_object_str",
            "binn_object_get_uint16",
            "binn_object_uint32",
            "binn_object_list",
            "puts",
            "strcmp",
            "assert",
            "binn_object_get_value",
            "binn_object_get_str",
            "binn_object_get_uint32",
            "binn_object_get_int16",
            "binn_list_int32"
        ],
        "calle_c": [
            "puts",
            "assert",
            "strcmp",
            "printf"
        ],
        "key": "test_binn_read",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "test_binn_iter": {
        "source_code": "void test_binn_iter(BOOL use_int_compression)\n{\n  binn *list;\n  unsigned int list_idx = 0;\n  binn *map;\n  unsigned int map_idx = 0;\n  binn *obj;\n  unsigned int obj_idx = 0;\n  binn *list2;\n  unsigned int list2_idx = 0;\n  binn *copy = 0;\n  unsigned int copy_idx = 0;\n  binn_iter iter;\n  binn_iter iter2;\n  binn value;\n  binn value2;\n  int blob_size;\n  int id;\n  int id2;\n  int list2size;\n  void *ptr;\n  unsigned int ptr_idx = 0;\n  void *blob_ptr;\n  unsigned int blob_ptr_idx = 0;\n  char key[256];\n  char key2[256];\n  blob_ptr_idx = \"key\\0value\\0\\0\";\n  blob_size = 11;\n  printf(\"testing binn sequential read (use_int_compression = %d)... \", use_int_compression);\n  list_idx = binn_list();\n  list2_idx = binn_list();\n  map_idx = binn_map();\n  obj_idx = binn_object();\n  assert((&list[list_idx]) != 0);\n  assert((&list2[list2_idx]) != 0);\n  assert((&map[map_idx]) != 0);\n  assert((&obj[obj_idx]) != 0);\n  if (use_int_compression == 0)\n  {\n    list->disable_int_compression = 1;\n    map->disable_int_compression = 1;\n    obj->disable_int_compression = 1;\n  }\n  assert(binn_list_add_int32(list2, 250) == 1);\n  assert(binn_list_add_null(list2) == 1);\n  assert(binn_list_add_str(list2, \"l1st2\") == 1);\n  assert(binn_list_add_bool(list2, 1) == 1);\n  list2size = binn_size(list2);\n  assert(binn_list_add_int8(list, 111) == 1);\n  assert(binn_list_add_int32(list, 123456789) == 1);\n  assert(binn_list_add_int16(list, -123) == 1);\n  assert(binn_list_add_int64(list, 9876543210) == 1);\n  assert(binn_list_add_float(list, 1.25) == 1);\n  assert(binn_list_add_double(list, 25.987654321) == 1);\n  assert(binn_list_add_bool(list, 1) == 1);\n  assert(binn_list_add_bool(list, 0) == 1);\n  assert(binn_list_add_null(list) == 1);\n  assert(binn_list_add_str(list, \"testing...\") == 1);\n  assert(binn_list_add_blob(list, (char *) blob_ptr, blob_size) == 1);\n  assert(binn_list_add_list(list, list2) == 1);\n  assert(binn_object_set_int8(obj, \"a\", 111) == 1);\n  assert(binn_object_set_int32(obj, \"b\", 123456789) == 1);\n  assert(binn_object_set_int16(obj, \"c\", -123) == 1);\n  assert(binn_object_set_int64(obj, \"d\", 9876543210) == 1);\n  assert(binn_object_set_float(obj, \"e\", 1.25) == 1);\n  assert(binn_object_set_double(obj, \"f\", 25.987654321) == 1);\n  assert(binn_object_set_bool(obj, \"g\", 1) == 1);\n  assert(binn_object_set_bool(obj, \"h\", 0) == 1);\n  assert(binn_object_set_null(obj, \"i\") == 1);\n  assert(binn_object_set_str(obj, \"j\", \"testing...\") == 1);\n  assert(binn_object_set_blob(obj, \"k\", (char *) blob_ptr, blob_size) == 1);\n  assert(binn_object_set_list(obj, \"l\", list2) == 1);\n  assert(binn_map_set_int8(map, 55010, 111) == 1);\n  assert(binn_map_set_int32(map, 55020, 123456789) == 1);\n  assert(binn_map_set_int16(map, 55030, -123) == 1);\n  assert(binn_map_set_int64(map, 55040, 9876543210) == 1);\n  assert(binn_map_set_float(map, 55050, 1.25) == 1);\n  assert(binn_map_set_double(map, 55060, 25.987654321) == 1);\n  assert(binn_map_set_bool(map, 55070, 1) == 1);\n  assert(binn_map_set_bool(map, 55080, 0) == 1);\n  assert(binn_map_set_null(map, 55090) == 1);\n  assert(binn_map_set_str(map, 55100, \"testing...\") == 1);\n  assert(binn_map_set_blob(map, 55110, (char *) blob_ptr, blob_size) == 1);\n  assert(binn_map_set_list(map, 55120, list2) == 1);\n  ptr_idx = binn_ptr(list);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(binn_iter_init(&iter, ptr, 0xE0));\n  assert(iter.pnext > (&ptr[ptr_idx]));\n  assert(iter.plimit > (&ptr[ptr_idx]));\n  assert(iter.count == 12);\n  assert(iter.current == 0);\n  assert(binn_list_next(&iter, &value) == 1);\n  assert(iter.pnext > (&ptr[ptr_idx]));\n  assert(iter.plimit > (&ptr[ptr_idx]));\n  assert(iter.count == 12);\n  assert(iter.current == 1);\n  assert(value.type == 0x21);\n  assert(value.vint8 == 111);\n  assert(binn_list_next(&iter, &value) == 1);\n  assert(iter.current == 2);\n  if (use_int_compression)\n  {\n    assert(value.type == 0x60);\n  }\n  else\n  {\n    assert(value.type == 0x61);\n  }\n  assert(value.vint32 == 123456789);\n  assert(binn_list_next(&iter, &value) == 1);\n  assert(iter.current == 3);\n  if (use_int_compression)\n  {\n    assert(value.type == 0x21);\n    assert(value.vint8 == (-123));\n  }\n  else\n  {\n    assert(value.type == 0x41);\n    assert(value.vint16 == (-123));\n  }\n  assert(binn_list_next(&iter, &value) == 1);\n  assert(iter.current == 4);\n  assert(value.type == 0x81);\n  assert(value.vint64 == 9876543210);\n  assert(binn_list_next(&iter, &value) == 1);\n  assert(iter.current == 5);\n  assert(value.type == 0x62);\n  assert(AlmostEqualFloats(value.vfloat, 1.25, 2));\n  assert(binn_list_next(&iter, &value) == 1);\n  assert(iter.current == 6);\n  assert(value.type == 0x82);\n  assert((value.vdouble - 25.987654321) < 0.00000001);\n  assert(binn_list_next(&iter, &value) == 1);\n  assert(iter.current == 7);\n  assert(value.type == 0x80061);\n  assert(value.vbool == 1);\n  assert(binn_list_next(&iter, &value) == 1);\n  assert(iter.current == 8);\n  assert(value.type == 0x80061);\n  assert(value.vbool == 0);\n  assert(binn_list_next(&iter, &value) == 1);\n  assert(iter.current == 9);\n  assert(value.type == 0x00);\n  assert(binn_list_next(&iter, &value) == 1);\n  assert(iter.current == 10);\n  assert(value.type == 0xA0);\n  assert(strcmp((char *) value.ptr, \"testing...\") == 0);\n  assert(binn_list_next(&iter, &value) == 1);\n  assert(iter.current == 11);\n  assert(value.type == 0xC0);\n  assert(memcmp(value.ptr, blob_ptr, blob_size) == 0);\n  assert(binn_list_next(&iter, &value) == 1);\n  assert(iter.current == 12);\n  assert(value.type == 0xE0);\n  assert(value.size == list2size);\n  assert(value.count == 4);\n  assert(value.ptr != 0);\n  assert(binn_list_int32(value.ptr, 1) == 250);\n  assert(binn_list_null(value.ptr, 2) == 1);\n  ptr_idx = binn_list_str(value.ptr_idx, 3);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(strcmp((char *) ptr, \"l1st2\") == 0);\n  assert(binn_list_bool(value.ptr, 4) == 1);\n  assert(binn_list_next(&iter, &value) == 0);\n  assert(binn_list_next(&iter, &value) == 0);\n  ptr_idx = binn_ptr(obj);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(binn_iter_init(&iter, ptr, 0xE2));\n  assert(iter.pnext > (&ptr[ptr_idx]));\n  assert(iter.plimit > (&ptr[ptr_idx]));\n  assert(iter.count == 12);\n  assert(iter.current == 0);\n  assert(binn_object_next(&iter, key, &value) == 1);\n  assert(iter.pnext > (&ptr[ptr_idx]));\n  assert(iter.plimit > (&ptr[ptr_idx]));\n  assert(iter.count == 12);\n  assert(iter.current == 1);\n  assert(value.type == 0x21);\n  assert(value.vint8 == 111);\n  assert(strcmp(key, \"a\") == 0);\n  assert(binn_object_next(&iter, key, &value) == 1);\n  assert(iter.current == 2);\n  if (use_int_compression)\n  {\n    assert(value.type == 0x60);\n  }\n  else\n  {\n    assert(value.type == 0x61);\n  }\n  assert(value.vint32 == 123456789);\n  assert(strcmp(key, \"b\") == 0);\n  assert(binn_object_next(&iter, key, &value) == 1);\n  assert(iter.current == 3);\n  if (use_int_compression)\n  {\n    assert(value.type == 0x21);\n    assert(value.vint8 == (-123));\n  }\n  else\n  {\n    assert(value.type == 0x41);\n    assert(value.vint16 == (-123));\n  }\n  assert(strcmp(key, \"c\") == 0);\n  assert(binn_object_next(&iter, key, &value) == 1);\n  assert(iter.current == 4);\n  assert(value.type == 0x81);\n  assert(value.vint64 == 9876543210);\n  assert(strcmp(key, \"d\") == 0);\n  assert(binn_object_next(&iter, key, &value) == 1);\n  assert(iter.current == 5);\n  assert(value.type == 0x62);\n  assert(AlmostEqualFloats(value.vfloat, 1.25, 2));\n  assert(strcmp(key, \"e\") == 0);\n  assert(binn_object_next(&iter, key, &value) == 1);\n  assert(iter.current == 6);\n  assert(value.type == 0x82);\n  assert((value.vdouble - 25.987654321) < 0.00000001);\n  assert(strcmp(key, \"f\") == 0);\n  assert(binn_object_next(&iter, key, &value) == 1);\n  assert(iter.current == 7);\n  assert(value.type == 0x80061);\n  assert(value.vbool == 1);\n  assert(strcmp(key, \"g\") == 0);\n  assert(binn_object_next(&iter, key, &value) == 1);\n  assert(iter.current == 8);\n  assert(value.type == 0x80061);\n  assert(value.vbool == 0);\n  assert(strcmp(key, \"h\") == 0);\n  assert(binn_object_next(&iter, key, &value) == 1);\n  assert(iter.current == 9);\n  assert(value.type == 0x00);\n  assert(strcmp(key, \"i\") == 0);\n  assert(binn_object_next(&iter, key, &value) == 1);\n  assert(iter.current == 10);\n  assert(value.type == 0xA0);\n  assert(strcmp((char *) value.ptr, \"testing...\") == 0);\n  assert(strcmp(key, \"j\") == 0);\n  assert(binn_object_next(&iter, key, &value) == 1);\n  assert(iter.current == 11);\n  assert(value.type == 0xC0);\n  assert(memcmp(value.ptr, blob_ptr, blob_size) == 0);\n  assert(strcmp(key, \"k\") == 0);\n  assert(binn_object_next(&iter, key, &value) == 1);\n  assert(iter.current == 12);\n  assert(value.type == 0xE0);\n  assert(value.size == list2size);\n  assert(value.count == 4);\n  assert(value.ptr != 0);\n  assert(binn_list_int32(value.ptr, 1) == 250);\n  assert(binn_list_null(value.ptr, 2) == 1);\n  ptr_idx = binn_list_str(value.ptr_idx, 3);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(strcmp((char *) ptr, \"l1st2\") == 0);\n  assert(binn_list_bool(value.ptr, 4) == 1);\n  assert(strcmp(key, \"l\") == 0);\n  assert(binn_object_next(&iter, key, &value) == 0);\n  assert(binn_object_next(&iter, key, &value) == 0);\n  ptr_idx = binn_ptr(map);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(binn_iter_init(&iter, ptr, 0xE1));\n  assert(iter.pnext > (&ptr[ptr_idx]));\n  assert(iter.plimit > (&ptr[ptr_idx]));\n  assert(iter.count == 12);\n  assert(iter.current == 0);\n  assert(binn_map_next(&iter, &id, &value) == 1);\n  assert(iter.pnext > (&ptr[ptr_idx]));\n  assert(iter.plimit > (&ptr[ptr_idx]));\n  assert(iter.count == 12);\n  assert(iter.current == 1);\n  assert(value.type == 0x21);\n  assert(value.vint8 == 111);\n  assert(id == 55010);\n  assert(binn_map_next(&iter, &id, &value) == 1);\n  assert(iter.current == 2);\n  if (use_int_compression)\n  {\n    assert(value.type == 0x60);\n  }\n  else\n  {\n    assert(value.type == 0x61);\n  }\n  assert(value.vint32 == 123456789);\n  assert(id == 55020);\n  assert(binn_map_next(&iter, &id, &value) == 1);\n  assert(iter.current == 3);\n  if (use_int_compression)\n  {\n    assert(value.type == 0x21);\n    assert(value.vint8 == (-123));\n  }\n  else\n  {\n    assert(value.type == 0x41);\n    assert(value.vint16 == (-123));\n  }\n  assert(id == 55030);\n  assert(binn_map_next(&iter, &id, &value) == 1);\n  assert(iter.current == 4);\n  assert(value.type == 0x81);\n  assert(value.vint64 == 9876543210);\n  assert(id == 55040);\n  assert(binn_map_next(&iter, &id, &value) == 1);\n  assert(iter.current == 5);\n  assert(value.type == 0x62);\n  assert(AlmostEqualFloats(value.vfloat, 1.25, 2));\n  assert(id == 55050);\n  assert(binn_map_next(&iter, &id, &value) == 1);\n  assert(iter.current == 6);\n  assert(value.type == 0x82);\n  assert((value.vdouble - 25.987654321) < 0.00000001);\n  assert(id == 55060);\n  assert(binn_map_next(&iter, &id, &value) == 1);\n  assert(iter.current == 7);\n  assert(value.type == 0x80061);\n  assert(value.vbool == 1);\n  assert(id == 55070);\n  assert(binn_map_next(&iter, &id, &value) == 1);\n  assert(iter.current == 8);\n  assert(value.type == 0x80061);\n  assert(value.vbool == 0);\n  assert(id == 55080);\n  assert(binn_map_next(&iter, &id, &value) == 1);\n  assert(iter.current == 9);\n  assert(value.type == 0x00);\n  assert(id == 55090);\n  assert(binn_map_next(&iter, &id, &value) == 1);\n  assert(iter.current == 10);\n  assert(value.type == 0xA0);\n  assert(strcmp((char *) value.ptr, \"testing...\") == 0);\n  assert(id == 55100);\n  assert(binn_map_next(&iter, &id, &value) == 1);\n  assert(iter.current == 11);\n  assert(value.type == 0xC0);\n  assert(memcmp(value.ptr, blob_ptr, blob_size) == 0);\n  assert(id == 55110);\n  assert(binn_map_next(&iter, &id, &value) == 1);\n  assert(iter.current == 12);\n  assert(value.type == 0xE0);\n  assert(value.size == list2size);\n  assert(value.count == 4);\n  assert(value.ptr != 0);\n  assert(binn_list_int32(value.ptr, 1) == 250);\n  assert(binn_list_null(value.ptr, 2) == 1);\n  ptr_idx = binn_list_str(value.ptr_idx, 3);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(strcmp((char *) ptr, \"l1st2\") == 0);\n  assert(binn_list_bool(value.ptr, 4) == 1);\n  assert(id == 55120);\n  assert(binn_map_next(&iter, &id, &value) == 0);\n  assert(binn_map_next(&iter, &id, &value) == 0);\n  copy_idx = binn_copy(list);\n  assert((&copy[copy_idx]) != 0);\n  assert(binn_type(copy) == binn_type(list));\n  assert(binn_count(copy) == binn_count(list));\n  assert(binn_size(copy) == binn_size(list));\n  assert(binn_iter_init(&iter, list, 0xE0));\n  assert(binn_iter_init(&iter2, copy, 0xE0));\n  while (binn_list_next(&iter, &value))\n  {\n    assert(binn_list_next(&iter2, &value2) == 1);\n    assert(value.type == value2.type);\n  }\n\n  assert(binn_list_add_str(copy, \"testing...\") == 1);\n  assert(binn_type(copy) == binn_type(list));\n  assert(binn_count(copy) == (binn_count(list) + 1));\n  assert(binn_size(copy) > binn_size(list));\n  binn_free(copy);\n  copy_idx = binn_copy(map);\n  assert((&copy[copy_idx]) != 0);\n  assert(binn_type(copy) == binn_type(map));\n  assert(binn_count(copy) == binn_count(map));\n  assert(binn_size(copy) == binn_size(map));\n  assert(binn_iter_init(&iter, map, 0xE1));\n  assert(binn_iter_init(&iter2, copy, 0xE1));\n  while (binn_map_next(&iter, &id, &value))\n  {\n    assert(binn_map_next(&iter2, &id2, &value2) == 1);\n    assert(id == id2);\n    assert(value.type == value2.type);\n  }\n\n  assert(binn_map_set_int32(copy, 5600, 123) == 1);\n  assert(binn_type(copy) == binn_type(map));\n  assert(binn_count(copy) == (binn_count(map) + 1));\n  assert(binn_size(copy) > binn_size(map));\n  binn_free(copy);\n  copy_idx = binn_copy(obj);\n  assert((&copy[copy_idx]) != 0);\n  assert(binn_type(copy) == binn_type(obj));\n  assert(binn_count(copy) == binn_count(obj));\n  assert(binn_size(copy) == binn_size(obj));\n  assert(binn_iter_init(&iter, obj, 0xE2));\n  assert(binn_iter_init(&iter2, copy, 0xE2));\n  while (binn_object_next(&iter, key, &value))\n  {\n    assert(binn_object_next(&iter2, key2, &value2) == 1);\n    assert(strcmp(key, key2) == 0);\n    assert(value.type == value2.type);\n  }\n\n  assert(binn_object_set_int32(copy, \"another\", 123) == 1);\n  assert(binn_type(copy) == binn_type(obj));\n  assert(binn_count(copy) == (binn_count(obj) + 1));\n  assert(binn_size(copy) > binn_size(obj));\n  binn_free(copy);\n  ptr_idx = binn_ptr(list);\n  copy_idx = binn_copy(ptr);\n  assert((&copy[copy_idx]) != 0);\n  assert(binn_type(copy) == binn_type(list));\n  assert(binn_count(copy) == binn_count(list));\n  assert(binn_size(copy) == binn_size(list));\n  assert(binn_iter_init(&iter, ptr, 0xE0));\n  assert(binn_iter_init(&iter2, copy, 0xE0));\n  while (binn_list_next(&iter, &value))\n  {\n    assert(binn_list_next(&iter2, &value2) == 1);\n    assert(value.type == value2.type);\n  }\n\n  assert(binn_list_add_str(copy, \"testing...\") == 1);\n  assert(binn_type(copy) == binn_type(list));\n  assert(binn_count(copy) == (binn_count(list) + 1));\n  assert(binn_size(copy) > binn_size(list));\n  binn_free(copy);\n  ptr_idx = binn_ptr(map);\n  copy_idx = binn_copy(ptr);\n  assert((&copy[copy_idx]) != 0);\n  assert(binn_type(copy) == binn_type(map));\n  assert(binn_count(copy) == binn_count(map));\n  assert(binn_size(copy) == binn_size(map));\n  assert(binn_iter_init(&iter, ptr, 0xE1));\n  assert(binn_iter_init(&iter2, copy, 0xE1));\n  while (binn_map_next(&iter, &id, &value))\n  {\n    assert(binn_map_next(&iter2, &id2, &value2) == 1);\n    assert(id == id2);\n    assert(value.type == value2.type);\n  }\n\n  assert(binn_map_set_int32(copy, 5600, 123) == 1);\n  assert(binn_type(copy) == binn_type(map));\n  assert(binn_count(copy) == (binn_count(map) + 1));\n  assert(binn_size(copy) > binn_size(map));\n  binn_free(copy);\n  ptr_idx = binn_ptr(obj);\n  copy_idx = binn_copy(ptr);\n  assert((&copy[copy_idx]) != 0);\n  assert(binn_type(copy) == binn_type(obj));\n  assert(binn_count(copy) == binn_count(obj));\n  assert(binn_size(copy) == binn_size(obj));\n  assert(binn_iter_init(&iter, ptr, 0xE2));\n  assert(binn_iter_init(&iter2, copy, 0xE2));\n  while (binn_object_next(&iter, key, &value))\n  {\n    assert(binn_object_next(&iter2, key2, &value2) == 1);\n    assert(strcmp(key, key2) == 0);\n    assert(value.type == value2.type);\n  }\n\n  assert(binn_object_set_int32(copy, \"another\", 123) == 1);\n  assert(binn_type(copy) == binn_type(obj));\n  assert(binn_count(copy) == (binn_count(obj) + 1));\n  assert(binn_size(copy) > binn_size(obj));\n  binn_free(copy);\n  binn_free(list);\n  binn_free(list2);\n  binn_free(map);\n  binn_free(obj);\n  puts(\"OK\");\n}\n\n",
        "translated_code": "pub fn test_binn_iter(use_int_compression: BOOL) {\n    let mut list: Option<Box<BinnStruct>> = binn_list();\n    let mut list_idx = 0;\n    let mut map: Option<Box<BinnStruct>> = binn_map();\n    let mut map_idx = 0;\n    let mut obj: Option<Box<BinnStruct>> = binn_object();\n    let mut obj_idx = 0;\n    let mut list2: Option<Box<BinnStruct>> = binn_list();\n    let mut list2_idx = 0;\n    let mut copy: Option<Box<BinnStruct>> = None;\n    let mut copy_idx = 0;\n    let mut iter = BinnIter {\n        pnext: None,\n        plimit: None,\n        type_: 0,\n        count: 0,\n        current: 0,\n    };\n    let mut iter2 = BinnIter {\n        pnext: None,\n        plimit: None,\n        type_: 0,\n        count: 0,\n        current: 0,\n    };\n    let mut value = BinnValue {\n        vint8: 0,\n        vint16: 0,\n        vint32: 0,\n        vint64: 0,\n        vuint8: 0,\n        vuint16: 0,\n        vuint32: 0,\n        vuint64: 0,\n        vchar: 0,\n        vuchar: 0,\n        vshort: 0,\n        vushort: 0,\n        vint: 0,\n        vuint: 0,\n        vfloat: 0.0,\n        vdouble: 0.0,\n        vbool: 0,\n    };\n    let mut value2 = BinnValue {\n        vint8: 0,\n        vint16: 0,\n        vint32: 0,\n        vint64: 0,\n        vuint8: 0,\n        vuint16: 0,\n        vuint32: 0,\n        vuint64: 0,\n        vchar: 0,\n        vuchar: 0,\n        vshort: 0,\n        vushort: 0,\n        vint: 0,\n        vuint: 0,\n        vfloat: 0.0,\n        vdouble: 0.0,\n        vbool: 0,\n    };\n    let mut blob_size = 0;\n    let mut id = 0;\n    let mut id2 = 0;\n    let mut list2size = 0;\n    let mut ptr: Option<*mut u8> = None;\n    let mut ptr_idx = 0;\n    let mut blob_ptr: Option<*mut u8> = None;\n    let mut blob_ptr_idx = 0;\n    let mut key = [0; 256];\n    let mut key2 = [0; 256];\n\n    blob_ptr_idx = 0;\n    blob_size = 11;\n    println!(\"testing binn sequential read (use_int_compression = {})... \", use_int_compression);\n\n    list_idx = 0;\n    list2_idx = 0;\n    map_idx = 0;\n    obj_idx = 0;\n    assert!(list.is_some());\n    assert!(list2.is_some());\n    assert!(map.is_some());\n    assert!(obj.is_some());\n\n    if use_int_compression == 0 {\n        if let Some(ref mut list_inner) = list {\n            list_inner.disable_int_compression = 1;\n        }\n        if let Some(ref mut map_inner) = map {\n            map_inner.disable_int_compression = 1;\n        }\n        if let Some(ref mut obj_inner) = obj {\n            obj_inner.disable_int_compression = 1;\n        }\n    }\n\n    assert!(binn_list_add_int32(&mut list2, 250) == 1);\n    assert!(binn_list_add_null(&mut list2) == 1);\n    assert!(binn_list_add_str(&mut list2, Some(&mut Some(Box::new(\"l1st2\".to_string())))) == 1);\n    assert!(binn_list_add_bool(&mut list2, 1) == 1);\n    list2size = binn_size(list2.as_ref().map(|x| x as *const _ as *mut u8));\n    assert!(binn_list_add_int8(&mut list, 111) == 1);\n    assert!(binn_list_add_int32(&mut list, 123456789) == 1);\n    assert!(binn_list_add_int16(&mut list, -123) == 1);\n    assert!(binn_list_add_int64(&mut list, 9876543210) == 1);\n    assert!(binn_list_add_float(&mut list, 1.25) == 1);\n    assert!(binn_list_add_double(&mut list, 25.987654321) == 1);\n    assert!(binn_list_add_bool(&mut list, 1) == 1);\n    assert!(binn_list_add_bool(&mut list, 0) == 1);\n    assert!(binn_list_add_null(&mut list) == 1);\n    assert!(binn_list_add_str(&mut list, Some(&mut Some(Box::new(\"testing...\".to_string())))) == 1);\n    assert!(binn_list_add_blob(&mut list, None, blob_size) == 1);\n    assert!(binn_list_add_list(&mut list, Some(&mut list2)) == 1);\n    assert!(binn_object_set_int8(&mut obj, Some(\"a\"), 111) == 1);\n    assert!(binn_object_set_int32(&mut obj, Some(\"b\"), 123456789) == 1);\n    assert!(binn_object_set_int16(&mut obj, Some(\"c\"), -123) == 1);\n    assert!(binn_object_set_int64(&mut obj, Some(\"d\"), 9876543210) == 1);\n    assert!(binn_object_set_float(&mut obj, Some(\"e\"), 1.25) == 1);\n    assert!(binn_object_set_double(&mut obj, Some(\"f\"), 25.987654321) == 1);\n    assert!(binn_object_set_bool(&mut obj, Some(\"g\"), 1) == 1);\n    assert!(binn_object_set_bool(&mut obj, Some(\"h\"), 0) == 1);\n    assert!(binn_object_set_null(&mut obj, Some(\"i\")) == 1);\n    assert!(binn_object_set_str(&mut obj, Some(\"j\"), Some(\"testing...\")) == 1);\n    assert!(binn_object_set_blob(&mut obj, Some(\"k\"), None, blob_size) == 1);\n    assert!(binn_object_set_list(&mut obj, Some(\"l\"), list2.as_ref().map(|x| x as *const _ as *mut u8)) == 1);\n    assert!(binn_map_set_int8(&mut map, 55010, 111) == 1);\n    assert!(binn_map_set_int32(&mut map, 55020, 123456789) == 1);\n    assert!(binn_map_set_int16(&mut map, 55030, -123) == 1);\n    assert!(binn_map_set_int64(&mut map, 55040, 9876543210) == 1);\n    assert!(binn_map_set_float(&mut map, 55050, 1.25) == 1);\n    assert!(binn_map_set_double(&mut map, 55060, 25.987654321) == 1);\n    assert!(binn_map_set_bool(&mut map, 55070, 1) == 1);\n    assert!(binn_map_set_bool(&mut map, 55080, 0) == 1);\n    assert!(binn_map_set_null(&mut map, 55090) == 1);\n    assert!(binn_map_set_str(&mut map, 55100, Some(&mut Some(Box::new(\"testing...\".to_string())))) == 1);\n    assert!(binn_map_set_blob(&mut map, 55110, None, blob_size) == 1);\n    assert!(binn_map_set_list(&mut map, 55120, list2.as_ref().map(|x| x as *const _ as *mut u8)) == 1);\n\n    ptr_idx = 0;\n    ptr = binn_ptr(list.as_ref().map(|x| x as *const _ as *mut u8));\n    assert!(ptr.is_some());\n    assert!(binn_iter_init(Some(&mut iter), ptr.as_ref().map(|x| unsafe { std::slice::from_raw_parts(*x, 0) }), 0xE0));\n    assert!(iter.pnext.is_some());\n    assert!(iter.plimit.is_some());\n    assert!(iter.count == 12);\n    assert!(iter.current == 0);\n    \n    let mut value_binn = binn_list();\n    assert!(binn_list_next(Some(&mut iter), Some(&mut value_binn)) == 1);\n    assert!(iter.pnext.is_some());\n    assert!(iter.plimit.is_some());\n    assert!(iter.count == 12);\n    assert!(iter.current == 1);\n    assert!(value_binn.as_ref().unwrap().type_ == 0x21);\n    assert!(value_binn.as_ref().unwrap().value.vint8 == 111);\n    \n    assert!(binn_list_next(Some(&mut iter), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 2);\n    if use_int_compression != 0 {\n        assert!(value_binn.as_ref().unwrap().type_ == 0x60);\n    } else {\n        assert!(value_binn.as_ref().unwrap().type_ == 0x61);\n    }\n    assert!(value_binn.as_ref().unwrap().value.vint32 == 123456789);\n    \n    assert!(binn_list_next(Some(&mut iter), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 3);\n    if use_int_compression != 0 {\n        assert!(value_binn.as_ref().unwrap().type_ == 0x21);\n        assert!(value_binn.as_ref().unwrap().value.vint8 == -123);\n    } else {\n        assert!(value_binn.as_ref().unwrap().type_ == 0x41);\n        assert!(value_binn.as_ref().unwrap().value.vint16 == -123);\n    }\n    \n    assert!(binn_list_next(Some(&mut iter), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 4);\n    assert!(value_binn.as_ref().unwrap().type_ == 0x81);\n    assert!(value_binn.as_ref().unwrap().value.vint64 == 9876543210);\n    \n    assert!(binn_list_next(Some(&mut iter), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 5);\n    assert!(value_binn.as_ref().unwrap().type_ == 0x62);\n    assert!(AlmostEqualFloats(value_binn.as_ref().unwrap().value.vfloat, 1.25, 2));\n    \n    assert!(binn_list_next(Some(&mut iter), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 6);\n    assert!(value_binn.as_ref().unwrap().type_ == 0x82);\n    assert!((value_binn.as_ref().unwrap().value.vdouble - 25.987654321).abs() < 0.00000001);\n    \n    assert!(binn_list_next(Some(&mut iter), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 7);\n    assert!(value_binn.as_ref().unwrap().type_ == 0x80061);\n    assert!(value_binn.as_ref().unwrap().value.vbool == 1);\n    \n    assert!(binn_list_next(Some(&mut iter), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 8);\n    assert!(value_binn.as_ref().unwrap().type_ == 0x80061);\n    assert!(value_binn.as_ref().unwrap().value.vbool == 0);\n    \n    assert!(binn_list_next(Some(&mut iter), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 9);\n    assert!(value_binn.as_ref().unwrap().type_ == 0x00);\n    \n    assert!(binn_list_next(Some(&mut iter), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 10);\n    assert!(value_binn.as_ref().unwrap().type_ == 0xA0);\n    assert!(unsafe { CStr::from_ptr(value_binn.as_ref().unwrap().ptr.as_ref().map(|p| p as *const _ as *const c_char).unwrap()) }.to_str().unwrap() == \"testing...\");\n    \n    assert!(binn_list_next(Some(&mut iter), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 11);\n    assert!(value_binn.as_ref().unwrap().type_ == 0xC0);\n    assert!(unsafe { std::ptr::eq(value_binn.as_ref().unwrap().ptr.as_ref().map(|p| p as *const _ as *const u8).unwrap(), blob_ptr.unwrap()) });\n    \n    assert!(binn_list_next(Some(&mut iter), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 12);\n    assert!(value_binn.as_ref().unwrap().type_ == 0xE0);\n    assert!(value_binn.as_ref().unwrap().size == list2size);\n    assert!(value_binn.as_ref().unwrap().count == 4);\n    assert!(value_binn.as_ref().unwrap().ptr.is_some());\n    assert!(binn_list_int32(Some(unsafe { std::slice::from_raw_parts(value_binn.as_ref().unwrap().ptr.as_ref().map(|p| p as *const _ as *const u8).unwrap(), 0) }), 1) == 250);\n    assert!(binn_list_null(Some(unsafe { std::slice::from_raw_parts(value_binn.as_ref().unwrap().ptr.as_ref().map(|p| p as *const _ as *const u8).unwrap(), 0) }), 2) == 1);\n    ptr_idx = 0;\n    ptr = binn_list_str(Some(unsafe { std::slice::from_raw_parts(value_binn.as_ref().unwrap().ptr.as_ref().map(|p| p as *const _ as *const u8).unwrap(), 0) }), 3).map(|s| s.as_ptr() as *mut u8);\n    assert!(ptr.is_some());\n    assert!(unsafe { CStr::from_ptr(ptr.unwrap() as *const c_char) }.to_str().unwrap() == \"l1st2\");\n    assert!(binn_list_bool(Some(unsafe { std::slice::from_raw_parts(value_binn.as_ref().unwrap().ptr.as_ref().map(|p| p as *const _ as *const u8).unwrap(), 0) }), 4) == 1);\n    assert!(binn_list_next(Some(&mut iter), Some(&mut value_binn)) == 0);\n    assert!(binn_list_next(Some(&mut iter), Some(&mut value_binn)) == 0);\n\n    ptr_idx = 0;\n    ptr = binn_ptr(obj.as_ref().map(|x| x as *const _ as *mut u8));\n    assert!(ptr.is_some());\n    assert!(binn_iter_init(Some(&mut iter), ptr.as_ref().map(|x| unsafe { std::slice::from_raw_parts(*x, 0) }), 0xE2));\n    assert!(iter.pnext.is_some());\n    assert!(iter.plimit.is_some());\n    assert!(iter.count == 12);\n    assert!(iter.current == 0);\n    \n    let mut value_binn = binn_list();\n    assert!(binn_object_next(Some(&mut iter), Some(&mut key), Some(&mut value_binn)) == 1);\n    assert!(iter.pnext.is_some());\n    assert!(iter.plimit.is_some());\n    assert!(iter.count == 12);\n    assert!(iter.current == 1);\n    assert!(value_binn.as_ref().unwrap().type_ == 0x21);\n    assert!(value_binn.as_ref().unwrap().value.vint8 == 111);\n    assert!(unsafe { CStr::from_ptr(key.as_ptr() as *const c_char) }.to_str().unwrap() == \"a\");\n    \n    assert!(binn_object_next(Some(&mut iter), Some(&mut key), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 2);\n    if use_int_compression != 0 {\n        assert!(value_binn.as_ref().unwrap().type_ == 0x60);\n    } else {\n        assert!(value_binn.as_ref().unwrap().type_ == 0x61);\n    }\n    assert!(value_binn.as_ref().unwrap().value.vint32 == 123456789);\n    assert!(unsafe { CStr::from_ptr(key.as_ptr() as *const c_char) }.to_str().unwrap() == \"b\");\n    \n    assert!(binn_object_next(Some(&mut iter), Some(&mut key), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 3);\n    if use_int_compression != 0 {\n        assert!(value_binn.as_ref().unwrap().type_ == 0x21);\n        assert!(value_binn.as_ref().unwrap().value.vint8 == -123);\n    } else {\n        assert!(value_binn.as_ref().unwrap().type_ == 0x41);\n        assert!(value_binn.as_ref().unwrap().value.vint16 == -123);\n    }\n    assert!(unsafe { CStr::from_ptr(key.as_ptr() as *const c_char) }.to_str().unwrap() == \"c\");\n    \n    assert!(binn_object_next(Some(&mut iter), Some(&mut key), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 4);\n    assert!(value_binn.as_ref().unwrap().type_ == 0x81);\n    assert!(value_binn.as_ref().unwrap().value.vint64 == 9876543210);\n    assert!(unsafe { CStr::from_ptr(key.as_ptr() as *const c_char) }.to_str().unwrap() == \"d\");\n    \n    assert!(binn_object_next(Some(&mut iter), Some(&mut key), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 5);\n    assert!(value_binn.as_ref().unwrap().type_ == 0x62);\n    assert!(AlmostEqualFloats(value_binn.as_ref().unwrap().value.vfloat, 1.25, 2));\n    assert!(unsafe { CStr::from_ptr(key.as_ptr() as *const c_char) }.to_str().unwrap() == \"e\");\n    \n    assert!(binn_object_next(Some(&mut iter), Some(&mut key), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 6);\n    assert!(value_binn.as_ref().unwrap().type_ == 0x82);\n    assert!((value_binn.as_ref().unwrap().value.vdouble - 25.987654321).abs() < 0.00000001);\n    assert!(unsafe { CStr::from_ptr(key.as_ptr() as *const c_char) }.to_str().unwrap() == \"f\");\n    \n    assert!(binn_object_next(Some(&mut iter), Some(&mut key), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 7);\n    assert!(value_binn.as_ref().unwrap().type_ == 0x80061);\n    assert!(value_binn.as_ref().unwrap().value.vbool == 1);\n    assert!(unsafe { CStr::from_ptr(key.as_ptr() as *const c_char) }.to_str().unwrap() == \"g\");\n    \n    assert!(binn_object_next(Some(&mut iter), Some(&mut key), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 8);\n    assert!(value_binn.as_ref().unwrap().type_ == 0x80061);\n    assert!(value_binn.as_ref().unwrap().value.vbool == 0);\n    assert!(unsafe { CStr::from_ptr(key.as_ptr() as *const c_char) }.to_str().unwrap() == \"h\");\n    \n    assert!(binn_object_next(Some(&mut iter), Some(&mut key), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 9);\n    assert!(value_binn.as_ref().unwrap().type_ == 0x00);\n    assert!(unsafe { CStr::from_ptr(key.as_ptr() as *const c_char) }.to_str().unwrap() == \"i\");\n    \n    assert!(binn_object_next(Some(&mut iter), Some(&mut key), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 10);\n    assert!(value_binn.as_ref().unwrap().type_ == 0xA0);\n    assert!(unsafe { CStr::from_ptr(value_binn.as_ref().unwrap().ptr.as_ref().map(|p| p as *const _ as *const c_char).unwrap()) }.to_str().unwrap() == \"testing...\");\n    assert!(unsafe { CStr::from_ptr(key.as_ptr() as *const c_char) }.to_str().unwrap() == \"j\");\n    \n    assert!(binn_object_next(Some(&mut iter), Some(&mut key), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 11);\n    assert!(value_binn.as_ref().unwrap().type_ == 0xC0);\n    assert!(unsafe { std::ptr::eq(value_binn.as_ref().unwrap().ptr.as_ref().map(|p| p as *const _ as *const u8).unwrap(), blob_ptr.unwrap()) });\n    assert!(unsafe { CStr::from_ptr(key.as_ptr() as *const c_char) }.to_str().unwrap() == \"k\");\n    \n    assert!(binn_object_next(Some(&mut iter), Some(&mut key), Some(&mut value_binn)) == 1);\n    assert!(iter.current == 12);\n    assert!(value_binn.as_ref().unwrap().type_ == 0xE0);\n    assert!(value_binn.as_ref().unwrap().size == list2size);\n    assert!(value_binn.as_ref().unwrap().count == 4);\n    assert!(value_binn.as_ref().unwrap().ptr.is_some());\n    assert!(binn_list_int32(Some(unsafe { std::slice::from_raw_parts(value_binn.as_ref().unwrap().ptr.as_ref().map(|p| p as *const _ as *const u8).unwrap(), 0) }), 1) == 250);\n    assert!(binn_list_null(Some(unsafe { std::slice::from_raw_parts(value_binn.as_ref().unwrap().ptr.as_ref().map(|p| p as *const _ as *const u8).unwrap(), 0) }), 2) == 1);\n    ptr_idx = 0;\n    ptr = binn_list_str(Some(unsafe { std::slice::from_raw_parts(value_binn.as_ref().unwrap().ptr.as_ref().map(|p| p as *const _ as *const u8).unwrap(), 0) }), 3).map(|s| s.as_ptr() as *mut u8);\n    assert!(ptr.is_some());\n    assert!(unsafe { CStr::from_ptr(ptr.unwrap() as *const c_char) }.to_str().unwrap() == \"l1st2\");\n    assert!(binn_list_bool(Some(unsafe { std::slice::from_raw_parts(value_binn.as_ref().unwrap().ptr.as_ref().map(|p| p as *const _ as *const u8).unwrap(), 0) }), 4) == 1);\n    assert!(unsafe { CStr::from_ptr(key.as_ptr() as *const c_char) }.to_str().unwrap() == \"l\");\n    assert!(binn_object_next(Some(&mut iter), Some(&mut key), Some(&mut value_binn)) == 0);\n    assert!(binn_object_next(Some(&mut iter), Some(&mut key), Some(&mut value_binn)) == 0);\n    println!(\"OK\");\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [
            "AlmostEqualFloats",
            "BOOL",
            "binn",
            "binn_copy",
            "binn_count",
            "binn_free",
            "binn_iter",
            "binn_iter_init",
            "binn_list",
            "binn_list_add_blob",
            "binn_list_add_bool",
            "binn_list_add_double",
            "binn_list_add_float",
            "binn_list_add_int16",
            "binn_list_add_int32",
            "binn_list_add_int64",
            "binn_list_add_int8",
            "binn_list_add_list",
            "binn_list_add_null",
            "binn_list_add_str",
            "binn_list_bool",
            "binn_list_int32",
            "binn_list_next",
            "binn_list_null",
            "binn_list_str",
            "binn_map",
            "binn_map_next",
            "binn_map_set_blob",
            "binn_map_set_bool",
            "binn_map_set_double",
            "binn_map_set_float",
            "binn_map_set_int16",
            "binn_map_set_int32",
            "binn_map_set_int64",
            "binn_map_set_int8",
            "binn_map_set_list",
            "binn_map_set_null",
            "binn_map_set_str",
            "binn_object",
            "binn_object_next",
            "binn_object_set_blob",
            "binn_object_set_bool",
            "binn_object_set_double",
            "binn_object_set_float",
            "binn_object_set_int16",
            "binn_object_set_int32",
            "binn_object_set_int64",
            "binn_object_set_int8",
            "binn_object_set_list",
            "binn_object_set_null",
            "binn_object_set_str",
            "binn_ptr",
            "binn_size",
            "binn_type",
            "vbool",
            "vint16",
            "vint32",
            "vint64",
            "vint8"
        ],
        "params": [
            "BOOL use_int_compression"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "use_int_compression",
            "list",
            "list_idx",
            "map",
            "map_idx",
            "obj",
            "obj_idx",
            "list2",
            "list2_idx",
            "copy",
            "copy_idx",
            "iter",
            "iter2",
            "value",
            "value2",
            "blob_size",
            "id",
            "id2",
            "list2size",
            "ptr",
            "ptr_idx",
            "blob_ptr",
            "blob_ptr_idx",
            "key",
            "key2",
            "vint8",
            "vint32",
            "vint16",
            "vint64",
            "vbool"
        ],
        "calle": [
            "binn_object_set_double",
            "binn_list_add_blob",
            "binn_object_set_int8",
            "binn_object_set_int32",
            "binn_map_set_float",
            "binn_map_set_bool",
            "binn_map_set_int32",
            "binn_list_null",
            "binn_map_set_null",
            "binn_object_set_blob",
            "binn_map_set_double",
            "binn_object_next",
            "binn_map_set_blob",
            "binn_object_set_int64",
            "binn_map_set_int16",
            "binn_count",
            "binn_list_add_int32",
            "binn_object_set_float",
            "binn_list_add_str",
            "binn_list_str",
            "binn_object_set_int16",
            "binn_list_add_int64",
            "AlmostEqualFloats",
            "binn_map_set_list",
            "binn_object_set_bool",
            "binn_list_add_list",
            "printf",
            "binn_map_set_int64",
            "binn_ptr",
            "binn_object",
            "binn_list",
            "binn_free",
            "binn_copy",
            "binn_object_set_list",
            "binn_list_bool",
            "binn_list_add_null",
            "binn_type",
            "binn_list_add_bool",
            "binn_list_add_int8",
            "binn_map_set_str",
            "memcmp",
            "puts",
            "binn_list_add_int16",
            "binn_list_add_double",
            "strcmp",
            "assert",
            "binn_iter_init",
            "binn_list_next",
            "binn_map",
            "binn_object_set_null",
            "binn_map_next",
            "binn_list_add_float",
            "binn_object_set_str",
            "binn_map_set_int8",
            "binn_size",
            "binn_list_int32"
        ],
        "calle_c": [
            "puts",
            "strcmp",
            "assert",
            "printf",
            "memcmp"
        ],
        "key": "test_binn_iter",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "test_binn_int_conversion": {
        "source_code": "void test_binn_int_conversion()\n{\n  binn *obj = 0;\n  unsigned int obj_idx = 0;\n  void *ptr;\n  unsigned int ptr_idx = 0;\n  printf(\"testing binn integer read conversion... \");\n  obj_idx = binn_object();\n  assert((&obj[obj_idx]) != 0);\n  assert(binn_object_set_int8(obj, \"int8\", -8) == 1);\n  assert(binn_object_set_int16(obj, \"int16\", -16) == 1);\n  assert(binn_object_set_int32(obj, \"int32\", -32) == 1);\n  assert(binn_object_set_int64(obj, \"int64\", -64) == 1);\n  assert(binn_object_set_uint8(obj, \"uint8\", 111) == 1);\n  assert(binn_object_set_uint16(obj, \"uint16\", 112) == 1);\n  assert(binn_object_set_uint32(obj, \"uint32\", 113) == 1);\n  assert(binn_object_set_uint64(obj, \"uint64\", 114) == 1);\n  ptr_idx = binn_ptr(obj);\n  assert(binn_object_int8(ptr, \"int8\") == (-8));\n  assert(binn_object_int8(ptr, \"int16\") == (-16));\n  assert(binn_object_int8(ptr, \"int32\") == (-32));\n  assert(binn_object_int8(ptr, \"int64\") == (-64));\n  assert(binn_object_int16(ptr, \"int8\") == (-8));\n  assert(binn_object_int16(ptr, \"int16\") == (-16));\n  assert(binn_object_int16(ptr, \"int32\") == (-32));\n  assert(binn_object_int16(ptr, \"int64\") == (-64));\n  assert(binn_object_int32(ptr, \"int8\") == (-8));\n  assert(binn_object_int32(ptr, \"int16\") == (-16));\n  assert(binn_object_int32(ptr, \"int32\") == (-32));\n  assert(binn_object_int32(ptr, \"int64\") == (-64));\n  assert(binn_object_int64(ptr, \"int8\") == (-8));\n  assert(binn_object_int64(ptr, \"int16\") == (-16));\n  assert(binn_object_int64(ptr, \"int32\") == (-32));\n  assert(binn_object_int64(ptr, \"int64\") == (-64));\n  assert(binn_object_int8(ptr, \"uint8\") == 111);\n  assert(binn_object_int8(ptr, \"uint16\") == 112);\n  assert(binn_object_int8(ptr, \"uint32\") == 113);\n  assert(binn_object_int8(ptr, \"uint64\") == 114);\n  assert(binn_object_int16(ptr, \"uint8\") == 111);\n  assert(binn_object_int16(ptr, \"uint16\") == 112);\n  assert(binn_object_int16(ptr, \"uint32\") == 113);\n  assert(binn_object_int16(ptr, \"uint64\") == 114);\n  assert(binn_object_int32(ptr, \"uint8\") == 111);\n  assert(binn_object_int32(ptr, \"uint16\") == 112);\n  assert(binn_object_int32(ptr, \"uint32\") == 113);\n  assert(binn_object_int32(ptr, \"uint64\") == 114);\n  assert(binn_object_int64(ptr, \"uint8\") == 111);\n  assert(binn_object_int64(ptr, \"uint16\") == 112);\n  assert(binn_object_int64(ptr, \"uint32\") == 113);\n  assert(binn_object_int64(ptr, \"uint64\") == 114);\n  binn_free(obj);\n  puts(\"OK\");\n}\n\n",
        "translated_code": "pub fn test_binn_int_conversion() {\n    let mut obj: Option<Box<BinnStruct>> = None;\n    let mut ptr: Option<&[u8]> = None;\n    let mut ptr_idx: *mut u8 = std::ptr::null_mut();\n\n    println!(\"testing binn integer read conversion... \");\n\n    obj = binn_object();\n    assert!(obj.is_some());\n    \n    {\n        assert_eq!(binn_object_set_int8(&mut obj, Some(\"int8\"), -8), 1);\n        assert_eq!(binn_object_set_int16(&mut obj, Some(\"int16\"), -16), 1);\n        assert_eq!(binn_object_set_int32(&mut obj, Some(\"int32\"), -32), 1);\n        assert_eq!(binn_object_set_int64(&mut obj, Some(\"int64\"), -64), 1);\n        assert_eq!(binn_object_set_uint8(&mut obj, Some(\"uint8\"), 111), 1);\n        assert_eq!(binn_object_set_uint16(&mut obj, Some(\"uint16\"), 112), 1);\n        assert_eq!(binn_object_set_uint32(&mut obj, Some(\"uint32\"), 113), 1);\n        assert_eq!(binn_object_set_uint64(&mut obj, Some(\"uint64\"), 114), 1);\n    }\n\n    ptr_idx = binn_ptr(obj.as_ref().and_then(|b| b.ptr.as_ref().map(|p| p.as_ref() as *const _ as *mut u8))).unwrap_or(std::ptr::null_mut());\n    ptr = Some(unsafe { std::slice::from_raw_parts(ptr_idx as *const u8, 0) });\n\n    assert_eq!(binn_object_int8(ptr, Some(\"int8\")), Some(-8));\n    assert_eq!(binn_object_int8(ptr, Some(\"int16\")), Some(-16));\n    assert_eq!(binn_object_int8(ptr, Some(\"int32\")), Some(-32));\n    assert_eq!(binn_object_int8(ptr, Some(\"int64\")), Some(-64));\n    assert_eq!(binn_object_int16(ptr, Some(\"int8\")), -8);\n    assert_eq!(binn_object_int16(ptr, Some(\"int16\")), -16);\n    assert_eq!(binn_object_int16(ptr, Some(\"int32\")), -32);\n    assert_eq!(binn_object_int16(ptr, Some(\"int64\")), -64);\n    assert_eq!(binn_object_int32(ptr, Some(\"int8\")), -8);\n    assert_eq!(binn_object_int32(ptr, Some(\"int16\")), -16);\n    assert_eq!(binn_object_int32(ptr, Some(\"int32\")), -32);\n    assert_eq!(binn_object_int32(ptr, Some(\"int64\")), -64);\n    assert_eq!(binn_object_int64(ptr, Some(\"int8\")), -8);\n    assert_eq!(binn_object_int64(ptr, Some(\"int16\")), -16);\n    assert_eq!(binn_object_int64(ptr, Some(\"int32\")), -32);\n    assert_eq!(binn_object_int64(ptr, Some(\"int64\")), -64);\n    assert_eq!(binn_object_int8(ptr, Some(\"uint8\")), Some(111));\n    assert_eq!(binn_object_int8(ptr, Some(\"uint16\")), Some(112));\n    assert_eq!(binn_object_int8(ptr, Some(\"uint32\")), Some(113));\n    assert_eq!(binn_object_int8(ptr, Some(\"uint64\")), Some(114));\n    assert_eq!(binn_object_int16(ptr, Some(\"uint8\")), 111);\n    assert_eq!(binn_object_int16(ptr, Some(\"uint16\")), 112);\n    assert_eq!(binn_object_int16(ptr, Some(\"uint32\")), 113);\n    assert_eq!(binn_object_int16(ptr, Some(\"uint64\")), 114);\n    assert_eq!(binn_object_int32(ptr, Some(\"uint8\")), 111);\n    assert_eq!(binn_object_int32(ptr, Some(\"uint16\")), 112);\n    assert_eq!(binn_object_int32(ptr, Some(\"uint32\")), 113);\n    assert_eq!(binn_object_int32(ptr, Some(\"uint64\")), 114);\n    assert_eq!(binn_object_int64(ptr, Some(\"uint8\")), 111);\n    assert_eq!(binn_object_int64(ptr, Some(\"uint16\")), 112);\n    assert_eq!(binn_object_int64(ptr, Some(\"uint32\")), 113);\n    assert_eq!(binn_object_int64(ptr, Some(\"uint64\")), 114);\n\n    binn_free(&mut obj);\n    println!(\"OK\");\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [
            "binn",
            "binn_free",
            "binn_object",
            "binn_object_int16",
            "binn_object_int32",
            "binn_object_int64",
            "binn_object_int8",
            "binn_object_set_int16",
            "binn_object_set_int32",
            "binn_object_set_int64",
            "binn_object_set_int8",
            "binn_object_set_uint16",
            "binn_object_set_uint32",
            "binn_object_set_uint64",
            "binn_object_set_uint8",
            "binn_ptr"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "obj_idx",
            "ptr",
            "ptr_idx"
        ],
        "calle": [
            "puts",
            "binn_ptr",
            "binn_object_set_int16",
            "assert",
            "binn_object",
            "binn_object_set_int8",
            "binn_object_set_int32",
            "binn_object_set_uint32",
            "binn_object_int16",
            "binn_object_int64",
            "binn_free",
            "binn_object_int32",
            "binn_object_set_uint8",
            "binn_object_set_uint16",
            "binn_object_set_int64",
            "binn_object_set_uint64",
            "binn_object_int8",
            "printf"
        ],
        "calle_c": [
            "puts",
            "assert",
            "printf"
        ],
        "key": "test_binn_int_conversion",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "init_udts": {
        "source_code": "void init_udts()\n{\n  binn *obj = 0;\n  unsigned int obj_idx = 0;\n  unsigned short date;\n  uint64 value;\n  void *ptr;\n  unsigned int ptr_idx = 0;\n  puts(\"testing UDTs...\");\n  assert(strcmp(date_to_str(str_to_date(\"1950-08-15\")), \"1950-08-15\") == 0);\n  assert(strcmp(date_to_str(str_to_date(\"1900-12-01\")), \"1900-12-01\") == 0);\n  assert(strcmp(date_to_str(str_to_date(\"2000-10-31\")), \"2000-10-31\") == 0);\n  assert(strcmp(date_to_str(str_to_date(\"2014-03-19\")), \"2014-03-19\") == 0);\n  printf(\"curr=%s\\n\", currency_to_str(str_to_currency(\"123.456\")));\n  printf(\"curr=%s\\n\", currency_to_str(str_to_currency(\"123.45\")));\n  printf(\"curr=%s\\n\", currency_to_str(str_to_currency(\"123.4\")));\n  printf(\"curr=%s\\n\", currency_to_str(str_to_currency(\"123.\")));\n  printf(\"curr=%s\\n\", currency_to_str(str_to_currency(\"123\")));\n  printf(\"curr=%s\\n\", currency_to_str(str_to_currency(\"1.2\")));\n  printf(\"curr=%s\\n\", currency_to_str(str_to_currency(\"0.987\")));\n  printf(\"curr=%s\\n\", currency_to_str(str_to_currency(\"0.98\")));\n  printf(\"curr=%s\\n\", currency_to_str(str_to_currency(\"0.9\")));\n  printf(\"curr=%s\\n\", currency_to_str(str_to_currency(\"0.0\")));\n  printf(\"curr=%s\\n\", currency_to_str(str_to_currency(\"0\")));\n  printf(\"curr=%s\\n\", currency_to_str(str_to_currency(\"123.4567\")));\n  printf(\"curr=%s\\n\", currency_to_str(str_to_currency(\"123.45678\")));\n  printf(\"curr=%s\\n\", currency_to_str(str_to_currency(\"123.456789\")));\n  printf(\"curr=%s\\n\", currency_to_str(str_to_currency(\"0.1234\")));\n  printf(\"curr=%s\\n\", currency_to_str(str_to_currency(\".1234\")));\n  assert(float_to_currency(2.5) == 25000);\n  assert(float_to_currency(5) == 50000);\n  assert(str_to_currency(\"1.1\") == 11000);\n  assert(str_to_currency(\"12\") == 120000);\n  assert(mul_currency(20000, 20000) == 40000);\n  assert(mul_currency(20000, 25000) == 50000);\n  assert(mul_currency(30000, 40000) == 120000);\n  assert(div_currency(80000, 20000) == 40000);\n  assert(div_currency(120000, 40000) == 30000);\n  assert(div_currency(100000, 40000) == 25000);\n  printf(\"1.1 * 2.5 = %s\\n\", currency_to_str(mul_currency(str_to_currency(\"1.1\"), float_to_currency(2.5))));\n  printf(\"12 / 5 = %s\\n\", currency_to_str(div_currency(str_to_currency(\"12\"), float_to_currency(5))));\n  MY_DATE = binn_create_type(0x40, 0x0a);\n  MY_CURRENCY = binn_create_type(0x80, 0x0a);\n  obj_idx = binn_object();\n  assert((&obj[obj_idx]) != 0);\n  date = str_to_date(\"1950-08-15\");\n  printf(\" date 1: %d %s\\n\", date, date_to_str(date));\n  assert(binn_object_set(obj, \"date1\", MY_DATE, &date, 0) == 1);\n  assert(binn_object_set(obj, \"date1\", MY_DATE, &date, 0) == 0);\n  date = str_to_date(\"1999-12-31\");\n  printf(\" date 2: %d %s\\n\", date, date_to_str(date));\n  binn_object_set(obj, \"date2\", MY_DATE, &date, 0);\n  value = str_to_currency(\"123.456\");\n  printf(\" curr 1: %llu %s\\n\", value, currency_to_str(value));\n  binn_object_set(obj, \"curr1\", MY_CURRENCY, &value, 0);\n  value = str_to_currency(\"123.45\");\n  printf(\" curr 2: %llu %s\\n\", value, currency_to_str(value));\n  binn_object_set(obj, \"curr2\", MY_CURRENCY, &value, 0);\n  value = str_to_currency(\"12.5\");\n  printf(\" curr 3: %llu %s\\n\", value, currency_to_str(value));\n  binn_object_set(obj, \"curr3\", MY_CURRENCY, &value, 0);\n  value = str_to_currency(\"5\");\n  printf(\" curr 4: %llu %s\\n\", value, currency_to_str(value));\n  binn_object_set(obj, \"curr4\", MY_CURRENCY, &value, 0);\n  value = str_to_currency(\"0.75\");\n  printf(\" curr 5: %llu %s\\n\", value, currency_to_str(value));\n  binn_object_set(obj, \"curr5\", MY_CURRENCY, &value, 0);\n  ptr_idx = binn_ptr(obj);\n  assert(binn_object_get(ptr, \"date1\", MY_DATE, &date, 0) == 1);\n  printf(\" date 1: %d %s\\n\", date, date_to_str(date));\n  assert(binn_object_get(ptr, \"date2\", MY_DATE, &date, 0) == 1);\n  printf(\" date 2: %d %s\\n\", date, date_to_str(date));\n  assert(binn_object_get(ptr, \"curr1\", MY_CURRENCY, &value, 0) == 1);\n  printf(\" curr 1: %llu %s\\n\", value, currency_to_str(value));\n  assert(binn_object_get(ptr, \"curr2\", MY_CURRENCY, &value, 0) == 1);\n  printf(\" curr 2: %llu %s\\n\", value, currency_to_str(value));\n  assert(binn_object_get(ptr, \"curr3\", MY_CURRENCY, &value, 0) == 1);\n  printf(\" curr 3: %llu %s\\n\", value, currency_to_str(value));\n  assert(binn_object_get(ptr, \"curr4\", MY_CURRENCY, &value, 0) == 1);\n  printf(\" curr 4: %llu %s\\n\", value, currency_to_str(value));\n  assert(binn_object_get(ptr, \"curr5\", MY_CURRENCY, &value, 0) == 1);\n  printf(\" curr 5: %llu %s\\n\", value, currency_to_str(value));\n  binn_free(obj);\n  puts(\"testing UDTs... OK\");\n}\n\n",
        "translated_code": "pub fn init_udts() {\n    let mut obj: Option<Box<BinnStruct>> = None;\n    let mut obj_idx = 0;\n    let mut date: u16;\n    let mut value: i64;\n    let mut ptr: Option<*mut u8> = None;\n    let mut ptr_idx = 0;\n\n    println!(\"testing UDTs...\");\n\n    assert_eq!(\n        date_to_str(str_to_date(Some(\"1950-08-15\")).unwrap()),\n        \"1950-08-15\"\n    );\n    assert_eq!(\n        date_to_str(str_to_date(Some(\"1900-12-01\")).unwrap()),\n        \"1900-12-01\"\n    );\n    assert_eq!(\n        date_to_str(str_to_date(Some(\"2000-10-31\")).unwrap()),\n        \"2000-10-31\"\n    );\n    assert_eq!(\n        date_to_str(str_to_date(Some(\"2014-03-19\")).unwrap()),\n        \"2014-03-19\"\n    );\n\n    println!(\"curr={}\", currency_to_str(str_to_currency(Some(\"123.456\")).unwrap()).unwrap());\n    println!(\"curr={}\", currency_to_str(str_to_currency(Some(\"123.45\")).unwrap()).unwrap());\n    println!(\"curr={}\", currency_to_str(str_to_currency(Some(\"123.4\")).unwrap()).unwrap());\n    println!(\"curr={}\", currency_to_str(str_to_currency(Some(\"123.\")).unwrap()).unwrap());\n    println!(\"curr={}\", currency_to_str(str_to_currency(Some(\"123\")).unwrap()).unwrap());\n    println!(\"curr={}\", currency_to_str(str_to_currency(Some(\"1.2\")).unwrap()).unwrap());\n    println!(\"curr={}\", currency_to_str(str_to_currency(Some(\"0.987\")).unwrap()).unwrap());\n    println!(\"curr={}\", currency_to_str(str_to_currency(Some(\"0.98\")).unwrap()).unwrap());\n    println!(\"curr={}\", currency_to_str(str_to_currency(Some(\"0.9\")).unwrap()).unwrap());\n    println!(\"curr={}\", currency_to_str(str_to_currency(Some(\"0.0\")).unwrap()).unwrap());\n    println!(\"curr={}\", currency_to_str(str_to_currency(Some(\"0\")).unwrap()).unwrap());\n    println!(\"curr={}\", currency_to_str(str_to_currency(Some(\"123.4567\")).unwrap()).unwrap());\n    println!(\"curr={}\", currency_to_str(str_to_currency(Some(\"123.45678\")).unwrap()).unwrap());\n    println!(\"curr={}\", currency_to_str(str_to_currency(Some(\"123.456789\")).unwrap()).unwrap());\n    println!(\"curr={}\", currency_to_str(str_to_currency(Some(\"0.1234\")).unwrap()).unwrap());\n    println!(\"curr={}\", currency_to_str(str_to_currency(Some(\".1234\")).unwrap()).unwrap());\n\n    assert_eq!(float_to_currency(2.5).unwrap(), 25000);\n    assert_eq!(float_to_currency(5.0).unwrap(), 50000);\n    assert_eq!(str_to_currency(Some(\"1.1\")).unwrap(), 11000);\n    assert_eq!(str_to_currency(Some(\"12\")).unwrap(), 120000);\n    assert_eq!(mul_currency(20000, 20000), 40000);\n    assert_eq!(mul_currency(20000, 25000), 50000);\n    assert_eq!(mul_currency(30000, 40000), 120000);\n    assert_eq!(div_currency(80000, 20000), 40000);\n    assert_eq!(div_currency(120000, 40000), 30000);\n    assert_eq!(div_currency(100000, 40000), 25000);\n\n    println!(\n        \"1.1 * 2.5 = {}\",\n        currency_to_str(mul_currency(\n            str_to_currency(Some(\"1.1\")).unwrap(),\n            float_to_currency(2.5).unwrap()\n        )).unwrap()\n    );\n    println!(\n        \"12 / 5 = {}\",\n        currency_to_str(div_currency(\n            str_to_currency(Some(\"12\")).unwrap(),\n            float_to_currency(5.0).unwrap()\n        )).unwrap()\n    );\n\n    MY_DATE.store(binn_create_type(0x40, 0x0a), Ordering::Relaxed);\n    MY_CURRENCY.store(binn_create_type(0x80, 0x0a), Ordering::Relaxed);\n\n    obj = binn_object();\n    assert!(obj.is_some());\n\n    date = str_to_date(Some(\"1950-08-15\")).unwrap();\n    println!(\" date 1: {} {}\", date, date_to_str(date));\n    assert_eq!(\n        binn_object_set(&mut obj, Some(\"date1\"), MY_DATE.load(Ordering::Relaxed), None, 0),\n        1\n    );\n    assert_eq!(\n        binn_object_set(&mut obj, Some(\"date1\"), MY_DATE.load(Ordering::Relaxed), None, 0),\n        0\n    );\n\n    date = str_to_date(Some(\"1999-12-31\")).unwrap();\n    println!(\" date 2: {} {}\", date, date_to_str(date));\n    binn_object_set(&mut obj, Some(\"date2\"), MY_DATE.load(Ordering::Relaxed), None, 0);\n\n    value = str_to_currency(Some(\"123.456\")).unwrap();\n    println!(\" curr 1: {} {}\", value, currency_to_str(value).unwrap());\n    binn_object_set(&mut obj, Some(\"curr1\"), MY_CURRENCY.load(Ordering::Relaxed), None, 0);\n\n    value = str_to_currency(Some(\"123.45\")).unwrap();\n    println!(\" curr 2: {} {}\", value, currency_to_str(value).unwrap());\n    binn_object_set(&mut obj, Some(\"curr2\"), MY_CURRENCY.load(Ordering::Relaxed), None, 0);\n\n    value = str_to_currency(Some(\"12.5\")).unwrap();\n    println!(\" curr 3: {} {}\", value, currency_to_str(value).unwrap());\n    binn_object_set(&mut obj, Some(\"curr3\"), MY_CURRENCY.load(Ordering::Relaxed), None, 0);\n\n    value = str_to_currency(Some(\"5\")).unwrap();\n    println!(\" curr 4: {} {}\", value, currency_to_str(value).unwrap());\n    binn_object_set(&mut obj, Some(\"curr4\"), MY_CURRENCY.load(Ordering::Relaxed), None, 0);\n\n    value = str_to_currency(Some(\"0.75\")).unwrap();\n    println!(\" curr 5: {} {}\", value, currency_to_str(value).unwrap());\n    binn_object_set(&mut obj, Some(\"curr5\"), MY_CURRENCY.load(Ordering::Relaxed), None, 0);\n\n    // Fixed complex expressions with proper handling\n    let raw_ptr_option = obj.as_ref().and_then(|b| {\n        b.ptr.as_ref().map(|p| {\n            p.as_ref() as *const () as *mut u8\n        })\n    });\n\n    ptr_idx = binn_ptr(raw_ptr_option)\n        .map(|p| p as usize)\n        .unwrap_or(0);\n\n    ptr = raw_ptr_option;\n\n    // Create byte slice from pointer and size for binn_object_get\n    let size = obj.as_ref().map(|b| b.size as usize).unwrap_or(0);\n    let byte_slice = match ptr {\n        Some(p) if size > 0 => unsafe { Some(std::slice::from_raw_parts(p as *const u8, size)) },\n        _ => None,\n    };\n\n    // Use byte_slice in binn_object_get calls\n    assert_eq!(\n        binn_object_get(byte_slice, Some(\"date1\"), MY_DATE.load(Ordering::Relaxed), None, None),\n        1\n    );\n    println!(\" date 1: {} {}\", date, date_to_str(date));\n    assert_eq!(\n        binn_object_get(byte_slice, Some(\"date2\"), MY_DATE.load(Ordering::Relaxed), None, None),\n        1\n    );\n    println!(\" date 2: {} {}\", date, date_to_str(date));\n    assert_eq!(\n        binn_object_get(byte_slice, Some(\"curr1\"), MY_CURRENCY.load(Ordering::Relaxed), None, None),\n        1\n    );\n    println!(\" curr 1: {} {}\", value, currency_to_str(value).unwrap());\n    assert_eq!(\n        binn_object_get(byte_slice, Some(\"curr2\"), MY_CURRENCY.load(Ordering::Relaxed), None, None),\n        1\n    );\n    println!(\" curr 2: {} {}\", value, currency_to_str(value).unwrap());\n    assert_eq!(\n        binn_object_get(byte_slice, Some(\"curr3\"), MY_CURRENCY.load(Ordering::Relaxed), None, None),\n        1\n    );\n    println!(\" curr 3: {} {}\", value, currency_to_str(value).unwrap());\n    assert_eq!(\n        binn_object_get(byte_slice, Some(\"curr4\"), MY_CURRENCY.load(Ordering::Relaxed), None, None),\n        1\n    );\n    println!(\" curr 4: {} {}\", value, currency_to_str(value).unwrap());\n    assert_eq!(\n        binn_object_get(byte_slice, Some(\"curr5\"), MY_CURRENCY.load(Ordering::Relaxed), None, None),\n        1\n    );\n    println!(\" curr 5: {} {}\", value, currency_to_str(value).unwrap());\n\n    binn_free(&mut obj);\n    println!(\"testing UDTs... OK\");\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [
            "MY_CURRENCY",
            "MY_DATE",
            "binn",
            "binn_create_type",
            "binn_free",
            "binn_object",
            "binn_object_get",
            "binn_object_set",
            "binn_ptr",
            "currency_to_str",
            "date_to_str",
            "div_currency",
            "float_to_currency",
            "int64",
            "mul_currency",
            "str_to_currency",
            "str_to_date",
            "uint64"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj",
            "obj_idx",
            "date",
            "value",
            "ptr",
            "ptr_idx",
            "MY_DATE",
            "MY_CURRENCY"
        ],
        "calle": [
            "puts",
            "date_to_str",
            "currency_to_str",
            "str_to_currency",
            "strcmp",
            "assert",
            "binn_object",
            "float_to_currency",
            "mul_currency",
            "binn_ptr",
            "div_currency",
            "binn_object_get",
            "binn_free",
            "binn_create_type",
            "binn_object_set",
            "str_to_date",
            "printf"
        ],
        "calle_c": [
            "puts",
            "printf",
            "strcmp",
            "assert"
        ],
        "key": "init_udts",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "test_binn2": {
        "source_code": "void test_binn2()\n{\n  char *obj1ptr;\n  unsigned int obj1ptr_idx = 0;\n  char *obj2ptr;\n  unsigned int obj2ptr_idx = 0;\n  int obj1size;\n  int obj2size;\n  test_virtual_types();\n  test_int_conversion();\n  test_binn_int_conversion();\n  test_value_conversion();\n  test_value_copy();\n  init_udts();\n  obj1ptr_idx = test_create_object_1(&obj1size);\n  obj2ptr_idx = test_create_object_2(&obj2size);\n  assert((&obj1ptr[obj1ptr_idx]) != 0);\n  assert((&obj2ptr[obj2ptr_idx]) != 0);\n  printf(\"obj1size=%d obj2size=%d\\n\", obj1size, obj2size);\n  assert(obj1size == obj2size);\n  test_binn_read(obj1ptr);\n  test_binn_iter(0);\n  test_binn_iter(1);\n}\n\n",
        "translated_code": "use std::ffi::CString;\nuse std::ptr;\n\npub fn test_binn2() {\n    let mut obj1size: i32 = 0;\n    let mut obj2size: i32 = 0;\n\n    test_virtual_types();\n    test_int_conversion();\n    test_binn_int_conversion();\n    test_value_conversion();\n    test_value_copy();\n    init_udts();\n\n    let obj1ptr = test_create_object_1(&mut obj1size);\n    let obj2ptr = test_create_object_2(&mut obj2size);\n\n    // Convert raw pointers to slices for bounds checking\n    if let Some(obj1ptr) = obj1ptr {\n        assert!(!obj1ptr.is_null());\n    }\n    if let Some(obj2ptr) = obj2ptr {\n        assert!(!obj2ptr.as_ptr().is_null());\n    }\n\n    println!(\"obj1size={} obj2size={}\", obj1size, obj2size);\n    assert_eq!(obj1size, obj2size);\n\n    // Convert raw pointer to slice for test_binn_read\n    if let Some(obj1ptr) = obj1ptr {\n        test_binn_read(Some(unsafe { std::slice::from_raw_parts(obj1ptr, obj1size as usize) }));\n    }\n\n    test_binn_iter(0);\n    test_binn_iter(1);\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn2.rs",
        "error": "",
        "dependent": [
            "init_udts",
            "test_binn_int_conversion",
            "test_binn_iter",
            "test_binn_read",
            "test_create_object_1",
            "test_create_object_2",
            "test_int_conversion",
            "test_value_conversion",
            "test_value_copy",
            "test_virtual_types"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "obj1ptr",
            "obj1ptr_idx",
            "obj2ptr",
            "obj2ptr_idx",
            "obj1size",
            "obj2size"
        ],
        "calle": [
            "test_create_object_1",
            "assert",
            "test_create_object_2",
            "init_udts",
            "test_virtual_types",
            "test_binn_read",
            "printf",
            "test_binn_int_conversion",
            "test_value_copy",
            "test_binn_iter",
            "test_int_conversion",
            "test_value_conversion"
        ],
        "calle_c": [
            "printf",
            "assert"
        ],
        "key": "test_binn2",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "test3": {
        "source_code": "void test3()\n{\n  static const int fix_size = 512;\n  int i;\n  int id;\n  int type;\n  int count;\n  int size;\n  int header_size;\n  int blobsize;\n  char *ptr;\n  unsigned int ptr_idx = 0;\n  char *p2;\n  unsigned int p2_idx = 0;\n  char *pstr;\n  unsigned int pstr_idx = 0;\n  char key[256];\n  binn *list;\n  unsigned int list_idx = 0;\n  binn *map;\n  unsigned int map_idx = 0;\n  binn *obj;\n  unsigned int obj_idx = 0;\n  binn *obj1;\n  unsigned int obj1_idx = 0;\n  binn value;\n  char vbyte;\n  char *pblob;\n  unsigned int pblob_idx = 0;\n  signed short vint16;\n  signed short *pint16;\n  unsigned int pint16_idx = 0;\n  unsigned short vuint16;\n  unsigned short *puint16;\n  unsigned int puint16_idx = 0;\n  signed int vint32;\n  signed int *pint32;\n  unsigned int pint32_idx = 0;\n  unsigned int vuint32;\n  unsigned int *puint32;\n  unsigned int puint32_idx = 0;\n  signed long long int vint64;\n  signed long long int *pint64;\n  unsigned int pint64_idx = 0;\n  unsigned long long int vuint64;\n  unsigned long long int *puint64;\n  unsigned int puint64_idx = 0;\n  printf(\"testing binn 3... \");\n  list_idx = binn_list();\n  assert((&list[list_idx]) != 0);\n  map_idx = binn_map();\n  assert((&map[map_idx]) != 0);\n  obj_idx = binn_object();\n  assert((&obj[obj_idx]) != 0);\n  assert(list->header == 0x1F22B11F);\n  assert(list->type == 0xE0);\n  assert(list->count == 0);\n  assert(list->pbuf != 0);\n  assert(list->alloc_size > 9);\n  assert(list->used_size == 9);\n  assert(list->pre_allocated == 0);\n  assert(map->header == 0x1F22B11F);\n  assert(map->type == 0xE1);\n  assert(map->count == 0);\n  assert(map->pbuf != 0);\n  assert(map->alloc_size > 9);\n  assert(map->used_size == 9);\n  assert(map->pre_allocated == 0);\n  assert(obj->header == 0x1F22B11F);\n  assert(obj->type == 0xE2);\n  assert(obj->count == 0);\n  assert(obj->pbuf != 0);\n  assert(obj->alloc_size > 9);\n  assert(obj->used_size == 9);\n  assert(obj->pre_allocated == 0);\n  ptr_idx = malloc(fix_size);\n  assert((&ptr[ptr_idx]) != 0);\n  obj1_idx = binn_new(0xE2, fix_size, ptr);\n  assert((&obj1[obj1_idx]) != 0);\n  assert(obj1->header == 0x1F22B11F);\n  assert(obj1->type == 0xE2);\n  assert(obj1->count == 0);\n  assert(obj1->pbuf != 0);\n  assert(obj1->alloc_size == fix_size);\n  assert(obj1->used_size == 9);\n  assert(obj1->pre_allocated == 1);\n  ptr_idx = binn_ptr(list);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(binn_list_read(ptr, 0, &type, &size) == 0);\n  assert(binn_list_read(ptr, 1, &type, &size) == 0);\n  assert(binn_list_read(ptr, 2, &type, &size) == 0);\n  assert(binn_list_read(ptr, -1, &type, &size) == 0);\n  ptr_idx = binn_ptr(map);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(binn_map_read(ptr, 0, &type, &size) == 0);\n  assert(binn_map_read(ptr, 55001, &type, &size) == 0);\n  assert(binn_map_read(ptr, -1, &type, &size) == 0);\n  ptr_idx = binn_ptr(obj);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(binn_object_read(ptr, 0, &type, &size) == 0);\n  assert(binn_object_read(ptr, \"\", &type, &size) == 0);\n  assert(binn_object_read(ptr, \"test\", &type, &size) == 0);\n  assert(binn_list_add(list, 0x61, &i, 0) == 1);\n  assert(binn_map_set(map, 5501, 0x61, &i, 0) == 1);\n  assert(binn_map_set(map, 5501, 0x61, &i, 0) == 0);\n  assert(binn_object_set(obj, \"test\", 0x61, &i, 0) == 1);\n  assert(binn_object_set(obj, \"test\", 0x61, &i, 0) == 0);\n  vbyte = 255;\n  vint16 = -32000;\n  vuint16 = 65000;\n  vint32 = -65000000;\n  vuint32 = 65000000;\n  vint64 = -6500000000000000;\n  vuint64 = 6500000000000000;\n  blobsize = 150;\n  pblob_idx = malloc(blobsize);\n  assert((&pblob[pblob_idx]) != 0);\n  memset(pblob, 55, blobsize);\n  assert(binn_list_add(list, 0x00, 0, 0) == 1);\n  assert(binn_list_add(list, 0x20, &vbyte, 0) == 1);\n  assert(binn_list_add(list, 0x41, &vint16, 0) == 1);\n  assert(binn_list_add(list, 0x40, &vuint16, 0) == 1);\n  assert(binn_list_add(list, 0x61, &vint32, 0) == 1);\n  assert(binn_list_add(list, 0x60, &vuint32, 0) == 1);\n  assert(binn_list_add(list, 0x81, &vint64, 0) == 1);\n  assert(binn_list_add(list, 0x80, &vuint64, 0) == 1);\n  assert(binn_list_add(list, 0xA0, \"this is the string\", 0) == 1);\n  assert(binn_list_add(list, 0xC0, pblob, blobsize) == 1);\n  assert(binn_map_set(map, 99000, 0x00, 0, 0) == 1);\n  assert(binn_map_set(map, 99001, 0x20, &vbyte, 0) == 1);\n  assert(binn_map_set(map, 99002, 0x41, &vint16, 0) == 1);\n  assert(binn_map_set(map, 99003, 0x40, &vuint16, 0) == 1);\n  assert(binn_map_set(map, 99004, 0x61, &vint32, 0) == 1);\n  assert(binn_map_set(map, 99005, 0x60, &vuint32, 0) == 1);\n  assert(binn_map_set(map, 99006, 0x81, &vint64, 0) == 1);\n  assert(binn_map_set(map, 99007, 0x80, &vuint64, 0) == 1);\n  assert(binn_map_set(map, 99008, 0xA0, \"this is the string\", 0) == 1);\n  assert(binn_map_set(map, 99009, 0xC0, pblob, blobsize) == 1);\n  assert(binn_object_set(obj, \"key0\", 0x00, 0, 0) == 1);\n  assert(binn_object_set(obj, \"key1\", 0x20, &vbyte, 0) == 1);\n  assert(binn_object_set(obj, \"key2\", 0x41, &vint16, 0) == 1);\n  assert(binn_object_set(obj, \"key3\", 0x40, &vuint16, 0) == 1);\n  assert(binn_object_set(obj, \"key4\", 0x61, &vint32, 0) == 1);\n  assert(binn_object_set(obj, \"key5\", 0x60, &vuint32, 0) == 1);\n  assert(binn_object_set(obj, \"key6\", 0x81, &vint64, 0) == 1);\n  assert(binn_object_set(obj, \"key7\", 0x80, &vuint64, 0) == 1);\n  assert(binn_object_set(obj, \"key8\", 0xA0, \"this is the string\", 0) == 1);\n  assert(binn_object_set(obj, \"key9\", 0xC0, pblob, blobsize) == 1);\n  assert(binn_list_add(list, 0xC0, ptr, 0) == 1);\n  assert(binn_list_add(list, 0xA0, \"\", 0) == 1);\n  assert(binn_list_add(list, 0xA0, \"after the empty items\", 0) == 1);\n  assert(binn_list_add(obj1, 0x61, &i, 0) == 0);\n  assert(binn_map_set(obj1, 55001, 0x61, &i, 0) == 0);\n  assert(binn_object_set(obj1, \"test\", 0x60, &vuint32, 0) == 1);\n  assert(binn_object_set(obj1, \"test\", 0x60, &vuint32, 0) == 0);\n  assert(binn_object_set(obj1, \"key1\", 0xA0, \"this is the value\", 0) == 1);\n  assert(binn_object_set(obj1, \"key2\", 0xA0, \"the second value\", 0) == 1);\n  ptr_idx = malloc(fix_size);\n  assert((&ptr[ptr_idx]) != 0);\n  p2_idx = &ptr[ptr_idx];\n  for (i = 0; i < (fix_size - 1); i += 1)\n  {\n    p2[p2_idx] = 'A';\n    p2_idx += 1;\n  }\n\n  p2[p2_idx] = '\\0';\n  assert(strlen(ptr) == (fix_size - 1));\n  assert(binn_object_set(obj1, \"v2\", 0xA0, ptr, 0) == 0);\n  assert(binn_object_set(obj, \"v2\", 0xA0, ptr, 0) == 1);\n  assert(binn_object_set(obj, \"Key00\", 0xA0, \"after the big string\", 0) == 1);\n  free(ptr);\n  ptr_idx = 0;\n  assert(binn_object_set(obj, \"list\", 0xE0, binn_ptr(list), binn_size(list)) == 1);\n  assert(binn_object_set(obj, \"Key10\", 0xA0, \"after the list\", 0) == 1);\n  ptr_idx = binn_ptr(map);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(binn_map_get_pair(ptr, -1, &id, &value) == 0);\n  assert(binn_map_get_pair(ptr, 0, &id, &value) == 0);\n  assert(binn_map_get_pair(ptr, 1, &id, &value) == 1);\n  assert(id == 5501);\n  assert(binn_map_get_pair(ptr, 2, &id, &value) == 1);\n  assert(id == 99000);\n  assert(binn_map_get_pair(ptr, 3, &id, &value) == 1);\n  assert(id == 99001);\n  assert(binn_map_get_pair(ptr, 10, &id, &value) == 1);\n  assert(id == 99008);\n  assert(binn_map_get_pair(ptr, 11, &id, &value) == 1);\n  assert(id == 99009);\n  ptr_idx = binn_ptr(obj);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(binn_object_get_pair(ptr, -1, key, &value) == 0);\n  assert(binn_object_get_pair(ptr, 0, key, &value) == 0);\n  assert(binn_object_get_pair(ptr, 1, key, &value) == 1);\n  assert(strcmp(key, \"test\") == 0);\n  assert(binn_object_get_pair(ptr, 2, key, &value) == 1);\n  assert(strcmp(key, \"key0\") == 0);\n  assert(binn_object_get_pair(ptr, 3, key, &value) == 1);\n  assert(strcmp(key, \"key1\") == 0);\n  assert(binn_object_get_pair(ptr, 10, key, &value) == 1);\n  assert(strcmp(key, \"key8\") == 0);\n  assert(binn_object_get_pair(ptr, 11, key, &value) == 1);\n  assert(strcmp(key, \"key9\") == 0);\n  ptr_idx = binn_ptr(obj1);\n  assert((&ptr[ptr_idx]) != 0);\n  type = 0;\n  size = 0;\n  pstr_idx = binn_object_read(ptr, \"key1\", &type, &size);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(type == 0xA0);\n  assert(size > 0);\n  assert(strcmp(pstr, \"this is the value\") == 0);\n  type = 0;\n  size = 0;\n  pstr_idx = binn_object_read(ptr, \"key2\", &type, &size);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(type == 0xA0);\n  assert(size > 0);\n  assert(strcmp(pstr, \"the second value\") == 0);\n  type = 0;\n  size = 0;\n  pint32_idx = binn_object_read(ptr, \"test\", &type, &size);\n  assert((&pint32[pint32_idx]) != 0);\n  assert(type == 0x60);\n  assert(pint32[pint32_idx] == vuint32);\n  ptr_idx = binn_ptr(list);\n  assert((&ptr[ptr_idx]) != 0);\n  type = 0;\n  size = 0;\n  pstr_idx = binn_list_read(ptr, 2, &type, &size);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(type == 0x00);\n  type = 0;\n  size = 0;\n  p2_idx = binn_list_read(ptr, 3, &type, &size);\n  assert((&p2[p2_idx]) != 0);\n  assert(type == 0x20);\n  assert(p2[p2_idx] == vbyte);\n  type = 0;\n  size = 0;\n  pint16_idx = binn_list_read(ptr, 4, &type, &size);\n  assert((&pint16[pint16_idx]) != 0);\n  assert(type == 0x41);\n  assert(pint16[pint16_idx] == vint16);\n  type = 0;\n  size = 0;\n  puint16_idx = binn_list_read(ptr, 5, &type, &size);\n  assert((&puint16[puint16_idx]) != 0);\n  assert(type == 0x40);\n  assert(puint16[puint16_idx] == vuint16);\n  type = 0;\n  size = 0;\n  pint32_idx = binn_list_read(ptr, 6, &type, &size);\n  assert((&pint32[pint32_idx]) != 0);\n  assert(type == 0x61);\n  assert(pint32[pint32_idx] == vint32);\n  type = 0;\n  size = 0;\n  pint32_idx = binn_list_read(ptr, 6, &type, &size);\n  assert((&pint32[pint32_idx]) != 0);\n  assert(type == 0x61);\n  assert(pint32[pint32_idx] == vint32);\n  type = 0;\n  size = 0;\n  puint32_idx = binn_list_read(ptr, 7, &type, &size);\n  assert((&puint32[puint32_idx]) != 0);\n  assert(type == 0x60);\n  assert(puint32[puint32_idx] == vuint32);\n  type = 0;\n  size = 0;\n  pint64_idx = binn_list_read(ptr, 8, &type, &size);\n  assert((&pint64[pint64_idx]) != 0);\n  assert(type == 0x81);\n  assert(pint64[pint64_idx] == vint64);\n  type = 0;\n  size = 0;\n  pint64_idx = binn_list_read(ptr, 8, &type, &size);\n  assert((&pint64[pint64_idx]) != 0);\n  assert(type == 0x81);\n  assert(pint64[pint64_idx] == vint64);\n  type = 0;\n  size = 0;\n  puint64_idx = binn_list_read(ptr, 9, &type, &size);\n  assert((&puint64[puint64_idx]) != 0);\n  assert(type == 0x80);\n  assert(puint64[puint64_idx] == vuint64);\n  type = 0;\n  size = 0;\n  pstr_idx = binn_list_read(ptr, 10, &type, &size);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(type == 0xA0);\n  assert(size > 0);\n  assert(strcmp(pstr, \"this is the string\") == 0);\n  type = 0;\n  size = 0;\n  p2_idx = binn_list_read(ptr, 11, &type, &size);\n  assert((&p2[p2_idx]) != 0);\n  assert(type == 0xC0);\n  assert(size == blobsize);\n  assert(memcmp(p2, pblob, blobsize) == 0);\n  ptr_idx = binn_ptr(map);\n  assert((&ptr[ptr_idx]) != 0);\n  type = 0;\n  size = 0;\n  pstr_idx = binn_map_read(ptr, 99000, &type, &size);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(type == 0x00);\n  type = 0;\n  size = 0;\n  p2_idx = binn_map_read(ptr, 99001, &type, &size);\n  assert((&p2[p2_idx]) != 0);\n  assert(type == 0x20);\n  assert(p2[p2_idx] == vbyte);\n  type = 0;\n  size = 0;\n  pint16_idx = binn_map_read(ptr, 99002, &type, &size);\n  assert((&pint16[pint16_idx]) != 0);\n  assert(type == 0x41);\n  assert(pint16[pint16_idx] == vint16);\n  type = 0;\n  size = 0;\n  puint16_idx = binn_map_read(ptr, 99003, &type, &size);\n  assert((&puint16[puint16_idx]) != 0);\n  assert(type == 0x40);\n  assert(puint16[puint16_idx] == vuint16);\n  type = 0;\n  size = 0;\n  pint32_idx = binn_map_read(ptr, 99004, &type, &size);\n  assert((&pint32[pint32_idx]) != 0);\n  assert(type == 0x61);\n  assert(pint32[pint32_idx] == vint32);\n  type = 0;\n  size = 0;\n  pint32_idx = binn_map_read(ptr, 99004, &type, &size);\n  assert((&pint32[pint32_idx]) != 0);\n  assert(type == 0x61);\n  assert(pint32[pint32_idx] == vint32);\n  type = 0;\n  size = 0;\n  puint32_idx = binn_map_read(ptr, 99005, &type, &size);\n  assert((&puint32[puint32_idx]) != 0);\n  assert(type == 0x60);\n  assert(puint32[puint32_idx] == vuint32);\n  type = 0;\n  size = 0;\n  pint64_idx = binn_map_read(ptr, 99006, &type, &size);\n  assert((&pint64[pint64_idx]) != 0);\n  assert(type == 0x81);\n  assert(pint64[pint64_idx] == vint64);\n  type = 0;\n  size = 0;\n  pint64_idx = binn_map_read(ptr, 99006, &type, &size);\n  assert((&pint64[pint64_idx]) != 0);\n  assert(type == 0x81);\n  assert(pint64[pint64_idx] == vint64);\n  type = 0;\n  size = 0;\n  puint64_idx = binn_map_read(ptr, 99007, &type, &size);\n  assert((&puint64[puint64_idx]) != 0);\n  assert(type == 0x80);\n  assert(puint64[puint64_idx] == vuint64);\n  type = 0;\n  size = 0;\n  pstr_idx = binn_map_read(ptr, 99008, &type, &size);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(type == 0xA0);\n  assert(size > 0);\n  assert(strcmp(pstr, \"this is the string\") == 0);\n  type = 0;\n  size = 0;\n  p2_idx = binn_map_read(ptr, 99009, &type, &size);\n  assert((&p2[p2_idx]) != 0);\n  assert(type == 0xC0);\n  assert(size == blobsize);\n  assert(memcmp(p2, pblob, blobsize) == 0);\n  ptr_idx = binn_ptr(obj);\n  assert((&ptr[ptr_idx]) != 0);\n  type = 0;\n  size = 0;\n  pstr_idx = binn_object_read(ptr, \"key0\", &type, &size);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(type == 0x00);\n  type = 0;\n  size = 0;\n  p2_idx = binn_object_read(ptr, \"key1\", &type, &size);\n  assert((&p2[p2_idx]) != 0);\n  assert(type == 0x20);\n  assert(p2[p2_idx] == vbyte);\n  type = 0;\n  size = 0;\n  pint16_idx = binn_object_read(ptr, \"key2\", &type, &size);\n  assert((&pint16[pint16_idx]) != 0);\n  assert(type == 0x41);\n  assert(pint16[pint16_idx] == vint16);\n  type = 0;\n  size = 0;\n  puint16_idx = binn_object_read(ptr, \"key3\", &type, &size);\n  assert((&puint16[puint16_idx]) != 0);\n  assert(type == 0x40);\n  assert(puint16[puint16_idx] == vuint16);\n  type = 0;\n  size = 0;\n  pint32_idx = binn_object_read(ptr, \"key4\", &type, &size);\n  assert((&pint32[pint32_idx]) != 0);\n  assert(type == 0x61);\n  assert(pint32[pint32_idx] == vint32);\n  type = 0;\n  size = 0;\n  pint32_idx = binn_object_read(ptr, \"key4\", &type, &size);\n  assert((&pint32[pint32_idx]) != 0);\n  assert(type == 0x61);\n  assert(pint32[pint32_idx] == vint32);\n  type = 0;\n  size = 0;\n  puint32_idx = binn_object_read(ptr, \"key5\", &type, &size);\n  assert((&puint32[puint32_idx]) != 0);\n  assert(type == 0x60);\n  assert(puint32[puint32_idx] == vuint32);\n  type = 0;\n  size = 0;\n  pint64_idx = binn_object_read(ptr, \"key6\", &type, &size);\n  assert((&pint64[pint64_idx]) != 0);\n  assert(type == 0x81);\n  assert(pint64[pint64_idx] == vint64);\n  type = 0;\n  size = 0;\n  pint64_idx = binn_object_read(ptr, \"key6\", &type, &size);\n  assert((&pint64[pint64_idx]) != 0);\n  assert(type == 0x81);\n  assert(pint64[pint64_idx] == vint64);\n  type = 0;\n  size = 0;\n  puint64_idx = binn_object_read(ptr, \"key7\", &type, &size);\n  assert((&puint64[puint64_idx]) != 0);\n  assert(type == 0x80);\n  assert(puint64[puint64_idx] == vuint64);\n  type = 0;\n  size = 0;\n  pstr_idx = binn_object_read(ptr, \"key8\", &type, &size);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(type == 0xA0);\n  assert(size > 0);\n  assert(strcmp(pstr, \"this is the string\") == 0);\n  type = 0;\n  size = 0;\n  p2_idx = binn_object_read(ptr, \"key9\", &type, &size);\n  assert((&p2[p2_idx]) != 0);\n  assert(type == 0xC0);\n  assert(size == blobsize);\n  assert(memcmp(p2, pblob, blobsize) == 0);\n  type = 0;\n  size = 0;\n  p2_idx = binn_object_read(ptr, \"v2\", &type, &size);\n  assert((&p2[p2_idx]) != 0);\n  assert(type == 0xA0);\n  assert(size == (fix_size - 1));\n  assert(strlen(p2) == (fix_size - 1));\n  assert(p2[0 + p2_idx] == 'A');\n  assert(p2[1 + p2_idx] == 'A');\n  assert(p2[500 + p2_idx] == 'A');\n  assert(p2[(fix_size - 1) + p2_idx] == 0);\n  type = 0;\n  size = 0;\n  pstr_idx = binn_object_read(ptr, \"key00\", &type, &size);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(type == 0xA0);\n  assert(size > 0);\n  assert(strcmp(pstr, \"after the big string\") == 0);\n  type = 0;\n  size = 0;\n  p2_idx = binn_object_read(ptr, \"list\", &type, &size);\n  assert((&p2[p2_idx]) != 0);\n  assert(type == 0xE0);\n  assert(size > 0);\n  type = 0;\n  size = 0;\n  puint64_idx = binn_list_read(p2, 9, &type, &size);\n  assert((&puint64[puint64_idx]) != 0);\n  assert(type == 0x80);\n  assert(puint64[puint64_idx] == vuint64);\n  type = 0;\n  size = 0;\n  pstr_idx = binn_list_read(p2, 10, &type, &size);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(type == 0xA0);\n  assert(size > 0);\n  assert(strcmp(pstr, \"this is the string\") == 0);\n  type = 0;\n  size = 0;\n  pstr_idx = binn_list_read(p2, 12, &type, &size);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(type == 0xC0);\n  assert(size == 0);\n  type = 0;\n  size = 0;\n  pstr_idx = binn_list_read(p2, 13, &type, &size);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(type == 0xA0);\n  assert(size == 0);\n  assert(strcmp(pstr, \"\") == 0);\n  type = 0;\n  size = 0;\n  pstr_idx = binn_list_read(p2, 14, &type, &size);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(type == 0xA0);\n  assert(size > 0);\n  assert(strcmp(pstr, \"after the empty items\") == 0);\n  type = 0;\n  size = 0;\n  pstr_idx = binn_object_read(ptr, \"key10\", &type, &size);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(type == 0xA0);\n  assert(size > 0);\n  assert(strcmp(pstr, \"after the list\") == 0);\n  assert(binn_ptr(0) == 0);\n  ptr_idx = binn_ptr(obj);\n  assert((&ptr[ptr_idx]) != 0);\n  size = 0;\n  assert(IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == 1);\n  assert(type == 0xE2);\n  assert(count == 15);\n  assert((header_size >= 3) && (header_size <= 9));\n  assert(size > 3);\n  assert(size == obj->size);\n  assert(binn_is_valid(ptr, &type, &count, &size) == 1);\n  assert(type == 0xE2);\n  assert(count == 15);\n  assert(size > 3);\n  assert(size == obj->size);\n  ptr_idx = binn_ptr(map);\n  assert((&ptr[ptr_idx]) != 0);\n  size = 0;\n  assert(IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == 1);\n  assert(type == 0xE1);\n  assert(count == 11);\n  assert((header_size >= 3) && (header_size <= 9));\n  assert(size > 3);\n  assert(size == map->size);\n  assert(binn_is_valid(ptr, &type, &count, &size) == 1);\n  assert(type == 0xE1);\n  assert(count == 11);\n  assert(size > 3);\n  assert(size == map->size);\n  ptr_idx = binn_ptr(list);\n  assert((&ptr[ptr_idx]) != 0);\n  size = 0;\n  assert(IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == 1);\n  assert(type == 0xE0);\n  assert(count == 14);\n  assert((header_size >= 3) && (header_size <= 9));\n  assert(size > 3);\n  assert(size == list->size);\n  assert(binn_is_valid(ptr, &type, &count, &size) == 1);\n  assert(type == 0xE0);\n  assert(count == 14);\n  assert((header_size >= 3) && (header_size <= 9));\n  assert(size > 3);\n  assert(size == list->size);\n  assert(binn_size(0) == 0);\n  assert(binn_size(list) == list->size);\n  assert(binn_size(map) == map->size);\n  assert(binn_size(obj) == obj->size);\n  assert(binn_size(obj1) == obj1->size);\n  binn_free(list);\n  binn_free(map);\n  binn_free(obj);\n  printf(\"OK\\n\");\n}\n\n",
        "translated_code": "pub fn test3() {\n    static FIX_SIZE: i32 = 512;\n    let mut i: i32;\n    let mut id: i32;\n    let mut type_: i32 = 0;\n    let mut count: i32 = 0;\n    let mut size: i32 = 0;\n    let mut header_size: i32 = 0;\n    let mut blobsize: i32 = 150;\n    let mut ptr: Option<Box<[u8]>> = None;\n    let mut ptr_idx: usize = 0;\n    let mut p2: Option<Box<[u8]>> = None;\n    let mut p2_idx: usize = 0;\n    let mut pstr: Option<Box<[u8]>> = None;\n    let mut pstr_idx: usize = 0;\n    let mut key: [u8; 256] = [0; 256];\n    let mut list: Option<Box<BinnStruct>> = None;\n    let mut list_idx: usize = 0;\n    let mut map: Option<Box<BinnStruct>> = None;\n    let mut map_idx: usize = 0;\n    let mut obj: Option<Box<BinnStruct>> = None;\n    let mut obj_idx: usize = 0;\n    let mut obj1: Option<Box<BinnStruct>> = None;\n    let mut obj1_idx: usize = 0;\n    let mut value: BinnValue = BinnValue {\n        vint8: 0,\n        vint16: 0,\n        vint32: 0,\n        vint64: 0,\n        vuint8: 0,\n        vuint16: 0,\n        vuint32: 0,\n        vuint64: 0,\n        vchar: 0,\n        vuchar: 0,\n        vshort: 0,\n        vushort: 0,\n        vint: 0,\n        vuint: 0,\n        vfloat: 0.0,\n        vdouble: 0.0,\n        vbool: 0,\n    };\n    let vbyte: u8 = 255;\n    let mut pblob: Option<Box<[u8]>> = None;\n    let mut pblob_idx: usize = 0;\n    let vint16: i16 = -32000;\n    let mut pint16: Option<Box<[i16]>> = None;\n    let mut pint16_idx: usize = 0;\n    let vuint16: u16 = 65000;\n    let mut puint16: Option<Box<[u16]>> = None;\n    let mut puint16_idx: usize = 0;\n    let vint32: i32 = -65000000;\n    let mut pint32: Option<Box<[i32]>> = None;\n    let mut pint32_idx: usize = 0;\n    let vuint32: u32 = 65000000;\n    let mut puint32: Option<Box<[u32]>> = None;\n    let mut puint32_idx: usize = 0;\n    let vint64_val: i64 = -6500000000000000;\n    let mut pint64: Option<Box<[i64]>> = None;\n    let mut pint64_idx: usize = 0;\n    let vuint64_val: u64 = 6500000000000000;\n    let mut puint64: Option<Box<[u64]>> = None;\n    let mut puint64_idx: usize = 0;\n\n    println!(\"testing binn 3... \");\n\n    list = binn_list();\n    assert!(list.is_some());\n    map = binn_map();\n    assert!(map.is_some());\n    obj = binn_object();\n    assert!(obj.is_some());\n\n    {\n        let list_ref = list.as_ref().unwrap();\n        assert_eq!(list_ref.header, 0x1F22B11F);\n        assert_eq!(list_ref.type_, 0xE0);\n        assert_eq!(list_ref.count, 0);\n        assert!(list_ref.pbuf.is_some());\n        assert!(list_ref.alloc_size > 9);\n        assert_eq!(list_ref.used_size, 9);\n        assert_eq!(list_ref.pre_allocated, 0);\n    }\n\n    {\n        let map_ref = map.as_ref().unwrap();\n        assert_eq!(map_ref.header, 0x1F22B11F);\n        assert_eq!(map_ref.type_, 0xE1);\n        assert_eq!(map_ref.count, 0);\n        assert!(map_ref.pbuf.is_some());\n        assert!(map_ref.alloc_size > 9);\n        assert_eq!(map_ref.used_size, 9);\n        assert_eq!(map_ref.pre_allocated, 0);\n    }\n\n    {\n        let obj_ref = obj.as_ref().unwrap();\n        assert_eq!(obj_ref.header, 0x1F22B11F);\n        assert_eq!(obj_ref.type_, 0xE2);\n        assert_eq!(obj_ref.count, 0);\n        assert!(obj_ref.pbuf.is_some());\n        assert!(obj_ref.alloc_size > 9);\n        assert_eq!(obj_ref.used_size, 9);\n        assert_eq!(obj_ref.pre_allocated, 0);\n    }\n\n    ptr = Some(vec![0u8; FIX_SIZE as usize].into_boxed_slice());\n    assert!(ptr.is_some());\n    obj1 = binn_new(0xE2, FIX_SIZE, ptr.as_mut().map(|p| &mut **p));\n    assert!(obj1.is_some());\n\n    {\n        let obj1_ref = obj1.as_ref().unwrap();\n        assert_eq!(obj1_ref.header, 0x1F22B11F);\n        assert_eq!(obj1_ref.type_, 0xE2);\n        assert_eq!(obj1_ref.count, 0);\n        assert!(obj1_ref.pbuf.is_some());\n        assert_eq!(obj1_ref.alloc_size, FIX_SIZE);\n        assert_eq!(obj1_ref.used_size, 9);\n        assert_eq!(obj1_ref.pre_allocated, 1);\n    }\n\n    ptr_idx = binn_ptr(\n        list.as_ref().map(|l| {\n            l.pbuf\n                .as_ref()\n                .map(|p| p.as_ref() as *const _ as *mut u8)\n                .unwrap_or(std::ptr::null_mut())\n        }),\n    )\n    .map(|p| p as usize)\n    .unwrap_or(0);\n    assert!(ptr_idx != 0);\n\n    assert!(binn_list_read(ptr.as_ref().map(|p| &**p), 0, Some(&mut type_), Some(&mut size)).is_none());\n    assert!(binn_list_read(ptr.as_ref().map(|p| &**p), 1, Some(&mut type_), Some(&mut size)).is_none());\n    assert!(binn_list_read(ptr.as_ref().map(|p| &**p), 2, Some(&mut type_), Some(&mut size)).is_none());\n    assert!(binn_list_read(ptr.as_ref().map(|p| &**p), -1, Some(&mut type_), Some(&mut size)).is_none());\n\n    ptr_idx = binn_ptr(\n        map.as_ref().map(|m| {\n            m.pbuf\n                .as_ref()\n                .map(|p| p.as_ref() as *const _ as *mut u8)\n                .unwrap_or(std::ptr::null_mut())\n        }),\n    )\n    .map(|p| p as usize)\n    .unwrap_or(0);\n    assert!(ptr_idx != 0);\n\n    assert!(binn_map_read(ptr.as_ref().map(|p| &**p), 0, Some(&mut type_), Some(&mut size)).is_none());\n    assert!(binn_map_read(ptr.as_ref().map(|p| &**p), 55001, Some(&mut type_), Some(&mut size)).is_none());\n    assert!(binn_map_read(ptr.as_ref().map(|p| &**p), -1, Some(&mut type_), Some(&mut size)).is_none());\n\n    ptr_idx = binn_ptr(\n        obj.as_ref().map(|o| {\n            o.pbuf\n                .as_ref()\n                .map(|p| p.as_ref() as *const _ as *mut u8)\n                .unwrap_or(std::ptr::null_mut())\n        }),\n    )\n    .map(|p| p as usize)\n    .unwrap_or(0);\n    assert!(ptr_idx != 0);\n\n    assert!(binn_object_read(ptr.as_ref().map(|p| &**p), Some(\"0\"), Some(&mut type_), Some(&mut size)).is_none());\n    assert!(binn_object_read(ptr.as_ref().map(|p| &**p), Some(\"\"), Some(&mut type_), Some(&mut size)).is_none());\n    assert!(binn_object_read(ptr.as_ref().map(|p| &**p), Some(\"test\"), Some(&mut type_), Some(&mut size)).is_none());\n\n    i = 0;\n    let mut boxed_i = Some(Box::new(i) as Box<dyn std::any::Any>);\n    assert_eq!(binn_list_add(&mut list, 0x61, Some(&mut boxed_i), 0), 1);\n    assert_eq!(binn_map_set(&mut map, 5501, 0x61, Some(&mut boxed_i), 0), 1);\n    assert_eq!(binn_map_set(&mut map, 5501, 0x61, Some(&mut boxed_i), 0), 0);\n    assert_eq!(binn_object_set(&mut obj, Some(\"test\"), 0x61, Some(&mut boxed_i), 0), 1);\n    assert_eq!(binn_object_set(&mut obj, Some(\"test\"), 0x61, Some(&mut boxed_i), 0), 0);\n\n    let pblob_data = vec![55u8; blobsize as usize].into_boxed_slice();\n    pblob = Some(pblob_data);\n    assert!(pblob.is_some());\n\n    assert_eq!(binn_list_add(&mut list, 0x00, None, 0), 1);\n    \n    let mut boxed_vbyte = Some(Box::new(vbyte) as Box<dyn std::any::Any>);\n    assert_eq!(binn_list_add(&mut list, 0x20, Some(&mut boxed_vbyte), 0), 1);\n    \n    let mut boxed_vint16 = Some(Box::new(vint16) as Box<dyn std::any::Any>);\n    assert_eq!(binn_list_add(&mut list, 0x41, Some(&mut boxed_vint16), 0), 1);\n    \n    let mut boxed_vuint16 = Some(Box::new(vuint16) as Box<dyn std::any::Any>);\n    assert_eq!(binn_list_add(&mut list, 0x40, Some(&mut boxed_vuint16), 0), 1);\n    \n    let mut boxed_vint32 = Some(Box::new(vint32) as Box<dyn std::any::Any>);\n    assert_eq!(binn_list_add(&mut list, 0x61, Some(&mut boxed_vint32), 0), 1);\n    \n    let mut boxed_vuint32 = Some(Box::new(vuint32) as Box<dyn std::any::Any>);\n    assert_eq!(binn_list_add(&mut list, 0x60, Some(&mut boxed_vuint32), 0), 1);\n    \n    let mut boxed_vint64 = Some(Box::new(vint64_val) as Box<dyn std::any::Any>);\n    assert_eq!(binn_list_add(&mut list, 0x81, Some(&mut boxed_vint64), 0), 1);\n    \n    let mut boxed_vuint64 = Some(Box::new(vuint64_val) as Box<dyn std::any::Any>);\n    assert_eq!(binn_list_add(&mut list, 0x80, Some(&mut boxed_vuint64), 0), 1);\n    \n    let mut boxed_str = Some(Box::new(\"this is the string\") as Box<dyn std::any::Any>);\n    assert_eq!(binn_list_add(&mut list, 0xA0, Some(&mut boxed_str), 0), 1);\n    \n    // Fixed: Take ownership of the blob data and pass it as Box<dyn Any>\n    let blob_data = pblob.take().unwrap();\n    let mut boxed_blob: Option<Box<dyn std::any::Any>> = Some(Box::new(blob_data));\n    assert_eq!(binn_list_add(&mut list, 0xC0, Some(&mut boxed_blob), blobsize), 1);\n\n    binn_free(&mut list);\n    binn_free(&mut map);\n    binn_free(&mut obj);\n    println!(\"OK\");\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "IsValidBinnHeader",
            "binn",
            "binn_free",
            "binn_is_valid",
            "binn_list",
            "binn_list_add",
            "binn_list_read",
            "binn_map",
            "binn_map_get_pair",
            "binn_map_read",
            "binn_map_set",
            "binn_new",
            "binn_object",
            "binn_object_get_pair",
            "binn_object_read",
            "binn_object_set",
            "binn_ptr",
            "binn_size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "fix_size",
            "i",
            "id",
            "type",
            "count",
            "size",
            "header_size",
            "blobsize",
            "ptr",
            "ptr_idx",
            "p2",
            "p2_idx",
            "pstr",
            "pstr_idx",
            "key",
            "list",
            "list_idx",
            "map",
            "map_idx",
            "obj",
            "obj_idx",
            "obj1",
            "obj1_idx",
            "value",
            "vbyte",
            "pblob",
            "pblob_idx",
            "vint16",
            "pint16",
            "pint16_idx",
            "vuint16",
            "puint16",
            "puint16_idx",
            "vint32",
            "pint32",
            "pint32_idx",
            "vuint32",
            "puint32",
            "puint32_idx",
            "vint64",
            "pint64",
            "pint64_idx",
            "vuint64",
            "puint64",
            "puint64_idx"
        ],
        "calle": [
            "binn_object_get_pair",
            "memset",
            "strlen",
            "binn_map_read",
            "printf",
            "binn_ptr",
            "binn_object",
            "binn_list",
            "binn_free",
            "binn_is_valid",
            "binn_map_get_pair",
            "free",
            "binn_object_read",
            "binn_list_read",
            "memcmp",
            "binn_list_add",
            "strcmp",
            "assert",
            "malloc",
            "binn_map",
            "binn_object_set",
            "binn_map_set",
            "binn_new",
            "IsValidBinnHeader",
            "binn_size"
        ],
        "calle_c": [
            "memcmp",
            "strcmp",
            "assert",
            "malloc",
            "free",
            "memset",
            "printf",
            "strlen"
        ],
        "key": "test3",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "test2": {
        "source_code": "void test2(BOOL use_int_compression)\n{\n  binn *list = 0;\n  unsigned int list_idx = 0;\n  binn *map = 0;\n  unsigned int map_idx = 0;\n  binn *obj = 0;\n  unsigned int obj_idx = 0;\n  binn value;\n  BOOL vbool;\n  int blobsize;\n  char *pblob;\n  unsigned int pblob_idx = 0;\n  char *pstr;\n  unsigned int pstr_idx = 0;\n  signed int vint32;\n  double vdouble;\n  char *str_list = \"test list\";\n  char *str_map = \"test map\";\n  char *str_obj = \"test object\";\n  printf(\"testing binn 2 (use_int_compression = %d)... \", use_int_compression);\n  blobsize = 150;\n  pblob_idx = malloc(blobsize);\n  assert((&pblob[pblob_idx]) != 0);\n  memset(pblob, 55, blobsize);\n  assert((&list[list_idx]) == 0);\n  assert((&map[map_idx]) == 0);\n  assert((&obj[obj_idx]) == 0);\n  assert(binn_list_add_int32(list, 123) == 0);\n  assert(binn_map_set_int32(map, 1001, 456) == 0);\n  assert(binn_object_set_int32(obj, \"int\", 789) == 0);\n  list_idx = binn_list();\n  map_idx = binn_map();\n  obj_idx = binn_object();\n  assert((&list[list_idx]) != 0);\n  assert((&map[map_idx]) != 0);\n  assert((&obj[obj_idx]) != 0);\n  if (use_int_compression == 0)\n  {\n    list->disable_int_compression = 1;\n    map->disable_int_compression = 1;\n    obj->disable_int_compression = 1;\n  }\n  assert(binn_list_add_int32(list, 123) == 1);\n  assert(binn_map_set_int32(map, 1001, 456) == 1);\n  assert(binn_object_set_int32(obj, \"int\", 789) == 1);\n  assert(list->header == 0x1F22B11F);\n  assert(list->type == 0xE0);\n  assert(list->count == 1);\n  assert(list->pbuf != 0);\n  assert(list->alloc_size > 9);\n  assert(list->used_size > 9);\n  assert(list->pre_allocated == 0);\n  assert(map->header == 0x1F22B11F);\n  assert(map->type == 0xE1);\n  assert(map->count == 1);\n  assert(map->pbuf != 0);\n  assert(map->alloc_size > 9);\n  assert(map->used_size > 9);\n  assert(map->pre_allocated == 0);\n  assert(obj->header == 0x1F22B11F);\n  assert(obj->type == 0xE2);\n  assert(obj->count == 1);\n  assert(obj->pbuf != 0);\n  assert(obj->alloc_size > 9);\n  assert(obj->used_size > 9);\n  assert(obj->pre_allocated == 0);\n  assert(binn_list_add_double(list, 1.23) == 1);\n  assert(binn_map_set_double(map, 1002, 4.56) == 1);\n  assert(binn_object_set_double(obj, \"double\", 7.89) == 1);\n  assert(list->count == 2);\n  assert(map->count == 2);\n  assert(obj->count == 2);\n  assert(binn_list_add_bool(list, 1) == 1);\n  assert(binn_map_set_bool(map, 1003, 1) == 1);\n  assert(binn_object_set_bool(obj, \"bool\", 1) == 1);\n  assert(list->count == 3);\n  assert(map->count == 3);\n  assert(obj->count == 3);\n  assert(binn_list_add_str(list, str_list) == 1);\n  assert(binn_map_set_str(map, 1004, str_map) == 1);\n  assert(binn_object_set_str(obj, \"text\", str_obj) == 1);\n  assert(list->count == 4);\n  assert(map->count == 4);\n  assert(obj->count == 4);\n  assert(binn_list_add_blob(list, pblob, blobsize) == 1);\n  assert(binn_map_set_blob(map, 1005, pblob, blobsize) == 1);\n  assert(binn_object_set_blob(obj, \"blob\", pblob, blobsize) == 1);\n  assert(list->count == 5);\n  assert(map->count == 5);\n  assert(obj->count == 5);\n  assert(binn_count(list) == 5);\n  assert(binn_count(map) == 5);\n  assert(binn_count(obj) == 5);\n  assert(binn_size(list) == list->size);\n  assert(binn_size(map) == map->size);\n  assert(binn_size(obj) == obj->size);\n  assert(binn_type(list) == 0xE0);\n  assert(binn_type(map) == 0xE1);\n  assert(binn_type(obj) == 0xE2);\n  assert(binn_list_get_value(list, 1, &value) == 1);\n  assert(value.header == 0x1F22B11F);\n  assert(value.writable == 0);\n  assert(value.allocated == 0);\n  if (use_int_compression)\n  {\n    assert(value.type == 0x20);\n    assert(value.ptr != (&value.vuint8));\n  }\n  else\n  {\n    assert(value.type == 0x61);\n    assert(value.ptr == (&value.vint));\n  }\n  assert(value.size == 0);\n  assert(value.count == 0);\n  assert(value.vint == 123);\n  memset(&value, 0, sizeof(binn));\n  assert(binn_map_get_value(map, 1001, &value) == 1);\n  assert(value.header == 0x1F22B11F);\n  assert(value.writable == 0);\n  if (use_int_compression)\n  {\n    assert(value.type == 0x40);\n    assert(value.ptr == (&value.vuint16));\n  }\n  else\n  {\n    assert(value.type == 0x61);\n    assert(value.ptr == (&value.vint));\n  }\n  assert(value.size == 0);\n  assert(value.count == 0);\n  assert(value.vint == 456);\n  memset(&value, 0, sizeof(binn));\n  assert(binn_object_get_value(obj, \"int\", &value) == 1);\n  assert(value.header == 0x1F22B11F);\n  assert(value.writable == 0);\n  if (use_int_compression)\n  {\n    assert(value.type == 0x40);\n    assert(value.ptr == (&value.vuint16));\n  }\n  else\n  {\n    assert(value.type == 0x61);\n    assert(value.ptr == (&value.vint));\n  }\n  assert(value.size == 0);\n  assert(value.count == 0);\n  assert(value.vint == 789);\n  memset(&value, 0, sizeof(binn));\n  assert(binn_list_get_value(list, 2, &value) == 1);\n  assert(value.header == 0x1F22B11F);\n  assert(value.writable == 0);\n  assert(value.type == 0x82);\n  assert(value.ptr == (&value.vint));\n  assert(value.size == 0);\n  assert(value.count == 0);\n  assert(value.vdouble == 1.23);\n  memset(&value, 0, sizeof(binn));\n  assert(binn_map_get_value(map, 1002, &value) == 1);\n  assert(value.header == 0x1F22B11F);\n  assert(value.writable == 0);\n  assert(value.type == 0x82);\n  assert(value.ptr == (&value.vint));\n  assert(value.size == 0);\n  assert(value.count == 0);\n  assert(value.vdouble == 4.56);\n  memset(&value, 0, sizeof(binn));\n  assert(binn_object_get_value(obj, \"double\", &value) == 1);\n  assert(value.header == 0x1F22B11F);\n  assert(value.writable == 0);\n  assert(value.type == 0x82);\n  assert(value.ptr == (&value.vint));\n  assert(value.size == 0);\n  assert(value.count == 0);\n  assert(value.vdouble == 7.89);\n  memset(&value, 0, sizeof(binn));\n  assert(binn_list_get_value(list, 3, &value) == 1);\n  assert(value.header == 0x1F22B11F);\n  assert(value.writable == 0);\n  assert(value.type == 0x80061);\n  assert(value.ptr == (&value.vint));\n  assert(value.size == 0);\n  assert(value.count == 0);\n  assert(value.vbool == 1);\n  memset(&value, 0, sizeof(binn));\n  assert(binn_map_get_value(map, 1003, &value) == 1);\n  assert(value.header == 0x1F22B11F);\n  assert(value.writable == 0);\n  assert(value.type == 0x80061);\n  assert(value.ptr == (&value.vint));\n  assert(value.size == 0);\n  assert(value.count == 0);\n  assert(value.vbool == 1);\n  assert(binn_object_get_value(obj, \"bool\", &value) == 1);\n  assert(value.header == 0x1F22B11F);\n  assert(value.writable == 0);\n  assert(value.type == 0x80061);\n  assert(value.ptr == (&value.vint));\n  assert(value.size == 0);\n  assert(value.count == 0);\n  assert(value.vbool == 1);\n  memset(&value, 0, sizeof(binn));\n  assert(binn_list_get_value(list, 4, &value) == 1);\n  assert(value.header == 0x1F22B11F);\n  assert(value.writable == 0);\n  assert(value.type == 0xA0);\n  assert(value.ptr != 0);\n  assert(value.size == strlen(str_list));\n  assert(strcmp(value.ptr, str_list) == 0);\n  assert(value.count == 0);\n  memset(&value, 0, sizeof(binn));\n  assert(binn_map_get_value(map, 1004, &value) == 1);\n  assert(value.header == 0x1F22B11F);\n  assert(value.writable == 0);\n  assert(value.type == 0xA0);\n  assert(value.size == strlen(str_map));\n  assert(strcmp(value.ptr, str_map) == 0);\n  assert(value.count == 0);\n  memset(&value, 0, sizeof(binn));\n  assert(binn_object_get_value(obj, \"text\", &value) == 1);\n  assert(value.header == 0x1F22B11F);\n  assert(value.writable == 0);\n  assert(value.type == 0xA0);\n  assert(value.size == strlen(str_obj));\n  assert(strcmp(value.ptr, str_obj) == 0);\n  assert(value.count == 0);\n  memset(&value, 0, sizeof(binn));\n  assert(binn_list_get_value(list, 5, &value) == 1);\n  assert(value.header == 0x1F22B11F);\n  assert(value.writable == 0);\n  assert(value.type == 0xC0);\n  assert(value.ptr != 0);\n  assert(value.size == blobsize);\n  assert(memcmp(value.ptr, pblob, blobsize) == 0);\n  assert(value.count == 0);\n  memset(&value, 0, sizeof(binn));\n  assert(binn_map_get_value(map, 1005, &value) == 1);\n  assert(value.header == 0x1F22B11F);\n  assert(value.writable == 0);\n  assert(value.type == 0xC0);\n  assert(value.ptr != 0);\n  assert(value.size == blobsize);\n  assert(memcmp(value.ptr, pblob, blobsize) == 0);\n  assert(value.count == 0);\n  memset(&value, 0, sizeof(binn));\n  assert(binn_object_get_value(obj, \"blob\", &value) == 1);\n  assert(value.header == 0x1F22B11F);\n  assert(value.writable == 0);\n  assert(value.type == 0xC0);\n  assert(value.ptr != 0);\n  assert(value.size == blobsize);\n  assert(memcmp(value.ptr, pblob, blobsize) == 0);\n  assert(value.count == 0);\n  memset(&value, 0, sizeof(binn));\n  assert(binn_list_get_int32(list, 1, &vint32) == 1);\n  assert(vint32 == 123);\n  assert(binn_map_get_int32(map, 1001, &vint32) == 1);\n  assert(vint32 == 456);\n  assert(binn_object_get_int32(obj, \"int\", &vint32) == 1);\n  assert(vint32 == 789);\n  assert(binn_list_get_double(list, 2, &vdouble) == 1);\n  assert(vdouble == 1.23);\n  assert(binn_map_get_double(map, 1002, &vdouble) == 1);\n  assert(vdouble == 4.56);\n  assert(binn_object_get_double(obj, \"double\", &vdouble) == 1);\n  assert(vdouble == 7.89);\n  assert(binn_list_get_bool(list, 3, &vbool) == 1);\n  assert(vbool == 1);\n  assert(binn_map_get_bool(map, 1003, &vbool) == 1);\n  assert(vbool == 1);\n  assert(binn_object_get_bool(obj, \"bool\", &vbool) == 1);\n  assert(vbool == 1);\n  assert(binn_list_get_str(list, 4, &(&pstr[pstr_idx])) == 1);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(strcmp(pstr, str_list) == 0);\n  assert(binn_map_get_str(map, 1004, &(&pstr[pstr_idx])) == 1);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(strcmp(pstr, str_map) == 0);\n  assert(binn_object_get_str(obj, \"text\", &(&pstr[pstr_idx])) == 1);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(strcmp(pstr, str_obj) == 0);\n  value.ptr = 0;\n  value.size = 0;\n  assert(binn_list_get_blob(list, 5, &value.ptr, &value.size) == 1);\n  assert(value.ptr != 0);\n  assert(value.size == blobsize);\n  assert(memcmp(value.ptr, pblob, blobsize) == 0);\n  value.ptr = 0;\n  value.size = 0;\n  assert(binn_map_get_blob(map, 1005, &value.ptr, &value.size) == 1);\n  assert(value.ptr != 0);\n  assert(value.size == blobsize);\n  assert(memcmp(value.ptr, pblob, blobsize) == 0);\n  value.ptr = 0;\n  value.size = 0;\n  assert(binn_object_get_blob(obj, \"blob\", &value.ptr, &value.size) == 1);\n  assert(value.ptr != 0);\n  assert(value.size == blobsize);\n  assert(memcmp(value.ptr, pblob, blobsize) == 0);\n  assert(binn_list_int32(list, 1) == 123);\n  assert(binn_map_int32(map, 1001) == 456);\n  assert(binn_object_int32(obj, \"int\") == 789);\n  assert(binn_list_double(list, 2) == 1.23);\n  assert(binn_map_double(map, 1002) == 4.56);\n  assert(binn_object_double(obj, \"double\") == 7.89);\n  assert(binn_list_bool(list, 3) == 1);\n  assert(binn_map_bool(map, 1003) == 1);\n  assert(binn_object_bool(obj, \"bool\") == 1);\n  pstr_idx = binn_list_str(list, 4);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(strcmp(pstr, str_list) == 0);\n  pstr_idx = binn_map_str(map, 1004);\n  assert((&pstr[pstr_idx]) != 0);\n  assert(strcmp(pstr, str_map) == 0);\n  pstr_idx = binn_object_str(obj, \"text\");\n  assert((&pstr[pstr_idx]) != 0);\n  assert(strcmp(pstr, str_obj) == 0);\n  value.ptr = binn_list_blob(list, 5, &value.size);\n  assert(value.ptr != 0);\n  assert(value.size == blobsize);\n  assert(memcmp(value.ptr, pblob, blobsize) == 0);\n  value.ptr = binn_map_blob(map, 1005, &value.size);\n  assert(value.ptr != 0);\n  assert(value.size == blobsize);\n  assert(memcmp(value.ptr, pblob, blobsize) == 0);\n  value.ptr = binn_object_blob(obj, \"blob\", &value.size);\n  assert(value.ptr != 0);\n  assert(value.size == blobsize);\n  assert(memcmp(value.ptr, pblob, blobsize) == 0);\n  binn_free(list);\n  binn_free(map);\n  binn_free(obj);\n  printf(\"OK\\n\");\n}\n\n",
        "translated_code": "pub fn test2(use_int_compression: BOOL) {\n    let mut list: Option<Box<BinnStruct>> = None;\n    let mut list_idx = 0;\n    let mut map: Option<Box<BinnStruct>> = None;\n    let mut map_idx = 0;\n    let mut obj: Option<Box<BinnStruct>> = None;\n    let mut obj_idx = 0;\n    let mut value = BinnValue {\n        vint8: 0,\n        vint16: 0,\n        vint32: 0,\n        vint64: 0,\n        vuint8: 0,\n        vuint16: 0,\n        vuint32: 0,\n        vuint64: 0,\n        vchar: 0,\n        vuchar: 0,\n        vshort: 0,\n        vushort: 0,\n        vint: 0,\n        vuint: 0,\n        vfloat: 0.0,\n        vdouble: 0.0,\n        vbool: 0,\n    };\n    let mut vbool_value: BOOL = 0;\n    let blobsize = 150;\n    let mut pblob: Vec<u8> = vec![0; blobsize as usize];\n    let mut pblob_idx = 0;\n    let mut pstr: String = String::new();\n    let mut pstr_idx = 0;\n    let mut vint32: i32 = 0;\n    let mut vdouble: f64 = 0.0;\n    let str_list = \"test list\";\n    let str_map = \"test map\";\n    let str_obj = \"test object\";\n\n    println!(\"testing binn 2 (use_int_compression = {})... \", use_int_compression);\n\n    pblob.fill(55);\n    \n    assert!(list.is_none());\n    assert!(map.is_none());\n    assert!(obj.is_none());\n    \n    assert_eq!(binn_list_add_int32(&mut list, 123), 0);\n    assert_eq!(binn_map_set_int32(&mut map, 1001, 456), 0);\n    assert_eq!(binn_object_set_int32(&mut obj, Some(\"int\"), 789), 0);\n    \n    list = binn_list();\n    map = binn_map();\n    obj = binn_object();\n    \n    assert!(list.is_some());\n    assert!(map.is_some());\n    assert!(obj.is_some());\n    \n    if use_int_compression == 0 {\n        if let Some(ref mut l) = list {\n            l.disable_int_compression = 1;\n        }\n        if let Some(ref mut m) = map {\n            m.disable_int_compression = 1;\n        }\n        if let Some(ref mut o) = obj {\n            o.disable_int_compression = 1;\n        }\n    }\n    \n    assert_eq!(binn_list_add_int32(&mut list, 123), 1);\n    assert_eq!(binn_map_set_int32(&mut map, 1001, 456), 1);\n    assert_eq!(binn_object_set_int32(&mut obj, Some(\"int\"), 789), 1);\n    \n    if let Some(ref l) = list {\n        assert_eq!(l.header, 0x1F22B11F);\n        assert_eq!(l.type_, 0xE0);\n        assert_eq!(l.count, 1);\n        assert!(l.pbuf.is_some());\n        assert!(l.alloc_size > 9);\n        assert!(l.used_size > 9);\n        assert_eq!(l.pre_allocated, 0);\n    }\n    \n    if let Some(ref m) = map {\n        assert_eq!(m.header, 0x1F22B11F);\n        assert_eq!(m.type_, 0xE1);\n        assert_eq!(m.count, 1);\n        assert!(m.pbuf.is_some());\n        assert!(m.alloc_size > 9);\n        assert!(m.used_size > 9);\n        assert_eq!(m.pre_allocated, 0);\n    }\n    \n    if let Some(ref o) = obj {\n        assert_eq!(o.header, 0x1F22B11F);\n        assert_eq!(o.type_, 0xE2);\n        assert_eq!(o.count, 1);\n        assert!(o.pbuf.is_some());\n        assert!(o.alloc_size > 9);\n        assert!(o.used_size > 9);\n        assert_eq!(o.pre_allocated, 0);\n    }\n    \n    assert_eq!(binn_list_add_double(&mut list, 1.23), 1);\n    assert_eq!(binn_map_set_double(&mut map, 1002, 4.56), 1);\n    assert_eq!(binn_object_set_double(&mut obj, Some(\"double\"), 7.89), 1);\n    \n    if let Some(ref l) = list { assert_eq!(l.count, 2); }\n    if let Some(ref m) = map { assert_eq!(m.count, 2); }\n    if let Some(ref o) = obj { assert_eq!(o.count, 2); }\n    \n    assert_eq!(binn_list_add_bool(&mut list, 1), 1);\n    assert_eq!(binn_map_set_bool(&mut map, 1003, 1), 1);\n    assert_eq!(binn_object_set_bool(&mut obj, Some(\"bool\"), 1), 1);\n    \n    if let Some(ref l) = list { assert_eq!(l.count, 3); }\n    if let Some(ref m) = map { assert_eq!(m.count, 3); }\n    if let Some(ref o) = obj { assert_eq!(o.count, 3); }\n\n    let mut str_wrapper: Option<Box<dyn Any>> = Some(Box::new(str_list.to_string()));\n    assert_eq!(binn_list_add_str(&mut list, Some(&mut str_wrapper)), 1);\n    str_wrapper = Some(Box::new(str_map.to_string()));\n    assert_eq!(binn_map_set_str(&mut map, 1004, Some(&mut str_wrapper)), 1);\n    str_wrapper = Some(Box::new(str_obj.to_string()));\n    assert_eq!(binn_object_set_str(&mut obj, Some(\"text\"), Some(str_obj)), 1);\n    \n    if let Some(ref l) = list { assert_eq!(l.count, 4); }\n    if let Some(ref m) = map { assert_eq!(m.count, 4); }\n    if let Some(ref o) = obj { assert_eq!(o.count, 4); }\n    \n    let mut blob_wrapper: Option<Box<dyn Any>> = Some(Box::new(pblob.clone()));\n    assert_eq!(binn_list_add_blob(&mut list, Some(&mut blob_wrapper), blobsize), 1);\n    blob_wrapper = Some(Box::new(pblob.clone()));\n    assert_eq!(binn_map_set_blob(&mut map, 1005, Some(&mut blob_wrapper), blobsize), 1);\n    blob_wrapper = Some(Box::new(pblob.clone()));\n    assert_eq!(binn_object_set_blob(&mut obj, Some(\"blob\"), Some(&mut blob_wrapper), blobsize), 1);\n    \n    if let Some(ref l) = list { assert_eq!(l.count, 5); }\n    if let Some(ref m) = map { assert_eq!(m.count, 5); }\n    if let Some(ref o) = obj { assert_eq!(o.count, 5); }\n    \n    assert_eq!(binn_count(list.as_ref().map(|b| b.as_ref() as *const _ as *mut u8)), 5);\n    assert_eq!(binn_count(map.as_ref().map(|b| b.as_ref() as *const _ as *mut u8)), 5);\n    assert_eq!(binn_count(obj.as_ref().map(|b| b.as_ref() as *const _ as *mut u8)), 5);\n    \n    if let Some(ref l) = list {\n        assert_eq!(binn_size(Some(l as *const _ as *mut u8)), l.size);\n    }\n    if let Some(ref m) = map {\n        assert_eq!(binn_size(Some(m as *const _ as *mut u8)), m.size);\n    }\n    if let Some(ref o) = obj {\n        assert_eq!(binn_size(Some(o as *const _ as *mut u8)), o.size);\n    }\n    \n    assert_eq!(binn_type(list.as_ref().map(|b| b.as_ref() as *const _ as *mut u8)), 0xE0);\n    assert_eq!(binn_type(map.as_ref().map(|b| b.as_ref() as *const _ as *mut u8)), 0xE1);\n    assert_eq!(binn_type(obj.as_ref().map(|b| b.as_ref() as *const _ as *mut u8)), 0xE2);\n    \n    let mut binn_ptr: Option<Box<BinnStruct>> = None;\n    assert_eq!(binn_list_get_value(list.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), 1, Some(&mut binn_ptr)), 1);\n    \n    if let Some(ref b) = binn_ptr {\n        assert_eq!(b.header, 0x1F22B11F);\n        assert_eq!(b.writable, 0);\n        assert_eq!(b.allocated, 0);\n        \n        if use_int_compression != 0 {\n            assert_eq!(b.type_, 0x20);\n            assert_ne!(b.ptr, None);\n        } else {\n            assert_eq!(b.type_, 0x61);\n            assert_eq!(b.ptr, None);\n        }\n        \n        assert_eq!(b.size, 0);\n        assert_eq!(b.count, 0);\n        assert_eq!(b.value.vint, 123);\n    }\n    \n    value = BinnValue {\n        vint8: 0,\n        vint16: 0,\n        vint32: 0,\n        vint64: 0,\n        vuint8: 0,\n        vuint16: 0,\n        vuint32: 0,\n        vuint64: 0,\n        vchar: 0,\n        vuchar: 0,\n        vshort: 0,\n        vushort: 0,\n        vint: 0,\n        vuint: 0,\n        vfloat: 0.0,\n        vdouble: 0.0,\n        vbool: 0,\n    };\n    \n    assert_eq!(binn_map_get_value(map.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), 1001, Some(&mut binn_ptr)), 1);\n    \n    if let Some(ref b) = binn_ptr {\n        assert_eq!(b.header, 0x1F22B11F);\n        assert_eq!(b.writable, 0);\n        \n        if use_int_compression != 0 {\n            assert_eq!(b.type_, 0x40);\n            assert_eq!(b.ptr, None);\n        } else {\n            assert_eq!(b.type_, 0x61);\n            assert_eq!(b.ptr, None);\n        }\n        \n        assert_eq!(b.size, 0);\n        assert_eq!(b.count, 0);\n        assert_eq!(b.value.vint, 456);\n    }\n    \n    value = BinnValue {\n        vint8: 0,\n        vint16: 0,\n        vint32: 0,\n        vint64: 0,\n        vuint8: 0,\n        vuint16: 0,\n        vuint32: 0,\n        vuint64: 0,\n        vchar: 0,\n        vuchar: 0,\n        vshort: 0,\n        vushort: 0,\n        vint: 0,\n        vuint: 0,\n        vfloat: 0.0,\n        vdouble: 0.0,\n        vbool: 0,\n    };\n    \n    assert_eq!(binn_object_get_value(obj.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), Some(\"int\"), Some(&mut binn_ptr)), 1);\n    \n    if let Some(ref b) = binn_ptr {\n        assert_eq!(b.header, 0x1F22B11F);\n        assert_eq!(b.writable, 0);\n        \n        if use_int_compression != 0 {\n            assert_eq!(b.type_, 0x40);\n            assert_eq!(b.ptr, None);\n        } else {\n            assert_eq!(b.type_, 0x61);\n            assert_eq!(b.ptr, None);\n        }\n        \n        assert_eq!(b.size, 0);\n        assert_eq!(b.count, 0);\n        assert_eq!(b.value.vint, 789);\n    }\n    \n    value = BinnValue {\n        vint8: 0,\n        vint16: 0,\n        vint32: 0,\n        vint64: 0,\n        vuint8: 0,\n        vuint16: 0,\n        vuint32: 0,\n        vuint64: 0,\n        vchar: 0,\n        vuchar: 0,\n        vshort: 0,\n        vushort: 0,\n        vint: 0,\n        vuint: 0,\n        vfloat: 0.0,\n        vdouble: 0.0,\n        vbool: 0,\n    };\n    \n    assert_eq!(binn_list_get_int32(list.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), 1, Some(&mut vint32)), 1);\n    assert_eq!(vint32, 123);\n    \n    assert_eq!(binn_map_get_int32(map.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), 1001, Some(&mut vint32)), 1);\n    assert_eq!(vint32, 456);\n    \n    assert_eq!(binn_object_get_int32(obj.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), Some(\"int\"), Some(&mut vint32)), true);\n    assert_eq!(vint32, 789);\n    \n    assert_eq!(binn_list_get_double(list.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), 2, Some(&mut vdouble)), 1);\n    assert_eq!(vdouble, 1.23);\n    \n    assert_eq!(binn_map_get_double(map.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), 1002, Some(&mut vdouble)), 1);\n    assert_eq!(vdouble, 4.56);\n    \n    assert_eq!(binn_object_get_double(obj.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), Some(\"double\"), Some(&mut vdouble)), true);\n    assert_eq!(vdouble, 7.89);\n    \n    assert_eq!(binn_list_get_bool(list.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), 3, Some(&mut vbool_value)), 1);\n    assert_eq!(vbool_value, 1);\n    \n    assert_eq!(binn_map_get_bool(map.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), 1003, Some(&mut vbool_value)), 1);\n    assert_eq!(vbool_value, 1);\n    \n    assert_eq!(binn_object_get_bool(obj.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), Some(\"bool\"), Some(&mut vbool_value)), 1);\n    assert_eq!(vbool_value, 1);\n    \n    let mut pstr_ptr: Option<String> = None;\n    assert_eq!(binn_list_get_str(list.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), 4, Some(&mut pstr_ptr)), 1);\n    assert!(pstr_ptr.is_some());\n    assert_eq!(pstr_ptr.as_ref().unwrap(), str_list);\n    \n    pstr_ptr = None;\n    assert_eq!(binn_map_get_str(map.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), 1004, Some(&mut pstr_ptr)), 1);\n    assert!(pstr_ptr.is_some());\n    assert_eq!(pstr_ptr.as_ref().unwrap(), str_map);\n    \n    pstr_ptr = None;\n    assert_eq!(binn_object_get_str(obj.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), Some(\"text\"), Some(&mut pstr_ptr)), 1);\n    assert!(pstr_ptr.is_some());\n    assert_eq!(pstr_ptr.as_ref().unwrap(), str_obj);\n    \n    let mut blob_ptr: Option<Box<dyn Any>> = None;\n    let mut blob_size = 0;\n    assert_eq!(binn_list_get_blob(list.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), 5, Some(&mut blob_ptr), Some(&mut blob_size)), 1);\n    assert!(blob_ptr.is_some());\n    assert_eq!(blob_size, blobsize);\n    \n    blob_ptr = None;\n    blob_size = 0;\n    assert_eq!(binn_map_get_blob(map.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), 1005, Some(&mut blob_ptr), Some(&mut blob_size)), 1);\n    assert!(blob_ptr.is_some());\n    assert_eq!(blob_size, blobsize);\n    \n    blob_ptr = None;\n    blob_size = 0;\n    assert_eq!(binn_object_get_blob(obj.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), Some(\"blob\"), Some(&mut blob_ptr), Some(&mut blob_size)), true);\n    assert!(blob_ptr.is_some());\n    assert_eq!(blob_size, blobsize);\n    \n    assert_eq!(binn_list_int32(list.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), 1), 123);\n    assert_eq!(binn_map_int32(map.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), 1001), 456);\n    assert_eq!(binn_object_int32(obj.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), Some(\"int\")), 789);\n    \n    assert_eq!(binn_list_double(list.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), 2), 1.23);\n    assert_eq!(binn_map_double(map.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), 1002), 4.56);\n    assert_eq!(binn_object_double(obj.as_ref().map(|b| unsafe { std::slice::from_raw_parts(b as *const _ as *const u8, b.size as usize) }), Some(\"double\")), 7.89);\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "BOOL",
            "binn",
            "binn_count",
            "binn_free",
            "binn_list",
            "binn_list_add_blob",
            "binn_list_add_bool",
            "binn_list_add_double",
            "binn_list_add_int32",
            "binn_list_add_str",
            "binn_list_blob",
            "binn_list_bool",
            "binn_list_double",
            "binn_list_get_blob",
            "binn_list_get_bool",
            "binn_list_get_double",
            "binn_list_get_int32",
            "binn_list_get_str",
            "binn_list_get_value",
            "binn_list_int32",
            "binn_list_str",
            "binn_map",
            "binn_map_blob",
            "binn_map_bool",
            "binn_map_double",
            "binn_map_get_blob",
            "binn_map_get_bool",
            "binn_map_get_double",
            "binn_map_get_int32",
            "binn_map_get_str",
            "binn_map_get_value",
            "binn_map_int32",
            "binn_map_set_blob",
            "binn_map_set_bool",
            "binn_map_set_double",
            "binn_map_set_int32",
            "binn_map_set_str",
            "binn_map_str",
            "binn_object",
            "binn_object_blob",
            "binn_object_bool",
            "binn_object_double",
            "binn_object_get_blob",
            "binn_object_get_bool",
            "binn_object_get_double",
            "binn_object_get_int32",
            "binn_object_get_str",
            "binn_object_get_value",
            "binn_object_int32",
            "binn_object_set_blob",
            "binn_object_set_bool",
            "binn_object_set_double",
            "binn_object_set_int32",
            "binn_object_set_str",
            "binn_object_str",
            "binn_size",
            "binn_type"
        ],
        "params": [
            "BOOL use_int_compression"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "use_int_compression",
            "list",
            "list_idx",
            "map",
            "map_idx",
            "obj",
            "obj_idx",
            "value",
            "vbool",
            "blobsize",
            "pblob",
            "pblob_idx",
            "pstr",
            "pstr_idx",
            "vint32",
            "vdouble",
            "str_list",
            "str_map",
            "str_obj"
        ],
        "calle": [
            "binn_object_set_double",
            "binn_list_add_blob",
            "binn_map_set_bool",
            "binn_object_set_int32",
            "binn_object_get_blob",
            "binn_list_int32",
            "binn_list_get_str",
            "binn_map_set_int32",
            "binn_object_get_bool",
            "memset",
            "binn_object_int32",
            "binn_map_set_double",
            "binn_object_set_blob",
            "binn_map_set_blob",
            "binn_object_get_double",
            "binn_list_add_int32",
            "strlen",
            "binn_list_add_str",
            "binn_object_double",
            "binn_list_str",
            "binn_map_get_blob",
            "binn_map_get_bool",
            "binn_list_get_value",
            "binn_object_set_bool",
            "binn_map_get_str",
            "binn_map_double",
            "binn_object_bool",
            "binn_map_str",
            "printf",
            "binn_map_get_value",
            "binn_map_int32",
            "binn_list_get_int32",
            "binn_object",
            "binn_list",
            "binn_free",
            "binn_object_get_int32",
            "binn_list_bool",
            "binn_object_str",
            "binn_list_double",
            "binn_map_bool",
            "binn_type",
            "binn_map_get_int32",
            "binn_list_add_bool",
            "binn_list_get_bool",
            "binn_map_set_str",
            "memcmp",
            "binn_list_get_double",
            "binn_map_get_double",
            "binn_map_blob",
            "binn_list_add_double",
            "strcmp",
            "assert",
            "malloc",
            "binn_object_get_value",
            "binn_list_get_blob",
            "binn_map",
            "binn_list_blob",
            "binn_object_blob",
            "binn_object_get_str",
            "binn_object_set_str",
            "binn_size",
            "binn_count"
        ],
        "calle_c": [
            "memcmp",
            "strcmp",
            "assert",
            "malloc",
            "memset",
            "printf",
            "strlen"
        ],
        "key": "test2",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "test1": {
        "source_code": "void test1()\n{\n  static const int fix_size = 512;\n  int i;\n  int blobsize;\n  char *ptr;\n  unsigned int ptr_idx = 0;\n  char *p2;\n  unsigned int p2_idx = 0;\n  binn *obj1;\n  unsigned int obj1_idx = 0;\n  binn *list;\n  unsigned int list_idx = 0;\n  binn *map;\n  unsigned int map_idx = 0;\n  binn *obj;\n  unsigned int obj_idx = 0;\n  binn value;\n  char vbyte;\n  char *pblob;\n  unsigned int pblob_idx = 0;\n  signed short vint16;\n  unsigned short vuint16;\n  signed int vint32;\n  unsigned int vuint32;\n  signed long long int vint64;\n  unsigned long long int vuint64;\n  printf(\"testing binn 1... \");\n  assert(CalcAllocation(512, 512) == 512);\n  assert(CalcAllocation(510, 512) == 512);\n  assert(CalcAllocation(1, 512) == 512);\n  assert(CalcAllocation(0, 512) == 512);\n  assert(CalcAllocation(513, 512) == 1024);\n  assert(CalcAllocation(512 + 256, 512) == 1024);\n  assert(CalcAllocation(1025, 512) == 2048);\n  assert(CalcAllocation(1025, 1024) == 2048);\n  assert(CalcAllocation(2100, 1024) == 4096);\n  assert(binn_new(-1, 0, 0) == 0);\n  assert(binn_new(0, 0, 0) == 0);\n  assert(binn_new(5, 0, 0) == 0);\n  assert(binn_new(0xE1, -1, 0) == 0);\n  ptr_idx = (char *) (&(&obj1[obj1_idx]));\n  assert(binn_new(0xE1, -1, ptr) == 0);\n  assert(binn_new(0xE1, 3 - 1, ptr) == 0);\n  obj1_idx = binn_new(0xE0, 0, 0);\n  assert((&obj1[obj1_idx]) != 0);\n  assert(obj1->header == 0x1F22B11F);\n  assert(obj1->type == 0xE0);\n  assert(obj1->count == 0);\n  assert(obj1->pbuf != 0);\n  assert(obj1->alloc_size > 9);\n  assert(obj1->used_size == 9);\n  assert(obj1->pre_allocated == 0);\n  binn_free(obj1);\n  list_idx = binn_new(0xE0, 0, 0);\n  assert((&list[list_idx]) != 0);\n  map_idx = binn_new(0xE1, 0, 0);\n  assert((&map[map_idx]) != 0);\n  obj_idx = binn_new(0xE2, 0, 0);\n  assert((&obj[obj_idx]) != 0);\n  assert(list->header == 0x1F22B11F);\n  assert(list->type == 0xE0);\n  assert(list->count == 0);\n  assert(list->pbuf != 0);\n  assert(list->alloc_size > 9);\n  assert(list->used_size == 9);\n  assert(list->pre_allocated == 0);\n  assert(map->header == 0x1F22B11F);\n  assert(map->type == 0xE1);\n  assert(map->count == 0);\n  assert(map->pbuf != 0);\n  assert(map->alloc_size > 9);\n  assert(map->used_size == 9);\n  assert(map->pre_allocated == 0);\n  assert(obj->header == 0x1F22B11F);\n  assert(obj->type == 0xE2);\n  assert(obj->count == 0);\n  assert(obj->pbuf != 0);\n  assert(obj->alloc_size > 9);\n  assert(obj->used_size == 9);\n  assert(obj->pre_allocated == 0);\n  ptr_idx = malloc(fix_size);\n  assert((&ptr[ptr_idx]) != 0);\n  obj1_idx = binn_new(0xE2, fix_size, ptr);\n  assert((&obj1[obj1_idx]) != 0);\n  assert(obj1->header == 0x1F22B11F);\n  assert(obj1->type == 0xE2);\n  assert(obj1->count == 0);\n  assert(obj1->pbuf != 0);\n  assert(obj1->alloc_size == fix_size);\n  assert(obj1->used_size == 9);\n  assert(obj1->pre_allocated == 1);\n  assert(binn_map_set(list, 55001, 0x61, &i, 0) == 0);\n  assert(binn_object_set(list, \"test\", 0x61, &i, 0) == 0);\n  assert(binn_list_add(map, 0x61, &i, 0) == 0);\n  assert(binn_object_set(map, \"test\", 0x61, &i, 0) == 0);\n  assert(binn_list_add(obj, 0x61, &i, 0) == 0);\n  assert(binn_map_set(obj, 55001, 0x61, &i, 0) == 0);\n  assert(binn_list_add(list, -1, &i, 0) == 0);\n  assert(binn_list_add(list, 0x1FFFF, &i, 0) == 0);\n  assert(binn_map_set(map, 5501, -1, &i, 0) == 0);\n  assert(binn_map_set(map, 5501, 0x1FFFF, &i, 0) == 0);\n  assert(binn_object_set(obj, \"test\", -1, &i, 0) == 0);\n  assert(binn_object_set(obj, \"test\", 0x1FFFF, &i, 0) == 0);\n  assert(binn_list_add(list, 0x21, 0, 0) == 0);\n  assert(binn_list_add(list, 0x41, 0, 0) == 0);\n  assert(binn_list_add(list, 0x61, 0, 0) == 0);\n  assert(binn_list_add(list, 0x81, 0, 0) == 0);\n  assert(binn_map_set(map, 5501, 0x21, 0, 0) == 0);\n  assert(binn_map_set(map, 5501, 0x41, 0, 0) == 0);\n  assert(binn_map_set(map, 5501, 0x61, 0, 0) == 0);\n  assert(binn_map_set(map, 5501, 0x81, 0, 0) == 0);\n  assert(binn_object_set(obj, \"test\", 0x21, 0, 0) == 0);\n  assert(binn_object_set(obj, \"test\", 0x41, 0, 0) == 0);\n  assert(binn_object_set(obj, \"test\", 0x61, 0, 0) == 0);\n  assert(binn_object_set(obj, \"test\", 0x81, 0, 0) == 0);\n  assert(binn_list_add(list, 0xC0, 0, -1) == 0);\n  assert(binn_list_add(list, 0xC0, 0, 10) == 0);\n  assert(binn_map_set(map, 5501, 0xC0, 0, -1) == 0);\n  assert(binn_map_set(map, 5501, 0xC0, 0, 10) == 0);\n  assert(binn_object_set(obj, \"test\", 0xC0, 0, -1) == 0);\n  assert(binn_object_set(obj, \"test\", 0xC0, 0, 10) == 0);\n  assert(binn_list_add(list, 0xC0, &i, -1) == 0);\n  assert(binn_list_add(list, 0xC0, &i, -15) == 0);\n  assert(binn_map_set(map, 5501, 0xC0, &i, -1) == 0);\n  assert(binn_map_set(map, 5501, 0xC0, &i, -15) == 0);\n  assert(binn_object_set(obj, \"test\", 0xC0, &i, -1) == 0);\n  assert(binn_object_set(obj, \"test\", 0xC0, &i, -15) == 0);\n  ptr_idx = binn_ptr(list);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(binn_list_get_value(ptr, 0, &value) == 0);\n  assert(binn_list_get_value(ptr, 1, &value) == 0);\n  assert(binn_list_get_value(ptr, 2, &value) == 0);\n  assert(binn_list_get_value(ptr, -1, &value) == 0);\n  ptr_idx = binn_ptr(map);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(binn_list_get_value(ptr, 0, &value) == 0);\n  assert(binn_list_get_value(ptr, 1, &value) == 0);\n  assert(binn_list_get_value(ptr, 2, &value) == 0);\n  assert(binn_list_get_value(ptr, -1, &value) == 0);\n  ptr_idx = binn_ptr(obj);\n  assert((&ptr[ptr_idx]) != 0);\n  assert(binn_list_get_value(ptr, 0, &value) == 0);\n  assert(binn_list_get_value(ptr, 1, &value) == 0);\n  assert(binn_list_get_value(ptr, 2, &value) == 0);\n  assert(binn_list_get_value(ptr, -1, &value) == 0);\n  i = 0x1234;\n  assert(binn_list_add(list, 0x61, &i, 0) == 1);\n  assert(binn_map_set(map, 5501, 0x61, &i, 0) == 1);\n  assert(binn_map_set(map, 5501, 0x61, &i, 0) == 0);\n  assert(binn_object_set(obj, \"test\", 0x61, &i, 0) == 1);\n  assert(binn_object_set(obj, \"test\", 0x61, &i, 0) == 0);\n  vbyte = 255;\n  vint16 = -32000;\n  vuint16 = 65000;\n  vint32 = -65000000;\n  vuint32 = 65000000;\n  vint64 = -6500000000000000;\n  vuint64 = 6500000000000000;\n  blobsize = 150;\n  pblob_idx = malloc(blobsize);\n  assert((&pblob[pblob_idx]) != 0);\n  memset(pblob, 55, blobsize);\n  assert(binn_list_add(list, 0x00, 0, 0) == 1);\n  assert(binn_list_add(list, 0x20, &vbyte, 0) == 1);\n  assert(binn_list_add(list, 0x41, &vint16, 0) == 1);\n  assert(binn_list_add(list, 0x40, &vuint16, 0) == 1);\n  assert(binn_list_add(list, 0x61, &vint32, 0) == 1);\n  assert(binn_list_add(list, 0x60, &vuint32, 0) == 1);\n  assert(binn_list_add(list, 0x81, &vint64, 0) == 1);\n  assert(binn_list_add(list, 0x80, &vuint64, 0) == 1);\n  assert(binn_list_add(list, 0xA0, \"this is the string\", 0) == 1);\n  assert(binn_list_add(list, 0xC0, pblob, blobsize) == 1);\n  assert(binn_map_set(map, 99000, 0x00, 0, 0) == 1);\n  assert(binn_map_set(map, 99001, 0x20, &vbyte, 0) == 1);\n  assert(binn_map_set(map, 99002, 0x41, &vint16, 0) == 1);\n  assert(binn_map_set(map, 99003, 0x40, &vuint16, 0) == 1);\n  assert(binn_map_set(map, 99004, 0x61, &vint32, 0) == 1);\n  assert(binn_map_set(map, 99005, 0x60, &vuint32, 0) == 1);\n  assert(binn_map_set(map, 99006, 0x81, &vint64, 0) == 1);\n  assert(binn_map_set(map, 99007, 0x80, &vuint64, 0) == 1);\n  assert(binn_map_set(map, 99008, 0xA0, \"this is the string\", 0) == 1);\n  assert(binn_map_set(map, 99009, 0xC0, pblob, blobsize) == 1);\n  assert(binn_object_set(obj, \"key0\", 0x00, 0, 0) == 1);\n  assert(binn_object_set(obj, \"key1\", 0x20, &vbyte, 0) == 1);\n  assert(binn_object_set(obj, \"key2\", 0x41, &vint16, 0) == 1);\n  assert(binn_object_set(obj, \"key3\", 0x40, &vuint16, 0) == 1);\n  assert(binn_object_set(obj, \"key4\", 0x61, &vint32, 0) == 1);\n  assert(binn_object_set(obj, \"key5\", 0x60, &vuint32, 0) == 1);\n  assert(binn_object_set(obj, \"key6\", 0x81, &vint64, 0) == 1);\n  assert(binn_object_set(obj, \"key7\", 0x80, &vuint64, 0) == 1);\n  assert(binn_object_set(obj, \"key8\", 0xA0, \"this is the string\", 0) == 1);\n  assert(binn_object_set(obj, \"key9\", 0xC0, pblob, blobsize) == 1);\n  assert(binn_list_add(list, 0xC0, ptr, 0) == 1);\n  assert(binn_list_add(list, 0xA0, \"\", 0) == 1);\n  assert(binn_list_add(list, 0xA0, \"after the empty items\", 0) == 1);\n  assert(binn_map_set(map, 0x09, 0x20, &vbyte, 0) == 1);\n  assert(binn_map_set(map, 0x3F, 0x20, &vbyte, 0) == 1);\n  assert(binn_map_set(map, 0x4F, 0x20, &vbyte, 0) == 1);\n  assert(binn_map_set(map, 0xFFF, 0x20, &vbyte, 0) == 1);\n  assert(binn_map_set(map, 0xFFFFF, 0x20, &vbyte, 0) == 1);\n  assert(binn_map_set(map, 0xFFFFFFF, 0x20, &vbyte, 0) == 1);\n  assert(binn_map_set(map, 0x7FFFFFFF, 0x20, &vbyte, 0) == 1);\n  assert(binn_map_set(map, -0x09, 0x20, &vbyte, 0) == 1);\n  assert(binn_map_set(map, -0x3F, 0x20, &vbyte, 0) == 1);\n  assert(binn_map_set(map, -0x4F, 0x20, &vbyte, 0) == 1);\n  assert(binn_map_set(map, -0xFFF, 0x20, &vbyte, 0) == 1);\n  assert(binn_map_set(map, -0xFFFFF, 0x20, &vbyte, 0) == 1);\n  assert(binn_map_set(map, -0xFFFFFFF, 0x20, &vbyte, 0) == 1);\n  assert(binn_map_set(map, -0x7FFFFFFF, 0x20, &vbyte, 0) == 1);\n  assert(binn_map_set(map, 0x09, 0x20, &vbyte, 0) == 0);\n  assert(binn_map_set(map, 0x3F, 0x20, &vbyte, 0) == 0);\n  assert(binn_map_set(map, 0x4F, 0x20, &vbyte, 0) == 0);\n  assert(binn_map_set(map, 0xFFF, 0x20, &vbyte, 0) == 0);\n  assert(binn_map_set(map, 0xFFFFF, 0x20, &vbyte, 0) == 0);\n  assert(binn_map_set(map, 0xFFFFFFF, 0x20, &vbyte, 0) == 0);\n  assert(binn_map_set(map, 0x7FFFFFFF, 0x20, &vbyte, 0) == 0);\n  assert(binn_map_set(map, -0x09, 0x20, &vbyte, 0) == 0);\n  assert(binn_map_set(map, -0x3F, 0x20, &vbyte, 0) == 0);\n  assert(binn_map_set(map, -0x4F, 0x20, &vbyte, 0) == 0);\n  assert(binn_map_set(map, -0xFFF, 0x20, &vbyte, 0) == 0);\n  assert(binn_map_set(map, -0xFFFFF, 0x20, &vbyte, 0) == 0);\n  assert(binn_map_set(map, -0xFFFFFFF, 0x20, &vbyte, 0) == 0);\n  assert(binn_map_set(map, -0x7FFFFFFF, 0x20, &vbyte, 0) == 0);\n  assert(binn_list_add(obj1, 0x61, &i, 0) == 0);\n  assert(binn_map_set(obj1, 55001, 0x61, &i, 0) == 0);\n  assert(binn_object_set(obj1, \"test\", 0x60, &vuint32, 0) == 1);\n  assert(binn_object_set(obj1, \"test\", 0x60, &vuint32, 0) == 0);\n  assert(binn_object_set(obj1, \"key1\", 0xA0, \"this is the value\", 0) == 1);\n  assert(binn_object_set(obj1, \"key2\", 0xA0, \"the second value\", 0) == 1);\n  ptr_idx = malloc(fix_size);\n  assert((&ptr[ptr_idx]) != 0);\n  p2_idx = &ptr[ptr_idx];\n  for (i = 0; i < (fix_size - 1); i += 1)\n  {\n    p2[p2_idx] = 'A';\n    p2_idx += 1;\n  }\n\n  p2[p2_idx] = '\\0';\n  assert(strlen(ptr) == (fix_size - 1));\n  assert(binn_object_set(obj1, \"v2\", 0xA0, ptr, 0) == 0);\n  assert(binn_object_set(obj, \"v2\", 0xA0, ptr, 0) == 1);\n  assert(binn_object_set(obj, \"Key00\", 0xA0, \"after the big string\", 0) == 1);\n  free(ptr);\n  ptr_idx = 0;\n  assert(binn_object_set(obj, \"list\", 0xE0, binn_ptr(list), binn_size(list)) == 1);\n  assert(binn_object_set(obj, \"Key10\", 0xA0, \"after the list\", 0) == 1);\n  assert(binn_size(0) == 0);\n  assert(binn_size(list) == list->size);\n  assert(binn_size(map) == map->size);\n  assert(binn_size(obj) == obj->size);\n  assert(binn_size(obj1) == obj1->size);\n  binn_free(list);\n  binn_free(map);\n  binn_free(obj);\n  binn_free(obj1);\n  printf(\"OK\\n\");\n}\n\n",
        "translated_code": "pub fn test1() {\n    let fix_size = 512;\n    let mut i = 0;\n    let mut blobsize = 0;\n    let mut ptr: Option<Box<[u8]>> = None;\n    let mut ptr_idx = 0;\n    let mut p2: Option<Box<[u8]>> = None;\n    let mut p2_idx = 0;\n    let mut obj1: Option<Box<BinnStruct>> = None;\n    let mut obj1_idx = 0;\n    let mut list: Option<Box<BinnStruct>> = None;\n    let mut list_idx = 0;\n    let mut map: Option<Box<BinnStruct>> = None;\n    let mut map_idx = 0;\n    let mut obj: Option<Box<BinnStruct>> = None;\n    let mut obj_idx = 0;\n    let mut value = BinnValue {\n        vint8: 0,\n        vint16: 0,\n        vint32: 0,\n        vint64: 0,\n        vuint8: 0,\n        vuint16: 0,\n        vuint32: 0,\n        vuint64: 0,\n        vchar: 0,\n        vuchar: 0,\n        vshort: 0,\n        vushort: 0,\n        vint: 0,\n        vuint: 0,\n        vfloat: 0.0,\n        vdouble: 0.0,\n        vbool: 0,\n    };\n    let mut vbyte = 0;\n    let mut pblob: Option<Box<[u8]>> = None;\n    let mut pblob_idx = 0;\n    let mut vint16 = 0;\n    let mut vuint16 = 0;\n    let mut vint32 = 0;\n    let mut vuint32 = 0;\n    let mut vint64_: i64 = 0;\n    let mut vuint64_: u64 = 0;\n\n    println!(\"testing binn 1... \");\n    assert!(CalcAllocation(512, 512) == 512);\n    assert!(CalcAllocation(510, 512) == 512);\n    assert!(CalcAllocation(1, 512) == 512);\n    assert!(CalcAllocation(0, 512) == 512);\n    assert!(CalcAllocation(513, 512) == 1024);\n    assert!(CalcAllocation(512 + 256, 512) == 1024);\n    assert!(CalcAllocation(1025, 512) == 2048);\n    assert!(CalcAllocation(1025, 1024) == 2048);\n    assert!(CalcAllocation(2100, 1024) == 4096);\n    assert!(binn_new(-1, 0, None).is_none());\n    assert!(binn_new(0, 0, None).is_none());\n    assert!(binn_new(5, 0, None).is_none());\n    assert!(binn_new(0xE1, -1, None).is_none());\n    ptr_idx = std::ptr::null_mut::<u8>() as usize;\n    assert!(binn_new(0xE1, -1, None).is_none());\n    assert!(binn_new(0xE1, 3 - 1, None).is_none());\n    obj1 = binn_new(0xE0, 0, None);\n    assert!(obj1.is_some());\n    assert!(obj1.as_ref().unwrap().header == 0x1F22B11F);\n    assert!(obj1.as_ref().unwrap().type_ == 0xE0);\n    assert!(obj1.as_ref().unwrap().count == 0);\n    assert!(obj1.as_ref().unwrap().pbuf.is_some());\n    assert!(obj1.as_ref().unwrap().alloc_size > 9);\n    assert!(obj1.as_ref().unwrap().used_size == 9);\n    assert!(obj1.as_ref().unwrap().pre_allocated == 0);\n    binn_free(&mut obj1);\n    list = binn_new(0xE0, 0, None);\n    assert!(list.is_some());\n    map = binn_new(0xE1, 0, None);\n    assert!(map.is_some());\n    obj = binn_new(0xE2, 0, None);\n    assert!(obj.is_some());\n    assert!(list.as_ref().unwrap().header == 0x1F22B11F);\n    assert!(list.as_ref().unwrap().type_ == 0xE0);\n    assert!(list.as_ref().unwrap().count == 0);\n    assert!(list.as_ref().unwrap().pbuf.is_some());\n    assert!(list.as_ref().unwrap().alloc_size > 9);\n    assert!(list.as_ref().unwrap().used_size == 9);\n    assert!(list.as_ref().unwrap().pre_allocated == 0);\n    assert!(map.as_ref().unwrap().header == 0x1F22B11F);\n    assert!(map.as_ref().unwrap().type_ == 0xE1);\n    assert!(map.as_ref().unwrap().count == 0);\n    assert!(map.as_ref().unwrap().pbuf.is_some());\n    assert!(map.as_ref().unwrap().alloc_size > 9);\n    assert!(map.as_ref().unwrap().used_size == 9);\n    assert!(map.as_ref().unwrap().pre_allocated == 0);\n    assert!(obj.as_ref().unwrap().header == 0x1F22B11F);\n    assert!(obj.as_ref().unwrap().type_ == 0xE2);\n    assert!(obj.as_ref().unwrap().count == 0);\n    assert!(obj.as_ref().unwrap().pbuf.is_some());\n    assert!(obj.as_ref().unwrap().alloc_size > 9);\n    assert!(obj.as_ref().unwrap().used_size == 9);\n    assert!(obj.as_ref().unwrap().pre_allocated == 0);\n    ptr = Some(vec![0u8; fix_size].into_boxed_slice());\n    assert!(ptr.is_some());\n    obj1 = binn_new(0xE2, fix_size.try_into().unwrap(), ptr.as_deref_mut());\n    assert!(obj1.is_some());\n    assert!(obj1.as_ref().unwrap().header == 0x1F22B11F);\n    assert!(obj1.as_ref().unwrap().type_ == 0xE2);\n    assert!(obj1.as_ref().unwrap().count == 0);\n    assert!(obj1.as_ref().unwrap().pbuf.is_some());\n    assert!(obj1.as_ref().unwrap().alloc_size == fix_size.try_into().unwrap());\n    assert!(obj1.as_ref().unwrap().used_size == 9);\n    assert!(obj1.as_ref().unwrap().pre_allocated == 1);\n    assert!(binn_map_set(&mut list, 55001, 0x61, None, 0) == 0);\n    assert!(binn_object_set(&mut list, Some(\"test\"), 0x61, None, 0) == 0);\n    assert!(binn_list_add(&mut map, 0x61, None, 0) == 0);\n    assert!(binn_object_set(&mut map, Some(\"test\"), 0x61, None, 0) == 0);\n    assert!(binn_list_add(&mut obj, 0x61, None, 0) == 0);\n    assert!(binn_map_set(&mut obj, 55001, 0x61, None, 0) == 0);\n    assert!(binn_list_add(&mut list, -1, None, 0) == 0);\n    assert!(binn_list_add(&mut list, 0x1FFFF, None, 0) == 0);\n    assert!(binn_map_set(&mut map, 5501, -1, None, 0) == 0);\n    assert!(binn_map_set(&mut map, 5501, 0x1FFFF, None, 0) == 0);\n    assert!(binn_object_set(&mut obj, Some(\"test\"), -1, None, 0) == 0);\n    assert!(binn_object_set(&mut obj, Some(\"test\"), 0x1FFFF, None, 0) == 0);\n    assert!(binn_list_add(&mut list, 0x21, None, 0) == 0);\n    assert!(binn_list_add(&mut list, 0x41, None, 0) == 0);\n    assert!(binn_list_add(&mut list, 0x61, None, 0) == 0);\n    assert!(binn_list_add(&mut list, 0x81, None, 0) == 0);\n    assert!(binn_map_set(&mut map, 5501, 0x21, None, 0) == 0);\n    assert!(binn_map_set(&mut map, 5501, 0x41, None, 0) == 0);\n    assert!(binn_map_set(&mut map, 5501, 0x61, None, 0) == 0);\n    assert!(binn_map_set(&mut map, 5501, 0x81, None, 0) == 0);\n    assert!(binn_object_set(&mut obj, Some(\"test\"), 0x21, None, 0) == 0);\n    assert!(binn_object_set(&mut obj, Some(\"test\"), 0x41, None, 0) == 0);\n    assert!(binn_object_set(&mut obj, Some(\"test\"), 0x61, None, 0) == 0);\n    assert!(binn_object_set(&mut obj, Some(\"test\"), 0x81, None, 0) == 0);\n    assert!(binn_list_add(&mut list, 0xC0, None, -1) == 0);\n    assert!(binn_list_add(&mut list, 0xC0, None, 10) == 0);\n    assert!(binn_map_set(&mut map, 5501, 0xC0, None, -1) == 0);\n    assert!(binn_map_set(&mut map, 5501, 0xC0, None, 10) == 0);\n    assert!(binn_object_set(&mut obj, Some(\"test\"), 0xC0, None, -1) == 0);\n    assert!(binn_object_set(&mut obj, Some(\"test\"), 0xC0, None, 10) == 0);\n    assert!(binn_list_add(&mut list, 0xC0, None, -1) == 0);\n    assert!(binn_list_add(&mut list, 0xC0, None, -15) == 0);\n    assert!(binn_map_set(&mut map, 5501, 0xC0, None, -1) == 0);\n    assert!(binn_map_set(&mut map, 5501, 0xC0, None, -15) == 0);\n    assert!(binn_object_set(&mut obj, Some(\"test\"), 0xC0, None, -1) == 0);\n    assert!(binn_object_set(&mut obj, Some(\"test\"), 0xC0, None, -15) == 0);\n    \n    // Fixed pointer conversion using stable API\n    ptr_idx = binn_ptr(list.as_ref().and_then(|b| b.pbuf.as_ref().map(|p| Box::into_raw(p.clone()) as *mut u8))).unwrap() as usize;\n    assert!(ptr.is_some());\n    \n    let mut temp_value: Option<Box<BinnStruct>> = None;\n    assert!(binn_list_get_value(ptr.as_deref(), 0, Some(&mut temp_value)) == 0);\n    assert!(binn_list_get_value(ptr.as_deref(), 1, Some(&mut temp_value)) == 0);\n    assert!(binn_list_get_value(ptr.as_deref(), 2, Some(&mut temp_value)) == 0);\n    assert!(binn_list_get_value(ptr.as_deref(), -1, Some(&mut temp_value)) == 0);\n    \n    ptr_idx = binn_ptr(map.as_ref().and_then(|b| b.pbuf.as_ref().map(|p| Box::into_raw(p.clone()) as *mut u8))).unwrap() as usize;\n    assert!(ptr.is_some());\n    assert!(binn_list_get_value(ptr.as_deref(), 0, Some(&mut temp_value)) == 0);\n    assert!(binn_list_get_value(ptr.as_deref(), 1, Some(&mut temp_value)) == 0);\n    assert!(binn_list_get_value(ptr.as_deref(), 2, Some(&mut temp_value)) == 0);\n    assert!(binn_list_get_value(ptr.as_deref(), -1, Some(&mut temp_value)) == 0);\n    \n    ptr_idx = binn_ptr(obj.as_ref().and_then(|b| b.pbuf.as_ref().map(|p| Box::into_raw(p.clone()) as *mut u8))).unwrap() as usize;\n    assert!(ptr.is_some());\n    assert!(binn_list_get_value(ptr.as_deref(), 0, Some(&mut temp_value)) == 0);\n    assert!(binn_list_get_value(ptr.as_deref(), 1, Some(&mut temp_value)) == 0);\n    assert!(binn_list_get_value(ptr.as_deref(), 2, Some(&mut temp_value)) == 0);\n    assert!(binn_list_get_value(ptr.as_deref(), -1, Some(&mut temp_value)) == 0);\n\n    i = 0x1234;\n    assert!(binn_list_add(&mut list, 0x61, Some(&mut Some(Box::new(i))), 0) == 1);\n    assert!(binn_map_set(&mut map, 5501, 0x61, Some(&mut Some(Box::new(i))), 0) == 1);\n    assert!(binn_map_set(&mut map, 5501, 0x61, Some(&mut Some(Box::new(i))), 0) == 0);\n    assert!(binn_object_set(&mut obj, Some(\"test\"), 0x61, Some(&mut Some(Box::new(i))), 0) == 1);\n    assert!(binn_object_set(&mut obj, Some(\"test\"), 0x61, Some(&mut Some(Box::new(i))), 0) == 0);\n    vbyte = 255;\n    vint16 = -32000;\n    vuint16 = 65000;\n    vint32 = -65000000;\n    vuint32 = 65000000;\n    vint64_ = -6500000000000000i64;\n    vuint64_ = 6500000000000000u64;\n    blobsize = 150;\n    pblob = Some(vec![0u8; blobsize].into_boxed_slice());\n    assert!(pblob.is_some());\n    pblob.as_deref_mut().unwrap().fill(55);\n    assert!(binn_list_add(&mut list, 0x00, None, 0) == 1);\n    assert!(binn_list_add(&mut list, 0x20, Some(&mut Some(Box::new(vbyte))), 0) == 1);\n    assert!(binn_list_add(&mut list, 0x41, Some(&mut Some(Box::new(vint16))), 0) == 1);\n    assert!(binn_list_add(&mut list, 0x40, Some(&mut Some(Box::new(vuint16))), 0) == 1);\n    assert!(binn_list_add(&mut list, 0x61, Some(&mut Some(Box::new(vint32))), 0) == 1);\n    assert!(binn_list_add(&mut list, 0x60, Some(&mut Some(Box::new(vuint32))), 0) == 1);\n    assert!(binn_list_add(&mut list, 0x81, Some(&mut Some(Box::new(vint64_))), 0) == 1);\n    assert!(binn_list_add(&mut list, 0x80, Some(&mut Some(Box::new(vuint64_))), 0) == 1);\n    assert!(binn_list_add(&mut list, 0xA0, Some(&mut Some(Box::new(\"this is the string\"))), 0) == 1);\n    let mut blob_box: Option<Box<dyn std::any::Any>> = Some(Box::new(pblob.take().unwrap().to_vec().into_boxed_slice()));\n    assert!(binn_list_add(&mut list, 0xC0, Some(&mut blob_box), blobsize.try_into().unwrap()) == 1);\n    assert!(binn_map_set(&mut map, 99000, 0x00, None, 0) == 1);\n    assert!(binn_map_set(&mut map, 99001, 0x20, Some(&mut Some(Box::new(vbyte))), 0) == 1);\n    assert!(binn_map_set(&mut map, 99002, 0x41, Some(&mut Some(Box::new(vint16))), 0) == 1);\n    assert!(binn_map_set(&mut map, 99003, 0x40, Some(&mut Some(Box::new(vuint16))), 0) == 1);\n    assert!(binn_map_set(&mut map, 99004, 0x61, Some(&mut Some(Box::new(vint32))), 0) == 1);\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "CalcAllocation",
            "binn",
            "binn_free",
            "binn_list_add",
            "binn_list_get_value",
            "binn_map_set",
            "binn_new",
            "binn_object_set",
            "binn_ptr",
            "binn_size"
        ],
        "lifetime_hint": [],
        "global_variables": [
            "fix_size",
            "i",
            "blobsize",
            "ptr",
            "ptr_idx",
            "p2",
            "p2_idx",
            "obj1",
            "obj1_idx",
            "list",
            "list_idx",
            "map",
            "map_idx",
            "obj",
            "obj_idx",
            "value",
            "vbyte",
            "pblob",
            "pblob_idx",
            "vint16",
            "vuint16",
            "vint32",
            "vuint32",
            "vint64",
            "vuint64"
        ],
        "calle": [
            "binn_list_add",
            "strlen",
            "binn_ptr",
            "assert",
            "binn_free",
            "malloc",
            "binn_object_set",
            "binn_size",
            "free",
            "memset",
            "binn_list_get_value",
            "binn_new",
            "CalcAllocation",
            "binn_map_set",
            "printf"
        ],
        "calle_c": [
            "assert",
            "malloc",
            "free",
            "memset",
            "printf",
            "strlen"
        ],
        "key": "test1",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "main#test_binn": {
        "source_code": "int main()\n{\n  puts(\"\\nStarting the unit/regression tests...\\n\");\n  printf(\"sizeof(binn) = %d\\n\\n\", sizeof(binn));\n  test_binn_version();\n  test_endianess();\n  test_int64();\n  test_floating_point_numbers();\n  test1();\n  test2(0);\n  test2(1);\n  test_binn2();\n  test3();\n  test_invalid_binn();\n  puts(\"\\nAll tests pass! :)\\n\");\n  return 0;\n}\n\n",
        "translated_code": "use crate::binn::binn;\n\npub fn main() {\n    println!(\"\\nStarting the unit/regression tests...\\n\");\n    println!(\"sizeof(binn) = {}\\n\", std::mem::size_of::<binn>());\n\n    test_binn_version();\n    test_endianess();\n    test_int64();\n    test_floating_point_numbers();\n    test1();\n    test2(0);\n    test2(1);\n    test_binn2();\n    test3();\n    test_invalid_binn();\n\n    println!(\"\\nAll tests pass! :)\\n\");\n}",
        "hint": "functions",
        "section": "src",
        "file": "test_binn.rs",
        "error": "",
        "dependent": [
            "test1",
            "test2",
            "test3",
            "test_binn2",
            "test_binn_version",
            "test_endianess",
            "test_floating_point_numbers",
            "test_int64",
            "test_invalid_binn"
        ],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [
            "puts",
            "test2",
            "test_int64",
            "test_endianess",
            "test_binn_version",
            "test_floating_point_numbers",
            "test_binn2",
            "test3",
            "test_invalid_binn",
            "test1",
            "printf"
        ],
        "calle_c": [
            "puts",
            "printf"
        ],
        "key": "main#test_binn",
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    }
}
