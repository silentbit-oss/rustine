# 0 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 1
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 2
# 2 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 3 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdint.h" 1
# 4 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/string.h" 1
# 5 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/memory.h" 1
# 6 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.h" 1
# 33 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.h"
typedef int BOOL;
# 67 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.h"
  typedef long long int int64;
  typedef unsigned long long int uint64;
# 199 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.h"
typedef void (*binn_mem_free)(void*);







struct binn_struct {
  int header;
  BOOL allocated;
  BOOL writable;
  BOOL dirty;

  void *pbuf;
  BOOL pre_allocated;
  int alloc_size;
  int used_size;

  int type;
  void *ptr;
  int size;
  int count;

  binn_mem_free freefn;

  union {
    signed char vint8;
    signed short vint16;
    signed int vint32;
    int64 vint64;
    unsigned char vuint8;
    unsigned short vuint16;
    unsigned int vuint32;
    uint64 vuint64;

    signed char vchar;
    unsigned char vuchar;
    signed short vshort;
    unsigned short vushort;
    signed int vint;
    unsigned int vuint;

    float vfloat;
    double vdouble;

    BOOL vbool;
  };

  BOOL disable_int_compression;
};

typedef struct binn_struct binn;





char * binn_version();

void binn_set_alloc_functions(void* (*new_malloc)(size_t), void* (*new_realloc)(void*,size_t), void (*new_free)(void*));

int binn_create_type(int storage_type, int data_type_index);
BOOL binn_get_type_info(int long_type, int *pstorage_type, int *pextra_type);

int binn_get_write_storage(int type);
int binn_get_read_storage(int type);

BOOL binn_is_container(binn *item);





binn * binn_new(int type, int size, void *buffer);
binn * binn_list();
binn * binn_map();
binn * binn_object();


BOOL binn_create(binn *item, int type, int size, void *buffer);
BOOL binn_create_list(binn *list);
BOOL binn_create_map(binn *map);
BOOL binn_create_object(binn *object);


binn * binn_copy(void *old);


BOOL binn_list_add_new(binn *list, binn *value);
BOOL binn_map_set_new(binn *map, int id, binn *value);
BOOL binn_object_set_new(binn *obj, const char *key, binn *value);




BOOL binn_list_add(binn *list, int type, void *pvalue, int size);
BOOL binn_map_set(binn *map, int id, int type, void *pvalue, int size);
BOOL binn_object_set(binn *obj, const char *key, int type, void *pvalue, int size);




void binn_free(binn *item);
void * binn_release(binn *item);




binn * binn_value(int type, void *pvalue, int size, binn_mem_free freefn);

static inline binn * binn_int8(signed char value) {
  return binn_value(0x21, &value, 0, 0);
}
static inline binn * binn_int16(short value) {
  return binn_value(0x41, &value, 0, 0);
}
static inline binn * binn_int32(int value) {
  return binn_value(0x61, &value, 0, 0);
}
static inline binn * binn_int64(int64 value) {
  return binn_value(0x81, &value, 0, 0);
}
static inline binn * binn_uint8(unsigned char value) {
  return binn_value(0x20, &value, 0, 0);
}
static inline binn * binn_uint16(unsigned short value) {
  return binn_value(0x40, &value, 0, 0);
}
static inline binn * binn_uint32(unsigned int value) {
  return binn_value(0x60, &value, 0, 0);
}
static inline binn * binn_uint64(uint64 value) {
  return binn_value(0x80, &value, 0, 0);
}
static inline binn * binn_float(float value) {
  return binn_value(0x62, &value, 0, 0);
}
static inline binn * binn_double(double value) {
  return binn_value(0x82, &value, 0, 0);
}
static inline binn * binn_bool(BOOL value) {
  return binn_value(0x80061, &value, 0, 0);
}
static inline binn * binn_null() {
  return binn_value(0x00, 0, 0, 0);
}
static inline binn * binn_string(char *str, binn_mem_free freefn) {
  return binn_value(0xA0, str, 0, freefn);
}
static inline binn * binn_blob(void *ptr, int size, binn_mem_free freefn) {
  return binn_value(0xC0, ptr, size, freefn);
}





void * binn_ptr(void *ptr);
int binn_size(void *ptr);
int binn_type(void *ptr);
int binn_count(void *ptr);

BOOL binn_is_valid(void *ptr, int *ptype, int *pcount, int *psize);






BOOL binn_is_valid_ex(void *ptr, int *ptype, int *pcount, int *psize);
# 378 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.h"
BOOL binn_is_struct(void *ptr);




BOOL binn_load(void *data, binn *item);
binn * binn_open(void *data);




signed char binn_list_int8(void *list, int pos);
short binn_list_int16(void *list, int pos);
int binn_list_int32(void *list, int pos);
int64 binn_list_int64(void *list, int pos);
unsigned char binn_list_uint8(void *list, int pos);
unsigned short binn_list_uint16(void *list, int pos);
unsigned int binn_list_uint32(void *list, int pos);
uint64 binn_list_uint64(void *list, int pos);
float binn_list_float(void *list, int pos);
double binn_list_double(void *list, int pos);
BOOL binn_list_bool(void *list, int pos);
BOOL binn_list_null(void *list, int pos);
char * binn_list_str(void *list, int pos);
void * binn_list_blob(void *list, int pos, int *psize);
void * binn_list_list(void *list, int pos);
void * binn_list_map(void *list, int pos);
void * binn_list_object(void *list, int pos);

signed char binn_map_int8(void *map, int id);
short binn_map_int16(void *map, int id);
int binn_map_int32(void *map, int id);
int64 binn_map_int64(void *map, int id);
unsigned char binn_map_uint8(void *map, int id);
unsigned short binn_map_uint16(void *map, int id);
unsigned int binn_map_uint32(void *map, int id);
uint64 binn_map_uint64(void *map, int id);
float binn_map_float(void *map, int id);
double binn_map_double(void *map, int id);
BOOL binn_map_bool(void *map, int id);
BOOL binn_map_null(void *map, int id);
char * binn_map_str(void *map, int id);
void * binn_map_blob(void *map, int id, int *psize);
void * binn_map_list(void *map, int id);
void * binn_map_map(void *map, int id);
void * binn_map_object(void *map, int id);

signed char binn_object_int8(void *obj, const char *key);
short binn_object_int16(void *obj, const char *key);
int binn_object_int32(void *obj, const char *key);
int64 binn_object_int64(void *obj, const char *key);
unsigned char binn_object_uint8(void *obj, const char *key);
unsigned short binn_object_uint16(void *obj, const char *key);
unsigned int binn_object_uint32(void *obj, const char *key);
uint64 binn_object_uint64(void *obj, const char *key);
float binn_object_float(void *obj, const char *key);
double binn_object_double(void *obj, const char *key);
BOOL binn_object_bool(void *obj, const char *key);
BOOL binn_object_null(void *obj, const char *key);
char * binn_object_str(void *obj, const char *key);
void * binn_object_blob(void *obj, const char *key, int *psize);
void * binn_object_list(void *obj, const char *key);
void * binn_object_map(void *obj, const char *key);
void * binn_object_object(void *obj, const char *key);



binn * binn_list_value(void *list, int pos);
binn * binn_map_value(void *map, int id);
binn * binn_object_value(void *obj, const char *key);


BOOL binn_list_get_value(void* list, int pos, binn *value);
BOOL binn_map_get_value(void* map, int id, binn *value);
BOOL binn_object_get_value(void *obj, const char *key, binn *value);


BOOL binn_list_get(void *list, int pos, int type, void *pvalue, int *psize);
BOOL binn_map_get(void *map, int id, int type, void *pvalue, int *psize);
BOOL binn_object_get(void *obj, const char *key, int type, void *pvalue, int *psize);





void * binn_list_read(void *list, int pos, int *ptype, int *psize);
void * binn_map_read(void *map, int id, int *ptype, int *psize);
void * binn_object_read(void *obj, const char *key, int *ptype, int *psize);







BOOL binn_map_get_pair(void *map, int pos, int *pid, binn *value);
BOOL binn_object_get_pair(void *obj, int pos, char *pkey, binn *value);


binn * binn_map_pair(void *map, int pos, int *pid);
binn * binn_object_pair(void *obj, int pos, char *pkey);





void * binn_map_read_pair(void *ptr, int pos, int *pid, int *ptype, int *psize);
void * binn_object_read_pair(void *ptr, int pos, char *pkey, int *ptype, int *psize);




typedef struct binn_iter_struct {
    unsigned char *pnext;
    unsigned char *plimit;
    int type;
    int count;
    int current;
} binn_iter;

BOOL binn_iter_init(binn_iter *iter, void *pbuf, int type);


binn * binn_list_next_value(binn_iter *iter);
binn * binn_map_next_value(binn_iter *iter, int *pid);
binn * binn_object_next_value(binn_iter *iter, char *pkey);


BOOL binn_list_next(binn_iter *iter, binn *value);
BOOL binn_map_next(binn_iter *iter, int *pid, binn *value);
BOOL binn_object_next(binn_iter *iter, char *pkey, binn *value);





void * binn_list_read_next(binn_iter *iter, int *ptype, int *psize);
void * binn_map_read_next(binn_iter *iter, int *pid, int *ptype, int *psize);
void * binn_object_read_next(binn_iter *iter, char *pkey, int *ptype, int *psize);
# 542 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.h"
BOOL binn_set_string(binn *item, char *str, binn_mem_free pfree);
BOOL binn_set_blob(binn *item, void *ptr, int size, binn_mem_free pfree);
# 575 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.h"
static inline BOOL binn_list_add_int8(binn *list, signed char value) {
  return binn_list_add(list, 0x21, &value, 0);
}
static inline BOOL binn_list_add_int16(binn *list, short value) {
  return binn_list_add(list, 0x41, &value, 0);
}
static inline BOOL binn_list_add_int32(binn *list, int value) {
  return binn_list_add(list, 0x61, &value, 0);
}
static inline BOOL binn_list_add_int64(binn *list, int64 value) {
  return binn_list_add(list, 0x81, &value, 0);
}
static inline BOOL binn_list_add_uint8(binn *list, unsigned char value) {
  return binn_list_add(list, 0x20, &value, 0);
}
static inline BOOL binn_list_add_uint16(binn *list, unsigned short value) {
  return binn_list_add(list, 0x40, &value, 0);
}
static inline BOOL binn_list_add_uint32(binn *list, unsigned int value) {
  return binn_list_add(list, 0x60, &value, 0);
}
static inline BOOL binn_list_add_uint64(binn *list, uint64 value) {
  return binn_list_add(list, 0x80, &value, 0);
}
static inline BOOL binn_list_add_float(binn *list, float value) {
  return binn_list_add(list, 0x62, &value, 0);
}
static inline BOOL binn_list_add_double(binn *list, double value) {
  return binn_list_add(list, 0x82, &value, 0);
}
static inline BOOL binn_list_add_bool(binn *list, BOOL value) {
  return binn_list_add(list, 0x80061, &value, 0);
}
static inline BOOL binn_list_add_null(binn *list) {
  return binn_list_add(list, 0x00, 0, 0);
}
static inline BOOL binn_list_add_str(binn *list, char *str) {
  return binn_list_add(list, 0xA0, str, 0);
}
static inline BOOL binn_list_add_blob(binn *list, void *ptr, int size) {
  return binn_list_add(list, 0xC0, ptr, size);
}
static inline BOOL binn_list_add_list(binn *list, void *list2) {
  return binn_list_add(list, 0xE0, binn_ptr(list2), binn_size(list2));
}
static inline BOOL binn_list_add_map(binn *list, void *map) {
  return binn_list_add(list, 0xE1, binn_ptr(map), binn_size(map));
}
static inline BOOL binn_list_add_object(binn *list, void *obj) {
  return binn_list_add(list, 0xE2, binn_ptr(obj), binn_size(obj));
}
static inline BOOL binn_list_add_value(binn *list, binn *value) {
  return binn_list_add(list, value->type, binn_ptr(value), binn_size(value));
}



static inline BOOL binn_map_set_int8(binn *map, int id, signed char value) {
  return binn_map_set(map, id, 0x21, &value, 0);
}
static inline BOOL binn_map_set_int16(binn *map, int id, short value) {
  return binn_map_set(map, id, 0x41, &value, 0);
}
static inline BOOL binn_map_set_int32(binn *map, int id, int value) {
  return binn_map_set(map, id, 0x61, &value, 0);
}
static inline BOOL binn_map_set_int64(binn *map, int id, int64 value) {
  return binn_map_set(map, id, 0x81, &value, 0);
}
static inline BOOL binn_map_set_uint8(binn *map, int id, unsigned char value) {
  return binn_map_set(map, id, 0x20, &value, 0);
}
static inline BOOL binn_map_set_uint16(binn *map, int id, unsigned short value) {
  return binn_map_set(map, id, 0x40, &value, 0);
}
static inline BOOL binn_map_set_uint32(binn *map, int id, unsigned int value) {
  return binn_map_set(map, id, 0x60, &value, 0);
}
static inline BOOL binn_map_set_uint64(binn *map, int id, uint64 value) {
  return binn_map_set(map, id, 0x80, &value, 0);
}
static inline BOOL binn_map_set_float(binn *map, int id, float value) {
  return binn_map_set(map, id, 0x62, &value, 0);
}
static inline BOOL binn_map_set_double(binn *map, int id, double value) {
  return binn_map_set(map, id, 0x82, &value, 0);
}
static inline BOOL binn_map_set_bool(binn *map, int id, BOOL value) {
  return binn_map_set(map, id, 0x80061, &value, 0);
}
static inline BOOL binn_map_set_null(binn *map, int id) {
  return binn_map_set(map, id, 0x00, 0, 0);
}
static inline BOOL binn_map_set_str(binn *map, int id, char *str) {
  return binn_map_set(map, id, 0xA0, str, 0);
}
static inline BOOL binn_map_set_blob(binn *map, int id, void *ptr, int size) {
  return binn_map_set(map, id, 0xC0, ptr, size);
}
static inline BOOL binn_map_set_list(binn *map, int id, void *list) {
  return binn_map_set(map, id, 0xE0, binn_ptr(list), binn_size(list));
}
static inline BOOL binn_map_set_map(binn *map, int id, void *map2) {
  return binn_map_set(map, id, 0xE1, binn_ptr(map2), binn_size(map2));
}
static inline BOOL binn_map_set_object(binn *map, int id, void *obj) {
  return binn_map_set(map, id, 0xE2, binn_ptr(obj), binn_size(obj));
}
static inline BOOL binn_map_set_value(binn *map, int id, binn *value) {
  return binn_map_set(map, id, value->type, binn_ptr(value), binn_size(value));
}



static inline BOOL binn_object_set_int8(binn *obj, const char *key, signed char value) {
  return binn_object_set(obj, key, 0x21, &value, 0);
}
static inline BOOL binn_object_set_int16(binn *obj, const char *key, short value) {
  return binn_object_set(obj, key, 0x41, &value, 0);
}
static inline BOOL binn_object_set_int32(binn *obj, const char *key, int value) {
  return binn_object_set(obj, key, 0x61, &value, 0);
}
static inline BOOL binn_object_set_int64(binn *obj, const char *key, int64 value) {
  return binn_object_set(obj, key, 0x81, &value, 0);
}
static inline BOOL binn_object_set_uint8(binn *obj, const char *key, unsigned char value) {
  return binn_object_set(obj, key, 0x20, &value, 0);
}
static inline BOOL binn_object_set_uint16(binn *obj, const char *key, unsigned short value) {
  return binn_object_set(obj, key, 0x40, &value, 0);
}
static inline BOOL binn_object_set_uint32(binn *obj, const char *key, unsigned int value) {
  return binn_object_set(obj, key, 0x60, &value, 0);
}
static inline BOOL binn_object_set_uint64(binn *obj, const char *key, uint64 value) {
  return binn_object_set(obj, key, 0x80, &value, 0);
}
static inline BOOL binn_object_set_float(binn *obj, const char *key, float value) {
  return binn_object_set(obj, key, 0x62, &value, 0);
}
static inline BOOL binn_object_set_double(binn *obj, const char *key, double value) {
  return binn_object_set(obj, key, 0x82, &value, 0);
}
static inline BOOL binn_object_set_bool(binn *obj, const char *key, BOOL value) {
  return binn_object_set(obj, key, 0x80061, &value, 0);
}
static inline BOOL binn_object_set_null(binn *obj, const char *key) {
  return binn_object_set(obj, key, 0x00, 0, 0);
}
static inline BOOL binn_object_set_str(binn *obj, const char *key, char *str) {
  return binn_object_set(obj, key, 0xA0, str, 0);
}
static inline BOOL binn_object_set_blob(binn *obj, const char *key, void *ptr, int size) {
  return binn_object_set(obj, key, 0xC0, ptr, size);
}
static inline BOOL binn_object_set_list(binn *obj, const char *key, void *list) {
  return binn_object_set(obj, key, 0xE0, binn_ptr(list), binn_size(list));
}
static inline BOOL binn_object_set_map(binn *obj, const char *key, void *map) {
  return binn_object_set(obj, key, 0xE1, binn_ptr(map), binn_size(map));
}
static inline BOOL binn_object_set_object(binn *obj, const char *key, void *obj2) {
  return binn_object_set(obj, key, 0xE2, binn_ptr(obj2), binn_size(obj2));
}
static inline BOOL binn_object_set_value(binn *obj, const char *key, binn *value) {
  return binn_object_set(obj, key, value->type, binn_ptr(value), binn_size(value));
}





static inline BOOL binn_list_get_int8(void *list, int pos, signed char *pvalue) {
  return binn_list_get(list, pos, 0x21, pvalue, 0);
}
static inline BOOL binn_list_get_int16(void *list, int pos, short *pvalue) {
  return binn_list_get(list, pos, 0x41, pvalue, 0);
}
static inline BOOL binn_list_get_int32(void *list, int pos, int *pvalue) {
  return binn_list_get(list, pos, 0x61, pvalue, 0);
}
static inline BOOL binn_list_get_int64(void *list, int pos, int64 *pvalue) {
  return binn_list_get(list, pos, 0x81, pvalue, 0);
}
static inline BOOL binn_list_get_uint8(void *list, int pos, unsigned char *pvalue) {
  return binn_list_get(list, pos, 0x20, pvalue, 0);
}
static inline BOOL binn_list_get_uint16(void *list, int pos, unsigned short *pvalue) {
  return binn_list_get(list, pos, 0x40, pvalue, 0);
}
static inline BOOL binn_list_get_uint32(void *list, int pos, unsigned int *pvalue) {
  return binn_list_get(list, pos, 0x60, pvalue, 0);
}
static inline BOOL binn_list_get_uint64(void *list, int pos, uint64 *pvalue) {
  return binn_list_get(list, pos, 0x80, pvalue, 0);
}
static inline BOOL binn_list_get_float(void *list, int pos, float *pvalue) {
  return binn_list_get(list, pos, 0x62, pvalue, 0);
}
static inline BOOL binn_list_get_double(void *list, int pos, double *pvalue) {
  return binn_list_get(list, pos, 0x82, pvalue, 0);
}
static inline BOOL binn_list_get_bool(void *list, int pos, BOOL *pvalue) {
  return binn_list_get(list, pos, 0x80061, pvalue, 0);
}
static inline BOOL binn_list_get_str(void *list, int pos, char **pvalue) {
  return binn_list_get(list, pos, 0xA0, pvalue, 0);
}
static inline BOOL binn_list_get_blob(void *list, int pos, void **pvalue, int *psize) {
  return binn_list_get(list, pos, 0xC0, pvalue, psize);
}
static inline BOOL binn_list_get_list(void *list, int pos, void **pvalue) {
  return binn_list_get(list, pos, 0xE0, pvalue, 0);
}
static inline BOOL binn_list_get_map(void *list, int pos, void **pvalue) {
  return binn_list_get(list, pos, 0xE1, pvalue, 0);
}
static inline BOOL binn_list_get_object(void *list, int pos, void **pvalue) {
  return binn_list_get(list, pos, 0xE2, pvalue, 0);
}



static inline BOOL binn_map_get_int8(void *map, int id, signed char *pvalue) {
  return binn_map_get(map, id, 0x21, pvalue, 0);
}
static inline BOOL binn_map_get_int16(void *map, int id, short *pvalue) {
  return binn_map_get(map, id, 0x41, pvalue, 0);
}
static inline BOOL binn_map_get_int32(void *map, int id, int *pvalue) {
  return binn_map_get(map, id, 0x61, pvalue, 0);
}
static inline BOOL binn_map_get_int64(void *map, int id, int64 *pvalue) {
  return binn_map_get(map, id, 0x81, pvalue, 0);
}
static inline BOOL binn_map_get_uint8(void *map, int id, unsigned char *pvalue) {
  return binn_map_get(map, id, 0x20, pvalue, 0);
}
static inline BOOL binn_map_get_uint16(void *map, int id, unsigned short *pvalue) {
  return binn_map_get(map, id, 0x40, pvalue, 0);
}
static inline BOOL binn_map_get_uint32(void *map, int id, unsigned int *pvalue) {
  return binn_map_get(map, id, 0x60, pvalue, 0);
}
static inline BOOL binn_map_get_uint64(void *map, int id, uint64 *pvalue) {
  return binn_map_get(map, id, 0x80, pvalue, 0);
}
static inline BOOL binn_map_get_float(void *map, int id, float *pvalue) {
  return binn_map_get(map, id, 0x62, pvalue, 0);
}
static inline BOOL binn_map_get_double(void *map, int id, double *pvalue) {
  return binn_map_get(map, id, 0x82, pvalue, 0);
}
static inline BOOL binn_map_get_bool(void *map, int id, BOOL *pvalue) {
  return binn_map_get(map, id, 0x80061, pvalue, 0);
}
static inline BOOL binn_map_get_str(void *map, int id, char **pvalue) {
  return binn_map_get(map, id, 0xA0, pvalue, 0);
}
static inline BOOL binn_map_get_blob(void *map, int id, void **pvalue, int *psize) {
  return binn_map_get(map, id, 0xC0, pvalue, psize);
}
static inline BOOL binn_map_get_list(void *map, int id, void **pvalue) {
  return binn_map_get(map, id, 0xE0, pvalue, 0);
}
static inline BOOL binn_map_get_map(void *map, int id, void **pvalue) {
  return binn_map_get(map, id, 0xE1, pvalue, 0);
}
static inline BOOL binn_map_get_object(void *map, int id, void **pvalue) {
  return binn_map_get(map, id, 0xE2, pvalue, 0);
}






static inline BOOL binn_object_get_int8(void *obj, const char *key, signed char *pvalue) {
  return binn_object_get(obj, key, 0x21, pvalue, 0);
}
static inline BOOL binn_object_get_int16(void *obj, const char *key, short *pvalue) {
  return binn_object_get(obj, key, 0x41, pvalue, 0);
}
static inline BOOL binn_object_get_int32(void *obj, const char *key, int *pvalue) {
  return binn_object_get(obj, key, 0x61, pvalue, 0);
}
static inline BOOL binn_object_get_int64(void *obj, const char *key, int64 *pvalue) {
  return binn_object_get(obj, key, 0x81, pvalue, 0);
}
static inline BOOL binn_object_get_uint8(void *obj, const char *key, unsigned char *pvalue) {
  return binn_object_get(obj, key, 0x20, pvalue, 0);
}
static inline BOOL binn_object_get_uint16(void *obj, const char *key, unsigned short *pvalue) {
  return binn_object_get(obj, key, 0x40, pvalue, 0);
}
static inline BOOL binn_object_get_uint32(void *obj, const char *key, unsigned int *pvalue) {
  return binn_object_get(obj, key, 0x60, pvalue, 0);
}
static inline BOOL binn_object_get_uint64(void *obj, const char *key, uint64 *pvalue) {
  return binn_object_get(obj, key, 0x80, pvalue, 0);
}
static inline BOOL binn_object_get_float(void *obj, const char *key, float *pvalue) {
  return binn_object_get(obj, key, 0x62, pvalue, 0);
}
static inline BOOL binn_object_get_double(void *obj, const char *key, double *pvalue) {
  return binn_object_get(obj, key, 0x82, pvalue, 0);
}
static inline BOOL binn_object_get_bool(void *obj, const char *key, BOOL *pvalue) {
  return binn_object_get(obj, key, 0x80061, pvalue, 0);
}
static inline BOOL binn_object_get_str(void *obj, const char *key, char **pvalue) {
  return binn_object_get(obj, key, 0xA0, pvalue, 0);
}
static inline BOOL binn_object_get_blob(void *obj, const char *key, void **pvalue, int *psize) {
  return binn_object_get(obj, key, 0xC0, pvalue, psize);
}
static inline BOOL binn_object_get_list(void *obj, const char *key, void **pvalue) {
  return binn_object_get(obj, key, 0xE0, pvalue, 0);
}
static inline BOOL binn_object_get_map(void *obj, const char *key, void **pvalue) {
  return binn_object_get(obj, key, 0xE1, pvalue, 0);
}
static inline BOOL binn_object_get_object(void *obj, const char *key, void **pvalue) {
  return binn_object_get(obj, key, 0xE2, pvalue, 0);
}



BOOL binn_get_int32(binn *value, int *pint);
BOOL binn_get_int64(binn *value, int64 *pint);
BOOL binn_get_double(binn *value, double *pfloat);
BOOL binn_get_bool(binn *value, BOOL *pbool);
char * binn_get_str(binn *value);
# 7 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c" 2
# 22 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
void* (*malloc_fn)(size_t len) = 0;
void* (*realloc_fn)(void *ptr, size_t len) = 0;
void (*free_fn)(void *ptr) = 0;
# 45 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/endian.h" 1
# 46 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c" 2
# 64 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
typedef unsigned short int u16;
typedef unsigned int u32;
typedef unsigned long long int u64;

static void copy_be16(u16 *pdest, u16 *psource) {

  unsigned char *source = (unsigned char *) psource;
  unsigned char *dest = (unsigned char *) pdest;
  dest[0] = source[1];
  dest[1] = source[0];
# 88 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
}

static void copy_be32(u32 *pdest, u32 *psource) {

  unsigned char *source = (unsigned char *) psource;
  unsigned char *dest = (unsigned char *) pdest;
  dest[0] = source[3];
  dest[1] = source[2];
  dest[2] = source[1];
  dest[3] = source[0];
# 114 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
}

static void copy_be64(u64 *pdest, u64 *psource) {

  unsigned char *source = (unsigned char *) psource;
  unsigned char *dest = (unsigned char *) pdest;
  int i;
  for (i=0; i < 8; i++) {
    dest[i] = source[7-i];
  }
# 140 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
}
# 149 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
static BOOL IsValidBinnHeader(void *pbuf, int *ptype, int *pcount, int *psize, int *pheadersize);



char * binn_version() {
  return "3.0.0";
}



void binn_set_alloc_functions(void* (*new_malloc)(size_t), void* (*new_realloc)(void*,size_t), void (*new_free)(void*)) {

  malloc_fn = new_malloc;
  realloc_fn = new_realloc;
  free_fn = new_free;

}



static void check_alloc_functions() {

  if (malloc_fn == 0) malloc_fn = &malloc;
  if (realloc_fn == 0) realloc_fn = &realloc;
  if (free_fn == 0) free_fn = &free;

}



static void * binn_malloc(int size) {
  check_alloc_functions();
  return malloc_fn(size);
}



static void * binn_memdup(void *src, int size) {
  void *dest;

  if (src == 0 || size <= 0) return 0;
  dest = binn_malloc(size);
  if (dest == 0) return 0;
  memcpy(dest, src, size);
  return dest;

}



static size_t strlen2(char *str) {

  if (str == 0) return 0;
  return strlen(str);

}



int binn_create_type(int storage_type, int data_type_index) {
  if (data_type_index < 0) return -1;
  if ((storage_type < 0x00) || (storage_type > 0xE0)) return -1;
  if (data_type_index < 16)
    return storage_type | data_type_index;
  else if (data_type_index < 4096) {
    storage_type |= 0x10;
    storage_type <<= 8;
    data_type_index >>= 4;
    return storage_type | data_type_index;
  } else
    return -1;
}



BOOL binn_get_type_info(int long_type, int *pstorage_type, int *pextra_type) {
  int storage_type, extra_type;
  BOOL retval=1;

again:

  if (long_type < 0) {
    goto loc_invalid;
  } else if (long_type <= 0xff) {
    storage_type = long_type & 0xE0;
    extra_type = long_type & 0x0F;
  } else if (long_type <= 0xffff) {
    storage_type = long_type & 0xE000;
    storage_type >>= 8;
    extra_type = long_type & 0x0FFF;
    extra_type >>= 4;
  } else if (long_type & 0x80000) {


    long_type &= 0xffff;
    goto again;
  } else {
loc_invalid:
    storage_type = -1;
    extra_type = -1;
    retval = 0;
  }

  if (pstorage_type) *pstorage_type = storage_type;
  if (pextra_type) *pextra_type = extra_type;

  return retval;

}



BOOL binn_create(binn *item, int type, int size, void *pointer) {
  BOOL retval=0;

  switch (type) {
    case 0xE0:
    case 0xE1:
    case 0xE2:
      break;
    default:
      goto loc_exit;
  }

  if ((item == 0) || (size < 0)) goto loc_exit;
  if (size < 3) {
    if (pointer) goto loc_exit;
    else size = 0;
  }

  memset(item, 0, sizeof(binn));

  if (pointer) {
    item->pre_allocated = 1;
    item->pbuf = pointer;
    item->alloc_size = size;
  } else {
    item->pre_allocated = 0;
    if (size == 0) size = 256;
    pointer = binn_malloc(size);
    if (pointer == 0) return 0;
    item->pbuf = pointer;
    item->alloc_size = size;
  }

  item->header = 0x1F22B11F;

  item->writable = 1;
  item->used_size = 9;
  item->type = type;

  item->dirty = 1;

  retval = 1;

loc_exit:
  return retval;

}



binn * binn_new(int type, int size, void *pointer) {
  binn *item;

  item = (binn*) binn_malloc(sizeof(binn));

  if (binn_create(item, type, size, pointer) == 0) {
    free_fn(item);
    return 0;
  }

  item->allocated = 1;
  return item;

}



BOOL binn_create_list(binn *list) {

  return binn_create(list, 0xE0, 0, 0);

}



BOOL binn_create_map(binn *map) {

  return binn_create(map, 0xE1, 0, 0);

}



BOOL binn_create_object(binn *object) {

  return binn_create(object, 0xE2, 0, 0);

}



binn * binn_list() {
  return binn_new(0xE0, 0, 0);
}



binn * binn_map() {
  return binn_new(0xE1, 0, 0);
}



binn * binn_object() {
  return binn_new(0xE2, 0, 0);
}



binn * binn_copy(void *old) {
  int type, count, size, header_size;
  unsigned char *old_ptr = binn_ptr(old);
  binn *item;

  size = 0;
  if (!IsValidBinnHeader(old_ptr, &type, &count, &size, &header_size)) return 0;

  item = binn_new(type, size - header_size + 9, 0);
  if( item ){
    unsigned char *dest;
    dest = ((unsigned char *) item->pbuf) + 9;
    memcpy(dest, old_ptr + header_size, size - header_size);
    item->used_size = 9 + size - header_size;
    item->count = count;
  }
  return item;

}



BOOL binn_load(void *data, binn *value) {

  if ((data == 0) || (value == 0)) return 0;
  memset(value, 0, sizeof(binn));
  value->header = 0x1F22B11F;



  if (binn_is_valid(data, &value->type, &value->count, &value->size) == 0) return 0;
  value->ptr = data;
  return 1;

}



binn * binn_open(void *data) {
  binn *item;

  item = (binn*) binn_malloc(sizeof(binn));

  if (binn_load(data, item) == 0) {
    free_fn(item);
    return 0;
  }

  item->allocated = 1;
  return item;

}



static int binn_get_ptr_type(void *ptr) {

  if (ptr == 0) return 0;

  switch (*(unsigned int *)ptr) {
  case 0x1F22B11F:
    return 1;
  default:
    return 2;
  }

}



BOOL binn_is_struct(void *ptr) {

  if (ptr == 0) return 0;

  if ((*(unsigned int *)ptr) == 0x1F22B11F) {
    return 1;
  } else {
    return 0;
  }

}



static int CalcAllocation(int needed_size, int alloc_size) {
  int calc_size;

  calc_size = alloc_size;
  while (calc_size < needed_size) {
    calc_size <<= 1;

  }
  return calc_size;

}



static BOOL CheckAllocation(binn *item, int add_size) {
  int alloc_size;
  void *ptr;

  if (item->used_size + add_size > item->alloc_size) {
    if (item->pre_allocated) return 0;
    alloc_size = CalcAllocation(item->used_size + add_size, item->alloc_size);
    ptr = realloc_fn(item->pbuf, alloc_size);
    if (ptr == 0) return 0;
    item->pbuf = ptr;
    item->alloc_size = alloc_size;
  }

  return 1;

}
# 512 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
static unsigned char * AdvanceDataPos(unsigned char *p, unsigned char *plimit) {
  unsigned char byte;
  int storage_type, DataSize;

  if (p > plimit) return 0;

  byte = *p; p++;
  storage_type = byte & 0xE0;
  if (byte & 0x10) p++;

  switch (storage_type) {
  case 0x00:

    break;
  case 0x20:
    p ++;
    break;
  case 0x40:
    p += 2;
    break;
  case 0x60:
    p += 4;
    break;
  case 0x80:
    p += 8;
    break;
  case 0xC0:
  case 0xA0:
    if (p > plimit) return 0;
    DataSize = *((unsigned char*)p);
    if (DataSize & 0x80) {
      if (p + sizeof(int) - 1 > plimit) return 0;
      copy_be32((u32*)&DataSize, (u32*)p);
      DataSize &= 0x7FFFFFFF;
      p+=4;
    } else {
      p++;
    }
    p += DataSize;
    if (storage_type == 0xA0) {
      p++;
    }
    break;
  case 0xE0:
    if (p > plimit) return 0;
    DataSize = *((unsigned char*)p);
    if (DataSize & 0x80) {
      if (p + sizeof(int) - 1 > plimit) return 0;
      copy_be32((u32*)&DataSize, (u32*)p);
      DataSize &= 0x7FFFFFFF;
    }
    DataSize--;
    p += DataSize;
    break;
  default:
    return 0;
  }

  if (p > plimit) return 0;

  return p;

}
# 592 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
static int read_map_id(unsigned char **pp, unsigned char *plimit) {
  unsigned char *p, c, sign, type;
  int id, extra_bytes;

  p = *pp;

  c = *p++;

  if (c & 0x80) {
    extra_bytes = ((c & 0x60) >> 5) + 1;
    if (p + extra_bytes > plimit ) {
      *pp = p + extra_bytes;
      return 0;
    }
  }

  type = c & 0xE0;
  sign = c & 0x10;

  if ((c & 0x80) == 0) {
    sign = c & 0x40;
    id = c & 0x3F;
  } else if (type == 0x80) {
    id = c & 0x0F;
    id = (id << 8) | *p++;
  } else if (type == 0xA0) {
    id = c & 0x0F;
    id = (id << 8) | *p++;
    id = (id << 8) | *p++;
  } else if (type == 0xC0) {
    id = c & 0x0F;
    id = (id << 8) | *p++;
    id = (id << 8) | *p++;
    id = (id << 8) | *p++;
  } else if (type == 0xE0) {
    copy_be32((u32*)&id, (u32*)p);
    p += 4;
  } else {
    *pp = plimit + 2;
    return 0;
  }

  if (sign) id = -id;

  *pp = p;

  return id;
}



static unsigned char * SearchForID(unsigned char *p, int header_size, int size, int numitems, int id) {
  unsigned char *plimit, *base;
  int i, int32;

  base = p;
  plimit = p + size - 1;
  p += header_size;


  for (i = 0; i < numitems; i++) {
    int32 = read_map_id(&p, plimit);
    if (p > plimit) break;

    if (int32 == id) return p;

    p = AdvanceDataPos(p, plimit);
    if ((p == 0) || (p < base)) break;
  }

  return 0;

}



static unsigned char * SearchForKey(unsigned char *p, int header_size, int size, int numitems, const char *key) {
  unsigned char len, *plimit, *base;
  int i, keylen;

  base = p;
  plimit = p + size - 1;
  p += header_size;

  keylen = strlen(key);


  for (i = 0; i < numitems; i++) {
    len = *((unsigned char *)p);
    p++;
    if (p > plimit) break;

    if (len > 0) {
      if (strncasecmp((char*)p, key, len) == 0) {
        if (keylen == len) {
          p += len;
          return p;
        }
      }
      p += len;
      if (p > plimit) break;
    } else if (len == keylen) {
      return p;
    }

    p = AdvanceDataPos(p, plimit);
    if ((p == 0) || (p < base)) break;
  }

  return 0;

}



static BOOL AddValue(binn *item, int type, void *pvalue, int size);



static BOOL binn_list_add_raw(binn *item, int type, void *pvalue, int size) {

  if ((item == 0) || (item->type != 0xE0) || (item->writable == 0)) return 0;



  if (AddValue(item, type, pvalue, size) == 0) return 0;

  item->count++;

  return 1;

}



static BOOL binn_object_set_raw(binn *item, const char *key, int type, void *pvalue, int size) {
  unsigned char *p, len;
  int int32;

  if ((item == 0) || (item->type != 0xE2) || (item->writable == 0)) return 0;

  if (key == 0) return 0;
  int32 = strlen(key);
  if (int32 > 255) return 0;


  p = SearchForKey(item->pbuf, 9, item->used_size, item->count, key);
  if (p) return 0;



  if (CheckAllocation(item, 1 + int32) == 0) return 0;

  p = ((unsigned char *) item->pbuf) + item->used_size;
  len = int32;
  *p = len;
  p++;
  memcpy(p, key, int32);
  int32++;
  item->used_size += int32;

  if (AddValue(item, type, pvalue, size) == 0) {
    item->used_size -= int32;
    return 0;
  }

  item->count++;

  return 1;

}



static BOOL binn_map_set_raw(binn *item, int id, int type, void *pvalue, int size) {
  unsigned char *base, *p, sign;
  int id_size;

  if ((item == 0) || (item->type != 0xE1) || (item->writable == 0)) return 0;


  p = SearchForID(item->pbuf, 9, item->used_size, item->count, id);
  if (p) return 0;



  if (CheckAllocation(item, 5) == 0) return 0;

  p = base = ((unsigned char *) item->pbuf) + item->used_size;

  sign = (id < 0);
  if (sign) id = -id;

  if (id <= 0x3F) {
    *p++ = (sign << 6) | id;
  } else if (id <= 0xFFF) {
    *p++ = 0x80 | (sign << 4) | ((id & 0xF00) >> 8);
    *p++ = id & 0xFF;
  } else if (id <= 0xFFFFF) {
    *p++ = 0xA0 | (sign << 4) | ((id & 0xF0000) >> 16);
    *p++ = (id & 0xFF00) >> 8;
    *p++ = id & 0xFF;
  } else if (id <= 0xFFFFFFF) {
    *p++ = 0xC0 | (sign << 4) | ((id & 0xF000000) >> 24);
    *p++ = (id & 0xFF0000) >> 16;
    *p++ = (id & 0xFF00) >> 8;
    *p++ = id & 0xFF;
  } else {
    *p++ = 0xE0;
    if (sign) id = -id;
    copy_be32((u32*)p, (u32*)&id);
    p += 4;
  }

  id_size = (p - base);
  item->used_size += id_size;

  if (AddValue(item, type, pvalue, size) == 0) {
    item->used_size -= id_size;
    return 0;
  }

  item->count++;

  return 1;

}



static void * compress_int(int *pstorage_type, int *ptype, void *psource) {
  int storage_type, storage_type2, type, type2=0;
  int64 vint = 0;
  uint64 vuint;
  char *pvalue;




  storage_type = *pstorage_type;
  if (storage_type == 0x20) return psource;

  type = *ptype;

  switch (type) {
  case 0x81:
    vint = *(int64*)psource;
    goto loc_signed;
  case 0x61:
    vint = *(int*)psource;
    goto loc_signed;
  case 0x41:
    vint = *(short*)psource;
    goto loc_signed;
  case 0x80:
    vuint = *(uint64*)psource;
    goto loc_positive;
  case 0x60:
    vuint = *(unsigned int*)psource;
    goto loc_positive;
  case 0x40:
    vuint = *(unsigned short*)psource;
    goto loc_positive;
  }

loc_signed:

  if (vint >= 0) {
    vuint = vint;
    goto loc_positive;
  }



  if (vint >= INT8_MIN) {
    type2 = 0x21;
  } else
  if (vint >= INT16_MIN) {
    type2 = 0x41;
  } else
  if (vint >= INT32_MIN) {
    type2 = 0x61;
  }
  goto loc_exit;

loc_positive:

  if (vuint <= UINT8_MAX) {
    type2 = 0x20;
  } else
  if (vuint <= UINT16_MAX) {
    type2 = 0x40;
  } else
  if (vuint <= UINT32_MAX) {
    type2 = 0x60;
  }

loc_exit:

  pvalue = (char *) psource;

  if ((type2) && (type2 != type)) {
    *ptype = type2;
    storage_type2 = binn_get_write_storage(type2);
    *pstorage_type = storage_type2;





  }

  return pvalue;

}



static int type_family(int type);

static BOOL AddValue(binn *item, int type, void *pvalue, int size) {
  int int32, ArgSize, storage_type, extra_type;
  unsigned char *p;

  binn_get_type_info(type, &storage_type, &extra_type);

  if (pvalue == 0) {
    switch (storage_type) {
      case 0x00:
        break;
      case 0xC0:
      case 0xA0:
        if (size == 0) break;
      default:
        return 0;
    }
  }

  if ((type_family(type) == 0xf2) && (item->disable_int_compression == 0))
    pvalue = compress_int(&storage_type, &type, pvalue);

  switch (storage_type) {
    case 0x00:
      size = 0;
      ArgSize = size;
      break;
    case 0x20:
      size = 1;
      ArgSize = size;
      break;
    case 0x40:
      size = 2;
      ArgSize = size;
      break;
    case 0x60:
      size = 4;
      ArgSize = size;
      break;
    case 0x80:
      size = 8;
      ArgSize = size;
      break;
    case 0xC0:
      if (size < 0) return 0;

      ArgSize = size + 4;
      break;
    case 0xA0:
      if (size < 0) return 0;
      if (size == 0) size = strlen2( (char *) pvalue);
      ArgSize = size + 5;
      break;
    case 0xE0:
      if (size <= 0) return 0;
      ArgSize = size;
      break;
    default:
      return 0;
  }

  ArgSize += 2;
  if (CheckAllocation(item, ArgSize) == 0) return 0;


  p = ((unsigned char *) item->pbuf) + item->used_size;


  if (storage_type != 0xE0) {
    if (type > 255) {
      u16 type16 = type;
      copy_be16((u16*)p, (u16*)&type16);
      p += 2;
      item->used_size += 2;
    } else {
      *p = type;
      p++;
      item->used_size++;
    }
  }

  switch (storage_type) {
    case 0x00:

      break;
    case 0x20:
      *((char *) p) = *((char *) pvalue);
      item->used_size += 1;
      break;
    case 0x40:
      copy_be16((u16*)p, (u16*)pvalue);
      item->used_size += 2;
      break;
    case 0x60:
      copy_be32((u32*)p, (u32*)pvalue);
      item->used_size += 4;
      break;
    case 0x80:
      copy_be64((u64*)p, (u64*)pvalue);
      item->used_size += 8;
      break;
    case 0xC0:
    case 0xA0:
      if (size > 127) {
        int32 = size | 0x80000000;
        copy_be32((u32*)p, (u32*)&int32);
        p += 4;
        item->used_size += 4;
      } else {
        *((unsigned char *) p) = size;
        p++;
        item->used_size++;
      }
      memcpy(p, pvalue, size);
      if (storage_type == 0xA0) {
        p += size;
        *((char *) p) = (char) 0;
        size++;
      }
      item->used_size += size;
      break;
    case 0xE0:
      memcpy(p, pvalue, size);
      item->used_size += size;
      break;
  }

  item->dirty = 1;

  return 1;
}



static BOOL binn_save_header(binn *item) {
  unsigned char byte, *p;
  int int32, size;

  if (item == 0) return 0;



  p = ((unsigned char *) item->pbuf) + 9;
  size = item->used_size - 9 + 3;


  if (item->count > 127) {
    p -= 4;
    size += 3;
    int32 = item->count | 0x80000000;
    copy_be32((u32*)p, (u32*)&int32);
  } else {
    p--;
    *p = (unsigned char) item->count;
  }


  if (size > 127) {
    p -= 4;
    size += 3;
    int32 = size | 0x80000000;
    copy_be32((u32*)p, (u32*)&int32);
  } else {
    p--;
    *p = (unsigned char) size;
  }


  p--;
  *p = (unsigned char) item->type;


  item->ptr = p;
  item->size = size;

  (void)(byte);
# 1108 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
  item->dirty = 0;

  return 1;

}



void binn_free(binn *item) {

  if (item == 0) return;

  if ((item->writable) && (item->pre_allocated == 0)) {
    free_fn(item->pbuf);
  }

  if (item->freefn) item->freefn(item->ptr);

  if (item->allocated) {
    free_fn(item);
  } else {
    memset(item, 0, sizeof(binn));
    item->header = 0x1F22B11F;
  }

}



void * binn_release(binn *item) {
  void *data;

  if (item == 0) return 0;

  data = binn_ptr(item);

  if (data > item->pbuf) {
    memmove(item->pbuf, data, item->size);
    data = item->pbuf;
  }

  if (item->allocated) {
    free_fn(item);
  } else {
    memset(item, 0, sizeof(binn));
    item->header = 0x1F22B11F;
  }

  return data;

}



static BOOL IsValidBinnHeader(void *pbuf, int *ptype, int *pcount, int *psize, int *pheadersize) {
  unsigned char byte, *p, *plimit=0;
  int int32, type, size, count;

  if (pbuf == 0) return 0;

  p = (unsigned char *) pbuf;

  if (psize && *psize > 0) {
    plimit = p + *psize - 1;
  }


  byte = *p; p++;
  if ((byte & 0xE0) != 0xE0) return 0;
  if (byte & 0x10) return 0;
  type = byte;

  switch (type) {
    case 0xE0:
    case 0xE1:
    case 0xE2:
      break;
    default:
      return 0;
  }


  if (plimit && p > plimit) return 0;
  int32 = *((unsigned char*)p);
  if (int32 & 0x80) {
    if (plimit && p + sizeof(int) - 1 > plimit) return 0;
    copy_be32((u32*)&int32, (u32*)p);
    int32 &= 0x7FFFFFFF;
    p+=4;
  } else {
    p++;
  }
  size = int32;


  if (plimit && p > plimit) return 0;
  int32 = *((unsigned char*)p);
  if (int32 & 0x80) {
    if (plimit && p + sizeof(int) - 1 > plimit) return 0;
    copy_be32((u32*)&int32, (u32*)p);
    int32 &= 0x7FFFFFFF;
    p+=4;
  } else {
    p++;
  }
  count = int32;
# 1227 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
  if ((size < 3) || (count < 0)) return 0;


  if (ptype) *ptype = type;
  if (pcount) *pcount = count;
  if (psize && *psize==0) *psize = size;
  if (pheadersize) *pheadersize = (int) (p - (unsigned char*)pbuf);
  return 1;
}



static int binn_buf_type(void *pbuf) {
  int type;

  if (!IsValidBinnHeader(pbuf, &type, 0, 0, 0)) return 0;

  return type;

}



static int binn_buf_count(void *pbuf) {
  int nitems;

  if (!IsValidBinnHeader(pbuf, 0, &nitems, 0, 0)) return 0;

  return nitems;

}



static int binn_buf_size(void *pbuf) {
  int size=0;

  if (!IsValidBinnHeader(pbuf, 0, 0, &size, 0)) return 0;

  return size;

}



void * binn_ptr(void *ptr) {
  binn *item;

  switch (binn_get_ptr_type(ptr)) {
  case 1:
    item = (binn*) ptr;
    if (item->writable && item->dirty) {
      binn_save_header(item);
    }
    return item->ptr;
  case 2:
    return ptr;
  default:
    return 0;
  }

}



int binn_size(void *ptr) {
  binn *item;

  switch (binn_get_ptr_type(ptr)) {
  case 1:
    item = (binn*) ptr;
    if (item->writable && item->dirty) {
      binn_save_header(item);
    }
    return item->size;
  case 2:
    return binn_buf_size(ptr);
  default:
    return 0;
  }

}



int binn_type(void *ptr) {
  binn *item;

  switch (binn_get_ptr_type(ptr)) {
  case 1:
    item = (binn*) ptr;
    return item->type;
  case 2:
    return binn_buf_type(ptr);
  default:
    return -1;
  }

}



int binn_count(void *ptr) {
  binn *item;

  switch (binn_get_ptr_type(ptr)) {
  case 1:
    item = (binn*) ptr;
    return item->count;
  case 2:
    return binn_buf_count(ptr);
  default:
    return -1;
  }

}



BOOL binn_is_valid_ex(void *ptr, int *ptype, int *pcount, int *psize) {
  int i, type, count, size, header_size;
  unsigned char *p, *plimit, *base, len;
  void *pbuf;

  pbuf = binn_ptr(ptr);
  if (pbuf == 0) return 0;


  if (psize && *psize > 0) {
    size = *psize;
  } else {
    size = 0;
  }

  if (!IsValidBinnHeader(pbuf, &type, &count, &size, &header_size)) return 0;


  if (psize && *psize > 0) {

    if (size != *psize) return 0;
  }

  if (pcount && *pcount > 0) {

    if (count != *pcount) return 0;
  }

  if (ptype && *ptype != 0) {

    if (type != *ptype) return 0;
  }



  p = (unsigned char *)pbuf;
  base = p;
  plimit = p + size;

  p += header_size;


  for (i = 0; i < count; i++) {
    switch (type) {
      case 0xE2:

        len = *p;
        p++;


        p += len;
        break;
      case 0xE1:

        read_map_id(&p, plimit);
        break;


    }

    p = AdvanceDataPos(p, plimit);
    if ((p == 0) || (p < base)) goto Invalid;
  }

  if (ptype && *ptype==0) *ptype = type;
  if (pcount && *pcount==0) *pcount = count;
  if (psize && *psize==0) *psize = size;
  return 1;

Invalid:
  return 0;

}



BOOL binn_is_valid(void *ptr, int *ptype, int *pcount, int *psize) {

  if (ptype) *ptype = 0;
  if (pcount) *pcount = 0;
  if (psize) *psize = 0;

  return binn_is_valid_ex(ptr, ptype, pcount, psize);

}





static BOOL GetValue(unsigned char *p, binn *value) {
  unsigned char byte;
  int data_type, storage_type;
  int DataSize;
  void *p2;

  if (value == 0) return 0;
  memset(value, 0, sizeof(binn));
  value->header = 0x1F22B11F;




  p2 = p;


  byte = *p; p++;
  storage_type = byte & 0xE0;
  if (byte & 0x10) {
    data_type = byte << 8;
    byte = *p; p++;
    data_type |= byte;

  } else {
    data_type = byte;

  }


  value->type = data_type;

  switch (storage_type) {
  case 0x00:
    break;
  case 0x20:
    value->vuint8 = *((unsigned char *) p);
    value->ptr = p;
    break;
  case 0x40:
    copy_be16((u16*)&value->vint16, (u16*)p);
    value->ptr = &value->vint16;
    break;
  case 0x60:
    copy_be32((u32*)&value->vint32, (u32*)p);
    value->ptr = &value->vint32;
    break;
  case 0x80:
    copy_be64((u64*)&value->vint64, (u64*)p);
    value->ptr = &value->vint64;
    break;
  case 0xC0:
  case 0xA0:
    DataSize = *((unsigned char*)p);
    if (DataSize & 0x80) {
      copy_be32((u32*)&DataSize, (u32*)p);
      DataSize &= 0x7FFFFFFF;
      p+=4;
    } else {
      p++;
    }
    value->size = DataSize;
    value->ptr = p;
    break;
  case 0xE0:
    value->ptr = p2;
    if (IsValidBinnHeader(p2, 0, &value->count, &value->size, 0) == 0) return 0;
    break;
  default:
    return 0;
  }



  switch (value->type) {
    case 0x01:
      value->type = 0x80061;
      value->vbool = 1;
      value->ptr = &value->vbool;
      break;
    case 0x02:
      value->type = 0x80061;
      value->vbool = 0;
      value->ptr = &value->vbool;
      break;
# 1539 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
  }

  return 1;

}
# 1552 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
binn local_value;

static void * store_value(binn *value) {

  memcpy(&local_value, value, sizeof(binn));

  switch (binn_get_read_storage(value->type)) {
  case 0x00:

  case 0x40:
  case 0x60:
  case 0x80:
    return &local_value.vint32;
  }

  return value->ptr;

}







BOOL binn_object_get_value(void *ptr, const char *key, binn *value) {
  int type, count, size=0, header_size;
  unsigned char *p;

  ptr = binn_ptr(ptr);
  if ((ptr == 0) || (key == 0) || (value == 0)) return 0;


  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == 0) return 0;

  if (type != 0xE2) return 0;
  if (count == 0) return 0;

  p = (unsigned char *) ptr;
  p = SearchForKey(p, header_size, size, count, key);
  if (p == 0) return 0;

  return GetValue(p, value);

}



BOOL binn_map_get_value(void* ptr, int id, binn *value) {
  int type, count, size=0, header_size;
  unsigned char *p;

  ptr = binn_ptr(ptr);
  if ((ptr == 0) || (value == 0)) return 0;


  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == 0) return 0;

  if (type != 0xE1) return 0;
  if (count == 0) return 0;

  p = (unsigned char *) ptr;
  p = SearchForID(p, header_size, size, count, id);
  if (p == 0) return 0;

  return GetValue(p, value);

}



BOOL binn_list_get_value(void* ptr, int pos, binn *value) {
  int i, type, count, size=0, header_size;
  unsigned char *p, *plimit, *base;

  ptr = binn_ptr(ptr);
  if ((ptr == 0) || (value == 0)) return 0;


  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == 0) return 0;

  if (type != 0xE0) return 0;
  if (count == 0) return 0;
  if ((pos <= 0) | (pos > count)) return 0;
  pos--;

  p = (unsigned char *) ptr;
  base = p;
  plimit = p + size;
  p += header_size;

  for (i = 0; i < pos; i++) {
    p = AdvanceDataPos(p, plimit);
    if ((p == 0) || (p < base)) return 0;
  }

  return GetValue(p, value);

}





static BOOL binn_read_pair(int expected_type, void *ptr, int pos, int *pid, char *pkey, binn *value) {
  int type, count, size=0, header_size;
  int i, int32, id = 0, counter=0;
  unsigned char *p, *plimit, *base, *key = 0, len = 0;

  ptr = binn_ptr(ptr);


  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == 0) return 0;

  if ((type != expected_type) || (count == 0) || (pos < 1) || (pos > count)) return 0;

  p = (unsigned char *) ptr;
  base = p;
  plimit = p + size - 1;
  p += header_size;

  for (i = 0; i < count; i++) {
    switch (type) {
      case 0xE1:
        int32 = read_map_id(&p, plimit);
        if (p > plimit) return 0;
        id = int32;
        break;
      case 0xE2:
        len = *((unsigned char *)p); p++;
        if (p > plimit) return 0;
        key = p;
        p += len;
        if (p > plimit) return 0;
        break;
    }
    counter++;
    if (counter == pos) goto found;

    p = AdvanceDataPos(p, plimit);
    if ((p == 0) || (p < base)) return 0;
  }

  return 0;

found:

  switch (type) {
    case 0xE1:
      if (pid) *pid = id;
      break;
    case 0xE2:
      if (pkey) {
        memcpy(pkey, key, len);
        pkey[len] = 0;
      }
      break;
  }

  return GetValue(p, value);

}



BOOL binn_map_get_pair(void *ptr, int pos, int *pid, binn *value) {

  return binn_read_pair(0xE1, ptr, pos, pid, 0, value);

}



BOOL binn_object_get_pair(void *ptr, int pos, char *pkey, binn *value) {

  return binn_read_pair(0xE2, ptr, pos, 0, pkey, value);

}



binn * binn_map_pair(void *map, int pos, int *pid) {
  binn *value;

  value = (binn *) binn_malloc(sizeof(binn));

  if (binn_read_pair(0xE1, map, pos, pid, 0, value) == 0) {
    free_fn(value);
    return 0;
  }

  value->allocated = 1;
  return value;

}



binn * binn_object_pair(void *obj, int pos, char *pkey) {
  binn *value;

  value = (binn *) binn_malloc(sizeof(binn));

  if (binn_read_pair(0xE2, obj, pos, 0, pkey, value) == 0) {
    free_fn(value);
    return 0;
  }

  value->allocated = 1;
  return value;

}




void * binn_map_read_pair(void *ptr, int pos, int *pid, int *ptype, int *psize) {
  binn value;

  if (binn_map_get_pair(ptr, pos, pid, &value) == 0) return 0;
  if (ptype) *ptype = value.type;
  if (psize) *psize = value.size;

  return store_value(&value);




}



void * binn_object_read_pair(void *ptr, int pos, char *pkey, int *ptype, int *psize) {
  binn value;

  if (binn_object_get_pair(ptr, pos, pkey, &value) == 0) return 0;
  if (ptype) *ptype = value.type;
  if (psize) *psize = value.size;

  return store_value(&value);




}





BOOL binn_iter_init(binn_iter *iter, void *ptr, int expected_type) {
  int type, count, size=0, header_size;

  ptr = binn_ptr(ptr);
  if ((ptr == 0) || (iter == 0)) return 0;
  memset(iter, 0, sizeof(binn_iter));


  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == 0) return 0;

  if (type != expected_type) return 0;


  iter->plimit = (unsigned char *)ptr + size - 1;
  iter->pnext = (unsigned char *)ptr + header_size;
  iter->count = count;
  iter->current = 0;
  iter->type = type;

  return 1;
}



BOOL binn_list_next(binn_iter *iter, binn *value) {
  unsigned char *pnow;

  if ((iter == 0) || (iter->pnext == 0) || (iter->pnext > iter->plimit) || (iter->current > iter->count) || (iter->type != 0xE0)) return 0;

  iter->current++;
  if (iter->current > iter->count) return 0;

  pnow = iter->pnext;
  iter->pnext = AdvanceDataPos(pnow, iter->plimit);
  if (iter->pnext != 0 && iter->pnext < pnow) return 0;

  return GetValue(pnow, value);

}



static BOOL binn_read_next_pair(int expected_type, binn_iter *iter, int *pid, char *pkey, binn *value) {
  int int32, id;
  unsigned char *p, *key;
  unsigned short len;

  if ((iter == 0) || (iter->pnext == 0) || (iter->pnext > iter->plimit) || (iter->current > iter->count) || (iter->type != expected_type)) return 0;

  iter->current++;
  if (iter->current > iter->count) return 0;

  p = iter->pnext;

  switch (expected_type) {
    case 0xE1:
      int32 = read_map_id(&p, iter->plimit);
      if (p > iter->plimit) return 0;
      id = int32;
      if (pid) *pid = id;
      break;
    case 0xE2:
      len = *((unsigned char *)p); p++;
      key = p;
      p += len;
      if (p > iter->plimit) return 0;
      if (pkey) {
        memcpy(pkey, key, len);
        pkey[len] = 0;
      }
      break;
  }

  iter->pnext = AdvanceDataPos(p, iter->plimit);
  if (iter->pnext != 0 && iter->pnext < p) return 0;

  return GetValue(p, value);

}



BOOL binn_map_next(binn_iter *iter, int *pid, binn *value) {

  return binn_read_next_pair(0xE1, iter, pid, 0, value);

}



BOOL binn_object_next(binn_iter *iter, char *pkey, binn *value) {

  return binn_read_next_pair(0xE2, iter, 0, pkey, value);

}




binn * binn_list_next_value(binn_iter *iter) {
  binn *value;

  value = (binn *) binn_malloc(sizeof(binn));

  if (binn_list_next(iter, value) == 0) {
    free_fn(value);
    return 0;
  }

  value->allocated = 1;
  return value;

}



binn * binn_map_next_value(binn_iter *iter, int *pid) {
  binn *value;

  value = (binn *) binn_malloc(sizeof(binn));

  if (binn_map_next(iter, pid, value) == 0) {
    free_fn(value);
    return 0;
  }

  value->allocated = 1;
  return value;

}



binn * binn_object_next_value(binn_iter *iter, char *pkey) {
  binn *value;

  value = (binn *) binn_malloc(sizeof(binn));

  if (binn_object_next(iter, pkey, value) == 0) {
    free_fn(value);
    return 0;
  }

  value->allocated = 1;
  return value;

}




void * binn_list_read_next(binn_iter *iter, int *ptype, int *psize) {
  binn value;

  if (binn_list_next(iter, &value) == 0) return 0;
  if (ptype) *ptype = value.type;
  if (psize) *psize = value.size;

  return store_value(&value);




}



void * binn_map_read_next(binn_iter *iter, int *pid, int *ptype, int *psize) {
  binn value;

  if (binn_map_next(iter, pid, &value) == 0) return 0;
  if (ptype) *ptype = value.type;
  if (psize) *psize = value.size;

  return store_value(&value);




}



void * binn_object_read_next(binn_iter *iter, char *pkey, int *ptype, int *psize) {
  binn value;

  if (binn_object_next(iter, pkey, &value) == 0) return 0;
  if (ptype) *ptype = value.type;
  if (psize) *psize = value.size;

  return store_value(&value);




}






int binn_get_write_storage(int type) {
  int storage_type;

  switch (type) {
    case 0xA6:
    case 0xA7:
      return 0xA0;

    case 0x80061:
      return 0x00;

    default:
      binn_get_type_info(type, &storage_type, 0);
      return storage_type;
  }

}



int binn_get_read_storage(int type) {
  int storage_type;

  switch (type) {






    case 0x80061:
    case 0x01:
    case 0x02:
      return 0x60;
    default:
      binn_get_type_info(type, &storage_type, 0);
      return storage_type;
  }

}



static BOOL GetWriteConvertedData(int *ptype, void **ppvalue, int *psize) {
  int type;
  float f1;
  double d1;
  char pstr[128];

  (void)(pstr);
  (void)(d1);
  (void)(f1);

  type = *ptype;

  if (*ppvalue == 0) {
    switch (type) {
      case 0x00:
      case 0x01:
      case 0x02:
        break;
      case 0xA0:
      case 0xC0:
        if (*psize == 0) break;
      default:
        return 0;
    }
  }

  switch (type) {
# 2090 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
    case 0xA4:
    case 0xA5:





      return 1;
      break;

    case 0xA2:
    case 0xA1:
    case 0xA3:
      return 1;
      break;

    case 0x80061:
      if (**((BOOL**)ppvalue) == 0) {
        type = 0x02;
      } else {
        type = 0x01;
      }
      *ptype = type;
      break;

  }

  return 1;

}



static int type_family(int type) {

  switch (type) {
    case 0xE0:
    case 0xE1:
    case 0xE2:
      return 0xf7;

    case 0x21:
    case 0x41:
    case 0x61:
    case 0x81:
    case 0x20:
    case 0x40:
    case 0x60:
    case 0x80:
      return 0xf2;

    case 0x62:
    case 0x82:

    case 0xA6:

    case 0xA7:
      return 0xf3;

    case 0xA0:
    case 0xB001:
    case 0xB005:
    case 0xB002:
    case 0xB003:
    case 0xB004:
      return 0xf4;

    case 0xC0:
    case 0xD001:
    case 0xD002:
    case 0xD003:
    case 0xD004:
      return 0xf5;

    case 0xA4:
    case 0x83:
    case 0xA2:
    case 0xA3:
    case 0xA1:
      return 0xf4;

    case 0x80061:
      return 0xf6;

    case 0x00:
      return 0xf1;

    default:

      return 0x00;
  }

}



static int int_type(int type) {

  switch (type) {
  case 0x21:
  case 0x41:
  case 0x61:
  case 0x81:
    return 11;

  case 0x20:
  case 0x40:
  case 0x60:
  case 0x80:
    return 22;

  default:
    return 0;
  }

}



static BOOL copy_raw_value(void *psource, void *pdest, int data_store) {

  switch (data_store) {
  case 0x00:
    break;
  case 0x20:
    *((char *) pdest) = *(char *)psource;
    break;
  case 0x40:
    *((short *) pdest) = *(short *)psource;
    break;
  case 0x60:
    *((int *) pdest) = *(int *)psource;
    break;
  case 0x80:
    *((uint64 *) pdest) = *(uint64 *)psource;
    break;
  case 0xC0:
  case 0xA0:
  case 0xE0:
    *((char **) pdest) = (char *)psource;
    break;
  default:
    return 0;
  }

  return 1;

}



static BOOL copy_int_value(void *psource, void *pdest, int source_type, int dest_type) {
  uint64 vuint64 = 0; int64 vint64 = 0;

  switch (source_type) {
  case 0x21:
    vint64 = *(signed char *)psource;
    break;
  case 0x41:
    vint64 = *(short *)psource;
    break;
  case 0x61:
    vint64 = *(int *)psource;
    break;
  case 0x81:
    vint64 = *(int64 *)psource;
    break;

  case 0x20:
    vuint64 = *(unsigned char *)psource;
    break;
  case 0x40:
    vuint64 = *(unsigned short *)psource;
    break;
  case 0x60:
    vuint64 = *(unsigned int *)psource;
    break;
  case 0x80:
    vuint64 = *(uint64 *)psource;
    break;

  default:
    return 0;
  }




  if ((int_type(source_type) == 22) && (int_type(dest_type) == 11)) {
    if (vuint64 > INT64_MAX) return 0;
    vint64 = vuint64;
  } else if ((int_type(source_type) == 11) && (int_type(dest_type) == 22)) {
    if (vint64 < 0) return 0;
    vuint64 = vint64;
  }


  switch (dest_type) {
  case 0x21:
    if ((vint64 < INT8_MIN) || (vint64 > INT8_MAX)) return 0;
    *(signed char *)pdest = (signed char) vint64;
    break;
  case 0x41:
    if ((vint64 < INT16_MIN) || (vint64 > INT16_MAX)) return 0;
    *(short *)pdest = (short) vint64;
    break;
  case 0x61:
    if ((vint64 < INT32_MIN) || (vint64 > INT32_MAX)) return 0;
    *(int *)pdest = (int) vint64;
    break;
  case 0x81:
    *(int64 *)pdest = vint64;
    break;

  case 0x20:
    if (vuint64 > UINT8_MAX) return 0;
    *(unsigned char *)pdest = (unsigned char) vuint64;
    break;
  case 0x40:
    if (vuint64 > UINT16_MAX) return 0;
    *(unsigned short *)pdest = (unsigned short) vuint64;
    break;
  case 0x60:
    if (vuint64 > UINT32_MAX) return 0;
    *(unsigned int *)pdest = (unsigned int) vuint64;
    break;
  case 0x80:
    *(uint64 *)pdest = vuint64;
    break;

  default:
    return 0;
  }

  return 1;

}



static BOOL copy_float_value(void *psource, void *pdest, int source_type, int dest_type) {

  switch (source_type) {
  case 0x62:
    *(double *)pdest = *(float *)psource;
    break;
  case 0x82:
    *(float *)pdest = (float) *(double *)psource;
    break;
  default:
    return 0;
  }

  return 1;

}



static void zero_value(void *pvalue, int type) {


  switch (binn_get_read_storage(type)) {
  case 0x00:
    break;
  case 0x20:
    *((char *) pvalue) = 0;

    break;
  case 0x40:
    *((short *) pvalue) = 0;

    break;
  case 0x60:
    *((int *) pvalue) = 0;

    break;
  case 0x80:
    *((uint64 *) pvalue) = 0;

    break;
  case 0xC0:
  case 0xA0:
  case 0xE0:
    *(char **)pvalue = 0;
    break;
  }



}



static BOOL copy_value(void *psource, void *pdest, int source_type, int dest_type, int data_store) {

  if (type_family(source_type) != type_family(dest_type)) return 0;

  if ((type_family(source_type) == 0xf2) && (source_type != dest_type)) {
    return copy_int_value(psource, pdest, source_type, dest_type);
  } else if ((type_family(source_type) == 0xf3) && (source_type != dest_type)) {
    return copy_float_value(psource, pdest, source_type, dest_type);
  } else {
    return copy_raw_value(psource, pdest, data_store);
  }

}





BOOL binn_list_add(binn *list, int type, void *pvalue, int size) {

  if (GetWriteConvertedData(&type, &pvalue, &size) == 0) return 0;

  return binn_list_add_raw(list, type, pvalue, size);

}



BOOL binn_map_set(binn *map, int id, int type, void *pvalue, int size) {

  if (GetWriteConvertedData(&type, &pvalue, &size) == 0) return 0;

  return binn_map_set_raw(map, id, type, pvalue, size);

}



BOOL binn_object_set(binn *obj, const char *key, int type, void *pvalue, int size) {

  if (GetWriteConvertedData(&type, &pvalue, &size) == 0) return 0;

  return binn_object_set_raw(obj, key, type, pvalue, size);

}




BOOL binn_add_value(binn *item, int binn_type, int id, char *name, int type, void *pvalue, int size) {

  switch (binn_type) {
    case 0xE0:
      return binn_list_add(item, type, pvalue, size);
    case 0xE1:
      return binn_map_set(item, id, type, pvalue, size);
    case 0xE2:
      return binn_object_set(item, name, type, pvalue, size);
    default:
      return 0;
  }

}




BOOL binn_list_add_new(binn *list, binn *value) {
  BOOL retval;

  retval = binn_list_add_value(list, value);
  if (value) free_fn(value);
  return retval;

}



BOOL binn_map_set_new(binn *map, int id, binn *value) {
  BOOL retval;

  retval = binn_map_set_value(map, id, value);
  if (value) free_fn(value);
  return retval;

}



BOOL binn_object_set_new(binn *obj, const char *key, binn *value) {
  BOOL retval;

  retval = binn_object_set_value(obj, key, value);
  if (value) free_fn(value);
  return retval;

}





binn * binn_list_value(void *ptr, int pos) {
  binn *value;

  value = (binn *) binn_malloc(sizeof(binn));

  if (binn_list_get_value(ptr, pos, value) == 0) {
    free_fn(value);
    return 0;
  }

  value->allocated = 1;
  return value;

}



binn * binn_map_value(void *ptr, int id) {
  binn *value;

  value = (binn *) binn_malloc(sizeof(binn));

  if (binn_map_get_value(ptr, id, value) == 0) {
    free_fn(value);
    return 0;
  }

  value->allocated = 1;
  return value;

}



binn * binn_object_value(void *ptr, const char *key) {
  binn *value;

  value = (binn *) binn_malloc(sizeof(binn));

  if (binn_object_get_value(ptr, key, value) == 0) {
    free_fn(value);
    return 0;
  }

  value->allocated = 1;
  return value;

}




void * binn_list_read(void *list, int pos, int *ptype, int *psize) {
  binn value;

  if (binn_list_get_value(list, pos, &value) == 0) return 0;
  if (ptype) *ptype = value.type;
  if (psize) *psize = value.size;

  return store_value(&value);




}



void * binn_map_read(void *map, int id, int *ptype, int *psize) {
  binn value;

  if (binn_map_get_value(map, id, &value) == 0) return 0;
  if (ptype) *ptype = value.type;
  if (psize) *psize = value.size;

  return store_value(&value);




}



void * binn_object_read(void *obj, const char *key, int *ptype, int *psize) {
  binn value;

  if (binn_object_get_value(obj, key, &value) == 0) return 0;
  if (ptype) *ptype = value.type;
  if (psize) *psize = value.size;

  return store_value(&value);




}




BOOL binn_list_get(void *ptr, int pos, int type, void *pvalue, int *psize) {
  binn value;
  int storage_type;

  storage_type = binn_get_read_storage(type);
  if ((storage_type != 0x00) && (pvalue == 0)) return 0;

  zero_value(pvalue, type);

  if (binn_list_get_value(ptr, pos, &value) == 0) return 0;

  if (copy_value(value.ptr, pvalue, value.type, type, storage_type) == 0) return 0;

  if (psize) *psize = value.size;

  return 1;

}



BOOL binn_map_get(void *ptr, int id, int type, void *pvalue, int *psize) {
  binn value;
  int storage_type;

  storage_type = binn_get_read_storage(type);
  if ((storage_type != 0x00) && (pvalue == 0)) return 0;

  zero_value(pvalue, type);

  if (binn_map_get_value(ptr, id, &value) == 0) return 0;

  if (copy_value(value.ptr, pvalue, value.type, type, storage_type) == 0) return 0;

  if (psize) *psize = value.size;

  return 1;

}





BOOL binn_object_get(void *ptr, const char *key, int type, void *pvalue, int *psize) {
  binn value;
  int storage_type;

  storage_type = binn_get_read_storage(type);
  if ((storage_type != 0x00) && (pvalue == 0)) return 0;

  zero_value(pvalue, type);

  if (binn_object_get_value(ptr, key, &value) == 0) return 0;

  if (copy_value(value.ptr, pvalue, value.type, type, storage_type) == 0) return 0;

  if (psize) *psize = value.size;

  return 1;

}
# 2660 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
signed char binn_list_int8(void *list, int pos) {
  signed char value;

  binn_list_get(list, pos, 0x21, &value, 0);

  return value;
}

short binn_list_int16(void *list, int pos) {
  short value;

  binn_list_get(list, pos, 0x41, &value, 0);

  return value;
}

int binn_list_int32(void *list, int pos) {
  int value;

  binn_list_get(list, pos, 0x61, &value, 0);

  return value;
}

int64 binn_list_int64(void *list, int pos) {
  int64 value;

  binn_list_get(list, pos, 0x81, &value, 0);

  return value;
}

unsigned char binn_list_uint8(void *list, int pos) {
  unsigned char value;

  binn_list_get(list, pos, 0x20, &value, 0);

  return value;
}

unsigned short binn_list_uint16(void *list, int pos) {
  unsigned short value;

  binn_list_get(list, pos, 0x40, &value, 0);

  return value;
}

unsigned int binn_list_uint32(void *list, int pos) {
  unsigned int value;

  binn_list_get(list, pos, 0x60, &value, 0);

  return value;
}

uint64 binn_list_uint64(void *list, int pos) {
  uint64 value;

  binn_list_get(list, pos, 0x80, &value, 0);

  return value;
}

float binn_list_float(void *list, int pos) {
  float value;

  binn_list_get(list, pos, 0x62, &value, 0);

  return value;
}

double binn_list_double(void *list, int pos) {
  double value;

  binn_list_get(list, pos, 0x82, &value, 0);

  return value;
}

BOOL binn_list_bool(void *list, int pos) {
  BOOL value;

  binn_list_get(list, pos, 0x80061, &value, 0);

  return value;
}

BOOL binn_list_null(void *list, int pos) {

  return binn_list_get(list, pos, 0x00, 0, 0);

}

char * binn_list_str(void *list, int pos) {
  char *value;

  binn_list_get(list, pos, 0xA0, &value, 0);

  return value;
}

void * binn_list_blob(void *list, int pos, int *psize) {
  void *value;

  binn_list_get(list, pos, 0xC0, &value, psize);

  return value;
}

void * binn_list_list(void *list, int pos) {
  void *value;

  binn_list_get(list, pos, 0xE0, &value, 0);

  return value;
}

void * binn_list_map(void *list, int pos) {
  void *value;

  binn_list_get(list, pos, 0xE1, &value, 0);

  return value;
}

void * binn_list_object(void *list, int pos) {
  void *value;

  binn_list_get(list, pos, 0xE2, &value, 0);

  return value;
}



signed char binn_map_int8(void *map, int id) {
  signed char value;

  binn_map_get(map, id, 0x21, &value, 0);

  return value;
}

short binn_map_int16(void *map, int id) {
  short value;

  binn_map_get(map, id, 0x41, &value, 0);

  return value;
}

int binn_map_int32(void *map, int id) {
  int value;

  binn_map_get(map, id, 0x61, &value, 0);

  return value;
}

int64 binn_map_int64(void *map, int id) {
  int64 value;

  binn_map_get(map, id, 0x81, &value, 0);

  return value;
}

unsigned char binn_map_uint8(void *map, int id) {
  unsigned char value;

  binn_map_get(map, id, 0x20, &value, 0);

  return value;
}

unsigned short binn_map_uint16(void *map, int id) {
  unsigned short value;

  binn_map_get(map, id, 0x40, &value, 0);

  return value;
}

unsigned int binn_map_uint32(void *map, int id) {
  unsigned int value;

  binn_map_get(map, id, 0x60, &value, 0);

  return value;
}

uint64 binn_map_uint64(void *map, int id) {
  uint64 value;

  binn_map_get(map, id, 0x80, &value, 0);

  return value;
}

float binn_map_float(void *map, int id) {
  float value;

  binn_map_get(map, id, 0x62, &value, 0);

  return value;
}

double binn_map_double(void *map, int id) {
  double value;

  binn_map_get(map, id, 0x82, &value, 0);

  return value;
}

BOOL binn_map_bool(void *map, int id) {
  BOOL value;

  binn_map_get(map, id, 0x80061, &value, 0);

  return value;
}

BOOL binn_map_null(void *map, int id) {

  return binn_map_get(map, id, 0x00, 0, 0);

}

char * binn_map_str(void *map, int id) {
  char *value;

  binn_map_get(map, id, 0xA0, &value, 0);

  return value;
}

void * binn_map_blob(void *map, int id, int *psize) {
  void *value;

  binn_map_get(map, id, 0xC0, &value, psize);

  return value;
}

void * binn_map_list(void *map, int id) {
  void *value;

  binn_map_get(map, id, 0xE0, &value, 0);

  return value;
}

void * binn_map_map(void *map, int id) {
  void *value;

  binn_map_get(map, id, 0xE1, &value, 0);

  return value;
}

void * binn_map_object(void *map, int id) {
  void *value;

  binn_map_get(map, id, 0xE2, &value, 0);

  return value;
}



signed char binn_object_int8(void *obj, const char *key) {
  signed char value;

  binn_object_get(obj, key, 0x21, &value, 0);

  return value;
}

short binn_object_int16(void *obj, const char *key) {
  short value;

  binn_object_get(obj, key, 0x41, &value, 0);

  return value;
}

int binn_object_int32(void *obj, const char *key) {
  int value;

  binn_object_get(obj, key, 0x61, &value, 0);

  return value;
}

int64 binn_object_int64(void *obj, const char *key) {
  int64 value;

  binn_object_get(obj, key, 0x81, &value, 0);

  return value;
}

unsigned char binn_object_uint8(void *obj, const char *key) {
  unsigned char value;

  binn_object_get(obj, key, 0x20, &value, 0);

  return value;
}

unsigned short binn_object_uint16(void *obj, const char *key) {
  unsigned short value;

  binn_object_get(obj, key, 0x40, &value, 0);

  return value;
}

unsigned int binn_object_uint32(void *obj, const char *key) {
  unsigned int value;

  binn_object_get(obj, key, 0x60, &value, 0);

  return value;
}

uint64 binn_object_uint64(void *obj, const char *key) {
  uint64 value;

  binn_object_get(obj, key, 0x80, &value, 0);

  return value;
}

float binn_object_float(void *obj, const char *key) {
  float value;

  binn_object_get(obj, key, 0x62, &value, 0);

  return value;
}

double binn_object_double(void *obj, const char *key) {
  double value;

  binn_object_get(obj, key, 0x82, &value, 0);

  return value;
}

BOOL binn_object_bool(void *obj, const char *key) {
  BOOL value;

  binn_object_get(obj, key, 0x80061, &value, 0);

  return value;
}

BOOL binn_object_null(void *obj, const char *key) {

  return binn_object_get(obj, key, 0x00, 0, 0);

}

char * binn_object_str(void *obj, const char *key) {
  char *value;

  binn_object_get(obj, key, 0xA0, &value, 0);

  return value;
}

void * binn_object_blob(void *obj, const char *key, int *psize) {
  void *value;

  binn_object_get(obj, key, 0xC0, &value, psize);

  return value;
}

void * binn_object_list(void *obj, const char *key) {
  void *value;

  binn_object_get(obj, key, 0xE0, &value, 0);

  return value;
}

void * binn_object_map(void *obj, const char *key) {
  void *value;

  binn_object_get(obj, key, 0xE1, &value, 0);

  return value;
}

void * binn_object_object(void *obj, const char *key) {
  void *value;

  binn_object_get(obj, key, 0xE2, &value, 0);

  return value;
}




static binn * binn_alloc_item() {
  binn *item;
  item = (binn *) binn_malloc(sizeof(binn));
  if (item) {
    memset(item, 0, sizeof(binn));
    item->header = 0x1F22B11F;
    item->allocated = 1;

  }
  return item;
}



binn * binn_value(int type, void *pvalue, int size, binn_mem_free freefn) {
  int storage_type;
  binn *item = binn_alloc_item();
  if (item) {
    item->type = type;
    binn_get_type_info(type, &storage_type, 0);
    switch (storage_type) {
    case 0x00:
      break;
    case 0xA0:
      if (size == 0) size = strlen((char*)pvalue) + 1;
    case 0xC0:
    case 0xE0:
      if (freefn == ((binn_mem_free)-1)) {
        item->ptr = binn_memdup(pvalue, size);
        if (item->ptr == 0) {
          free_fn(item);
          return 0;
        }
        item->freefn = free_fn;
        if (storage_type == 0xA0) size--;
      } else {
        item->ptr = pvalue;
        item->freefn = freefn;
      }
      item->size = size;
      break;
    default:
      item->ptr = &item->vint32;
      copy_raw_value(pvalue, item->ptr, storage_type);
    }
  }
  return item;
}



BOOL binn_set_string(binn *item, char *str, binn_mem_free pfree) {

  if (item == 0 || str == 0) return 0;

  if (pfree == ((binn_mem_free)-1)) {
    item->ptr = binn_memdup(str, strlen(str) + 1);
    if (item->ptr == 0) return 0;
    item->freefn = free_fn;
  } else {
    item->ptr = str;
    item->freefn = pfree;
  }

  item->type = 0xA0;
  return 1;

}



BOOL binn_set_blob(binn *item, void *ptr, int size, binn_mem_free pfree) {

  if (item == 0 || ptr == 0) return 0;

  if (pfree == ((binn_mem_free)-1)) {
    item->ptr = binn_memdup(ptr, size);
    if (item->ptr == 0) return 0;
    item->freefn = free_fn;
  } else {
    item->ptr = ptr;
    item->freefn = pfree;
  }

  item->type = 0xC0;
  item->size = size;
  return 1;

}
# 3166 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
int64 atoi64(char *str) {
  int64 retval;
  int is_negative=0;

  if (*str == '-') {
    is_negative = 1;
    str++;
  }
  retval = 0;
  for (; *str; str++) {
    retval = 10 * retval + (*str - '0');
  }
  if (is_negative) retval *= -1;
  return retval;
}




static BOOL is_integer(char *p) {
  BOOL retval;

  if (p == 0) return 0;
  if (*p == '-') p++;
  if (*p == 0) return 0;

  retval = 1;

  for (; *p; p++) {
    if ( (*p < '0') || (*p > '9') ) {
      retval = 0;
    }
  }

  return retval;
}



static BOOL is_float(char *p) {
  BOOL retval, number_found=0;

  if (p == 0) return 0;
  if (*p == '-') p++;
  if (*p == 0) return 0;

  retval = 1;

  for (; *p; p++) {
    if ((*p == '.') || (*p == ',')) {
      if (!number_found) retval = 0;
    } else if ( (*p >= '0') && (*p <= '9') ) {
      number_found = 1;
    } else {
      return 0;
    }
  }

  return retval;
}



static BOOL is_bool_str(char *str, BOOL *pbool) {
  int64 vint;
  double vdouble;

  if (str == 0 || pbool == 0) return 0;

  if (strcasecmp(str, "true") == 0) goto loc_true;
  if (strcasecmp(str, "yes") == 0) goto loc_true;
  if (strcasecmp(str, "on") == 0) goto loc_true;


  if (strcasecmp(str, "false") == 0) goto loc_false;
  if (strcasecmp(str, "no") == 0) goto loc_false;
  if (strcasecmp(str, "off") == 0) goto loc_false;


  if (is_integer(str)) {
    vint = atoi64(str);
    *pbool = (vint != 0) ? 1 : 0;
    return 1;
  } else if (is_float(str)) {
    vdouble = atof(str);
    *pbool = (vdouble != 0) ? 1 : 0;
    return 1;
  }

  return 0;

loc_true:
  *pbool = 1;
  return 1;

loc_false:
  *pbool = 0;
  return 1;

}



BOOL binn_get_int32(binn *value, int *pint) {

  if (value == 0 || pint == 0) return 0;

  if (type_family(value->type) == 0xf2) {
    return copy_int_value(value->ptr, pint, value->type, 0x61);
  }

  switch (value->type) {
  case 0x62:
    if ((value->vfloat < INT32_MIN) || (value->vfloat > INT32_MAX)) return 0;
    *pint = value->vfloat >= 0.0 ? (int)(value->vfloat + 0.5) : ((value->vfloat - (double)(int)value->vfloat) <= -0.5 ? (int)value->vfloat : (int)(value->vfloat - 0.5));
    break;
  case 0x82:
    if ((value->vdouble < INT32_MIN) || (value->vdouble > INT32_MAX)) return 0;
    *pint = value->vdouble >= 0.0 ? (int)(value->vdouble + 0.5) : ((value->vdouble - (double)(int)value->vdouble) <= -0.5 ? (int)value->vdouble : (int)(value->vdouble - 0.5));
    break;
  case 0xA0:
    if (is_integer((char*)value->ptr))
      *pint = atoi((char*)value->ptr);
    else if (is_float((char*)value->ptr))
      *pint = atof((char*)value->ptr) >= 0.0 ? (int)(atof((char*)value->ptr) + 0.5) : ((atof((char*)value->ptr) - (double)(int)atof((char*)value->ptr)) <= -0.5 ? (int)atof((char*)value->ptr) : (int)(atof((char*)value->ptr) - 0.5));
    else
      return 0;
    break;
  case 0x80061:
    *pint = value->vbool;
    break;
  default:
    return 0;
  }

  return 1;
}



BOOL binn_get_int64(binn *value, int64 *pint) {

  if (value == 0 || pint == 0) return 0;

  if (type_family(value->type) == 0xf2) {
    return copy_int_value(value->ptr, pint, value->type, 0x81);
  }

  switch (value->type) {
  case 0x62:
    if ((value->vfloat < INT64_MIN) || (value->vfloat > INT64_MAX)) return 0;
    *pint = value->vfloat >= 0.0 ? (int)(value->vfloat + 0.5) : ((value->vfloat - (double)(int)value->vfloat) <= -0.5 ? (int)value->vfloat : (int)(value->vfloat - 0.5));
    break;
  case 0x82:
    if ((value->vdouble < INT64_MIN) || (value->vdouble > INT64_MAX)) return 0;
    *pint = value->vdouble >= 0.0 ? (int)(value->vdouble + 0.5) : ((value->vdouble - (double)(int)value->vdouble) <= -0.5 ? (int)value->vdouble : (int)(value->vdouble - 0.5));
    break;
  case 0xA0:
    if (is_integer((char*)value->ptr))
      *pint = atoi64((char*)value->ptr);
    else if (is_float((char*)value->ptr))
      *pint = atof((char*)value->ptr) >= 0.0 ? (int)(atof((char*)value->ptr) + 0.5) : ((atof((char*)value->ptr) - (double)(int)atof((char*)value->ptr)) <= -0.5 ? (int)atof((char*)value->ptr) : (int)(atof((char*)value->ptr) - 0.5));
    else
      return 0;
    break;
  case 0x80061:
    *pint = value->vbool;
    break;
  default:
    return 0;
  }

  return 1;
}



BOOL binn_get_double(binn *value, double *pfloat) {
  int64 vint;

  if (value == 0 || pfloat == 0) return 0;

  if (type_family(value->type) == 0xf2) {
    if (copy_int_value(value->ptr, &vint, value->type, 0x81) == 0) return 0;
    *pfloat = (double) vint;
    return 1;
  }

  switch (value->type) {
  case 0x62:
    *pfloat = value->vfloat;
    break;
  case 0x82:
    *pfloat = value->vdouble;
    break;
  case 0xA0:
    if (is_integer((char*)value->ptr))
      *pfloat = (double) atoi64((char*)value->ptr);
    else if (is_float((char*)value->ptr))
      *pfloat = atof((char*)value->ptr);
    else
      return 0;
    break;
  case 0x80061:
    *pfloat = value->vbool;
    break;
  default:
    return 0;
  }

  return 1;
}



BOOL binn_get_bool(binn *value, BOOL *pbool) {
  int64 vint;

  if (value == 0 || pbool == 0) return 0;

  if (type_family(value->type) == 0xf2) {
    if (copy_int_value(value->ptr, &vint, value->type, 0x81) == 0) return 0;
    *pbool = (vint != 0) ? 1 : 0;
    return 1;
  }

  switch (value->type) {
  case 0x80061:
    *pbool = value->vbool;
    break;
  case 0x62:
    *pbool = (value->vfloat != 0) ? 1 : 0;
    break;
  case 0x82:
    *pbool = (value->vdouble != 0) ? 1 : 0;
    break;
  case 0xA0:
    return is_bool_str((char*)value->ptr, pbool);
  default:
    return 0;
  }

  return 1;
}



char * binn_get_str(binn *value) {
  int64 vint;
  char buf[128];

  if (value == 0) return 0;

  if (type_family(value->type) == 0xf2) {
    if (copy_int_value(value->ptr, &vint, value->type, 0x81) == 0) return 0;
    snprintf(buf, sizeof buf, "%" "lli", vint);
    goto loc_convert_value;
  }

  switch (value->type) {
  case 0x62:
    value->vdouble = value->vfloat;
  case 0x82:
    snprintf(buf, sizeof buf, "%g", value->vdouble);
    goto loc_convert_value;
  case 0xA0:
    return (char*) value->ptr;
  case 0x80061:
    if (value->vbool)
      strcpy(buf, "true");
    else
      strcpy(buf, "false");
    goto loc_convert_value;
  }

  return 0;

loc_convert_value:


  value->ptr = strdup(buf);
  if (value->ptr == 0) return 0;
  value->freefn = free;
  value->type = 0xA0;
  return (char*) value->ptr;

}





BOOL binn_is_container(binn *item) {

  if (item == 0) return 0;

  switch (item->type) {
  case 0xE0:
  case 0xE1:
  case 0xE2:
    return 1;
  default:
    return 0;
  }

}
# 0 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 1
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 2
# 2 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 3 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdint.h" 1
# 4 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/string.h" 1
# 5 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/memory.h" 1
# 6 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.h" 1
# 33 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.h"
typedef int BOOL;
# 67 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.h"
  typedef long long int int64;
  typedef unsigned long long int uint64;
# 199 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.h"
typedef void (*binn_mem_free)(void*);







struct binn_struct {
  int header;
  BOOL allocated;
  BOOL writable;
  BOOL dirty;

  void *pbuf;
  BOOL pre_allocated;
  int alloc_size;
  int used_size;

  int type;
  void *ptr;
  int size;
  int count;

  binn_mem_free freefn;

  union {
    signed char vint8;
    signed short vint16;
    signed int vint32;
    int64 vint64;
    unsigned char vuint8;
    unsigned short vuint16;
    unsigned int vuint32;
    uint64 vuint64;

    signed char vchar;
    unsigned char vuchar;
    signed short vshort;
    unsigned short vushort;
    signed int vint;
    unsigned int vuint;

    float vfloat;
    double vdouble;

    BOOL vbool;
  };

  BOOL disable_int_compression;
};

typedef struct binn_struct binn;





char * binn_version();

void binn_set_alloc_functions(void* (*new_malloc)(size_t), void* (*new_realloc)(void*,size_t), void (*new_free)(void*));

int binn_create_type(int storage_type, int data_type_index);
BOOL binn_get_type_info(int long_type, int *pstorage_type, int *pextra_type);

int binn_get_write_storage(int type);
int binn_get_read_storage(int type);

BOOL binn_is_container(binn *item);





binn * binn_new(int type, int size, void *buffer);
binn * binn_list();
binn * binn_map();
binn * binn_object();


BOOL binn_create(binn *item, int type, int size, void *buffer);
BOOL binn_create_list(binn *list);
BOOL binn_create_map(binn *map);
BOOL binn_create_object(binn *object);


binn * binn_copy(void *old);


BOOL binn_list_add_new(binn *list, binn *value);
BOOL binn_map_set_new(binn *map, int id, binn *value);
BOOL binn_object_set_new(binn *obj, const char *key, binn *value);




BOOL binn_list_add(binn *list, int type, void *pvalue, int size);
BOOL binn_map_set(binn *map, int id, int type, void *pvalue, int size);
BOOL binn_object_set(binn *obj, const char *key, int type, void *pvalue, int size);




void binn_free(binn *item);
void * binn_release(binn *item);




binn * binn_value(int type, void *pvalue, int size, binn_mem_free freefn);

static inline binn * binn_int8(signed char value) {
  return binn_value(0x21, &value, 0, 0);
}
static inline binn * binn_int16(short value) {
  return binn_value(0x41, &value, 0, 0);
}
static inline binn * binn_int32(int value) {
  return binn_value(0x61, &value, 0, 0);
}
static inline binn * binn_int64(int64 value) {
  return binn_value(0x81, &value, 0, 0);
}
static inline binn * binn_uint8(unsigned char value) {
  return binn_value(0x20, &value, 0, 0);
}
static inline binn * binn_uint16(unsigned short value) {
  return binn_value(0x40, &value, 0, 0);
}
static inline binn * binn_uint32(unsigned int value) {
  return binn_value(0x60, &value, 0, 0);
}
static inline binn * binn_uint64(uint64 value) {
  return binn_value(0x80, &value, 0, 0);
}
static inline binn * binn_float(float value) {
  return binn_value(0x62, &value, 0, 0);
}
static inline binn * binn_double(double value) {
  return binn_value(0x82, &value, 0, 0);
}
static inline binn * binn_bool(BOOL value) {
  return binn_value(0x80061, &value, 0, 0);
}
static inline binn * binn_null() {
  return binn_value(0x00, 0, 0, 0);
}
static inline binn * binn_string(char *str, binn_mem_free freefn) {
  return binn_value(0xA0, str, 0, freefn);
}
static inline binn * binn_blob(void *ptr, int size, binn_mem_free freefn) {
  return binn_value(0xC0, ptr, size, freefn);
}





void * binn_ptr(void *ptr);
int binn_size(void *ptr);
int binn_type(void *ptr);
int binn_count(void *ptr);

BOOL binn_is_valid(void *ptr, int *ptype, int *pcount, int *psize);






BOOL binn_is_valid_ex(void *ptr, int *ptype, int *pcount, int *psize);
# 378 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.h"
BOOL binn_is_struct(void *ptr);




BOOL binn_load(void *data, binn *item);
binn * binn_open(void *data);




signed char binn_list_int8(void *list, int pos);
short binn_list_int16(void *list, int pos);
int binn_list_int32(void *list, int pos);
int64 binn_list_int64(void *list, int pos);
unsigned char binn_list_uint8(void *list, int pos);
unsigned short binn_list_uint16(void *list, int pos);
unsigned int binn_list_uint32(void *list, int pos);
uint64 binn_list_uint64(void *list, int pos);
float binn_list_float(void *list, int pos);
double binn_list_double(void *list, int pos);
BOOL binn_list_bool(void *list, int pos);
BOOL binn_list_null(void *list, int pos);
char * binn_list_str(void *list, int pos);
void * binn_list_blob(void *list, int pos, int *psize);
void * binn_list_list(void *list, int pos);
void * binn_list_map(void *list, int pos);
void * binn_list_object(void *list, int pos);

signed char binn_map_int8(void *map, int id);
short binn_map_int16(void *map, int id);
int binn_map_int32(void *map, int id);
int64 binn_map_int64(void *map, int id);
unsigned char binn_map_uint8(void *map, int id);
unsigned short binn_map_uint16(void *map, int id);
unsigned int binn_map_uint32(void *map, int id);
uint64 binn_map_uint64(void *map, int id);
float binn_map_float(void *map, int id);
double binn_map_double(void *map, int id);
BOOL binn_map_bool(void *map, int id);
BOOL binn_map_null(void *map, int id);
char * binn_map_str(void *map, int id);
void * binn_map_blob(void *map, int id, int *psize);
void * binn_map_list(void *map, int id);
void * binn_map_map(void *map, int id);
void * binn_map_object(void *map, int id);

signed char binn_object_int8(void *obj, const char *key);
short binn_object_int16(void *obj, const char *key);
int binn_object_int32(void *obj, const char *key);
int64 binn_object_int64(void *obj, const char *key);
unsigned char binn_object_uint8(void *obj, const char *key);
unsigned short binn_object_uint16(void *obj, const char *key);
unsigned int binn_object_uint32(void *obj, const char *key);
uint64 binn_object_uint64(void *obj, const char *key);
float binn_object_float(void *obj, const char *key);
double binn_object_double(void *obj, const char *key);
BOOL binn_object_bool(void *obj, const char *key);
BOOL binn_object_null(void *obj, const char *key);
char * binn_object_str(void *obj, const char *key);
void * binn_object_blob(void *obj, const char *key, int *psize);
void * binn_object_list(void *obj, const char *key);
void * binn_object_map(void *obj, const char *key);
void * binn_object_object(void *obj, const char *key);



binn * binn_list_value(void *list, int pos);
binn * binn_map_value(void *map, int id);
binn * binn_object_value(void *obj, const char *key);


BOOL binn_list_get_value(void* list, int pos, binn *value);
BOOL binn_map_get_value(void* map, int id, binn *value);
BOOL binn_object_get_value(void *obj, const char *key, binn *value);


BOOL binn_list_get(void *list, int pos, int type, void *pvalue, int *psize);
BOOL binn_map_get(void *map, int id, int type, void *pvalue, int *psize);
BOOL binn_object_get(void *obj, const char *key, int type, void *pvalue, int *psize);





void * binn_list_read(void *list, int pos, int *ptype, int *psize);
void * binn_map_read(void *map, int id, int *ptype, int *psize);
void * binn_object_read(void *obj, const char *key, int *ptype, int *psize);







BOOL binn_map_get_pair(void *map, int pos, int *pid, binn *value);
BOOL binn_object_get_pair(void *obj, int pos, char *pkey, binn *value);


binn * binn_map_pair(void *map, int pos, int *pid);
binn * binn_object_pair(void *obj, int pos, char *pkey);





void * binn_map_read_pair(void *ptr, int pos, int *pid, int *ptype, int *psize);
void * binn_object_read_pair(void *ptr, int pos, char *pkey, int *ptype, int *psize);




typedef struct binn_iter_struct {
    unsigned char *pnext;
    unsigned char *plimit;
    int type;
    int count;
    int current;
} binn_iter;

BOOL binn_iter_init(binn_iter *iter, void *pbuf, int type);


binn * binn_list_next_value(binn_iter *iter);
binn * binn_map_next_value(binn_iter *iter, int *pid);
binn * binn_object_next_value(binn_iter *iter, char *pkey);


BOOL binn_list_next(binn_iter *iter, binn *value);
BOOL binn_map_next(binn_iter *iter, int *pid, binn *value);
BOOL binn_object_next(binn_iter *iter, char *pkey, binn *value);





void * binn_list_read_next(binn_iter *iter, int *ptype, int *psize);
void * binn_map_read_next(binn_iter *iter, int *pid, int *ptype, int *psize);
void * binn_object_read_next(binn_iter *iter, char *pkey, int *ptype, int *psize);
# 542 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.h"
BOOL binn_set_string(binn *item, char *str, binn_mem_free pfree);
BOOL binn_set_blob(binn *item, void *ptr, int size, binn_mem_free pfree);
# 575 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.h"
static inline BOOL binn_list_add_int8(binn *list, signed char value) {
  return binn_list_add(list, 0x21, &value, 0);
}
static inline BOOL binn_list_add_int16(binn *list, short value) {
  return binn_list_add(list, 0x41, &value, 0);
}
static inline BOOL binn_list_add_int32(binn *list, int value) {
  return binn_list_add(list, 0x61, &value, 0);
}
static inline BOOL binn_list_add_int64(binn *list, int64 value) {
  return binn_list_add(list, 0x81, &value, 0);
}
static inline BOOL binn_list_add_uint8(binn *list, unsigned char value) {
  return binn_list_add(list, 0x20, &value, 0);
}
static inline BOOL binn_list_add_uint16(binn *list, unsigned short value) {
  return binn_list_add(list, 0x40, &value, 0);
}
static inline BOOL binn_list_add_uint32(binn *list, unsigned int value) {
  return binn_list_add(list, 0x60, &value, 0);
}
static inline BOOL binn_list_add_uint64(binn *list, uint64 value) {
  return binn_list_add(list, 0x80, &value, 0);
}
static inline BOOL binn_list_add_float(binn *list, float value) {
  return binn_list_add(list, 0x62, &value, 0);
}
static inline BOOL binn_list_add_double(binn *list, double value) {
  return binn_list_add(list, 0x82, &value, 0);
}
static inline BOOL binn_list_add_bool(binn *list, BOOL value) {
  return binn_list_add(list, 0x80061, &value, 0);
}
static inline BOOL binn_list_add_null(binn *list) {
  return binn_list_add(list, 0x00, 0, 0);
}
static inline BOOL binn_list_add_str(binn *list, char *str) {
  return binn_list_add(list, 0xA0, str, 0);
}
static inline BOOL binn_list_add_blob(binn *list, void *ptr, int size) {
  return binn_list_add(list, 0xC0, ptr, size);
}
static inline BOOL binn_list_add_list(binn *list, void *list2) {
  return binn_list_add(list, 0xE0, binn_ptr(list2), binn_size(list2));
}
static inline BOOL binn_list_add_map(binn *list, void *map) {
  return binn_list_add(list, 0xE1, binn_ptr(map), binn_size(map));
}
static inline BOOL binn_list_add_object(binn *list, void *obj) {
  return binn_list_add(list, 0xE2, binn_ptr(obj), binn_size(obj));
}
static inline BOOL binn_list_add_value(binn *list, binn *value) {
  return binn_list_add(list, value->type, binn_ptr(value), binn_size(value));
}



static inline BOOL binn_map_set_int8(binn *map, int id, signed char value) {
  return binn_map_set(map, id, 0x21, &value, 0);
}
static inline BOOL binn_map_set_int16(binn *map, int id, short value) {
  return binn_map_set(map, id, 0x41, &value, 0);
}
static inline BOOL binn_map_set_int32(binn *map, int id, int value) {
  return binn_map_set(map, id, 0x61, &value, 0);
}
static inline BOOL binn_map_set_int64(binn *map, int id, int64 value) {
  return binn_map_set(map, id, 0x81, &value, 0);
}
static inline BOOL binn_map_set_uint8(binn *map, int id, unsigned char value) {
  return binn_map_set(map, id, 0x20, &value, 0);
}
static inline BOOL binn_map_set_uint16(binn *map, int id, unsigned short value) {
  return binn_map_set(map, id, 0x40, &value, 0);
}
static inline BOOL binn_map_set_uint32(binn *map, int id, unsigned int value) {
  return binn_map_set(map, id, 0x60, &value, 0);
}
static inline BOOL binn_map_set_uint64(binn *map, int id, uint64 value) {
  return binn_map_set(map, id, 0x80, &value, 0);
}
static inline BOOL binn_map_set_float(binn *map, int id, float value) {
  return binn_map_set(map, id, 0x62, &value, 0);
}
static inline BOOL binn_map_set_double(binn *map, int id, double value) {
  return binn_map_set(map, id, 0x82, &value, 0);
}
static inline BOOL binn_map_set_bool(binn *map, int id, BOOL value) {
  return binn_map_set(map, id, 0x80061, &value, 0);
}
static inline BOOL binn_map_set_null(binn *map, int id) {
  return binn_map_set(map, id, 0x00, 0, 0);
}
static inline BOOL binn_map_set_str(binn *map, int id, char *str) {
  return binn_map_set(map, id, 0xA0, str, 0);
}
static inline BOOL binn_map_set_blob(binn *map, int id, void *ptr, int size) {
  return binn_map_set(map, id, 0xC0, ptr, size);
}
static inline BOOL binn_map_set_list(binn *map, int id, void *list) {
  return binn_map_set(map, id, 0xE0, binn_ptr(list), binn_size(list));
}
static inline BOOL binn_map_set_map(binn *map, int id, void *map2) {
  return binn_map_set(map, id, 0xE1, binn_ptr(map2), binn_size(map2));
}
static inline BOOL binn_map_set_object(binn *map, int id, void *obj) {
  return binn_map_set(map, id, 0xE2, binn_ptr(obj), binn_size(obj));
}
static inline BOOL binn_map_set_value(binn *map, int id, binn *value) {
  return binn_map_set(map, id, value->type, binn_ptr(value), binn_size(value));
}



static inline BOOL binn_object_set_int8(binn *obj, const char *key, signed char value) {
  return binn_object_set(obj, key, 0x21, &value, 0);
}
static inline BOOL binn_object_set_int16(binn *obj, const char *key, short value) {
  return binn_object_set(obj, key, 0x41, &value, 0);
}
static inline BOOL binn_object_set_int32(binn *obj, const char *key, int value) {
  return binn_object_set(obj, key, 0x61, &value, 0);
}
static inline BOOL binn_object_set_int64(binn *obj, const char *key, int64 value) {
  return binn_object_set(obj, key, 0x81, &value, 0);
}
static inline BOOL binn_object_set_uint8(binn *obj, const char *key, unsigned char value) {
  return binn_object_set(obj, key, 0x20, &value, 0);
}
static inline BOOL binn_object_set_uint16(binn *obj, const char *key, unsigned short value) {
  return binn_object_set(obj, key, 0x40, &value, 0);
}
static inline BOOL binn_object_set_uint32(binn *obj, const char *key, unsigned int value) {
  return binn_object_set(obj, key, 0x60, &value, 0);
}
static inline BOOL binn_object_set_uint64(binn *obj, const char *key, uint64 value) {
  return binn_object_set(obj, key, 0x80, &value, 0);
}
static inline BOOL binn_object_set_float(binn *obj, const char *key, float value) {
  return binn_object_set(obj, key, 0x62, &value, 0);
}
static inline BOOL binn_object_set_double(binn *obj, const char *key, double value) {
  return binn_object_set(obj, key, 0x82, &value, 0);
}
static inline BOOL binn_object_set_bool(binn *obj, const char *key, BOOL value) {
  return binn_object_set(obj, key, 0x80061, &value, 0);
}
static inline BOOL binn_object_set_null(binn *obj, const char *key) {
  return binn_object_set(obj, key, 0x00, 0, 0);
}
static inline BOOL binn_object_set_str(binn *obj, const char *key, char *str) {
  return binn_object_set(obj, key, 0xA0, str, 0);
}
static inline BOOL binn_object_set_blob(binn *obj, const char *key, void *ptr, int size) {
  return binn_object_set(obj, key, 0xC0, ptr, size);
}
static inline BOOL binn_object_set_list(binn *obj, const char *key, void *list) {
  return binn_object_set(obj, key, 0xE0, binn_ptr(list), binn_size(list));
}
static inline BOOL binn_object_set_map(binn *obj, const char *key, void *map) {
  return binn_object_set(obj, key, 0xE1, binn_ptr(map), binn_size(map));
}
static inline BOOL binn_object_set_object(binn *obj, const char *key, void *obj2) {
  return binn_object_set(obj, key, 0xE2, binn_ptr(obj2), binn_size(obj2));
}
static inline BOOL binn_object_set_value(binn *obj, const char *key, binn *value) {
  return binn_object_set(obj, key, value->type, binn_ptr(value), binn_size(value));
}





static inline BOOL binn_list_get_int8(void *list, int pos, signed char *pvalue) {
  return binn_list_get(list, pos, 0x21, pvalue, 0);
}
static inline BOOL binn_list_get_int16(void *list, int pos, short *pvalue) {
  return binn_list_get(list, pos, 0x41, pvalue, 0);
}
static inline BOOL binn_list_get_int32(void *list, int pos, int *pvalue) {
  return binn_list_get(list, pos, 0x61, pvalue, 0);
}
static inline BOOL binn_list_get_int64(void *list, int pos, int64 *pvalue) {
  return binn_list_get(list, pos, 0x81, pvalue, 0);
}
static inline BOOL binn_list_get_uint8(void *list, int pos, unsigned char *pvalue) {
  return binn_list_get(list, pos, 0x20, pvalue, 0);
}
static inline BOOL binn_list_get_uint16(void *list, int pos, unsigned short *pvalue) {
  return binn_list_get(list, pos, 0x40, pvalue, 0);
}
static inline BOOL binn_list_get_uint32(void *list, int pos, unsigned int *pvalue) {
  return binn_list_get(list, pos, 0x60, pvalue, 0);
}
static inline BOOL binn_list_get_uint64(void *list, int pos, uint64 *pvalue) {
  return binn_list_get(list, pos, 0x80, pvalue, 0);
}
static inline BOOL binn_list_get_float(void *list, int pos, float *pvalue) {
  return binn_list_get(list, pos, 0x62, pvalue, 0);
}
static inline BOOL binn_list_get_double(void *list, int pos, double *pvalue) {
  return binn_list_get(list, pos, 0x82, pvalue, 0);
}
static inline BOOL binn_list_get_bool(void *list, int pos, BOOL *pvalue) {
  return binn_list_get(list, pos, 0x80061, pvalue, 0);
}
static inline BOOL binn_list_get_str(void *list, int pos, char **pvalue) {
  return binn_list_get(list, pos, 0xA0, pvalue, 0);
}
static inline BOOL binn_list_get_blob(void *list, int pos, void **pvalue, int *psize) {
  return binn_list_get(list, pos, 0xC0, pvalue, psize);
}
static inline BOOL binn_list_get_list(void *list, int pos, void **pvalue) {
  return binn_list_get(list, pos, 0xE0, pvalue, 0);
}
static inline BOOL binn_list_get_map(void *list, int pos, void **pvalue) {
  return binn_list_get(list, pos, 0xE1, pvalue, 0);
}
static inline BOOL binn_list_get_object(void *list, int pos, void **pvalue) {
  return binn_list_get(list, pos, 0xE2, pvalue, 0);
}



static inline BOOL binn_map_get_int8(void *map, int id, signed char *pvalue) {
  return binn_map_get(map, id, 0x21, pvalue, 0);
}
static inline BOOL binn_map_get_int16(void *map, int id, short *pvalue) {
  return binn_map_get(map, id, 0x41, pvalue, 0);
}
static inline BOOL binn_map_get_int32(void *map, int id, int *pvalue) {
  return binn_map_get(map, id, 0x61, pvalue, 0);
}
static inline BOOL binn_map_get_int64(void *map, int id, int64 *pvalue) {
  return binn_map_get(map, id, 0x81, pvalue, 0);
}
static inline BOOL binn_map_get_uint8(void *map, int id, unsigned char *pvalue) {
  return binn_map_get(map, id, 0x20, pvalue, 0);
}
static inline BOOL binn_map_get_uint16(void *map, int id, unsigned short *pvalue) {
  return binn_map_get(map, id, 0x40, pvalue, 0);
}
static inline BOOL binn_map_get_uint32(void *map, int id, unsigned int *pvalue) {
  return binn_map_get(map, id, 0x60, pvalue, 0);
}
static inline BOOL binn_map_get_uint64(void *map, int id, uint64 *pvalue) {
  return binn_map_get(map, id, 0x80, pvalue, 0);
}
static inline BOOL binn_map_get_float(void *map, int id, float *pvalue) {
  return binn_map_get(map, id, 0x62, pvalue, 0);
}
static inline BOOL binn_map_get_double(void *map, int id, double *pvalue) {
  return binn_map_get(map, id, 0x82, pvalue, 0);
}
static inline BOOL binn_map_get_bool(void *map, int id, BOOL *pvalue) {
  return binn_map_get(map, id, 0x80061, pvalue, 0);
}
static inline BOOL binn_map_get_str(void *map, int id, char **pvalue) {
  return binn_map_get(map, id, 0xA0, pvalue, 0);
}
static inline BOOL binn_map_get_blob(void *map, int id, void **pvalue, int *psize) {
  return binn_map_get(map, id, 0xC0, pvalue, psize);
}
static inline BOOL binn_map_get_list(void *map, int id, void **pvalue) {
  return binn_map_get(map, id, 0xE0, pvalue, 0);
}
static inline BOOL binn_map_get_map(void *map, int id, void **pvalue) {
  return binn_map_get(map, id, 0xE1, pvalue, 0);
}
static inline BOOL binn_map_get_object(void *map, int id, void **pvalue) {
  return binn_map_get(map, id, 0xE2, pvalue, 0);
}






static inline BOOL binn_object_get_int8(void *obj, const char *key, signed char *pvalue) {
  return binn_object_get(obj, key, 0x21, pvalue, 0);
}
static inline BOOL binn_object_get_int16(void *obj, const char *key, short *pvalue) {
  return binn_object_get(obj, key, 0x41, pvalue, 0);
}
static inline BOOL binn_object_get_int32(void *obj, const char *key, int *pvalue) {
  return binn_object_get(obj, key, 0x61, pvalue, 0);
}
static inline BOOL binn_object_get_int64(void *obj, const char *key, int64 *pvalue) {
  return binn_object_get(obj, key, 0x81, pvalue, 0);
}
static inline BOOL binn_object_get_uint8(void *obj, const char *key, unsigned char *pvalue) {
  return binn_object_get(obj, key, 0x20, pvalue, 0);
}
static inline BOOL binn_object_get_uint16(void *obj, const char *key, unsigned short *pvalue) {
  return binn_object_get(obj, key, 0x40, pvalue, 0);
}
static inline BOOL binn_object_get_uint32(void *obj, const char *key, unsigned int *pvalue) {
  return binn_object_get(obj, key, 0x60, pvalue, 0);
}
static inline BOOL binn_object_get_uint64(void *obj, const char *key, uint64 *pvalue) {
  return binn_object_get(obj, key, 0x80, pvalue, 0);
}
static inline BOOL binn_object_get_float(void *obj, const char *key, float *pvalue) {
  return binn_object_get(obj, key, 0x62, pvalue, 0);
}
static inline BOOL binn_object_get_double(void *obj, const char *key, double *pvalue) {
  return binn_object_get(obj, key, 0x82, pvalue, 0);
}
static inline BOOL binn_object_get_bool(void *obj, const char *key, BOOL *pvalue) {
  return binn_object_get(obj, key, 0x80061, pvalue, 0);
}
static inline BOOL binn_object_get_str(void *obj, const char *key, char **pvalue) {
  return binn_object_get(obj, key, 0xA0, pvalue, 0);
}
static inline BOOL binn_object_get_blob(void *obj, const char *key, void **pvalue, int *psize) {
  return binn_object_get(obj, key, 0xC0, pvalue, psize);
}
static inline BOOL binn_object_get_list(void *obj, const char *key, void **pvalue) {
  return binn_object_get(obj, key, 0xE0, pvalue, 0);
}
static inline BOOL binn_object_get_map(void *obj, const char *key, void **pvalue) {
  return binn_object_get(obj, key, 0xE1, pvalue, 0);
}
static inline BOOL binn_object_get_object(void *obj, const char *key, void **pvalue) {
  return binn_object_get(obj, key, 0xE2, pvalue, 0);
}



BOOL binn_get_int32(binn *value, int *pint);
BOOL binn_get_int64(binn *value, int64 *pint);
BOOL binn_get_double(binn *value, double *pfloat);
BOOL binn_get_bool(binn *value, BOOL *pbool);
char * binn_get_str(binn *value);
# 7 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c" 2
# 22 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
void* (*malloc_fn)(size_t len) = 0;
void* (*realloc_fn)(void *ptr, size_t len) = 0;
void (*free_fn)(void *ptr) = 0;
# 45 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/endian.h" 1
# 46 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c" 2
# 64 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
typedef unsigned short int u16;
typedef unsigned int u32;
typedef unsigned long long int u64;

static void copy_be16(u16 *pdest, u16 *psource) {

  unsigned char *source = (unsigned char *) psource;
  unsigned char *dest = (unsigned char *) pdest;
  dest[0] = source[1];
  dest[1] = source[0];
# 88 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
}

static void copy_be32(u32 *pdest, u32 *psource) {

  unsigned char *source = (unsigned char *) psource;
  unsigned char *dest = (unsigned char *) pdest;
  dest[0] = source[3];
  dest[1] = source[2];
  dest[2] = source[1];
  dest[3] = source[0];
# 114 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
}

static void copy_be64(u64 *pdest, u64 *psource) {

  unsigned char *source = (unsigned char *) psource;
  unsigned char *dest = (unsigned char *) pdest;
  int i;
  for (i=0; i < 8; i++) {
    dest[i] = source[7-i];
  }
# 140 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
}
# 149 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
static BOOL IsValidBinnHeader(void *pbuf, int *ptype, int *pcount, int *psize, int *pheadersize);



char * binn_version() {
  return "3.0.0";
}



void binn_set_alloc_functions(void* (*new_malloc)(size_t), void* (*new_realloc)(void*,size_t), void (*new_free)(void*)) {

  malloc_fn = new_malloc;
  realloc_fn = new_realloc;
  free_fn = new_free;

}



static void check_alloc_functions() {

  if (malloc_fn == 0) malloc_fn = &malloc;
  if (realloc_fn == 0) realloc_fn = &realloc;
  if (free_fn == 0) free_fn = &free;

}



static void * binn_malloc(int size) {
  check_alloc_functions();
  return malloc_fn(size);
}



static void * binn_memdup(void *src, int size) {
  void *dest;

  if (src == 0 || size <= 0) return 0;
  dest = binn_malloc(size);
  if (dest == 0) return 0;
  memcpy(dest, src, size);
  return dest;

}



static size_t strlen2(char *str) {

  if (str == 0) return 0;
  return strlen(str);

}



int binn_create_type(int storage_type, int data_type_index) {
  if (data_type_index < 0) return -1;
  if ((storage_type < 0x00) || (storage_type > 0xE0)) return -1;
  if (data_type_index < 16)
    return storage_type | data_type_index;
  else if (data_type_index < 4096) {
    storage_type |= 0x10;
    storage_type <<= 8;
    data_type_index >>= 4;
    return storage_type | data_type_index;
  } else
    return -1;
}



BOOL binn_get_type_info(int long_type, int *pstorage_type, int *pextra_type) {
  int storage_type, extra_type;
  BOOL retval=1;

again:

  if (long_type < 0) {
    goto loc_invalid;
  } else if (long_type <= 0xff) {
    storage_type = long_type & 0xE0;
    extra_type = long_type & 0x0F;
  } else if (long_type <= 0xffff) {
    storage_type = long_type & 0xE000;
    storage_type >>= 8;
    extra_type = long_type & 0x0FFF;
    extra_type >>= 4;
  } else if (long_type & 0x80000) {


    long_type &= 0xffff;
    goto again;
  } else {
loc_invalid:
    storage_type = -1;
    extra_type = -1;
    retval = 0;
  }

  if (pstorage_type) *pstorage_type = storage_type;
  if (pextra_type) *pextra_type = extra_type;

  return retval;

}



BOOL binn_create(binn *item, int type, int size, void *pointer) {
  BOOL retval=0;

  switch (type) {
    case 0xE0:
    case 0xE1:
    case 0xE2:
      break;
    default:
      goto loc_exit;
  }

  if ((item == 0) || (size < 0)) goto loc_exit;
  if (size < 3) {
    if (pointer) goto loc_exit;
    else size = 0;
  }

  memset(item, 0, sizeof(binn));

  if (pointer) {
    item->pre_allocated = 1;
    item->pbuf = pointer;
    item->alloc_size = size;
  } else {
    item->pre_allocated = 0;
    if (size == 0) size = 256;
    pointer = binn_malloc(size);
    if (pointer == 0) return 0;
    item->pbuf = pointer;
    item->alloc_size = size;
  }

  item->header = 0x1F22B11F;

  item->writable = 1;
  item->used_size = 9;
  item->type = type;

  item->dirty = 1;

  retval = 1;

loc_exit:
  return retval;

}



binn * binn_new(int type, int size, void *pointer) {
  binn *item;

  item = (binn*) binn_malloc(sizeof(binn));

  if (binn_create(item, type, size, pointer) == 0) {
    free_fn(item);
    return 0;
  }

  item->allocated = 1;
  return item;

}



BOOL binn_create_list(binn *list) {

  return binn_create(list, 0xE0, 0, 0);

}



BOOL binn_create_map(binn *map) {

  return binn_create(map, 0xE1, 0, 0);

}



BOOL binn_create_object(binn *object) {

  return binn_create(object, 0xE2, 0, 0);

}



binn * binn_list() {
  return binn_new(0xE0, 0, 0);
}



binn * binn_map() {
  return binn_new(0xE1, 0, 0);
}



binn * binn_object() {
  return binn_new(0xE2, 0, 0);
}



binn * binn_copy(void *old) {
  int type, count, size, header_size;
  unsigned char *old_ptr = binn_ptr(old);
  binn *item;

  size = 0;
  if (!IsValidBinnHeader(old_ptr, &type, &count, &size, &header_size)) return 0;

  item = binn_new(type, size - header_size + 9, 0);
  if( item ){
    unsigned char *dest;
    dest = ((unsigned char *) item->pbuf) + 9;
    memcpy(dest, old_ptr + header_size, size - header_size);
    item->used_size = 9 + size - header_size;
    item->count = count;
  }
  return item;

}



BOOL binn_load(void *data, binn *value) {

  if ((data == 0) || (value == 0)) return 0;
  memset(value, 0, sizeof(binn));
  value->header = 0x1F22B11F;



  if (binn_is_valid(data, &value->type, &value->count, &value->size) == 0) return 0;
  value->ptr = data;
  return 1;

}



binn * binn_open(void *data) {
  binn *item;

  item = (binn*) binn_malloc(sizeof(binn));

  if (binn_load(data, item) == 0) {
    free_fn(item);
    return 0;
  }

  item->allocated = 1;
  return item;

}



static int binn_get_ptr_type(void *ptr) {

  if (ptr == 0) return 0;

  switch (*(unsigned int *)ptr) {
  case 0x1F22B11F:
    return 1;
  default:
    return 2;
  }

}



BOOL binn_is_struct(void *ptr) {

  if (ptr == 0) return 0;

  if ((*(unsigned int *)ptr) == 0x1F22B11F) {
    return 1;
  } else {
    return 0;
  }

}



static int CalcAllocation(int needed_size, int alloc_size) {
  int calc_size;

  calc_size = alloc_size;
  while (calc_size < needed_size) {
    calc_size <<= 1;

  }
  return calc_size;

}



static BOOL CheckAllocation(binn *item, int add_size) {
  int alloc_size;
  void *ptr;

  if (item->used_size + add_size > item->alloc_size) {
    if (item->pre_allocated) return 0;
    alloc_size = CalcAllocation(item->used_size + add_size, item->alloc_size);
    ptr = realloc_fn(item->pbuf, alloc_size);
    if (ptr == 0) return 0;
    item->pbuf = ptr;
    item->alloc_size = alloc_size;
  }

  return 1;

}
# 512 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
static unsigned char * AdvanceDataPos(unsigned char *p, unsigned char *plimit) {
  unsigned char byte;
  int storage_type, DataSize;

  if (p > plimit) return 0;

  byte = *p; p++;
  storage_type = byte & 0xE0;
  if (byte & 0x10) p++;

  switch (storage_type) {
  case 0x00:

    break;
  case 0x20:
    p ++;
    break;
  case 0x40:
    p += 2;
    break;
  case 0x60:
    p += 4;
    break;
  case 0x80:
    p += 8;
    break;
  case 0xC0:
  case 0xA0:
    if (p > plimit) return 0;
    DataSize = *((unsigned char*)p);
    if (DataSize & 0x80) {
      if (p + sizeof(int) - 1 > plimit) return 0;
      copy_be32((u32*)&DataSize, (u32*)p);
      DataSize &= 0x7FFFFFFF;
      p+=4;
    } else {
      p++;
    }
    p += DataSize;
    if (storage_type == 0xA0) {
      p++;
    }
    break;
  case 0xE0:
    if (p > plimit) return 0;
    DataSize = *((unsigned char*)p);
    if (DataSize & 0x80) {
      if (p + sizeof(int) - 1 > plimit) return 0;
      copy_be32((u32*)&DataSize, (u32*)p);
      DataSize &= 0x7FFFFFFF;
    }
    DataSize--;
    p += DataSize;
    break;
  default:
    return 0;
  }

  if (p > plimit) return 0;

  return p;

}
# 592 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
static int read_map_id(unsigned char **pp, unsigned char *plimit) {
  unsigned char *p, c, sign, type;
  int id, extra_bytes;

  p = *pp;

  c = *p++;

  if (c & 0x80) {
    extra_bytes = ((c & 0x60) >> 5) + 1;
    if (p + extra_bytes > plimit ) {
      *pp = p + extra_bytes;
      return 0;
    }
  }

  type = c & 0xE0;
  sign = c & 0x10;

  if ((c & 0x80) == 0) {
    sign = c & 0x40;
    id = c & 0x3F;
  } else if (type == 0x80) {
    id = c & 0x0F;
    id = (id << 8) | *p++;
  } else if (type == 0xA0) {
    id = c & 0x0F;
    id = (id << 8) | *p++;
    id = (id << 8) | *p++;
  } else if (type == 0xC0) {
    id = c & 0x0F;
    id = (id << 8) | *p++;
    id = (id << 8) | *p++;
    id = (id << 8) | *p++;
  } else if (type == 0xE0) {
    copy_be32((u32*)&id, (u32*)p);
    p += 4;
  } else {
    *pp = plimit + 2;
    return 0;
  }

  if (sign) id = -id;

  *pp = p;

  return id;
}



static unsigned char * SearchForID(unsigned char *p, int header_size, int size, int numitems, int id) {
  unsigned char *plimit, *base;
  int i, int32;

  base = p;
  plimit = p + size - 1;
  p += header_size;


  for (i = 0; i < numitems; i++) {
    int32 = read_map_id(&p, plimit);
    if (p > plimit) break;

    if (int32 == id) return p;

    p = AdvanceDataPos(p, plimit);
    if ((p == 0) || (p < base)) break;
  }

  return 0;

}



static unsigned char * SearchForKey(unsigned char *p, int header_size, int size, int numitems, const char *key) {
  unsigned char len, *plimit, *base;
  int i, keylen;

  base = p;
  plimit = p + size - 1;
  p += header_size;

  keylen = strlen(key);


  for (i = 0; i < numitems; i++) {
    len = *((unsigned char *)p);
    p++;
    if (p > plimit) break;

    if (len > 0) {
      if (strncasecmp((char*)p, key, len) == 0) {
        if (keylen == len) {
          p += len;
          return p;
        }
      }
      p += len;
      if (p > plimit) break;
    } else if (len == keylen) {
      return p;
    }

    p = AdvanceDataPos(p, plimit);
    if ((p == 0) || (p < base)) break;
  }

  return 0;

}



static BOOL AddValue(binn *item, int type, void *pvalue, int size);



static BOOL binn_list_add_raw(binn *item, int type, void *pvalue, int size) {

  if ((item == 0) || (item->type != 0xE0) || (item->writable == 0)) return 0;



  if (AddValue(item, type, pvalue, size) == 0) return 0;

  item->count++;

  return 1;

}



static BOOL binn_object_set_raw(binn *item, const char *key, int type, void *pvalue, int size) {
  unsigned char *p, len;
  int int32;

  if ((item == 0) || (item->type != 0xE2) || (item->writable == 0)) return 0;

  if (key == 0) return 0;
  int32 = strlen(key);
  if (int32 > 255) return 0;


  p = SearchForKey(item->pbuf, 9, item->used_size, item->count, key);
  if (p) return 0;



  if (CheckAllocation(item, 1 + int32) == 0) return 0;

  p = ((unsigned char *) item->pbuf) + item->used_size;
  len = int32;
  *p = len;
  p++;
  memcpy(p, key, int32);
  int32++;
  item->used_size += int32;

  if (AddValue(item, type, pvalue, size) == 0) {
    item->used_size -= int32;
    return 0;
  }

  item->count++;

  return 1;

}



static BOOL binn_map_set_raw(binn *item, int id, int type, void *pvalue, int size) {
  unsigned char *base, *p, sign;
  int id_size;

  if ((item == 0) || (item->type != 0xE1) || (item->writable == 0)) return 0;


  p = SearchForID(item->pbuf, 9, item->used_size, item->count, id);
  if (p) return 0;



  if (CheckAllocation(item, 5) == 0) return 0;

  p = base = ((unsigned char *) item->pbuf) + item->used_size;

  sign = (id < 0);
  if (sign) id = -id;

  if (id <= 0x3F) {
    *p++ = (sign << 6) | id;
  } else if (id <= 0xFFF) {
    *p++ = 0x80 | (sign << 4) | ((id & 0xF00) >> 8);
    *p++ = id & 0xFF;
  } else if (id <= 0xFFFFF) {
    *p++ = 0xA0 | (sign << 4) | ((id & 0xF0000) >> 16);
    *p++ = (id & 0xFF00) >> 8;
    *p++ = id & 0xFF;
  } else if (id <= 0xFFFFFFF) {
    *p++ = 0xC0 | (sign << 4) | ((id & 0xF000000) >> 24);
    *p++ = (id & 0xFF0000) >> 16;
    *p++ = (id & 0xFF00) >> 8;
    *p++ = id & 0xFF;
  } else {
    *p++ = 0xE0;
    if (sign) id = -id;
    copy_be32((u32*)p, (u32*)&id);
    p += 4;
  }

  id_size = (p - base);
  item->used_size += id_size;

  if (AddValue(item, type, pvalue, size) == 0) {
    item->used_size -= id_size;
    return 0;
  }

  item->count++;

  return 1;

}



static void * compress_int(int *pstorage_type, int *ptype, void *psource) {
  int storage_type, storage_type2, type, type2=0;
  int64 vint = 0;
  uint64 vuint;
  char *pvalue;




  storage_type = *pstorage_type;
  if (storage_type == 0x20) return psource;

  type = *ptype;

  switch (type) {
  case 0x81:
    vint = *(int64*)psource;
    goto loc_signed;
  case 0x61:
    vint = *(int*)psource;
    goto loc_signed;
  case 0x41:
    vint = *(short*)psource;
    goto loc_signed;
  case 0x80:
    vuint = *(uint64*)psource;
    goto loc_positive;
  case 0x60:
    vuint = *(unsigned int*)psource;
    goto loc_positive;
  case 0x40:
    vuint = *(unsigned short*)psource;
    goto loc_positive;
  }

loc_signed:

  if (vint >= 0) {
    vuint = vint;
    goto loc_positive;
  }



  if (vint >= INT8_MIN) {
    type2 = 0x21;
  } else
  if (vint >= INT16_MIN) {
    type2 = 0x41;
  } else
  if (vint >= INT32_MIN) {
    type2 = 0x61;
  }
  goto loc_exit;

loc_positive:

  if (vuint <= UINT8_MAX) {
    type2 = 0x20;
  } else
  if (vuint <= UINT16_MAX) {
    type2 = 0x40;
  } else
  if (vuint <= UINT32_MAX) {
    type2 = 0x60;
  }

loc_exit:

  pvalue = (char *) psource;

  if ((type2) && (type2 != type)) {
    *ptype = type2;
    storage_type2 = binn_get_write_storage(type2);
    *pstorage_type = storage_type2;





  }

  return pvalue;

}



static int type_family(int type);

static BOOL AddValue(binn *item, int type, void *pvalue, int size) {
  int int32, ArgSize, storage_type, extra_type;
  unsigned char *p;

  binn_get_type_info(type, &storage_type, &extra_type);

  if (pvalue == 0) {
    switch (storage_type) {
      case 0x00:
        break;
      case 0xC0:
      case 0xA0:
        if (size == 0) break;
      default:
        return 0;
    }
  }

  if ((type_family(type) == 0xf2) && (item->disable_int_compression == 0))
    pvalue = compress_int(&storage_type, &type, pvalue);

  switch (storage_type) {
    case 0x00:
      size = 0;
      ArgSize = size;
      break;
    case 0x20:
      size = 1;
      ArgSize = size;
      break;
    case 0x40:
      size = 2;
      ArgSize = size;
      break;
    case 0x60:
      size = 4;
      ArgSize = size;
      break;
    case 0x80:
      size = 8;
      ArgSize = size;
      break;
    case 0xC0:
      if (size < 0) return 0;

      ArgSize = size + 4;
      break;
    case 0xA0:
      if (size < 0) return 0;
      if (size == 0) size = strlen2( (char *) pvalue);
      ArgSize = size + 5;
      break;
    case 0xE0:
      if (size <= 0) return 0;
      ArgSize = size;
      break;
    default:
      return 0;
  }

  ArgSize += 2;
  if (CheckAllocation(item, ArgSize) == 0) return 0;


  p = ((unsigned char *) item->pbuf) + item->used_size;


  if (storage_type != 0xE0) {
    if (type > 255) {
      u16 type16 = type;
      copy_be16((u16*)p, (u16*)&type16);
      p += 2;
      item->used_size += 2;
    } else {
      *p = type;
      p++;
      item->used_size++;
    }
  }

  switch (storage_type) {
    case 0x00:

      break;
    case 0x20:
      *((char *) p) = *((char *) pvalue);
      item->used_size += 1;
      break;
    case 0x40:
      copy_be16((u16*)p, (u16*)pvalue);
      item->used_size += 2;
      break;
    case 0x60:
      copy_be32((u32*)p, (u32*)pvalue);
      item->used_size += 4;
      break;
    case 0x80:
      copy_be64((u64*)p, (u64*)pvalue);
      item->used_size += 8;
      break;
    case 0xC0:
    case 0xA0:
      if (size > 127) {
        int32 = size | 0x80000000;
        copy_be32((u32*)p, (u32*)&int32);
        p += 4;
        item->used_size += 4;
      } else {
        *((unsigned char *) p) = size;
        p++;
        item->used_size++;
      }
      memcpy(p, pvalue, size);
      if (storage_type == 0xA0) {
        p += size;
        *((char *) p) = (char) 0;
        size++;
      }
      item->used_size += size;
      break;
    case 0xE0:
      memcpy(p, pvalue, size);
      item->used_size += size;
      break;
  }

  item->dirty = 1;

  return 1;
}



static BOOL binn_save_header(binn *item) {
  unsigned char byte, *p;
  int int32, size;

  if (item == 0) return 0;



  p = ((unsigned char *) item->pbuf) + 9;
  size = item->used_size - 9 + 3;


  if (item->count > 127) {
    p -= 4;
    size += 3;
    int32 = item->count | 0x80000000;
    copy_be32((u32*)p, (u32*)&int32);
  } else {
    p--;
    *p = (unsigned char) item->count;
  }


  if (size > 127) {
    p -= 4;
    size += 3;
    int32 = size | 0x80000000;
    copy_be32((u32*)p, (u32*)&int32);
  } else {
    p--;
    *p = (unsigned char) size;
  }


  p--;
  *p = (unsigned char) item->type;


  item->ptr = p;
  item->size = size;

  (void)(byte);
# 1108 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
  item->dirty = 0;

  return 1;

}



void binn_free(binn *item) {

  if (item == 0) return;

  if ((item->writable) && (item->pre_allocated == 0)) {
    free_fn(item->pbuf);
  }

  if (item->freefn) item->freefn(item->ptr);

  if (item->allocated) {
    free_fn(item);
  } else {
    memset(item, 0, sizeof(binn));
    item->header = 0x1F22B11F;
  }

}



void * binn_release(binn *item) {
  void *data;

  if (item == 0) return 0;

  data = binn_ptr(item);

  if (data > item->pbuf) {
    memmove(item->pbuf, data, item->size);
    data = item->pbuf;
  }

  if (item->allocated) {
    free_fn(item);
  } else {
    memset(item, 0, sizeof(binn));
    item->header = 0x1F22B11F;
  }

  return data;

}



static BOOL IsValidBinnHeader(void *pbuf, int *ptype, int *pcount, int *psize, int *pheadersize) {
  unsigned char byte, *p, *plimit=0;
  int int32, type, size, count;

  if (pbuf == 0) return 0;

  p = (unsigned char *) pbuf;

  if (psize && *psize > 0) {
    plimit = p + *psize - 1;
  }


  byte = *p; p++;
  if ((byte & 0xE0) != 0xE0) return 0;
  if (byte & 0x10) return 0;
  type = byte;

  switch (type) {
    case 0xE0:
    case 0xE1:
    case 0xE2:
      break;
    default:
      return 0;
  }


  if (plimit && p > plimit) return 0;
  int32 = *((unsigned char*)p);
  if (int32 & 0x80) {
    if (plimit && p + sizeof(int) - 1 > plimit) return 0;
    copy_be32((u32*)&int32, (u32*)p);
    int32 &= 0x7FFFFFFF;
    p+=4;
  } else {
    p++;
  }
  size = int32;


  if (plimit && p > plimit) return 0;
  int32 = *((unsigned char*)p);
  if (int32 & 0x80) {
    if (plimit && p + sizeof(int) - 1 > plimit) return 0;
    copy_be32((u32*)&int32, (u32*)p);
    int32 &= 0x7FFFFFFF;
    p+=4;
  } else {
    p++;
  }
  count = int32;
# 1227 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
  if ((size < 3) || (count < 0)) return 0;


  if (ptype) *ptype = type;
  if (pcount) *pcount = count;
  if (psize && *psize==0) *psize = size;
  if (pheadersize) *pheadersize = (int) (p - (unsigned char*)pbuf);
  return 1;
}



static int binn_buf_type(void *pbuf) {
  int type;

  if (!IsValidBinnHeader(pbuf, &type, 0, 0, 0)) return 0;

  return type;

}



static int binn_buf_count(void *pbuf) {
  int nitems;

  if (!IsValidBinnHeader(pbuf, 0, &nitems, 0, 0)) return 0;

  return nitems;

}



static int binn_buf_size(void *pbuf) {
  int size=0;

  if (!IsValidBinnHeader(pbuf, 0, 0, &size, 0)) return 0;

  return size;

}



void * binn_ptr(void *ptr) {
  binn *item;

  switch (binn_get_ptr_type(ptr)) {
  case 1:
    item = (binn*) ptr;
    if (item->writable && item->dirty) {
      binn_save_header(item);
    }
    return item->ptr;
  case 2:
    return ptr;
  default:
    return 0;
  }

}



int binn_size(void *ptr) {
  binn *item;

  switch (binn_get_ptr_type(ptr)) {
  case 1:
    item = (binn*) ptr;
    if (item->writable && item->dirty) {
      binn_save_header(item);
    }
    return item->size;
  case 2:
    return binn_buf_size(ptr);
  default:
    return 0;
  }

}



int binn_type(void *ptr) {
  binn *item;

  switch (binn_get_ptr_type(ptr)) {
  case 1:
    item = (binn*) ptr;
    return item->type;
  case 2:
    return binn_buf_type(ptr);
  default:
    return -1;
  }

}



int binn_count(void *ptr) {
  binn *item;

  switch (binn_get_ptr_type(ptr)) {
  case 1:
    item = (binn*) ptr;
    return item->count;
  case 2:
    return binn_buf_count(ptr);
  default:
    return -1;
  }

}



BOOL binn_is_valid_ex(void *ptr, int *ptype, int *pcount, int *psize) {
  int i, type, count, size, header_size;
  unsigned char *p, *plimit, *base, len;
  void *pbuf;

  pbuf = binn_ptr(ptr);
  if (pbuf == 0) return 0;


  if (psize && *psize > 0) {
    size = *psize;
  } else {
    size = 0;
  }

  if (!IsValidBinnHeader(pbuf, &type, &count, &size, &header_size)) return 0;


  if (psize && *psize > 0) {

    if (size != *psize) return 0;
  }

  if (pcount && *pcount > 0) {

    if (count != *pcount) return 0;
  }

  if (ptype && *ptype != 0) {

    if (type != *ptype) return 0;
  }



  p = (unsigned char *)pbuf;
  base = p;
  plimit = p + size;

  p += header_size;


  for (i = 0; i < count; i++) {
    switch (type) {
      case 0xE2:

        len = *p;
        p++;


        p += len;
        break;
      case 0xE1:

        read_map_id(&p, plimit);
        break;


    }

    p = AdvanceDataPos(p, plimit);
    if ((p == 0) || (p < base)) goto Invalid;
  }

  if (ptype && *ptype==0) *ptype = type;
  if (pcount && *pcount==0) *pcount = count;
  if (psize && *psize==0) *psize = size;
  return 1;

Invalid:
  return 0;

}



BOOL binn_is_valid(void *ptr, int *ptype, int *pcount, int *psize) {

  if (ptype) *ptype = 0;
  if (pcount) *pcount = 0;
  if (psize) *psize = 0;

  return binn_is_valid_ex(ptr, ptype, pcount, psize);

}





static BOOL GetValue(unsigned char *p, binn *value) {
  unsigned char byte;
  int data_type, storage_type;
  int DataSize;
  void *p2;

  if (value == 0) return 0;
  memset(value, 0, sizeof(binn));
  value->header = 0x1F22B11F;




  p2 = p;


  byte = *p; p++;
  storage_type = byte & 0xE0;
  if (byte & 0x10) {
    data_type = byte << 8;
    byte = *p; p++;
    data_type |= byte;

  } else {
    data_type = byte;

  }


  value->type = data_type;

  switch (storage_type) {
  case 0x00:
    break;
  case 0x20:
    value->vuint8 = *((unsigned char *) p);
    value->ptr = p;
    break;
  case 0x40:
    copy_be16((u16*)&value->vint16, (u16*)p);
    value->ptr = &value->vint16;
    break;
  case 0x60:
    copy_be32((u32*)&value->vint32, (u32*)p);
    value->ptr = &value->vint32;
    break;
  case 0x80:
    copy_be64((u64*)&value->vint64, (u64*)p);
    value->ptr = &value->vint64;
    break;
  case 0xC0:
  case 0xA0:
    DataSize = *((unsigned char*)p);
    if (DataSize & 0x80) {
      copy_be32((u32*)&DataSize, (u32*)p);
      DataSize &= 0x7FFFFFFF;
      p+=4;
    } else {
      p++;
    }
    value->size = DataSize;
    value->ptr = p;
    break;
  case 0xE0:
    value->ptr = p2;
    if (IsValidBinnHeader(p2, 0, &value->count, &value->size, 0) == 0) return 0;
    break;
  default:
    return 0;
  }



  switch (value->type) {
    case 0x01:
      value->type = 0x80061;
      value->vbool = 1;
      value->ptr = &value->vbool;
      break;
    case 0x02:
      value->type = 0x80061;
      value->vbool = 0;
      value->ptr = &value->vbool;
      break;
# 1539 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
  }

  return 1;

}
# 1552 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
binn local_value;

static void * store_value(binn *value) {

  memcpy(&local_value, value, sizeof(binn));

  switch (binn_get_read_storage(value->type)) {
  case 0x00:

  case 0x40:
  case 0x60:
  case 0x80:
    return &local_value.vint32;
  }

  return value->ptr;

}







BOOL binn_object_get_value(void *ptr, const char *key, binn *value) {
  int type, count, size=0, header_size;
  unsigned char *p;

  ptr = binn_ptr(ptr);
  if ((ptr == 0) || (key == 0) || (value == 0)) return 0;


  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == 0) return 0;

  if (type != 0xE2) return 0;
  if (count == 0) return 0;

  p = (unsigned char *) ptr;
  p = SearchForKey(p, header_size, size, count, key);
  if (p == 0) return 0;

  return GetValue(p, value);

}



BOOL binn_map_get_value(void* ptr, int id, binn *value) {
  int type, count, size=0, header_size;
  unsigned char *p;

  ptr = binn_ptr(ptr);
  if ((ptr == 0) || (value == 0)) return 0;


  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == 0) return 0;

  if (type != 0xE1) return 0;
  if (count == 0) return 0;

  p = (unsigned char *) ptr;
  p = SearchForID(p, header_size, size, count, id);
  if (p == 0) return 0;

  return GetValue(p, value);

}



BOOL binn_list_get_value(void* ptr, int pos, binn *value) {
  int i, type, count, size=0, header_size;
  unsigned char *p, *plimit, *base;

  ptr = binn_ptr(ptr);
  if ((ptr == 0) || (value == 0)) return 0;


  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == 0) return 0;

  if (type != 0xE0) return 0;
  if (count == 0) return 0;
  if ((pos <= 0) | (pos > count)) return 0;
  pos--;

  p = (unsigned char *) ptr;
  base = p;
  plimit = p + size;
  p += header_size;

  for (i = 0; i < pos; i++) {
    p = AdvanceDataPos(p, plimit);
    if ((p == 0) || (p < base)) return 0;
  }

  return GetValue(p, value);

}





static BOOL binn_read_pair(int expected_type, void *ptr, int pos, int *pid, char *pkey, binn *value) {
  int type, count, size=0, header_size;
  int i, int32, id = 0, counter=0;
  unsigned char *p, *plimit, *base, *key = 0, len = 0;

  ptr = binn_ptr(ptr);


  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == 0) return 0;

  if ((type != expected_type) || (count == 0) || (pos < 1) || (pos > count)) return 0;

  p = (unsigned char *) ptr;
  base = p;
  plimit = p + size - 1;
  p += header_size;

  for (i = 0; i < count; i++) {
    switch (type) {
      case 0xE1:
        int32 = read_map_id(&p, plimit);
        if (p > plimit) return 0;
        id = int32;
        break;
      case 0xE2:
        len = *((unsigned char *)p); p++;
        if (p > plimit) return 0;
        key = p;
        p += len;
        if (p > plimit) return 0;
        break;
    }
    counter++;
    if (counter == pos) goto found;

    p = AdvanceDataPos(p, plimit);
    if ((p == 0) || (p < base)) return 0;
  }

  return 0;

found:

  switch (type) {
    case 0xE1:
      if (pid) *pid = id;
      break;
    case 0xE2:
      if (pkey) {
        memcpy(pkey, key, len);
        pkey[len] = 0;
      }
      break;
  }

  return GetValue(p, value);

}



BOOL binn_map_get_pair(void *ptr, int pos, int *pid, binn *value) {

  return binn_read_pair(0xE1, ptr, pos, pid, 0, value);

}



BOOL binn_object_get_pair(void *ptr, int pos, char *pkey, binn *value) {

  return binn_read_pair(0xE2, ptr, pos, 0, pkey, value);

}



binn * binn_map_pair(void *map, int pos, int *pid) {
  binn *value;

  value = (binn *) binn_malloc(sizeof(binn));

  if (binn_read_pair(0xE1, map, pos, pid, 0, value) == 0) {
    free_fn(value);
    return 0;
  }

  value->allocated = 1;
  return value;

}



binn * binn_object_pair(void *obj, int pos, char *pkey) {
  binn *value;

  value = (binn *) binn_malloc(sizeof(binn));

  if (binn_read_pair(0xE2, obj, pos, 0, pkey, value) == 0) {
    free_fn(value);
    return 0;
  }

  value->allocated = 1;
  return value;

}




void * binn_map_read_pair(void *ptr, int pos, int *pid, int *ptype, int *psize) {
  binn value;

  if (binn_map_get_pair(ptr, pos, pid, &value) == 0) return 0;
  if (ptype) *ptype = value.type;
  if (psize) *psize = value.size;

  return store_value(&value);




}



void * binn_object_read_pair(void *ptr, int pos, char *pkey, int *ptype, int *psize) {
  binn value;

  if (binn_object_get_pair(ptr, pos, pkey, &value) == 0) return 0;
  if (ptype) *ptype = value.type;
  if (psize) *psize = value.size;

  return store_value(&value);




}





BOOL binn_iter_init(binn_iter *iter, void *ptr, int expected_type) {
  int type, count, size=0, header_size;

  ptr = binn_ptr(ptr);
  if ((ptr == 0) || (iter == 0)) return 0;
  memset(iter, 0, sizeof(binn_iter));


  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == 0) return 0;

  if (type != expected_type) return 0;


  iter->plimit = (unsigned char *)ptr + size - 1;
  iter->pnext = (unsigned char *)ptr + header_size;
  iter->count = count;
  iter->current = 0;
  iter->type = type;

  return 1;
}



BOOL binn_list_next(binn_iter *iter, binn *value) {
  unsigned char *pnow;

  if ((iter == 0) || (iter->pnext == 0) || (iter->pnext > iter->plimit) || (iter->current > iter->count) || (iter->type != 0xE0)) return 0;

  iter->current++;
  if (iter->current > iter->count) return 0;

  pnow = iter->pnext;
  iter->pnext = AdvanceDataPos(pnow, iter->plimit);
  if (iter->pnext != 0 && iter->pnext < pnow) return 0;

  return GetValue(pnow, value);

}



static BOOL binn_read_next_pair(int expected_type, binn_iter *iter, int *pid, char *pkey, binn *value) {
  int int32, id;
  unsigned char *p, *key;
  unsigned short len;

  if ((iter == 0) || (iter->pnext == 0) || (iter->pnext > iter->plimit) || (iter->current > iter->count) || (iter->type != expected_type)) return 0;

  iter->current++;
  if (iter->current > iter->count) return 0;

  p = iter->pnext;

  switch (expected_type) {
    case 0xE1:
      int32 = read_map_id(&p, iter->plimit);
      if (p > iter->plimit) return 0;
      id = int32;
      if (pid) *pid = id;
      break;
    case 0xE2:
      len = *((unsigned char *)p); p++;
      key = p;
      p += len;
      if (p > iter->plimit) return 0;
      if (pkey) {
        memcpy(pkey, key, len);
        pkey[len] = 0;
      }
      break;
  }

  iter->pnext = AdvanceDataPos(p, iter->plimit);
  if (iter->pnext != 0 && iter->pnext < p) return 0;

  return GetValue(p, value);

}



BOOL binn_map_next(binn_iter *iter, int *pid, binn *value) {

  return binn_read_next_pair(0xE1, iter, pid, 0, value);

}



BOOL binn_object_next(binn_iter *iter, char *pkey, binn *value) {

  return binn_read_next_pair(0xE2, iter, 0, pkey, value);

}




binn * binn_list_next_value(binn_iter *iter) {
  binn *value;

  value = (binn *) binn_malloc(sizeof(binn));

  if (binn_list_next(iter, value) == 0) {
    free_fn(value);
    return 0;
  }

  value->allocated = 1;
  return value;

}



binn * binn_map_next_value(binn_iter *iter, int *pid) {
  binn *value;

  value = (binn *) binn_malloc(sizeof(binn));

  if (binn_map_next(iter, pid, value) == 0) {
    free_fn(value);
    return 0;
  }

  value->allocated = 1;
  return value;

}



binn * binn_object_next_value(binn_iter *iter, char *pkey) {
  binn *value;

  value = (binn *) binn_malloc(sizeof(binn));

  if (binn_object_next(iter, pkey, value) == 0) {
    free_fn(value);
    return 0;
  }

  value->allocated = 1;
  return value;

}




void * binn_list_read_next(binn_iter *iter, int *ptype, int *psize) {
  binn value;

  if (binn_list_next(iter, &value) == 0) return 0;
  if (ptype) *ptype = value.type;
  if (psize) *psize = value.size;

  return store_value(&value);




}



void * binn_map_read_next(binn_iter *iter, int *pid, int *ptype, int *psize) {
  binn value;

  if (binn_map_next(iter, pid, &value) == 0) return 0;
  if (ptype) *ptype = value.type;
  if (psize) *psize = value.size;

  return store_value(&value);




}



void * binn_object_read_next(binn_iter *iter, char *pkey, int *ptype, int *psize) {
  binn value;

  if (binn_object_next(iter, pkey, &value) == 0) return 0;
  if (ptype) *ptype = value.type;
  if (psize) *psize = value.size;

  return store_value(&value);




}






int binn_get_write_storage(int type) {
  int storage_type;

  switch (type) {
    case 0xA6:
    case 0xA7:
      return 0xA0;

    case 0x80061:
      return 0x00;

    default:
      binn_get_type_info(type, &storage_type, 0);
      return storage_type;
  }

}



int binn_get_read_storage(int type) {
  int storage_type;

  switch (type) {






    case 0x80061:
    case 0x01:
    case 0x02:
      return 0x60;
    default:
      binn_get_type_info(type, &storage_type, 0);
      return storage_type;
  }

}



static BOOL GetWriteConvertedData(int *ptype, void **ppvalue, int *psize) {
  int type;
  float f1;
  double d1;
  char pstr[128];

  (void)(pstr);
  (void)(d1);
  (void)(f1);

  type = *ptype;

  if (*ppvalue == 0) {
    switch (type) {
      case 0x00:
      case 0x01:
      case 0x02:
        break;
      case 0xA0:
      case 0xC0:
        if (*psize == 0) break;
      default:
        return 0;
    }
  }

  switch (type) {
# 2090 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
    case 0xA4:
    case 0xA5:





      return 1;
      break;

    case 0xA2:
    case 0xA1:
    case 0xA3:
      return 1;
      break;

    case 0x80061:
      if (**((BOOL**)ppvalue) == 0) {
        type = 0x02;
      } else {
        type = 0x01;
      }
      *ptype = type;
      break;

  }

  return 1;

}



static int type_family(int type) {

  switch (type) {
    case 0xE0:
    case 0xE1:
    case 0xE2:
      return 0xf7;

    case 0x21:
    case 0x41:
    case 0x61:
    case 0x81:
    case 0x20:
    case 0x40:
    case 0x60:
    case 0x80:
      return 0xf2;

    case 0x62:
    case 0x82:

    case 0xA6:

    case 0xA7:
      return 0xf3;

    case 0xA0:
    case 0xB001:
    case 0xB005:
    case 0xB002:
    case 0xB003:
    case 0xB004:
      return 0xf4;

    case 0xC0:
    case 0xD001:
    case 0xD002:
    case 0xD003:
    case 0xD004:
      return 0xf5;

    case 0xA4:
    case 0x83:
    case 0xA2:
    case 0xA3:
    case 0xA1:
      return 0xf4;

    case 0x80061:
      return 0xf6;

    case 0x00:
      return 0xf1;

    default:

      return 0x00;
  }

}



static int int_type(int type) {

  switch (type) {
  case 0x21:
  case 0x41:
  case 0x61:
  case 0x81:
    return 11;

  case 0x20:
  case 0x40:
  case 0x60:
  case 0x80:
    return 22;

  default:
    return 0;
  }

}



static BOOL copy_raw_value(void *psource, void *pdest, int data_store) {

  switch (data_store) {
  case 0x00:
    break;
  case 0x20:
    *((char *) pdest) = *(char *)psource;
    break;
  case 0x40:
    *((short *) pdest) = *(short *)psource;
    break;
  case 0x60:
    *((int *) pdest) = *(int *)psource;
    break;
  case 0x80:
    *((uint64 *) pdest) = *(uint64 *)psource;
    break;
  case 0xC0:
  case 0xA0:
  case 0xE0:
    *((char **) pdest) = (char *)psource;
    break;
  default:
    return 0;
  }

  return 1;

}



static BOOL copy_int_value(void *psource, void *pdest, int source_type, int dest_type) {
  uint64 vuint64 = 0; int64 vint64 = 0;

  switch (source_type) {
  case 0x21:
    vint64 = *(signed char *)psource;
    break;
  case 0x41:
    vint64 = *(short *)psource;
    break;
  case 0x61:
    vint64 = *(int *)psource;
    break;
  case 0x81:
    vint64 = *(int64 *)psource;
    break;

  case 0x20:
    vuint64 = *(unsigned char *)psource;
    break;
  case 0x40:
    vuint64 = *(unsigned short *)psource;
    break;
  case 0x60:
    vuint64 = *(unsigned int *)psource;
    break;
  case 0x80:
    vuint64 = *(uint64 *)psource;
    break;

  default:
    return 0;
  }




  if ((int_type(source_type) == 22) && (int_type(dest_type) == 11)) {
    if (vuint64 > INT64_MAX) return 0;
    vint64 = vuint64;
  } else if ((int_type(source_type) == 11) && (int_type(dest_type) == 22)) {
    if (vint64 < 0) return 0;
    vuint64 = vint64;
  }


  switch (dest_type) {
  case 0x21:
    if ((vint64 < INT8_MIN) || (vint64 > INT8_MAX)) return 0;
    *(signed char *)pdest = (signed char) vint64;
    break;
  case 0x41:
    if ((vint64 < INT16_MIN) || (vint64 > INT16_MAX)) return 0;
    *(short *)pdest = (short) vint64;
    break;
  case 0x61:
    if ((vint64 < INT32_MIN) || (vint64 > INT32_MAX)) return 0;
    *(int *)pdest = (int) vint64;
    break;
  case 0x81:
    *(int64 *)pdest = vint64;
    break;

  case 0x20:
    if (vuint64 > UINT8_MAX) return 0;
    *(unsigned char *)pdest = (unsigned char) vuint64;
    break;
  case 0x40:
    if (vuint64 > UINT16_MAX) return 0;
    *(unsigned short *)pdest = (unsigned short) vuint64;
    break;
  case 0x60:
    if (vuint64 > UINT32_MAX) return 0;
    *(unsigned int *)pdest = (unsigned int) vuint64;
    break;
  case 0x80:
    *(uint64 *)pdest = vuint64;
    break;

  default:
    return 0;
  }

  return 1;

}



static BOOL copy_float_value(void *psource, void *pdest, int source_type, int dest_type) {

  switch (source_type) {
  case 0x62:
    *(double *)pdest = *(float *)psource;
    break;
  case 0x82:
    *(float *)pdest = (float) *(double *)psource;
    break;
  default:
    return 0;
  }

  return 1;

}



static void zero_value(void *pvalue, int type) {


  switch (binn_get_read_storage(type)) {
  case 0x00:
    break;
  case 0x20:
    *((char *) pvalue) = 0;

    break;
  case 0x40:
    *((short *) pvalue) = 0;

    break;
  case 0x60:
    *((int *) pvalue) = 0;

    break;
  case 0x80:
    *((uint64 *) pvalue) = 0;

    break;
  case 0xC0:
  case 0xA0:
  case 0xE0:
    *(char **)pvalue = 0;
    break;
  }



}



static BOOL copy_value(void *psource, void *pdest, int source_type, int dest_type, int data_store) {

  if (type_family(source_type) != type_family(dest_type)) return 0;

  if ((type_family(source_type) == 0xf2) && (source_type != dest_type)) {
    return copy_int_value(psource, pdest, source_type, dest_type);
  } else if ((type_family(source_type) == 0xf3) && (source_type != dest_type)) {
    return copy_float_value(psource, pdest, source_type, dest_type);
  } else {
    return copy_raw_value(psource, pdest, data_store);
  }

}





BOOL binn_list_add(binn *list, int type, void *pvalue, int size) {

  if (GetWriteConvertedData(&type, &pvalue, &size) == 0) return 0;

  return binn_list_add_raw(list, type, pvalue, size);

}



BOOL binn_map_set(binn *map, int id, int type, void *pvalue, int size) {

  if (GetWriteConvertedData(&type, &pvalue, &size) == 0) return 0;

  return binn_map_set_raw(map, id, type, pvalue, size);

}



BOOL binn_object_set(binn *obj, const char *key, int type, void *pvalue, int size) {

  if (GetWriteConvertedData(&type, &pvalue, &size) == 0) return 0;

  return binn_object_set_raw(obj, key, type, pvalue, size);

}




BOOL binn_add_value(binn *item, int binn_type, int id, char *name, int type, void *pvalue, int size) {

  switch (binn_type) {
    case 0xE0:
      return binn_list_add(item, type, pvalue, size);
    case 0xE1:
      return binn_map_set(item, id, type, pvalue, size);
    case 0xE2:
      return binn_object_set(item, name, type, pvalue, size);
    default:
      return 0;
  }

}




BOOL binn_list_add_new(binn *list, binn *value) {
  BOOL retval;

  retval = binn_list_add_value(list, value);
  if (value) free_fn(value);
  return retval;

}



BOOL binn_map_set_new(binn *map, int id, binn *value) {
  BOOL retval;

  retval = binn_map_set_value(map, id, value);
  if (value) free_fn(value);
  return retval;

}



BOOL binn_object_set_new(binn *obj, const char *key, binn *value) {
  BOOL retval;

  retval = binn_object_set_value(obj, key, value);
  if (value) free_fn(value);
  return retval;

}





binn * binn_list_value(void *ptr, int pos) {
  binn *value;

  value = (binn *) binn_malloc(sizeof(binn));

  if (binn_list_get_value(ptr, pos, value) == 0) {
    free_fn(value);
    return 0;
  }

  value->allocated = 1;
  return value;

}



binn * binn_map_value(void *ptr, int id) {
  binn *value;

  value = (binn *) binn_malloc(sizeof(binn));

  if (binn_map_get_value(ptr, id, value) == 0) {
    free_fn(value);
    return 0;
  }

  value->allocated = 1;
  return value;

}



binn * binn_object_value(void *ptr, const char *key) {
  binn *value;

  value = (binn *) binn_malloc(sizeof(binn));

  if (binn_object_get_value(ptr, key, value) == 0) {
    free_fn(value);
    return 0;
  }

  value->allocated = 1;
  return value;

}




void * binn_list_read(void *list, int pos, int *ptype, int *psize) {
  binn value;

  if (binn_list_get_value(list, pos, &value) == 0) return 0;
  if (ptype) *ptype = value.type;
  if (psize) *psize = value.size;

  return store_value(&value);




}



void * binn_map_read(void *map, int id, int *ptype, int *psize) {
  binn value;

  if (binn_map_get_value(map, id, &value) == 0) return 0;
  if (ptype) *ptype = value.type;
  if (psize) *psize = value.size;

  return store_value(&value);




}



void * binn_object_read(void *obj, const char *key, int *ptype, int *psize) {
  binn value;

  if (binn_object_get_value(obj, key, &value) == 0) return 0;
  if (ptype) *ptype = value.type;
  if (psize) *psize = value.size;

  return store_value(&value);




}




BOOL binn_list_get(void *ptr, int pos, int type, void *pvalue, int *psize) {
  binn value;
  int storage_type;

  storage_type = binn_get_read_storage(type);
  if ((storage_type != 0x00) && (pvalue == 0)) return 0;

  zero_value(pvalue, type);

  if (binn_list_get_value(ptr, pos, &value) == 0) return 0;

  if (copy_value(value.ptr, pvalue, value.type, type, storage_type) == 0) return 0;

  if (psize) *psize = value.size;

  return 1;

}



BOOL binn_map_get(void *ptr, int id, int type, void *pvalue, int *psize) {
  binn value;
  int storage_type;

  storage_type = binn_get_read_storage(type);
  if ((storage_type != 0x00) && (pvalue == 0)) return 0;

  zero_value(pvalue, type);

  if (binn_map_get_value(ptr, id, &value) == 0) return 0;

  if (copy_value(value.ptr, pvalue, value.type, type, storage_type) == 0) return 0;

  if (psize) *psize = value.size;

  return 1;

}





BOOL binn_object_get(void *ptr, const char *key, int type, void *pvalue, int *psize) {
  binn value;
  int storage_type;

  storage_type = binn_get_read_storage(type);
  if ((storage_type != 0x00) && (pvalue == 0)) return 0;

  zero_value(pvalue, type);

  if (binn_object_get_value(ptr, key, &value) == 0) return 0;

  if (copy_value(value.ptr, pvalue, value.type, type, storage_type) == 0) return 0;

  if (psize) *psize = value.size;

  return 1;

}
# 2660 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
signed char binn_list_int8(void *list, int pos) {
  signed char value;

  binn_list_get(list, pos, 0x21, &value, 0);

  return value;
}

short binn_list_int16(void *list, int pos) {
  short value;

  binn_list_get(list, pos, 0x41, &value, 0);

  return value;
}

int binn_list_int32(void *list, int pos) {
  int value;

  binn_list_get(list, pos, 0x61, &value, 0);

  return value;
}

int64 binn_list_int64(void *list, int pos) {
  int64 value;

  binn_list_get(list, pos, 0x81, &value, 0);

  return value;
}

unsigned char binn_list_uint8(void *list, int pos) {
  unsigned char value;

  binn_list_get(list, pos, 0x20, &value, 0);

  return value;
}

unsigned short binn_list_uint16(void *list, int pos) {
  unsigned short value;

  binn_list_get(list, pos, 0x40, &value, 0);

  return value;
}

unsigned int binn_list_uint32(void *list, int pos) {
  unsigned int value;

  binn_list_get(list, pos, 0x60, &value, 0);

  return value;
}

uint64 binn_list_uint64(void *list, int pos) {
  uint64 value;

  binn_list_get(list, pos, 0x80, &value, 0);

  return value;
}

float binn_list_float(void *list, int pos) {
  float value;

  binn_list_get(list, pos, 0x62, &value, 0);

  return value;
}

double binn_list_double(void *list, int pos) {
  double value;

  binn_list_get(list, pos, 0x82, &value, 0);

  return value;
}

BOOL binn_list_bool(void *list, int pos) {
  BOOL value;

  binn_list_get(list, pos, 0x80061, &value, 0);

  return value;
}

BOOL binn_list_null(void *list, int pos) {

  return binn_list_get(list, pos, 0x00, 0, 0);

}

char * binn_list_str(void *list, int pos) {
  char *value;

  binn_list_get(list, pos, 0xA0, &value, 0);

  return value;
}

void * binn_list_blob(void *list, int pos, int *psize) {
  void *value;

  binn_list_get(list, pos, 0xC0, &value, psize);

  return value;
}

void * binn_list_list(void *list, int pos) {
  void *value;

  binn_list_get(list, pos, 0xE0, &value, 0);

  return value;
}

void * binn_list_map(void *list, int pos) {
  void *value;

  binn_list_get(list, pos, 0xE1, &value, 0);

  return value;
}

void * binn_list_object(void *list, int pos) {
  void *value;

  binn_list_get(list, pos, 0xE2, &value, 0);

  return value;
}



signed char binn_map_int8(void *map, int id) {
  signed char value;

  binn_map_get(map, id, 0x21, &value, 0);

  return value;
}

short binn_map_int16(void *map, int id) {
  short value;

  binn_map_get(map, id, 0x41, &value, 0);

  return value;
}

int binn_map_int32(void *map, int id) {
  int value;

  binn_map_get(map, id, 0x61, &value, 0);

  return value;
}

int64 binn_map_int64(void *map, int id) {
  int64 value;

  binn_map_get(map, id, 0x81, &value, 0);

  return value;
}

unsigned char binn_map_uint8(void *map, int id) {
  unsigned char value;

  binn_map_get(map, id, 0x20, &value, 0);

  return value;
}

unsigned short binn_map_uint16(void *map, int id) {
  unsigned short value;

  binn_map_get(map, id, 0x40, &value, 0);

  return value;
}

unsigned int binn_map_uint32(void *map, int id) {
  unsigned int value;

  binn_map_get(map, id, 0x60, &value, 0);

  return value;
}

uint64 binn_map_uint64(void *map, int id) {
  uint64 value;

  binn_map_get(map, id, 0x80, &value, 0);

  return value;
}

float binn_map_float(void *map, int id) {
  float value;

  binn_map_get(map, id, 0x62, &value, 0);

  return value;
}

double binn_map_double(void *map, int id) {
  double value;

  binn_map_get(map, id, 0x82, &value, 0);

  return value;
}

BOOL binn_map_bool(void *map, int id) {
  BOOL value;

  binn_map_get(map, id, 0x80061, &value, 0);

  return value;
}

BOOL binn_map_null(void *map, int id) {

  return binn_map_get(map, id, 0x00, 0, 0);

}

char * binn_map_str(void *map, int id) {
  char *value;

  binn_map_get(map, id, 0xA0, &value, 0);

  return value;
}

void * binn_map_blob(void *map, int id, int *psize) {
  void *value;

  binn_map_get(map, id, 0xC0, &value, psize);

  return value;
}

void * binn_map_list(void *map, int id) {
  void *value;

  binn_map_get(map, id, 0xE0, &value, 0);

  return value;
}

void * binn_map_map(void *map, int id) {
  void *value;

  binn_map_get(map, id, 0xE1, &value, 0);

  return value;
}

void * binn_map_object(void *map, int id) {
  void *value;

  binn_map_get(map, id, 0xE2, &value, 0);

  return value;
}



signed char binn_object_int8(void *obj, const char *key) {
  signed char value;

  binn_object_get(obj, key, 0x21, &value, 0);

  return value;
}

short binn_object_int16(void *obj, const char *key) {
  short value;

  binn_object_get(obj, key, 0x41, &value, 0);

  return value;
}

int binn_object_int32(void *obj, const char *key) {
  int value;

  binn_object_get(obj, key, 0x61, &value, 0);

  return value;
}

int64 binn_object_int64(void *obj, const char *key) {
  int64 value;

  binn_object_get(obj, key, 0x81, &value, 0);

  return value;
}

unsigned char binn_object_uint8(void *obj, const char *key) {
  unsigned char value;

  binn_object_get(obj, key, 0x20, &value, 0);

  return value;
}

unsigned short binn_object_uint16(void *obj, const char *key) {
  unsigned short value;

  binn_object_get(obj, key, 0x40, &value, 0);

  return value;
}

unsigned int binn_object_uint32(void *obj, const char *key) {
  unsigned int value;

  binn_object_get(obj, key, 0x60, &value, 0);

  return value;
}

uint64 binn_object_uint64(void *obj, const char *key) {
  uint64 value;

  binn_object_get(obj, key, 0x80, &value, 0);

  return value;
}

float binn_object_float(void *obj, const char *key) {
  float value;

  binn_object_get(obj, key, 0x62, &value, 0);

  return value;
}

double binn_object_double(void *obj, const char *key) {
  double value;

  binn_object_get(obj, key, 0x82, &value, 0);

  return value;
}

BOOL binn_object_bool(void *obj, const char *key) {
  BOOL value;

  binn_object_get(obj, key, 0x80061, &value, 0);

  return value;
}

BOOL binn_object_null(void *obj, const char *key) {

  return binn_object_get(obj, key, 0x00, 0, 0);

}

char * binn_object_str(void *obj, const char *key) {
  char *value;

  binn_object_get(obj, key, 0xA0, &value, 0);

  return value;
}

void * binn_object_blob(void *obj, const char *key, int *psize) {
  void *value;

  binn_object_get(obj, key, 0xC0, &value, psize);

  return value;
}

void * binn_object_list(void *obj, const char *key) {
  void *value;

  binn_object_get(obj, key, 0xE0, &value, 0);

  return value;
}

void * binn_object_map(void *obj, const char *key) {
  void *value;

  binn_object_get(obj, key, 0xE1, &value, 0);

  return value;
}

void * binn_object_object(void *obj, const char *key) {
  void *value;

  binn_object_get(obj, key, 0xE2, &value, 0);

  return value;
}




static binn * binn_alloc_item() {
  binn *item;
  item = (binn *) binn_malloc(sizeof(binn));
  if (item) {
    memset(item, 0, sizeof(binn));
    item->header = 0x1F22B11F;
    item->allocated = 1;

  }
  return item;
}



binn * binn_value(int type, void *pvalue, int size, binn_mem_free freefn) {
  int storage_type;
  binn *item = binn_alloc_item();
  if (item) {
    item->type = type;
    binn_get_type_info(type, &storage_type, 0);
    switch (storage_type) {
    case 0x00:
      break;
    case 0xA0:
      if (size == 0) size = strlen((char*)pvalue) + 1;
    case 0xC0:
    case 0xE0:
      if (freefn == ((binn_mem_free)-1)) {
        item->ptr = binn_memdup(pvalue, size);
        if (item->ptr == 0) {
          free_fn(item);
          return 0;
        }
        item->freefn = free_fn;
        if (storage_type == 0xA0) size--;
      } else {
        item->ptr = pvalue;
        item->freefn = freefn;
      }
      item->size = size;
      break;
    default:
      item->ptr = &item->vint32;
      copy_raw_value(pvalue, item->ptr, storage_type);
    }
  }
  return item;
}



BOOL binn_set_string(binn *item, char *str, binn_mem_free pfree) {

  if (item == 0 || str == 0) return 0;

  if (pfree == ((binn_mem_free)-1)) {
    item->ptr = binn_memdup(str, strlen(str) + 1);
    if (item->ptr == 0) return 0;
    item->freefn = free_fn;
  } else {
    item->ptr = str;
    item->freefn = pfree;
  }

  item->type = 0xA0;
  return 1;

}



BOOL binn_set_blob(binn *item, void *ptr, int size, binn_mem_free pfree) {

  if (item == 0 || ptr == 0) return 0;

  if (pfree == ((binn_mem_free)-1)) {
    item->ptr = binn_memdup(ptr, size);
    if (item->ptr == 0) return 0;
    item->freefn = free_fn;
  } else {
    item->ptr = ptr;
    item->freefn = pfree;
  }

  item->type = 0xC0;
  item->size = size;
  return 1;

}
# 3166 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/src/binn.c"
int64 atoi64(char *str) {
  int64 retval;
  int is_negative=0;

  if (*str == '-') {
    is_negative = 1;
    str++;
  }
  retval = 0;
  for (; *str; str++) {
    retval = 10 * retval + (*str - '0');
  }
  if (is_negative) retval *= -1;
  return retval;
}




static BOOL is_integer(char *p) {
  BOOL retval;

  if (p == 0) return 0;
  if (*p == '-') p++;
  if (*p == 0) return 0;

  retval = 1;

  for (; *p; p++) {
    if ( (*p < '0') || (*p > '9') ) {
      retval = 0;
    }
  }

  return retval;
}



static BOOL is_float(char *p) {
  BOOL retval, number_found=0;

  if (p == 0) return 0;
  if (*p == '-') p++;
  if (*p == 0) return 0;

  retval = 1;

  for (; *p; p++) {
    if ((*p == '.') || (*p == ',')) {
      if (!number_found) retval = 0;
    } else if ( (*p >= '0') && (*p <= '9') ) {
      number_found = 1;
    } else {
      return 0;
    }
  }

  return retval;
}



static BOOL is_bool_str(char *str, BOOL *pbool) {
  int64 vint;
  double vdouble;

  if (str == 0 || pbool == 0) return 0;

  if (strcasecmp(str, "true") == 0) goto loc_true;
  if (strcasecmp(str, "yes") == 0) goto loc_true;
  if (strcasecmp(str, "on") == 0) goto loc_true;


  if (strcasecmp(str, "false") == 0) goto loc_false;
  if (strcasecmp(str, "no") == 0) goto loc_false;
  if (strcasecmp(str, "off") == 0) goto loc_false;


  if (is_integer(str)) {
    vint = atoi64(str);
    *pbool = (vint != 0) ? 1 : 0;
    return 1;
  } else if (is_float(str)) {
    vdouble = atof(str);
    *pbool = (vdouble != 0) ? 1 : 0;
    return 1;
  }

  return 0;

loc_true:
  *pbool = 1;
  return 1;

loc_false:
  *pbool = 0;
  return 1;

}



BOOL binn_get_int32(binn *value, int *pint) {

  if (value == 0 || pint == 0) return 0;

  if (type_family(value->type) == 0xf2) {
    return copy_int_value(value->ptr, pint, value->type, 0x61);
  }

  switch (value->type) {
  case 0x62:
    if ((value->vfloat < INT32_MIN) || (value->vfloat > INT32_MAX)) return 0;
    *pint = value->vfloat >= 0.0 ? (int)(value->vfloat + 0.5) : ((value->vfloat - (double)(int)value->vfloat) <= -0.5 ? (int)value->vfloat : (int)(value->vfloat - 0.5));
    break;
  case 0x82:
    if ((value->vdouble < INT32_MIN) || (value->vdouble > INT32_MAX)) return 0;
    *pint = value->vdouble >= 0.0 ? (int)(value->vdouble + 0.5) : ((value->vdouble - (double)(int)value->vdouble) <= -0.5 ? (int)value->vdouble : (int)(value->vdouble - 0.5));
    break;
  case 0xA0:
    if (is_integer((char*)value->ptr))
      *pint = atoi((char*)value->ptr);
    else if (is_float((char*)value->ptr))
      *pint = atof((char*)value->ptr) >= 0.0 ? (int)(atof((char*)value->ptr) + 0.5) : ((atof((char*)value->ptr) - (double)(int)atof((char*)value->ptr)) <= -0.5 ? (int)atof((char*)value->ptr) : (int)(atof((char*)value->ptr) - 0.5));
    else
      return 0;
    break;
  case 0x80061:
    *pint = value->vbool;
    break;
  default:
    return 0;
  }

  return 1;
}



BOOL binn_get_int64(binn *value, int64 *pint) {

  if (value == 0 || pint == 0) return 0;

  if (type_family(value->type) == 0xf2) {
    return copy_int_value(value->ptr, pint, value->type, 0x81);
  }

  switch (value->type) {
  case 0x62:
    if ((value->vfloat < INT64_MIN) || (value->vfloat > INT64_MAX)) return 0;
    *pint = value->vfloat >= 0.0 ? (int)(value->vfloat + 0.5) : ((value->vfloat - (double)(int)value->vfloat) <= -0.5 ? (int)value->vfloat : (int)(value->vfloat - 0.5));
    break;
  case 0x82:
    if ((value->vdouble < INT64_MIN) || (value->vdouble > INT64_MAX)) return 0;
    *pint = value->vdouble >= 0.0 ? (int)(value->vdouble + 0.5) : ((value->vdouble - (double)(int)value->vdouble) <= -0.5 ? (int)value->vdouble : (int)(value->vdouble - 0.5));
    break;
  case 0xA0:
    if (is_integer((char*)value->ptr))
      *pint = atoi64((char*)value->ptr);
    else if (is_float((char*)value->ptr))
      *pint = atof((char*)value->ptr) >= 0.0 ? (int)(atof((char*)value->ptr) + 0.5) : ((atof((char*)value->ptr) - (double)(int)atof((char*)value->ptr)) <= -0.5 ? (int)atof((char*)value->ptr) : (int)(atof((char*)value->ptr) - 0.5));
    else
      return 0;
    break;
  case 0x80061:
    *pint = value->vbool;
    break;
  default:
    return 0;
  }

  return 1;
}



BOOL binn_get_double(binn *value, double *pfloat) {
  int64 vint;

  if (value == 0 || pfloat == 0) return 0;

  if (type_family(value->type) == 0xf2) {
    if (copy_int_value(value->ptr, &vint, value->type, 0x81) == 0) return 0;
    *pfloat = (double) vint;
    return 1;
  }

  switch (value->type) {
  case 0x62:
    *pfloat = value->vfloat;
    break;
  case 0x82:
    *pfloat = value->vdouble;
    break;
  case 0xA0:
    if (is_integer((char*)value->ptr))
      *pfloat = (double) atoi64((char*)value->ptr);
    else if (is_float((char*)value->ptr))
      *pfloat = atof((char*)value->ptr);
    else
      return 0;
    break;
  case 0x80061:
    *pfloat = value->vbool;
    break;
  default:
    return 0;
  }

  return 1;
}



BOOL binn_get_bool(binn *value, BOOL *pbool) {
  int64 vint;

  if (value == 0 || pbool == 0) return 0;

  if (type_family(value->type) == 0xf2) {
    if (copy_int_value(value->ptr, &vint, value->type, 0x81) == 0) return 0;
    *pbool = (vint != 0) ? 1 : 0;
    return 1;
  }

  switch (value->type) {
  case 0x80061:
    *pbool = value->vbool;
    break;
  case 0x62:
    *pbool = (value->vfloat != 0) ? 1 : 0;
    break;
  case 0x82:
    *pbool = (value->vdouble != 0) ? 1 : 0;
    break;
  case 0xA0:
    return is_bool_str((char*)value->ptr, pbool);
  default:
    return 0;
  }

  return 1;
}



char * binn_get_str(binn *value) {
  int64 vint;
  char buf[128];

  if (value == 0) return 0;

  if (type_family(value->type) == 0xf2) {
    if (copy_int_value(value->ptr, &vint, value->type, 0x81) == 0) return 0;
    snprintf(buf, sizeof buf, "%" "lli", vint);
    goto loc_convert_value;
  }

  switch (value->type) {
  case 0x62:
    value->vdouble = value->vfloat;
  case 0x82:
    snprintf(buf, sizeof buf, "%g", value->vdouble);
    goto loc_convert_value;
  case 0xA0:
    return (char*) value->ptr;
  case 0x80061:
    if (value->vbool)
      strcpy(buf, "true");
    else
      strcpy(buf, "false");
    goto loc_convert_value;
  }

  return 0;

loc_convert_value:


  value->ptr = strdup(buf);
  if (value->ptr == 0) return 0;
  value->freefn = free;
  value->type = 0xA0;
  return (char*) value->ptr;

}





BOOL binn_is_container(binn *item) {

  if (item == 0) return 0;

  switch (item->type) {
  case 0xE0:
  case 0xE1:
  case 0xE2:
    return 1;
  default:
    return 0;
  }

}
