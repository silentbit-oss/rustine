# 0 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 1
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 2
# 2 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 3 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/memory.h" 1
# 4 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/string.h" 1
# 5 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/math.h" 1
# 6 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/assert.h" 1
# 7 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/../src/binn.h" 1
# 33 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/../src/binn.h"
typedef int BOOL;
# 67 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/../src/binn.h"
  typedef long long int int64;
  typedef unsigned long long int uint64;
# 199 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/../src/binn.h"
typedef void (*binn_mem_free)(void*);







struct binn_struct {
  int header;
  BOOL allocated;
  BOOL writable;
  BOOL dirty;

  void *pbuf;
  BOOL pre_allocated;
  int alloc_size;
  int used_size;

  int type;
  void *ptr;
  int size;
  int count;

  binn_mem_free freefn;

  union {
    signed char vint8;
    signed short vint16;
    signed int vint32;
    int64 vint64;
    unsigned char vuint8;
    unsigned short vuint16;
    unsigned int vuint32;
    uint64 vuint64;

    signed char vchar;
    unsigned char vuchar;
    signed short vshort;
    unsigned short vushort;
    signed int vint;
    unsigned int vuint;

    float vfloat;
    double vdouble;

    BOOL vbool;
  };

  BOOL disable_int_compression;
};

typedef struct binn_struct binn;





char * binn_version();

void binn_set_alloc_functions(void* (*new_malloc)(size_t), void* (*new_realloc)(void*,size_t), void (*new_free)(void*));

int binn_create_type(int storage_type, int data_type_index);
BOOL binn_get_type_info(int long_type, int *pstorage_type, int *pextra_type);

int binn_get_write_storage(int type);
int binn_get_read_storage(int type);

BOOL binn_is_container(binn *item);





binn * binn_new(int type, int size, void *buffer);
binn * binn_list();
binn * binn_map();
binn * binn_object();


BOOL binn_create(binn *item, int type, int size, void *buffer);
BOOL binn_create_list(binn *list);
BOOL binn_create_map(binn *map);
BOOL binn_create_object(binn *object);


binn * binn_copy(void *old);


BOOL binn_list_add_new(binn *list, binn *value);
BOOL binn_map_set_new(binn *map, int id, binn *value);
BOOL binn_object_set_new(binn *obj, const char *key, binn *value);




BOOL binn_list_add(binn *list, int type, void *pvalue, int size);
BOOL binn_map_set(binn *map, int id, int type, void *pvalue, int size);
BOOL binn_object_set(binn *obj, const char *key, int type, void *pvalue, int size);




void binn_free(binn *item);
void * binn_release(binn *item);




binn * binn_value(int type, void *pvalue, int size, binn_mem_free freefn);

static inline binn * binn_int8(signed char value) {
  return binn_value(0x21, &value, 0, 0);
}
static inline binn * binn_int16(short value) {
  return binn_value(0x41, &value, 0, 0);
}
static inline binn * binn_int32(int value) {
  return binn_value(0x61, &value, 0, 0);
}
static inline binn * binn_int64(int64 value) {
  return binn_value(0x81, &value, 0, 0);
}
static inline binn * binn_uint8(unsigned char value) {
  return binn_value(0x20, &value, 0, 0);
}
static inline binn * binn_uint16(unsigned short value) {
  return binn_value(0x40, &value, 0, 0);
}
static inline binn * binn_uint32(unsigned int value) {
  return binn_value(0x60, &value, 0, 0);
}
static inline binn * binn_uint64(uint64 value) {
  return binn_value(0x80, &value, 0, 0);
}
static inline binn * binn_float(float value) {
  return binn_value(0x62, &value, 0, 0);
}
static inline binn * binn_double(double value) {
  return binn_value(0x82, &value, 0, 0);
}
static inline binn * binn_bool(BOOL value) {
  return binn_value(0x80061, &value, 0, 0);
}
static inline binn * binn_null() {
  return binn_value(0x00, 0, 0, 0);
}
static inline binn * binn_string(char *str, binn_mem_free freefn) {
  return binn_value(0xA0, str, 0, freefn);
}
static inline binn * binn_blob(void *ptr, int size, binn_mem_free freefn) {
  return binn_value(0xC0, ptr, size, freefn);
}





void * binn_ptr(void *ptr);
int binn_size(void *ptr);
int binn_type(void *ptr);
int binn_count(void *ptr);

BOOL binn_is_valid(void *ptr, int *ptype, int *pcount, int *psize);






BOOL binn_is_valid_ex(void *ptr, int *ptype, int *pcount, int *psize);
# 378 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/../src/binn.h"
BOOL binn_is_struct(void *ptr);




BOOL binn_load(void *data, binn *item);
binn * binn_open(void *data);




signed char binn_list_int8(void *list, int pos);
short binn_list_int16(void *list, int pos);
int binn_list_int32(void *list, int pos);
int64 binn_list_int64(void *list, int pos);
unsigned char binn_list_uint8(void *list, int pos);
unsigned short binn_list_uint16(void *list, int pos);
unsigned int binn_list_uint32(void *list, int pos);
uint64 binn_list_uint64(void *list, int pos);
float binn_list_float(void *list, int pos);
double binn_list_double(void *list, int pos);
BOOL binn_list_bool(void *list, int pos);
BOOL binn_list_null(void *list, int pos);
char * binn_list_str(void *list, int pos);
void * binn_list_blob(void *list, int pos, int *psize);
void * binn_list_list(void *list, int pos);
void * binn_list_map(void *list, int pos);
void * binn_list_object(void *list, int pos);

signed char binn_map_int8(void *map, int id);
short binn_map_int16(void *map, int id);
int binn_map_int32(void *map, int id);
int64 binn_map_int64(void *map, int id);
unsigned char binn_map_uint8(void *map, int id);
unsigned short binn_map_uint16(void *map, int id);
unsigned int binn_map_uint32(void *map, int id);
uint64 binn_map_uint64(void *map, int id);
float binn_map_float(void *map, int id);
double binn_map_double(void *map, int id);
BOOL binn_map_bool(void *map, int id);
BOOL binn_map_null(void *map, int id);
char * binn_map_str(void *map, int id);
void * binn_map_blob(void *map, int id, int *psize);
void * binn_map_list(void *map, int id);
void * binn_map_map(void *map, int id);
void * binn_map_object(void *map, int id);

signed char binn_object_int8(void *obj, const char *key);
short binn_object_int16(void *obj, const char *key);
int binn_object_int32(void *obj, const char *key);
int64 binn_object_int64(void *obj, const char *key);
unsigned char binn_object_uint8(void *obj, const char *key);
unsigned short binn_object_uint16(void *obj, const char *key);
unsigned int binn_object_uint32(void *obj, const char *key);
uint64 binn_object_uint64(void *obj, const char *key);
float binn_object_float(void *obj, const char *key);
double binn_object_double(void *obj, const char *key);
BOOL binn_object_bool(void *obj, const char *key);
BOOL binn_object_null(void *obj, const char *key);
char * binn_object_str(void *obj, const char *key);
void * binn_object_blob(void *obj, const char *key, int *psize);
void * binn_object_list(void *obj, const char *key);
void * binn_object_map(void *obj, const char *key);
void * binn_object_object(void *obj, const char *key);



binn * binn_list_value(void *list, int pos);
binn * binn_map_value(void *map, int id);
binn * binn_object_value(void *obj, const char *key);


BOOL binn_list_get_value(void* list, int pos, binn *value);
BOOL binn_map_get_value(void* map, int id, binn *value);
BOOL binn_object_get_value(void *obj, const char *key, binn *value);


BOOL binn_list_get(void *list, int pos, int type, void *pvalue, int *psize);
BOOL binn_map_get(void *map, int id, int type, void *pvalue, int *psize);
BOOL binn_object_get(void *obj, const char *key, int type, void *pvalue, int *psize);





void * binn_list_read(void *list, int pos, int *ptype, int *psize);
void * binn_map_read(void *map, int id, int *ptype, int *psize);
void * binn_object_read(void *obj, const char *key, int *ptype, int *psize);







BOOL binn_map_get_pair(void *map, int pos, int *pid, binn *value);
BOOL binn_object_get_pair(void *obj, int pos, char *pkey, binn *value);


binn * binn_map_pair(void *map, int pos, int *pid);
binn * binn_object_pair(void *obj, int pos, char *pkey);





void * binn_map_read_pair(void *ptr, int pos, int *pid, int *ptype, int *psize);
void * binn_object_read_pair(void *ptr, int pos, char *pkey, int *ptype, int *psize);




typedef struct binn_iter_struct {
    unsigned char *pnext;
    unsigned char *plimit;
    int type;
    int count;
    int current;
} binn_iter;

BOOL binn_iter_init(binn_iter *iter, void *pbuf, int type);


binn * binn_list_next_value(binn_iter *iter);
binn * binn_map_next_value(binn_iter *iter, int *pid);
binn * binn_object_next_value(binn_iter *iter, char *pkey);


BOOL binn_list_next(binn_iter *iter, binn *value);
BOOL binn_map_next(binn_iter *iter, int *pid, binn *value);
BOOL binn_object_next(binn_iter *iter, char *pkey, binn *value);





void * binn_list_read_next(binn_iter *iter, int *ptype, int *psize);
void * binn_map_read_next(binn_iter *iter, int *pid, int *ptype, int *psize);
void * binn_object_read_next(binn_iter *iter, char *pkey, int *ptype, int *psize);
# 542 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/../src/binn.h"
BOOL binn_set_string(binn *item, char *str, binn_mem_free pfree);
BOOL binn_set_blob(binn *item, void *ptr, int size, binn_mem_free pfree);
# 575 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/../src/binn.h"
static inline BOOL binn_list_add_int8(binn *list, signed char value) {
  return binn_list_add(list, 0x21, &value, 0);
}
static inline BOOL binn_list_add_int16(binn *list, short value) {
  return binn_list_add(list, 0x41, &value, 0);
}
static inline BOOL binn_list_add_int32(binn *list, int value) {
  return binn_list_add(list, 0x61, &value, 0);
}
static inline BOOL binn_list_add_int64(binn *list, int64 value) {
  return binn_list_add(list, 0x81, &value, 0);
}
static inline BOOL binn_list_add_uint8(binn *list, unsigned char value) {
  return binn_list_add(list, 0x20, &value, 0);
}
static inline BOOL binn_list_add_uint16(binn *list, unsigned short value) {
  return binn_list_add(list, 0x40, &value, 0);
}
static inline BOOL binn_list_add_uint32(binn *list, unsigned int value) {
  return binn_list_add(list, 0x60, &value, 0);
}
static inline BOOL binn_list_add_uint64(binn *list, uint64 value) {
  return binn_list_add(list, 0x80, &value, 0);
}
static inline BOOL binn_list_add_float(binn *list, float value) {
  return binn_list_add(list, 0x62, &value, 0);
}
static inline BOOL binn_list_add_double(binn *list, double value) {
  return binn_list_add(list, 0x82, &value, 0);
}
static inline BOOL binn_list_add_bool(binn *list, BOOL value) {
  return binn_list_add(list, 0x80061, &value, 0);
}
static inline BOOL binn_list_add_null(binn *list) {
  return binn_list_add(list, 0x00, 0, 0);
}
static inline BOOL binn_list_add_str(binn *list, char *str) {
  return binn_list_add(list, 0xA0, str, 0);
}
static inline BOOL binn_list_add_blob(binn *list, void *ptr, int size) {
  return binn_list_add(list, 0xC0, ptr, size);
}
static inline BOOL binn_list_add_list(binn *list, void *list2) {
  return binn_list_add(list, 0xE0, binn_ptr(list2), binn_size(list2));
}
static inline BOOL binn_list_add_map(binn *list, void *map) {
  return binn_list_add(list, 0xE1, binn_ptr(map), binn_size(map));
}
static inline BOOL binn_list_add_object(binn *list, void *obj) {
  return binn_list_add(list, 0xE2, binn_ptr(obj), binn_size(obj));
}
static inline BOOL binn_list_add_value(binn *list, binn *value) {
  return binn_list_add(list, value->type, binn_ptr(value), binn_size(value));
}



static inline BOOL binn_map_set_int8(binn *map, int id, signed char value) {
  return binn_map_set(map, id, 0x21, &value, 0);
}
static inline BOOL binn_map_set_int16(binn *map, int id, short value) {
  return binn_map_set(map, id, 0x41, &value, 0);
}
static inline BOOL binn_map_set_int32(binn *map, int id, int value) {
  return binn_map_set(map, id, 0x61, &value, 0);
}
static inline BOOL binn_map_set_int64(binn *map, int id, int64 value) {
  return binn_map_set(map, id, 0x81, &value, 0);
}
static inline BOOL binn_map_set_uint8(binn *map, int id, unsigned char value) {
  return binn_map_set(map, id, 0x20, &value, 0);
}
static inline BOOL binn_map_set_uint16(binn *map, int id, unsigned short value) {
  return binn_map_set(map, id, 0x40, &value, 0);
}
static inline BOOL binn_map_set_uint32(binn *map, int id, unsigned int value) {
  return binn_map_set(map, id, 0x60, &value, 0);
}
static inline BOOL binn_map_set_uint64(binn *map, int id, uint64 value) {
  return binn_map_set(map, id, 0x80, &value, 0);
}
static inline BOOL binn_map_set_float(binn *map, int id, float value) {
  return binn_map_set(map, id, 0x62, &value, 0);
}
static inline BOOL binn_map_set_double(binn *map, int id, double value) {
  return binn_map_set(map, id, 0x82, &value, 0);
}
static inline BOOL binn_map_set_bool(binn *map, int id, BOOL value) {
  return binn_map_set(map, id, 0x80061, &value, 0);
}
static inline BOOL binn_map_set_null(binn *map, int id) {
  return binn_map_set(map, id, 0x00, 0, 0);
}
static inline BOOL binn_map_set_str(binn *map, int id, char *str) {
  return binn_map_set(map, id, 0xA0, str, 0);
}
static inline BOOL binn_map_set_blob(binn *map, int id, void *ptr, int size) {
  return binn_map_set(map, id, 0xC0, ptr, size);
}
static inline BOOL binn_map_set_list(binn *map, int id, void *list) {
  return binn_map_set(map, id, 0xE0, binn_ptr(list), binn_size(list));
}
static inline BOOL binn_map_set_map(binn *map, int id, void *map2) {
  return binn_map_set(map, id, 0xE1, binn_ptr(map2), binn_size(map2));
}
static inline BOOL binn_map_set_object(binn *map, int id, void *obj) {
  return binn_map_set(map, id, 0xE2, binn_ptr(obj), binn_size(obj));
}
static inline BOOL binn_map_set_value(binn *map, int id, binn *value) {
  return binn_map_set(map, id, value->type, binn_ptr(value), binn_size(value));
}



static inline BOOL binn_object_set_int8(binn *obj, const char *key, signed char value) {
  return binn_object_set(obj, key, 0x21, &value, 0);
}
static inline BOOL binn_object_set_int16(binn *obj, const char *key, short value) {
  return binn_object_set(obj, key, 0x41, &value, 0);
}
static inline BOOL binn_object_set_int32(binn *obj, const char *key, int value) {
  return binn_object_set(obj, key, 0x61, &value, 0);
}
static inline BOOL binn_object_set_int64(binn *obj, const char *key, int64 value) {
  return binn_object_set(obj, key, 0x81, &value, 0);
}
static inline BOOL binn_object_set_uint8(binn *obj, const char *key, unsigned char value) {
  return binn_object_set(obj, key, 0x20, &value, 0);
}
static inline BOOL binn_object_set_uint16(binn *obj, const char *key, unsigned short value) {
  return binn_object_set(obj, key, 0x40, &value, 0);
}
static inline BOOL binn_object_set_uint32(binn *obj, const char *key, unsigned int value) {
  return binn_object_set(obj, key, 0x60, &value, 0);
}
static inline BOOL binn_object_set_uint64(binn *obj, const char *key, uint64 value) {
  return binn_object_set(obj, key, 0x80, &value, 0);
}
static inline BOOL binn_object_set_float(binn *obj, const char *key, float value) {
  return binn_object_set(obj, key, 0x62, &value, 0);
}
static inline BOOL binn_object_set_double(binn *obj, const char *key, double value) {
  return binn_object_set(obj, key, 0x82, &value, 0);
}
static inline BOOL binn_object_set_bool(binn *obj, const char *key, BOOL value) {
  return binn_object_set(obj, key, 0x80061, &value, 0);
}
static inline BOOL binn_object_set_null(binn *obj, const char *key) {
  return binn_object_set(obj, key, 0x00, 0, 0);
}
static inline BOOL binn_object_set_str(binn *obj, const char *key, char *str) {
  return binn_object_set(obj, key, 0xA0, str, 0);
}
static inline BOOL binn_object_set_blob(binn *obj, const char *key, void *ptr, int size) {
  return binn_object_set(obj, key, 0xC0, ptr, size);
}
static inline BOOL binn_object_set_list(binn *obj, const char *key, void *list) {
  return binn_object_set(obj, key, 0xE0, binn_ptr(list), binn_size(list));
}
static inline BOOL binn_object_set_map(binn *obj, const char *key, void *map) {
  return binn_object_set(obj, key, 0xE1, binn_ptr(map), binn_size(map));
}
static inline BOOL binn_object_set_object(binn *obj, const char *key, void *obj2) {
  return binn_object_set(obj, key, 0xE2, binn_ptr(obj2), binn_size(obj2));
}
static inline BOOL binn_object_set_value(binn *obj, const char *key, binn *value) {
  return binn_object_set(obj, key, value->type, binn_ptr(value), binn_size(value));
}





static inline BOOL binn_list_get_int8(void *list, int pos, signed char *pvalue) {
  return binn_list_get(list, pos, 0x21, pvalue, 0);
}
static inline BOOL binn_list_get_int16(void *list, int pos, short *pvalue) {
  return binn_list_get(list, pos, 0x41, pvalue, 0);
}
static inline BOOL binn_list_get_int32(void *list, int pos, int *pvalue) {
  return binn_list_get(list, pos, 0x61, pvalue, 0);
}
static inline BOOL binn_list_get_int64(void *list, int pos, int64 *pvalue) {
  return binn_list_get(list, pos, 0x81, pvalue, 0);
}
static inline BOOL binn_list_get_uint8(void *list, int pos, unsigned char *pvalue) {
  return binn_list_get(list, pos, 0x20, pvalue, 0);
}
static inline BOOL binn_list_get_uint16(void *list, int pos, unsigned short *pvalue) {
  return binn_list_get(list, pos, 0x40, pvalue, 0);
}
static inline BOOL binn_list_get_uint32(void *list, int pos, unsigned int *pvalue) {
  return binn_list_get(list, pos, 0x60, pvalue, 0);
}
static inline BOOL binn_list_get_uint64(void *list, int pos, uint64 *pvalue) {
  return binn_list_get(list, pos, 0x80, pvalue, 0);
}
static inline BOOL binn_list_get_float(void *list, int pos, float *pvalue) {
  return binn_list_get(list, pos, 0x62, pvalue, 0);
}
static inline BOOL binn_list_get_double(void *list, int pos, double *pvalue) {
  return binn_list_get(list, pos, 0x82, pvalue, 0);
}
static inline BOOL binn_list_get_bool(void *list, int pos, BOOL *pvalue) {
  return binn_list_get(list, pos, 0x80061, pvalue, 0);
}
static inline BOOL binn_list_get_str(void *list, int pos, char **pvalue) {
  return binn_list_get(list, pos, 0xA0, pvalue, 0);
}
static inline BOOL binn_list_get_blob(void *list, int pos, void **pvalue, int *psize) {
  return binn_list_get(list, pos, 0xC0, pvalue, psize);
}
static inline BOOL binn_list_get_list(void *list, int pos, void **pvalue) {
  return binn_list_get(list, pos, 0xE0, pvalue, 0);
}
static inline BOOL binn_list_get_map(void *list, int pos, void **pvalue) {
  return binn_list_get(list, pos, 0xE1, pvalue, 0);
}
static inline BOOL binn_list_get_object(void *list, int pos, void **pvalue) {
  return binn_list_get(list, pos, 0xE2, pvalue, 0);
}



static inline BOOL binn_map_get_int8(void *map, int id, signed char *pvalue) {
  return binn_map_get(map, id, 0x21, pvalue, 0);
}
static inline BOOL binn_map_get_int16(void *map, int id, short *pvalue) {
  return binn_map_get(map, id, 0x41, pvalue, 0);
}
static inline BOOL binn_map_get_int32(void *map, int id, int *pvalue) {
  return binn_map_get(map, id, 0x61, pvalue, 0);
}
static inline BOOL binn_map_get_int64(void *map, int id, int64 *pvalue) {
  return binn_map_get(map, id, 0x81, pvalue, 0);
}
static inline BOOL binn_map_get_uint8(void *map, int id, unsigned char *pvalue) {
  return binn_map_get(map, id, 0x20, pvalue, 0);
}
static inline BOOL binn_map_get_uint16(void *map, int id, unsigned short *pvalue) {
  return binn_map_get(map, id, 0x40, pvalue, 0);
}
static inline BOOL binn_map_get_uint32(void *map, int id, unsigned int *pvalue) {
  return binn_map_get(map, id, 0x60, pvalue, 0);
}
static inline BOOL binn_map_get_uint64(void *map, int id, uint64 *pvalue) {
  return binn_map_get(map, id, 0x80, pvalue, 0);
}
static inline BOOL binn_map_get_float(void *map, int id, float *pvalue) {
  return binn_map_get(map, id, 0x62, pvalue, 0);
}
static inline BOOL binn_map_get_double(void *map, int id, double *pvalue) {
  return binn_map_get(map, id, 0x82, pvalue, 0);
}
static inline BOOL binn_map_get_bool(void *map, int id, BOOL *pvalue) {
  return binn_map_get(map, id, 0x80061, pvalue, 0);
}
static inline BOOL binn_map_get_str(void *map, int id, char **pvalue) {
  return binn_map_get(map, id, 0xA0, pvalue, 0);
}
static inline BOOL binn_map_get_blob(void *map, int id, void **pvalue, int *psize) {
  return binn_map_get(map, id, 0xC0, pvalue, psize);
}
static inline BOOL binn_map_get_list(void *map, int id, void **pvalue) {
  return binn_map_get(map, id, 0xE0, pvalue, 0);
}
static inline BOOL binn_map_get_map(void *map, int id, void **pvalue) {
  return binn_map_get(map, id, 0xE1, pvalue, 0);
}
static inline BOOL binn_map_get_object(void *map, int id, void **pvalue) {
  return binn_map_get(map, id, 0xE2, pvalue, 0);
}






static inline BOOL binn_object_get_int8(void *obj, const char *key, signed char *pvalue) {
  return binn_object_get(obj, key, 0x21, pvalue, 0);
}
static inline BOOL binn_object_get_int16(void *obj, const char *key, short *pvalue) {
  return binn_object_get(obj, key, 0x41, pvalue, 0);
}
static inline BOOL binn_object_get_int32(void *obj, const char *key, int *pvalue) {
  return binn_object_get(obj, key, 0x61, pvalue, 0);
}
static inline BOOL binn_object_get_int64(void *obj, const char *key, int64 *pvalue) {
  return binn_object_get(obj, key, 0x81, pvalue, 0);
}
static inline BOOL binn_object_get_uint8(void *obj, const char *key, unsigned char *pvalue) {
  return binn_object_get(obj, key, 0x20, pvalue, 0);
}
static inline BOOL binn_object_get_uint16(void *obj, const char *key, unsigned short *pvalue) {
  return binn_object_get(obj, key, 0x40, pvalue, 0);
}
static inline BOOL binn_object_get_uint32(void *obj, const char *key, unsigned int *pvalue) {
  return binn_object_get(obj, key, 0x60, pvalue, 0);
}
static inline BOOL binn_object_get_uint64(void *obj, const char *key, uint64 *pvalue) {
  return binn_object_get(obj, key, 0x80, pvalue, 0);
}
static inline BOOL binn_object_get_float(void *obj, const char *key, float *pvalue) {
  return binn_object_get(obj, key, 0x62, pvalue, 0);
}
static inline BOOL binn_object_get_double(void *obj, const char *key, double *pvalue) {
  return binn_object_get(obj, key, 0x82, pvalue, 0);
}
static inline BOOL binn_object_get_bool(void *obj, const char *key, BOOL *pvalue) {
  return binn_object_get(obj, key, 0x80061, pvalue, 0);
}
static inline BOOL binn_object_get_str(void *obj, const char *key, char **pvalue) {
  return binn_object_get(obj, key, 0xA0, pvalue, 0);
}
static inline BOOL binn_object_get_blob(void *obj, const char *key, void **pvalue, int *psize) {
  return binn_object_get(obj, key, 0xC0, pvalue, psize);
}
static inline BOOL binn_object_get_list(void *obj, const char *key, void **pvalue) {
  return binn_object_get(obj, key, 0xE0, pvalue, 0);
}
static inline BOOL binn_object_get_map(void *obj, const char *key, void **pvalue) {
  return binn_object_get(obj, key, 0xE1, pvalue, 0);
}
static inline BOOL binn_object_get_object(void *obj, const char *key, void **pvalue) {
  return binn_object_get(obj, key, 0xE2, pvalue, 0);
}



BOOL binn_get_int32(binn *value, int *pint);
BOOL binn_get_int64(binn *value, int64 *pint);
BOOL binn_get_double(binn *value, double *pfloat);
BOOL binn_get_bool(binn *value, BOOL *pbool);
char * binn_get_str(binn *value);
# 8 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c" 2





int MY_DATE;
int MY_CURRENCY;

char tmp[128];

void * memdup(void *src, int size);

char * i64toa(int64 val, char *buf, int radix);



int64 atoi64(char *str);


BOOL AlmostEqualFloats(float A, float B, int maxUlps);



int vint32; unsigned int vuint32;
int64 vint64; uint64 vuint64;
short vint16; unsigned short vuint16;
signed char vint8; unsigned char vuint8;
float vfloat32;
double vfloat64;
BOOL vbool;



char * stripchr(char *mainstr, int separator) {
  char *ptr;

  if (mainstr == 0) return 0;

  ptr = strchr(mainstr, separator);
  if (ptr == 0) return 0;
  ptr[0] = '\0';
  ptr++;
  return ptr;

}







unsigned short str_to_date(char *datestr) {
  unsigned short date;
  int day, month, year;
  char *next;

  if (datestr == 0) return 0;
  strcpy(tmp, datestr);
  datestr = tmp;

  next = stripchr(datestr, '-');
  year = atoi(datestr) - 1900;

  datestr = next;
  next = stripchr(datestr, '-');
  month = atoi(datestr);

  day = atoi(next);

  date = (day << 11) | (month << 7) | year;
  return date;

}



char * date_to_str(unsigned short date) {
  int day, month, year;


  day = ((date & 0xf800) >> 11);
  month = ((date & 0x0780) >> 7);
  year = (date & 0x007f);

  sprintf(tmp, "%.4d-%.2d-%.2d", year + 1900 , month, day);

  return tmp;

}
# 107 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c"
int64 str_to_currency(char *str) {
  char *next;
  int size, i;

  if (str == 0) return 0;
  strcpy(tmp, str);
  str = tmp;

  next = strchr(str, '.');
  if (next) {
    size = strlen(next+1);
    memmove(next, next+1, size+1);
    if (size <= 4) {
      size = 4 - size;
      for (i=0; i<size; i++) strcat(str, "0");
    } else {
      next[4] = 0;
    }
  } else {
    strcat(str, "0000");
  }

  return atoi64(str);

}



char * currency_to_str(int64 value) {
  char *str, *ptr;
  int size, move, i;

  i64toa(value, tmp, 10);
  str = tmp;

  size = strlen(str);
  if (size > 4) {
    ptr = str + size - 4;
    memmove(ptr+1, ptr, 4 +1);
    ptr[0] = '.';
  } else {
    move = 2 + 4 - size;
    memmove(str+move, str, size+1);
    str[0] = '0';
    str[1] = '.';
    for (i=2; i<move; i++) str[i] = '0';
  }

  return str;
}



int64 float_to_currency(double value) {
  char buf[128];

  snprintf(buf, 127, "%.4f", value);

  return str_to_currency(buf);

}



double currency_to_float(int64 value) {

  currency_to_str(value);

  return atof(tmp);

}



int64 mul_currency(int64 value1, int64 value2) {
  return value1 * value2 / 10000;
}



int64 div_currency(int64 value1, int64 value2) {
  return value1 * 10000 / value2;
}
# 212 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c"
char * test_create_object_1(int *psize) {
  binn *obj=0, *list=0;

  printf("creating object 1...\n");

  obj = binn_object();
  assert(obj != 0);

  vint32 = -12345;
  assert(binn_object_set(obj, "int32", 0x61, &vint32, 0) == 1);
  vint16 = -258;
  assert(binn_object_set(obj, "int16", 0x41, &vint16, 0) == 1);
  vint8 = -120;
  assert(binn_object_set(obj, "int8", 0x21, &vint8, 0) == 1);
  vint64 = -1234567890123;
  assert(binn_object_set(obj, "int64", 0x81, &vint64, 0) == 1);

  vuint32 = 123456;
  assert(binn_object_set(obj, "uint32", 0x60, &vuint32, 0) == 1);
  vuint16 = 60500;
  assert(binn_object_set(obj, "uint16", 0x40, &vuint16, 0) == 1);
  vuint8 = 250;
  assert(binn_object_set(obj, "uint8", 0x20, &vuint8, 0) == 1);
  vuint64 = 1234567890123;
  assert(binn_object_set(obj, "uint64", 0x80, &vuint64, 0) == 1);

  vfloat32 = -12.345;
  assert(binn_object_set(obj, "float32", 0x62, &vfloat32, 0) == 1);
  vfloat32 = -12.345;
  assert(binn_object_set(obj, "single", 0x62, &vfloat32, 0) == 1);
  vfloat64 = -123456.7895;
  assert(binn_object_set(obj, "float64", 0x82, &vfloat64, 0) == 1);
  vfloat64 = -123456.7895;
  assert(binn_object_set(obj, "double", 0x82, &vfloat64, 0) == 1);

  assert(binn_object_set(obj, "str", 0xA0, "the value", 0) == 1);

  vint32 = 1;
  assert(binn_object_set(obj, "bool_true", 0x80061, &vint32, 0) == 1);
  vint32 = 0;
  assert(binn_object_set(obj, "bool_false", 0x80061, &vint32, 0) == 1);

  assert(binn_object_set(obj, "null", 0x00, 0, 0) == 1);




  list = binn_list();
  assert(list != 0);

  assert(binn_list_add(list, 0x00, 0, 0) == 1);
  vint32 = 123;
  assert(binn_list_add(list, 0x61, &vint32, 0) == 1);
  assert(binn_list_add(list, 0xA0, "this is a string", 0) == 1);

  assert(binn_object_set(obj, "list", 0xE0, binn_ptr(list), binn_size(list)) == 1);

  binn_free(list); list = 0;




  *psize = binn_size(obj);
  return (char *) binn_ptr(obj);

}



char * test_create_object_2(int *psize) {
  binn *obj=0, *list=0;

  printf("creating object 2...\n");

  obj = binn_object();
  assert(obj != 0);

  assert(binn_object_set_int32(obj, "int32", -12345) == 1);
  assert(binn_object_set_int16(obj, "int16", -258) == 1);
  assert(binn_object_set_int8(obj, "int8", -120) == 1);
  assert(binn_object_set_int64(obj, "int64", -1234567890123) == 1);

  assert(binn_object_set_uint32(obj, "uint32", 123456) == 1);
  assert(binn_object_set_int16(obj, "uint16", 60500) == 1);
  assert(binn_object_set_int8(obj, "uint8", 250) == 1);
  assert(binn_object_set_uint64(obj, "uint64", 1234567890123) == 1);

  assert(binn_object_set_float(obj, "float32", -12.345) == 1);
  vfloat32 = -12.345;
  assert(binn_object_set(obj, "single", 0x62, &vfloat32, 0) == 1);
  assert(binn_object_set_double(obj, "float64", -123456.7895) == 1);
  vfloat64 = -123456.7895;
  assert(binn_object_set(obj, "double", 0x82, &vfloat64, 0) == 1);

  assert(binn_object_set_str(obj, "str", "the value") == 1);

  assert(binn_object_set_bool(obj, "bool_true", 1) == 1);
  assert(binn_object_set_bool(obj, "bool_false", 0) == 1);

  assert(binn_object_set_null(obj, "null") == 1);




  list = binn_list();
  assert(list != 0);

  assert(binn_list_add_null(list) == 1);
  assert(binn_list_add_int32(list, 123) == 1);
  assert(binn_list_add_str(list, "this is a string") == 1);

  assert(binn_object_set_list(obj, "list", list) == 1);

  binn_free(list); list = 0;




  *psize = binn_size(obj);
  return (char *) binn_ptr(obj);

}



void test_binn_read(void *objptr) {
  void *listptr;
  char *ptr;
  binn value={0};

  printf("OK\nreading:\n");

  vint32 = 0;
  assert(binn_object_get(objptr, "int32", 0x61, &vint32, 0) == 1);
  printf("int32: %d\n", vint32);
  assert(vint32 == -12345);

  vint16 = 0;
  assert(binn_object_get(objptr, "int16", 0x41, &vint16, 0) == 1);
  printf("int16: %d\n", vint16);
  assert(vint16 == -258);

  vint8 = 0;
  assert(binn_object_get(objptr, "int8", 0x21, &vint8, 0) == 1);
  printf("int8: %d\n", vint8);
  assert(vint8 == -120);

  vint64 = 0;
  assert(binn_object_get(objptr, "int64", 0x81, &vint64, 0) == 1);
  printf("int64: %" "lli" "\n", vint64);
  assert(vint64 == -1234567890123);


  vuint32 = 0;
  assert(binn_object_get(objptr, "uint32", 0x60, &vuint32, 0) == 1);
  printf("uint32: %d\n", vuint32);
  assert(vuint32 == 123456);

  vuint16 = 0;
  assert(binn_object_get(objptr, "uint16", 0x40, &vuint16, 0) == 1);
  printf("uint16: %d\n", vuint16);
  assert(vuint16 == 60500);

  vuint8 = 0;
  assert(binn_object_get(objptr, "uint8", 0x20, &vuint8, 0) == 1);
  printf("uint8: %d\n", vuint8);
  assert(vuint8 == 250);

  vuint64 = 0;
  assert(binn_object_get(objptr, "uint64", 0x80, &vuint64, 0) == 1);
  printf("uint64: %" "llu" "\n", vuint64);
  assert(vuint64 == 1234567890123);


  vfloat32 = 0;
  assert(binn_object_get(objptr, "float32", 0x62, &vfloat32, 0) == 1);
  printf("float32: %f\n", vfloat32);
  assert(AlmostEqualFloats(vfloat32, -12.345, 2) == 1);

  vfloat64 = 0;
  assert(binn_object_get(objptr, "float64", 0x82, &vfloat64, 0) == 1);
  printf("float64: %f\n", vfloat64);
  assert(vfloat64 - -123456.7895 < 0.01);

  vfloat32 = 0;
  assert(binn_object_get(objptr, "single", 0x62, &vfloat32, 0) == 1);
  printf("single: %f\n", vfloat32);
  assert(AlmostEqualFloats(vfloat32, -12.345, 2) == 1);

  vfloat64 = 0;
  assert(binn_object_get(objptr, "double", 0x82, &vfloat64, 0) == 1);
  printf("double: %f\n", vfloat64);
  assert(vfloat64 - -123456.7895 < 0.01);


  ptr = 0;
  assert(binn_object_get(objptr, "str", 0xA0, &ptr, 0) == 1);
  printf("ptr: (%p) '%s'\n", ptr, ptr);
  assert(strcmp(ptr, "the value") == 0);


  vint32 = 999;
  assert(binn_object_get(objptr, "bool_true", 0x80061, &vint32, 0) == 1);
  printf("bool true: %d\n", vint32);
  assert(vint32 == 1);

  vint32 = 999;
  assert(binn_object_get(objptr, "bool_false", 0x80061, &vint32, 0) == 1);
  printf("bool false: %d\n", vint32);
  assert(vint32 == 0);


  vint32 = 999;
  assert(binn_object_get(objptr, "null", 0x00, &vint32, 0) == 1);
  printf("null: %d\n", vint32);

  assert(binn_object_get(objptr, "null", 0x00, 0, 0) == 1);


  assert(binn_object_get(objptr, "list", 0xE0, &listptr, 0) == 1);
  printf("obj ptr: %p  list ptr: %p\n", objptr, listptr);
  assert(listptr != 0);
  assert(listptr > objptr);

  vint32 = 0;
  assert(binn_list_get(listptr, 2, 0x61, &vint32, 0) == 1);
  printf("int32: %d\n", vint32);
  assert(vint32 == 123);

  ptr = 0;
  assert(binn_list_get(listptr, 3, 0xA0, &ptr, 0) == 1);
  printf("ptr: (%p) '%s'\n", ptr, ptr);
  assert(strcmp(ptr, "this is a string") == 0);






  vint32 = 0;
  assert(binn_object_get_int32(objptr, "int32", &vint32) == 1);
  printf("int32: %d\n", vint32);
  assert(vint32 == -12345);

  vint16 = 0;
  assert(binn_object_get_int16(objptr, "int16", &vint16) == 1);
  printf("int16: %d\n", vint16);
  assert(vint16 == -258);

  vint8 = 0;
  assert(binn_object_get_int8(objptr, "int8", &vint8) == 1);
  printf("int8: %d\n", vint8);
  assert(vint8 == -120);

  vint64 = 0;
  assert(binn_object_get_int64(objptr, "int64", &vint64) == 1);
  printf("int64: %" "lli" "\n", vint64);
  assert(vint64 == -1234567890123);


  vuint32 = 0;
  assert(binn_object_get_uint32(objptr, "uint32", &vuint32) == 1);
  printf("uint32: %d\n", vuint32);
  assert(vuint32 == 123456);

  vuint16 = 0;
  assert(binn_object_get_uint16(objptr, "uint16", &vuint16) == 1);
  printf("uint16: %d\n", vuint16);
  assert(vuint16 == 60500);

  vuint8 = 0;
  assert(binn_object_get_uint8(objptr, "uint8", &vuint8) == 1);
  printf("uint8: %d\n", vuint8);
  assert(vuint8 == 250);

  vuint64 = 0;
  assert(binn_object_get_uint64(objptr, "uint64", &vuint64) == 1);
  printf("uint64: %" "llu" "\n", vuint64);
  assert(vuint64 == 1234567890123);


  vfloat32 = 0;
  assert(binn_object_get_float(objptr, "float32", &vfloat32) == 1);
  printf("float32: %f\n", vfloat32);
  assert(AlmostEqualFloats(vfloat32, -12.345, 2) == 1);

  vfloat64 = 0;
  assert(binn_object_get_double(objptr, "float64", &vfloat64) == 1);
  printf("float64: %f\n", vfloat64);
  assert(AlmostEqualFloats(vfloat32, -12.345, 2) == 1);


  ptr = 0;
  assert(binn_object_get_str(objptr, "str", &ptr) == 1);
  printf("ptr: (%p) '%s'\n", ptr, ptr);
  assert(strcmp(ptr, "the value") == 0);


  vint32 = 999;
  assert(binn_object_get_bool(objptr, "bool_true", &vint32) == 1);
  printf("bool true: %d\n", vint32);
  assert(vint32 == 1);

  vint32 = 999;
  assert(binn_object_get_bool(objptr, "bool_false", &vint32) == 1);
  printf("bool false: %d\n", vint32);
  assert(vint32 == 0);


  vbool = 0;
  assert(binn_object_null(objptr, "null") == 1);

  assert(binn_object_null(objptr, "bool_true") == 0);


  assert(binn_object_get_list(objptr, "list", &listptr) == 1);
  printf("obj ptr: %p  list ptr: %p\n", objptr, listptr);
  assert(listptr != 0);
  assert(listptr > objptr);

  vint32 = 0;
  assert(binn_list_get_int32(listptr, 2, &vint32) == 1);
  printf("int32: %d\n", vint32);
  assert(vint32 == 123);

  ptr = 0;
  assert(binn_list_get_str(listptr, 3, &ptr) == 1);
  printf("ptr: (%p) '%s'\n", ptr, ptr);
  assert(strcmp(ptr, "this is a string") == 0);






  vint32 = binn_object_int32(objptr, "int32");
  printf("int32: %d\n", vint32);
  assert(vint32 == -12345);

  vint16 = binn_object_int16(objptr, "int16");
  printf("int16: %d\n", vint16);
  assert(vint16 == -258);

  vint8 = binn_object_int8(objptr, "int8");
  printf("int8: %d\n", vint8);
  assert(vint8 == -120);

  vint64 = binn_object_int64(objptr, "int64");
  printf("int64: %" "lli" "\n", vint64);
  assert(vint64 == -1234567890123);


  vuint32 = binn_object_uint32(objptr, "uint32");
  printf("uint32: %d\n", vuint32);
  assert(vuint32 == 123456);

  vuint16 = binn_object_uint16(objptr, "uint16");
  printf("uint16: %d\n", vuint16);
  assert(vuint16 == 60500);

  vuint8 = binn_object_uint8(objptr, "uint8");
  printf("uint8: %d\n", vuint8);
  assert(vuint8 == 250);

  vuint64 = binn_object_uint64(objptr, "uint64");
  printf("uint64: %" "llu" "\n", vuint64);
  assert(vuint64 == 1234567890123);


  vfloat32 = binn_object_float(objptr, "float32");
  printf("float32: %f\n", vfloat32);
  assert(AlmostEqualFloats(vfloat32, -12.345, 2) == 1);

  vfloat64 = binn_object_double(objptr, "float64");
  printf("float64: %f\n", vfloat64);
  assert(AlmostEqualFloats(vfloat32, -12.345, 2) == 1);


  ptr = binn_object_str(objptr, "str");
  printf("ptr: (%p) '%s'\n", ptr, ptr);
  assert(strcmp(ptr, "the value") == 0);


  vint32 = binn_object_bool(objptr, "bool_true");
  printf("bool true: %d\n", vint32);
  assert(vint32 == 1);

  vint32 = binn_object_bool(objptr, "bool_false");
  printf("bool false: %d\n", vint32);
  assert(vint32 == 0);


  assert(binn_object_null(objptr, "null") == 1);
  assert(binn_object_null(objptr, "nonull") == 0);


  listptr = binn_object_list(objptr, "list");
  printf("obj ptr: %p  list ptr: %p\n", objptr, listptr);
  assert(listptr != 0);
  assert(listptr > objptr);

  vint32 = binn_list_int32(listptr, 2);
  printf("int32: %d\n", vint32);
  assert(vint32 == 123);

  ptr = binn_list_str(listptr, 3);
  printf("ptr: (%p) '%s'\n", ptr, ptr);
  assert(strcmp(ptr, "this is a string") == 0);






  assert(binn_object_get_value(objptr, "int32", &value) == 1);

  assert(value.type == 0x41);
  assert(value.vint16 == -12345);





  assert(binn_object_get_value(objptr, "int16", &value) == 1);
  assert(value.type == 0x41);
  assert(value.vint16 == -258);

  assert(binn_object_get_value(objptr, "int8", &value) == 1);
  assert(value.type == 0x21);
  assert(value.vint8 == -120);

  assert(binn_object_get_value(objptr, "int64", &value) == 1);
  assert(value.type == 0x81);
  assert(value.vint64 == -1234567890123);


  assert(binn_object_get_value(objptr, "uint32", &value) == 1);
  assert(value.type == 0x60);
  assert(value.vuint32 == 123456);

  assert(binn_object_get_value(objptr, "uint16", &value) == 1);
  assert(value.type == 0x40);
  assert(value.vuint16 == 60500);

  assert(binn_object_get_value(objptr, "uint8", &value) == 1);
  assert(value.type == 0x20);
  assert(value.vuint8 == 250);

  assert(binn_object_get_value(objptr, "uint64", &value) == 1);
  assert(value.type == 0x80);
  assert(value.vuint64 == 1234567890123);

  puts("reading... OK");

}



void init_udts() {
  binn *obj=0;
  unsigned short date;
  uint64 value;
  void *ptr;

  puts("testing UDTs...");

  assert(strcmp(date_to_str(str_to_date("1950-08-15")), "1950-08-15") == 0);
  assert(strcmp(date_to_str(str_to_date("1900-12-01")), "1900-12-01") == 0);
  assert(strcmp(date_to_str(str_to_date("2000-10-31")), "2000-10-31") == 0);
  assert(strcmp(date_to_str(str_to_date("2014-03-19")), "2014-03-19") == 0);

  printf("curr=%s\n", currency_to_str(str_to_currency("123.456")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("123.45")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("123.4")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("123.")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("123")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("1.2")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("0.987")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("0.98")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("0.9")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("0.0")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("0")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("123.4567")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("123.45678")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("123.456789")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("0.1234")) );
  printf("curr=%s\n", currency_to_str(str_to_currency(".1234")) );

  assert(float_to_currency(2.5) == 25000);
  assert(float_to_currency(5) == 50000);
  assert(str_to_currency("1.1") == 11000);
  assert(str_to_currency("12") == 120000);
  assert(mul_currency(20000, 20000) == 40000);
  assert(mul_currency(20000, 25000) == 50000);
  assert(mul_currency(30000, 40000) == 120000);
  assert(div_currency(80000, 20000) == 40000);
  assert(div_currency(120000, 40000) == 30000);
  assert(div_currency(100000, 40000) == 25000);

  printf("1.1 * 2.5 = %s\n", currency_to_str(mul_currency(str_to_currency("1.1"), float_to_currency(2.5))) );
  printf("12 / 5 = %s\n", currency_to_str(div_currency(str_to_currency("12"), float_to_currency(5))) );





  MY_DATE = binn_create_type(0x40, 0x0a);
  MY_CURRENCY = binn_create_type(0x80, 0x0a);


  obj = binn_object();
  assert(obj != 0);

  date = str_to_date("1950-08-15");
  printf(" date 1: %d %s\n", date, date_to_str(date));
  assert(binn_object_set(obj, "date1", MY_DATE, &date, 0) == 1);
  assert(binn_object_set(obj, "date1", MY_DATE, &date, 0) == 0);

  date = str_to_date("1999-12-31");
  printf(" date 2: %d %s\n", date, date_to_str(date));
  binn_object_set(obj, "date2", MY_DATE, &date, 0);


  value = str_to_currency("123.456");
  printf(" curr 1: %" "llu" " %s\n", value, currency_to_str(value));
  binn_object_set(obj, "curr1", MY_CURRENCY, &value, 0);

  value = str_to_currency("123.45");
  printf(" curr 2: %" "llu" " %s\n", value, currency_to_str(value));
  binn_object_set(obj, "curr2", MY_CURRENCY, &value, 0);

  value = str_to_currency("12.5");
  printf(" curr 3: %" "llu" " %s\n", value, currency_to_str(value));
  binn_object_set(obj, "curr3", MY_CURRENCY, &value, 0);

  value = str_to_currency("5");
  printf(" curr 4: %" "llu" " %s\n", value, currency_to_str(value));
  binn_object_set(obj, "curr4", MY_CURRENCY, &value, 0);

  value = str_to_currency("0.75");
  printf(" curr 5: %" "llu" " %s\n", value, currency_to_str(value));
  binn_object_set(obj, "curr5", MY_CURRENCY, &value, 0);


  ptr = binn_ptr(obj);


  assert(binn_object_get(ptr, "date1", MY_DATE, &date, 0) == 1);
  printf(" date 1: %d %s\n", date, date_to_str(date));

  assert(binn_object_get(ptr, "date2", MY_DATE, &date, 0) == 1);
  printf(" date 2: %d %s\n", date, date_to_str(date));


  assert(binn_object_get(ptr, "curr1", MY_CURRENCY, &value, 0) == 1);
  printf(" curr 1: %" "llu" " %s\n", value, currency_to_str(value));

  assert(binn_object_get(ptr, "curr2", MY_CURRENCY, &value, 0) == 1);
  printf(" curr 2: %" "llu" " %s\n", value, currency_to_str(value));

  assert(binn_object_get(ptr, "curr3", MY_CURRENCY, &value, 0) == 1);
  printf(" curr 3: %" "llu" " %s\n", value, currency_to_str(value));

  assert(binn_object_get(ptr, "curr4", MY_CURRENCY, &value, 0) == 1);
  printf(" curr 4: %" "llu" " %s\n", value, currency_to_str(value));

  assert(binn_object_get(ptr, "curr5", MY_CURRENCY, &value, 0) == 1);
  printf(" curr 5: %" "llu" " %s\n", value, currency_to_str(value));


  binn_free(obj);

  puts("testing UDTs... OK");

}



BOOL copy_int_value(void *psource, void *pdest, int source_type, int dest_type);

void test_int_conversion() {

  printf("testing integer conversion...");



  vint8 = -110; vuint8 = 0;
  assert(copy_int_value(&vint8, &vuint8, 0x21, 0x20) == 0);
  assert(vint8 == -110);
  assert(vuint8 == 0);

  vint8 = -110; vuint16 = 0;
  assert(copy_int_value(&vint8, &vuint16, 0x21, 0x40) == 0);
  assert(vint8 == -110);
  assert(vuint16 == 0);

  vint8 = -110; vuint32 = 0;
  assert(copy_int_value(&vint8, &vuint32, 0x21, 0x60) == 0);
  assert(vint8 == -110);
  assert(vuint32 == 0);

  vint8 = -110; vuint64 = 0;
  assert(copy_int_value(&vint8, &vuint64, 0x21, 0x80) == 0);
  assert(vint8 == -110);
  assert(vuint64 == 0);


  vint16 = -123; vuint8 = 0;
  assert(copy_int_value(&vint16, &vuint8, 0x41, 0x20) == 0);
  assert(vint16 == -123);
  assert(vuint8 == 0);

  vint16 = -123; vuint16 = 0;
  assert(copy_int_value(&vint16, &vuint16, 0x41, 0x40) == 0);
  assert(vint16 == -123);
  assert(vuint16 == 0);

  vint16 = -32000; vuint32 = 0;
  assert(copy_int_value(&vint16, &vuint32, 0x41, 0x60) == 0);
  assert(vint16 == -32000);
  assert(vuint32 == 0);

  vint16 = -32000; vuint64 = 0;
  assert(copy_int_value(&vint16, &vuint64, 0x41, 0x80) == 0);
  assert(vint16 == -32000);
  assert(vuint64 == 0);


  vint32 = -123; vuint8 = 0;
  assert(copy_int_value(&vint32, &vuint8, 0x61, 0x20) == 0);
  assert(vint32 == -123);
  assert(vuint8 == 0);

  vint32 = -123; vuint16 = 0;
  assert(copy_int_value(&vint32, &vuint16, 0x61, 0x40) == 0);
  assert(vint32 == -123);
  assert(vuint16 == 0);

  vint32 = -123; vuint32 = 0;
  assert(copy_int_value(&vint32, &vuint32, 0x61, 0x60) == 0);
  assert(vint32 == -123);
  assert(vuint32 == 0);

  vint32 = -123; vuint64 = 0;
  assert(copy_int_value(&vint32, &vuint64, 0x61, 0x80) == 0);
  assert(vint32 == -123);
  assert(vuint64 == 0);


  vint64 = -123; vuint8 = 0;
  assert(copy_int_value(&vint64, &vuint8, 0x81, 0x20) == 0);
  assert(vint64 == -123);
  assert(vuint8 == 0);

  vint64 = -123; vuint16 = 0;
  assert(copy_int_value(&vint64, &vuint16, 0x81, 0x40) == 0);
  assert(vint64 == -123);
  assert(vuint16 == 0);

  vint64 = -123; vuint32 = 0;
  assert(copy_int_value(&vint64, &vuint32, 0x81, 0x60) == 0);
  assert(vint64 == -123);
  assert(vuint32 == 0);

  vint64 = -123; vuint64 = 0;
  assert(copy_int_value(&vint64, &vuint64, 0x81, 0x80) == 0);
  assert(vint64 == -123);
  assert(vuint64 == 0);




  vint16 = -32000; vint8 = 0;
  assert(copy_int_value(&vint16, &vint8, 0x41, 0x21) == 0);
  assert(vint16 == -32000);
  assert(vint8 == 0);


  vint32 = -250; vint8 = 0;
  assert(copy_int_value(&vint32, &vint8, 0x61, 0x21) == 0);
  assert(vint32 == -250);
  assert(vint8 == 0);

  vint32 = -35000; vint16 = 0;
  assert(copy_int_value(&vint32, &vint16, 0x61, 0x41) == 0);
  assert(vint32 == -35000);
  assert(vint16 == 0);


  vint64 = -250; vint8 = 0;
  assert(copy_int_value(&vint64, &vint8, 0x81, 0x21) == 0);
  assert(vint64 == -250);
  assert(vint8 == 0);

  vint64 = -35000; vint16 = 0;
  assert(copy_int_value(&vint64, &vint16, 0x81, 0x41) == 0);
  assert(vint64 == -35000);
  assert(vint16 == 0);

  vint64 = -25470000000; vint32 = 0;
  assert(copy_int_value(&vint64, &vint32, 0x81, 0x61) == 0);
  assert(vint64 == -25470000000);
  assert(vint32 == 0);




  vint16 = 250; vint8 = 0;
  assert(copy_int_value(&vint16, &vint8, 0x41, 0x21) == 0);
  assert(vint16 == 250);
  assert(vint8 == 0);


  vint32 = 250; vint8 = 0;
  assert(copy_int_value(&vint32, &vint8, 0x61, 0x21) == 0);
  assert(vint32 == 250);
  assert(vint8 == 0);

  vint32 = 35000; vint16 = 0;
  assert(copy_int_value(&vint32, &vint16, 0x61, 0x41) == 0);
  assert(vint32 == 35000);
  assert(vint16 == 0);


  vint64 = 250; vint8 = 0;
  assert(copy_int_value(&vint64, &vint8, 0x81, 0x21) == 0);
  assert(vint64 == 250);
  assert(vint8 == 0);

  vint64 = 35000; vint16 = 0;
  assert(copy_int_value(&vint64, &vint16, 0x81, 0x41) == 0);
  assert(vint64 == 35000);
  assert(vint16 == 0);

  vint64 = 25470000000; vint32 = 0;
  assert(copy_int_value(&vint64, &vint32, 0x81, 0x61) == 0);
  assert(vint64 == 25470000000);
  assert(vint32 == 0);





  vint16 = 300; vuint8 = 0;
  assert(copy_int_value(&vint16, &vuint8, 0x41, 0x20) == 0);
  assert(vint16 == 300);
  assert(vuint8 == 0);


  vint32 = 300; vuint8 = 0;
  assert(copy_int_value(&vint32, &vuint8, 0x61, 0x20) == 0);
  assert(vint32 == 300);
  assert(vuint8 == 0);

  vint32 = 70000; vuint16 = 0;
  assert(copy_int_value(&vint32, &vuint16, 0x61, 0x40) == 0);
  assert(vint32 == 70000);
  assert(vuint16 == 0);


  vint64 = 300; vuint8 = 0;
  assert(copy_int_value(&vint64, &vuint8, 0x81, 0x20) == 0);
  assert(vint64 == 300);
  assert(vuint8 == 0);

  vint64 = 70000; vuint16 = 0;
  assert(copy_int_value(&vint64, &vuint16, 0x81, 0x40) == 0);
  assert(vint64 == 70000);
  assert(vuint16 == 0);

  vint64 = 25470000000; vuint32 = 0;
  assert(copy_int_value(&vint64, &vuint32, 0x81, 0x60) == 0);
  assert(vint64 == 25470000000);
  assert(vuint32 == 0);
# 994 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c"
  vint8 = 123; vint16 = 0;
  assert(copy_int_value(&vint8, &vint16, 0x21, 0x41) == 1);
  assert(vint8 == 123);
  assert(vint16 == 123);

  vint8 = -110; vint16 = 0;
  assert(copy_int_value(&vint8, &vint16, 0x21, 0x41) == 1);
  assert(vint8 == -110);
  assert(vint16 == -110);

  vint8 = 123; vint32 = 0;
  assert(copy_int_value(&vint8, &vint32, 0x21, 0x61) == 1);
  assert(vint8 == 123);
  assert(vint32 == 123);

  vint8 = -110; vint32 = 0;
  assert(copy_int_value(&vint8, &vint32, 0x21, 0x61) == 1);
  assert(vint8 == -110);
  assert(vint32 == -110);

  vint8 = 123; vint64 = 0;
  assert(copy_int_value(&vint8, &vint64, 0x21, 0x81) == 1);
  assert(vint8 == 123);
  assert(vint64 == 123);

  vint8 = -120; vint64 = 0;
  assert(copy_int_value(&vint8, &vint64, 0x21, 0x81) == 1);
  assert(vint8 == -120);
  assert(vint64 == -120);




  vint8 = 123; vuint16 = 0;
  assert(copy_int_value(&vint8, &vuint16, 0x21, 0x40) == 1);
  assert(vint8 == 123);
  assert(vuint16 == 123);

  vint8 = 123; vuint32 = 0;
  assert(copy_int_value(&vint8, &vuint32, 0x21, 0x60) == 1);
  assert(vint8 == 123);
  assert(vuint32 == 123);

  vint8 = 123; vuint64 = 0;
  assert(copy_int_value(&vint8, &vuint64, 0x21, 0x80) == 1);
  assert(vint8 == 123);
  assert(vuint64 == 123);





  vuint8 = 123; vint16 = 0;
  assert(copy_int_value(&vuint8, &vint16, 0x20, 0x41) == 1);
  assert(vuint8 == 123);
  assert(vint16 == 123);

  vuint8 = 250; vint16 = 0;
  assert(copy_int_value(&vuint8, &vint16, 0x20, 0x41) == 1);
  assert(vuint8 == 250);
  assert(vint16 == 250);

  vuint8 = 123; vint32 = 0;
  assert(copy_int_value(&vuint8, &vint32, 0x20, 0x61) == 1);
  assert(vuint8 == 123);
  assert(vint32 == 123);

  vuint8 = 250; vint32 = 0;
  assert(copy_int_value(&vuint8, &vint32, 0x20, 0x61) == 1);
  assert(vuint8 == 250);
  assert(vint32 == 250);

  vuint8 = 123; vint64 = 0;
  assert(copy_int_value(&vuint8, &vint64, 0x20, 0x81) == 1);
  assert(vuint8 == 123);
  assert(vint64 == 123);

  vuint8 = 250; vint64 = 0;
  assert(copy_int_value(&vuint8, &vint64, 0x20, 0x81) == 1);
  assert(vuint8 == 250);
  assert(vint64 == 250);




  vuint8 = 123; vuint16 = 0;
  assert(copy_int_value(&vuint8, &vuint16, 0x20, 0x40) == 1);
  assert(vuint8 == 123);
  assert(vuint16 == 123);

  vuint8 = 250; vuint16 = 0;
  assert(copy_int_value(&vuint8, &vuint16, 0x20, 0x40) == 1);
  assert(vuint8 == 250);
  assert(vuint16 == 250);

  vuint8 = 123; vuint32 = 0;
  assert(copy_int_value(&vuint8, &vuint32, 0x20, 0x60) == 1);
  assert(vuint8 == 123);
  assert(vuint32 == 123);

  vuint8 = 250; vuint32 = 0;
  assert(copy_int_value(&vuint8, &vuint32, 0x20, 0x60) == 1);
  assert(vuint8 == 250);
  assert(vuint32 == 250);

  vuint8 = 123; vuint64 = 0;
  assert(copy_int_value(&vuint8, &vuint64, 0x20, 0x80) == 1);
  assert(vuint8 == 123);
  assert(vuint64 == 123);

  vuint8 = 250; vuint64 = 0;
  assert(copy_int_value(&vuint8, &vuint64, 0x20, 0x80) == 1);
  assert(vuint8 == 250);
  assert(vuint64 == 250);




  vint16 = 250; vuint8 = 0;
  assert(copy_int_value(&vint16, &vuint8, 0x41, 0x20) == 1);
  assert(vint16 == 250);
  assert(vuint8 == 250);


  vint32 = 250; vuint8 = 0;
  assert(copy_int_value(&vint32, &vuint8, 0x61, 0x20) == 1);
  assert(vint32 == 250);
  assert(vuint8 == 250);

  vint32 = 35000; vuint16 = 0;
  assert(copy_int_value(&vint32, &vuint16, 0x61, 0x40) == 1);
  assert(vint32 == 35000);
  assert(vuint16 == 35000);


  vint64 = 250; vuint8 = 0;
  assert(copy_int_value(&vint64, &vuint8, 0x81, 0x20) == 1);
  assert(vint64 == 250);
  assert(vuint8 == 250);

  vint64 = 35000; vuint16 = 0;
  assert(copy_int_value(&vint64, &vuint16, 0x81, 0x40) == 1);
  assert(vint64 == 35000);
  assert(vuint16 == 35000);

  vint64 = 2147000000; vuint32 = 0;
  assert(copy_int_value(&vint64, &vuint32, 0x81, 0x60) == 1);
  assert(vint64 == 2147000000);
  assert(vuint32 == 2147000000);







  vint8 = -110; vint16 = 0;
  assert(copy_int_value(&vint8, &vint16, 0x21, 0x41) == 1);
  assert(vint8 == -110);
  assert(vint16 == -110);

  vint8 = -110; vint32 = 0;
  assert(copy_int_value(&vint8, &vint32, 0x21, 0x61) == 1);
  assert(vint8 == -110);
  assert(vint32 == -110);

  vint8 = -110; vint64 = 0;
  assert(copy_int_value(&vint8, &vint64, 0x21, 0x81) == 1);
  assert(vint8 == -110);
  assert(vint64 == -110);


  vint16 = -123; vint8 = 0;
  assert(copy_int_value(&vint16, &vint8, 0x41, 0x21) == 1);
  assert(vint16 == -123);
  assert(vint8 == -123);

  vint16 = -32000; vint32 = 0;
  assert(copy_int_value(&vint16, &vint32, 0x41, 0x61) == 1);
  assert(vint16 == -32000);
  assert(vint32 == -32000);

  vint16 = -32000; vint64 = 0;
  assert(copy_int_value(&vint16, &vint64, 0x41, 0x81) == 1);
  assert(vint16 == -32000);
  assert(vint64 == -32000);


  vint32 = -123; vint8 = 0;
  assert(copy_int_value(&vint32, &vint8, 0x61, 0x21) == 1);
  assert(vint32 == -123);
  assert(vint8 == -123);

  vint32 = -123; vint16 = 0;
  assert(copy_int_value(&vint32, &vint16, 0x61, 0x41) == 1);
  assert(vint32 == -123);
  assert(vint16 == -123);

  vint32 = -32000; vint16 = 0;
  assert(copy_int_value(&vint32, &vint16, 0x61, 0x41) == 1);
  assert(vint32 == -32000);
  assert(vint16 == -32000);

  vint32 = -123; vint64 = 0;
  assert(copy_int_value(&vint32, &vint64, 0x61, 0x81) == 1);
  assert(vint32 == -123);
  assert(vint64 == -123);

  vint32 = -2147000000; vint64 = 0;
  assert(copy_int_value(&vint32, &vint64, 0x61, 0x81) == 1);
  assert(vint32 == -2147000000);
  assert(vint64 == -2147000000);


  vint64 = -123; vint8 = 0;
  assert(copy_int_value(&vint64, &vint8, 0x81, 0x21) == 1);
  assert(vint64 == -123);
  assert(vint8 == -123);

  vint64 = -250; vint16 = 0;
  assert(copy_int_value(&vint64, &vint16, 0x81, 0x41) == 1);
  assert(vint64 == -250);
  assert(vint16 == -250);

  vint64 = -35000; vint32 = 0;
  assert(copy_int_value(&vint64, &vint32, 0x81, 0x61) == 1);
  assert(vint64 == -35000);
  assert(vint32 == -35000);


  puts("OK");

}



void test_binn_int_conversion() {
  binn *obj=0;
  void *ptr;

  printf("testing binn integer read conversion... ");

  obj = binn_object();
  assert(obj != 0);

  assert(binn_object_set_int8(obj, "int8", -8) == 1);
  assert(binn_object_set_int16(obj, "int16", -16) == 1);
  assert(binn_object_set_int32(obj, "int32", -32) == 1);
  assert(binn_object_set_int64(obj, "int64", -64) == 1);

  assert(binn_object_set_uint8(obj, "uint8", 111) == 1);
  assert(binn_object_set_uint16(obj, "uint16", 112) == 1);
  assert(binn_object_set_uint32(obj, "uint32", 113) == 1);
  assert(binn_object_set_uint64(obj, "uint64", 114) == 1);

  ptr = binn_ptr(obj);

  assert(binn_object_int8(ptr, "int8") == -8);
  assert(binn_object_int8(ptr, "int16") == -16);
  assert(binn_object_int8(ptr, "int32") == -32);
  assert(binn_object_int8(ptr, "int64") == -64);

  assert(binn_object_int16(ptr, "int8") == -8);
  assert(binn_object_int16(ptr, "int16") == -16);
  assert(binn_object_int16(ptr, "int32") == -32);
  assert(binn_object_int16(ptr, "int64") == -64);

  assert(binn_object_int32(ptr, "int8") == -8);
  assert(binn_object_int32(ptr, "int16") == -16);
  assert(binn_object_int32(ptr, "int32") == -32);
  assert(binn_object_int32(ptr, "int64") == -64);

  assert(binn_object_int64(ptr, "int8") == -8);
  assert(binn_object_int64(ptr, "int16") == -16);
  assert(binn_object_int64(ptr, "int32") == -32);
  assert(binn_object_int64(ptr, "int64") == -64);


  assert(binn_object_int8(ptr, "uint8") == 111);
  assert(binn_object_int8(ptr, "uint16") == 112);
  assert(binn_object_int8(ptr, "uint32") == 113);
  assert(binn_object_int8(ptr, "uint64") == 114);

  assert(binn_object_int16(ptr, "uint8") == 111);
  assert(binn_object_int16(ptr, "uint16") == 112);
  assert(binn_object_int16(ptr, "uint32") == 113);
  assert(binn_object_int16(ptr, "uint64") == 114);

  assert(binn_object_int32(ptr, "uint8") == 111);
  assert(binn_object_int32(ptr, "uint16") == 112);
  assert(binn_object_int32(ptr, "uint32") == 113);
  assert(binn_object_int32(ptr, "uint64") == 114);

  assert(binn_object_int64(ptr, "uint8") == 111);
  assert(binn_object_int64(ptr, "uint16") == 112);
  assert(binn_object_int64(ptr, "uint32") == 113);
  assert(binn_object_int64(ptr, "uint64") == 114);


  binn_free(obj);

  puts("OK");

}



void test_value_conversion() {
  binn *value;
  char *ptr, blob[64] = "test blob";
  void *pblob;
  int size, vint32;
  int64 vint64;
  double vdouble;
  BOOL vbool;

  printf("testing binn value conversion... ");



  ptr = "static string";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn == 0);
  binn_free(value);

  ptr = "transient string";
  value = binn_string(ptr, ((binn_mem_free)-1));
  assert(value != 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr != ptr);
  assert(strcmp((char*)value->ptr, ptr) == 0);
  assert(value->freefn != 0);
  binn_free(value);

  ptr = strdup("dynamic allocated string");
  value = binn_string(ptr, free);
  assert(value != 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn != 0);
  assert(value->freefn == &free);
  binn_free(value);



  size = 64;
  pblob = blob;
  value = binn_blob(pblob, size, ((binn_mem_free)0));
  assert(value != 0);
  assert(value->type == 0xC0);
  assert(value->ptr != 0);
  assert(value->ptr == pblob);
  assert(value->freefn == 0);
  binn_free(value);

  size = 64;
  pblob = blob;
  value = binn_blob(pblob, size, ((binn_mem_free)-1));
  assert(value != 0);
  assert(value->type == 0xC0);
  assert(value->ptr != 0);
  assert(value->ptr != pblob);
  assert(memcmp(value->ptr, pblob, size) == 0);
  assert(value->freefn != 0);
  binn_free(value);

  size = 64;
  pblob = memdup(blob, size);
  value = binn_blob(pblob, size, free);
  assert(value != 0);
  assert(value->type == 0xC0);
  assert(value->ptr != 0);
  assert(value->ptr == pblob);
  assert(value->freefn == &free);
  binn_free(value);




  ptr = "123";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn == 0);

  assert(binn_get_str(value) == ptr);
  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == 123);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == 123);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, 123, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);

  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn == 0);

  binn_free(value);


  ptr = "-456";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn == 0);

  assert(binn_get_str(value) == ptr);
  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == -456);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == -456);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, -456, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);

  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn == 0);

  binn_free(value);


  ptr = "-4.56";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn == 0);

  assert(binn_get_str(value) == ptr);
  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == -4);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == -4);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, -4.56, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);

  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn == 0);

  binn_free(value);




  ptr = "yes";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(binn_get_str(value) == ptr);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);
  binn_free(value);

  ptr = "no";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 0);
  binn_free(value);

  ptr = "on";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);
  binn_free(value);

  ptr = "off";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 0);
  binn_free(value);

  ptr = "true";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);
  binn_free(value);

  ptr = "false";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 0);
  binn_free(value);

  ptr = "1";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);
  binn_free(value);

  ptr = "0";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 0);
  binn_free(value);




  value = binn_int32(-345);
  assert(value != 0);
  assert(value->type == 0x61);
  assert(value->vint32 == -345);
  assert(value->freefn == 0);

  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == -345);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == -345);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, -345, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);

  assert(value->type == 0x61);
  assert(value->vint32 == -345);
  assert(value->freefn == 0);

  ptr = binn_get_str(value);
  assert(ptr != 0);
  assert(strcmp(ptr, "-345") == 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn != 0);

  binn_free(value);


  value = binn_int32(0);
  assert(value != 0);
  assert(value->type == 0x61);
  assert(value->vint32 == 0);
  assert(value->freefn == 0);

  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == 0);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == 0);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, 0, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 0);

  assert(value->type == 0x61);
  assert(value->vint32 == 0);
  assert(value->freefn == 0);

  ptr = binn_get_str(value);
  assert(ptr != 0);
  assert(strcmp(ptr, "0") == 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn != 0);

  binn_free(value);




  value = binn_int64(-345678);
  assert(value != 0);
  assert(value->type == 0x81);
  assert(value->vint64 == -345678);
  assert(value->freefn == 0);

  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == -345678);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == -345678);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, -345678, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);

  assert(value->type == 0x81);
  assert(value->vint64 == -345678);
  assert(value->freefn == 0);

  ptr = binn_get_str(value);
  assert(ptr != 0);
  assert(strcmp(ptr, "-345678") == 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn != 0);

  binn_free(value);




  value = binn_double(-345.678);
  assert(value != 0);
  assert(value->type == 0x82);
  assert(value->vdouble == -345.678);
  assert(value->freefn == 0);

  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == -345);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == -345);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, -345.678, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);

  assert(value->type == 0x82);
  assert(value->vdouble == -345.678);
  assert(value->freefn == 0);

  ptr = binn_get_str(value);
  assert(ptr != 0);
  assert(strcmp(ptr, "-345.678") == 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn != 0);

  binn_free(value);


  value = binn_double(0.0);
  assert(value != 0);
  assert(value->type == 0x82);
  assert(value->vdouble == 0.0);
  assert(value->freefn == 0);

  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == 0);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == 0);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, 0, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 0);

  assert(value->type == 0x82);
  assert(value->vdouble == 0.0);
  assert(value->freefn == 0);

  ptr = binn_get_str(value);
  assert(ptr != 0);
  assert(strcmp(ptr, "0") == 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn != 0);

  binn_free(value);




  value = binn_bool(0);
  assert(value != 0);
  assert(value->type == 0x80061);
  assert(value->vbool == 0);
  assert(value->freefn == 0);

  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == 0);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == 0);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, 0, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 0);

  assert(value->type == 0x80061);
  assert(value->vbool == 0);
  assert(value->freefn == 0);

  ptr = binn_get_str(value);
  assert(ptr != 0);
  assert(strcmp(ptr, "false") == 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn != 0);

  binn_free(value);


  value = binn_bool(1);
  assert(value != 0);
  assert(value->type == 0x80061);
  assert(value->vbool == 1);
  assert(value->freefn == 0);

  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == 1);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == 1);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, 1, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);

  assert(value->type == 0x80061);
  assert(value->vbool == 1);
  assert(value->freefn == 0);

  ptr = binn_get_str(value);
  assert(ptr != 0);
  assert(strcmp(ptr, "true") == 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn != 0);

  binn_free(value);


  puts("OK");

}



void test_value_copy() {

  printf("testing binn value copy... ");



  puts("TODO!!!");

}



void test_virtual_types() {
  binn *list=0;
  void *ptr;
  int storage_type, extra_type;
  BOOL value;

  printf("testing binn virtual types... ");

  assert(binn_get_type_info(0x80061, &storage_type, &extra_type) == 1);
  assert(storage_type == 0x60);
  assert(extra_type == 1);

  list = binn_list();
  assert(list != 0);

  assert(binn_list_add_bool(list, 1) == 1);
  assert(binn_list_add_bool(list, 0) == 1);
  assert(binn_list_add_null(list) == 1);

  ptr = binn_ptr(list);
  assert(ptr != 0);

  assert(binn_list_get_bool(ptr, 1, &value) == 1);
  assert(value == 1);

  assert(binn_list_get_bool(ptr, 2, &value) == 1);
  assert(value == 0);

  assert(binn_list_null(ptr, 3) == 1);


  assert(binn_list_null(ptr, 1) == 0);
  assert(binn_list_null(ptr, 2) == 0);
  assert(binn_list_get_bool(ptr, 3, &value) == 0);

  binn_free(list);

  puts("OK");
}



void test_binn_iter(BOOL use_int_compression) {
  binn *list, *map, *obj;
  binn *list2, *copy=0;
  binn_iter iter, iter2;
  binn value, value2;
  int blob_size, id, id2, list2size;
  void *ptr, *blob_ptr;
  char key[256], key2[256];

  blob_ptr = "key\0value\0\0";
  blob_size = 11;

  printf("testing binn sequential read (use_int_compression = %d)... ", use_int_compression);



  list = binn_list();
  list2 = binn_list();
  map = binn_map();
  obj = binn_object();

  assert(list != 0);
  assert(list2 != 0);
  assert(map != 0);
  assert(obj != 0);

  if (use_int_compression == 0) {
    list->disable_int_compression = 1;
    map->disable_int_compression = 1;
    obj->disable_int_compression = 1;
  }

  assert(binn_list_add_int32(list2, 250) == 1);
  assert(binn_list_add_null(list2) == 1);
  assert(binn_list_add_str(list2, "l1st2") == 1);
  assert(binn_list_add_bool(list2, 1) == 1);

  list2size = binn_size(list2);

  assert(binn_list_add_int8(list, 111) == 1);
  assert(binn_list_add_int32(list, 123456789) == 1);
  assert(binn_list_add_int16(list, -123) == 1);
  assert(binn_list_add_int64(list, 9876543210) == 1);
  assert(binn_list_add_float(list, 1.25) == 1);
  assert(binn_list_add_double(list, 25.987654321) == 1);
  assert(binn_list_add_bool(list, 1) == 1);
  assert(binn_list_add_bool(list, 0) == 1);
  assert(binn_list_add_null(list) == 1);
  assert(binn_list_add_str(list, "testing...") == 1);
  assert(binn_list_add_blob(list, (char *)blob_ptr, blob_size) == 1);
  assert(binn_list_add_list(list, list2) == 1);

  assert(binn_object_set_int8(obj, "a", 111) == 1);
  assert(binn_object_set_int32(obj, "b", 123456789) == 1);
  assert(binn_object_set_int16(obj, "c", -123) == 1);
  assert(binn_object_set_int64(obj, "d", 9876543210) == 1);
  assert(binn_object_set_float(obj, "e", 1.25) == 1);
  assert(binn_object_set_double(obj, "f", 25.987654321) == 1);
  assert(binn_object_set_bool(obj, "g", 1) == 1);
  assert(binn_object_set_bool(obj, "h", 0) == 1);
  assert(binn_object_set_null(obj, "i") == 1);
  assert(binn_object_set_str(obj, "j", "testing...") == 1);
  assert(binn_object_set_blob(obj, "k", (char *)blob_ptr, blob_size) == 1);
  assert(binn_object_set_list(obj, "l", list2) == 1);

  assert(binn_map_set_int8(map, 55010, 111) == 1);
  assert(binn_map_set_int32(map, 55020, 123456789) == 1);
  assert(binn_map_set_int16(map, 55030, -123) == 1);
  assert(binn_map_set_int64(map, 55040, 9876543210) == 1);
  assert(binn_map_set_float(map, 55050, 1.25) == 1);
  assert(binn_map_set_double(map, 55060, 25.987654321) == 1);
  assert(binn_map_set_bool(map, 55070, 1) == 1);
  assert(binn_map_set_bool(map, 55080, 0) == 1);
  assert(binn_map_set_null(map, 55090) == 1);
  assert(binn_map_set_str(map, 55100, "testing...") == 1);
  assert(binn_map_set_blob(map, 55110, (char *)blob_ptr, blob_size) == 1);
  assert(binn_map_set_list(map, 55120, list2) == 1);
# 1885 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c"
  ptr = binn_ptr(list);
  assert(ptr != 0);
  assert(binn_iter_init(&iter, ptr, 0xE0));
  assert(iter.pnext > ptr);
  assert(iter.plimit > ptr);
  assert(iter.count == 12);
  assert(iter.current == 0);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.pnext > ptr);
  assert(iter.plimit > ptr);
  assert(iter.count == 12);
  assert(iter.current == 1);
  assert(value.type == 0x21);
  assert(value.vint8 == 111);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 2);
  if (use_int_compression) {
    assert(value.type == 0x60);
  } else {
    assert(value.type == 0x61);
  }
  assert(value.vint32 == 123456789);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 3);
  if (use_int_compression) {
    assert(value.type == 0x21);
    assert(value.vint8 == -123);
  } else {
    assert(value.type == 0x41);
    assert(value.vint16 == -123);
  }

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 4);
  assert(value.type == 0x81);
  assert(value.vint64 == 9876543210);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 5);
  assert(value.type == 0x62);
  assert(AlmostEqualFloats(value.vfloat, 1.25, 2));

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 6);
  assert(value.type == 0x82);
  assert(value.vdouble - 25.987654321 < 0.00000001);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 7);
  assert(value.type == 0x80061);
  assert(value.vbool == 1);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 8);
  assert(value.type == 0x80061);
  assert(value.vbool == 0);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 9);
  assert(value.type == 0x00);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 10);
  assert(value.type == 0xA0);
  assert(strcmp((char *)value.ptr, "testing...") == 0);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 11);
  assert(value.type == 0xC0);
  assert(memcmp(value.ptr, blob_ptr, blob_size) == 0);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 12);
  assert(value.type == 0xE0);
  assert(value.size == list2size);
  assert(value.count == 4);
  assert(value.ptr != 0);
  assert(binn_list_int32(value.ptr, 1) == 250);
  assert(binn_list_null(value.ptr, 2) == 1);
  ptr = binn_list_str(value.ptr, 3);
  assert(ptr != 0);
  assert(strcmp((char *)ptr, "l1st2") == 0);
  assert(binn_list_bool(value.ptr, 4) == 1);

  assert(binn_list_next(&iter, &value) == 0);



  assert(binn_list_next(&iter, &value) == 0);







  ptr = binn_ptr(obj);
  assert(ptr != 0);
  assert(binn_iter_init(&iter, ptr, 0xE2));
  assert(iter.pnext > ptr);
  assert(iter.plimit > ptr);
  assert(iter.count == 12);
  assert(iter.current == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.pnext > ptr);
  assert(iter.plimit > ptr);
  assert(iter.count == 12);
  assert(iter.current == 1);
  assert(value.type == 0x21);
  assert(value.vint8 == 111);

  assert(strcmp(key, "a") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 2);
  if (use_int_compression) {
    assert(value.type == 0x60);
  } else {
    assert(value.type == 0x61);
  }
  assert(value.vint32 == 123456789);

  assert(strcmp(key, "b") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 3);
  if (use_int_compression) {
    assert(value.type == 0x21);
    assert(value.vint8 == -123);
  } else {
    assert(value.type == 0x41);
    assert(value.vint16 == -123);
  }

  assert(strcmp(key, "c") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 4);
  assert(value.type == 0x81);
  assert(value.vint64 == 9876543210);

  assert(strcmp(key, "d") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 5);
  assert(value.type == 0x62);
  assert(AlmostEqualFloats(value.vfloat, 1.25, 2));

  assert(strcmp(key, "e") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 6);
  assert(value.type == 0x82);
  assert(value.vdouble - 25.987654321 < 0.00000001);

  assert(strcmp(key, "f") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 7);
  assert(value.type == 0x80061);
  assert(value.vbool == 1);

  assert(strcmp(key, "g") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 8);
  assert(value.type == 0x80061);
  assert(value.vbool == 0);

  assert(strcmp(key, "h") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 9);
  assert(value.type == 0x00);

  assert(strcmp(key, "i") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 10);
  assert(value.type == 0xA0);
  assert(strcmp((char *)value.ptr, "testing...") == 0);

  assert(strcmp(key, "j") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 11);
  assert(value.type == 0xC0);
  assert(memcmp(value.ptr, blob_ptr, blob_size) == 0);

  assert(strcmp(key, "k") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 12);
  assert(value.type == 0xE0);
  assert(value.size == list2size);
  assert(value.count == 4);
  assert(value.ptr != 0);
  assert(binn_list_int32(value.ptr, 1) == 250);
  assert(binn_list_null(value.ptr, 2) == 1);
  ptr = binn_list_str(value.ptr, 3);
  assert(ptr != 0);
  assert(strcmp((char *)ptr, "l1st2") == 0);
  assert(binn_list_bool(value.ptr, 4) == 1);

  assert(strcmp(key, "l") == 0);

  assert(binn_object_next(&iter, key, &value) == 0);



  assert(binn_object_next(&iter, key, &value) == 0);
# 2108 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c"
  ptr = binn_ptr(map);
  assert(ptr != 0);
  assert(binn_iter_init(&iter, ptr, 0xE1));
  assert(iter.pnext > ptr);
  assert(iter.plimit > ptr);
  assert(iter.count == 12);
  assert(iter.current == 0);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.pnext > ptr);
  assert(iter.plimit > ptr);
  assert(iter.count == 12);
  assert(iter.current == 1);
  assert(value.type == 0x21);
  assert(value.vint8 == 111);
  assert(id == 55010);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 2);
  if (use_int_compression) {
    assert(value.type == 0x60);
  } else {
    assert(value.type == 0x61);
  }
  assert(value.vint32 == 123456789);
  assert(id == 55020);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 3);
  if (use_int_compression) {
    assert(value.type == 0x21);
    assert(value.vint8 == -123);
  } else {
    assert(value.type == 0x41);
    assert(value.vint16 == -123);
  }
  assert(id == 55030);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 4);
  assert(value.type == 0x81);
  assert(value.vint64 == 9876543210);
  assert(id == 55040);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 5);
  assert(value.type == 0x62);
  assert(AlmostEqualFloats(value.vfloat, 1.25, 2));
  assert(id == 55050);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 6);
  assert(value.type == 0x82);
  assert(value.vdouble - 25.987654321 < 0.00000001);
  assert(id == 55060);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 7);
  assert(value.type == 0x80061);
  assert(value.vbool == 1);
  assert(id == 55070);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 8);
  assert(value.type == 0x80061);
  assert(value.vbool == 0);
  assert(id == 55080);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 9);
  assert(value.type == 0x00);
  assert(id == 55090);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 10);
  assert(value.type == 0xA0);
  assert(strcmp((char *)value.ptr, "testing...") == 0);
  assert(id == 55100);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 11);
  assert(value.type == 0xC0);
  assert(memcmp(value.ptr, blob_ptr, blob_size) == 0);
  assert(id == 55110);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 12);
  assert(value.type == 0xE0);
  assert(value.size == list2size);
  assert(value.count == 4);
  assert(value.ptr != 0);
  assert(binn_list_int32(value.ptr, 1) == 250);
  assert(binn_list_null(value.ptr, 2) == 1);
  ptr = binn_list_str(value.ptr, 3);
  assert(ptr != 0);
  assert(strcmp((char *)ptr, "l1st2") == 0);
  assert(binn_list_bool(value.ptr, 4) == 1);
  assert(id == 55120);

  assert(binn_map_next(&iter, &id, &value) == 0);



  assert(binn_map_next(&iter, &id, &value) == 0);






  copy = binn_copy(list);
  assert(copy!=0);
  assert(binn_type(copy) == binn_type(list));
  assert(binn_count(copy) == binn_count(list));
  assert(binn_size(copy) == binn_size(list));
  assert(binn_iter_init(&iter, list, 0xE0));
  assert(binn_iter_init(&iter2, copy, 0xE0));
  while( binn_list_next(&iter, &value) ){
    assert(binn_list_next(&iter2, &value2) == 1);
    assert(value.type == value2.type);

  }
  assert(binn_list_add_str(copy, "testing...") == 1);
  assert(binn_type(copy) == binn_type(list));
  assert(binn_count(copy) == binn_count(list)+1);
  assert(binn_size(copy) > binn_size(list));
  binn_free(copy);

  copy = binn_copy(map);
  assert(copy!=0);
  assert(binn_type(copy) == binn_type(map));
  assert(binn_count(copy) == binn_count(map));
  assert(binn_size(copy) == binn_size(map));
  assert(binn_iter_init(&iter, map, 0xE1));
  assert(binn_iter_init(&iter2, copy, 0xE1));
  while( binn_map_next(&iter, &id, &value) ){
    assert(binn_map_next(&iter2, &id2, &value2) == 1);
    assert(id == id2);
    assert(value.type == value2.type);

  }
  assert(binn_map_set_int32(copy, 5600, 123) == 1);
  assert(binn_type(copy) == binn_type(map));
  assert(binn_count(copy) == binn_count(map)+1);
  assert(binn_size(copy) > binn_size(map));
  binn_free(copy);

  copy = binn_copy(obj);
  assert(copy!=0);
  assert(binn_type(copy) == binn_type(obj));
  assert(binn_count(copy) == binn_count(obj));
  assert(binn_size(copy) == binn_size(obj));
  assert(binn_iter_init(&iter, obj, 0xE2));
  assert(binn_iter_init(&iter2, copy, 0xE2));
  while( binn_object_next(&iter, key, &value) ){
    assert(binn_object_next(&iter2, key2, &value2) == 1);
    assert(strcmp(key,key2)==0);
    assert(value.type == value2.type);

  }
  assert(binn_object_set_int32(copy, "another", 123) == 1);
  assert(binn_type(copy) == binn_type(obj));
  assert(binn_count(copy) == binn_count(obj)+1);
  assert(binn_size(copy) > binn_size(obj));
  binn_free(copy);




  ptr = binn_ptr(list);
  copy = binn_copy(ptr);
  assert(copy!=0);
  assert(binn_type(copy) == binn_type(list));
  assert(binn_count(copy) == binn_count(list));
  assert(binn_size(copy) == binn_size(list));
  assert(binn_iter_init(&iter, ptr, 0xE0));
  assert(binn_iter_init(&iter2, copy, 0xE0));
  while( binn_list_next(&iter, &value) ){
    assert(binn_list_next(&iter2, &value2) == 1);
    assert(value.type == value2.type);

  }
  assert(binn_list_add_str(copy, "testing...") == 1);
  assert(binn_type(copy) == binn_type(list));
  assert(binn_count(copy) == binn_count(list)+1);
  assert(binn_size(copy) > binn_size(list));
  binn_free(copy);

  ptr = binn_ptr(map);
  copy = binn_copy(ptr);
  assert(copy!=0);
  assert(binn_type(copy) == binn_type(map));
  assert(binn_count(copy) == binn_count(map));
  assert(binn_size(copy) == binn_size(map));
  assert(binn_iter_init(&iter, ptr, 0xE1));
  assert(binn_iter_init(&iter2, copy, 0xE1));
  while( binn_map_next(&iter, &id, &value) ){
    assert(binn_map_next(&iter2, &id2, &value2) == 1);
    assert(id == id2);
    assert(value.type == value2.type);

  }
  assert(binn_map_set_int32(copy, 5600, 123) == 1);
  assert(binn_type(copy) == binn_type(map));
  assert(binn_count(copy) == binn_count(map)+1);
  assert(binn_size(copy) > binn_size(map));
  binn_free(copy);

  ptr = binn_ptr(obj);
  copy = binn_copy(ptr);
  assert(copy!=0);
  assert(binn_type(copy) == binn_type(obj));
  assert(binn_count(copy) == binn_count(obj));
  assert(binn_size(copy) == binn_size(obj));
  assert(binn_iter_init(&iter, ptr, 0xE2));
  assert(binn_iter_init(&iter2, copy, 0xE2));
  while( binn_object_next(&iter, key, &value) ){
    assert(binn_object_next(&iter2, key2, &value2) == 1);
    assert(strcmp(key,key2)==0);
    assert(value.type == value2.type);

  }
  assert(binn_object_set_int32(copy, "another", 123) == 1);
  assert(binn_type(copy) == binn_type(obj));
  assert(binn_count(copy) == binn_count(obj)+1);
  assert(binn_size(copy) > binn_size(obj));
  binn_free(copy);


  binn_free(list);
  binn_free(list2);
  binn_free(map);
  binn_free(obj);

  puts("OK");

}



void test_binn2() {
  char *obj1ptr, *obj2ptr;
  int obj1size, obj2size;

  test_virtual_types();

  test_int_conversion();
  test_binn_int_conversion();
  test_value_conversion();
  test_value_copy();

  init_udts();

  obj1ptr = test_create_object_1(&obj1size);
  obj2ptr = test_create_object_2(&obj2size);

  assert(obj1ptr != 0);
  assert(obj2ptr != 0);

  printf("obj1size=%d obj2size=%d\n", obj1size, obj2size);
  assert(obj1size == obj2size);

  test_binn_read(obj1ptr);

  test_binn_iter(0);

  test_binn_iter(1);

}
# 0 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 1
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 2
# 2 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 3 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/memory.h" 1
# 4 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/string.h" 1
# 5 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/math.h" 1
# 6 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/assert.h" 1
# 7 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/../src/binn.h" 1
# 33 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/../src/binn.h"
typedef int BOOL;
# 67 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/../src/binn.h"
  typedef long long int int64;
  typedef unsigned long long int uint64;
# 199 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/../src/binn.h"
typedef void (*binn_mem_free)(void*);







struct binn_struct {
  int header;
  BOOL allocated;
  BOOL writable;
  BOOL dirty;

  void *pbuf;
  BOOL pre_allocated;
  int alloc_size;
  int used_size;

  int type;
  void *ptr;
  int size;
  int count;

  binn_mem_free freefn;

  union {
    signed char vint8;
    signed short vint16;
    signed int vint32;
    int64 vint64;
    unsigned char vuint8;
    unsigned short vuint16;
    unsigned int vuint32;
    uint64 vuint64;

    signed char vchar;
    unsigned char vuchar;
    signed short vshort;
    unsigned short vushort;
    signed int vint;
    unsigned int vuint;

    float vfloat;
    double vdouble;

    BOOL vbool;
  };

  BOOL disable_int_compression;
};

typedef struct binn_struct binn;





char * binn_version();

void binn_set_alloc_functions(void* (*new_malloc)(size_t), void* (*new_realloc)(void*,size_t), void (*new_free)(void*));

int binn_create_type(int storage_type, int data_type_index);
BOOL binn_get_type_info(int long_type, int *pstorage_type, int *pextra_type);

int binn_get_write_storage(int type);
int binn_get_read_storage(int type);

BOOL binn_is_container(binn *item);





binn * binn_new(int type, int size, void *buffer);
binn * binn_list();
binn * binn_map();
binn * binn_object();


BOOL binn_create(binn *item, int type, int size, void *buffer);
BOOL binn_create_list(binn *list);
BOOL binn_create_map(binn *map);
BOOL binn_create_object(binn *object);


binn * binn_copy(void *old);


BOOL binn_list_add_new(binn *list, binn *value);
BOOL binn_map_set_new(binn *map, int id, binn *value);
BOOL binn_object_set_new(binn *obj, const char *key, binn *value);




BOOL binn_list_add(binn *list, int type, void *pvalue, int size);
BOOL binn_map_set(binn *map, int id, int type, void *pvalue, int size);
BOOL binn_object_set(binn *obj, const char *key, int type, void *pvalue, int size);




void binn_free(binn *item);
void * binn_release(binn *item);




binn * binn_value(int type, void *pvalue, int size, binn_mem_free freefn);

static inline binn * binn_int8(signed char value) {
  return binn_value(0x21, &value, 0, 0);
}
static inline binn * binn_int16(short value) {
  return binn_value(0x41, &value, 0, 0);
}
static inline binn * binn_int32(int value) {
  return binn_value(0x61, &value, 0, 0);
}
static inline binn * binn_int64(int64 value) {
  return binn_value(0x81, &value, 0, 0);
}
static inline binn * binn_uint8(unsigned char value) {
  return binn_value(0x20, &value, 0, 0);
}
static inline binn * binn_uint16(unsigned short value) {
  return binn_value(0x40, &value, 0, 0);
}
static inline binn * binn_uint32(unsigned int value) {
  return binn_value(0x60, &value, 0, 0);
}
static inline binn * binn_uint64(uint64 value) {
  return binn_value(0x80, &value, 0, 0);
}
static inline binn * binn_float(float value) {
  return binn_value(0x62, &value, 0, 0);
}
static inline binn * binn_double(double value) {
  return binn_value(0x82, &value, 0, 0);
}
static inline binn * binn_bool(BOOL value) {
  return binn_value(0x80061, &value, 0, 0);
}
static inline binn * binn_null() {
  return binn_value(0x00, 0, 0, 0);
}
static inline binn * binn_string(char *str, binn_mem_free freefn) {
  return binn_value(0xA0, str, 0, freefn);
}
static inline binn * binn_blob(void *ptr, int size, binn_mem_free freefn) {
  return binn_value(0xC0, ptr, size, freefn);
}





void * binn_ptr(void *ptr);
int binn_size(void *ptr);
int binn_type(void *ptr);
int binn_count(void *ptr);

BOOL binn_is_valid(void *ptr, int *ptype, int *pcount, int *psize);






BOOL binn_is_valid_ex(void *ptr, int *ptype, int *pcount, int *psize);
# 378 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/../src/binn.h"
BOOL binn_is_struct(void *ptr);




BOOL binn_load(void *data, binn *item);
binn * binn_open(void *data);




signed char binn_list_int8(void *list, int pos);
short binn_list_int16(void *list, int pos);
int binn_list_int32(void *list, int pos);
int64 binn_list_int64(void *list, int pos);
unsigned char binn_list_uint8(void *list, int pos);
unsigned short binn_list_uint16(void *list, int pos);
unsigned int binn_list_uint32(void *list, int pos);
uint64 binn_list_uint64(void *list, int pos);
float binn_list_float(void *list, int pos);
double binn_list_double(void *list, int pos);
BOOL binn_list_bool(void *list, int pos);
BOOL binn_list_null(void *list, int pos);
char * binn_list_str(void *list, int pos);
void * binn_list_blob(void *list, int pos, int *psize);
void * binn_list_list(void *list, int pos);
void * binn_list_map(void *list, int pos);
void * binn_list_object(void *list, int pos);

signed char binn_map_int8(void *map, int id);
short binn_map_int16(void *map, int id);
int binn_map_int32(void *map, int id);
int64 binn_map_int64(void *map, int id);
unsigned char binn_map_uint8(void *map, int id);
unsigned short binn_map_uint16(void *map, int id);
unsigned int binn_map_uint32(void *map, int id);
uint64 binn_map_uint64(void *map, int id);
float binn_map_float(void *map, int id);
double binn_map_double(void *map, int id);
BOOL binn_map_bool(void *map, int id);
BOOL binn_map_null(void *map, int id);
char * binn_map_str(void *map, int id);
void * binn_map_blob(void *map, int id, int *psize);
void * binn_map_list(void *map, int id);
void * binn_map_map(void *map, int id);
void * binn_map_object(void *map, int id);

signed char binn_object_int8(void *obj, const char *key);
short binn_object_int16(void *obj, const char *key);
int binn_object_int32(void *obj, const char *key);
int64 binn_object_int64(void *obj, const char *key);
unsigned char binn_object_uint8(void *obj, const char *key);
unsigned short binn_object_uint16(void *obj, const char *key);
unsigned int binn_object_uint32(void *obj, const char *key);
uint64 binn_object_uint64(void *obj, const char *key);
float binn_object_float(void *obj, const char *key);
double binn_object_double(void *obj, const char *key);
BOOL binn_object_bool(void *obj, const char *key);
BOOL binn_object_null(void *obj, const char *key);
char * binn_object_str(void *obj, const char *key);
void * binn_object_blob(void *obj, const char *key, int *psize);
void * binn_object_list(void *obj, const char *key);
void * binn_object_map(void *obj, const char *key);
void * binn_object_object(void *obj, const char *key);



binn * binn_list_value(void *list, int pos);
binn * binn_map_value(void *map, int id);
binn * binn_object_value(void *obj, const char *key);


BOOL binn_list_get_value(void* list, int pos, binn *value);
BOOL binn_map_get_value(void* map, int id, binn *value);
BOOL binn_object_get_value(void *obj, const char *key, binn *value);


BOOL binn_list_get(void *list, int pos, int type, void *pvalue, int *psize);
BOOL binn_map_get(void *map, int id, int type, void *pvalue, int *psize);
BOOL binn_object_get(void *obj, const char *key, int type, void *pvalue, int *psize);





void * binn_list_read(void *list, int pos, int *ptype, int *psize);
void * binn_map_read(void *map, int id, int *ptype, int *psize);
void * binn_object_read(void *obj, const char *key, int *ptype, int *psize);







BOOL binn_map_get_pair(void *map, int pos, int *pid, binn *value);
BOOL binn_object_get_pair(void *obj, int pos, char *pkey, binn *value);


binn * binn_map_pair(void *map, int pos, int *pid);
binn * binn_object_pair(void *obj, int pos, char *pkey);





void * binn_map_read_pair(void *ptr, int pos, int *pid, int *ptype, int *psize);
void * binn_object_read_pair(void *ptr, int pos, char *pkey, int *ptype, int *psize);




typedef struct binn_iter_struct {
    unsigned char *pnext;
    unsigned char *plimit;
    int type;
    int count;
    int current;
} binn_iter;

BOOL binn_iter_init(binn_iter *iter, void *pbuf, int type);


binn * binn_list_next_value(binn_iter *iter);
binn * binn_map_next_value(binn_iter *iter, int *pid);
binn * binn_object_next_value(binn_iter *iter, char *pkey);


BOOL binn_list_next(binn_iter *iter, binn *value);
BOOL binn_map_next(binn_iter *iter, int *pid, binn *value);
BOOL binn_object_next(binn_iter *iter, char *pkey, binn *value);





void * binn_list_read_next(binn_iter *iter, int *ptype, int *psize);
void * binn_map_read_next(binn_iter *iter, int *pid, int *ptype, int *psize);
void * binn_object_read_next(binn_iter *iter, char *pkey, int *ptype, int *psize);
# 542 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/../src/binn.h"
BOOL binn_set_string(binn *item, char *str, binn_mem_free pfree);
BOOL binn_set_blob(binn *item, void *ptr, int size, binn_mem_free pfree);
# 575 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/../src/binn.h"
static inline BOOL binn_list_add_int8(binn *list, signed char value) {
  return binn_list_add(list, 0x21, &value, 0);
}
static inline BOOL binn_list_add_int16(binn *list, short value) {
  return binn_list_add(list, 0x41, &value, 0);
}
static inline BOOL binn_list_add_int32(binn *list, int value) {
  return binn_list_add(list, 0x61, &value, 0);
}
static inline BOOL binn_list_add_int64(binn *list, int64 value) {
  return binn_list_add(list, 0x81, &value, 0);
}
static inline BOOL binn_list_add_uint8(binn *list, unsigned char value) {
  return binn_list_add(list, 0x20, &value, 0);
}
static inline BOOL binn_list_add_uint16(binn *list, unsigned short value) {
  return binn_list_add(list, 0x40, &value, 0);
}
static inline BOOL binn_list_add_uint32(binn *list, unsigned int value) {
  return binn_list_add(list, 0x60, &value, 0);
}
static inline BOOL binn_list_add_uint64(binn *list, uint64 value) {
  return binn_list_add(list, 0x80, &value, 0);
}
static inline BOOL binn_list_add_float(binn *list, float value) {
  return binn_list_add(list, 0x62, &value, 0);
}
static inline BOOL binn_list_add_double(binn *list, double value) {
  return binn_list_add(list, 0x82, &value, 0);
}
static inline BOOL binn_list_add_bool(binn *list, BOOL value) {
  return binn_list_add(list, 0x80061, &value, 0);
}
static inline BOOL binn_list_add_null(binn *list) {
  return binn_list_add(list, 0x00, 0, 0);
}
static inline BOOL binn_list_add_str(binn *list, char *str) {
  return binn_list_add(list, 0xA0, str, 0);
}
static inline BOOL binn_list_add_blob(binn *list, void *ptr, int size) {
  return binn_list_add(list, 0xC0, ptr, size);
}
static inline BOOL binn_list_add_list(binn *list, void *list2) {
  return binn_list_add(list, 0xE0, binn_ptr(list2), binn_size(list2));
}
static inline BOOL binn_list_add_map(binn *list, void *map) {
  return binn_list_add(list, 0xE1, binn_ptr(map), binn_size(map));
}
static inline BOOL binn_list_add_object(binn *list, void *obj) {
  return binn_list_add(list, 0xE2, binn_ptr(obj), binn_size(obj));
}
static inline BOOL binn_list_add_value(binn *list, binn *value) {
  return binn_list_add(list, value->type, binn_ptr(value), binn_size(value));
}



static inline BOOL binn_map_set_int8(binn *map, int id, signed char value) {
  return binn_map_set(map, id, 0x21, &value, 0);
}
static inline BOOL binn_map_set_int16(binn *map, int id, short value) {
  return binn_map_set(map, id, 0x41, &value, 0);
}
static inline BOOL binn_map_set_int32(binn *map, int id, int value) {
  return binn_map_set(map, id, 0x61, &value, 0);
}
static inline BOOL binn_map_set_int64(binn *map, int id, int64 value) {
  return binn_map_set(map, id, 0x81, &value, 0);
}
static inline BOOL binn_map_set_uint8(binn *map, int id, unsigned char value) {
  return binn_map_set(map, id, 0x20, &value, 0);
}
static inline BOOL binn_map_set_uint16(binn *map, int id, unsigned short value) {
  return binn_map_set(map, id, 0x40, &value, 0);
}
static inline BOOL binn_map_set_uint32(binn *map, int id, unsigned int value) {
  return binn_map_set(map, id, 0x60, &value, 0);
}
static inline BOOL binn_map_set_uint64(binn *map, int id, uint64 value) {
  return binn_map_set(map, id, 0x80, &value, 0);
}
static inline BOOL binn_map_set_float(binn *map, int id, float value) {
  return binn_map_set(map, id, 0x62, &value, 0);
}
static inline BOOL binn_map_set_double(binn *map, int id, double value) {
  return binn_map_set(map, id, 0x82, &value, 0);
}
static inline BOOL binn_map_set_bool(binn *map, int id, BOOL value) {
  return binn_map_set(map, id, 0x80061, &value, 0);
}
static inline BOOL binn_map_set_null(binn *map, int id) {
  return binn_map_set(map, id, 0x00, 0, 0);
}
static inline BOOL binn_map_set_str(binn *map, int id, char *str) {
  return binn_map_set(map, id, 0xA0, str, 0);
}
static inline BOOL binn_map_set_blob(binn *map, int id, void *ptr, int size) {
  return binn_map_set(map, id, 0xC0, ptr, size);
}
static inline BOOL binn_map_set_list(binn *map, int id, void *list) {
  return binn_map_set(map, id, 0xE0, binn_ptr(list), binn_size(list));
}
static inline BOOL binn_map_set_map(binn *map, int id, void *map2) {
  return binn_map_set(map, id, 0xE1, binn_ptr(map2), binn_size(map2));
}
static inline BOOL binn_map_set_object(binn *map, int id, void *obj) {
  return binn_map_set(map, id, 0xE2, binn_ptr(obj), binn_size(obj));
}
static inline BOOL binn_map_set_value(binn *map, int id, binn *value) {
  return binn_map_set(map, id, value->type, binn_ptr(value), binn_size(value));
}



static inline BOOL binn_object_set_int8(binn *obj, const char *key, signed char value) {
  return binn_object_set(obj, key, 0x21, &value, 0);
}
static inline BOOL binn_object_set_int16(binn *obj, const char *key, short value) {
  return binn_object_set(obj, key, 0x41, &value, 0);
}
static inline BOOL binn_object_set_int32(binn *obj, const char *key, int value) {
  return binn_object_set(obj, key, 0x61, &value, 0);
}
static inline BOOL binn_object_set_int64(binn *obj, const char *key, int64 value) {
  return binn_object_set(obj, key, 0x81, &value, 0);
}
static inline BOOL binn_object_set_uint8(binn *obj, const char *key, unsigned char value) {
  return binn_object_set(obj, key, 0x20, &value, 0);
}
static inline BOOL binn_object_set_uint16(binn *obj, const char *key, unsigned short value) {
  return binn_object_set(obj, key, 0x40, &value, 0);
}
static inline BOOL binn_object_set_uint32(binn *obj, const char *key, unsigned int value) {
  return binn_object_set(obj, key, 0x60, &value, 0);
}
static inline BOOL binn_object_set_uint64(binn *obj, const char *key, uint64 value) {
  return binn_object_set(obj, key, 0x80, &value, 0);
}
static inline BOOL binn_object_set_float(binn *obj, const char *key, float value) {
  return binn_object_set(obj, key, 0x62, &value, 0);
}
static inline BOOL binn_object_set_double(binn *obj, const char *key, double value) {
  return binn_object_set(obj, key, 0x82, &value, 0);
}
static inline BOOL binn_object_set_bool(binn *obj, const char *key, BOOL value) {
  return binn_object_set(obj, key, 0x80061, &value, 0);
}
static inline BOOL binn_object_set_null(binn *obj, const char *key) {
  return binn_object_set(obj, key, 0x00, 0, 0);
}
static inline BOOL binn_object_set_str(binn *obj, const char *key, char *str) {
  return binn_object_set(obj, key, 0xA0, str, 0);
}
static inline BOOL binn_object_set_blob(binn *obj, const char *key, void *ptr, int size) {
  return binn_object_set(obj, key, 0xC0, ptr, size);
}
static inline BOOL binn_object_set_list(binn *obj, const char *key, void *list) {
  return binn_object_set(obj, key, 0xE0, binn_ptr(list), binn_size(list));
}
static inline BOOL binn_object_set_map(binn *obj, const char *key, void *map) {
  return binn_object_set(obj, key, 0xE1, binn_ptr(map), binn_size(map));
}
static inline BOOL binn_object_set_object(binn *obj, const char *key, void *obj2) {
  return binn_object_set(obj, key, 0xE2, binn_ptr(obj2), binn_size(obj2));
}
static inline BOOL binn_object_set_value(binn *obj, const char *key, binn *value) {
  return binn_object_set(obj, key, value->type, binn_ptr(value), binn_size(value));
}





static inline BOOL binn_list_get_int8(void *list, int pos, signed char *pvalue) {
  return binn_list_get(list, pos, 0x21, pvalue, 0);
}
static inline BOOL binn_list_get_int16(void *list, int pos, short *pvalue) {
  return binn_list_get(list, pos, 0x41, pvalue, 0);
}
static inline BOOL binn_list_get_int32(void *list, int pos, int *pvalue) {
  return binn_list_get(list, pos, 0x61, pvalue, 0);
}
static inline BOOL binn_list_get_int64(void *list, int pos, int64 *pvalue) {
  return binn_list_get(list, pos, 0x81, pvalue, 0);
}
static inline BOOL binn_list_get_uint8(void *list, int pos, unsigned char *pvalue) {
  return binn_list_get(list, pos, 0x20, pvalue, 0);
}
static inline BOOL binn_list_get_uint16(void *list, int pos, unsigned short *pvalue) {
  return binn_list_get(list, pos, 0x40, pvalue, 0);
}
static inline BOOL binn_list_get_uint32(void *list, int pos, unsigned int *pvalue) {
  return binn_list_get(list, pos, 0x60, pvalue, 0);
}
static inline BOOL binn_list_get_uint64(void *list, int pos, uint64 *pvalue) {
  return binn_list_get(list, pos, 0x80, pvalue, 0);
}
static inline BOOL binn_list_get_float(void *list, int pos, float *pvalue) {
  return binn_list_get(list, pos, 0x62, pvalue, 0);
}
static inline BOOL binn_list_get_double(void *list, int pos, double *pvalue) {
  return binn_list_get(list, pos, 0x82, pvalue, 0);
}
static inline BOOL binn_list_get_bool(void *list, int pos, BOOL *pvalue) {
  return binn_list_get(list, pos, 0x80061, pvalue, 0);
}
static inline BOOL binn_list_get_str(void *list, int pos, char **pvalue) {
  return binn_list_get(list, pos, 0xA0, pvalue, 0);
}
static inline BOOL binn_list_get_blob(void *list, int pos, void **pvalue, int *psize) {
  return binn_list_get(list, pos, 0xC0, pvalue, psize);
}
static inline BOOL binn_list_get_list(void *list, int pos, void **pvalue) {
  return binn_list_get(list, pos, 0xE0, pvalue, 0);
}
static inline BOOL binn_list_get_map(void *list, int pos, void **pvalue) {
  return binn_list_get(list, pos, 0xE1, pvalue, 0);
}
static inline BOOL binn_list_get_object(void *list, int pos, void **pvalue) {
  return binn_list_get(list, pos, 0xE2, pvalue, 0);
}



static inline BOOL binn_map_get_int8(void *map, int id, signed char *pvalue) {
  return binn_map_get(map, id, 0x21, pvalue, 0);
}
static inline BOOL binn_map_get_int16(void *map, int id, short *pvalue) {
  return binn_map_get(map, id, 0x41, pvalue, 0);
}
static inline BOOL binn_map_get_int32(void *map, int id, int *pvalue) {
  return binn_map_get(map, id, 0x61, pvalue, 0);
}
static inline BOOL binn_map_get_int64(void *map, int id, int64 *pvalue) {
  return binn_map_get(map, id, 0x81, pvalue, 0);
}
static inline BOOL binn_map_get_uint8(void *map, int id, unsigned char *pvalue) {
  return binn_map_get(map, id, 0x20, pvalue, 0);
}
static inline BOOL binn_map_get_uint16(void *map, int id, unsigned short *pvalue) {
  return binn_map_get(map, id, 0x40, pvalue, 0);
}
static inline BOOL binn_map_get_uint32(void *map, int id, unsigned int *pvalue) {
  return binn_map_get(map, id, 0x60, pvalue, 0);
}
static inline BOOL binn_map_get_uint64(void *map, int id, uint64 *pvalue) {
  return binn_map_get(map, id, 0x80, pvalue, 0);
}
static inline BOOL binn_map_get_float(void *map, int id, float *pvalue) {
  return binn_map_get(map, id, 0x62, pvalue, 0);
}
static inline BOOL binn_map_get_double(void *map, int id, double *pvalue) {
  return binn_map_get(map, id, 0x82, pvalue, 0);
}
static inline BOOL binn_map_get_bool(void *map, int id, BOOL *pvalue) {
  return binn_map_get(map, id, 0x80061, pvalue, 0);
}
static inline BOOL binn_map_get_str(void *map, int id, char **pvalue) {
  return binn_map_get(map, id, 0xA0, pvalue, 0);
}
static inline BOOL binn_map_get_blob(void *map, int id, void **pvalue, int *psize) {
  return binn_map_get(map, id, 0xC0, pvalue, psize);
}
static inline BOOL binn_map_get_list(void *map, int id, void **pvalue) {
  return binn_map_get(map, id, 0xE0, pvalue, 0);
}
static inline BOOL binn_map_get_map(void *map, int id, void **pvalue) {
  return binn_map_get(map, id, 0xE1, pvalue, 0);
}
static inline BOOL binn_map_get_object(void *map, int id, void **pvalue) {
  return binn_map_get(map, id, 0xE2, pvalue, 0);
}






static inline BOOL binn_object_get_int8(void *obj, const char *key, signed char *pvalue) {
  return binn_object_get(obj, key, 0x21, pvalue, 0);
}
static inline BOOL binn_object_get_int16(void *obj, const char *key, short *pvalue) {
  return binn_object_get(obj, key, 0x41, pvalue, 0);
}
static inline BOOL binn_object_get_int32(void *obj, const char *key, int *pvalue) {
  return binn_object_get(obj, key, 0x61, pvalue, 0);
}
static inline BOOL binn_object_get_int64(void *obj, const char *key, int64 *pvalue) {
  return binn_object_get(obj, key, 0x81, pvalue, 0);
}
static inline BOOL binn_object_get_uint8(void *obj, const char *key, unsigned char *pvalue) {
  return binn_object_get(obj, key, 0x20, pvalue, 0);
}
static inline BOOL binn_object_get_uint16(void *obj, const char *key, unsigned short *pvalue) {
  return binn_object_get(obj, key, 0x40, pvalue, 0);
}
static inline BOOL binn_object_get_uint32(void *obj, const char *key, unsigned int *pvalue) {
  return binn_object_get(obj, key, 0x60, pvalue, 0);
}
static inline BOOL binn_object_get_uint64(void *obj, const char *key, uint64 *pvalue) {
  return binn_object_get(obj, key, 0x80, pvalue, 0);
}
static inline BOOL binn_object_get_float(void *obj, const char *key, float *pvalue) {
  return binn_object_get(obj, key, 0x62, pvalue, 0);
}
static inline BOOL binn_object_get_double(void *obj, const char *key, double *pvalue) {
  return binn_object_get(obj, key, 0x82, pvalue, 0);
}
static inline BOOL binn_object_get_bool(void *obj, const char *key, BOOL *pvalue) {
  return binn_object_get(obj, key, 0x80061, pvalue, 0);
}
static inline BOOL binn_object_get_str(void *obj, const char *key, char **pvalue) {
  return binn_object_get(obj, key, 0xA0, pvalue, 0);
}
static inline BOOL binn_object_get_blob(void *obj, const char *key, void **pvalue, int *psize) {
  return binn_object_get(obj, key, 0xC0, pvalue, psize);
}
static inline BOOL binn_object_get_list(void *obj, const char *key, void **pvalue) {
  return binn_object_get(obj, key, 0xE0, pvalue, 0);
}
static inline BOOL binn_object_get_map(void *obj, const char *key, void **pvalue) {
  return binn_object_get(obj, key, 0xE1, pvalue, 0);
}
static inline BOOL binn_object_get_object(void *obj, const char *key, void **pvalue) {
  return binn_object_get(obj, key, 0xE2, pvalue, 0);
}



BOOL binn_get_int32(binn *value, int *pint);
BOOL binn_get_int64(binn *value, int64 *pint);
BOOL binn_get_double(binn *value, double *pfloat);
BOOL binn_get_bool(binn *value, BOOL *pbool);
char * binn_get_str(binn *value);
# 8 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c" 2





int MY_DATE;
int MY_CURRENCY;

char tmp[128];

void * memdup(void *src, int size);

char * i64toa(int64 val, char *buf, int radix);



int64 atoi64(char *str);


BOOL AlmostEqualFloats(float A, float B, int maxUlps);



int vint32; unsigned int vuint32;
int64 vint64; uint64 vuint64;
short vint16; unsigned short vuint16;
signed char vint8; unsigned char vuint8;
float vfloat32;
double vfloat64;
BOOL vbool;



char * stripchr(char *mainstr, int separator) {
  char *ptr;

  if (mainstr == 0) return 0;

  ptr = strchr(mainstr, separator);
  if (ptr == 0) return 0;
  ptr[0] = '\0';
  ptr++;
  return ptr;

}







unsigned short str_to_date(char *datestr) {
  unsigned short date;
  int day, month, year;
  char *next;

  if (datestr == 0) return 0;
  strcpy(tmp, datestr);
  datestr = tmp;

  next = stripchr(datestr, '-');
  year = atoi(datestr) - 1900;

  datestr = next;
  next = stripchr(datestr, '-');
  month = atoi(datestr);

  day = atoi(next);

  date = (day << 11) | (month << 7) | year;
  return date;

}



char * date_to_str(unsigned short date) {
  int day, month, year;


  day = ((date & 0xf800) >> 11);
  month = ((date & 0x0780) >> 7);
  year = (date & 0x007f);

  sprintf(tmp, "%.4d-%.2d-%.2d", year + 1900 , month, day);

  return tmp;

}
# 107 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c"
int64 str_to_currency(char *str) {
  char *next;
  int size, i;

  if (str == 0) return 0;
  strcpy(tmp, str);
  str = tmp;

  next = strchr(str, '.');
  if (next) {
    size = strlen(next+1);
    memmove(next, next+1, size+1);
    if (size <= 4) {
      size = 4 - size;
      for (i=0; i<size; i++) strcat(str, "0");
    } else {
      next[4] = 0;
    }
  } else {
    strcat(str, "0000");
  }

  return atoi64(str);

}



char * currency_to_str(int64 value) {
  char *str, *ptr;
  int size, move, i;

  i64toa(value, tmp, 10);
  str = tmp;

  size = strlen(str);
  if (size > 4) {
    ptr = str + size - 4;
    memmove(ptr+1, ptr, 4 +1);
    ptr[0] = '.';
  } else {
    move = 2 + 4 - size;
    memmove(str+move, str, size+1);
    str[0] = '0';
    str[1] = '.';
    for (i=2; i<move; i++) str[i] = '0';
  }

  return str;
}



int64 float_to_currency(double value) {
  char buf[128];

  snprintf(buf, 127, "%.4f", value);

  return str_to_currency(buf);

}



double currency_to_float(int64 value) {

  currency_to_str(value);

  return atof(tmp);

}



int64 mul_currency(int64 value1, int64 value2) {
  return value1 * value2 / 10000;
}



int64 div_currency(int64 value1, int64 value2) {
  return value1 * 10000 / value2;
}
# 212 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c"
char * test_create_object_1(int *psize) {
  binn *obj=0, *list=0;

  printf("creating object 1...\n");

  obj = binn_object();
  assert(obj != 0);

  vint32 = -12345;
  assert(binn_object_set(obj, "int32", 0x61, &vint32, 0) == 1);
  vint16 = -258;
  assert(binn_object_set(obj, "int16", 0x41, &vint16, 0) == 1);
  vint8 = -120;
  assert(binn_object_set(obj, "int8", 0x21, &vint8, 0) == 1);
  vint64 = -1234567890123;
  assert(binn_object_set(obj, "int64", 0x81, &vint64, 0) == 1);

  vuint32 = 123456;
  assert(binn_object_set(obj, "uint32", 0x60, &vuint32, 0) == 1);
  vuint16 = 60500;
  assert(binn_object_set(obj, "uint16", 0x40, &vuint16, 0) == 1);
  vuint8 = 250;
  assert(binn_object_set(obj, "uint8", 0x20, &vuint8, 0) == 1);
  vuint64 = 1234567890123;
  assert(binn_object_set(obj, "uint64", 0x80, &vuint64, 0) == 1);

  vfloat32 = -12.345;
  assert(binn_object_set(obj, "float32", 0x62, &vfloat32, 0) == 1);
  vfloat32 = -12.345;
  assert(binn_object_set(obj, "single", 0x62, &vfloat32, 0) == 1);
  vfloat64 = -123456.7895;
  assert(binn_object_set(obj, "float64", 0x82, &vfloat64, 0) == 1);
  vfloat64 = -123456.7895;
  assert(binn_object_set(obj, "double", 0x82, &vfloat64, 0) == 1);

  assert(binn_object_set(obj, "str", 0xA0, "the value", 0) == 1);

  vint32 = 1;
  assert(binn_object_set(obj, "bool_true", 0x80061, &vint32, 0) == 1);
  vint32 = 0;
  assert(binn_object_set(obj, "bool_false", 0x80061, &vint32, 0) == 1);

  assert(binn_object_set(obj, "null", 0x00, 0, 0) == 1);




  list = binn_list();
  assert(list != 0);

  assert(binn_list_add(list, 0x00, 0, 0) == 1);
  vint32 = 123;
  assert(binn_list_add(list, 0x61, &vint32, 0) == 1);
  assert(binn_list_add(list, 0xA0, "this is a string", 0) == 1);

  assert(binn_object_set(obj, "list", 0xE0, binn_ptr(list), binn_size(list)) == 1);

  binn_free(list); list = 0;




  *psize = binn_size(obj);
  return (char *) binn_ptr(obj);

}



char * test_create_object_2(int *psize) {
  binn *obj=0, *list=0;

  printf("creating object 2...\n");

  obj = binn_object();
  assert(obj != 0);

  assert(binn_object_set_int32(obj, "int32", -12345) == 1);
  assert(binn_object_set_int16(obj, "int16", -258) == 1);
  assert(binn_object_set_int8(obj, "int8", -120) == 1);
  assert(binn_object_set_int64(obj, "int64", -1234567890123) == 1);

  assert(binn_object_set_uint32(obj, "uint32", 123456) == 1);
  assert(binn_object_set_int16(obj, "uint16", 60500) == 1);
  assert(binn_object_set_int8(obj, "uint8", 250) == 1);
  assert(binn_object_set_uint64(obj, "uint64", 1234567890123) == 1);

  assert(binn_object_set_float(obj, "float32", -12.345) == 1);
  vfloat32 = -12.345;
  assert(binn_object_set(obj, "single", 0x62, &vfloat32, 0) == 1);
  assert(binn_object_set_double(obj, "float64", -123456.7895) == 1);
  vfloat64 = -123456.7895;
  assert(binn_object_set(obj, "double", 0x82, &vfloat64, 0) == 1);

  assert(binn_object_set_str(obj, "str", "the value") == 1);

  assert(binn_object_set_bool(obj, "bool_true", 1) == 1);
  assert(binn_object_set_bool(obj, "bool_false", 0) == 1);

  assert(binn_object_set_null(obj, "null") == 1);




  list = binn_list();
  assert(list != 0);

  assert(binn_list_add_null(list) == 1);
  assert(binn_list_add_int32(list, 123) == 1);
  assert(binn_list_add_str(list, "this is a string") == 1);

  assert(binn_object_set_list(obj, "list", list) == 1);

  binn_free(list); list = 0;




  *psize = binn_size(obj);
  return (char *) binn_ptr(obj);

}



void test_binn_read(void *objptr) {
  void *listptr;
  char *ptr;
  binn value={0};

  printf("OK\nreading:\n");

  vint32 = 0;
  assert(binn_object_get(objptr, "int32", 0x61, &vint32, 0) == 1);
  printf("int32: %d\n", vint32);
  assert(vint32 == -12345);

  vint16 = 0;
  assert(binn_object_get(objptr, "int16", 0x41, &vint16, 0) == 1);
  printf("int16: %d\n", vint16);
  assert(vint16 == -258);

  vint8 = 0;
  assert(binn_object_get(objptr, "int8", 0x21, &vint8, 0) == 1);
  printf("int8: %d\n", vint8);
  assert(vint8 == -120);

  vint64 = 0;
  assert(binn_object_get(objptr, "int64", 0x81, &vint64, 0) == 1);
  printf("int64: %" "lli" "\n", vint64);
  assert(vint64 == -1234567890123);


  vuint32 = 0;
  assert(binn_object_get(objptr, "uint32", 0x60, &vuint32, 0) == 1);
  printf("uint32: %d\n", vuint32);
  assert(vuint32 == 123456);

  vuint16 = 0;
  assert(binn_object_get(objptr, "uint16", 0x40, &vuint16, 0) == 1);
  printf("uint16: %d\n", vuint16);
  assert(vuint16 == 60500);

  vuint8 = 0;
  assert(binn_object_get(objptr, "uint8", 0x20, &vuint8, 0) == 1);
  printf("uint8: %d\n", vuint8);
  assert(vuint8 == 250);

  vuint64 = 0;
  assert(binn_object_get(objptr, "uint64", 0x80, &vuint64, 0) == 1);
  printf("uint64: %" "llu" "\n", vuint64);
  assert(vuint64 == 1234567890123);


  vfloat32 = 0;
  assert(binn_object_get(objptr, "float32", 0x62, &vfloat32, 0) == 1);
  printf("float32: %f\n", vfloat32);
  assert(AlmostEqualFloats(vfloat32, -12.345, 2) == 1);

  vfloat64 = 0;
  assert(binn_object_get(objptr, "float64", 0x82, &vfloat64, 0) == 1);
  printf("float64: %f\n", vfloat64);
  assert(vfloat64 - -123456.7895 < 0.01);

  vfloat32 = 0;
  assert(binn_object_get(objptr, "single", 0x62, &vfloat32, 0) == 1);
  printf("single: %f\n", vfloat32);
  assert(AlmostEqualFloats(vfloat32, -12.345, 2) == 1);

  vfloat64 = 0;
  assert(binn_object_get(objptr, "double", 0x82, &vfloat64, 0) == 1);
  printf("double: %f\n", vfloat64);
  assert(vfloat64 - -123456.7895 < 0.01);


  ptr = 0;
  assert(binn_object_get(objptr, "str", 0xA0, &ptr, 0) == 1);
  printf("ptr: (%p) '%s'\n", ptr, ptr);
  assert(strcmp(ptr, "the value") == 0);


  vint32 = 999;
  assert(binn_object_get(objptr, "bool_true", 0x80061, &vint32, 0) == 1);
  printf("bool true: %d\n", vint32);
  assert(vint32 == 1);

  vint32 = 999;
  assert(binn_object_get(objptr, "bool_false", 0x80061, &vint32, 0) == 1);
  printf("bool false: %d\n", vint32);
  assert(vint32 == 0);


  vint32 = 999;
  assert(binn_object_get(objptr, "null", 0x00, &vint32, 0) == 1);
  printf("null: %d\n", vint32);

  assert(binn_object_get(objptr, "null", 0x00, 0, 0) == 1);


  assert(binn_object_get(objptr, "list", 0xE0, &listptr, 0) == 1);
  printf("obj ptr: %p  list ptr: %p\n", objptr, listptr);
  assert(listptr != 0);
  assert(listptr > objptr);

  vint32 = 0;
  assert(binn_list_get(listptr, 2, 0x61, &vint32, 0) == 1);
  printf("int32: %d\n", vint32);
  assert(vint32 == 123);

  ptr = 0;
  assert(binn_list_get(listptr, 3, 0xA0, &ptr, 0) == 1);
  printf("ptr: (%p) '%s'\n", ptr, ptr);
  assert(strcmp(ptr, "this is a string") == 0);






  vint32 = 0;
  assert(binn_object_get_int32(objptr, "int32", &vint32) == 1);
  printf("int32: %d\n", vint32);
  assert(vint32 == -12345);

  vint16 = 0;
  assert(binn_object_get_int16(objptr, "int16", &vint16) == 1);
  printf("int16: %d\n", vint16);
  assert(vint16 == -258);

  vint8 = 0;
  assert(binn_object_get_int8(objptr, "int8", &vint8) == 1);
  printf("int8: %d\n", vint8);
  assert(vint8 == -120);

  vint64 = 0;
  assert(binn_object_get_int64(objptr, "int64", &vint64) == 1);
  printf("int64: %" "lli" "\n", vint64);
  assert(vint64 == -1234567890123);


  vuint32 = 0;
  assert(binn_object_get_uint32(objptr, "uint32", &vuint32) == 1);
  printf("uint32: %d\n", vuint32);
  assert(vuint32 == 123456);

  vuint16 = 0;
  assert(binn_object_get_uint16(objptr, "uint16", &vuint16) == 1);
  printf("uint16: %d\n", vuint16);
  assert(vuint16 == 60500);

  vuint8 = 0;
  assert(binn_object_get_uint8(objptr, "uint8", &vuint8) == 1);
  printf("uint8: %d\n", vuint8);
  assert(vuint8 == 250);

  vuint64 = 0;
  assert(binn_object_get_uint64(objptr, "uint64", &vuint64) == 1);
  printf("uint64: %" "llu" "\n", vuint64);
  assert(vuint64 == 1234567890123);


  vfloat32 = 0;
  assert(binn_object_get_float(objptr, "float32", &vfloat32) == 1);
  printf("float32: %f\n", vfloat32);
  assert(AlmostEqualFloats(vfloat32, -12.345, 2) == 1);

  vfloat64 = 0;
  assert(binn_object_get_double(objptr, "float64", &vfloat64) == 1);
  printf("float64: %f\n", vfloat64);
  assert(AlmostEqualFloats(vfloat32, -12.345, 2) == 1);


  ptr = 0;
  assert(binn_object_get_str(objptr, "str", &ptr) == 1);
  printf("ptr: (%p) '%s'\n", ptr, ptr);
  assert(strcmp(ptr, "the value") == 0);


  vint32 = 999;
  assert(binn_object_get_bool(objptr, "bool_true", &vint32) == 1);
  printf("bool true: %d\n", vint32);
  assert(vint32 == 1);

  vint32 = 999;
  assert(binn_object_get_bool(objptr, "bool_false", &vint32) == 1);
  printf("bool false: %d\n", vint32);
  assert(vint32 == 0);


  vbool = 0;
  assert(binn_object_null(objptr, "null") == 1);

  assert(binn_object_null(objptr, "bool_true") == 0);


  assert(binn_object_get_list(objptr, "list", &listptr) == 1);
  printf("obj ptr: %p  list ptr: %p\n", objptr, listptr);
  assert(listptr != 0);
  assert(listptr > objptr);

  vint32 = 0;
  assert(binn_list_get_int32(listptr, 2, &vint32) == 1);
  printf("int32: %d\n", vint32);
  assert(vint32 == 123);

  ptr = 0;
  assert(binn_list_get_str(listptr, 3, &ptr) == 1);
  printf("ptr: (%p) '%s'\n", ptr, ptr);
  assert(strcmp(ptr, "this is a string") == 0);






  vint32 = binn_object_int32(objptr, "int32");
  printf("int32: %d\n", vint32);
  assert(vint32 == -12345);

  vint16 = binn_object_int16(objptr, "int16");
  printf("int16: %d\n", vint16);
  assert(vint16 == -258);

  vint8 = binn_object_int8(objptr, "int8");
  printf("int8: %d\n", vint8);
  assert(vint8 == -120);

  vint64 = binn_object_int64(objptr, "int64");
  printf("int64: %" "lli" "\n", vint64);
  assert(vint64 == -1234567890123);


  vuint32 = binn_object_uint32(objptr, "uint32");
  printf("uint32: %d\n", vuint32);
  assert(vuint32 == 123456);

  vuint16 = binn_object_uint16(objptr, "uint16");
  printf("uint16: %d\n", vuint16);
  assert(vuint16 == 60500);

  vuint8 = binn_object_uint8(objptr, "uint8");
  printf("uint8: %d\n", vuint8);
  assert(vuint8 == 250);

  vuint64 = binn_object_uint64(objptr, "uint64");
  printf("uint64: %" "llu" "\n", vuint64);
  assert(vuint64 == 1234567890123);


  vfloat32 = binn_object_float(objptr, "float32");
  printf("float32: %f\n", vfloat32);
  assert(AlmostEqualFloats(vfloat32, -12.345, 2) == 1);

  vfloat64 = binn_object_double(objptr, "float64");
  printf("float64: %f\n", vfloat64);
  assert(AlmostEqualFloats(vfloat32, -12.345, 2) == 1);


  ptr = binn_object_str(objptr, "str");
  printf("ptr: (%p) '%s'\n", ptr, ptr);
  assert(strcmp(ptr, "the value") == 0);


  vint32 = binn_object_bool(objptr, "bool_true");
  printf("bool true: %d\n", vint32);
  assert(vint32 == 1);

  vint32 = binn_object_bool(objptr, "bool_false");
  printf("bool false: %d\n", vint32);
  assert(vint32 == 0);


  assert(binn_object_null(objptr, "null") == 1);
  assert(binn_object_null(objptr, "nonull") == 0);


  listptr = binn_object_list(objptr, "list");
  printf("obj ptr: %p  list ptr: %p\n", objptr, listptr);
  assert(listptr != 0);
  assert(listptr > objptr);

  vint32 = binn_list_int32(listptr, 2);
  printf("int32: %d\n", vint32);
  assert(vint32 == 123);

  ptr = binn_list_str(listptr, 3);
  printf("ptr: (%p) '%s'\n", ptr, ptr);
  assert(strcmp(ptr, "this is a string") == 0);






  assert(binn_object_get_value(objptr, "int32", &value) == 1);

  assert(value.type == 0x41);
  assert(value.vint16 == -12345);





  assert(binn_object_get_value(objptr, "int16", &value) == 1);
  assert(value.type == 0x41);
  assert(value.vint16 == -258);

  assert(binn_object_get_value(objptr, "int8", &value) == 1);
  assert(value.type == 0x21);
  assert(value.vint8 == -120);

  assert(binn_object_get_value(objptr, "int64", &value) == 1);
  assert(value.type == 0x81);
  assert(value.vint64 == -1234567890123);


  assert(binn_object_get_value(objptr, "uint32", &value) == 1);
  assert(value.type == 0x60);
  assert(value.vuint32 == 123456);

  assert(binn_object_get_value(objptr, "uint16", &value) == 1);
  assert(value.type == 0x40);
  assert(value.vuint16 == 60500);

  assert(binn_object_get_value(objptr, "uint8", &value) == 1);
  assert(value.type == 0x20);
  assert(value.vuint8 == 250);

  assert(binn_object_get_value(objptr, "uint64", &value) == 1);
  assert(value.type == 0x80);
  assert(value.vuint64 == 1234567890123);

  puts("reading... OK");

}



void init_udts() {
  binn *obj=0;
  unsigned short date;
  uint64 value;
  void *ptr;

  puts("testing UDTs...");

  assert(strcmp(date_to_str(str_to_date("1950-08-15")), "1950-08-15") == 0);
  assert(strcmp(date_to_str(str_to_date("1900-12-01")), "1900-12-01") == 0);
  assert(strcmp(date_to_str(str_to_date("2000-10-31")), "2000-10-31") == 0);
  assert(strcmp(date_to_str(str_to_date("2014-03-19")), "2014-03-19") == 0);

  printf("curr=%s\n", currency_to_str(str_to_currency("123.456")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("123.45")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("123.4")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("123.")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("123")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("1.2")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("0.987")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("0.98")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("0.9")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("0.0")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("0")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("123.4567")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("123.45678")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("123.456789")) );
  printf("curr=%s\n", currency_to_str(str_to_currency("0.1234")) );
  printf("curr=%s\n", currency_to_str(str_to_currency(".1234")) );

  assert(float_to_currency(2.5) == 25000);
  assert(float_to_currency(5) == 50000);
  assert(str_to_currency("1.1") == 11000);
  assert(str_to_currency("12") == 120000);
  assert(mul_currency(20000, 20000) == 40000);
  assert(mul_currency(20000, 25000) == 50000);
  assert(mul_currency(30000, 40000) == 120000);
  assert(div_currency(80000, 20000) == 40000);
  assert(div_currency(120000, 40000) == 30000);
  assert(div_currency(100000, 40000) == 25000);

  printf("1.1 * 2.5 = %s\n", currency_to_str(mul_currency(str_to_currency("1.1"), float_to_currency(2.5))) );
  printf("12 / 5 = %s\n", currency_to_str(div_currency(str_to_currency("12"), float_to_currency(5))) );





  MY_DATE = binn_create_type(0x40, 0x0a);
  MY_CURRENCY = binn_create_type(0x80, 0x0a);


  obj = binn_object();
  assert(obj != 0);

  date = str_to_date("1950-08-15");
  printf(" date 1: %d %s\n", date, date_to_str(date));
  assert(binn_object_set(obj, "date1", MY_DATE, &date, 0) == 1);
  assert(binn_object_set(obj, "date1", MY_DATE, &date, 0) == 0);

  date = str_to_date("1999-12-31");
  printf(" date 2: %d %s\n", date, date_to_str(date));
  binn_object_set(obj, "date2", MY_DATE, &date, 0);


  value = str_to_currency("123.456");
  printf(" curr 1: %" "llu" " %s\n", value, currency_to_str(value));
  binn_object_set(obj, "curr1", MY_CURRENCY, &value, 0);

  value = str_to_currency("123.45");
  printf(" curr 2: %" "llu" " %s\n", value, currency_to_str(value));
  binn_object_set(obj, "curr2", MY_CURRENCY, &value, 0);

  value = str_to_currency("12.5");
  printf(" curr 3: %" "llu" " %s\n", value, currency_to_str(value));
  binn_object_set(obj, "curr3", MY_CURRENCY, &value, 0);

  value = str_to_currency("5");
  printf(" curr 4: %" "llu" " %s\n", value, currency_to_str(value));
  binn_object_set(obj, "curr4", MY_CURRENCY, &value, 0);

  value = str_to_currency("0.75");
  printf(" curr 5: %" "llu" " %s\n", value, currency_to_str(value));
  binn_object_set(obj, "curr5", MY_CURRENCY, &value, 0);


  ptr = binn_ptr(obj);


  assert(binn_object_get(ptr, "date1", MY_DATE, &date, 0) == 1);
  printf(" date 1: %d %s\n", date, date_to_str(date));

  assert(binn_object_get(ptr, "date2", MY_DATE, &date, 0) == 1);
  printf(" date 2: %d %s\n", date, date_to_str(date));


  assert(binn_object_get(ptr, "curr1", MY_CURRENCY, &value, 0) == 1);
  printf(" curr 1: %" "llu" " %s\n", value, currency_to_str(value));

  assert(binn_object_get(ptr, "curr2", MY_CURRENCY, &value, 0) == 1);
  printf(" curr 2: %" "llu" " %s\n", value, currency_to_str(value));

  assert(binn_object_get(ptr, "curr3", MY_CURRENCY, &value, 0) == 1);
  printf(" curr 3: %" "llu" " %s\n", value, currency_to_str(value));

  assert(binn_object_get(ptr, "curr4", MY_CURRENCY, &value, 0) == 1);
  printf(" curr 4: %" "llu" " %s\n", value, currency_to_str(value));

  assert(binn_object_get(ptr, "curr5", MY_CURRENCY, &value, 0) == 1);
  printf(" curr 5: %" "llu" " %s\n", value, currency_to_str(value));


  binn_free(obj);

  puts("testing UDTs... OK");

}



BOOL copy_int_value(void *psource, void *pdest, int source_type, int dest_type);

void test_int_conversion() {

  printf("testing integer conversion...");



  vint8 = -110; vuint8 = 0;
  assert(copy_int_value(&vint8, &vuint8, 0x21, 0x20) == 0);
  assert(vint8 == -110);
  assert(vuint8 == 0);

  vint8 = -110; vuint16 = 0;
  assert(copy_int_value(&vint8, &vuint16, 0x21, 0x40) == 0);
  assert(vint8 == -110);
  assert(vuint16 == 0);

  vint8 = -110; vuint32 = 0;
  assert(copy_int_value(&vint8, &vuint32, 0x21, 0x60) == 0);
  assert(vint8 == -110);
  assert(vuint32 == 0);

  vint8 = -110; vuint64 = 0;
  assert(copy_int_value(&vint8, &vuint64, 0x21, 0x80) == 0);
  assert(vint8 == -110);
  assert(vuint64 == 0);


  vint16 = -123; vuint8 = 0;
  assert(copy_int_value(&vint16, &vuint8, 0x41, 0x20) == 0);
  assert(vint16 == -123);
  assert(vuint8 == 0);

  vint16 = -123; vuint16 = 0;
  assert(copy_int_value(&vint16, &vuint16, 0x41, 0x40) == 0);
  assert(vint16 == -123);
  assert(vuint16 == 0);

  vint16 = -32000; vuint32 = 0;
  assert(copy_int_value(&vint16, &vuint32, 0x41, 0x60) == 0);
  assert(vint16 == -32000);
  assert(vuint32 == 0);

  vint16 = -32000; vuint64 = 0;
  assert(copy_int_value(&vint16, &vuint64, 0x41, 0x80) == 0);
  assert(vint16 == -32000);
  assert(vuint64 == 0);


  vint32 = -123; vuint8 = 0;
  assert(copy_int_value(&vint32, &vuint8, 0x61, 0x20) == 0);
  assert(vint32 == -123);
  assert(vuint8 == 0);

  vint32 = -123; vuint16 = 0;
  assert(copy_int_value(&vint32, &vuint16, 0x61, 0x40) == 0);
  assert(vint32 == -123);
  assert(vuint16 == 0);

  vint32 = -123; vuint32 = 0;
  assert(copy_int_value(&vint32, &vuint32, 0x61, 0x60) == 0);
  assert(vint32 == -123);
  assert(vuint32 == 0);

  vint32 = -123; vuint64 = 0;
  assert(copy_int_value(&vint32, &vuint64, 0x61, 0x80) == 0);
  assert(vint32 == -123);
  assert(vuint64 == 0);


  vint64 = -123; vuint8 = 0;
  assert(copy_int_value(&vint64, &vuint8, 0x81, 0x20) == 0);
  assert(vint64 == -123);
  assert(vuint8 == 0);

  vint64 = -123; vuint16 = 0;
  assert(copy_int_value(&vint64, &vuint16, 0x81, 0x40) == 0);
  assert(vint64 == -123);
  assert(vuint16 == 0);

  vint64 = -123; vuint32 = 0;
  assert(copy_int_value(&vint64, &vuint32, 0x81, 0x60) == 0);
  assert(vint64 == -123);
  assert(vuint32 == 0);

  vint64 = -123; vuint64 = 0;
  assert(copy_int_value(&vint64, &vuint64, 0x81, 0x80) == 0);
  assert(vint64 == -123);
  assert(vuint64 == 0);




  vint16 = -32000; vint8 = 0;
  assert(copy_int_value(&vint16, &vint8, 0x41, 0x21) == 0);
  assert(vint16 == -32000);
  assert(vint8 == 0);


  vint32 = -250; vint8 = 0;
  assert(copy_int_value(&vint32, &vint8, 0x61, 0x21) == 0);
  assert(vint32 == -250);
  assert(vint8 == 0);

  vint32 = -35000; vint16 = 0;
  assert(copy_int_value(&vint32, &vint16, 0x61, 0x41) == 0);
  assert(vint32 == -35000);
  assert(vint16 == 0);


  vint64 = -250; vint8 = 0;
  assert(copy_int_value(&vint64, &vint8, 0x81, 0x21) == 0);
  assert(vint64 == -250);
  assert(vint8 == 0);

  vint64 = -35000; vint16 = 0;
  assert(copy_int_value(&vint64, &vint16, 0x81, 0x41) == 0);
  assert(vint64 == -35000);
  assert(vint16 == 0);

  vint64 = -25470000000; vint32 = 0;
  assert(copy_int_value(&vint64, &vint32, 0x81, 0x61) == 0);
  assert(vint64 == -25470000000);
  assert(vint32 == 0);




  vint16 = 250; vint8 = 0;
  assert(copy_int_value(&vint16, &vint8, 0x41, 0x21) == 0);
  assert(vint16 == 250);
  assert(vint8 == 0);


  vint32 = 250; vint8 = 0;
  assert(copy_int_value(&vint32, &vint8, 0x61, 0x21) == 0);
  assert(vint32 == 250);
  assert(vint8 == 0);

  vint32 = 35000; vint16 = 0;
  assert(copy_int_value(&vint32, &vint16, 0x61, 0x41) == 0);
  assert(vint32 == 35000);
  assert(vint16 == 0);


  vint64 = 250; vint8 = 0;
  assert(copy_int_value(&vint64, &vint8, 0x81, 0x21) == 0);
  assert(vint64 == 250);
  assert(vint8 == 0);

  vint64 = 35000; vint16 = 0;
  assert(copy_int_value(&vint64, &vint16, 0x81, 0x41) == 0);
  assert(vint64 == 35000);
  assert(vint16 == 0);

  vint64 = 25470000000; vint32 = 0;
  assert(copy_int_value(&vint64, &vint32, 0x81, 0x61) == 0);
  assert(vint64 == 25470000000);
  assert(vint32 == 0);





  vint16 = 300; vuint8 = 0;
  assert(copy_int_value(&vint16, &vuint8, 0x41, 0x20) == 0);
  assert(vint16 == 300);
  assert(vuint8 == 0);


  vint32 = 300; vuint8 = 0;
  assert(copy_int_value(&vint32, &vuint8, 0x61, 0x20) == 0);
  assert(vint32 == 300);
  assert(vuint8 == 0);

  vint32 = 70000; vuint16 = 0;
  assert(copy_int_value(&vint32, &vuint16, 0x61, 0x40) == 0);
  assert(vint32 == 70000);
  assert(vuint16 == 0);


  vint64 = 300; vuint8 = 0;
  assert(copy_int_value(&vint64, &vuint8, 0x81, 0x20) == 0);
  assert(vint64 == 300);
  assert(vuint8 == 0);

  vint64 = 70000; vuint16 = 0;
  assert(copy_int_value(&vint64, &vuint16, 0x81, 0x40) == 0);
  assert(vint64 == 70000);
  assert(vuint16 == 0);

  vint64 = 25470000000; vuint32 = 0;
  assert(copy_int_value(&vint64, &vuint32, 0x81, 0x60) == 0);
  assert(vint64 == 25470000000);
  assert(vuint32 == 0);
# 994 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c"
  vint8 = 123; vint16 = 0;
  assert(copy_int_value(&vint8, &vint16, 0x21, 0x41) == 1);
  assert(vint8 == 123);
  assert(vint16 == 123);

  vint8 = -110; vint16 = 0;
  assert(copy_int_value(&vint8, &vint16, 0x21, 0x41) == 1);
  assert(vint8 == -110);
  assert(vint16 == -110);

  vint8 = 123; vint32 = 0;
  assert(copy_int_value(&vint8, &vint32, 0x21, 0x61) == 1);
  assert(vint8 == 123);
  assert(vint32 == 123);

  vint8 = -110; vint32 = 0;
  assert(copy_int_value(&vint8, &vint32, 0x21, 0x61) == 1);
  assert(vint8 == -110);
  assert(vint32 == -110);

  vint8 = 123; vint64 = 0;
  assert(copy_int_value(&vint8, &vint64, 0x21, 0x81) == 1);
  assert(vint8 == 123);
  assert(vint64 == 123);

  vint8 = -120; vint64 = 0;
  assert(copy_int_value(&vint8, &vint64, 0x21, 0x81) == 1);
  assert(vint8 == -120);
  assert(vint64 == -120);




  vint8 = 123; vuint16 = 0;
  assert(copy_int_value(&vint8, &vuint16, 0x21, 0x40) == 1);
  assert(vint8 == 123);
  assert(vuint16 == 123);

  vint8 = 123; vuint32 = 0;
  assert(copy_int_value(&vint8, &vuint32, 0x21, 0x60) == 1);
  assert(vint8 == 123);
  assert(vuint32 == 123);

  vint8 = 123; vuint64 = 0;
  assert(copy_int_value(&vint8, &vuint64, 0x21, 0x80) == 1);
  assert(vint8 == 123);
  assert(vuint64 == 123);





  vuint8 = 123; vint16 = 0;
  assert(copy_int_value(&vuint8, &vint16, 0x20, 0x41) == 1);
  assert(vuint8 == 123);
  assert(vint16 == 123);

  vuint8 = 250; vint16 = 0;
  assert(copy_int_value(&vuint8, &vint16, 0x20, 0x41) == 1);
  assert(vuint8 == 250);
  assert(vint16 == 250);

  vuint8 = 123; vint32 = 0;
  assert(copy_int_value(&vuint8, &vint32, 0x20, 0x61) == 1);
  assert(vuint8 == 123);
  assert(vint32 == 123);

  vuint8 = 250; vint32 = 0;
  assert(copy_int_value(&vuint8, &vint32, 0x20, 0x61) == 1);
  assert(vuint8 == 250);
  assert(vint32 == 250);

  vuint8 = 123; vint64 = 0;
  assert(copy_int_value(&vuint8, &vint64, 0x20, 0x81) == 1);
  assert(vuint8 == 123);
  assert(vint64 == 123);

  vuint8 = 250; vint64 = 0;
  assert(copy_int_value(&vuint8, &vint64, 0x20, 0x81) == 1);
  assert(vuint8 == 250);
  assert(vint64 == 250);




  vuint8 = 123; vuint16 = 0;
  assert(copy_int_value(&vuint8, &vuint16, 0x20, 0x40) == 1);
  assert(vuint8 == 123);
  assert(vuint16 == 123);

  vuint8 = 250; vuint16 = 0;
  assert(copy_int_value(&vuint8, &vuint16, 0x20, 0x40) == 1);
  assert(vuint8 == 250);
  assert(vuint16 == 250);

  vuint8 = 123; vuint32 = 0;
  assert(copy_int_value(&vuint8, &vuint32, 0x20, 0x60) == 1);
  assert(vuint8 == 123);
  assert(vuint32 == 123);

  vuint8 = 250; vuint32 = 0;
  assert(copy_int_value(&vuint8, &vuint32, 0x20, 0x60) == 1);
  assert(vuint8 == 250);
  assert(vuint32 == 250);

  vuint8 = 123; vuint64 = 0;
  assert(copy_int_value(&vuint8, &vuint64, 0x20, 0x80) == 1);
  assert(vuint8 == 123);
  assert(vuint64 == 123);

  vuint8 = 250; vuint64 = 0;
  assert(copy_int_value(&vuint8, &vuint64, 0x20, 0x80) == 1);
  assert(vuint8 == 250);
  assert(vuint64 == 250);




  vint16 = 250; vuint8 = 0;
  assert(copy_int_value(&vint16, &vuint8, 0x41, 0x20) == 1);
  assert(vint16 == 250);
  assert(vuint8 == 250);


  vint32 = 250; vuint8 = 0;
  assert(copy_int_value(&vint32, &vuint8, 0x61, 0x20) == 1);
  assert(vint32 == 250);
  assert(vuint8 == 250);

  vint32 = 35000; vuint16 = 0;
  assert(copy_int_value(&vint32, &vuint16, 0x61, 0x40) == 1);
  assert(vint32 == 35000);
  assert(vuint16 == 35000);


  vint64 = 250; vuint8 = 0;
  assert(copy_int_value(&vint64, &vuint8, 0x81, 0x20) == 1);
  assert(vint64 == 250);
  assert(vuint8 == 250);

  vint64 = 35000; vuint16 = 0;
  assert(copy_int_value(&vint64, &vuint16, 0x81, 0x40) == 1);
  assert(vint64 == 35000);
  assert(vuint16 == 35000);

  vint64 = 2147000000; vuint32 = 0;
  assert(copy_int_value(&vint64, &vuint32, 0x81, 0x60) == 1);
  assert(vint64 == 2147000000);
  assert(vuint32 == 2147000000);







  vint8 = -110; vint16 = 0;
  assert(copy_int_value(&vint8, &vint16, 0x21, 0x41) == 1);
  assert(vint8 == -110);
  assert(vint16 == -110);

  vint8 = -110; vint32 = 0;
  assert(copy_int_value(&vint8, &vint32, 0x21, 0x61) == 1);
  assert(vint8 == -110);
  assert(vint32 == -110);

  vint8 = -110; vint64 = 0;
  assert(copy_int_value(&vint8, &vint64, 0x21, 0x81) == 1);
  assert(vint8 == -110);
  assert(vint64 == -110);


  vint16 = -123; vint8 = 0;
  assert(copy_int_value(&vint16, &vint8, 0x41, 0x21) == 1);
  assert(vint16 == -123);
  assert(vint8 == -123);

  vint16 = -32000; vint32 = 0;
  assert(copy_int_value(&vint16, &vint32, 0x41, 0x61) == 1);
  assert(vint16 == -32000);
  assert(vint32 == -32000);

  vint16 = -32000; vint64 = 0;
  assert(copy_int_value(&vint16, &vint64, 0x41, 0x81) == 1);
  assert(vint16 == -32000);
  assert(vint64 == -32000);


  vint32 = -123; vint8 = 0;
  assert(copy_int_value(&vint32, &vint8, 0x61, 0x21) == 1);
  assert(vint32 == -123);
  assert(vint8 == -123);

  vint32 = -123; vint16 = 0;
  assert(copy_int_value(&vint32, &vint16, 0x61, 0x41) == 1);
  assert(vint32 == -123);
  assert(vint16 == -123);

  vint32 = -32000; vint16 = 0;
  assert(copy_int_value(&vint32, &vint16, 0x61, 0x41) == 1);
  assert(vint32 == -32000);
  assert(vint16 == -32000);

  vint32 = -123; vint64 = 0;
  assert(copy_int_value(&vint32, &vint64, 0x61, 0x81) == 1);
  assert(vint32 == -123);
  assert(vint64 == -123);

  vint32 = -2147000000; vint64 = 0;
  assert(copy_int_value(&vint32, &vint64, 0x61, 0x81) == 1);
  assert(vint32 == -2147000000);
  assert(vint64 == -2147000000);


  vint64 = -123; vint8 = 0;
  assert(copy_int_value(&vint64, &vint8, 0x81, 0x21) == 1);
  assert(vint64 == -123);
  assert(vint8 == -123);

  vint64 = -250; vint16 = 0;
  assert(copy_int_value(&vint64, &vint16, 0x81, 0x41) == 1);
  assert(vint64 == -250);
  assert(vint16 == -250);

  vint64 = -35000; vint32 = 0;
  assert(copy_int_value(&vint64, &vint32, 0x81, 0x61) == 1);
  assert(vint64 == -35000);
  assert(vint32 == -35000);


  puts("OK");

}



void test_binn_int_conversion() {
  binn *obj=0;
  void *ptr;

  printf("testing binn integer read conversion... ");

  obj = binn_object();
  assert(obj != 0);

  assert(binn_object_set_int8(obj, "int8", -8) == 1);
  assert(binn_object_set_int16(obj, "int16", -16) == 1);
  assert(binn_object_set_int32(obj, "int32", -32) == 1);
  assert(binn_object_set_int64(obj, "int64", -64) == 1);

  assert(binn_object_set_uint8(obj, "uint8", 111) == 1);
  assert(binn_object_set_uint16(obj, "uint16", 112) == 1);
  assert(binn_object_set_uint32(obj, "uint32", 113) == 1);
  assert(binn_object_set_uint64(obj, "uint64", 114) == 1);

  ptr = binn_ptr(obj);

  assert(binn_object_int8(ptr, "int8") == -8);
  assert(binn_object_int8(ptr, "int16") == -16);
  assert(binn_object_int8(ptr, "int32") == -32);
  assert(binn_object_int8(ptr, "int64") == -64);

  assert(binn_object_int16(ptr, "int8") == -8);
  assert(binn_object_int16(ptr, "int16") == -16);
  assert(binn_object_int16(ptr, "int32") == -32);
  assert(binn_object_int16(ptr, "int64") == -64);

  assert(binn_object_int32(ptr, "int8") == -8);
  assert(binn_object_int32(ptr, "int16") == -16);
  assert(binn_object_int32(ptr, "int32") == -32);
  assert(binn_object_int32(ptr, "int64") == -64);

  assert(binn_object_int64(ptr, "int8") == -8);
  assert(binn_object_int64(ptr, "int16") == -16);
  assert(binn_object_int64(ptr, "int32") == -32);
  assert(binn_object_int64(ptr, "int64") == -64);


  assert(binn_object_int8(ptr, "uint8") == 111);
  assert(binn_object_int8(ptr, "uint16") == 112);
  assert(binn_object_int8(ptr, "uint32") == 113);
  assert(binn_object_int8(ptr, "uint64") == 114);

  assert(binn_object_int16(ptr, "uint8") == 111);
  assert(binn_object_int16(ptr, "uint16") == 112);
  assert(binn_object_int16(ptr, "uint32") == 113);
  assert(binn_object_int16(ptr, "uint64") == 114);

  assert(binn_object_int32(ptr, "uint8") == 111);
  assert(binn_object_int32(ptr, "uint16") == 112);
  assert(binn_object_int32(ptr, "uint32") == 113);
  assert(binn_object_int32(ptr, "uint64") == 114);

  assert(binn_object_int64(ptr, "uint8") == 111);
  assert(binn_object_int64(ptr, "uint16") == 112);
  assert(binn_object_int64(ptr, "uint32") == 113);
  assert(binn_object_int64(ptr, "uint64") == 114);


  binn_free(obj);

  puts("OK");

}



void test_value_conversion() {
  binn *value;
  char *ptr, blob[64] = "test blob";
  void *pblob;
  int size, vint32;
  int64 vint64;
  double vdouble;
  BOOL vbool;

  printf("testing binn value conversion... ");



  ptr = "static string";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn == 0);
  binn_free(value);

  ptr = "transient string";
  value = binn_string(ptr, ((binn_mem_free)-1));
  assert(value != 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr != ptr);
  assert(strcmp((char*)value->ptr, ptr) == 0);
  assert(value->freefn != 0);
  binn_free(value);

  ptr = strdup("dynamic allocated string");
  value = binn_string(ptr, free);
  assert(value != 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn != 0);
  assert(value->freefn == &free);
  binn_free(value);



  size = 64;
  pblob = blob;
  value = binn_blob(pblob, size, ((binn_mem_free)0));
  assert(value != 0);
  assert(value->type == 0xC0);
  assert(value->ptr != 0);
  assert(value->ptr == pblob);
  assert(value->freefn == 0);
  binn_free(value);

  size = 64;
  pblob = blob;
  value = binn_blob(pblob, size, ((binn_mem_free)-1));
  assert(value != 0);
  assert(value->type == 0xC0);
  assert(value->ptr != 0);
  assert(value->ptr != pblob);
  assert(memcmp(value->ptr, pblob, size) == 0);
  assert(value->freefn != 0);
  binn_free(value);

  size = 64;
  pblob = memdup(blob, size);
  value = binn_blob(pblob, size, free);
  assert(value != 0);
  assert(value->type == 0xC0);
  assert(value->ptr != 0);
  assert(value->ptr == pblob);
  assert(value->freefn == &free);
  binn_free(value);




  ptr = "123";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn == 0);

  assert(binn_get_str(value) == ptr);
  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == 123);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == 123);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, 123, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);

  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn == 0);

  binn_free(value);


  ptr = "-456";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn == 0);

  assert(binn_get_str(value) == ptr);
  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == -456);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == -456);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, -456, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);

  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn == 0);

  binn_free(value);


  ptr = "-4.56";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn == 0);

  assert(binn_get_str(value) == ptr);
  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == -4);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == -4);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, -4.56, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);

  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn == 0);

  binn_free(value);




  ptr = "yes";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(binn_get_str(value) == ptr);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);
  binn_free(value);

  ptr = "no";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 0);
  binn_free(value);

  ptr = "on";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);
  binn_free(value);

  ptr = "off";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 0);
  binn_free(value);

  ptr = "true";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);
  binn_free(value);

  ptr = "false";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 0);
  binn_free(value);

  ptr = "1";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);
  binn_free(value);

  ptr = "0";
  value = binn_string(ptr, ((binn_mem_free)0));
  assert(value != 0);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 0);
  binn_free(value);




  value = binn_int32(-345);
  assert(value != 0);
  assert(value->type == 0x61);
  assert(value->vint32 == -345);
  assert(value->freefn == 0);

  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == -345);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == -345);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, -345, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);

  assert(value->type == 0x61);
  assert(value->vint32 == -345);
  assert(value->freefn == 0);

  ptr = binn_get_str(value);
  assert(ptr != 0);
  assert(strcmp(ptr, "-345") == 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn != 0);

  binn_free(value);


  value = binn_int32(0);
  assert(value != 0);
  assert(value->type == 0x61);
  assert(value->vint32 == 0);
  assert(value->freefn == 0);

  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == 0);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == 0);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, 0, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 0);

  assert(value->type == 0x61);
  assert(value->vint32 == 0);
  assert(value->freefn == 0);

  ptr = binn_get_str(value);
  assert(ptr != 0);
  assert(strcmp(ptr, "0") == 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn != 0);

  binn_free(value);




  value = binn_int64(-345678);
  assert(value != 0);
  assert(value->type == 0x81);
  assert(value->vint64 == -345678);
  assert(value->freefn == 0);

  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == -345678);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == -345678);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, -345678, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);

  assert(value->type == 0x81);
  assert(value->vint64 == -345678);
  assert(value->freefn == 0);

  ptr = binn_get_str(value);
  assert(ptr != 0);
  assert(strcmp(ptr, "-345678") == 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn != 0);

  binn_free(value);




  value = binn_double(-345.678);
  assert(value != 0);
  assert(value->type == 0x82);
  assert(value->vdouble == -345.678);
  assert(value->freefn == 0);

  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == -345);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == -345);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, -345.678, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);

  assert(value->type == 0x82);
  assert(value->vdouble == -345.678);
  assert(value->freefn == 0);

  ptr = binn_get_str(value);
  assert(ptr != 0);
  assert(strcmp(ptr, "-345.678") == 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn != 0);

  binn_free(value);


  value = binn_double(0.0);
  assert(value != 0);
  assert(value->type == 0x82);
  assert(value->vdouble == 0.0);
  assert(value->freefn == 0);

  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == 0);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == 0);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, 0, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 0);

  assert(value->type == 0x82);
  assert(value->vdouble == 0.0);
  assert(value->freefn == 0);

  ptr = binn_get_str(value);
  assert(ptr != 0);
  assert(strcmp(ptr, "0") == 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn != 0);

  binn_free(value);




  value = binn_bool(0);
  assert(value != 0);
  assert(value->type == 0x80061);
  assert(value->vbool == 0);
  assert(value->freefn == 0);

  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == 0);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == 0);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, 0, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 0);

  assert(value->type == 0x80061);
  assert(value->vbool == 0);
  assert(value->freefn == 0);

  ptr = binn_get_str(value);
  assert(ptr != 0);
  assert(strcmp(ptr, "false") == 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn != 0);

  binn_free(value);


  value = binn_bool(1);
  assert(value != 0);
  assert(value->type == 0x80061);
  assert(value->vbool == 1);
  assert(value->freefn == 0);

  assert(binn_get_int32(value, &vint32) == 1);
  assert(vint32 == 1);
  assert(binn_get_int64(value, &vint64) == 1);
  assert(vint64 == 1);
  assert(binn_get_double(value, &vdouble) == 1);
  assert(AlmostEqualFloats(vdouble, 1, 4) == 1);
  assert(binn_get_bool(value, &vbool) == 1);
  assert(vbool == 1);

  assert(value->type == 0x80061);
  assert(value->vbool == 1);
  assert(value->freefn == 0);

  ptr = binn_get_str(value);
  assert(ptr != 0);
  assert(strcmp(ptr, "true") == 0);
  assert(value->type == 0xA0);
  assert(value->ptr != 0);
  assert(value->ptr == ptr);
  assert(value->freefn != 0);

  binn_free(value);


  puts("OK");

}



void test_value_copy() {

  printf("testing binn value copy... ");



  puts("TODO!!!");

}



void test_virtual_types() {
  binn *list=0;
  void *ptr;
  int storage_type, extra_type;
  BOOL value;

  printf("testing binn virtual types... ");

  assert(binn_get_type_info(0x80061, &storage_type, &extra_type) == 1);
  assert(storage_type == 0x60);
  assert(extra_type == 1);

  list = binn_list();
  assert(list != 0);

  assert(binn_list_add_bool(list, 1) == 1);
  assert(binn_list_add_bool(list, 0) == 1);
  assert(binn_list_add_null(list) == 1);

  ptr = binn_ptr(list);
  assert(ptr != 0);

  assert(binn_list_get_bool(ptr, 1, &value) == 1);
  assert(value == 1);

  assert(binn_list_get_bool(ptr, 2, &value) == 1);
  assert(value == 0);

  assert(binn_list_null(ptr, 3) == 1);


  assert(binn_list_null(ptr, 1) == 0);
  assert(binn_list_null(ptr, 2) == 0);
  assert(binn_list_get_bool(ptr, 3, &value) == 0);

  binn_free(list);

  puts("OK");
}



void test_binn_iter(BOOL use_int_compression) {
  binn *list, *map, *obj;
  binn *list2, *copy=0;
  binn_iter iter, iter2;
  binn value, value2;
  int blob_size, id, id2, list2size;
  void *ptr, *blob_ptr;
  char key[256], key2[256];

  blob_ptr = "key\0value\0\0";
  blob_size = 11;

  printf("testing binn sequential read (use_int_compression = %d)... ", use_int_compression);



  list = binn_list();
  list2 = binn_list();
  map = binn_map();
  obj = binn_object();

  assert(list != 0);
  assert(list2 != 0);
  assert(map != 0);
  assert(obj != 0);

  if (use_int_compression == 0) {
    list->disable_int_compression = 1;
    map->disable_int_compression = 1;
    obj->disable_int_compression = 1;
  }

  assert(binn_list_add_int32(list2, 250) == 1);
  assert(binn_list_add_null(list2) == 1);
  assert(binn_list_add_str(list2, "l1st2") == 1);
  assert(binn_list_add_bool(list2, 1) == 1);

  list2size = binn_size(list2);

  assert(binn_list_add_int8(list, 111) == 1);
  assert(binn_list_add_int32(list, 123456789) == 1);
  assert(binn_list_add_int16(list, -123) == 1);
  assert(binn_list_add_int64(list, 9876543210) == 1);
  assert(binn_list_add_float(list, 1.25) == 1);
  assert(binn_list_add_double(list, 25.987654321) == 1);
  assert(binn_list_add_bool(list, 1) == 1);
  assert(binn_list_add_bool(list, 0) == 1);
  assert(binn_list_add_null(list) == 1);
  assert(binn_list_add_str(list, "testing...") == 1);
  assert(binn_list_add_blob(list, (char *)blob_ptr, blob_size) == 1);
  assert(binn_list_add_list(list, list2) == 1);

  assert(binn_object_set_int8(obj, "a", 111) == 1);
  assert(binn_object_set_int32(obj, "b", 123456789) == 1);
  assert(binn_object_set_int16(obj, "c", -123) == 1);
  assert(binn_object_set_int64(obj, "d", 9876543210) == 1);
  assert(binn_object_set_float(obj, "e", 1.25) == 1);
  assert(binn_object_set_double(obj, "f", 25.987654321) == 1);
  assert(binn_object_set_bool(obj, "g", 1) == 1);
  assert(binn_object_set_bool(obj, "h", 0) == 1);
  assert(binn_object_set_null(obj, "i") == 1);
  assert(binn_object_set_str(obj, "j", "testing...") == 1);
  assert(binn_object_set_blob(obj, "k", (char *)blob_ptr, blob_size) == 1);
  assert(binn_object_set_list(obj, "l", list2) == 1);

  assert(binn_map_set_int8(map, 55010, 111) == 1);
  assert(binn_map_set_int32(map, 55020, 123456789) == 1);
  assert(binn_map_set_int16(map, 55030, -123) == 1);
  assert(binn_map_set_int64(map, 55040, 9876543210) == 1);
  assert(binn_map_set_float(map, 55050, 1.25) == 1);
  assert(binn_map_set_double(map, 55060, 25.987654321) == 1);
  assert(binn_map_set_bool(map, 55070, 1) == 1);
  assert(binn_map_set_bool(map, 55080, 0) == 1);
  assert(binn_map_set_null(map, 55090) == 1);
  assert(binn_map_set_str(map, 55100, "testing...") == 1);
  assert(binn_map_set_blob(map, 55110, (char *)blob_ptr, blob_size) == 1);
  assert(binn_map_set_list(map, 55120, list2) == 1);
# 1885 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c"
  ptr = binn_ptr(list);
  assert(ptr != 0);
  assert(binn_iter_init(&iter, ptr, 0xE0));
  assert(iter.pnext > ptr);
  assert(iter.plimit > ptr);
  assert(iter.count == 12);
  assert(iter.current == 0);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.pnext > ptr);
  assert(iter.plimit > ptr);
  assert(iter.count == 12);
  assert(iter.current == 1);
  assert(value.type == 0x21);
  assert(value.vint8 == 111);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 2);
  if (use_int_compression) {
    assert(value.type == 0x60);
  } else {
    assert(value.type == 0x61);
  }
  assert(value.vint32 == 123456789);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 3);
  if (use_int_compression) {
    assert(value.type == 0x21);
    assert(value.vint8 == -123);
  } else {
    assert(value.type == 0x41);
    assert(value.vint16 == -123);
  }

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 4);
  assert(value.type == 0x81);
  assert(value.vint64 == 9876543210);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 5);
  assert(value.type == 0x62);
  assert(AlmostEqualFloats(value.vfloat, 1.25, 2));

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 6);
  assert(value.type == 0x82);
  assert(value.vdouble - 25.987654321 < 0.00000001);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 7);
  assert(value.type == 0x80061);
  assert(value.vbool == 1);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 8);
  assert(value.type == 0x80061);
  assert(value.vbool == 0);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 9);
  assert(value.type == 0x00);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 10);
  assert(value.type == 0xA0);
  assert(strcmp((char *)value.ptr, "testing...") == 0);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 11);
  assert(value.type == 0xC0);
  assert(memcmp(value.ptr, blob_ptr, blob_size) == 0);

  assert(binn_list_next(&iter, &value) == 1);
  assert(iter.current == 12);
  assert(value.type == 0xE0);
  assert(value.size == list2size);
  assert(value.count == 4);
  assert(value.ptr != 0);
  assert(binn_list_int32(value.ptr, 1) == 250);
  assert(binn_list_null(value.ptr, 2) == 1);
  ptr = binn_list_str(value.ptr, 3);
  assert(ptr != 0);
  assert(strcmp((char *)ptr, "l1st2") == 0);
  assert(binn_list_bool(value.ptr, 4) == 1);

  assert(binn_list_next(&iter, &value) == 0);



  assert(binn_list_next(&iter, &value) == 0);







  ptr = binn_ptr(obj);
  assert(ptr != 0);
  assert(binn_iter_init(&iter, ptr, 0xE2));
  assert(iter.pnext > ptr);
  assert(iter.plimit > ptr);
  assert(iter.count == 12);
  assert(iter.current == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.pnext > ptr);
  assert(iter.plimit > ptr);
  assert(iter.count == 12);
  assert(iter.current == 1);
  assert(value.type == 0x21);
  assert(value.vint8 == 111);

  assert(strcmp(key, "a") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 2);
  if (use_int_compression) {
    assert(value.type == 0x60);
  } else {
    assert(value.type == 0x61);
  }
  assert(value.vint32 == 123456789);

  assert(strcmp(key, "b") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 3);
  if (use_int_compression) {
    assert(value.type == 0x21);
    assert(value.vint8 == -123);
  } else {
    assert(value.type == 0x41);
    assert(value.vint16 == -123);
  }

  assert(strcmp(key, "c") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 4);
  assert(value.type == 0x81);
  assert(value.vint64 == 9876543210);

  assert(strcmp(key, "d") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 5);
  assert(value.type == 0x62);
  assert(AlmostEqualFloats(value.vfloat, 1.25, 2));

  assert(strcmp(key, "e") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 6);
  assert(value.type == 0x82);
  assert(value.vdouble - 25.987654321 < 0.00000001);

  assert(strcmp(key, "f") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 7);
  assert(value.type == 0x80061);
  assert(value.vbool == 1);

  assert(strcmp(key, "g") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 8);
  assert(value.type == 0x80061);
  assert(value.vbool == 0);

  assert(strcmp(key, "h") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 9);
  assert(value.type == 0x00);

  assert(strcmp(key, "i") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 10);
  assert(value.type == 0xA0);
  assert(strcmp((char *)value.ptr, "testing...") == 0);

  assert(strcmp(key, "j") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 11);
  assert(value.type == 0xC0);
  assert(memcmp(value.ptr, blob_ptr, blob_size) == 0);

  assert(strcmp(key, "k") == 0);

  assert(binn_object_next(&iter, key, &value) == 1);
  assert(iter.current == 12);
  assert(value.type == 0xE0);
  assert(value.size == list2size);
  assert(value.count == 4);
  assert(value.ptr != 0);
  assert(binn_list_int32(value.ptr, 1) == 250);
  assert(binn_list_null(value.ptr, 2) == 1);
  ptr = binn_list_str(value.ptr, 3);
  assert(ptr != 0);
  assert(strcmp((char *)ptr, "l1st2") == 0);
  assert(binn_list_bool(value.ptr, 4) == 1);

  assert(strcmp(key, "l") == 0);

  assert(binn_object_next(&iter, key, &value) == 0);



  assert(binn_object_next(&iter, key, &value) == 0);
# 2108 "/home/enumclass/Documents/C2RustTranslation/bkp/binn-3.0/test/test_binn2.c"
  ptr = binn_ptr(map);
  assert(ptr != 0);
  assert(binn_iter_init(&iter, ptr, 0xE1));
  assert(iter.pnext > ptr);
  assert(iter.plimit > ptr);
  assert(iter.count == 12);
  assert(iter.current == 0);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.pnext > ptr);
  assert(iter.plimit > ptr);
  assert(iter.count == 12);
  assert(iter.current == 1);
  assert(value.type == 0x21);
  assert(value.vint8 == 111);
  assert(id == 55010);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 2);
  if (use_int_compression) {
    assert(value.type == 0x60);
  } else {
    assert(value.type == 0x61);
  }
  assert(value.vint32 == 123456789);
  assert(id == 55020);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 3);
  if (use_int_compression) {
    assert(value.type == 0x21);
    assert(value.vint8 == -123);
  } else {
    assert(value.type == 0x41);
    assert(value.vint16 == -123);
  }
  assert(id == 55030);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 4);
  assert(value.type == 0x81);
  assert(value.vint64 == 9876543210);
  assert(id == 55040);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 5);
  assert(value.type == 0x62);
  assert(AlmostEqualFloats(value.vfloat, 1.25, 2));
  assert(id == 55050);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 6);
  assert(value.type == 0x82);
  assert(value.vdouble - 25.987654321 < 0.00000001);
  assert(id == 55060);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 7);
  assert(value.type == 0x80061);
  assert(value.vbool == 1);
  assert(id == 55070);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 8);
  assert(value.type == 0x80061);
  assert(value.vbool == 0);
  assert(id == 55080);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 9);
  assert(value.type == 0x00);
  assert(id == 55090);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 10);
  assert(value.type == 0xA0);
  assert(strcmp((char *)value.ptr, "testing...") == 0);
  assert(id == 55100);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 11);
  assert(value.type == 0xC0);
  assert(memcmp(value.ptr, blob_ptr, blob_size) == 0);
  assert(id == 55110);

  assert(binn_map_next(&iter, &id, &value) == 1);
  assert(iter.current == 12);
  assert(value.type == 0xE0);
  assert(value.size == list2size);
  assert(value.count == 4);
  assert(value.ptr != 0);
  assert(binn_list_int32(value.ptr, 1) == 250);
  assert(binn_list_null(value.ptr, 2) == 1);
  ptr = binn_list_str(value.ptr, 3);
  assert(ptr != 0);
  assert(strcmp((char *)ptr, "l1st2") == 0);
  assert(binn_list_bool(value.ptr, 4) == 1);
  assert(id == 55120);

  assert(binn_map_next(&iter, &id, &value) == 0);



  assert(binn_map_next(&iter, &id, &value) == 0);






  copy = binn_copy(list);
  assert(copy!=0);
  assert(binn_type(copy) == binn_type(list));
  assert(binn_count(copy) == binn_count(list));
  assert(binn_size(copy) == binn_size(list));
  assert(binn_iter_init(&iter, list, 0xE0));
  assert(binn_iter_init(&iter2, copy, 0xE0));
  while( binn_list_next(&iter, &value) ){
    assert(binn_list_next(&iter2, &value2) == 1);
    assert(value.type == value2.type);

  }
  assert(binn_list_add_str(copy, "testing...") == 1);
  assert(binn_type(copy) == binn_type(list));
  assert(binn_count(copy) == binn_count(list)+1);
  assert(binn_size(copy) > binn_size(list));
  binn_free(copy);

  copy = binn_copy(map);
  assert(copy!=0);
  assert(binn_type(copy) == binn_type(map));
  assert(binn_count(copy) == binn_count(map));
  assert(binn_size(copy) == binn_size(map));
  assert(binn_iter_init(&iter, map, 0xE1));
  assert(binn_iter_init(&iter2, copy, 0xE1));
  while( binn_map_next(&iter, &id, &value) ){
    assert(binn_map_next(&iter2, &id2, &value2) == 1);
    assert(id == id2);
    assert(value.type == value2.type);

  }
  assert(binn_map_set_int32(copy, 5600, 123) == 1);
  assert(binn_type(copy) == binn_type(map));
  assert(binn_count(copy) == binn_count(map)+1);
  assert(binn_size(copy) > binn_size(map));
  binn_free(copy);

  copy = binn_copy(obj);
  assert(copy!=0);
  assert(binn_type(copy) == binn_type(obj));
  assert(binn_count(copy) == binn_count(obj));
  assert(binn_size(copy) == binn_size(obj));
  assert(binn_iter_init(&iter, obj, 0xE2));
  assert(binn_iter_init(&iter2, copy, 0xE2));
  while( binn_object_next(&iter, key, &value) ){
    assert(binn_object_next(&iter2, key2, &value2) == 1);
    assert(strcmp(key,key2)==0);
    assert(value.type == value2.type);

  }
  assert(binn_object_set_int32(copy, "another", 123) == 1);
  assert(binn_type(copy) == binn_type(obj));
  assert(binn_count(copy) == binn_count(obj)+1);
  assert(binn_size(copy) > binn_size(obj));
  binn_free(copy);




  ptr = binn_ptr(list);
  copy = binn_copy(ptr);
  assert(copy!=0);
  assert(binn_type(copy) == binn_type(list));
  assert(binn_count(copy) == binn_count(list));
  assert(binn_size(copy) == binn_size(list));
  assert(binn_iter_init(&iter, ptr, 0xE0));
  assert(binn_iter_init(&iter2, copy, 0xE0));
  while( binn_list_next(&iter, &value) ){
    assert(binn_list_next(&iter2, &value2) == 1);
    assert(value.type == value2.type);

  }
  assert(binn_list_add_str(copy, "testing...") == 1);
  assert(binn_type(copy) == binn_type(list));
  assert(binn_count(copy) == binn_count(list)+1);
  assert(binn_size(copy) > binn_size(list));
  binn_free(copy);

  ptr = binn_ptr(map);
  copy = binn_copy(ptr);
  assert(copy!=0);
  assert(binn_type(copy) == binn_type(map));
  assert(binn_count(copy) == binn_count(map));
  assert(binn_size(copy) == binn_size(map));
  assert(binn_iter_init(&iter, ptr, 0xE1));
  assert(binn_iter_init(&iter2, copy, 0xE1));
  while( binn_map_next(&iter, &id, &value) ){
    assert(binn_map_next(&iter2, &id2, &value2) == 1);
    assert(id == id2);
    assert(value.type == value2.type);

  }
  assert(binn_map_set_int32(copy, 5600, 123) == 1);
  assert(binn_type(copy) == binn_type(map));
  assert(binn_count(copy) == binn_count(map)+1);
  assert(binn_size(copy) > binn_size(map));
  binn_free(copy);

  ptr = binn_ptr(obj);
  copy = binn_copy(ptr);
  assert(copy!=0);
  assert(binn_type(copy) == binn_type(obj));
  assert(binn_count(copy) == binn_count(obj));
  assert(binn_size(copy) == binn_size(obj));
  assert(binn_iter_init(&iter, ptr, 0xE2));
  assert(binn_iter_init(&iter2, copy, 0xE2));
  while( binn_object_next(&iter, key, &value) ){
    assert(binn_object_next(&iter2, key2, &value2) == 1);
    assert(strcmp(key,key2)==0);
    assert(value.type == value2.type);

  }
  assert(binn_object_set_int32(copy, "another", 123) == 1);
  assert(binn_type(copy) == binn_type(obj));
  assert(binn_count(copy) == binn_count(obj)+1);
  assert(binn_size(copy) > binn_size(obj));
  binn_free(copy);


  binn_free(list);
  binn_free(list2);
  binn_free(map);
  binn_free(obj);

  puts("OK");

}



void test_binn2() {
  char *obj1ptr, *obj2ptr;
  int obj1size, obj2size;

  test_virtual_types();

  test_int_conversion();
  test_binn_int_conversion();
  test_value_conversion();
  test_value_copy();

  init_udts();

  obj1ptr = test_create_object_1(&obj1size);
  obj2ptr = test_create_object_2(&obj2size);

  assert(obj1ptr != 0);
  assert(obj2ptr != 0);

  printf("obj1size=%d obj2size=%d\n", obj1size, obj2size);
  assert(obj1size == obj2size);

  test_binn_read(obj1ptr);

  test_binn_iter(0);

  test_binn_iter(1);

}
