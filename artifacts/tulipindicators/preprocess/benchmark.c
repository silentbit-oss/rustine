# 0 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
# 24 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/string.h" 1
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/string.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/string.h" 2
# 25 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 26 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 1
# 27 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/time.h" 1
# 28 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/assert.h" 1
# 29 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/ctype.h" 1
# 30 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/math.h" 1
# 31 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/utils/minmax.h" 1
# 32 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2

# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/indicators.h" 1
# 53 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/indicators.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/math.h" 1
# 54 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/indicators.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/assert.h" 1
# 55 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/indicators.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/string.h" 1
# 56 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/indicators.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 57 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/indicators.h" 2
# 65 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/indicators.h"
const char* ti_version(void);
long int ti_build(void);
int ti_indicator_count(void);
# 90 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/indicators.h"
typedef int (*ti_indicator_start_function)(double const *options);
typedef int (*ti_indicator_function)(int size, double const *const *inputs, double const *options, double *const *outputs);


struct ti_stream; typedef struct ti_stream ti_stream;
typedef int (*ti_indicator_stream_new)(double const *options, ti_stream **stream);
typedef int (*ti_indicator_stream_run)(ti_stream *stream, int size, double const *const *inputs, double *const *outputs);
typedef void (*ti_indicator_stream_free)(ti_stream *stream);


typedef struct ti_indicator_info {
    const char *name;
    const char *full_name;
    ti_indicator_start_function start;
    ti_indicator_function indicator;
    ti_indicator_function indicator_ref;
    int type, inputs, options, outputs;
    const char *input_names[16];
    const char *option_names[16];
    const char *output_names[16];
    ti_indicator_stream_new stream_new;
    ti_indicator_stream_run stream_run;
    ti_indicator_stream_free stream_free;
} ti_indicator_info;



extern ti_indicator_info ti_indicators[];



const ti_indicator_info *ti_find_indicator(const char *name);




int ti_stream_run(ti_stream *stream, int size, double const *const *inputs, double *const *outputs);
ti_indicator_info *ti_stream_get_info(ti_stream *stream);
int ti_stream_get_progress(ti_stream *stream);
void ti_stream_free(ti_stream *stream);
# 158 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/indicators.h"
int ti_abs_start(double const *options);
int ti_abs(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_acos_start(double const *options);
int ti_acos(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ad_start(double const *options);
int ti_ad(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_add_start(double const *options);
int ti_add(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_adosc_start(double const *options);
int ti_adosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_adx_start(double const *options);
int ti_adx(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_adxr_start(double const *options);
int ti_adxr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ao_start(double const *options);
int ti_ao(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_apo_start(double const *options);
int ti_apo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_aroon_start(double const *options);
int ti_aroon(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_aroonosc_start(double const *options);
int ti_aroonosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_asin_start(double const *options);
int ti_asin(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_atan_start(double const *options);
int ti_atan(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_atr_start(double const *options);
int ti_atr(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_atr_ref(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_atr_stream_new(double const *options, ti_stream **stream);
int ti_atr_stream_run(ti_stream *stream, int size, double const *const *inputs, double *const *outputs);
void ti_atr_stream_free(ti_stream *stream);







int ti_avgprice_start(double const *options);
int ti_avgprice(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_bbands_start(double const *options);
int ti_bbands(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_bop_start(double const *options);
int ti_bop(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cci_start(double const *options);
int ti_cci(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ceil_start(double const *options);
int ti_ceil(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cmo_start(double const *options);
int ti_cmo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cos_start(double const *options);
int ti_cos(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cosh_start(double const *options);
int ti_cosh(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_crossany_start(double const *options);
int ti_crossany(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_crossover_start(double const *options);
int ti_crossover(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cvi_start(double const *options);
int ti_cvi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_decay_start(double const *options);
int ti_decay(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_dema_start(double const *options);
int ti_dema(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_di_start(double const *options);
int ti_di(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_div_start(double const *options);
int ti_div(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_dm_start(double const *options);
int ti_dm(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_dpo_start(double const *options);
int ti_dpo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_dx_start(double const *options);
int ti_dx(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_edecay_start(double const *options);
int ti_edecay(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ema_start(double const *options);
int ti_ema(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_emv_start(double const *options);
int ti_emv(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_exp_start(double const *options);
int ti_exp(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_fisher_start(double const *options);
int ti_fisher(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_floor_start(double const *options);
int ti_floor(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_fosc_start(double const *options);
int ti_fosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_hma_start(double const *options);
int ti_hma(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_kama_start(double const *options);
int ti_kama(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_kvo_start(double const *options);
int ti_kvo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_lag_start(double const *options);
int ti_lag(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_linreg_start(double const *options);
int ti_linreg(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_linregintercept_start(double const *options);
int ti_linregintercept(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_linregslope_start(double const *options);
int ti_linregslope(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ln_start(double const *options);
int ti_ln(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_log10_start(double const *options);
int ti_log10(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_macd_start(double const *options);
int ti_macd(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_marketfi_start(double const *options);
int ti_marketfi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_mass_start(double const *options);
int ti_mass(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_max_start(double const *options);
int ti_max(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_max_ref(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_md_start(double const *options);
int ti_md(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_medprice_start(double const *options);
int ti_medprice(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_mfi_start(double const *options);
int ti_mfi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_min_start(double const *options);
int ti_min(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_min_ref(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_mom_start(double const *options);
int ti_mom(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_msw_start(double const *options);
int ti_msw(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_mul_start(double const *options);
int ti_mul(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_natr_start(double const *options);
int ti_natr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_nvi_start(double const *options);
int ti_nvi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_obv_start(double const *options);
int ti_obv(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ppo_start(double const *options);
int ti_ppo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_psar_start(double const *options);
int ti_psar(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_pvi_start(double const *options);
int ti_pvi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_qstick_start(double const *options);
int ti_qstick(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_roc_start(double const *options);
int ti_roc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_rocr_start(double const *options);
int ti_rocr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_round_start(double const *options);
int ti_round(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_rsi_start(double const *options);
int ti_rsi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sin_start(double const *options);
int ti_sin(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sinh_start(double const *options);
int ti_sinh(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sma_start(double const *options);
int ti_sma(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_sma_stream_new(double const *options, ti_stream **stream);
int ti_sma_stream_run(ti_stream *stream, int size, double const *const *inputs, double *const *outputs);
void ti_sma_stream_free(ti_stream *stream);







int ti_sqrt_start(double const *options);
int ti_sqrt(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_stddev_start(double const *options);
int ti_stddev(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_stderr_start(double const *options);
int ti_stderr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_stoch_start(double const *options);
int ti_stoch(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_stochrsi_start(double const *options);
int ti_stochrsi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sub_start(double const *options);
int ti_sub(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sum_start(double const *options);
int ti_sum(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tan_start(double const *options);
int ti_tan(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tanh_start(double const *options);
int ti_tanh(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tema_start(double const *options);
int ti_tema(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_todeg_start(double const *options);
int ti_todeg(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_torad_start(double const *options);
int ti_torad(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tr_start(double const *options);
int ti_tr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_trima_start(double const *options);
int ti_trima(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_trix_start(double const *options);
int ti_trix(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_trunc_start(double const *options);
int ti_trunc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tsf_start(double const *options);
int ti_tsf(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_typprice_start(double const *options);
int ti_typprice(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ultosc_start(double const *options);
int ti_ultosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_var_start(double const *options);
int ti_var(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_vhf_start(double const *options);
int ti_vhf(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_vidya_start(double const *options);
int ti_vidya(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_volatility_start(double const *options);
int ti_volatility(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_vosc_start(double const *options);
int ti_vosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_vwma_start(double const *options);
int ti_vwma(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_wad_start(double const *options);
int ti_wad(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_wcprice_start(double const *options);
int ti_wcprice(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_wilders_start(double const *options);
int ti_wilders(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_willr_start(double const *options);
int ti_willr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_wma_start(double const *options);
int ti_wma(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_zlema_start(double const *options);
int ti_zlema(int size, double const *const *inputs, double const *options, double *const *outputs);
# 34 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/candles.h" 1
# 53 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/candles.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdint.h" 1
# 54 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/candles.h" 2
# 62 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/candles.h"
const char* tc_version(void);
long int tc_build(void);
int tc_candle_count(void);





typedef double TC_REAL;
typedef struct tc_result tc_result;

typedef uint64_t tc_set;
# 119 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/candles.h"
typedef struct tc_config {
    int period;

    TC_REAL body_none;
    TC_REAL body_short;
    TC_REAL body_long;

    TC_REAL wick_none;
    TC_REAL wick_long;

    TC_REAL near;

} tc_config;



typedef struct tc_hit {
    int index;
    tc_set patterns;
} tc_hit;



typedef int (*tc_candle_function)(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);



typedef struct tc_candle_info {
    const char *name;
    const char *full_name;
    tc_set pattern;
    tc_candle_function candle;
} tc_candle_info;



extern tc_candle_info tc_candles[];


const tc_candle_info *tc_find_candle(const char *name);


const tc_candle_info *tc_get_info(tc_set pattern);


tc_config const *tc_config_default();
void tc_config_set_to_default(tc_config *config);


tc_result *tc_result_new();
void tc_result_free(tc_result *result);
int tc_result_count(const tc_result *result);
int tc_result_pattern_count(const tc_result *result);

tc_hit tc_result_get(const tc_result *result, int index);
tc_set tc_result_at(const tc_result *result, int index);




int tc_run(tc_set patterns, int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
# 199 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/candles.h"
int tc_abandoned_baby_bear(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_abandoned_baby_bull(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_big_black_candle(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_big_white_candle(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_black_marubozu(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_dragonfly_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_engulfing_bear(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_engulfing_bull(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_evening_doji_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_evening_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_four_price_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_gravestone_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_hammer(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_hanging_man(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_inverted_hammer(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_long_legged_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_marubozu(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_morning_doji_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_morning_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_shooting_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_spinning_top(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_three_black_crows(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_three_white_soldiers(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_white_marubozu(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
# 35 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2
# 54 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
int bestof = 1;

int fails = 0;




double in[5][4000];
double out[3][4000];
double outref[3][4000];
double outstream1[3][4000];
double outstreamall[3][4000];
tc_result *outcnd = 0;
int ind_offset;
# 77 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
void generate_inputs() {
    double *open = in[0];
    double *high = in[1];
    double *low = in[2];
    double *close = in[3];
    double *volume = in[4];

    open[0] = 100;

    srand(22);

    int i;
    for (i = 0; i < 4000; ++i) {

        const double diff1 = (((double)(rand()) / 32767 - .5) + .01) * 2.5;
        const double diff2 = (((double)(rand()) / 32767 - .5) + .01) * 2.5;
        const double diff3 = (((double)(rand()) / 32767)) * 0.5;
        const double diff4 = (((double)(rand()) / 32767)) * 0.5;
        const double vol = (((double)(rand()) / 32767)) * 10000 + 500;

        if (i) {
            open[i] = open[i-1] + diff1;
        }

        close[i] = open[i] + diff2;
        high[i] = open[i] > close[i] ? open[i] + diff3 : close[i] + diff3;
        low[i] = open[i] < close[i] ? open[i] - diff4 : close[i] - diff4;
        volume[i] = vol;




        assert(open[i] <= high[i]);
        assert(close[i] <= high[i]);

        assert(open[i] >= low[i]);
        assert(close[i] >= low[i]);

        assert(high[i] >= low[i]);
        assert(high[i] >= open[i]);
        assert(high[i] >= close[i]);

        assert(low[i] <= low[i]);
        assert(low[i] <= open[i]);
        assert(low[i] <= close[i]);
    }



    volume[0] = 0;
}
# 138 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
typedef int (*run_fun)(const ti_indicator_info *info, double *options, int goal);
# 351 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
void ti_setup(const ti_indicator_info *info, double **inputs) {

    int j;
    for (j = 0; j < info->inputs; ++j) {
        if (strcmp(info->input_names[j], "open") == 0) {
            inputs[j] = in[0];
        } else if (strcmp(info->input_names[j], "high") == 0) {
            inputs[j] = in[1];
        } else if (strcmp(info->input_names[j], "low") == 0) {
            inputs[j] = in[2];
        } else if (strcmp(info->input_names[j], "close") == 0) {
            inputs[j] = in[3];
        } else if (strcmp(info->input_names[j], "real") == 0) {
            inputs[j] = in[3];
        } else if (strcmp(info->input_names[j], "volume") == 0) {
            inputs[j] = in[4];
        } else {
            assert(0);
        };
    }
}


int run_ti(const ti_indicator_info *info, double *options, int goal) {
    static double *inputs[] = {0, 0, 0, 0, 0};
    static double *outputs[] = {out[0], out[1], out[2], out[3], out[4]};

    if (goal == 0) {

        ind_offset = info->start(options);


        const int ret = info->indicator(4000, (double const *const *)inputs, options, outputs);
        if (ret != 0) {
            printf("   *ERROR* (%d)\n", ret);
            printf("options:\n");
            int i;
            for (i = 0; i < info->options; ++i) {
                printf("%d = %f\n", i, options[i]);
            }
            return 1;
        }

    } else if (goal == 1) {

        ti_setup(info, inputs);

    } else if (goal == 2) {
    } else {
        assert(0);
    }

    return 0;
}


int run_ti_ref(const ti_indicator_info *info, double *options, int goal) {
    static double *inputs[] = {0, 0, 0, 0, 0};
    static double *outputs[] = {outref[0], outref[1], outref[2], outref[3], outref[4]};

    if (goal == 0) {

        ind_offset = info->start(options);


        const int ret = info->indicator_ref(4000, (double const *const *)inputs, options, outputs);
        if (ret != 0) {
            printf("   *ERROR* (%d)\n", ret);
            printf("options:\n");
            int i;
            for (i = 0; i < info->options; ++i) {
                printf("%d = %f\n", i, options[i]);
            }
            return 1;
        }

    } else if (goal == 1) {

        ti_setup(info, inputs);

    } else if (goal == 2) {
    } else {
        assert(0);
    }

    return 0;
}


int run_ti_stream1(const ti_indicator_info *info, double *options, int goal) {
    static double *inputs[] = {0, 0, 0, 0, 0};
    static double *outputs[] = {outstream1[0], outstream1[1], outstream1[2], outstream1[3], outstream1[4]};

    if (goal == 0) {

        ind_offset = info->start(options);


        double *ins[5] = {0};
        double *outs[5] = {0};


        ti_stream *stream;
        const int sret = info->stream_new(options, &stream);
        assert(stream);
        assert(sret == 0);

        for (int i = 0; i < 4000; ++i) {

            for (unsigned int j = 0; j < (sizeof(inputs)/sizeof(double*)); ++j) {
                ins[j] = inputs[j] + i;
            }

            int k = ti_stream_get_progress(stream);
            if (k < 0) k = 0;
            for (unsigned int j = 0; j < (sizeof(outputs)/sizeof(double*)); ++j) {
                outs[j] = outstream1[j] + k;
            }

            const int ret = info->stream_run(stream, 1, (double const *const *)ins, outs);

            if (ret != 0) {
                printf("   *ERROR* (%d)\n", ret);
                printf("options:\n");
                for (int j = 0; j < info->options; ++j) {
                    printf("%d = %f\n", j, options[j]);
                }
                return 1;
            }


        }

        info->stream_free(stream);


    } else if (goal == 1) {

        ti_setup(info, inputs);

    } else if (goal == 2) {
    } else {
        assert(0);
    }

    return 0;
}


int run_ti_streamall(const ti_indicator_info *info, double *options, int goal) {
    static double *inputs[] = {0, 0, 0, 0, 0};
    static double *outputs[] = {outstreamall[0], outstreamall[1], outstreamall[2], outstreamall[3], outstreamall[4]};

    if (goal == 0) {

        ind_offset = info->start(options);


        ti_stream *stream;
        const int sret = info->stream_new(options, &stream);
        assert(stream);
        assert(sret == 0);

        const int ret = info->stream_run(stream, 4000, (double const *const *)inputs, outputs);
        info->stream_free(stream);

        if (ret != 0) {
            printf("   *ERROR* (%d)\n", ret);
            printf("options:\n");
            int i;
            for (i = 0; i < info->options; ++i) {
                printf("%d = %f\n", i, options[i]);
            }
            return 1;
        }


    } else if (goal == 1) {

        ti_setup(info, inputs);

    } else if (goal == 2) {
    } else {
        assert(0);
    }

    return 0;
}







void simple_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
}

void fast_slow_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = period + 10;
}

void alma_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 0.5;
    options[2] = 1;
}

void bbands_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 1.0;






}

void ce_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 3;
}

void copp_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = 11;
    options[1] = 14;
    options[2] = period;
}

void kc_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 0.77;
}

void kst_option_setter(double period, double *options, int ti) {
    (void)ti;
    for (int i = 0; i < 4; ++i) {
        options[i+4] = options[i] = period + period / 4. * i;
    }
}

void macd_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = period + 10;

    options[2] = period + 1;
}

void mama_option_setter(double period, double *options, int ti) {
    (void)ti;

    (void)period;
    options[0] = 0.5;
    options[1] = 0.05;
}

void pfe_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 5;
}

void posc_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 3;
}

void ppo_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = period + 10;






}

void psar_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = 1/period;
    options[1] = options[0] * 10;
}

void rmi_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 3;
}

void rmta_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 1 - (2. / (period + 1));
}

void rvi_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 10;
}

void smi_option_setter(double period, double* options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 25;
    options[2] = 3;
}

void stoch_option_setter(double period, double *options, int ti) {


    if (ti) {
        options[0] = period;
        options[1] = 3;
        options[2] = 4;
    } else {







    }
}

void stochrsi_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = period;
    options[2] = period;
    options[3] = 1;
}

void tsi_option_setter(double period, double* options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 3;
}

void ultosc_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = period * 2;
    options[2] = period * 4;
}

void vidya_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = period + 10;
    options[2] = .2;
}
# 727 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
double stochrsi_output_adjust(double a) {

    return a * 0.01;
}







void check_outputs(const ti_indicator_info *info, const char* what, double compare[3][4000]) {


    int remap[] = {0,1,2,3,4};

    int nanok = 0;
    if (strcmp(info->name, "asin") == 0) nanok = 1;
    if (strcmp(info->name, "acos") == 0) nanok = 1;
# 761 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
    int i, j;
# 770 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
    for (j = 0; j < info->outputs; ++j) {
        int end = 4000 - ind_offset;



        if (remap[j] == -1) continue;


        for (i = 0; i < end; ++i) {
            double a = out[j][4000 -1-i-ind_offset];
            double b = compare[j][4000 -1-i-ind_offset];
# 790 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
            double diff = fabs(a-b);
            if (diff > 0.0001 || (!nanok && diff != diff)) {
                ++fails;
                printf("Results disagree.\n");
                printf("    series         (diff)   ti   %s\n", what);
                printf("    series %d, %4d (%f) %.5f %.5f\n", j, i, diff, a, b);
                break;
            }
        }
    }
}




void bench_run(FILE *log, const ti_indicator_info *info, const void *run_info, run_fun fun, const char *name) {



    double options[] = {1,1,1,1,1,1,1,1,1,1};




    void (*options_setter)(double period, double *options, int ti) = 0;


    if (strcmp(info->name, "alma") == 0) { options_setter = alma_option_setter; }
    if (strcmp(info->name, "adosc") == 0) { options_setter = fast_slow_option_setter; }
    if (strcmp(info->name, "apo") == 0) { options_setter = ppo_option_setter; }
    if (strcmp(info->name, "bbands") == 0) { options_setter = bbands_option_setter; }
    if (strcmp(info->name, "copp") == 0) { options_setter = copp_option_setter; }
    if (strcmp(info->name, "kc") == 0) { options_setter = kc_option_setter; }
    if (strcmp(info->name, "kst") == 0) { options_setter = kst_option_setter; }
    if (strcmp(info->name, "kvo") == 0) { options_setter = fast_slow_option_setter; }
    if (strcmp(info->name, "macd") == 0) { options_setter = macd_option_setter; }
    if (strcmp(info->name, "mama") == 0) { options_setter = mama_option_setter; }
    if (strcmp(info->name, "pfe") == 0) { options_setter = pfe_option_setter; }
    if (strcmp(info->name, "posc") == 0) { options_setter = posc_option_setter; }
    if (strcmp(info->name, "ppo") == 0) { options_setter = ppo_option_setter; }
    if (strcmp(info->name, "psar") == 0) { options_setter = psar_option_setter; }
    if (strcmp(info->name, "rvi") == 0) { options_setter = rvi_option_setter; }
    if (strcmp(info->name, "rmi") == 0) { options_setter = rmi_option_setter; }
    if (strcmp(info->name, "rmta") == 0) { options_setter = rmta_option_setter; }
    if (strcmp(info->name, "smi") == 0) { options_setter = smi_option_setter; }
    if (strcmp(info->name, "stoch") == 0) { options_setter = stoch_option_setter; }
    if (strcmp(info->name, "stochrsi") == 0) { options_setter = stochrsi_option_setter; }
    if (strcmp(info->name, "ultosc") == 0) { options_setter = ultosc_option_setter; }
    if (strcmp(info->name, "vidya") == 0) { options_setter = vidya_option_setter; }
    if (strcmp(info->name, "vosc") == 0) { options_setter = fast_slow_option_setter; }


    int best_e = 1e9, best_p = -1e9;
    int best;
    for (best = 0; best < bestof; ++best) {
        printf("Benchmark %25s-%-16s ", info->name, name);
        int i, period;
        int iterations = 0;
        const clock_t start = clock();

        fun(run_info, 0, 1);

        for (i = 0; i < 1; ++i) {
            for (period = 4; period <= 150; ++period) {
                if (options_setter)
                    options_setter(period, options, info == run_info);
                else
                    options[0] = period;

                const int ret = fun(run_info, options, 0);
                if (ret) {
                    return;
                }
                ++iterations;
            }
        }

        fun(run_info, 0, 2);

        const int elapsed = (clock() - start) * 1000 / CLOCKS_PER_SEC;
        const int performance = elapsed == 0 ? 0 : (iterations * 4000) / elapsed / 1000;


        if (elapsed)
            printf("\t%5dms\t%5dmfps\n", elapsed, performance);
        else
            printf("\n");

        best_e = ((elapsed)<(best_e)?(elapsed):(best_e));
        best_p = ((performance)>(best_p)?(performance):(best_p));
    }

    if (log) fprintf(log, ",\n    \"%s\" => array(\"elapsed\" => %d, \"performance\" => %d)", name, best_e, best_p);
}



void bench_indicator(FILE *log, const ti_indicator_info *info) {



    {
        int i;
        for (i = 0; i < 3; ++i) {
            memset(out[i], 0xF1, sizeof(out[i]));
            memset(outref[i], 0xF2, sizeof(outref[i]));
            memset(outstream1[i], 0xF3, sizeof(outstream1[i]));
            memset(outstreamall[i], 0xF4, sizeof(outstreamall[i]));



        }
    }
# 911 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
    if (info) {
        if (log) fprintf(log, ",\n  \"%s\" => array(\n", info->name);
        if (log) fprintf(log, "    \"name\" => \"%s\"", info->full_name);

        bench_run(log, info, info, run_ti, "ti");
    }

    if (info && info->indicator_ref) {
        bench_run(log, info, info, run_ti_ref, "ti_ref");
        check_outputs(info, "ref", outref);
    }

    if (info && info->stream_new) {
        bench_run(log, info, info, run_ti_stream1, "ti_stream1");
        check_outputs(info, "stream1", outstream1);

        bench_run(log, info, info, run_ti_streamall, "ti_streamall");
        check_outputs(info, "streamall", outstreamall);
    }
# 950 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
    if (log) fprintf(log, "\n  )");
    printf("\n");
}


void bench_run_candle(FILE *log, const tc_candle_info *info) {

    const char* name = "ti";
    tc_set pattern = info->pattern;

    int best_e = 1e9, best_p = -1e9;
    int best;
    for (best = 0; best < bestof; ++best) {
        printf("Benchmark %25s-%-16s ", info->name, name);
        int i, period;
        int iterations = 0;
        const clock_t start = clock();

        const double *inputs[4] = {in[0], in[1], in[2], in[3]};
        tc_config config;
        tc_config_set_to_default(&config);


        for (i = 0; i < 1; ++i) {
            for (period = 4; period <= 150; ++period) {

                const int ret = tc_run(pattern, 4000, inputs, &config, outcnd);
                if (ret) {
                    return;
                }
                ++iterations;
            }
        }


        const int elapsed = (clock() - start) * 1000 / CLOCKS_PER_SEC;
        const int performance = elapsed == 0 ? 0 : (iterations * 4000) / elapsed / 1000;


        if (elapsed)
            printf("\t%5dms\t%5dmfps\n", elapsed, performance);
        else
            printf("\n");

        best_e = ((elapsed)<(best_e)?(elapsed):(best_e));
        best_p = ((performance)>(best_p)?(performance):(best_p));
    }

    if (log) fprintf(log, ",\n    \"%s\" => array(\"elapsed\" => %d, \"performance\" => %d)", name, best_e, best_p);


}
# 1050 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
void bench_candle(FILE *log, const tc_candle_info *info) {

    outcnd = tc_result_new();
    assert(outcnd);

    if (info) {
        if (log) fprintf(log, ",\n  \"%s\" => array(\n", info->name);
        if (log) fprintf(log, "    \"name\" => \"%s\"", info->full_name);

        bench_run_candle(log, info);
# 1111 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
    tc_result_free(outcnd);

    }





    if (log) fprintf(log, "\n  )");
    printf("\n");
}



int main(int argc, char **argv) {
    printf("Tulip Charts Indicator benchmark.\n");
    printf("Using real size of: %d.\n\n", sizeof(double));

    generate_inputs();





    const ti_indicator_info *ind_info = ti_indicators;
    const tc_candle_info *cnd_info = tc_candles;

    const int candles_only = argc > 1 && !strcmp(argv[1], "tc");

    if (argc > 1 && !isdigit(argv[1][0]) && !candles_only) {


        if (argc > 2) {
            bestof = atoi(argv[2]);
            if (!bestof) bestof = 1;
        }

        ind_info = ti_find_indicator(argv[1]);
        if (ind_info) bench_indicator(0, ind_info);

        cnd_info = tc_find_candle(argv[1]);
        if (cnd_info) bench_candle(0, cnd_info);

    } else {

        if (argc > 1 && isdigit(argv[1][0])) {
            bestof = atoi(argv[1]);
        }

        FILE *log = fopen("docs/benchmark.php", "w");
        if (!log) {
            printf("Couldn't open results file for output. Make sure ./docs/ exists.\n");
            exit(1);
        }

        fprintf(log, "<?php\n");
        fprintf(log, "#GENERATED BY benchmark.c\n");
        fprintf(log, "#DO NOT MODIFY DIRECTLY\n");
        fprintf(log, "$benchmark = array(\n");
        fprintf(log, "  \"worksize\" => %d,", 1 * (150 -4 +1) * 4000);
        fprintf(log, "  \"bestof\" => %d", bestof);

        if (!candles_only) {

            do {

                if (strcmp(ind_info->name, "msw") == 0) continue;

                bench_indicator(log, ind_info);
            } while ((++ind_info)->name);
        }

        do {
            bench_candle(log, cnd_info);
        } while ((++cnd_info)->name);

        const tc_candle_info cnd_all = {.name = "all", .full_name = "All Candle Patterns", .pattern = ((1L<<26)-1)};
        bench_candle(log, &cnd_all);

        fprintf(log, ");");

        fclose(log);
    }
# 1203 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
    if (!fails) {
        printf("All comparisons passed.\n");
    } else {
        printf("%d comparisons failed.\n", fails);
    }


    return 0;
}
# 0 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
# 24 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/string.h" 1
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/string.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/string.h" 2
# 25 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 26 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 1
# 27 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/time.h" 1
# 28 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/assert.h" 1
# 29 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/ctype.h" 1
# 30 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/math.h" 1
# 31 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/utils/minmax.h" 1
# 32 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2

# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/indicators.h" 1
# 53 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/indicators.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/math.h" 1
# 54 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/indicators.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/assert.h" 1
# 55 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/indicators.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/string.h" 1
# 56 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/indicators.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 57 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/indicators.h" 2
# 65 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/indicators.h"
const char* ti_version(void);
long int ti_build(void);
int ti_indicator_count(void);
# 90 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/indicators.h"
typedef int (*ti_indicator_start_function)(double const *options);
typedef int (*ti_indicator_function)(int size, double const *const *inputs, double const *options, double *const *outputs);


struct ti_stream; typedef struct ti_stream ti_stream;
typedef int (*ti_indicator_stream_new)(double const *options, ti_stream **stream);
typedef int (*ti_indicator_stream_run)(ti_stream *stream, int size, double const *const *inputs, double *const *outputs);
typedef void (*ti_indicator_stream_free)(ti_stream *stream);


typedef struct ti_indicator_info {
    const char *name;
    const char *full_name;
    ti_indicator_start_function start;
    ti_indicator_function indicator;
    ti_indicator_function indicator_ref;
    int type, inputs, options, outputs;
    const char *input_names[16];
    const char *option_names[16];
    const char *output_names[16];
    ti_indicator_stream_new stream_new;
    ti_indicator_stream_run stream_run;
    ti_indicator_stream_free stream_free;
} ti_indicator_info;



extern ti_indicator_info ti_indicators[];



const ti_indicator_info *ti_find_indicator(const char *name);




int ti_stream_run(ti_stream *stream, int size, double const *const *inputs, double *const *outputs);
ti_indicator_info *ti_stream_get_info(ti_stream *stream);
int ti_stream_get_progress(ti_stream *stream);
void ti_stream_free(ti_stream *stream);
# 158 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/indicators.h"
int ti_abs_start(double const *options);
int ti_abs(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_acos_start(double const *options);
int ti_acos(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ad_start(double const *options);
int ti_ad(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_add_start(double const *options);
int ti_add(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_adosc_start(double const *options);
int ti_adosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_adx_start(double const *options);
int ti_adx(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_adxr_start(double const *options);
int ti_adxr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ao_start(double const *options);
int ti_ao(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_apo_start(double const *options);
int ti_apo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_aroon_start(double const *options);
int ti_aroon(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_aroonosc_start(double const *options);
int ti_aroonosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_asin_start(double const *options);
int ti_asin(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_atan_start(double const *options);
int ti_atan(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_atr_start(double const *options);
int ti_atr(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_atr_ref(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_atr_stream_new(double const *options, ti_stream **stream);
int ti_atr_stream_run(ti_stream *stream, int size, double const *const *inputs, double *const *outputs);
void ti_atr_stream_free(ti_stream *stream);







int ti_avgprice_start(double const *options);
int ti_avgprice(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_bbands_start(double const *options);
int ti_bbands(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_bop_start(double const *options);
int ti_bop(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cci_start(double const *options);
int ti_cci(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ceil_start(double const *options);
int ti_ceil(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cmo_start(double const *options);
int ti_cmo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cos_start(double const *options);
int ti_cos(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cosh_start(double const *options);
int ti_cosh(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_crossany_start(double const *options);
int ti_crossany(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_crossover_start(double const *options);
int ti_crossover(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cvi_start(double const *options);
int ti_cvi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_decay_start(double const *options);
int ti_decay(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_dema_start(double const *options);
int ti_dema(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_di_start(double const *options);
int ti_di(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_div_start(double const *options);
int ti_div(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_dm_start(double const *options);
int ti_dm(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_dpo_start(double const *options);
int ti_dpo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_dx_start(double const *options);
int ti_dx(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_edecay_start(double const *options);
int ti_edecay(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ema_start(double const *options);
int ti_ema(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_emv_start(double const *options);
int ti_emv(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_exp_start(double const *options);
int ti_exp(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_fisher_start(double const *options);
int ti_fisher(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_floor_start(double const *options);
int ti_floor(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_fosc_start(double const *options);
int ti_fosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_hma_start(double const *options);
int ti_hma(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_kama_start(double const *options);
int ti_kama(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_kvo_start(double const *options);
int ti_kvo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_lag_start(double const *options);
int ti_lag(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_linreg_start(double const *options);
int ti_linreg(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_linregintercept_start(double const *options);
int ti_linregintercept(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_linregslope_start(double const *options);
int ti_linregslope(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ln_start(double const *options);
int ti_ln(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_log10_start(double const *options);
int ti_log10(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_macd_start(double const *options);
int ti_macd(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_marketfi_start(double const *options);
int ti_marketfi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_mass_start(double const *options);
int ti_mass(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_max_start(double const *options);
int ti_max(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_max_ref(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_md_start(double const *options);
int ti_md(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_medprice_start(double const *options);
int ti_medprice(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_mfi_start(double const *options);
int ti_mfi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_min_start(double const *options);
int ti_min(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_min_ref(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_mom_start(double const *options);
int ti_mom(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_msw_start(double const *options);
int ti_msw(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_mul_start(double const *options);
int ti_mul(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_natr_start(double const *options);
int ti_natr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_nvi_start(double const *options);
int ti_nvi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_obv_start(double const *options);
int ti_obv(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ppo_start(double const *options);
int ti_ppo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_psar_start(double const *options);
int ti_psar(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_pvi_start(double const *options);
int ti_pvi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_qstick_start(double const *options);
int ti_qstick(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_roc_start(double const *options);
int ti_roc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_rocr_start(double const *options);
int ti_rocr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_round_start(double const *options);
int ti_round(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_rsi_start(double const *options);
int ti_rsi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sin_start(double const *options);
int ti_sin(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sinh_start(double const *options);
int ti_sinh(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sma_start(double const *options);
int ti_sma(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_sma_stream_new(double const *options, ti_stream **stream);
int ti_sma_stream_run(ti_stream *stream, int size, double const *const *inputs, double *const *outputs);
void ti_sma_stream_free(ti_stream *stream);







int ti_sqrt_start(double const *options);
int ti_sqrt(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_stddev_start(double const *options);
int ti_stddev(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_stderr_start(double const *options);
int ti_stderr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_stoch_start(double const *options);
int ti_stoch(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_stochrsi_start(double const *options);
int ti_stochrsi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sub_start(double const *options);
int ti_sub(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sum_start(double const *options);
int ti_sum(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tan_start(double const *options);
int ti_tan(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tanh_start(double const *options);
int ti_tanh(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tema_start(double const *options);
int ti_tema(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_todeg_start(double const *options);
int ti_todeg(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_torad_start(double const *options);
int ti_torad(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tr_start(double const *options);
int ti_tr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_trima_start(double const *options);
int ti_trima(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_trix_start(double const *options);
int ti_trix(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_trunc_start(double const *options);
int ti_trunc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tsf_start(double const *options);
int ti_tsf(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_typprice_start(double const *options);
int ti_typprice(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ultosc_start(double const *options);
int ti_ultosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_var_start(double const *options);
int ti_var(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_vhf_start(double const *options);
int ti_vhf(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_vidya_start(double const *options);
int ti_vidya(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_volatility_start(double const *options);
int ti_volatility(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_vosc_start(double const *options);
int ti_vosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_vwma_start(double const *options);
int ti_vwma(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_wad_start(double const *options);
int ti_wad(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_wcprice_start(double const *options);
int ti_wcprice(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_wilders_start(double const *options);
int ti_wilders(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_willr_start(double const *options);
int ti_willr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_wma_start(double const *options);
int ti_wma(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_zlema_start(double const *options);
int ti_zlema(int size, double const *const *inputs, double const *options, double *const *outputs);
# 34 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/candles.h" 1
# 53 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/candles.h"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdint.h" 1
# 54 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/candles.h" 2
# 62 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/candles.h"
const char* tc_version(void);
long int tc_build(void);
int tc_candle_count(void);





typedef double TC_REAL;
typedef struct tc_result tc_result;

typedef uint64_t tc_set;
# 119 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/candles.h"
typedef struct tc_config {
    int period;

    TC_REAL body_none;
    TC_REAL body_short;
    TC_REAL body_long;

    TC_REAL wick_none;
    TC_REAL wick_long;

    TC_REAL near;

} tc_config;



typedef struct tc_hit {
    int index;
    tc_set patterns;
} tc_hit;



typedef int (*tc_candle_function)(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);



typedef struct tc_candle_info {
    const char *name;
    const char *full_name;
    tc_set pattern;
    tc_candle_function candle;
} tc_candle_info;



extern tc_candle_info tc_candles[];


const tc_candle_info *tc_find_candle(const char *name);


const tc_candle_info *tc_get_info(tc_set pattern);


tc_config const *tc_config_default();
void tc_config_set_to_default(tc_config *config);


tc_result *tc_result_new();
void tc_result_free(tc_result *result);
int tc_result_count(const tc_result *result);
int tc_result_pattern_count(const tc_result *result);

tc_hit tc_result_get(const tc_result *result, int index);
tc_set tc_result_at(const tc_result *result, int index);




int tc_run(tc_set patterns, int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
# 199 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/candles.h"
int tc_abandoned_baby_bear(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_abandoned_baby_bull(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_big_black_candle(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_big_white_candle(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_black_marubozu(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_dragonfly_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_engulfing_bear(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_engulfing_bull(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_evening_doji_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_evening_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_four_price_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_gravestone_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_hammer(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_hanging_man(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_inverted_hammer(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_long_legged_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_marubozu(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_morning_doji_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_morning_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_shooting_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_spinning_top(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_three_black_crows(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_three_white_soldiers(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_white_marubozu(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
# 35 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c" 2
# 54 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
int bestof = 1;

int fails = 0;




double in[5][4000];
double out[3][4000];
double outref[3][4000];
double outstream1[3][4000];
double outstreamall[3][4000];
tc_result *outcnd = 0;
int ind_offset;
# 77 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
void generate_inputs() {
    double *open = in[0];
    double *high = in[1];
    double *low = in[2];
    double *close = in[3];
    double *volume = in[4];

    open[0] = 100;

    srand(22);

    int i;
    for (i = 0; i < 4000; ++i) {

        const double diff1 = (((double)(rand()) / 32767 - .5) + .01) * 2.5;
        const double diff2 = (((double)(rand()) / 32767 - .5) + .01) * 2.5;
        const double diff3 = (((double)(rand()) / 32767)) * 0.5;
        const double diff4 = (((double)(rand()) / 32767)) * 0.5;
        const double vol = (((double)(rand()) / 32767)) * 10000 + 500;

        if (i) {
            open[i] = open[i-1] + diff1;
        }

        close[i] = open[i] + diff2;
        high[i] = open[i] > close[i] ? open[i] + diff3 : close[i] + diff3;
        low[i] = open[i] < close[i] ? open[i] - diff4 : close[i] - diff4;
        volume[i] = vol;




        assert(open[i] <= high[i]);
        assert(close[i] <= high[i]);

        assert(open[i] >= low[i]);
        assert(close[i] >= low[i]);

        assert(high[i] >= low[i]);
        assert(high[i] >= open[i]);
        assert(high[i] >= close[i]);

        assert(low[i] <= low[i]);
        assert(low[i] <= open[i]);
        assert(low[i] <= close[i]);
    }



    volume[0] = 0;
}
# 138 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
typedef int (*run_fun)(const ti_indicator_info *info, double *options, int goal);
# 351 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
void ti_setup(const ti_indicator_info *info, double **inputs) {

    int j;
    for (j = 0; j < info->inputs; ++j) {
        if (strcmp(info->input_names[j], "open") == 0) {
            inputs[j] = in[0];
        } else if (strcmp(info->input_names[j], "high") == 0) {
            inputs[j] = in[1];
        } else if (strcmp(info->input_names[j], "low") == 0) {
            inputs[j] = in[2];
        } else if (strcmp(info->input_names[j], "close") == 0) {
            inputs[j] = in[3];
        } else if (strcmp(info->input_names[j], "real") == 0) {
            inputs[j] = in[3];
        } else if (strcmp(info->input_names[j], "volume") == 0) {
            inputs[j] = in[4];
        } else {
            assert(0);
        };
    }
}


int run_ti(const ti_indicator_info *info, double *options, int goal) {
    static double *inputs[] = {0, 0, 0, 0, 0};
    static double *outputs[] = {out[0], out[1], out[2], out[3], out[4]};

    if (goal == 0) {

        ind_offset = info->start(options);


        const int ret = info->indicator(4000, (double const *const *)inputs, options, outputs);
        if (ret != 0) {
            printf("   *ERROR* (%d)\n", ret);
            printf("options:\n");
            int i;
            for (i = 0; i < info->options; ++i) {
                printf("%d = %f\n", i, options[i]);
            }
            return 1;
        }

    } else if (goal == 1) {

        ti_setup(info, inputs);

    } else if (goal == 2) {
    } else {
        assert(0);
    }

    return 0;
}


int run_ti_ref(const ti_indicator_info *info, double *options, int goal) {
    static double *inputs[] = {0, 0, 0, 0, 0};
    static double *outputs[] = {outref[0], outref[1], outref[2], outref[3], outref[4]};

    if (goal == 0) {

        ind_offset = info->start(options);


        const int ret = info->indicator_ref(4000, (double const *const *)inputs, options, outputs);
        if (ret != 0) {
            printf("   *ERROR* (%d)\n", ret);
            printf("options:\n");
            int i;
            for (i = 0; i < info->options; ++i) {
                printf("%d = %f\n", i, options[i]);
            }
            return 1;
        }

    } else if (goal == 1) {

        ti_setup(info, inputs);

    } else if (goal == 2) {
    } else {
        assert(0);
    }

    return 0;
}


int run_ti_stream1(const ti_indicator_info *info, double *options, int goal) {
    static double *inputs[] = {0, 0, 0, 0, 0};
    static double *outputs[] = {outstream1[0], outstream1[1], outstream1[2], outstream1[3], outstream1[4]};

    if (goal == 0) {

        ind_offset = info->start(options);


        double *ins[5] = {0};
        double *outs[5] = {0};


        ti_stream *stream;
        const int sret = info->stream_new(options, &stream);
        assert(stream);
        assert(sret == 0);

        for (int i = 0; i < 4000; ++i) {

            for (unsigned int j = 0; j < (sizeof(inputs)/sizeof(double*)); ++j) {
                ins[j] = inputs[j] + i;
            }

            int k = ti_stream_get_progress(stream);
            if (k < 0) k = 0;
            for (unsigned int j = 0; j < (sizeof(outputs)/sizeof(double*)); ++j) {
                outs[j] = outstream1[j] + k;
            }

            const int ret = info->stream_run(stream, 1, (double const *const *)ins, outs);

            if (ret != 0) {
                printf("   *ERROR* (%d)\n", ret);
                printf("options:\n");
                for (int j = 0; j < info->options; ++j) {
                    printf("%d = %f\n", j, options[j]);
                }
                return 1;
            }


        }

        info->stream_free(stream);


    } else if (goal == 1) {

        ti_setup(info, inputs);

    } else if (goal == 2) {
    } else {
        assert(0);
    }

    return 0;
}


int run_ti_streamall(const ti_indicator_info *info, double *options, int goal) {
    static double *inputs[] = {0, 0, 0, 0, 0};
    static double *outputs[] = {outstreamall[0], outstreamall[1], outstreamall[2], outstreamall[3], outstreamall[4]};

    if (goal == 0) {

        ind_offset = info->start(options);


        ti_stream *stream;
        const int sret = info->stream_new(options, &stream);
        assert(stream);
        assert(sret == 0);

        const int ret = info->stream_run(stream, 4000, (double const *const *)inputs, outputs);
        info->stream_free(stream);

        if (ret != 0) {
            printf("   *ERROR* (%d)\n", ret);
            printf("options:\n");
            int i;
            for (i = 0; i < info->options; ++i) {
                printf("%d = %f\n", i, options[i]);
            }
            return 1;
        }


    } else if (goal == 1) {

        ti_setup(info, inputs);

    } else if (goal == 2) {
    } else {
        assert(0);
    }

    return 0;
}







void simple_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
}

void fast_slow_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = period + 10;
}

void alma_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 0.5;
    options[2] = 1;
}

void bbands_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 1.0;






}

void ce_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 3;
}

void copp_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = 11;
    options[1] = 14;
    options[2] = period;
}

void kc_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 0.77;
}

void kst_option_setter(double period, double *options, int ti) {
    (void)ti;
    for (int i = 0; i < 4; ++i) {
        options[i+4] = options[i] = period + period / 4. * i;
    }
}

void macd_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = period + 10;

    options[2] = period + 1;
}

void mama_option_setter(double period, double *options, int ti) {
    (void)ti;

    (void)period;
    options[0] = 0.5;
    options[1] = 0.05;
}

void pfe_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 5;
}

void posc_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 3;
}

void ppo_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = period + 10;






}

void psar_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = 1/period;
    options[1] = options[0] * 10;
}

void rmi_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 3;
}

void rmta_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 1 - (2. / (period + 1));
}

void rvi_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 10;
}

void smi_option_setter(double period, double* options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 25;
    options[2] = 3;
}

void stoch_option_setter(double period, double *options, int ti) {


    if (ti) {
        options[0] = period;
        options[1] = 3;
        options[2] = 4;
    } else {







    }
}

void stochrsi_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = period;
    options[2] = period;
    options[3] = 1;
}

void tsi_option_setter(double period, double* options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = 3;
}

void ultosc_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = period * 2;
    options[2] = period * 4;
}

void vidya_option_setter(double period, double *options, int ti) {
    (void)ti;
    options[0] = period;
    options[1] = period + 10;
    options[2] = .2;
}
# 727 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
double stochrsi_output_adjust(double a) {

    return a * 0.01;
}







void check_outputs(const ti_indicator_info *info, const char* what, double compare[3][4000]) {


    int remap[] = {0,1,2,3,4};

    int nanok = 0;
    if (strcmp(info->name, "asin") == 0) nanok = 1;
    if (strcmp(info->name, "acos") == 0) nanok = 1;
# 761 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
    int i, j;
# 770 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
    for (j = 0; j < info->outputs; ++j) {
        int end = 4000 - ind_offset;



        if (remap[j] == -1) continue;


        for (i = 0; i < end; ++i) {
            double a = out[j][4000 -1-i-ind_offset];
            double b = compare[j][4000 -1-i-ind_offset];
# 790 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
            double diff = fabs(a-b);
            if (diff > 0.0001 || (!nanok && diff != diff)) {
                ++fails;
                printf("Results disagree.\n");
                printf("    series         (diff)   ti   %s\n", what);
                printf("    series %d, %4d (%f) %.5f %.5f\n", j, i, diff, a, b);
                break;
            }
        }
    }
}




void bench_run(FILE *log, const ti_indicator_info *info, const void *run_info, run_fun fun, const char *name) {



    double options[] = {1,1,1,1,1,1,1,1,1,1};




    void (*options_setter)(double period, double *options, int ti) = 0;


    if (strcmp(info->name, "alma") == 0) { options_setter = alma_option_setter; }
    if (strcmp(info->name, "adosc") == 0) { options_setter = fast_slow_option_setter; }
    if (strcmp(info->name, "apo") == 0) { options_setter = ppo_option_setter; }
    if (strcmp(info->name, "bbands") == 0) { options_setter = bbands_option_setter; }
    if (strcmp(info->name, "copp") == 0) { options_setter = copp_option_setter; }
    if (strcmp(info->name, "kc") == 0) { options_setter = kc_option_setter; }
    if (strcmp(info->name, "kst") == 0) { options_setter = kst_option_setter; }
    if (strcmp(info->name, "kvo") == 0) { options_setter = fast_slow_option_setter; }
    if (strcmp(info->name, "macd") == 0) { options_setter = macd_option_setter; }
    if (strcmp(info->name, "mama") == 0) { options_setter = mama_option_setter; }
    if (strcmp(info->name, "pfe") == 0) { options_setter = pfe_option_setter; }
    if (strcmp(info->name, "posc") == 0) { options_setter = posc_option_setter; }
    if (strcmp(info->name, "ppo") == 0) { options_setter = ppo_option_setter; }
    if (strcmp(info->name, "psar") == 0) { options_setter = psar_option_setter; }
    if (strcmp(info->name, "rvi") == 0) { options_setter = rvi_option_setter; }
    if (strcmp(info->name, "rmi") == 0) { options_setter = rmi_option_setter; }
    if (strcmp(info->name, "rmta") == 0) { options_setter = rmta_option_setter; }
    if (strcmp(info->name, "smi") == 0) { options_setter = smi_option_setter; }
    if (strcmp(info->name, "stoch") == 0) { options_setter = stoch_option_setter; }
    if (strcmp(info->name, "stochrsi") == 0) { options_setter = stochrsi_option_setter; }
    if (strcmp(info->name, "ultosc") == 0) { options_setter = ultosc_option_setter; }
    if (strcmp(info->name, "vidya") == 0) { options_setter = vidya_option_setter; }
    if (strcmp(info->name, "vosc") == 0) { options_setter = fast_slow_option_setter; }


    int best_e = 1e9, best_p = -1e9;
    int best;
    for (best = 0; best < bestof; ++best) {
        printf("Benchmark %25s-%-16s ", info->name, name);
        int i, period;
        int iterations = 0;
        const clock_t start = clock();

        fun(run_info, 0, 1);

        for (i = 0; i < 1; ++i) {
            for (period = 4; period <= 150; ++period) {
                if (options_setter)
                    options_setter(period, options, info == run_info);
                else
                    options[0] = period;

                const int ret = fun(run_info, options, 0);
                if (ret) {
                    return;
                }
                ++iterations;
            }
        }

        fun(run_info, 0, 2);

        const int elapsed = (clock() - start) * 1000 / CLOCKS_PER_SEC;
        const int performance = elapsed == 0 ? 0 : (iterations * 4000) / elapsed / 1000;


        if (elapsed)
            printf("\t%5dms\t%5dmfps\n", elapsed, performance);
        else
            printf("\n");

        best_e = ((elapsed)<(best_e)?(elapsed):(best_e));
        best_p = ((performance)>(best_p)?(performance):(best_p));
    }

    if (log) fprintf(log, ",\n    \"%s\" => array(\"elapsed\" => %d, \"performance\" => %d)", name, best_e, best_p);
}



void bench_indicator(FILE *log, const ti_indicator_info *info) {



    {
        int i;
        for (i = 0; i < 3; ++i) {
            memset(out[i], 0xF1, sizeof(out[i]));
            memset(outref[i], 0xF2, sizeof(outref[i]));
            memset(outstream1[i], 0xF3, sizeof(outstream1[i]));
            memset(outstreamall[i], 0xF4, sizeof(outstreamall[i]));



        }
    }
# 911 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
    if (info) {
        if (log) fprintf(log, ",\n  \"%s\" => array(\n", info->name);
        if (log) fprintf(log, "    \"name\" => \"%s\"", info->full_name);

        bench_run(log, info, info, run_ti, "ti");
    }

    if (info && info->indicator_ref) {
        bench_run(log, info, info, run_ti_ref, "ti_ref");
        check_outputs(info, "ref", outref);
    }

    if (info && info->stream_new) {
        bench_run(log, info, info, run_ti_stream1, "ti_stream1");
        check_outputs(info, "stream1", outstream1);

        bench_run(log, info, info, run_ti_streamall, "ti_streamall");
        check_outputs(info, "streamall", outstreamall);
    }
# 950 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
    if (log) fprintf(log, "\n  )");
    printf("\n");
}


void bench_run_candle(FILE *log, const tc_candle_info *info) {

    const char* name = "ti";
    tc_set pattern = info->pattern;

    int best_e = 1e9, best_p = -1e9;
    int best;
    for (best = 0; best < bestof; ++best) {
        printf("Benchmark %25s-%-16s ", info->name, name);
        int i, period;
        int iterations = 0;
        const clock_t start = clock();

        const double *inputs[4] = {in[0], in[1], in[2], in[3]};
        tc_config config;
        tc_config_set_to_default(&config);


        for (i = 0; i < 1; ++i) {
            for (period = 4; period <= 150; ++period) {

                const int ret = tc_run(pattern, 4000, inputs, &config, outcnd);
                if (ret) {
                    return;
                }
                ++iterations;
            }
        }


        const int elapsed = (clock() - start) * 1000 / CLOCKS_PER_SEC;
        const int performance = elapsed == 0 ? 0 : (iterations * 4000) / elapsed / 1000;


        if (elapsed)
            printf("\t%5dms\t%5dmfps\n", elapsed, performance);
        else
            printf("\n");

        best_e = ((elapsed)<(best_e)?(elapsed):(best_e));
        best_p = ((performance)>(best_p)?(performance):(best_p));
    }

    if (log) fprintf(log, ",\n    \"%s\" => array(\"elapsed\" => %d, \"performance\" => %d)", name, best_e, best_p);


}
# 1050 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
void bench_candle(FILE *log, const tc_candle_info *info) {

    outcnd = tc_result_new();
    assert(outcnd);

    if (info) {
        if (log) fprintf(log, ",\n  \"%s\" => array(\n", info->name);
        if (log) fprintf(log, "    \"name\" => \"%s\"", info->full_name);

        bench_run_candle(log, info);
# 1111 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
    tc_result_free(outcnd);

    }





    if (log) fprintf(log, "\n  )");
    printf("\n");
}



int main(int argc, char **argv) {
    printf("Tulip Charts Indicator benchmark.\n");
    printf("Using real size of: %d.\n\n", sizeof(double));

    generate_inputs();





    const ti_indicator_info *ind_info = ti_indicators;
    const tc_candle_info *cnd_info = tc_candles;

    const int candles_only = argc > 1 && !strcmp(argv[1], "tc");

    if (argc > 1 && !isdigit(argv[1][0]) && !candles_only) {


        if (argc > 2) {
            bestof = atoi(argv[2]);
            if (!bestof) bestof = 1;
        }

        ind_info = ti_find_indicator(argv[1]);
        if (ind_info) bench_indicator(0, ind_info);

        cnd_info = tc_find_candle(argv[1]);
        if (cnd_info) bench_candle(0, cnd_info);

    } else {

        if (argc > 1 && isdigit(argv[1][0])) {
            bestof = atoi(argv[1]);
        }

        FILE *log = fopen("docs/benchmark.php", "w");
        if (!log) {
            printf("Couldn't open results file for output. Make sure ./docs/ exists.\n");
            exit(1);
        }

        fprintf(log, "<?php\n");
        fprintf(log, "#GENERATED BY benchmark.c\n");
        fprintf(log, "#DO NOT MODIFY DIRECTLY\n");
        fprintf(log, "$benchmark = array(\n");
        fprintf(log, "  \"worksize\" => %d,", 1 * (150 -4 +1) * 4000);
        fprintf(log, "  \"bestof\" => %d", bestof);

        if (!candles_only) {

            do {

                if (strcmp(ind_info->name, "msw") == 0) continue;

                bench_indicator(log, ind_info);
            } while ((++ind_info)->name);
        }

        do {
            bench_candle(log, cnd_info);
        } while ((++cnd_info)->name);

        const tc_candle_info cnd_all = {.name = "all", .full_name = "All Candle Patterns", .pattern = ((1L<<26)-1)};
        bench_candle(log, &cnd_all);

        fprintf(log, ");");

        fclose(log);
    }
# 1203 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/benchmark.c"
    if (!fails) {
        printf("All comparisons passed.\n");
    } else {
        printf("%d comparisons failed.\n", fails);
    }


    return 0;
}
