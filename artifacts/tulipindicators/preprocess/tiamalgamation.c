# 0 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
# 60 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/math.h" 1
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/math.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/math.h" 2
# 61 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/assert.h" 1
# 62 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/string.h" 1
# 63 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 64 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c" 2
# 72 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
const char* ti_version(void);
long int ti_build(void);
int ti_indicator_count(void);
# 97 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
typedef int (*ti_indicator_start_function)(double const *options);
typedef int (*ti_indicator_function)(int size, double const *const *inputs, double const *options, double *const *outputs);


struct ti_stream; typedef struct ti_stream ti_stream;
typedef int (*ti_indicator_stream_new)(double const *options, ti_stream **stream);
typedef int (*ti_indicator_stream_run)(ti_stream *stream, int size, double const *const *inputs, double *const *outputs);
typedef void (*ti_indicator_stream_free)(ti_stream *stream);


typedef struct ti_indicator_info {
    const char *name;
    const char *full_name;
    ti_indicator_start_function start;
    ti_indicator_function indicator;
    ti_indicator_function indicator_ref;
    int type, inputs, options, outputs;
    const char *input_names[16];
    const char *option_names[16];
    const char *output_names[16];
    ti_indicator_stream_new stream_new;
    ti_indicator_stream_run stream_run;
    ti_indicator_stream_free stream_free;
} ti_indicator_info;



extern ti_indicator_info ti_indicators[];



const ti_indicator_info *ti_find_indicator(const char *name);




int ti_stream_run(ti_stream *stream, int size, double const *const *inputs, double *const *outputs);
ti_indicator_info *ti_stream_get_info(ti_stream *stream);
int ti_stream_get_progress(ti_stream *stream);
void ti_stream_free(ti_stream *stream);
# 165 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
int ti_abs_start(double const *options);
int ti_abs(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_acos_start(double const *options);
int ti_acos(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ad_start(double const *options);
int ti_ad(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_add_start(double const *options);
int ti_add(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_adosc_start(double const *options);
int ti_adosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_adx_start(double const *options);
int ti_adx(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_adxr_start(double const *options);
int ti_adxr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ao_start(double const *options);
int ti_ao(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_apo_start(double const *options);
int ti_apo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_aroon_start(double const *options);
int ti_aroon(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_aroonosc_start(double const *options);
int ti_aroonosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_asin_start(double const *options);
int ti_asin(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_atan_start(double const *options);
int ti_atan(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_atr_start(double const *options);
int ti_atr(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_atr_ref(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_atr_stream_new(double const *options, ti_stream **stream);
int ti_atr_stream_run(ti_stream *stream, int size, double const *const *inputs, double *const *outputs);
void ti_atr_stream_free(ti_stream *stream);







int ti_avgprice_start(double const *options);
int ti_avgprice(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_bbands_start(double const *options);
int ti_bbands(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_bop_start(double const *options);
int ti_bop(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cci_start(double const *options);
int ti_cci(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ceil_start(double const *options);
int ti_ceil(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cmo_start(double const *options);
int ti_cmo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cos_start(double const *options);
int ti_cos(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cosh_start(double const *options);
int ti_cosh(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_crossany_start(double const *options);
int ti_crossany(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_crossover_start(double const *options);
int ti_crossover(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cvi_start(double const *options);
int ti_cvi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_decay_start(double const *options);
int ti_decay(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_dema_start(double const *options);
int ti_dema(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_di_start(double const *options);
int ti_di(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_div_start(double const *options);
int ti_div(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_dm_start(double const *options);
int ti_dm(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_dpo_start(double const *options);
int ti_dpo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_dx_start(double const *options);
int ti_dx(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_edecay_start(double const *options);
int ti_edecay(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ema_start(double const *options);
int ti_ema(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_emv_start(double const *options);
int ti_emv(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_exp_start(double const *options);
int ti_exp(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_fisher_start(double const *options);
int ti_fisher(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_floor_start(double const *options);
int ti_floor(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_fosc_start(double const *options);
int ti_fosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_hma_start(double const *options);
int ti_hma(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_kama_start(double const *options);
int ti_kama(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_kvo_start(double const *options);
int ti_kvo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_lag_start(double const *options);
int ti_lag(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_linreg_start(double const *options);
int ti_linreg(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_linregintercept_start(double const *options);
int ti_linregintercept(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_linregslope_start(double const *options);
int ti_linregslope(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ln_start(double const *options);
int ti_ln(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_log10_start(double const *options);
int ti_log10(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_macd_start(double const *options);
int ti_macd(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_marketfi_start(double const *options);
int ti_marketfi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_mass_start(double const *options);
int ti_mass(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_max_start(double const *options);
int ti_max(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_max_ref(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_md_start(double const *options);
int ti_md(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_medprice_start(double const *options);
int ti_medprice(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_mfi_start(double const *options);
int ti_mfi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_min_start(double const *options);
int ti_min(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_min_ref(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_mom_start(double const *options);
int ti_mom(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_msw_start(double const *options);
int ti_msw(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_mul_start(double const *options);
int ti_mul(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_natr_start(double const *options);
int ti_natr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_nvi_start(double const *options);
int ti_nvi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_obv_start(double const *options);
int ti_obv(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ppo_start(double const *options);
int ti_ppo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_psar_start(double const *options);
int ti_psar(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_pvi_start(double const *options);
int ti_pvi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_qstick_start(double const *options);
int ti_qstick(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_roc_start(double const *options);
int ti_roc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_rocr_start(double const *options);
int ti_rocr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_round_start(double const *options);
int ti_round(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_rsi_start(double const *options);
int ti_rsi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sin_start(double const *options);
int ti_sin(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sinh_start(double const *options);
int ti_sinh(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sma_start(double const *options);
int ti_sma(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_sma_stream_new(double const *options, ti_stream **stream);
int ti_sma_stream_run(ti_stream *stream, int size, double const *const *inputs, double *const *outputs);
void ti_sma_stream_free(ti_stream *stream);







int ti_sqrt_start(double const *options);
int ti_sqrt(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_stddev_start(double const *options);
int ti_stddev(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_stderr_start(double const *options);
int ti_stderr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_stoch_start(double const *options);
int ti_stoch(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_stochrsi_start(double const *options);
int ti_stochrsi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sub_start(double const *options);
int ti_sub(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sum_start(double const *options);
int ti_sum(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tan_start(double const *options);
int ti_tan(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tanh_start(double const *options);
int ti_tanh(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tema_start(double const *options);
int ti_tema(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_todeg_start(double const *options);
int ti_todeg(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_torad_start(double const *options);
int ti_torad(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tr_start(double const *options);
int ti_tr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_trima_start(double const *options);
int ti_trima(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_trix_start(double const *options);
int ti_trix(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_trunc_start(double const *options);
int ti_trunc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tsf_start(double const *options);
int ti_tsf(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_typprice_start(double const *options);
int ti_typprice(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ultosc_start(double const *options);
int ti_ultosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_var_start(double const *options);
int ti_var(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_vhf_start(double const *options);
int ti_vhf(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_vidya_start(double const *options);
int ti_vidya(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_volatility_start(double const *options);
int ti_volatility(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_vosc_start(double const *options);
int ti_vosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_vwma_start(double const *options);
int ti_vwma(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_wad_start(double const *options);
int ti_wad(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_wcprice_start(double const *options);
int ti_wcprice(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_wilders_start(double const *options);
int ti_wilders(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_willr_start(double const *options);
int ti_willr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_wma_start(double const *options);
int ti_wma(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_zlema_start(double const *options);
int ti_zlema(int size, double const *const *inputs, double const *options, double *const *outputs);
# 1169 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdint.h" 1
# 1170 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c" 2
# 1178 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
const char* tc_version(void);
long int tc_build(void);
int tc_candle_count(void);





typedef double TC_REAL;
typedef struct tc_result tc_result;

typedef uint64_t tc_set;
# 1235 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
typedef struct tc_config {
    int period;

    TC_REAL body_none;
    TC_REAL body_short;
    TC_REAL body_long;

    TC_REAL wick_none;
    TC_REAL wick_long;

    TC_REAL near;

} tc_config;



typedef struct tc_hit {
    int index;
    tc_set patterns;
} tc_hit;



typedef int (*tc_candle_function)(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);



typedef struct tc_candle_info {
    const char *name;
    const char *full_name;
    tc_set pattern;
    tc_candle_function candle;
} tc_candle_info;



extern tc_candle_info tc_candles[];


const tc_candle_info *tc_find_candle(const char *name);


const tc_candle_info *tc_get_info(tc_set pattern);


tc_config const *tc_config_default();
void tc_config_set_to_default(tc_config *config);


tc_result *tc_result_new();
void tc_result_free(tc_result *result);
int tc_result_count(const tc_result *result);
int tc_result_pattern_count(const tc_result *result);

tc_hit tc_result_get(const tc_result *result, int index);
tc_set tc_result_at(const tc_result *result, int index);




int tc_run(tc_set patterns, int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
# 1315 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
int tc_abandoned_baby_bear(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_abandoned_baby_bull(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_big_black_candle(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_big_white_candle(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_black_marubozu(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_dragonfly_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_engulfing_bear(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_engulfing_bull(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_evening_doji_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_evening_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_four_price_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_gravestone_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_hammer(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_hanging_man(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_inverted_hammer(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_long_legged_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_marubozu(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_morning_doji_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_morning_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_shooting_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_spinning_top(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_three_black_crows(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_three_white_soldiers(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_white_marubozu(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
# 1378 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
typedef struct {
    int size, pushes, index;
    double sum;
    double vals[1];
} ti_buffer;


ti_buffer *ti_buffer_new(int size);
void ti_buffer_free(ti_buffer *buffer);
# 1540 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
int ti_abs_start(double const *options) { (void)options; return 0; } int ti_abs(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (fabs(in1[i])); } return 0; }
int ti_acos_start(double const *options) { (void)options; return 0; } int ti_acos(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (acos(in1[i])); } return 0; }
int ti_ad_start(double const *options) {
    (void)options;
    return 0;
}
int ti_ad(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const double *volume = inputs[3];
    (void)options;
    double *output = outputs[0];
    double sum = 0;
    int i;
    for (i = 0; i < size; ++i) {
        const double hl = (high[i] - low[i]);
        if (hl != 0.0) {
            sum += (close[i] - low[i] - high[i] + close[i]) / hl * volume[i];
        }
        output[i] = sum;
    }
    return 0;
}
int ti_add_start(double const *options) { (void)options; return 0; } int ti_add(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; const double *in2 = inputs[1]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (in1[i] + in2[i]); } return 0; }
int ti_adosc_start(double const *options) {
    return (int)(options[1])-1;
}
int ti_adosc(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const double *volume = inputs[3];
    const int short_period = (int)options[0];
    const int long_period = (int)options[1];
    const int start = long_period - 1;
    if (short_period < 1) return 1;
    if (long_period < short_period) return 1;
    if (size <= ti_adosc_start(options)) return 0;
    const double short_per = 2 / ((double)short_period + 1);
    const double long_per = 2 / ((double)long_period + 1);
    double *output = outputs[0];
    double sum = 0, short_ema = 0, long_ema = 0;
    int i;
    for (i = 0; i < size; ++i) {
        const double hl = (high[i] - low[i]);
        if (hl != 0.0) {
            sum += (close[i] - low[i] - high[i] + close[i]) / hl * volume[i];
        }
        if (i == 0) {
            short_ema = sum;
            long_ema = sum;
        } else {
            short_ema = (sum-short_ema) * short_per + short_ema;
            long_ema = (sum-long_ema) * long_per + long_ema;
        }
        if (i >= start) {
            *output++ = short_ema - long_ema;
        }
    }
    assert(output - outputs[0] == size - ti_adosc_start(options));
    return 0;
}
int ti_adx_start(double const *options) {
    return ((int)options[0]-1) * 2;
}
int ti_adx(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 2) return 1;
    if (size <= ti_adx_start(options)) return 0;
    const double per = ((double)period-1) / ((double)period);
    const double invper = 1.0 / ((double)period);
    double dmup = 0;
    double dmdown = 0;
    int i;
    for (i = 1; i < period; ++i) {
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup += dp;
        dmdown += dm;
    }
    double adx = 0.0;
    {
        double di_up = dmup;
        double di_down = dmdown;
        double dm_diff = fabs(di_up - di_down);
        double dm_sum = di_up + di_down;
        double dx = dm_diff / dm_sum * 100;
        adx += dx;
    }
    for (i = period; i < size; ++i) {
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup = dmup * per + dp;
        dmdown = dmdown * per + dm;
        double di_up = dmup;
        double di_down = dmdown;
        double dm_diff = fabs(di_up - di_down);
        double dm_sum = di_up + di_down;
        double dx = dm_diff / dm_sum * 100;
        if (i-period < period-2) {
            adx += dx;
        } else if (i-period == period-2) {
            adx += dx;
            *output++ = adx * invper;
        } else {
            adx = adx * per + dx;
            *output++ = adx * invper;
        }
    }
    assert(output - outputs[0] == size - ti_adx_start(options));
    return 0;
}
int ti_adxr_start(double const *options) {
    return ((int)options[0]-1) * 3;
}
int ti_adxr(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 2) return 1;
    if (size <= ti_adxr_start(options)) return 0;
    const double per = ((double)period-1) / ((double)period);
    const double invper = 1.0 / ((double)period);
    double dmup = 0;
    double dmdown = 0;
    int i;
    for (i = 1; i < period; ++i) {
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup += dp;
        dmdown += dm;
    }
    double adx = 0.0;
    {
        double di_up = dmup;
        double di_down = dmdown;
        double dm_diff = fabs(di_up - di_down);
        double dm_sum = di_up + di_down;
        double dx = dm_diff / dm_sum * 100;
        adx += dx;
    }
    ti_buffer *adxr = ti_buffer_new(period-1);
    const int first_adxr = ti_adxr_start(options);
    for (i = period; i < size; ++i) {
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup = dmup * per + dp;
        dmdown = dmdown * per + dm;
        double di_up = dmup;
        double di_down = dmdown;
        double dm_diff = fabs(di_up - di_down);
        double dm_sum = di_up + di_down;
        double dx = dm_diff / dm_sum * 100;
        if (i-period < period-2) {
            adx += dx;
        } else if (i-period == period-2) {
            adx += dx;
            do { (adxr)->vals[(adxr)->index] = (adx * invper); (adxr)->index = ((adxr)->index + 1); if ((adxr)->index >= (adxr)->size) (adxr)->index = 0; } while (0);
        } else {
            adx = adx * per + dx;
            if (i >= first_adxr) {
                *output++ = 0.5 * (adx * invper + ((adxr)->vals[((adxr)->index + (adxr)->size - 1 + (1)) % (adxr)->size]));
            }
            do { (adxr)->vals[(adxr)->index] = (adx * invper); (adxr)->index = ((adxr)->index + 1); if ((adxr)->index >= (adxr)->size) (adxr)->index = 0; } while (0);
        }
    }
    ti_buffer_free(adxr);
    assert(output - outputs[0] == size - ti_adxr_start(options));
    return 0;
}
int ti_ao_start(double const *options) {
    (void)options;
    return 33;
}
int ti_ao(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const int period = 34;
    double *output = outputs[0];
    if (size <= ti_ao_start(options)) return 0;
    double sum34 = 0;
    double sum5 = 0;
    const double per34 = 1.0 / 34.0;
    const double per5 = 1.0 / 5.0;
    int i;
    for (i = 0; i < 34; ++i) {
        double hl = 0.5 * (high[i] + low[i]);
        sum34 += hl;
        if (i >= 29) sum5 += hl;
    }
    *output++ = (per5 * sum5 - per34 * sum34);
    for (i = period; i < size; ++i) {
        double hl = 0.5 * (high[i] + low[i]);
        sum34 += hl;
        sum5 += hl;
        sum34 -= 0.5 * (high[i-34] + low[i-34]);
        sum5 -= 0.5 * (high[i-5] + low[i-5]);
        *output++ = (per5 * sum5 - per34 * sum34);
    }
    assert(output - outputs[0] == size - ti_ao_start(options));
    return 0;
}
int ti_apo_start(double const *options) {
    (void)options;
    return 1;
}
int ti_apo(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    double *apo = outputs[0];
    const int short_period = (int)options[0];
    const int long_period = (int)options[1];
    if (short_period < 1) return 1;
    if (long_period < 2) return 1;
    if (long_period < short_period) return 1;
    if (size <= ti_apo_start(options)) return 0;
    double short_per = 2 / ((double)short_period + 1);
    double long_per = 2 / ((double)long_period + 1);
    double short_ema = input[0];
    double long_ema = input[0];
    int i;
    for (i = 1; i < size; ++i) {
        short_ema = (input[i]-short_ema) * short_per + short_ema;
        long_ema = (input[i]-long_ema) * long_per + long_ema;
        const double out = short_ema - long_ema;
        *apo++ = out;
    }
    assert(apo - outputs[0] == size - ti_apo_start(options));
    return 0;
}
int ti_aroon_start(double const *options) {
    return (int)options[0];
}
int ti_aroon(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    double *adown = outputs[0];
    double *aup = outputs[1];
    const int period = (int)options[0];
    if (period < 1) return 1;
    if (size <= ti_aroon_start(options)) return 0;
    const double scale = 100.0 / period;
    int trail = 0, maxi = -1, mini = -1;
    double max = high[0];
    double min = low[0];
    double bar;
    int i, j;
    for (i = period; i < size; ++i, ++trail) {
        bar = high[i];
        if (maxi < trail) {
            maxi = trail;
            max = high[maxi];
            j = trail;
            while(++j <= i) {
                bar = high[j];
                if (bar >= max) {
                    max = bar;
                    maxi = j;
                }
            }
        } else if (bar >= max) {
            maxi = i;
            max = bar;
        }
        bar = low[i];
        if (mini < trail) {
            mini = trail;
            min = low[mini];
            j = trail;
            while(++j <= i) {
                bar = low[j];
                if (bar <= min) {
                    min = bar;
                    mini = j;
                }
            }
        } else if (bar <= min) {
            mini = i;
            min = bar;
        }
        *adown++ = ((double)period - (i-mini)) * scale;
        *aup++ = ((double)period - (i-maxi)) * scale;
    }
    assert(adown - outputs[0] == size - ti_aroon_start(options));
    assert(aup - outputs[1] == size - ti_aroon_start(options));
    return 0;
}
int ti_aroonosc_start(double const *options) {
    return (int)options[0];
}
int ti_aroonosc(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    double *output = outputs[0];
    const int period = (int)options[0];
    if (period < 1) return 1;
    if (size <= ti_aroon_start(options)) return 0;
    const double scale = 100.0 / period;
    int trail = 0, maxi = -1, mini = -1;
    double max = high[0];
    double min = low[0];
    int i, j;
    for (i = period; i < size; ++i, ++trail) {
        double bar = high[i];
        if (maxi < trail) {
            maxi = trail;
            max = high[maxi];
            j = trail;
            while(++j <= i) {
                bar = high[j];
                if (bar >= max) {
                    max = bar;
                    maxi = j;
                }
            }
        } else if (bar >= max) {
            maxi = i;
            max = bar;
        }
        bar = low[i];
        if (mini < trail) {
            mini = trail;
            min = low[mini];
            j = trail;
            while(++j <= i) {
                bar = low[j];
                if (bar <= min) {
                    min = bar;
                    mini = j;
                }
            }
        } else if (bar <= min) {
            mini = i;
            min = bar;
        }
        *output++ = (maxi-mini) * scale;
    }
    assert(output - outputs[0] == size - ti_aroonosc_start(options));
    return 0;
}
int ti_asin_start(double const *options) { (void)options; return 0; } int ti_asin(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (asin(in1[i])); } return 0; }
int ti_atan_start(double const *options) { (void)options; return 0; } int ti_atan(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (atan(in1[i])); } return 0; }
int ti_atr_start(double const *options) {
    return (int)options[0]-1;
}
int ti_atr(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_atr_start(options)) return 0;
    const double per = 1.0 / ((double)period);
    double sum = 0;
    double truerange;
    sum += high[0] - low[0];
    int i;
    for (i = 1; i < period; ++i) {
        do{ const double l = low[i]; const double h = high[i]; const double c = close[i-1]; const double ych = fabs(h - c); const double ycl = fabs(l - c); double v = h - l; if (ych > v) v = ych; if (ycl > v) v = ycl; truerange = v;}while(0);
        sum += truerange;
    }
    double val = sum / period;
    *output++ = val;
    for (i = period; i < size; ++i) {
        do{ const double l = low[i]; const double h = high[i]; const double c = close[i-1]; const double ych = fabs(h - c); const double ycl = fabs(l - c); double v = h - l; if (ych > v) v = ych; if (ycl > v) v = ycl; truerange = v;}while(0);
        val = (truerange-val) * per + val;
        *output++ = val;
    }
    assert(output - outputs[0] == size - ti_atr_start(options));
    return 0;
}
int ti_atr_ref(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const int period = (int)options[0];
    if (period < 1) return 1;
    if (size <= ti_atr_start(options)) return 0;
    const int tr_start = ti_tr_start(options);
    const int tr_size = size - tr_start;
    double *truerange = malloc((unsigned int)tr_size * sizeof(double));
    if (!truerange) {return 2;}
    double *tr_outputs[1] = {truerange};
    const int tr_ret = ti_tr(size, inputs, 0, tr_outputs);
    if (tr_ret != 0) {
        free(truerange);
        return tr_ret;
    }
    const double *wilders_inputs[1] = {truerange};
    const int wilders_ret = ti_wilders(tr_size, wilders_inputs, options, outputs);
    free(truerange);
    assert(size - ti_atr_start(options) == size - ti_wilders_start(options));
    return wilders_ret;
}
typedef struct ti_stream_atr {
    int index;
    int progress;
    int period;
    double sum;
    double last;
    double last_close;
} ti_stream_atr;
int ti_atr_stream_new(double const *options, ti_stream **stream_in) {
    ti_stream_atr **stream = (ti_stream_atr**) stream_in;
    const int period = (int)options[0];
    if (period < 1) return 1;
    *stream = malloc(sizeof(ti_stream_atr));
    if (!*stream) {
        return 2;
    }
    (*stream)->index = 13;
    (*stream)->progress = -ti_atr_start(options);
    (*stream)->period = period;
    (*stream)->sum = 0.0;
    return 0;
}
int ti_atr_stream_run(ti_stream *stream_in, int size, double const *const *inputs, double *const *outputs) {
    ti_stream_atr *stream = (ti_stream_atr*)stream_in;
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    double *output = outputs[0];
    const double per = 1.0 / ((double)stream->period);
    const int start = -(stream->period-1);
    int i = 0;
    if (stream->progress < 1) {
        if (stream->progress == start) {
            stream->sum = high[0] - low[0];
            stream->last_close = close[0];
            ++stream->progress; ++i;
        }
        while (stream->progress <= 0 && i < size) {
            double truerange; do { const double ych = fabs((high[i]) - (stream->last_close)); const double ycl = fabs((low[i]) - (stream->last_close)); double v = (high[i]) - (low[i]); if (ych > v) v = ych; if (ycl > v) v = ycl; truerange = v; } while (0);
            stream->sum += truerange;
            stream->last_close = close[i];
            ++stream->progress; ++i;
        }
        if (stream->progress == 1) {
            const double val = stream->sum * per;
            stream->last = val;
            *output++ = val;
        }
    }
    if (stream->progress >= 1) {
        double val = stream->last;
        while (i < size) {
            double truerange; do { const double ych = fabs((high[i]) - (stream->last_close)); const double ycl = fabs((low[i]) - (stream->last_close)); double v = (high[i]) - (low[i]); if (ych > v) v = ych; if (ycl > v) v = ycl; truerange = v; } while (0);
            val = (truerange-val) * per + val;
            *output++ = val;
            stream->last_close = close[i];
            ++stream->progress; ++i;
        }
        stream->last = val;
    }
    return 0;
}
void ti_atr_stream_free(ti_stream *stream) {
    free(stream);
}
int ti_avgprice_start(double const *options) {
    (void)options;
    return 0;
}
int ti_avgprice(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *open = inputs[0];
    const double *high = inputs[1];
    const double *low = inputs[2];
    const double *close = inputs[3];
    (void)options;
    double *output = outputs[0];
    int i;
    for (i = 0; i < size; ++i) {
        output[i] = (open[i] + high[i] + low[i] + close[i]) * 0.25;
    }
    return 0;
}
int ti_bbands_start(double const *options) {
    return (int)options[0]-1;
}
int ti_bbands(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    double *lower = outputs[0];
    double *middle = outputs[1];
    double *upper = outputs[2];
    const int period = (int)options[0];
    const double stddev = options[1];
    const double scale = 1.0 / period;
    if (period < 1) return 1;
    if (size <= ti_bbands_start(options)) return 0;
    double sum = 0;
    double sum2 = 0;
    int i;
    for (i = 0; i < period; ++i) {
        sum += input[i];
        sum2 += input[i] * input[i];
    }
    double sd = sqrt(sum2 * scale - (sum * scale) * (sum * scale));
    *middle = sum * scale;
    *lower++ = *middle - stddev * sd;
    *upper++ = *middle + stddev * sd;
    ++middle;
    for (i = period; i < size; ++i) {
        sum += input[i];
        sum2 += input[i] * input[i];
        sum -= input[i-period];
        sum2 -= input[i-period] * input[i-period];
        sd = sqrt(sum2 * scale - (sum * scale) * (sum * scale));
        *middle = sum * scale;
        *upper++ = *middle + stddev * sd;
        *lower++ = *middle - stddev * sd;
        ++middle;
    }
    assert(lower - outputs[0] == size - ti_bbands_start(options));
    assert(middle - outputs[1] == size - ti_bbands_start(options));
    assert(upper - outputs[2] == size - ti_bbands_start(options));
    return 0;
}
int ti_bop_start(double const *options) {
    (void)options;
    return 0;
}
int ti_bop(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *open = inputs[0];
    const double *high = inputs[1];
    const double *low = inputs[2];
    const double *close = inputs[3];
    (void)options;
    double *output = outputs[0];
    int i;
    for (i = 0; i < size; ++i) {
        double hl = high[i] - low[i];
        if (hl <= 0.0) {
            output[i] = 0;
        } else {
            output[i] = (close[i] - open[i]) / hl;
        }
    }
    return 0;
}
int ti_cci_start(double const *options) {
    const int period = (int)options[0];
    return (period-1) * 2;
}
int ti_cci(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const int period = (int)options[0];
    const double scale = 1.0 / period;
    if (period < 1) return 1;
    if (size <= ti_cci_start(options)) return 0;
    double *output = outputs[0];
    ti_buffer *sum = ti_buffer_new(period);
    int i, j;
    for (i = 0; i < size; ++i) {
        const double today = ((high[(i)] + low[(i)] + close[(i)]) * (1.0/3.0));
        do { if ((sum)->pushes >= (sum)->size) { (sum)->sum -= (sum)->vals[(sum)->index]; } (sum)->sum += (today); (sum)->vals[(sum)->index] = (today); (sum)->pushes += 1; (sum)->index = ((sum)->index + 1); if ((sum)->index >= (sum)->size) (sum)->index = 0; } while (0);
        const double avg = sum->sum * scale;
        if (i >= period * 2 - 2) {
            double acc = 0;
            for (j = 0; j < period; ++j) {
                acc += fabs(avg - sum->vals[j]);
            }
            double cci = acc * scale;
            cci *= .015;
            cci = (today-avg)/cci;
            *output++ = cci;
        }
    }
    ti_buffer_free(sum);
    assert(output - outputs[0] == size - ti_cci_start(options));
    return 0;
}
int ti_ceil_start(double const *options) { (void)options; return 0; } int ti_ceil(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (ceil(in1[i])); } return 0; }
int ti_cmo_start(double const *options) {
    return (int)options[0];
}
int ti_cmo(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    double *output = outputs[0];
    const int period = (int)options[0];
    if (period < 1) return 1;
    if (size <= ti_cmo_start(options)) return 0;
    double up_sum = 0, down_sum = 0;
    int i;
    for (i = 1; i <= period; ++i) {
        up_sum += (input[(i)] > input[(i)-1] ? input[(i)] - input[(i)-1] : 0);
        down_sum += (input[(i)] < input[(i)-1] ? input[(i)-1] - input[(i)] : 0);
    }
    *output++ = 100 * (up_sum - down_sum) / (up_sum + down_sum);
    for (i = period+1; i < size; ++i) {
        up_sum -= (input[(i-period)] > input[(i-period)-1] ? input[(i-period)] - input[(i-period)-1] : 0);
        down_sum -= (input[(i-period)] < input[(i-period)-1] ? input[(i-period)-1] - input[(i-period)] : 0);
        up_sum += (input[(i)] > input[(i)-1] ? input[(i)] - input[(i)-1] : 0);
        down_sum += (input[(i)] < input[(i)-1] ? input[(i)-1] - input[(i)] : 0);
        *output++ = 100 * (up_sum - down_sum) / (up_sum + down_sum);
    }
    assert(output - outputs[0] == size - ti_cmo_start(options));
    return 0;
}
int ti_cos_start(double const *options) { (void)options; return 0; } int ti_cos(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (cos(in1[i])); } return 0; }
int ti_cosh_start(double const *options) { (void)options; return 0; } int ti_cosh(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (cosh(in1[i])); } return 0; }
int ti_crossany_start(double const *options) {
    (void)options;
    return 1;
}
int ti_crossany(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *a = inputs[0];
    const double *b = inputs[1];
    (void)options;
    double *output = outputs[0];
    int i;
    for (i = 1; i < size; ++i) {
        *output++ = (a[i] > b[i] && a[i-1] <= b[i-1])
                 || (a[i] < b[i] && a[i-1] >= b[i-1]);
    }
    return 0;
}
int ti_crossover_start(double const *options) {
    (void)options;
    return 1;
}
int ti_crossover(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *a = inputs[0];
    const double *b = inputs[1];
    (void)options;
    double *output = outputs[0];
    int i;
    for (i = 1; i < size; ++i) {
        *output++ = a[i] > b[i] && a[i-1] <= b[i-1];
    }
    return 0;
}
int ti_cvi_start(double const *options) {
    const int n = (int)options[0];
    return n*2-1;
}
int ti_cvi(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_cvi_start(options)) return 0;
    const double per = 2 / ((double)period + 1);
    ti_buffer *lag = ti_buffer_new(period);
    double val = high[0]-low[0];
    int i;
    for (i = 1; i < period*2-1; ++i) {
        val = ((high[i]-low[i])-val) * per + val;
        do { (lag)->vals[(lag)->index] = (val); (lag)->index = ((lag)->index + 1); if ((lag)->index >= (lag)->size) (lag)->index = 0; } while (0);
    }
    for (i = period*2-1; i < size; ++i) {
        val = ((high[i]-low[i])-val) * per + val;
        const double old = lag->vals[lag->index];
        *output++ = 100.0 * (val - old) / old;
        do { (lag)->vals[(lag)->index] = (val); (lag)->index = ((lag)->index + 1); if ((lag)->index >= (lag)->size) (lag)->index = 0; } while (0);
    }
    ti_buffer_free(lag);
    assert(output - outputs[0] == size - ti_cvi_start(options));
    return 0;
}
int ti_decay_start(double const *options) {
    (void)options;
    return 0;
}
int ti_decay(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    double *output = outputs[0];
    const int period = (int)options[0];
    const double scale = 1.0 / period;
    *output++ = input[0];
    int i;
    for (i = 1; i < size; ++i) {
        double d = output[-1] - scale;
        *output++ = input[i] > d ? input[i] : d;
    }
    return 0;
}
int ti_dema_start(double const *options) {
    const int period = (int)options[0];
    return (period-1) * 2;
}
int ti_dema(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_dema_start(options)) return 0;
    const double per = 2 / ((double)period + 1);
    const double per1 = 1.0 - per;
    double ema = input[0];
    double ema2 = ema;
    int i;
    for (i = 0; i < size; ++i) {
        ema = ema * per1 + input[i] * per;
        if (i == period-1) {
            ema2 = ema;
        }
        if (i >= period-1) {
            ema2 = ema2 * per1 + ema * per;
            if (i >= (period-1) * 2) {
                *output = ema * 2 - ema2;
                ++output;
            }
        }
    }
    assert(output - outputs[0] == size - ti_dema_start(options));
    return 0;
}
int ti_di_start(double const *options) {
    return (int)options[0]-1;
}
int ti_di(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const int period = (int)options[0];
    double *plus_di = outputs[0];
    double *minus_di = outputs[1];
    if (period < 1) return 1;
    if (size <= ti_di_start(options)) return 0;
    const double per = ((double)period-1) / ((double)period);
    double atr = 0;
    double dmup = 0;
    double dmdown = 0;
    int i;
    for (i = 1; i < period; ++i) {
        double truerange;
        do{ const double l = low[i]; const double h = high[i]; const double c = close[i-1]; const double ych = fabs(h - c); const double ycl = fabs(l - c); double v = h - l; if (ych > v) v = ych; if (ycl > v) v = ycl; truerange = v;}while(0);
        atr += truerange;
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup += dp;
        dmdown += dm;
    }
    *plus_di++ = 100.0 * dmup / atr;
    *minus_di++ = 100.0 * dmdown / atr;
    for (i = period; i < size; ++i) {
        double truerange;
        do{ const double l = low[i]; const double h = high[i]; const double c = close[i-1]; const double ych = fabs(h - c); const double ycl = fabs(l - c); double v = h - l; if (ych > v) v = ych; if (ycl > v) v = ycl; truerange = v;}while(0);
        atr = atr * per + truerange;
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup = dmup * per + dp;
        dmdown = dmdown * per + dm;
        *plus_di++ = 100.0 * dmup / atr;
        *minus_di++ = 100.0 * dmdown / atr;
    }
    assert(plus_di - outputs[0] == size - ti_di_start(options));
    assert(minus_di - outputs[1] == size - ti_di_start(options));
    return 0;
}
int ti_div_start(double const *options) { (void)options; return 0; } int ti_div(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; const double *in2 = inputs[1]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (in1[i] / in2[i]); } return 0; }
int ti_dm_start(double const *options) {
    return (int)options[0]-1;
}
int ti_dm(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const int period = (int)options[0];
    double *plus_dm = outputs[0];
    double *minus_dm = outputs[1];
    if (period < 1) return 1;
    if (size <= ti_dm_start(options)) return 0;
    const double per = ((double)period-1) / ((double)period);
    double dmup = 0;
    double dmdown = 0;
    int i;
    for (i = 1; i < period; ++i) {
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup += dp;
        dmdown += dm;
    }
    *plus_dm++ = dmup;
    *minus_dm++ = dmdown;
    for (i = period; i < size; ++i) {
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup = dmup * per + dp;
        dmdown = dmdown * per + dm;
        *plus_dm++ = dmup;
        *minus_dm++ = dmdown;
    }
    assert(plus_dm - outputs[0] == size - ti_dm_start(options));
    assert(minus_dm - outputs[1] == size - ti_dm_start(options));
    return 0;
}
int ti_dpo_start(double const *options) {
    return (int)options[0]-1;
}
int ti_dpo(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    const int back = period / 2 + 1;
    double *output = outputs[0];
    const double scale = 1.0 / period;
    if (period < 1) return 1;
    if (size <= ti_dpo_start(options)) return 0;
    double sum = 0;
    int i;
    for (i = 0; i < period; ++i) {
        sum += input[i];
    }
    *output++ = input[period-1-back] - (sum * scale);
    for (i = period; i < size; ++i) {
        sum += input[i];
        sum -= input[i-period];
        *output++ = input[i-back] - (sum * scale);
    }
    assert(output - outputs[0] == size - ti_dpo_start(options));
    return 0;
}
int ti_dx_start(double const *options) {
    return (int)options[0]-1;
}
int ti_dx(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_dx_start(options)) return 0;
    const double per = ((double)period-1) / ((double)period);
    double dmup = 0;
    double dmdown = 0;
    int i;
    for (i = 1; i < period; ++i) {
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup += dp;
        dmdown += dm;
    }
    {
        double di_up = dmup;
        double di_down = dmdown;
        double dm_diff = fabs(di_up - di_down);
        double dm_sum = di_up + di_down;
        double dx = dm_diff / dm_sum * 100;
        *output++ = dx;
    }
    for (i = period; i < size; ++i) {
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup = dmup * per + dp;
        dmdown = dmdown * per + dm;
        double di_up = dmup;
        double di_down = dmdown;
        double dm_diff = fabs(di_up - di_down);
        double dm_sum = di_up + di_down;
        double dx = dm_diff / dm_sum * 100;
        *output++ = dx;
    }
    assert(output - outputs[0] == size - ti_dx_start(options));
    return 0;
}
int ti_edecay_start(double const *options) {
    (void)options;
    return 0;
}
int ti_edecay(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    const double scale = 1.0 - 1.0 / period;
    *output++ = input[0];
    int i;
    for (i = 1; i < size; ++i) {
        double d = output[-1] * scale;
        *output++ = input[i] > d ? input[i] : d;
    }
    return 0;
}
int ti_ema_start(double const *options) {
    (void)options;
    return 0;
}
int ti_ema(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_ema_start(options)) return 0;
    const double per = 2 / ((double)period + 1);
    double val = input[0];
    *output++ = val;
    int i;
    for (i = 1; i < size; ++i) {
        val = (input[i]-val) * per + val;
        *output++ = val;
    }
    assert(output - outputs[0] == size - ti_ema_start(options));
    return 0;
}
int ti_emv_start(double const *options) {
    (void)options;
    return 1;
}
int ti_emv(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *volume = inputs[2];
    (void)options;
    double *output = outputs[0];
    if (size <= ti_emv_start(options)) return 0;
    double last = (high[0] + low[0]) * 0.5;
    int i;
    for (i = 1; i < size; ++i) {
        double hl = (high[i] + low[i]) * 0.5;
        double br = volume[i] / 10000.0 / (high[i] - low[i]);
        *output++ = (hl - last) / br;
        last = hl;
    }
    assert(output - outputs[0] == size - ti_emv_start(options));
    return 0;
}
int ti_exp_start(double const *options) { (void)options; return 0; } int ti_exp(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (exp(in1[i])); } return 0; }
int ti_fisher_start(double const *options) {
    return (int)options[0]-1;
}
int ti_fisher(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    double *fisher = outputs[0];
    double *signal = outputs[1];
    const int period = (int)options[0];
    if (period < 1) return 1;
    if (size <= ti_fisher_start(options)) return 0;
    int trail = 0, maxi = -1, mini = -1;
    double max = (0.5 * (high[(0)] + low[(0)]));
    double min = (0.5 * (high[(0)] + low[(0)]));
    double val1 = 0.0;
    double bar;
    double fish = 0.0;
    int i, j;
    for (i = period-1; i < size; ++i, ++trail) {
        bar = (0.5 * (high[(i)] + low[(i)]));
        if (maxi < trail) {
            maxi = trail;
            max = (0.5 * (high[(maxi)] + low[(maxi)]));
            j = trail;
            while(++j <= i) {
                bar = (0.5 * (high[(j)] + low[(j)]));
                if (bar >= max) {
                    max = bar;
                    maxi = j;
                }
            }
        } else if (bar >= max) {
            maxi = i;
            max = bar;
        }
        bar = (0.5 * (high[(i)] + low[(i)]));
        if (mini < trail) {
            mini = trail;
            min = (0.5 * (high[(mini)] + low[(mini)]));
            j = trail;
            while(++j <= i) {
                bar = (0.5 * (high[(j)] + low[(j)]));
                if (bar <= min) {
                    min = bar;
                    mini = j;
                }
            }
        } else if (bar <= min) {
            mini = i;
            min = bar;
        }
        double mm = max - min;
        if (mm == 0.0) mm = 0.001;
        val1 = 0.33 * 2.0 * ( ((0.5 * (high[(i)] + low[(i)]))-min) / (mm) - 0.5) + 0.67 * val1;
        if (val1 > 0.99) val1 = .999;
        if (val1 < -0.99) val1 = -.999;
        *signal++ = fish;
        fish = 0.5 * log((1.0+val1)/(1.0-val1)) + 0.5 * fish;
        *fisher++ = fish;
    }
    assert(fisher - outputs[0] == size - ti_fisher_start(options));
    assert(signal - outputs[1] == size - ti_fisher_start(options));
    return 0;
}
int ti_floor_start(double const *options) { (void)options; return 0; } int ti_floor(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (floor(in1[i])); } return 0; }
int ti_fosc_start(double const *options) {
    return (int)options[0];
}
int ti_fosc(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_fosc_start(options)) return 0;
    do { double x = 0; double x2 = 0; double y = 0; double xy = 0; const double p = (1.0 / (period)); double tsf = 0;; int i; for (i = 0; i < (period)-1; ++i) { x += i+1; x2 += (i+1)*(i+1); xy += (input)[i] * (i+1); y += (input)[i]; } x += (period); x2 += (period) * (period); const double bd = 1.0 / ((period) * x2 - x * x); for (i = (period)-1; i < (size); ++i) { xy += (input)[i] * (period); y += (input)[i]; const double b = ((period) * xy - x * y) * bd; do { const double a = (y - b * x) * p; if (i >= (period)) {*output++ = 100 * (input[i] - tsf) / input[i];} tsf = (a + b * ((period+1))); } while (0); xy -= y; y -= (input)[i-(period)+1]; } } while (0);
    assert(output - outputs[0] == size - ti_fosc_start(options));
    return 0;
}
int ti_hma_start(double const *options) {
    const int period = (int)options[0];
    const int periodsqrt = (int)(sqrt(period));
    return period + periodsqrt - 2;
}
int ti_hma(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_hma_start(options)) return 0;
    const int period2 = (int)(period / 2);
    const int periodsqrt = (int)(sqrt(period));
    const double weights = period * (period+1) / 2;
    const double weights2 = period2 * (period2+1) / 2;
    const double weightssqrt = periodsqrt * (periodsqrt+1) / 2;
    double sum = 0;
    double weight_sum = 0;
    double sum2 = 0;
    double weight_sum2 = 0;
    double sumsqrt = 0;
    double weight_sumsqrt = 0;
    int i;
    for (i = 0; i < period-1; ++i) {
        weight_sum += input[i] * (i+1);
        sum += input[i];
        if (i >= period - period2) {
            weight_sum2 += input[i] * (i+1-(period-period2));
            sum2 += input[i];
        }
    }
    ti_buffer *buff = ti_buffer_new(periodsqrt);
    for (i = period-1; i < size; ++i) {
        weight_sum += input[i] * period;
        sum += input[i];
        weight_sum2 += input[i] * period2;
        sum2 += input[i];
        const double wma = weight_sum / weights;
        const double wma2 = weight_sum2 / weights2;
        const double diff = 2 * wma2 - wma;
        weight_sumsqrt += diff * periodsqrt;
        sumsqrt += diff;
        do { (buff)->vals[(buff)->index] = (diff); (buff)->index = ((buff)->index + 1); if ((buff)->index >= (buff)->size) (buff)->index = 0; } while (0);
        if (i >= (period-1) + (periodsqrt-1)) {
            *output++ = weight_sumsqrt / weightssqrt;
            weight_sumsqrt -= sumsqrt;
            sumsqrt -= ((buff)->vals[((buff)->index + (buff)->size - 1 + (1)) % (buff)->size]);
        } else {
            weight_sumsqrt -= sumsqrt;
        }
        weight_sum -= sum;
        sum -= input[i-period+1];
        weight_sum2 -= sum2;
        sum2 -= input[i-period2+1];
    }
    ti_buffer_free(buff);
    assert(output - outputs[0] == size - ti_hma_start(options));
    return 0;
}
int ti_kama_start(double const *options) {
    return (int)options[0]-1;
}
int ti_kama(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_kama_start(options)) return 0;
    const double short_per = 2 / (2.0 + 1);
    const double long_per = 2 / (30.0 + 1);
    double sum = 0;
    int i;
    for (i = 1; i < period; ++i) {
        sum += fabs(input[i] - input[i-1]);
    }
    double kama = input[period-1];
    *output++ = kama;
    double er, sc;
    for (i = period; i < size; ++i) {
        sum += fabs(input[i] - input[i-1]);
        if (i > period) {
            sum -= fabs(input[i-period] - input[i-period-1]);
        }
        if (sum != 0.0) {
            er = fabs(input[i] - input[i-period]) / sum;
        } else {
            er = 1.0;
        }
        sc = pow(er * (short_per - long_per) + long_per, 2);
        kama = kama + sc * (input[i] - kama);
        *output++ = kama;
    }
    assert(output - outputs[0] == size - ti_kama_start(options));
    return 0;
}
int ti_kvo_start(double const *options) {
    (void)options;
    return 1;
}
int ti_kvo(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const double *volume = inputs[3];
    const int short_period = (int)options[0];
    const int long_period = (int)options[1];
    if (short_period < 1) return 1;
    if (long_period < short_period) return 1;
    if (size <= ti_kvo_start(options)) return 0;
    const double short_per = 2 / ((double)short_period + 1);
    const double long_per = 2 / ((double)long_period + 1);
    double *output = outputs[0];
    double cm = 0;
    double prev_hlc = high[0] + low[0] + close[0];
    int trend = -1;
    double short_ema = 0, long_ema = 0;
    int i;
    for (i = 1; i < size; ++i) {
        const double hlc = high[i] + low[i] + close[i];
        const double dm = high[i] - low[i];
        if (hlc > prev_hlc && trend != 1) {
            trend = 1;
            cm = high[i-1] - low[i-1];
        } else if (hlc < prev_hlc && trend != 0) {
            trend = 0;
            cm = high[i-1] - low[i-1];
        }
        cm += dm;
        const double vf = volume[i] * fabs(dm / cm * 2 - 1) * 100 * (trend ? 1.0 : -1.0);
        if (i == 1) {
            short_ema = vf;
            long_ema = vf;
        } else {
            short_ema = (vf-short_ema) * short_per + short_ema;
            long_ema = (vf-long_ema) * long_per + long_ema;
        }
        *output++ = short_ema - long_ema;
        prev_hlc = hlc;
    }
    assert(output - outputs[0] == size - ti_kvo_start(options));
    return 0;
}
int ti_lag_start(double const *options) {
    return (int)options[0];
}
int ti_lag(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 0) return 1;
    if (size <= ti_lag_start(options)) return 0;
    int i;
    for (i = period; i < size; ++i) {
        *output++ = input[i-period];
    }
    assert(output - outputs[0] == size - ti_lag_start(options));
    return 0;
}
int ti_linreg_start(double const *options) {
    return (int)options[0]-1;
}
int ti_linreg(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_linreg_start(options)) return 0;
    do { double x = 0; double x2 = 0; double y = 0; double xy = 0; const double p = (1.0 / (period)); int i; for (i = 0; i < (period)-1; ++i) { x += i+1; x2 += (i+1)*(i+1); xy += (input)[i] * (i+1); y += (input)[i]; } x += (period); x2 += (period) * (period); const double bd = 1.0 / ((period) * x2 - x * x); for (i = (period)-1; i < (size); ++i) { xy += (input)[i] * (period); y += (input)[i]; const double b = ((period) * xy - x * y) * bd; do { const double a = (y - b * x) * p; *output++ = (a + b * ((period))); } while (0); xy -= y; y -= (input)[i-(period)+1]; } } while (0);
    assert(output - outputs[0] == size - ti_linreg_start(options));
    return 0;
}
int ti_linregintercept_start(double const *options) {
    return (int)options[0]-1;
}
int ti_linregintercept(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_linregintercept_start(options)) return 0;
    do { double x = 0; double x2 = 0; double y = 0; double xy = 0; const double p = (1.0 / (period)); int i; for (i = 0; i < (period)-1; ++i) { x += i+1; x2 += (i+1)*(i+1); xy += (input)[i] * (i+1); y += (input)[i]; } x += (period); x2 += (period) * (period); const double bd = 1.0 / ((period) * x2 - x * x); for (i = (period)-1; i < (size); ++i) { xy += (input)[i] * (period); y += (input)[i]; const double b = ((period) * xy - x * y) * bd; do { const double a = (y - b * x) * p; *output++ = (a + b * ((1))); } while (0); xy -= y; y -= (input)[i-(period)+1]; } } while (0);
    assert(output - outputs[0] == size - ti_linregintercept_start(options));
    return 0;
}
int ti_linregslope_start(double const *options) {
    return (int)options[0]-1;
}
int ti_linregslope(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_linregslope_start(options)) return 0;
    do { double x = 0; double x2 = 0; double y = 0; double xy = 0; do{}while(0); int i; for (i = 0; i < (period)-1; ++i) { x += i+1; x2 += (i+1)*(i+1); xy += (input)[i] * (i+1); y += (input)[i]; } x += (period); x2 += (period) * (period); const double bd = 1.0 / ((period) * x2 - x * x); for (i = (period)-1; i < (size); ++i) { xy += (input)[i] * (period); y += (input)[i]; const double b = ((period) * xy - x * y) * bd; do { *output++ = b; } while (0); xy -= y; y -= (input)[i-(period)+1]; } } while (0);
    assert(output - outputs[0] == size - ti_linregslope_start(options));
    return 0;
}
int ti_ln_start(double const *options) { (void)options; return 0; } int ti_ln(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (log(in1[i])); } return 0; }
int ti_log10_start(double const *options) { (void)options; return 0; } int ti_log10(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (log10(in1[i])); } return 0; }
int ti_macd_start(double const *options) {
    const int long_period = (int)options[1];
    return (long_period-1);
}
int ti_macd(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    double *macd = outputs[0];
    double *signal = outputs[1];
    double *hist = outputs[2];
    const int short_period = (int)options[0];
    const int long_period = (int)options[1];
    const int signal_period = (int)options[2];
    if (short_period < 1) return 1;
    if (long_period < 2) return 1;
    if (long_period < short_period) return 1;
    if (signal_period < 1) return 1;
    if (size <= ti_macd_start(options)) return 0;
    double short_per = 2 / ((double)short_period + 1);
    double long_per = 2 / ((double)long_period + 1);
    double signal_per = 2 / ((double)signal_period + 1);
    if (short_period == 12 && long_period == 26) {
        short_per = 0.15;
        long_per = 0.075;
    }
    double short_ema = input[0];
    double long_ema = input[0];
    double signal_ema = 0;
    int i;
    for (i = 1; i < size; ++i) {
        short_ema = (input[i]-short_ema) * short_per + short_ema;
        long_ema = (input[i]-long_ema) * long_per + long_ema;
        const double out = short_ema - long_ema;
        if (i == long_period-1) {
            signal_ema = out;
        }
        if (i >= long_period-1) {
            signal_ema = (out-signal_ema) * signal_per + signal_ema;
            *macd++ = out;
            *signal++ = signal_ema;
            *hist++ = out - signal_ema;
        }
    }
    assert(macd - outputs[0] == size - ti_macd_start(options));
    assert(signal - outputs[1] == size - ti_macd_start(options));
    assert(hist - outputs[2] == size - ti_macd_start(options));
    return 0;
}
int ti_marketfi_start(double const *options) {
    (void)options;
    return 0;
}
int ti_marketfi(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *volume = inputs[2];
    (void)options;
    double *output = outputs[0];
    if (size <= ti_marketfi_start(options)) return 0;
    int i;
    for (i = 0; i < size; ++i) {
        *output++ = (high[i] - low[i]) / volume[i];
    }
    assert(output - outputs[0] == size - ti_marketfi_start(options));
    return 0;
}
int ti_mass_start(double const *options) {
    int sum_p = (int)options[0]-1;
    return 16 + sum_p;
}
int ti_mass(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_mass_start(options)) return 0;
    const double per = 2 / (9.0 + 1);
    const double per1 = 1.0 - per;
    double ema = high[0] - low[0];
    double ema2 = ema;
    ti_buffer *sum = ti_buffer_new(period);
    int i;
    for (i = 0; i < size; ++i) {
        double hl = high[i] - low[i];
        ema = ema * per1 + hl * per;
        if (i == 8) {
            ema2 = ema;
        }
        if (i >= 8) {
            ema2 = ema2 * per1 + ema * per;
            if (i >= 16) {
                do { if ((sum)->pushes >= (sum)->size) { (sum)->sum -= (sum)->vals[(sum)->index]; } (sum)->sum += (ema/ema2); (sum)->vals[(sum)->index] = (ema/ema2); (sum)->pushes += 1; (sum)->index = ((sum)->index + 1); if ((sum)->index >= (sum)->size) (sum)->index = 0; } while (0);
                if (i >= 16 + period - 1) {
                    *output++ = sum->sum;
                }
            }
        }
    }
    ti_buffer_free(sum);
    assert(output - outputs[0] == size - ti_mass_start(options));
    return 0;
}
int ti_max_start(double const *options) {
    return (int)options[0]-1;
}
int ti_max(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_max_start(options)) return 0;
    int trail = 0, maxi = -1;
    double max = input[0];
    int i, j;
    for (i = period-1; i < size; ++i, ++trail) {
        double bar = input[i];
        if (maxi < trail) {
            maxi = trail;
            max = input[maxi];
            j = trail;
            while(++j <= i) {
                bar = input[j];
                if (bar >= max) {
                    max = bar;
                    maxi = j;
                }
            }
        } else if (bar >= max) {
            maxi = i;
            max = bar;
        }
        *output++ = max;
    }
    assert(output - outputs[0] == size - ti_max_start(options));
    return 0;
}
int ti_max_ref(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_max_start(options)) return 0;
    for (int i = period-1; i < size; ++i) {
        double max = input[i-period+1];
        for (int j = i-period+2; j <= i; ++j) {
            max = ((max) > (input[j]) ? (max) : (input[j]));
        }
        *output++ = max;
    }
    return 0;
}
int ti_md_start(double const *options) {
    return (int)options[0]-1;
}
int ti_md(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    const double scale = 1.0 / period;
    if (period < 1) return 1;
    if (size <= ti_md_start(options)) return 0;
    double sum = 0;
    int i, j;
    for (i = 0; i < size; ++i) {
        const double today = input[i];
        sum += today;
        if (i >= period) sum -= input[i-period];
        const double avg = sum * scale;
        if (i >= period - 1) {
            double acc = 0;
            for (j = 0; j < period; ++j) {
                acc += fabs(avg - input[i-j]);
            }
            *output++ = acc * scale;
        }
    }
    assert(output - outputs[0] == size - ti_md_start(options));
    return 0;
}
int ti_medprice_start(double const *options) {
    (void)options;
    return 0;
}
int ti_medprice(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    (void)options;
    double *output = outputs[0];
    int i;
    for (i = 0; i < size; ++i) {
        output[i] = (high[i] + low[i]) * 0.5;
    }
    return 0;
}
int ti_mfi_start(double const *options) {
    return (int)options[0];
}
int ti_mfi(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const double *volume = inputs[3];
    const int period = (int)options[0];
    if (period < 1) return 1;
    if (size <= ti_mfi_start(options)) return 0;
    double *output = outputs[0];
    double ytyp = ((high[(0)] + low[(0)] + close[(0)]) * (1.0/3.0));
    int i;
    ti_buffer *up = ti_buffer_new(period);
    ti_buffer *down = ti_buffer_new(period);
    for (i = 1; i < size; ++i) {
        const double typ = ((high[(i)] + low[(i)] + close[(i)]) * (1.0/3.0));
        const double bar = typ * volume[i];
        if (typ > ytyp) {
            do { if ((up)->pushes >= (up)->size) { (up)->sum -= (up)->vals[(up)->index]; } (up)->sum += (bar); (up)->vals[(up)->index] = (bar); (up)->pushes += 1; (up)->index = ((up)->index + 1); if ((up)->index >= (up)->size) (up)->index = 0; } while (0);
            do { if ((down)->pushes >= (down)->size) { (down)->sum -= (down)->vals[(down)->index]; } (down)->sum += (0.0); (down)->vals[(down)->index] = (0.0); (down)->pushes += 1; (down)->index = ((down)->index + 1); if ((down)->index >= (down)->size) (down)->index = 0; } while (0);
        } else if (typ < ytyp) {
            do { if ((down)->pushes >= (down)->size) { (down)->sum -= (down)->vals[(down)->index]; } (down)->sum += (bar); (down)->vals[(down)->index] = (bar); (down)->pushes += 1; (down)->index = ((down)->index + 1); if ((down)->index >= (down)->size) (down)->index = 0; } while (0);
            do { if ((up)->pushes >= (up)->size) { (up)->sum -= (up)->vals[(up)->index]; } (up)->sum += (0.0); (up)->vals[(up)->index] = (0.0); (up)->pushes += 1; (up)->index = ((up)->index + 1); if ((up)->index >= (up)->size) (up)->index = 0; } while (0);
        } else {
            do { if ((up)->pushes >= (up)->size) { (up)->sum -= (up)->vals[(up)->index]; } (up)->sum += (0.0); (up)->vals[(up)->index] = (0.0); (up)->pushes += 1; (up)->index = ((up)->index + 1); if ((up)->index >= (up)->size) (up)->index = 0; } while (0);
            do { if ((down)->pushes >= (down)->size) { (down)->sum -= (down)->vals[(down)->index]; } (down)->sum += (0.0); (down)->vals[(down)->index] = (0.0); (down)->pushes += 1; (down)->index = ((down)->index + 1); if ((down)->index >= (down)->size) (down)->index = 0; } while (0);
        }
        ytyp = typ;
        if (i >= period) {
            *output++ = up->sum / (up->sum + down->sum) * 100.0;
        }
    }
    ti_buffer_free(up);
    ti_buffer_free(down);
    assert(output - outputs[0] == size - ti_mfi_start(options));
    return 0;
}
int ti_min_start(double const *options) {
    return (int)options[0]-1;
}
int ti_min(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_min_start(options)) return 0;
    int trail = 0, mini = -1;
    double min = input[0];
    int i, j;
    for (i = period-1; i < size; ++i, ++trail) {
        double bar = input[i];
        if (mini < trail) {
            mini = trail;
            min = input[mini];
            j = trail;
            while(++j <= i) {
                bar = input[j];
                if (bar <= min) {
                    min = bar;
                    mini = j;
                }
            }
        } else if (bar <= min) {
            mini = i;
            min = bar;
        }
        *output++ = min;
    }
    assert(output - outputs[0] == size - ti_min_start(options));
    return 0;
}
int ti_min_ref(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_min_start(options)) return 0;
    for (int i = period-1; i < size; ++i) {
        double min = input[i-period+1];
        for (int j = i-period+2; j <= i; ++j) {
            min = ((min) < (input[j]) ? (min) : (input[j]));
        }
        *output++ = min;
    }
    assert(output - outputs[0] == size - ti_min_start(options));
    return 0;
}
int ti_mom_start(double const *options) {
    return (int)options[0];
}
int ti_mom(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_mom_start(options)) return 0;
    int i;
    for (i = period; i < size; ++i) {
        *output++ = input[i] - input[i-period];
    }
    assert(output - outputs[0] == size - ti_mom_start(options));
    return 0;
}
int ti_msw_start(double const *options) {
    return (int)options[0];
}
int ti_msw(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    double *sine = outputs[0];
    double *lead = outputs[1];
    const int period = (int)options[0];
    if (period < 1) return 1;
    if (size <= ti_msw_start(options)) return 0;
    const double pi = 3.1415926;
    const double tpi = 2 * pi;
    double weight = 0, phase;
    double rp, ip;
    int i, j;
    for (i = period; i < size; ++i) {
        rp = 0;
        ip = 0;
        for (j = 0; j < period; ++j) {
            weight = input[i-j];
            rp = rp + cos(tpi * j / period) * weight;
            ip = ip + sin(tpi * j / period) * weight;
        }
        if (fabs(rp) > .001) {
            phase = atan(ip/rp);
        } else {
            phase = tpi / 2.0 * (ip < 0 ? -1.0 : 1.0);
        }
        if (rp < 0.0) phase += pi;
        phase += pi/2.0;
        if (phase < 0.0) phase += tpi;
        if (phase > tpi) phase -= tpi;
        *sine++ = sin(phase);
        *lead++ = sin(phase + pi/4.0);
    }
    assert(sine - outputs[0] == size - ti_msw_start(options));
    assert(lead - outputs[1] == size - ti_msw_start(options));
    return 0;
}
int ti_mul_start(double const *options) { (void)options; return 0; } int ti_mul(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; const double *in2 = inputs[1]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (in1[i] * in2[i]); } return 0; }
int ti_natr_start(double const *options) {
    return (int)options[0]-1;
}
int ti_natr(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_natr_start(options)) return 0;
    const double per = 1.0 / ((double)period);
    double sum = 0;
    double truerange;
    sum += high[0] - low[0];
    int i;
    for (i = 1; i < period; ++i) {
        do{ const double l = low[i]; const double h = high[i]; const double c = close[i-1]; const double ych = fabs(h - c); const double ycl = fabs(l - c); double v = h - l; if (ych > v) v = ych; if (ycl > v) v = ycl; truerange = v;}while(0);
        sum += truerange;
    }
    double val = sum / period;
    *output++ = 100 * (val) / close[period-1];
    for (i = period; i < size; ++i) {
        do{ const double l = low[i]; const double h = high[i]; const double c = close[i-1]; const double ych = fabs(h - c); const double ycl = fabs(l - c); double v = h - l; if (ych > v) v = ych; if (ycl > v) v = ycl; truerange = v;}while(0);
        val = (truerange-val) * per + val;
        *output++ = 100 * (val) / close[i];
    }
    assert(output - outputs[0] == size - ti_natr_start(options));
    return 0;
}
int ti_nvi_start(double const *options) {
    (void)options;
    return 0;
}
int ti_nvi(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *close = inputs[0];
    const double *volume = inputs[1];
    (void)options;
    double *output = outputs[0];
    if (size <= ti_nvi_start(options)) return 0;
    double nvi = 1000;
    *output++ = nvi;
    int i;
    for (i = 1; i < size; ++i) {
        if (volume[i] < volume[i-1]) {
            nvi += ((close[i] - close[i-1])/close[i-1]) * nvi;
        }
        *output++ = nvi;
    }
    assert(output - outputs[0] == size - ti_nvi_start(options));
    return 0;
}
int ti_obv_start(double const *options) {
    (void)options;
    return 0;
}
int ti_obv(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *close = inputs[0];
    const double *volume = inputs[1];
    (void)options;
    double *output = outputs[0];
    double sum = 0;
    *output++ = sum;
    double prev = close[0];
    int i;
    for (i = 1; i < size; ++i) {
        if (close[i] > prev) {
            sum += volume[i];
        } else if (close[i] < prev) {
            sum -= volume[i];
        } else {
        }
        prev = close[i];
        *output++ = sum;
    }
    return 0;
}
int ti_ppo_start(double const *options) {
    (void)options;
    return 1;
}
int ti_ppo(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    double *ppo = outputs[0];
    const int short_period = (int)options[0];
    const int long_period = (int)options[1];
    if (short_period < 1) return 1;
    if (long_period < 2) return 1;
    if (long_period < short_period) return 1;
    if (size <= ti_ppo_start(options)) return 0;
    double short_per = 2 / ((double)short_period + 1);
    double long_per = 2 / ((double)long_period + 1);
    double short_ema = input[0];
    double long_ema = input[0];
    int i;
    for (i = 1; i < size; ++i) {
        short_ema = (input[i]-short_ema) * short_per + short_ema;
        long_ema = (input[i]-long_ema) * long_per + long_ema;
        const double out = 100.0 * (short_ema - long_ema) / long_ema;
        *ppo++ = out;
    }
    assert(ppo - outputs[0] == size - ti_ppo_start(options));
    return 0;
}
int ti_psar_start(double const *options) {
    (void)options;
    return 1;
}
int ti_psar(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double accel_step = options[0];
    const double accel_max = options[1];
    double *output = outputs[0];
    if (accel_step <= 0) return 1;
    if (accel_max <= accel_step) return 1;
    if (size < 2) return 0;
    int lng;
    if (high[0] + low[0] <= high[1] + low[1])
        lng = 1;
    else
        lng = 0;
    double sar, extreme;
    if (lng) {
        extreme = high[0];
        sar = low[0];
    } else {
        extreme = low[0];
        sar = high[0];
    }
    double accel = accel_step;
    int i;
    for (i = 1; i < size; ++i) {
        sar = (extreme - sar) * accel + sar;
        if (lng) {
            if (i >= 2 && (sar > low[i-2])) sar = low[i-2];
            if ((sar > low[i-1])) sar = low[i-1];
            if (accel < accel_max && high[i] > extreme) {
                accel += accel_step;
                if (accel > accel_max) accel = accel_max;
            }
            if (high[i] > extreme) extreme = high[i];
        } else {
            if (i >= 2 && (sar < high[i-2])) sar = high[i-2];
            if ((sar < high[i-1])) sar = high[i-1];
            if (accel < accel_max && low[i] < extreme) {
                accel += accel_step;
                if (accel > accel_max) accel = accel_max;
            }
            if (low[i] < extreme) extreme = low[i];
        }
        if ((lng && low[i] < sar) || (!lng && high[i] > sar)) {
            accel = accel_step;
            sar = extreme;
            lng = !lng;
            if (!lng) extreme = low[i];
            else extreme = high[i];
        }
        *output++ = sar;
    }
    assert(output - outputs[0] == size - ti_psar_start(options));
    return 0;
}
int ti_pvi_start(double const *options) {
    (void)options;
    return 0;
}
int ti_pvi(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *close = inputs[0];
    const double *volume = inputs[1];
    (void)options;
    double *output = outputs[0];
    if (size <= ti_pvi_start(options)) return 0;
    double pvi = 1000;
    *output++ = pvi;
    int i;
    for (i = 1; i < size; ++i) {
        if (volume[i] > volume[i-1]) {
            pvi += ((close[i] - close[i-1])/close[i-1]) * pvi;
        }
        *output++ = pvi;
    }
    assert(output - outputs[0] == size - ti_pvi_start(options));
    return 0;
}
int ti_qstick_start(double const *options) {
    return (int)options[0]-1;
}
int ti_qstick(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *open = inputs[0];
    const double *close = inputs[1];
    double *output = outputs[0];
    const int period = (int)options[0];
    const double scale = 1.0 / period;
    if (period < 1) return 1;
    if (size <= ti_qstick_start(options)) return 0;
    double sum = 0;
    int i;
    for (i = 0; i < period; ++i) {
        sum += close[i] - open[i];
    }
    *output++ = sum * scale;
    for (i = period; i < size; ++i) {
        sum += close[i] - open[i];
        sum -= close[i-period] - open[i-period];
        *output++ = sum * scale;
    }
    assert(output - outputs[0] == size - ti_qstick_start(options));
    return 0;
}
int ti_roc_start(double const *options) {
    return (int)options[0];
}
int ti_roc(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_roc_start(options)) return 0;
    int i;
    for (i = period; i < size; ++i) {
        *output++ = (input[i] - input[i-period]) / input[i-period];
    }
    assert(output - outputs[0] == size - ti_roc_start(options));
    return 0;
}
int ti_rocr_start(double const *options) {
    return (int)options[0];
}
int ti_rocr(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_rocr_start(options)) return 0;
    int i;
    for (i = period; i < size; ++i) {
        *output++ = input[i] / input[i-period];
    }
    assert(output - outputs[0] == size - ti_rocr_start(options));
    return 0;
}
int ti_round_start(double const *options) { (void)options; return 0; } int ti_round(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (floor(in1[i] + 0.5)); } return 0; }
int ti_rsi_start(double const *options) {
    return (int)options[0];
}
int ti_rsi(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    const double per = 1.0 / ((double)period);
    if (period < 1) return 1;
    if (size <= ti_rsi_start(options)) return 0;
    double smooth_up = 0, smooth_down = 0;
    int i;
    for (i = 1; i <= period; ++i) {
        const double upward = input[i] > input[i-1] ? input[i] - input[i-1] : 0;
        const double downward = input[i] < input[i-1] ? input[i-1] - input[i] : 0;
        smooth_up += upward;
        smooth_down += downward;
    }
    smooth_up /= period;
    smooth_down /= period;
    *output++ = 100.0 * (smooth_up / (smooth_up + smooth_down));
    for (i = period+1; i < size; ++i) {
        const double upward = input[i] > input[i-1] ? input[i] - input[i-1] : 0;
        const double downward = input[i] < input[i-1] ? input[i-1] - input[i] : 0;
        smooth_up = (upward-smooth_up) * per + smooth_up;
        smooth_down = (downward-smooth_down) * per + smooth_down;
        *output++ = 100.0 * (smooth_up / (smooth_up + smooth_down));
    }
    assert(output - outputs[0] == size - ti_rsi_start(options));
    return 0;
}
int ti_sin_start(double const *options) { (void)options; return 0; } int ti_sin(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (sin(in1[i])); } return 0; }
int ti_sinh_start(double const *options) { (void)options; return 0; } int ti_sinh(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (sinh(in1[i])); } return 0; }
int ti_sma_start(double const *options) {
    return (int)options[0]-1;
}
int ti_sma(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    const double scale = 1.0 / period;
    if (period < 1) return 1;
    if (size <= ti_sma_start(options)) return 0;
    double sum = 0;
    int i;
    for (i = 0; i < period; ++i) {
        sum += input[i];
    }
    *output++ = sum * scale;
    for (i = period; i < size; ++i) {
        sum += input[i];
        sum -= input[i-period];
        *output++ = sum * scale;
    }
    assert(output - outputs[0] == size - ti_sma_start(options));
    return 0;
}
typedef struct ti_stream_sma {
    int index;
    int progress;
    int period;
    double per;
    double sum;
    int buffer_idx;
    double buffer[];
} ti_stream_sma;
int ti_sma_stream_new(double const *options, ti_stream **stream_in) {
    ti_stream_sma **stream = (ti_stream_sma**)stream_in;
    int period = (int)options[0];
    if (period < 1) return 1;
    *stream = malloc(sizeof(ti_stream_sma) + sizeof(double) * period);
    if (!stream) {
        return 2;
    }
    (*stream)->index = 72;
    (*stream)->progress = -ti_sma_start(options);
    (*stream)->period = period;
    (*stream)->per = 1. / period;
    (*stream)->sum = 0.;
    (*stream)->buffer_idx = -1;
    return 0;
}
int ti_sma_stream_run(ti_stream *stream_in, int size, double const *const *inputs, double *const *outputs) {
    ti_stream_sma *stream = (ti_stream_sma*)stream_in;
    int progress = stream->progress;
    const double *real = inputs[0];
    int period = stream->period;
    double *sma = outputs[0];
    double per = stream->per;
    double sum = stream->sum;
    int buffer_idx = stream->buffer_idx;
    double *buffer = stream->buffer;
    if (progress == -period + 1) {} else {}
    int i;
    for (i = 0; progress < 1 && i < size; ++i, ++progress) {
        { ++buffer_idx; sum += buffer[buffer_idx] = real[i] * per; };
    }
    if (i > 0 && progress == 1) {
        *sma++ = sum;
    }
    for (; i < size; ++i, ++progress) {
        { ++buffer_idx; if (buffer_idx == period) { buffer_idx = 0; } sum -= buffer[buffer_idx]; sum += buffer[buffer_idx] = real[i] * per; };
        *sma++ = sum;
    }
    stream->progress = progress;
    stream->sum = sum;
    stream->buffer_idx = buffer_idx;
    return 0;
}
void ti_sma_stream_free(ti_stream *stream) {
    free(stream);
}
int ti_sqrt_start(double const *options) { (void)options; return 0; } int ti_sqrt(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (sqrt(in1[i])); } return 0; }
int ti_stddev_start(double const *options) {
    return (int)options[0]-1;
}
int ti_stddev(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    const double scale = 1.0 / period;
    if (period < 1) return 1;
    if (size <= ti_stddev_start(options)) return 0;
    double sum = 0;
    double sum2 = 0;
    int i;
    for (i = 0; i < period; ++i) {
        sum += input[i];
        sum2 += input[i] * input[i];
    }
    {
        double s2s2 = (sum2 * scale - (sum * scale) * (sum * scale));
        if (s2s2 > 0.0) s2s2 = sqrt(s2s2);
        *output++ = s2s2;
    }
    for (i = period; i < size; ++i) {
        sum += input[i];
        sum2 += input[i] * input[i];
        sum -= input[i-period];
        sum2 -= input[i-period] * input[i-period];
        double s2s2 = (sum2 * scale - (sum * scale) * (sum * scale));
        if (s2s2 > 0.0) s2s2 = sqrt(s2s2);
        *output++ = s2s2;
    }
    assert(output - outputs[0] == size - ti_stddev_start(options));
    return 0;
}
int ti_stderr_start(double const *options) {
    return (int)options[0]-1;
}
int ti_stderr(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    const double scale = 1.0 / period;
    if (period < 1) return 1;
    if (size <= ti_stderr_start(options)) return 0;
    double sum = 0;
    double sum2 = 0;
    const double mul = 1.0 / sqrt(period);
    int i;
    for (i = 0; i < period; ++i) {
        sum += input[i];
        sum2 += input[i] * input[i];
    }
    {
        double s2s2 = (sum2 * scale - (sum * scale) * (sum * scale));
        if (s2s2 > 0.0) s2s2 = sqrt(s2s2);
        *output++ = mul * s2s2;
    }
    for (i = period; i < size; ++i) {
        sum += input[i];
        sum2 += input[i] * input[i];
        sum -= input[i-period];
        sum2 -= input[i-period] * input[i-period];
        double s2s2 = (sum2 * scale - (sum * scale) * (sum * scale));
        if (s2s2 > 0.0) s2s2 = sqrt(s2s2);
        *output++ = mul * s2s2;
    }
    assert(output - outputs[0] == size - ti_stderr_start(options));
    return 0;
}
int ti_stoch_start(double const *options) {
    const int kperiod = (int)options[0];
    const int kslow = (int)options[1];
    const int dperiod = (int)options[2];
    return kperiod + kslow + dperiod - 3;
}
int ti_stoch(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const int kperiod = (int)options[0];
    const int kslow = (int)options[1];
    const int dperiod = (int)options[2];
    const double kper = 1.0 / kslow;
    const double dper = 1.0 / dperiod;
    double *stoch = outputs[0];
    double *stoch_ma = outputs[1];
    if (kperiod < 1) return 1;
    if (kslow < 1) return 1;
    if (dperiod < 1) return 1;
    if (size <= ti_stoch_start(options)) return 0;
    int trail = 0, maxi = -1, mini = -1;
    double max = high[0];
    double min = low[0];
    double bar;
    ti_buffer *k_sum = ti_buffer_new(kslow);
    ti_buffer *d_sum = ti_buffer_new(dperiod);
    int i, j;
    for (i = 0; i < size; ++i) {
        if (i >= kperiod) ++trail;
        bar = high[i];
        if (maxi < trail) {
            maxi = trail;
            max = high[maxi];
            j = trail;
            while(++j <= i) {
                bar = high[j];
                if (bar >= max) {
                    max = bar;
                    maxi = j;
                }
            }
        } else if (bar >= max) {
            maxi = i;
            max = bar;
        }
        bar = low[i];
        if (mini < trail) {
            mini = trail;
            min = low[mini];
            j = trail;
            while(++j <= i) {
                bar = low[j];
                if (bar <= min) {
                    min = bar;
                    mini = j;
                }
            }
        } else if (bar <= min) {
            mini = i;
            min = bar;
        }
        const double kdiff = (max - min);
        const double kfast = kdiff == 0.0 ? 0.0 : 100 * ((close[i] - min) / kdiff);
        do { if ((k_sum)->pushes >= (k_sum)->size) { (k_sum)->sum -= (k_sum)->vals[(k_sum)->index]; } (k_sum)->sum += (kfast); (k_sum)->vals[(k_sum)->index] = (kfast); (k_sum)->pushes += 1; (k_sum)->index = ((k_sum)->index + 1); if ((k_sum)->index >= (k_sum)->size) (k_sum)->index = 0; } while (0);
        if (i >= kperiod-1 + kslow-1) {
            const double k = k_sum->sum * kper;
            do { if ((d_sum)->pushes >= (d_sum)->size) { (d_sum)->sum -= (d_sum)->vals[(d_sum)->index]; } (d_sum)->sum += (k); (d_sum)->vals[(d_sum)->index] = (k); (d_sum)->pushes += 1; (d_sum)->index = ((d_sum)->index + 1); if ((d_sum)->index >= (d_sum)->size) (d_sum)->index = 0; } while (0);
            if (i >= kperiod-1 + kslow-1 + dperiod-1) {
                *stoch++ = k;
                *stoch_ma++ = d_sum->sum * dper;
            }
        }
    }
    ti_buffer_free(k_sum);
    ti_buffer_free(d_sum);
    assert(stoch - outputs[0] == size - ti_stoch_start(options));
    assert(stoch_ma - outputs[1] == size - ti_stoch_start(options));
    return 0;
}
int ti_stochrsi_start(double const *options) {
    return ((int)options[0]) * 2 - 1;
}
int ti_stochrsi(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    const double per = 1.0 / ((double)period);
    if (period < 2) return 1;
    if (size <= ti_stochrsi_start(options)) return 0;
    ti_buffer *rsi = ti_buffer_new(period);
    double smooth_up = 0, smooth_down = 0;
    int i;
    for (i = 1; i <= period; ++i) {
        const double upward = input[i] > input[i-1] ? input[i] - input[i-1] : 0;
        const double downward = input[i] < input[i-1] ? input[i-1] - input[i] : 0;
        smooth_up += upward;
        smooth_down += downward;
    }
    smooth_up /= period;
    smooth_down /= period;
    double r = 100.0 * (smooth_up / (smooth_up + smooth_down));
    do { if ((rsi)->pushes >= (rsi)->size) { (rsi)->sum -= (rsi)->vals[(rsi)->index]; } (rsi)->sum += (r); (rsi)->vals[(rsi)->index] = (r); (rsi)->pushes += 1; (rsi)->index = ((rsi)->index + 1); if ((rsi)->index >= (rsi)->size) (rsi)->index = 0; } while (0);
    double min = r;
    double max = r;
    int mini = 0;
    int maxi = 0;
    for (i = period+1; i < size; ++i) {
        const double upward = input[i] > input[i-1] ? input[i] - input[i-1] : 0;
        const double downward = input[i] < input[i-1] ? input[i-1] - input[i] : 0;
        smooth_up = (upward-smooth_up) * per + smooth_up;
        smooth_down = (downward-smooth_down) * per + smooth_down;
        r = 100.0 * (smooth_up / (smooth_up + smooth_down));
        if (r > max) {
            max = r;
            maxi = rsi->index;
        } else if (maxi == rsi->index) {
            max = r;
            int j;
            for (j = 0; j < rsi->size; ++j) {
                if (j == rsi->index) continue;
                if (rsi->vals[j] > max) {
                    max = rsi->vals[j];
                    maxi = j;
                }
            }
        }
        if (r < min) {
            min = r;
            mini = rsi->index;
        } else if (mini == rsi->index) {
            min = r;
            int j;
            for (j = 0; j < rsi->size; ++j) {
                if (j == rsi->index) continue;
                if (rsi->vals[j] < min) {
                    min = rsi->vals[j];
                    mini = j;
                }
            }
        }
        do { (rsi)->vals[(rsi)->index] = (r); (rsi)->index = ((rsi)->index + 1); if ((rsi)->index >= (rsi)->size) (rsi)->index = 0; } while (0);
        if (i > period*2 - 2) {
            const double diff = max - min;
            if (diff == 0.0) {
                *output++ = 0.0;
            } else {
                *output++ = (r - min) / (diff);
            }
        }
    }
    ti_buffer_free(rsi);
    assert(output - outputs[0] == size - ti_stochrsi_start(options));
    return 0;
}
int ti_sub_start(double const *options) { (void)options; return 0; } int ti_sub(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; const double *in2 = inputs[1]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (in1[i] - in2[i]); } return 0; }
int ti_sum_start(double const *options) {
    return (int)options[0]-1;
}
int ti_sum(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_sum_start(options)) return 0;
    double sum = 0;
    int i;
    for (i = 0; i < period; ++i) {
        sum += input[i];
    }
    *output++ = sum;
    for (i = period; i < size; ++i) {
        sum += input[i];
        sum -= input[i-period];
        *output++ = sum;
    }
    assert(output - outputs[0] == size - ti_sum_start(options));
    return 0;
}
int ti_tan_start(double const *options) { (void)options; return 0; } int ti_tan(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (tan(in1[i])); } return 0; }
int ti_tanh_start(double const *options) { (void)options; return 0; } int ti_tanh(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (tanh(in1[i])); } return 0; }
int ti_tema_start(double const *options) {
    const int period = (int)options[0];
    return (period-1) * 3;
}
int ti_tema(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_tema_start(options)) return 0;
    const double per = 2 / ((double)period + 1);
    const double per1 = 1.0 - per;
    double ema = input[0];
    double ema2 = 0;
    double ema3 = 0;
    int i;
    for (i = 0; i < size; ++i) {
        ema = ema * per1 + input[i] * per;
        if (i == period-1) {
            ema2 = ema;
        }
        if (i >= period-1) {
            ema2 = ema2 * per1 + ema * per;
            if (i == (period-1) * 2) {
                ema3 = ema2;
            }
            if (i >= (period-1) * 2) {
                ema3 = ema3 * per1 + ema2 * per;
                if (i >= (period-1) * 3) {
                    *output = 3 * ema - 3 * ema2 + ema3;
                    ++output;
                }
            }
        }
    }
    assert(output - outputs[0] == size - ti_tema_start(options));
    return 0;
}
int ti_todeg_start(double const *options) { (void)options; return 0; } int ti_todeg(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = ((in1[i] * (180.0 / 3.14159265358979323846))); } return 0; }
int ti_torad_start(double const *options) { (void)options; return 0; } int ti_torad(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = ((in1[i] * (3.14159265358979323846 / 180.0))); } return 0; }
int ti_tr_start(double const *options) {
    (void)options;
    return 0;
}
int ti_tr(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    (void)options;
    double *output = outputs[0];
    double truerange;
    output[0] = high[0] - low[0];
    int i;
    for (i = 1; i < size; ++i) {
        do{ const double l = low[i]; const double h = high[i]; const double c = close[i-1]; const double ych = fabs(h - c); const double ycl = fabs(l - c); double v = h - l; if (ych > v) v = ych; if (ycl > v) v = ycl; truerange = v;}while(0);
        output[i] = truerange;
    }
    return 0;
}
int ti_trima_start(double const *options) {
    return (int)options[0]-1;
}
int ti_trima(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_trima_start(options)) return 0;
    if (period <= 2) return ti_sma(size, inputs, options, outputs);
    double weights = 1 / (double) ((period%2) ?
        ((period/2+1) * (period/2+1)):
        ((period/2+1) * (period/2)));
    double weight_sum = 0;
    double lead_sum = 0;
    double trail_sum = 0;
    const int lead_period = period%2 ? period/2 : period/2-1;
    const int trail_period = lead_period + 1;
    int i, w = 1;
    for (i = 0; i < period-1; ++i) {
        weight_sum += input[i] * w;
        if (i+1 > period-lead_period) lead_sum += input[i];
        if (i+1 <= trail_period) trail_sum += input[i];
        if (i+1 < trail_period) ++w;
        if (i+1 >= period-lead_period) --w;
    }
    int lsi = (period-1)-lead_period+1;
    int tsi1 = (period-1)-period+1+trail_period;
    int tsi2 = (period-1)-period+1;
    for (i = period-1; i < size; ++i) {
        weight_sum += input[i];
        *output++ = weight_sum * weights;
        lead_sum += input[i];
        weight_sum += lead_sum;
        weight_sum -= trail_sum;
        lead_sum -= input[lsi++];
        trail_sum += input[tsi1++];
        trail_sum -= input[tsi2++];
    }
    assert(output - outputs[0] == size - ti_trima_start(options));
    return 0;
}
int ti_trix_start(double const *options) {
    const int period = (int)options[0];
    return ((period-1)*3)+1;
}
int ti_trix(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_trix_start(options)) return 0;
    const int start = (period*3)-2;
    assert(start == ti_trix_start(options));
    const double per = 2 / ((double)period + 1);
    double ema1 = input[0];
    double ema2 = 0, ema3 = 0;
    int i;
    for (i = 1; i < start; ++i) {
        ema1 = (input[i]-ema1) * per + ema1;
        if (i == period-1) {
            ema2 = ema1;
        } else if (i > period-1) {
            ema2 = (ema1-ema2) * per + ema2;
            if (i == period * 2 - 2) {
                ema3 = ema2;
            } else if (i > period * 2 - 2) {
                ema3 = (ema2-ema3) * per + ema3;
            }
        }
    }
    for (i = start; i < size; ++i) {
        ema1 = (input[i]-ema1) * per + ema1;
        ema2 = (ema1-ema2) * per + ema2;
        const double last = ema3;
        ema3 = (ema2-ema3) * per + ema3;
        *output++ = (ema3-last)/ema3 * 100.0;
    }
    assert(output - outputs[0] == size - ti_trix_start(options));
    return 0;
}
int ti_trunc_start(double const *options) { (void)options; return 0; } int ti_trunc(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = ((int)(in1[i])); } return 0; }
int ti_tsf_start(double const *options) {
    return (int)options[0]-1;
}
int ti_tsf(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_tsf_start(options)) return 0;
    do { double x = 0; double x2 = 0; double y = 0; double xy = 0; const double p = (1.0 / (period)); int i; for (i = 0; i < (period)-1; ++i) { x += i+1; x2 += (i+1)*(i+1); xy += (input)[i] * (i+1); y += (input)[i]; } x += (period); x2 += (period) * (period); const double bd = 1.0 / ((period) * x2 - x * x); for (i = (period)-1; i < (size); ++i) { xy += (input)[i] * (period); y += (input)[i]; const double b = ((period) * xy - x * y) * bd; do { const double a = (y - b * x) * p; *output++ = (a + b * ((period+1))); } while (0); xy -= y; y -= (input)[i-(period)+1]; } } while (0);
    assert(output - outputs[0] == size - ti_tsf_start(options));
    return 0;
}
int ti_typprice_start(double const *options) {
    (void)options;
    return 0;
}
int ti_typprice(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    (void)options;
    double *output = outputs[0];
    int i;
    for (i = 0; i < size; ++i) {
        output[i] = (high[i] + low[i] + close[i]) * (1.0/3.0);
    }
    return 0;
}
int ti_ultosc_start(double const *options) {
    return (int)options[2];
}
int ti_ultosc(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const int short_period = (int)options[0];
    const int medium_period = (int)options[1];
    const int long_period = (int)options[2];
    double *output = outputs[0];
    if (short_period < 1) return 1;
    if (medium_period < short_period) return 1;
    if (long_period < medium_period) return 1;
    if (size <= ti_ultosc_start(options)) return 0;
    ti_buffer *bp_buf = ti_buffer_new(long_period);
    ti_buffer *r_buf = ti_buffer_new(long_period);
    double bp_short_sum = 0, bp_medium_sum = 0;
    double r_short_sum = 0, r_medium_sum = 0;
    int i;
    for (i = 1; i < size; ++i) {
        const double true_low = ((low[i])<(close[i-1])?(low[i]):(close[i-1]));
        const double true_high = ((high[i])>(close[i-1])?(high[i]):(close[i-1]));
        const double bp = close[i] - true_low;
        const double r = true_high - true_low;
        bp_short_sum += bp;
        bp_medium_sum += bp;
        r_short_sum += r;
        r_medium_sum += r;
        do { if ((bp_buf)->pushes >= (bp_buf)->size) { (bp_buf)->sum -= (bp_buf)->vals[(bp_buf)->index]; } (bp_buf)->sum += (bp); (bp_buf)->vals[(bp_buf)->index] = (bp); (bp_buf)->pushes += 1; (bp_buf)->index = ((bp_buf)->index + 1); if ((bp_buf)->index >= (bp_buf)->size) (bp_buf)->index = 0; } while (0);
        do { if ((r_buf)->pushes >= (r_buf)->size) { (r_buf)->sum -= (r_buf)->vals[(r_buf)->index]; } (r_buf)->sum += (r); (r_buf)->vals[(r_buf)->index] = (r); (r_buf)->pushes += 1; (r_buf)->index = ((r_buf)->index + 1); if ((r_buf)->index >= (r_buf)->size) (r_buf)->index = 0; } while (0);
        if (i > short_period) {
            int short_index = bp_buf->index - short_period - 1;
            if (short_index < 0) short_index += long_period;
            bp_short_sum -= bp_buf->vals[short_index];
            r_short_sum -= r_buf->vals[short_index];
            if (i > medium_period) {
                int medium_index = bp_buf->index - medium_period - 1;
                if (medium_index < 0) medium_index += long_period;
                bp_medium_sum -= bp_buf->vals[medium_index];
                r_medium_sum -= r_buf->vals[medium_index];
            }
        }
        if (i >= long_period) {
            const double first = 4 * bp_short_sum / r_short_sum;
            const double second = 2 * bp_medium_sum / r_medium_sum;
            const double third = 1 * bp_buf->sum / r_buf->sum;
            const double ult = (first + second + third) * 100.0 / 7.0;
            *output++ = ult;
        }
    }
    ti_buffer_free(bp_buf);
    ti_buffer_free(r_buf);
    assert(output - outputs[0] == size - ti_ultosc_start(options));
    return 0;
}
int ti_var_start(double const *options) {
    return (int)options[0]-1;
}
int ti_var(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    const double scale = 1.0 / period;
    if (period < 1) return 1;
    if (size <= ti_var_start(options)) return 0;
    double sum = 0;
    double sum2 = 0;
    int i;
    for (i = 0; i < period; ++i) {
        sum += input[i];
        sum2 += input[i] * input[i];
    }
    *output++ = sum2 * scale - (sum * scale) * (sum * scale);
    for (i = period; i < size; ++i) {
        sum += input[i];
        sum2 += input[i] * input[i];
        sum -= input[i-period];
        sum2 -= input[i-period] * input[i-period];
        *output++ = sum2 * scale - (sum * scale) * (sum * scale);
    }
    assert(output - outputs[0] == size - ti_var_start(options));
    return 0;
}
int ti_vhf_start(double const *options) {
    return (int)options[0];
}
int ti_vhf(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *in = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_vhf_start(options)) return 0;
    int trail = 1, maxi = -1, mini = -1;
    double max = in[0], min = in[0];
    double bar;
    double sum = 0;
    int i, j;
    double yc = in[0];
    double c;
    for (i = 1; i < period; ++i) {
        c = in[i];
        sum += fabs(c - yc);
        yc = c;
    }
    for (i = period; i < size; ++i, ++trail) {
        c = in[i];
        sum += fabs(c - yc);
        yc = c;
        if (i > period) {
            sum -= fabs(in[i-period] - in[i-period-1]);
        }
        bar = c;
        if (maxi < trail) {
            maxi = trail;
            max = in[maxi];
            j = trail;
            while(++j <= i) {
                bar = in[j];
                if (bar >= max) {
                    max = bar;
                    maxi = j;
                }
            }
        } else if (bar >= max) {
            maxi = i;
            max = bar;
        }
        bar = c;
        if (mini < trail) {
            mini = trail;
            min = in[mini];
            j = trail;
            while(++j <= i) {
                bar = in[j];
                if (bar <= min) {
                    min = bar;
                    mini = j;
                }
            }
        } else if (bar <= min) {
            mini = i;
            min = bar;
        }
        *output++ = fabs(max - min) / sum;
    }
    assert(output - outputs[0] == size - ti_vhf_start(options));
    return 0;
}
int ti_vidya_start(double const *options) {
    return ((int)(options[1])) - 2;
}
int ti_vidya(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int short_period = (int)options[0];
    const int long_period = (int)options[1];
    const double alpha = options[2];
    double *output = outputs[0];
    const double short_div = 1.0 / short_period;
    const double long_div = 1.0 / long_period;
    if (short_period < 1) return 1;
    if (long_period < short_period) return 1;
    if (long_period < 2) return 1;
    if (alpha < 0.0 || alpha > 1.0) return 1;
    if (size <= ti_vidya_start(options)) return 0;
    double short_sum = 0;
    double short_sum2 = 0;
    double long_sum = 0;
    double long_sum2 = 0;
    int i;
    for (i = 0; i < long_period; ++i) {
        long_sum += input[i];
        long_sum2 += input[i] * input[i];
        if (i >= long_period - short_period) {
            short_sum += input[i];
            short_sum2 += input[i] * input[i];
        }
    }
    double val = input[long_period-2];
    *output++ = val;
    if (long_period - 1 < size) {
        double short_stddev = sqrt(short_sum2 * short_div - (short_sum * short_div) * (short_sum * short_div));
        double long_stddev = sqrt(long_sum2 * long_div - (long_sum * long_div) * (long_sum * long_div));
        double k = short_stddev / long_stddev;
        if (k != k) k = 0;
        k *= alpha;
        val = (input[long_period-1]-val) * k + val;
        *output++ = val;
    }
    for (i = long_period; i < size; ++i) {
        long_sum += input[i];
        long_sum2 += input[i] * input[i];
        short_sum += input[i];
        short_sum2 += input[i] * input[i];
        long_sum -= input[i-long_period];
        long_sum2 -= input[i-long_period] * input[i-long_period];
        short_sum -= input[i-short_period];
        short_sum2 -= input[i-short_period] * input[i-short_period];
        {
            double short_stddev = sqrt(short_sum2 * short_div - (short_sum * short_div) * (short_sum * short_div));
            double long_stddev = sqrt(long_sum2 * long_div - (long_sum * long_div) * (long_sum * long_div));
            double k = short_stddev / long_stddev;
            if (k != k) k = 0;
            k *= alpha;
            val = (input[i]-val) * k + val;
            *output++ = val;
        }
    }
    assert(output - outputs[0] == size - ti_vidya_start(options));
    return 0;
}
int ti_volatility_start(double const *options) {
    return (int)options[0];
}
int ti_volatility(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    double *output = outputs[0];
    const int period = (int)options[0];
    const double scale = 1.0 / period;
    const double annual = sqrt(252);
    if (period < 1) return 1;
    if (size <= ti_volatility_start(options)) return 0;
    double sum = 0;
    double sum2 = 0;
    int i;
    for (i = 1; i <= period; ++i) {
        const double c = (input[i]/input[i-1]-1.0);
        sum += c;
        sum2 += c * c;
    }
    *output++ = sqrt(sum2 * scale - (sum * scale) * (sum * scale)) * annual;
    for (i = period+1; i < size; ++i) {
        const double c = (input[i]/input[i-1]-1.0);
        sum += c;
        sum2 += c * c;
        const double cp = (input[i-period]/input[i-period-1]-1.0);
        sum -= cp;
        sum2 -= cp * cp;
        *output++ = sqrt(sum2 * scale - (sum * scale) * (sum * scale)) * annual;
    }
    assert(output - outputs[0] == size - ti_volatility_start(options));
    return 0;
}
int ti_vosc_start(double const *options) {
    return (int)options[1]-1;
}
int ti_vosc(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    double *output = outputs[0];
    const int short_period = (int)options[0];
    const int long_period = (int)options[1];
    const double short_div = 1.0 / short_period;
    const double long_div = 1.0 / long_period;
    if (short_period < 1) return 1;
    if (long_period < short_period) return 1;
    if (size <= ti_vosc_start(options)) return 0;
    double short_sum = 0;
    double long_sum = 0;
    int i;
    for (i = 0; i < long_period; ++i) {
        if (i >= (long_period - short_period)) {
            short_sum += input[i];
        }
        long_sum += input[i];
    }
    {
        const double savg = short_sum * short_div;
        const double lavg = long_sum * long_div;
        *output++ = 100.0 * (savg - lavg) / lavg;
    }
    for (i = long_period; i < size; ++i) {
        short_sum += input[i];
        short_sum -= input[i-short_period];
        long_sum += input[i];
        long_sum -= input[i-long_period];
        const double savg = short_sum * short_div;
        const double lavg = long_sum * long_div;
        *output++ = 100.0 * (savg - lavg) / lavg;
    }
    assert(output - outputs[0] == size - ti_vosc_start(options));
    return 0;
}
int ti_vwma_start(double const *options) {
    return (int)options[0]-1;
}
int ti_vwma(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const double *volume = inputs[1];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_vwma_start(options)) return 0;
    double sum = 0;
    double vsum = 0;
    int i;
    for (i = 0; i < period; ++i) {
        sum += input[i] * volume[i];
        vsum += volume[i];
    }
    *output++ = sum / vsum;
    for (i = period; i < size; ++i) {
        sum += input[i] * volume[i];
        sum -= input[i-period] * volume[i-period];
        vsum += volume[i];
        vsum -= volume[i-period];
        *output++ = sum / vsum;
    }
    assert(output - outputs[0] == size - ti_vwma_start(options));
    return 0;
}
int ti_wad_start(double const *options) {
    (void)options;
    return 1;
}
int ti_wad(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    (void)options;
    if (size <= ti_wad_start(options)) return 0;
    double *output = outputs[0];
    double sum = 0;
    double yc = close[0];
    int i;
    for (i = 1; i < size; ++i) {
        const double c = close[i];
        if (c > yc) {
            sum += c - ((yc)<(low[i])?(yc):(low[i]));
        } else if (c < yc) {
            sum += c - ((yc)>(high[i])?(yc):(high[i]));
        } else {
        }
        *output++ = sum;
        yc = close[i];
    }
    assert(output - outputs[0] == size - ti_wad_start(options));
    return 0;
}
int ti_wcprice_start(double const *options) {
    (void)options;
    return 0;
}
int ti_wcprice(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    (void)options;
    double *output = outputs[0];
    int i;
    for (i = 0; i < size; ++i) {
        output[i] = (high[i] + low[i] + close[i] + close[i]) * 0.25;
    }
    return 0;
}
int ti_wilders_start(double const *options) {
    return (int)options[0]-1;
}
int ti_wilders(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_wilders_start(options)) return 0;
    const double per = 1.0 / ((double)period);
    double sum = 0;
    int i;
    for (i = 0; i < period; ++i) {
        sum += input[i];
    }
    double val = sum / period;
    *output++ = val;
    for (i = period; i < size; ++i) {
        val = (input[i]-val) * per + val;
        *output++ = val;
    }
    assert(output - outputs[0] == size - ti_wilders_start(options));
    return 0;
}
int ti_willr_start(double const *options) {
    return (int)options[0]-1;
}
int ti_willr(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_willr_start(options)) return 0;
    int trail = 0, maxi = -1, mini = -1;
    double max = high[0];
    double min = low[0];
    double bar;
    int i, j;
    for (i = period-1; i < size; ++i, ++trail) {
        bar = high[i];
        if (maxi < trail) {
            maxi = trail;
            max = high[maxi];
            j = trail;
            while(++j <= i) {
                bar = high[j];
                if (bar >= max) {
                    max = bar;
                    maxi = j;
                }
            }
        } else if (bar >= max) {
            maxi = i;
            max = bar;
        }
        bar = low[i];
        if (mini < trail) {
            mini = trail;
            min = low[mini];
            j = trail;
            while(++j <= i) {
                bar = low[j];
                if (bar <= min) {
                    min = bar;
                    mini = j;
                }
            }
        } else if (bar <= min) {
            mini = i;
            min = bar;
        }
        const double highlow = (max - min);
        const double r = highlow == 0.0 ? 0.0 : -100 * ((max - close[i]) / highlow);
        *output++ = r;
    }
    assert(output - outputs[0] == size - ti_willr_start(options));
    return 0;
}
int ti_wma_start(double const *options) {
    return (int)options[0]-1;
}
int ti_wma(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_wma_start(options)) return 0;
    const double weights = period * (period+1) / 2;
    double sum = 0;
    double weight_sum = 0;
    int i;
    for (i = 0; i < period-1; ++i) {
        weight_sum += input[i] * (i+1);
        sum += input[i];
    }
    for (i = period-1; i < size; ++i) {
        weight_sum += input[i] * period;
        sum += input[i];
        *output++ = weight_sum / weights;
        weight_sum -= sum;
        sum -= input[i-period+1];
    }
    assert(output - outputs[0] == size - ti_wma_start(options));
    return 0;
}
int ti_zlema_start(double const *options) {
    return ((int)options[0] - 1) / 2 - 1;
}
int ti_zlema(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    const int lag = (period - 1) / 2;
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_zlema_start(options)) return 0;
    const double per = 2 / ((double)period + 1);
    double val = input[lag-1];
    *output++ = val;
    int i;
    for (i = lag; i < size; ++i) {
        double c = input[i];
        double l = input[i-lag];
        val = ((c + (c-l))-val) * per + val;
        *output++ = val;
    }
    assert(output - outputs[0] == size - ti_zlema_start(options));
    return 0;
}
ti_buffer *ti_buffer_new(int size) {
    const int s = (int)sizeof(ti_buffer) + (size-1) * (int)sizeof(double);
    ti_buffer *ret = (ti_buffer*)malloc((unsigned int)s);
    ret->size = size;
    ret->pushes = 0;
    ret->index = 0;
    ret->sum = 0;
    return ret;
}
void ti_buffer_free(ti_buffer *buffer) {
    free(buffer);
}
const char* ti_version(void) {return "0.9.2";}
long int ti_build(void) {return 1746800254;}
int ti_indicator_count(void) {return 104;}
struct ti_indicator_info ti_indicators[] = { {"abs", "Vector Absolute Value", ti_abs_start, ti_abs, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"abs",0}, 0, 0, 0}, {"acos", "Vector Arccosine", ti_acos_start, ti_acos, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"acos",0}, 0, 0, 0}, {"ad", "Accumulation/Distribution Line", ti_ad_start, ti_ad, 0, 2, 4, 0, 1, {"high","low","close","volume",0}, {"",0}, {"ad",0}, 0, 0, 0}, {"add", "Vector Addition", ti_add_start, ti_add, 0, 4, 2, 0, 1, {"real","real",0}, {"",0}, {"add",0}, 0, 0, 0}, {"adosc", "Accumulation/Distribution Oscillator", ti_adosc_start, ti_adosc, 0, 2, 4, 2, 1, {"high","low","close","volume",0}, {"short_period","long_period",0}, {"adosc",0}, 0, 0, 0}, {"adx", "Average Directional Movement Index", ti_adx_start, ti_adx, 0, 2, 2, 1, 1, {"high","low",0}, {"period",0}, {"adx",0}, 0, 0, 0}, {"adxr", "Average Directional Movement Rating", ti_adxr_start, ti_adxr, 0, 2, 2, 1, 1, {"high","low",0}, {"period",0}, {"adxr",0}, 0, 0, 0}, {"ao", "Awesome Oscillator", ti_ao_start, ti_ao, 0, 2, 2, 0, 1, {"high","low",0}, {"",0}, {"ao",0}, 0, 0, 0}, {"apo", "Absolute Price Oscillator", ti_apo_start, ti_apo, 0, 2, 1, 2, 1, {"real",0}, {"short_period","long_period",0}, {"apo",0}, 0, 0, 0}, {"aroon", "Aroon", ti_aroon_start, ti_aroon, 0, 2, 2, 1, 2, {"high","low",0}, {"period",0}, {"aroon_down","aroon_up",0}, 0, 0, 0}, {"aroonosc", "Aroon Oscillator", ti_aroonosc_start, ti_aroonosc, 0, 2, 2, 1, 1, {"high","low",0}, {"period",0}, {"aroonosc",0}, 0, 0, 0}, {"asin", "Vector Arcsine", ti_asin_start, ti_asin, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"asin",0}, 0, 0, 0}, {"atan", "Vector Arctangent", ti_atan_start, ti_atan, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"atan",0}, 0, 0, 0}, {"atr", "Average True Range", ti_atr_start, ti_atr, ti_atr_ref, 2, 3, 1, 1, {"high","low","close",0}, {"period",0}, {"atr",0}, ti_atr_stream_new, ti_atr_stream_run, ti_atr_stream_free}, {"avgprice", "Average Price", ti_avgprice_start, ti_avgprice, 0, 1, 4, 0, 1, {"open","high","low","close",0}, {"",0}, {"avgprice",0}, 0, 0, 0}, {"bbands", "Bollinger Bands", ti_bbands_start, ti_bbands, 0, 1, 1, 2, 3, {"real",0}, {"period","stddev",0}, {"bbands_lower","bbands_middle","bbands_upper",0}, 0, 0, 0}, {"bop", "Balance of Power", ti_bop_start, ti_bop, 0, 2, 4, 0, 1, {"open","high","low","close",0}, {"",0}, {"bop",0}, 0, 0, 0}, {"cci", "Commodity Channel Index", ti_cci_start, ti_cci, 0, 2, 3, 1, 1, {"high","low","close",0}, {"period",0}, {"cci",0}, 0, 0, 0}, {"ceil", "Vector Ceiling", ti_ceil_start, ti_ceil, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"ceil",0}, 0, 0, 0}, {"cmo", "Chande Momentum Oscillator", ti_cmo_start, ti_cmo, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"cmo",0}, 0, 0, 0}, {"cos", "Vector Cosine", ti_cos_start, ti_cos, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"cos",0}, 0, 0, 0}, {"cosh", "Vector Hyperbolic Cosine", ti_cosh_start, ti_cosh, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"cosh",0}, 0, 0, 0}, {"crossany", "Crossany", ti_crossany_start, ti_crossany, 0, 3, 2, 0, 1, {"real","real",0}, {"",0}, {"crossany",0}, 0, 0, 0}, {"crossover", "Crossover", ti_crossover_start, ti_crossover, 0, 3, 2, 0, 1, {"real","real",0}, {"",0}, {"crossover",0}, 0, 0, 0}, {"cvi", "Chaikins Volatility", ti_cvi_start, ti_cvi, 0, 2, 2, 1, 1, {"high","low",0}, {"period",0}, {"cvi",0}, 0, 0, 0}, {"decay", "Linear Decay", ti_decay_start, ti_decay, 0, 3, 1, 1, 1, {"real",0}, {"period",0}, {"decay",0}, 0, 0, 0}, {"dema", "Double Exponential Moving Average", ti_dema_start, ti_dema, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"dema",0}, 0, 0, 0}, {"di", "Directional Indicator", ti_di_start, ti_di, 0, 2, 3, 1, 2, {"high","low","close",0}, {"period",0}, {"plus_di","minus_di",0}, 0, 0, 0}, {"div", "Vector Division", ti_div_start, ti_div, 0, 4, 2, 0, 1, {"real","real",0}, {"",0}, {"div",0}, 0, 0, 0}, {"dm", "Directional Movement", ti_dm_start, ti_dm, 0, 2, 2, 1, 2, {"high","low",0}, {"period",0}, {"plus_dm","minus_dm",0}, 0, 0, 0}, {"dpo", "Detrended Price Oscillator", ti_dpo_start, ti_dpo, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"dpo",0}, 0, 0, 0}, {"dx", "Directional Movement Index", ti_dx_start, ti_dx, 0, 2, 2, 1, 1, {"high","low",0}, {"period",0}, {"dx",0}, 0, 0, 0}, {"edecay", "Exponential Decay", ti_edecay_start, ti_edecay, 0, 3, 1, 1, 1, {"real",0}, {"period",0}, {"edecay",0}, 0, 0, 0}, {"ema", "Exponential Moving Average", ti_ema_start, ti_ema, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"ema",0}, 0, 0, 0}, {"emv", "Ease of Movement", ti_emv_start, ti_emv, 0, 2, 3, 0, 1, {"high","low","volume",0}, {"",0}, {"emv",0}, 0, 0, 0}, {"exp", "Vector Exponential", ti_exp_start, ti_exp, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"exp",0}, 0, 0, 0}, {"fisher", "Fisher Transform", ti_fisher_start, ti_fisher, 0, 2, 2, 1, 2, {"high","low",0}, {"period",0}, {"fisher","fisher_signal",0}, 0, 0, 0}, {"floor", "Vector Floor", ti_floor_start, ti_floor, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"floor",0}, 0, 0, 0}, {"fosc", "Forecast Oscillator", ti_fosc_start, ti_fosc, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"fosc",0}, 0, 0, 0}, {"hma", "Hull Moving Average", ti_hma_start, ti_hma, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"hma",0}, 0, 0, 0}, {"kama", "Kaufman Adaptive Moving Average", ti_kama_start, ti_kama, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"kama",0}, 0, 0, 0}, {"kvo", "Klinger Volume Oscillator", ti_kvo_start, ti_kvo, 0, 2, 4, 2, 1, {"high","low","close","volume",0}, {"short_period","long_period",0}, {"kvo",0}, 0, 0, 0}, {"lag", "Lag", ti_lag_start, ti_lag, 0, 3, 1, 1, 1, {"real",0}, {"period",0}, {"lag",0}, 0, 0, 0}, {"linreg", "Linear Regression", ti_linreg_start, ti_linreg, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"linreg",0}, 0, 0, 0}, {"linregintercept", "Linear Regression Intercept", ti_linregintercept_start, ti_linregintercept, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"linregintercept",0}, 0, 0, 0}, {"linregslope", "Linear Regression Slope", ti_linregslope_start, ti_linregslope, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"linregslope",0}, 0, 0, 0}, {"ln", "Vector Natural Log", ti_ln_start, ti_ln, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"ln",0}, 0, 0, 0}, {"log10", "Vector Base-10 Log", ti_log10_start, ti_log10, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"log10",0}, 0, 0, 0}, {"macd", "Moving Average Convergence/Divergence", ti_macd_start, ti_macd, 0, 2, 1, 3, 3, {"real",0}, {"short_period","long_period","signal_period",0}, {"macd","macd_signal","macd_histogram",0}, 0, 0, 0}, {"marketfi", "Market Facilitation Index", ti_marketfi_start, ti_marketfi, 0, 2, 3, 0, 1, {"high","low","volume",0}, {"",0}, {"marketfi",0}, 0, 0, 0}, {"mass", "Mass Index", ti_mass_start, ti_mass, 0, 2, 2, 1, 1, {"high","low",0}, {"period",0}, {"mass",0}, 0, 0, 0}, {"max", "Maximum In Period", ti_max_start, ti_max, ti_max_ref, 3, 1, 1, 1, {"real",0}, {"period",0}, {"max",0}, 0, 0, 0}, {"md", "Mean Deviation Over Period", ti_md_start, ti_md, 0, 3, 1, 1, 1, {"real",0}, {"period",0}, {"md",0}, 0, 0, 0}, {"medprice", "Median Price", ti_medprice_start, ti_medprice, 0, 1, 2, 0, 1, {"high","low",0}, {"",0}, {"medprice",0}, 0, 0, 0}, {"mfi", "Money Flow Index", ti_mfi_start, ti_mfi, 0, 2, 4, 1, 1, {"high","low","close","volume",0}, {"period",0}, {"mfi",0}, 0, 0, 0}, {"min", "Minimum In Period", ti_min_start, ti_min, ti_min_ref, 3, 1, 1, 1, {"real",0}, {"period",0}, {"min",0}, 0, 0, 0}, {"mom", "Momentum", ti_mom_start, ti_mom, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"mom",0}, 0, 0, 0}, {"msw", "Mesa Sine Wave", ti_msw_start, ti_msw, 0, 2, 1, 1, 2, {"real",0}, {"period",0}, {"msw_sine","msw_lead",0}, 0, 0, 0}, {"mul", "Vector Multiplication", ti_mul_start, ti_mul, 0, 4, 2, 0, 1, {"real","real",0}, {"",0}, {"mul",0}, 0, 0, 0}, {"natr", "Normalized Average True Range", ti_natr_start, ti_natr, 0, 2, 3, 1, 1, {"high","low","close",0}, {"period",0}, {"natr",0}, 0, 0, 0}, {"nvi", "Negative Volume Index", ti_nvi_start, ti_nvi, 0, 2, 2, 0, 1, {"close","volume",0}, {"",0}, {"nvi",0}, 0, 0, 0}, {"obv", "On Balance Volume", ti_obv_start, ti_obv, 0, 2, 2, 0, 1, {"close","volume",0}, {"",0}, {"obv",0}, 0, 0, 0}, {"ppo", "Percentage Price Oscillator", ti_ppo_start, ti_ppo, 0, 2, 1, 2, 1, {"real",0}, {"short_period","long_period",0}, {"ppo",0}, 0, 0, 0}, {"psar", "Parabolic SAR", ti_psar_start, ti_psar, 0, 1, 2, 2, 1, {"high","low",0}, {"acceleration_factor_step","acceleration_factor_maximum",0}, {"psar",0}, 0, 0, 0}, {"pvi", "Positive Volume Index", ti_pvi_start, ti_pvi, 0, 2, 2, 0, 1, {"close","volume",0}, {"",0}, {"pvi",0}, 0, 0, 0}, {"qstick", "Qstick", ti_qstick_start, ti_qstick, 0, 2, 2, 1, 1, {"open","close",0}, {"period",0}, {"qstick",0}, 0, 0, 0}, {"roc", "Rate of Change", ti_roc_start, ti_roc, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"roc",0}, 0, 0, 0}, {"rocr", "Rate of Change Ratio", ti_rocr_start, ti_rocr, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"rocr",0}, 0, 0, 0}, {"round", "Vector Round", ti_round_start, ti_round, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"round",0}, 0, 0, 0}, {"rsi", "Relative Strength Index", ti_rsi_start, ti_rsi, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"rsi",0}, 0, 0, 0}, {"sin", "Vector Sine", ti_sin_start, ti_sin, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"sin",0}, 0, 0, 0}, {"sinh", "Vector Hyperbolic Sine", ti_sinh_start, ti_sinh, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"sinh",0}, 0, 0, 0}, {"sma", "Simple Moving Average", ti_sma_start, ti_sma, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"sma",0}, ti_sma_stream_new, ti_sma_stream_run, ti_sma_stream_free}, {"sqrt", "Vector Square Root", ti_sqrt_start, ti_sqrt, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"sqrt",0}, 0, 0, 0}, {"stddev", "Standard Deviation Over Period", ti_stddev_start, ti_stddev, 0, 3, 1, 1, 1, {"real",0}, {"period",0}, {"stddev",0}, 0, 0, 0}, {"stderr", "Standard Error Over Period", ti_stderr_start, ti_stderr, 0, 3, 1, 1, 1, {"real",0}, {"period",0}, {"stderr",0}, 0, 0, 0}, {"stoch", "Stochastic Oscillator", ti_stoch_start, ti_stoch, 0, 2, 3, 3, 2, {"high","low","close",0}, {"k_period","k_slowing_period","d_period",0}, {"stoch_k","stoch_d",0}, 0, 0, 0}, {"stochrsi", "Stochastic RSI", ti_stochrsi_start, ti_stochrsi, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"stochrsi",0}, 0, 0, 0}, {"sub", "Vector Subtraction", ti_sub_start, ti_sub, 0, 4, 2, 0, 1, {"real","real",0}, {"",0}, {"sub",0}, 0, 0, 0}, {"sum", "Sum Over Period", ti_sum_start, ti_sum, 0, 3, 1, 1, 1, {"real",0}, {"period",0}, {"sum",0}, 0, 0, 0}, {"tan", "Vector Tangent", ti_tan_start, ti_tan, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"tan",0}, 0, 0, 0}, {"tanh", "Vector Hyperbolic Tangent", ti_tanh_start, ti_tanh, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"tanh",0}, 0, 0, 0}, {"tema", "Triple Exponential Moving Average", ti_tema_start, ti_tema, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"tema",0}, 0, 0, 0}, {"todeg", "Vector Degree Conversion", ti_todeg_start, ti_todeg, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"degrees",0}, 0, 0, 0}, {"torad", "Vector Radian Conversion", ti_torad_start, ti_torad, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"radians",0}, 0, 0, 0}, {"tr", "True Range", ti_tr_start, ti_tr, 0, 2, 3, 0, 1, {"high","low","close",0}, {"",0}, {"tr",0}, 0, 0, 0}, {"trima", "Triangular Moving Average", ti_trima_start, ti_trima, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"trima",0}, 0, 0, 0}, {"trix", "Trix", ti_trix_start, ti_trix, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"trix",0}, 0, 0, 0}, {"trunc", "Vector Truncate", ti_trunc_start, ti_trunc, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"trunc",0}, 0, 0, 0}, {"tsf", "Time Series Forecast", ti_tsf_start, ti_tsf, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"tsf",0}, 0, 0, 0}, {"typprice", "Typical Price", ti_typprice_start, ti_typprice, 0, 1, 3, 0, 1, {"high","low","close",0}, {"",0}, {"typprice",0}, 0, 0, 0}, {"ultosc", "Ultimate Oscillator", ti_ultosc_start, ti_ultosc, 0, 2, 3, 3, 1, {"high","low","close",0}, {"short_period","medium_period","long_period",0}, {"ultosc",0}, 0, 0, 0}, {"var", "Variance Over Period", ti_var_start, ti_var, 0, 3, 1, 1, 1, {"real",0}, {"period",0}, {"var",0}, 0, 0, 0}, {"vhf", "Vertical Horizontal Filter", ti_vhf_start, ti_vhf, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"vhf",0}, 0, 0, 0}, {"vidya", "Variable Index Dynamic Average", ti_vidya_start, ti_vidya, 0, 1, 1, 3, 1, {"real",0}, {"short_period","long_period","alpha",0}, {"vidya",0}, 0, 0, 0}, {"volatility", "Annualized Historical Volatility", ti_volatility_start, ti_volatility, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"volatility",0}, 0, 0, 0}, {"vosc", "Volume Oscillator", ti_vosc_start, ti_vosc, 0, 2, 1, 2, 1, {"volume",0}, {"short_period","long_period",0}, {"vosc",0}, 0, 0, 0}, {"vwma", "Volume Weighted Moving Average", ti_vwma_start, ti_vwma, 0, 1, 2, 1, 1, {"close","volume",0}, {"period",0}, {"vwma",0}, 0, 0, 0}, {"wad", "Williams Accumulation/Distribution", ti_wad_start, ti_wad, 0, 2, 3, 0, 1, {"high","low","close",0}, {"",0}, {"wad",0}, 0, 0, 0}, {"wcprice", "Weighted Close Price", ti_wcprice_start, ti_wcprice, 0, 1, 3, 0, 1, {"high","low","close",0}, {"",0}, {"wcprice",0}, 0, 0, 0}, {"wilders", "Wilders Smoothing", ti_wilders_start, ti_wilders, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"wilders",0}, 0, 0, 0}, {"willr", "Williams %R", ti_willr_start, ti_willr, 0, 2, 3, 1, 1, {"high","low","close",0}, {"period",0}, {"willr",0}, 0, 0, 0}, {"wma", "Weighted Moving Average", ti_wma_start, ti_wma, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"wma",0}, 0, 0, 0}, {"zlema", "Zero-Lag Exponential Moving Average", ti_zlema_start, ti_zlema, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"zlema",0}, 0, 0, 0}, {0,0,0,0,0,0,0,0,0,{0,0},{0,0},{0,0},0,0,0}};
struct ti_stream {
    int index;
    int progress;
};
int ti_stream_run(ti_stream *stream, int size, double const *const *inputs, double *const *outputs) {
    return ti_indicators[stream->index].stream_run(stream, size, inputs, outputs);
}
ti_indicator_info *ti_stream_get_info(ti_stream *stream) {
    return ti_indicators + stream->index;
}
int ti_stream_get_progress(ti_stream *stream) {
    return stream->progress;
}
void ti_stream_free(ti_stream *stream) {
    ti_indicators[stream->index].stream_free(stream);
}
const ti_indicator_info *ti_find_indicator(const char *name) {
    int imin = 0;
    int imax = sizeof(ti_indicators) / sizeof(ti_indicator_info) - 2;
    while (imax >= imin) {
        const int i = (imin + ((imax-imin)/2));
        const int c = strcmp(name, ti_indicators[i].name);
        if (c == 0) {
            return ti_indicators + i;
        } else if (c > 0) {
            imin = i + 1;
        } else {
            imax = i - 1;
        }
    }
    return 0;
}
const char* tc_version(void) {return "0.9.2";}
long int tc_build(void) {return 1746800254;}
int tc_candle_count(void) {return 26;}
struct tc_result {
    int progress;
    int space;
    int count;
    int pattern_count;
    tc_hit *hits;
};
tc_config const *tc_config_default() {
    static tc_config default_config = {
        .period = 10,
        .body_none = 0.05,
        .body_short = 0.5,
        .body_long = 1.4,
        .wick_none = 0.05,
        .wick_long = 0.6,
        .near = 0.3
    };
    return &default_config;
}
tc_candle_info tc_candles[] = {
{"abandoned_baby_bear", "Abandoned Baby Bear", (1L<<0), tc_abandoned_baby_bear},
{"abandoned_baby_bull", "Abandoned Baby Bull", (1L<<1), tc_abandoned_baby_bull},
{"big_black_candle", "Big Black Candle", (1L<<2), tc_big_black_candle},
{"big_white_candle", "Big White Candle", (1L<<3), tc_big_white_candle},
{"black_marubozu", "Black Marubozu", (1L<<4), tc_black_marubozu},
{"doji", "Doji", (1L<<5), tc_doji},
{"dragonfly_doji", "Dragonfly Doji", (1L<<6), tc_dragonfly_doji},
{"engulfing_bear", "Engulfing Bear", (1L<<7), tc_engulfing_bear},
{"engulfing_bull", "Engulfing Bull", (1L<<8), tc_engulfing_bull},
{"evening_doji_star", "Evening Doji Star", (1L<<9), tc_evening_doji_star},
{"evening_star", "Evening Star", (1L<<10), tc_evening_star},
{"four_price_doji", "Four Price Doji", (1L<<11), tc_four_price_doji},
{"gravestone_doji", "Gravestone Doji", (1L<<12), tc_gravestone_doji},
{"hammer", "Hammer", (1L<<13), tc_hammer},
{"hanging_man", "Hanging Man", (1L<<14), tc_hanging_man},
{"inverted_hammer", "Inverted Hammer", (1L<<15), tc_inverted_hammer},
{"long_legged_doji", "Long Legged Doji", (1L<<16), tc_long_legged_doji},
{"marubozu", "Marubozu", (1L<<17), tc_marubozu},
{"morning_doji_star", "Morning Doji Star", (1L<<18), tc_morning_doji_star},
{"morning_star", "Morning Star", (1L<<19), tc_morning_star},
{"shooting_star", "Shooting Star", (1L<<20), tc_shooting_star},
{"spinning_top", "Spinning Top", (1L<<21), tc_spinning_top},
{"star", "Star", (1L<<22), tc_star},
{"three_black_crows", "Three Black Crows", (1L<<23), tc_three_black_crows},
{"three_white_soldiers", "Three White Soldiers", (1L<<24), tc_three_white_soldiers},
{"white_marubozu", "White Marubozu", (1L<<25), tc_white_marubozu},
{0,0,0,0}
};
const tc_candle_info *tc_find_candle(const char *name) {
    int imin = 0;
    int imax = sizeof(tc_candles) / sizeof(tc_candle_info) - 2;
    while (imax >= imin) {
        const int i = (imin + ((imax-imin)/2));
        const int c = strcmp(name, tc_candles[i].name);
        if (c == 0) {
            return tc_candles + i;
        } else if (c > 0) {
            imin = i + 1;
        } else {
            imax = i - 1;
        }
    }
    return 0;
}
const tc_candle_info *tc_get_info(tc_set pattern) {
    if (!pattern) return 0;
    tc_set k = pattern & ~(pattern-1);
    int imin = 0;
    int imax = sizeof(tc_candles) / sizeof(tc_candle_info) - 2;
    while (imax >= imin) {
        const int i = (imin + ((imax-imin)/2));
        if (k == tc_candles[i].pattern) {
            return tc_candles + i;
        } else if (k > tc_candles[i].pattern) {
            imin = i + 1;
        } else {
            imax = i - 1;
        }
    }
    return 0;
}
void tc_config_set_to_default(tc_config *config) {
    memcpy(config, tc_config_default(), sizeof(tc_config));
}
tc_result *tc_result_new() {
    tc_result *k = malloc(sizeof(tc_result));
    if (!k) return 0;
    memset(k, 0, sizeof(tc_result));
    return k;
}
static void tc_result_reset(tc_result *result) {
    result->progress = 0;
    result->count = 0;
    result->pattern_count = 0;
}
void tc_result_free(tc_result *result) {
    if (!result) return;
    free(result->hits);
    free(result);
}
int tc_result_count(const tc_result *result) {
    return result->count;
}
int tc_result_pattern_count(const tc_result *result) {
    return result->pattern_count;
}
tc_hit tc_result_get(const tc_result *result, int index) {
    if (index < result->count) {
        return result->hits[index];
    }
    tc_hit hit = {0};
    return hit;
}
tc_set tc_result_at(const tc_result *result, int index) {
    int imin = 0;
    int imax = result->count - 1;
    if (!imax) return 0;
    while (imax >= imin) {
        const int i = (imin + ((imax-imin)/2));
        assert(i >= 0);
        assert(i < result->count);
        if (index == result->hits[i].index) {
            return result->hits[i].patterns;
        } else if (index > result->hits[i].index) {
            imin = i + 1;
        } else {
            imax = i - 1;
        }
    }
    return 0;
}
static int tc_result_add(tc_result *result, tc_hit hit) {
    ++result->pattern_count;
    if (result->count > 0) {
        if (result->hits[result->count-1].index == hit.index) {
            do {result->hits[result->count-1].patterns |= hit.patterns;} while (0);
            return 0;
        }
    }
    if (result->space == 0) {
        result->space = 2048;
        result->count = 0;
        result->hits = malloc(sizeof(tc_hit) * (unsigned int)result->space);
    } else if (result->space == result->count) {
        result->space *= 2;
        tc_hit *hits = realloc(result->hits, sizeof(tc_hit) * (unsigned int)result->space);
        if (!hits) {
            return 2;
        }
        result->hits = hits;
    }
    result->hits[result->count] = hit;
    ++result->count;
    return 0;
}
int tc_run(tc_set patterns, int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
    tc_result_reset(output);
    {
        if ((patterns & (patterns-1)) == 0) {
if (patterns == (1L<<0)) return tc_abandoned_baby_bear(size, inputs, options, output);
if (patterns == (1L<<1)) return tc_abandoned_baby_bull(size, inputs, options, output);
if (patterns == (1L<<2)) return tc_big_black_candle(size, inputs, options, output);
if (patterns == (1L<<3)) return tc_big_white_candle(size, inputs, options, output);
if (patterns == (1L<<4)) return tc_black_marubozu(size, inputs, options, output);
if (patterns == (1L<<5)) return tc_doji(size, inputs, options, output);
if (patterns == (1L<<6)) return tc_dragonfly_doji(size, inputs, options, output);
if (patterns == (1L<<7)) return tc_engulfing_bear(size, inputs, options, output);
if (patterns == (1L<<8)) return tc_engulfing_bull(size, inputs, options, output);
if (patterns == (1L<<9)) return tc_evening_doji_star(size, inputs, options, output);
if (patterns == (1L<<10)) return tc_evening_star(size, inputs, options, output);
if (patterns == (1L<<11)) return tc_four_price_doji(size, inputs, options, output);
if (patterns == (1L<<12)) return tc_gravestone_doji(size, inputs, options, output);
if (patterns == (1L<<13)) return tc_hammer(size, inputs, options, output);
if (patterns == (1L<<14)) return tc_hanging_man(size, inputs, options, output);
if (patterns == (1L<<15)) return tc_inverted_hammer(size, inputs, options, output);
if (patterns == (1L<<16)) return tc_long_legged_doji(size, inputs, options, output);
if (patterns == (1L<<17)) return tc_marubozu(size, inputs, options, output);
if (patterns == (1L<<18)) return tc_morning_doji_star(size, inputs, options, output);
if (patterns == (1L<<19)) return tc_morning_star(size, inputs, options, output);
if (patterns == (1L<<20)) return tc_shooting_star(size, inputs, options, output);
if (patterns == (1L<<21)) return tc_spinning_top(size, inputs, options, output);
if (patterns == (1L<<22)) return tc_star(size, inputs, options, output);
if (patterns == (1L<<23)) return tc_three_black_crows(size, inputs, options, output);
if (patterns == (1L<<24)) return tc_three_white_soldiers(size, inputs, options, output);
if (patterns == (1L<<25)) return tc_white_marubozu(size, inputs, options, output);
        }
    }
    const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
    while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((1L<<0) & patterns) && i>=2 && (open[i-2]<close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && (low[i-1] >= high[(i-1)-1]) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_none * avg_total)) && (open[i]>close[i]) && (high[i] <= low[(i)-1]) && (close[i] <= close[i-2])) { do { const tc_hit hit = {i, (1L<<0)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<1) & patterns) && i>=2 && (open[i-2]>close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && (high[i-1] <= low[(i-1)-1]) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_none * avg_total)) && (open[i]<close[i]) && (low[i] >= high[(i)-1]) && (close[i] >= close[i-2])) { do { const tc_hit hit = {i, (1L<<1)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<2) & patterns) && (open[i]>close[i]) && ((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body))) { do { const tc_hit hit = {i, (1L<<2)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<3) & patterns) && (open[i]<close[i]) && ((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body))) { do { const tc_hit hit = {i, (1L<<3)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<4) & patterns) && ((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) < (options->wick_none * avg_total)) && (open[i]>close[i])) { do { const tc_hit hit = {i, (1L<<4)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<5) & patterns) && ((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total))) { do { const tc_hit hit = {i, (1L<<5)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<6) & patterns) && ((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) > (options->wick_long * avg_body))) { do { const tc_hit hit = {i, (1L<<6)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<7) & patterns) && i>=1 && (open[i]>close[i]) && (open[i-1]<close[i-1]) && close[i] < open[i-1] && open[i] > close[i-1]) { do { const tc_hit hit = {i, (1L<<7)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<8) & patterns) && i>=1 && (open[i]<close[i]) && (open[i-1]>close[i-1]) && close[i] > open[i-1] && open[i] < close[i-1]) { do { const tc_hit hit = {i, (1L<<8)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<9) & patterns) && i>=2 && (open[i-2]<close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && ((open[(i-1)] < close[(i-1)] ? open[(i-1)] : close[(i-1)]) >= (open[((i-1)-1)] > close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_none * avg_total)) && (open[i]>close[i]) && ((open[(i)] > close[(i)] ? open[(i)] : close[(i)]) <= (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)])) && (close[i] <= close[i-2])) { do { const tc_hit hit = {i, (1L<<9)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<10) & patterns) && i>=2 && (open[i-2]<close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && ((open[(i-1)] < close[(i-1)] ? open[(i-1)] : close[(i-1)]) >= (open[((i-1)-1)] > close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_short * avg_body)) && (open[i]>close[i]) && ((open[(i)] > close[(i)] ? open[(i)] : close[(i)]) <= (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)])) && (close[i] <= close[i-2])) { do { const tc_hit hit = {i, (1L<<10)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<11) & patterns) && ((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) < (options->wick_none * avg_total))) { do { const tc_hit hit = {i, (1L<<11)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<12) & patterns) && ((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total)) && ((high[(i)] - top) > (options->wick_long * avg_body)) && ((bottom - low[(i)]) < (options->wick_none * avg_total))) { do { const tc_hit hit = {i, (1L<<12)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<13) & patterns) && i>=1 && ((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) > (options->wick_long * avg_body)) && (open[(i)] < close[(i)] ? open[(i)] : close[(i)]) <= low[i-1] + (options->near * avg_total)) { do { const tc_hit hit = {i, (1L<<13)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<14) & patterns) && i>=1 && ((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) > (options->wick_long * avg_body)) && (open[(i)] < close[(i)] ? open[(i)] : close[(i)]) >= high[i-1] - (options->near * avg_total)) { do { const tc_hit hit = {i, (1L<<14)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<15) & patterns) && i>=1 && ((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) > (options->wick_long * avg_body)) && ((bottom - low[(i)]) < (options->wick_none * avg_total)) && ((open[(i)] > close[(i)] ? open[(i)] : close[(i)]) <= (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]))) { do { const tc_hit hit = {i, (1L<<15)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<16) & patterns) && ((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total)) && ((high[(i)] - top) > (options->wick_long * avg_body)) && ((bottom - low[(i)]) > (options->wick_long * avg_body))) { do { const tc_hit hit = {i, (1L<<16)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<17) & patterns) && ((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) < (options->wick_none * avg_total))) { do { const tc_hit hit = {i, (1L<<17)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<18) & patterns) && i>=2 && (open[i-2]>close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && ((open[(i-1)] > close[(i-1)] ? open[(i-1)] : close[(i-1)]) <= (open[((i-1)-1)] < close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_none * avg_total)) && (open[i]<close[i]) && ((open[(i)] < close[(i)] ? open[(i)] : close[(i)]) >= (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)])) && (close[i] >= close[i-2])) { do { const tc_hit hit = {i, (1L<<18)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<19) & patterns) && i>=2 && (open[i-2]>close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && ((open[(i-1)] > close[(i-1)] ? open[(i-1)] : close[(i-1)]) <= (open[((i-1)-1)] < close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_short * avg_body)) && (open[i]<close[i]) && ((open[(i)] < close[(i)] ? open[(i)] : close[(i)]) >= (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)])) && (close[i] >= close[i-2])) { do { const tc_hit hit = {i, (1L<<19)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<20) & patterns) && i>=1 && ((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) > (options->wick_long * avg_body)) && ((bottom - low[(i)]) < (options->wick_none * avg_total)) && ((open[(i)] < close[(i)] ? open[(i)] : close[(i)]) >= (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]))) { do { const tc_hit hit = {i, (1L<<20)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<21) & patterns) && ((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) > (fabs(open[(i)] - close[(i)]))) && ((bottom - low[(i)]) > (fabs(open[(i)] - close[(i)])))) { do { const tc_hit hit = {i, (1L<<21)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<22) & patterns) && i>=1 && ((low[i] >= high[(i)-1]) || (high[i] <= low[(i)-1]))) { do { const tc_hit hit = {i, (1L<<22)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<23) & patterns) && i>=2 && (open[i-2]>close[i-2]) && (open[i-1]>close[i-1]) && (open[i]>close[i]) && (open[i-1] < (open[((i-1)-1)] > close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)]) && open[i-1] > (open[((i-1)-1)] < close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && (open[i] < (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]) && open[i] > (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]))) { do { const tc_hit hit = {i, (1L<<23)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<24) & patterns) && i>=2 && (open[i-2]<close[i-2]) && (open[i-1]<close[i-1]) && (open[i]<close[i]) && (open[i-1] < (open[((i-1)-1)] > close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)]) && open[i-1] > (open[((i-1)-1)] < close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && (open[i] < (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]) && open[i] > (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]))) { do { const tc_hit hit = {i, (1L<<24)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<25) & patterns) && ((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) < (options->wick_none * avg_total)) && (open[i]<close[i])) { do { const tc_hit hit = {i, (1L<<25)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
    return 0;
}
int tc_abandoned_baby_bear(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=2 && (open[i-2]<close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && (low[i-1] >= high[(i-1)-1]) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_none * avg_total)) && (open[i]>close[i]) && (high[i] <= low[(i)-1]) && (close[i] <= close[i-2])) { do { const tc_hit hit = {i, (1L<<0)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_abandoned_baby_bull(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=2 && (open[i-2]>close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && (high[i-1] <= low[(i-1)-1]) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_none * avg_total)) && (open[i]<close[i]) && (low[i] >= high[(i)-1]) && (close[i] >= close[i-2])) { do { const tc_hit hit = {i, (1L<<1)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_big_black_candle(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if ((open[i]>close[i]) && ((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body))) { do { const tc_hit hit = {i, (1L<<2)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_big_white_candle(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if ((open[i]<close[i]) && ((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body))) { do { const tc_hit hit = {i, (1L<<3)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_black_marubozu(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) < (options->wick_none * avg_total)) && (open[i]>close[i])) { do { const tc_hit hit = {i, (1L<<4)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total))) { do { const tc_hit hit = {i, (1L<<5)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_dragonfly_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) > (options->wick_long * avg_body))) { do { const tc_hit hit = {i, (1L<<6)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_engulfing_bear(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=1 && (open[i]>close[i]) && (open[i-1]<close[i-1]) && close[i] < open[i-1] && open[i] > close[i-1]) { do { const tc_hit hit = {i, (1L<<7)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_engulfing_bull(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=1 && (open[i]<close[i]) && (open[i-1]>close[i-1]) && close[i] > open[i-1] && open[i] < close[i-1]) { do { const tc_hit hit = {i, (1L<<8)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_evening_doji_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=2 && (open[i-2]<close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && ((open[(i-1)] < close[(i-1)] ? open[(i-1)] : close[(i-1)]) >= (open[((i-1)-1)] > close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_none * avg_total)) && (open[i]>close[i]) && ((open[(i)] > close[(i)] ? open[(i)] : close[(i)]) <= (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)])) && (close[i] <= close[i-2])) { do { const tc_hit hit = {i, (1L<<9)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_evening_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=2 && (open[i-2]<close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && ((open[(i-1)] < close[(i-1)] ? open[(i-1)] : close[(i-1)]) >= (open[((i-1)-1)] > close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_short * avg_body)) && (open[i]>close[i]) && ((open[(i)] > close[(i)] ? open[(i)] : close[(i)]) <= (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)])) && (close[i] <= close[i-2])) { do { const tc_hit hit = {i, (1L<<10)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_four_price_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) < (options->wick_none * avg_total))) { do { const tc_hit hit = {i, (1L<<11)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_gravestone_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total)) && ((high[(i)] - top) > (options->wick_long * avg_body)) && ((bottom - low[(i)]) < (options->wick_none * avg_total))) { do { const tc_hit hit = {i, (1L<<12)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_hammer(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=1 && ((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) > (options->wick_long * avg_body)) && (open[(i)] < close[(i)] ? open[(i)] : close[(i)]) <= low[i-1] + (options->near * avg_total)) { do { const tc_hit hit = {i, (1L<<13)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_hanging_man(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=1 && ((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) > (options->wick_long * avg_body)) && (open[(i)] < close[(i)] ? open[(i)] : close[(i)]) >= high[i-1] - (options->near * avg_total)) { do { const tc_hit hit = {i, (1L<<14)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_inverted_hammer(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=1 && ((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) > (options->wick_long * avg_body)) && ((bottom - low[(i)]) < (options->wick_none * avg_total)) && ((open[(i)] > close[(i)] ? open[(i)] : close[(i)]) <= (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]))) { do { const tc_hit hit = {i, (1L<<15)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_long_legged_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total)) && ((high[(i)] - top) > (options->wick_long * avg_body)) && ((bottom - low[(i)]) > (options->wick_long * avg_body))) { do { const tc_hit hit = {i, (1L<<16)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_marubozu(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) < (options->wick_none * avg_total))) { do { const tc_hit hit = {i, (1L<<17)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_morning_doji_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=2 && (open[i-2]>close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && ((open[(i-1)] > close[(i-1)] ? open[(i-1)] : close[(i-1)]) <= (open[((i-1)-1)] < close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_none * avg_total)) && (open[i]<close[i]) && ((open[(i)] < close[(i)] ? open[(i)] : close[(i)]) >= (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)])) && (close[i] >= close[i-2])) { do { const tc_hit hit = {i, (1L<<18)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_morning_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=2 && (open[i-2]>close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && ((open[(i-1)] > close[(i-1)] ? open[(i-1)] : close[(i-1)]) <= (open[((i-1)-1)] < close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_short * avg_body)) && (open[i]<close[i]) && ((open[(i)] < close[(i)] ? open[(i)] : close[(i)]) >= (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)])) && (close[i] >= close[i-2])) { do { const tc_hit hit = {i, (1L<<19)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_shooting_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=1 && ((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) > (options->wick_long * avg_body)) && ((bottom - low[(i)]) < (options->wick_none * avg_total)) && ((open[(i)] < close[(i)] ? open[(i)] : close[(i)]) >= (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]))) { do { const tc_hit hit = {i, (1L<<20)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_spinning_top(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) > (fabs(open[(i)] - close[(i)]))) && ((bottom - low[(i)]) > (fabs(open[(i)] - close[(i)])))) { do { const tc_hit hit = {i, (1L<<21)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=1 && ((low[i] >= high[(i)-1]) || (high[i] <= low[(i)-1]))) { do { const tc_hit hit = {i, (1L<<22)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_three_black_crows(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=2 && (open[i-2]>close[i-2]) && (open[i-1]>close[i-1]) && (open[i]>close[i]) && (open[i-1] < (open[((i-1)-1)] > close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)]) && open[i-1] > (open[((i-1)-1)] < close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && (open[i] < (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]) && open[i] > (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]))) { do { const tc_hit hit = {i, (1L<<23)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_three_white_soldiers(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=2 && (open[i-2]<close[i-2]) && (open[i-1]<close[i-1]) && (open[i]<close[i]) && (open[i-1] < (open[((i-1)-1)] > close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)]) && open[i-1] > (open[((i-1)-1)] < close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && (open[i] < (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]) && open[i] > (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]))) { do { const tc_hit hit = {i, (1L<<24)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_white_marubozu(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) < (options->wick_none * avg_total)) && (open[i]<close[i])) { do { const tc_hit hit = {i, (1L<<25)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
# 0 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
# 60 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/math.h" 1
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/math.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/math.h" 2
# 61 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/assert.h" 1
# 62 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/string.h" 1
# 63 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 64 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c" 2
# 72 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
const char* ti_version(void);
long int ti_build(void);
int ti_indicator_count(void);
# 97 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
typedef int (*ti_indicator_start_function)(double const *options);
typedef int (*ti_indicator_function)(int size, double const *const *inputs, double const *options, double *const *outputs);


struct ti_stream; typedef struct ti_stream ti_stream;
typedef int (*ti_indicator_stream_new)(double const *options, ti_stream **stream);
typedef int (*ti_indicator_stream_run)(ti_stream *stream, int size, double const *const *inputs, double *const *outputs);
typedef void (*ti_indicator_stream_free)(ti_stream *stream);


typedef struct ti_indicator_info {
    const char *name;
    const char *full_name;
    ti_indicator_start_function start;
    ti_indicator_function indicator;
    ti_indicator_function indicator_ref;
    int type, inputs, options, outputs;
    const char *input_names[16];
    const char *option_names[16];
    const char *output_names[16];
    ti_indicator_stream_new stream_new;
    ti_indicator_stream_run stream_run;
    ti_indicator_stream_free stream_free;
} ti_indicator_info;



extern ti_indicator_info ti_indicators[];



const ti_indicator_info *ti_find_indicator(const char *name);




int ti_stream_run(ti_stream *stream, int size, double const *const *inputs, double *const *outputs);
ti_indicator_info *ti_stream_get_info(ti_stream *stream);
int ti_stream_get_progress(ti_stream *stream);
void ti_stream_free(ti_stream *stream);
# 165 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
int ti_abs_start(double const *options);
int ti_abs(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_acos_start(double const *options);
int ti_acos(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ad_start(double const *options);
int ti_ad(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_add_start(double const *options);
int ti_add(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_adosc_start(double const *options);
int ti_adosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_adx_start(double const *options);
int ti_adx(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_adxr_start(double const *options);
int ti_adxr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ao_start(double const *options);
int ti_ao(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_apo_start(double const *options);
int ti_apo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_aroon_start(double const *options);
int ti_aroon(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_aroonosc_start(double const *options);
int ti_aroonosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_asin_start(double const *options);
int ti_asin(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_atan_start(double const *options);
int ti_atan(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_atr_start(double const *options);
int ti_atr(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_atr_ref(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_atr_stream_new(double const *options, ti_stream **stream);
int ti_atr_stream_run(ti_stream *stream, int size, double const *const *inputs, double *const *outputs);
void ti_atr_stream_free(ti_stream *stream);







int ti_avgprice_start(double const *options);
int ti_avgprice(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_bbands_start(double const *options);
int ti_bbands(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_bop_start(double const *options);
int ti_bop(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cci_start(double const *options);
int ti_cci(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ceil_start(double const *options);
int ti_ceil(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cmo_start(double const *options);
int ti_cmo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cos_start(double const *options);
int ti_cos(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cosh_start(double const *options);
int ti_cosh(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_crossany_start(double const *options);
int ti_crossany(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_crossover_start(double const *options);
int ti_crossover(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_cvi_start(double const *options);
int ti_cvi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_decay_start(double const *options);
int ti_decay(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_dema_start(double const *options);
int ti_dema(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_di_start(double const *options);
int ti_di(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_div_start(double const *options);
int ti_div(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_dm_start(double const *options);
int ti_dm(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_dpo_start(double const *options);
int ti_dpo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_dx_start(double const *options);
int ti_dx(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_edecay_start(double const *options);
int ti_edecay(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ema_start(double const *options);
int ti_ema(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_emv_start(double const *options);
int ti_emv(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_exp_start(double const *options);
int ti_exp(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_fisher_start(double const *options);
int ti_fisher(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_floor_start(double const *options);
int ti_floor(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_fosc_start(double const *options);
int ti_fosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_hma_start(double const *options);
int ti_hma(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_kama_start(double const *options);
int ti_kama(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_kvo_start(double const *options);
int ti_kvo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_lag_start(double const *options);
int ti_lag(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_linreg_start(double const *options);
int ti_linreg(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_linregintercept_start(double const *options);
int ti_linregintercept(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_linregslope_start(double const *options);
int ti_linregslope(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ln_start(double const *options);
int ti_ln(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_log10_start(double const *options);
int ti_log10(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_macd_start(double const *options);
int ti_macd(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_marketfi_start(double const *options);
int ti_marketfi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_mass_start(double const *options);
int ti_mass(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_max_start(double const *options);
int ti_max(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_max_ref(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_md_start(double const *options);
int ti_md(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_medprice_start(double const *options);
int ti_medprice(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_mfi_start(double const *options);
int ti_mfi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_min_start(double const *options);
int ti_min(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_min_ref(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_mom_start(double const *options);
int ti_mom(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_msw_start(double const *options);
int ti_msw(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_mul_start(double const *options);
int ti_mul(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_natr_start(double const *options);
int ti_natr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_nvi_start(double const *options);
int ti_nvi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_obv_start(double const *options);
int ti_obv(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ppo_start(double const *options);
int ti_ppo(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_psar_start(double const *options);
int ti_psar(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_pvi_start(double const *options);
int ti_pvi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_qstick_start(double const *options);
int ti_qstick(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_roc_start(double const *options);
int ti_roc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_rocr_start(double const *options);
int ti_rocr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_round_start(double const *options);
int ti_round(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_rsi_start(double const *options);
int ti_rsi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sin_start(double const *options);
int ti_sin(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sinh_start(double const *options);
int ti_sinh(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sma_start(double const *options);
int ti_sma(int size, double const *const *inputs, double const *options, double *const *outputs);
int ti_sma_stream_new(double const *options, ti_stream **stream);
int ti_sma_stream_run(ti_stream *stream, int size, double const *const *inputs, double *const *outputs);
void ti_sma_stream_free(ti_stream *stream);







int ti_sqrt_start(double const *options);
int ti_sqrt(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_stddev_start(double const *options);
int ti_stddev(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_stderr_start(double const *options);
int ti_stderr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_stoch_start(double const *options);
int ti_stoch(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_stochrsi_start(double const *options);
int ti_stochrsi(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sub_start(double const *options);
int ti_sub(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_sum_start(double const *options);
int ti_sum(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tan_start(double const *options);
int ti_tan(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tanh_start(double const *options);
int ti_tanh(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tema_start(double const *options);
int ti_tema(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_todeg_start(double const *options);
int ti_todeg(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_torad_start(double const *options);
int ti_torad(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tr_start(double const *options);
int ti_tr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_trima_start(double const *options);
int ti_trima(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_trix_start(double const *options);
int ti_trix(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_trunc_start(double const *options);
int ti_trunc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_tsf_start(double const *options);
int ti_tsf(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_typprice_start(double const *options);
int ti_typprice(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_ultosc_start(double const *options);
int ti_ultosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_var_start(double const *options);
int ti_var(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_vhf_start(double const *options);
int ti_vhf(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_vidya_start(double const *options);
int ti_vidya(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_volatility_start(double const *options);
int ti_volatility(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_vosc_start(double const *options);
int ti_vosc(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_vwma_start(double const *options);
int ti_vwma(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_wad_start(double const *options);
int ti_wad(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_wcprice_start(double const *options);
int ti_wcprice(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_wilders_start(double const *options);
int ti_wilders(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_willr_start(double const *options);
int ti_willr(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_wma_start(double const *options);
int ti_wma(int size, double const *const *inputs, double const *options, double *const *outputs);







int ti_zlema_start(double const *options);
int ti_zlema(int size, double const *const *inputs, double const *options, double *const *outputs);
# 1169 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdint.h" 1
# 1170 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c" 2
# 1178 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
const char* tc_version(void);
long int tc_build(void);
int tc_candle_count(void);





typedef double TC_REAL;
typedef struct tc_result tc_result;

typedef uint64_t tc_set;
# 1235 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
typedef struct tc_config {
    int period;

    TC_REAL body_none;
    TC_REAL body_short;
    TC_REAL body_long;

    TC_REAL wick_none;
    TC_REAL wick_long;

    TC_REAL near;

} tc_config;



typedef struct tc_hit {
    int index;
    tc_set patterns;
} tc_hit;



typedef int (*tc_candle_function)(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);



typedef struct tc_candle_info {
    const char *name;
    const char *full_name;
    tc_set pattern;
    tc_candle_function candle;
} tc_candle_info;



extern tc_candle_info tc_candles[];


const tc_candle_info *tc_find_candle(const char *name);


const tc_candle_info *tc_get_info(tc_set pattern);


tc_config const *tc_config_default();
void tc_config_set_to_default(tc_config *config);


tc_result *tc_result_new();
void tc_result_free(tc_result *result);
int tc_result_count(const tc_result *result);
int tc_result_pattern_count(const tc_result *result);

tc_hit tc_result_get(const tc_result *result, int index);
tc_set tc_result_at(const tc_result *result, int index);




int tc_run(tc_set patterns, int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
# 1315 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
int tc_abandoned_baby_bear(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_abandoned_baby_bull(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_big_black_candle(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_big_white_candle(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_black_marubozu(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_dragonfly_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_engulfing_bear(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_engulfing_bull(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_evening_doji_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_evening_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_four_price_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_gravestone_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_hammer(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_hanging_man(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_inverted_hammer(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_long_legged_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_marubozu(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_morning_doji_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_morning_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_shooting_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_spinning_top(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_three_black_crows(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_three_white_soldiers(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
int tc_white_marubozu(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output);
# 1378 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
typedef struct {
    int size, pushes, index;
    double sum;
    double vals[1];
} ti_buffer;


ti_buffer *ti_buffer_new(int size);
void ti_buffer_free(ti_buffer *buffer);
# 1540 "/home/enumclass/Documents/C2RustTranslation/bkp/tulipindicators/tiamalgamation.c"
int ti_abs_start(double const *options) { (void)options; return 0; } int ti_abs(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (fabs(in1[i])); } return 0; }
int ti_acos_start(double const *options) { (void)options; return 0; } int ti_acos(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (acos(in1[i])); } return 0; }
int ti_ad_start(double const *options) {
    (void)options;
    return 0;
}
int ti_ad(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const double *volume = inputs[3];
    (void)options;
    double *output = outputs[0];
    double sum = 0;
    int i;
    for (i = 0; i < size; ++i) {
        const double hl = (high[i] - low[i]);
        if (hl != 0.0) {
            sum += (close[i] - low[i] - high[i] + close[i]) / hl * volume[i];
        }
        output[i] = sum;
    }
    return 0;
}
int ti_add_start(double const *options) { (void)options; return 0; } int ti_add(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; const double *in2 = inputs[1]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (in1[i] + in2[i]); } return 0; }
int ti_adosc_start(double const *options) {
    return (int)(options[1])-1;
}
int ti_adosc(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const double *volume = inputs[3];
    const int short_period = (int)options[0];
    const int long_period = (int)options[1];
    const int start = long_period - 1;
    if (short_period < 1) return 1;
    if (long_period < short_period) return 1;
    if (size <= ti_adosc_start(options)) return 0;
    const double short_per = 2 / ((double)short_period + 1);
    const double long_per = 2 / ((double)long_period + 1);
    double *output = outputs[0];
    double sum = 0, short_ema = 0, long_ema = 0;
    int i;
    for (i = 0; i < size; ++i) {
        const double hl = (high[i] - low[i]);
        if (hl != 0.0) {
            sum += (close[i] - low[i] - high[i] + close[i]) / hl * volume[i];
        }
        if (i == 0) {
            short_ema = sum;
            long_ema = sum;
        } else {
            short_ema = (sum-short_ema) * short_per + short_ema;
            long_ema = (sum-long_ema) * long_per + long_ema;
        }
        if (i >= start) {
            *output++ = short_ema - long_ema;
        }
    }
    assert(output - outputs[0] == size - ti_adosc_start(options));
    return 0;
}
int ti_adx_start(double const *options) {
    return ((int)options[0]-1) * 2;
}
int ti_adx(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 2) return 1;
    if (size <= ti_adx_start(options)) return 0;
    const double per = ((double)period-1) / ((double)period);
    const double invper = 1.0 / ((double)period);
    double dmup = 0;
    double dmdown = 0;
    int i;
    for (i = 1; i < period; ++i) {
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup += dp;
        dmdown += dm;
    }
    double adx = 0.0;
    {
        double di_up = dmup;
        double di_down = dmdown;
        double dm_diff = fabs(di_up - di_down);
        double dm_sum = di_up + di_down;
        double dx = dm_diff / dm_sum * 100;
        adx += dx;
    }
    for (i = period; i < size; ++i) {
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup = dmup * per + dp;
        dmdown = dmdown * per + dm;
        double di_up = dmup;
        double di_down = dmdown;
        double dm_diff = fabs(di_up - di_down);
        double dm_sum = di_up + di_down;
        double dx = dm_diff / dm_sum * 100;
        if (i-period < period-2) {
            adx += dx;
        } else if (i-period == period-2) {
            adx += dx;
            *output++ = adx * invper;
        } else {
            adx = adx * per + dx;
            *output++ = adx * invper;
        }
    }
    assert(output - outputs[0] == size - ti_adx_start(options));
    return 0;
}
int ti_adxr_start(double const *options) {
    return ((int)options[0]-1) * 3;
}
int ti_adxr(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 2) return 1;
    if (size <= ti_adxr_start(options)) return 0;
    const double per = ((double)period-1) / ((double)period);
    const double invper = 1.0 / ((double)period);
    double dmup = 0;
    double dmdown = 0;
    int i;
    for (i = 1; i < period; ++i) {
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup += dp;
        dmdown += dm;
    }
    double adx = 0.0;
    {
        double di_up = dmup;
        double di_down = dmdown;
        double dm_diff = fabs(di_up - di_down);
        double dm_sum = di_up + di_down;
        double dx = dm_diff / dm_sum * 100;
        adx += dx;
    }
    ti_buffer *adxr = ti_buffer_new(period-1);
    const int first_adxr = ti_adxr_start(options);
    for (i = period; i < size; ++i) {
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup = dmup * per + dp;
        dmdown = dmdown * per + dm;
        double di_up = dmup;
        double di_down = dmdown;
        double dm_diff = fabs(di_up - di_down);
        double dm_sum = di_up + di_down;
        double dx = dm_diff / dm_sum * 100;
        if (i-period < period-2) {
            adx += dx;
        } else if (i-period == period-2) {
            adx += dx;
            do { (adxr)->vals[(adxr)->index] = (adx * invper); (adxr)->index = ((adxr)->index + 1); if ((adxr)->index >= (adxr)->size) (adxr)->index = 0; } while (0);
        } else {
            adx = adx * per + dx;
            if (i >= first_adxr) {
                *output++ = 0.5 * (adx * invper + ((adxr)->vals[((adxr)->index + (adxr)->size - 1 + (1)) % (adxr)->size]));
            }
            do { (adxr)->vals[(adxr)->index] = (adx * invper); (adxr)->index = ((adxr)->index + 1); if ((adxr)->index >= (adxr)->size) (adxr)->index = 0; } while (0);
        }
    }
    ti_buffer_free(adxr);
    assert(output - outputs[0] == size - ti_adxr_start(options));
    return 0;
}
int ti_ao_start(double const *options) {
    (void)options;
    return 33;
}
int ti_ao(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const int period = 34;
    double *output = outputs[0];
    if (size <= ti_ao_start(options)) return 0;
    double sum34 = 0;
    double sum5 = 0;
    const double per34 = 1.0 / 34.0;
    const double per5 = 1.0 / 5.0;
    int i;
    for (i = 0; i < 34; ++i) {
        double hl = 0.5 * (high[i] + low[i]);
        sum34 += hl;
        if (i >= 29) sum5 += hl;
    }
    *output++ = (per5 * sum5 - per34 * sum34);
    for (i = period; i < size; ++i) {
        double hl = 0.5 * (high[i] + low[i]);
        sum34 += hl;
        sum5 += hl;
        sum34 -= 0.5 * (high[i-34] + low[i-34]);
        sum5 -= 0.5 * (high[i-5] + low[i-5]);
        *output++ = (per5 * sum5 - per34 * sum34);
    }
    assert(output - outputs[0] == size - ti_ao_start(options));
    return 0;
}
int ti_apo_start(double const *options) {
    (void)options;
    return 1;
}
int ti_apo(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    double *apo = outputs[0];
    const int short_period = (int)options[0];
    const int long_period = (int)options[1];
    if (short_period < 1) return 1;
    if (long_period < 2) return 1;
    if (long_period < short_period) return 1;
    if (size <= ti_apo_start(options)) return 0;
    double short_per = 2 / ((double)short_period + 1);
    double long_per = 2 / ((double)long_period + 1);
    double short_ema = input[0];
    double long_ema = input[0];
    int i;
    for (i = 1; i < size; ++i) {
        short_ema = (input[i]-short_ema) * short_per + short_ema;
        long_ema = (input[i]-long_ema) * long_per + long_ema;
        const double out = short_ema - long_ema;
        *apo++ = out;
    }
    assert(apo - outputs[0] == size - ti_apo_start(options));
    return 0;
}
int ti_aroon_start(double const *options) {
    return (int)options[0];
}
int ti_aroon(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    double *adown = outputs[0];
    double *aup = outputs[1];
    const int period = (int)options[0];
    if (period < 1) return 1;
    if (size <= ti_aroon_start(options)) return 0;
    const double scale = 100.0 / period;
    int trail = 0, maxi = -1, mini = -1;
    double max = high[0];
    double min = low[0];
    double bar;
    int i, j;
    for (i = period; i < size; ++i, ++trail) {
        bar = high[i];
        if (maxi < trail) {
            maxi = trail;
            max = high[maxi];
            j = trail;
            while(++j <= i) {
                bar = high[j];
                if (bar >= max) {
                    max = bar;
                    maxi = j;
                }
            }
        } else if (bar >= max) {
            maxi = i;
            max = bar;
        }
        bar = low[i];
        if (mini < trail) {
            mini = trail;
            min = low[mini];
            j = trail;
            while(++j <= i) {
                bar = low[j];
                if (bar <= min) {
                    min = bar;
                    mini = j;
                }
            }
        } else if (bar <= min) {
            mini = i;
            min = bar;
        }
        *adown++ = ((double)period - (i-mini)) * scale;
        *aup++ = ((double)period - (i-maxi)) * scale;
    }
    assert(adown - outputs[0] == size - ti_aroon_start(options));
    assert(aup - outputs[1] == size - ti_aroon_start(options));
    return 0;
}
int ti_aroonosc_start(double const *options) {
    return (int)options[0];
}
int ti_aroonosc(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    double *output = outputs[0];
    const int period = (int)options[0];
    if (period < 1) return 1;
    if (size <= ti_aroon_start(options)) return 0;
    const double scale = 100.0 / period;
    int trail = 0, maxi = -1, mini = -1;
    double max = high[0];
    double min = low[0];
    int i, j;
    for (i = period; i < size; ++i, ++trail) {
        double bar = high[i];
        if (maxi < trail) {
            maxi = trail;
            max = high[maxi];
            j = trail;
            while(++j <= i) {
                bar = high[j];
                if (bar >= max) {
                    max = bar;
                    maxi = j;
                }
            }
        } else if (bar >= max) {
            maxi = i;
            max = bar;
        }
        bar = low[i];
        if (mini < trail) {
            mini = trail;
            min = low[mini];
            j = trail;
            while(++j <= i) {
                bar = low[j];
                if (bar <= min) {
                    min = bar;
                    mini = j;
                }
            }
        } else if (bar <= min) {
            mini = i;
            min = bar;
        }
        *output++ = (maxi-mini) * scale;
    }
    assert(output - outputs[0] == size - ti_aroonosc_start(options));
    return 0;
}
int ti_asin_start(double const *options) { (void)options; return 0; } int ti_asin(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (asin(in1[i])); } return 0; }
int ti_atan_start(double const *options) { (void)options; return 0; } int ti_atan(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (atan(in1[i])); } return 0; }
int ti_atr_start(double const *options) {
    return (int)options[0]-1;
}
int ti_atr(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_atr_start(options)) return 0;
    const double per = 1.0 / ((double)period);
    double sum = 0;
    double truerange;
    sum += high[0] - low[0];
    int i;
    for (i = 1; i < period; ++i) {
        do{ const double l = low[i]; const double h = high[i]; const double c = close[i-1]; const double ych = fabs(h - c); const double ycl = fabs(l - c); double v = h - l; if (ych > v) v = ych; if (ycl > v) v = ycl; truerange = v;}while(0);
        sum += truerange;
    }
    double val = sum / period;
    *output++ = val;
    for (i = period; i < size; ++i) {
        do{ const double l = low[i]; const double h = high[i]; const double c = close[i-1]; const double ych = fabs(h - c); const double ycl = fabs(l - c); double v = h - l; if (ych > v) v = ych; if (ycl > v) v = ycl; truerange = v;}while(0);
        val = (truerange-val) * per + val;
        *output++ = val;
    }
    assert(output - outputs[0] == size - ti_atr_start(options));
    return 0;
}
int ti_atr_ref(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const int period = (int)options[0];
    if (period < 1) return 1;
    if (size <= ti_atr_start(options)) return 0;
    const int tr_start = ti_tr_start(options);
    const int tr_size = size - tr_start;
    double *truerange = malloc((unsigned int)tr_size * sizeof(double));
    if (!truerange) {return 2;}
    double *tr_outputs[1] = {truerange};
    const int tr_ret = ti_tr(size, inputs, 0, tr_outputs);
    if (tr_ret != 0) {
        free(truerange);
        return tr_ret;
    }
    const double *wilders_inputs[1] = {truerange};
    const int wilders_ret = ti_wilders(tr_size, wilders_inputs, options, outputs);
    free(truerange);
    assert(size - ti_atr_start(options) == size - ti_wilders_start(options));
    return wilders_ret;
}
typedef struct ti_stream_atr {
    int index;
    int progress;
    int period;
    double sum;
    double last;
    double last_close;
} ti_stream_atr;
int ti_atr_stream_new(double const *options, ti_stream **stream_in) {
    ti_stream_atr **stream = (ti_stream_atr**) stream_in;
    const int period = (int)options[0];
    if (period < 1) return 1;
    *stream = malloc(sizeof(ti_stream_atr));
    if (!*stream) {
        return 2;
    }
    (*stream)->index = 13;
    (*stream)->progress = -ti_atr_start(options);
    (*stream)->period = period;
    (*stream)->sum = 0.0;
    return 0;
}
int ti_atr_stream_run(ti_stream *stream_in, int size, double const *const *inputs, double *const *outputs) {
    ti_stream_atr *stream = (ti_stream_atr*)stream_in;
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    double *output = outputs[0];
    const double per = 1.0 / ((double)stream->period);
    const int start = -(stream->period-1);
    int i = 0;
    if (stream->progress < 1) {
        if (stream->progress == start) {
            stream->sum = high[0] - low[0];
            stream->last_close = close[0];
            ++stream->progress; ++i;
        }
        while (stream->progress <= 0 && i < size) {
            double truerange; do { const double ych = fabs((high[i]) - (stream->last_close)); const double ycl = fabs((low[i]) - (stream->last_close)); double v = (high[i]) - (low[i]); if (ych > v) v = ych; if (ycl > v) v = ycl; truerange = v; } while (0);
            stream->sum += truerange;
            stream->last_close = close[i];
            ++stream->progress; ++i;
        }
        if (stream->progress == 1) {
            const double val = stream->sum * per;
            stream->last = val;
            *output++ = val;
        }
    }
    if (stream->progress >= 1) {
        double val = stream->last;
        while (i < size) {
            double truerange; do { const double ych = fabs((high[i]) - (stream->last_close)); const double ycl = fabs((low[i]) - (stream->last_close)); double v = (high[i]) - (low[i]); if (ych > v) v = ych; if (ycl > v) v = ycl; truerange = v; } while (0);
            val = (truerange-val) * per + val;
            *output++ = val;
            stream->last_close = close[i];
            ++stream->progress; ++i;
        }
        stream->last = val;
    }
    return 0;
}
void ti_atr_stream_free(ti_stream *stream) {
    free(stream);
}
int ti_avgprice_start(double const *options) {
    (void)options;
    return 0;
}
int ti_avgprice(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *open = inputs[0];
    const double *high = inputs[1];
    const double *low = inputs[2];
    const double *close = inputs[3];
    (void)options;
    double *output = outputs[0];
    int i;
    for (i = 0; i < size; ++i) {
        output[i] = (open[i] + high[i] + low[i] + close[i]) * 0.25;
    }
    return 0;
}
int ti_bbands_start(double const *options) {
    return (int)options[0]-1;
}
int ti_bbands(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    double *lower = outputs[0];
    double *middle = outputs[1];
    double *upper = outputs[2];
    const int period = (int)options[0];
    const double stddev = options[1];
    const double scale = 1.0 / period;
    if (period < 1) return 1;
    if (size <= ti_bbands_start(options)) return 0;
    double sum = 0;
    double sum2 = 0;
    int i;
    for (i = 0; i < period; ++i) {
        sum += input[i];
        sum2 += input[i] * input[i];
    }
    double sd = sqrt(sum2 * scale - (sum * scale) * (sum * scale));
    *middle = sum * scale;
    *lower++ = *middle - stddev * sd;
    *upper++ = *middle + stddev * sd;
    ++middle;
    for (i = period; i < size; ++i) {
        sum += input[i];
        sum2 += input[i] * input[i];
        sum -= input[i-period];
        sum2 -= input[i-period] * input[i-period];
        sd = sqrt(sum2 * scale - (sum * scale) * (sum * scale));
        *middle = sum * scale;
        *upper++ = *middle + stddev * sd;
        *lower++ = *middle - stddev * sd;
        ++middle;
    }
    assert(lower - outputs[0] == size - ti_bbands_start(options));
    assert(middle - outputs[1] == size - ti_bbands_start(options));
    assert(upper - outputs[2] == size - ti_bbands_start(options));
    return 0;
}
int ti_bop_start(double const *options) {
    (void)options;
    return 0;
}
int ti_bop(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *open = inputs[0];
    const double *high = inputs[1];
    const double *low = inputs[2];
    const double *close = inputs[3];
    (void)options;
    double *output = outputs[0];
    int i;
    for (i = 0; i < size; ++i) {
        double hl = high[i] - low[i];
        if (hl <= 0.0) {
            output[i] = 0;
        } else {
            output[i] = (close[i] - open[i]) / hl;
        }
    }
    return 0;
}
int ti_cci_start(double const *options) {
    const int period = (int)options[0];
    return (period-1) * 2;
}
int ti_cci(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const int period = (int)options[0];
    const double scale = 1.0 / period;
    if (period < 1) return 1;
    if (size <= ti_cci_start(options)) return 0;
    double *output = outputs[0];
    ti_buffer *sum = ti_buffer_new(period);
    int i, j;
    for (i = 0; i < size; ++i) {
        const double today = ((high[(i)] + low[(i)] + close[(i)]) * (1.0/3.0));
        do { if ((sum)->pushes >= (sum)->size) { (sum)->sum -= (sum)->vals[(sum)->index]; } (sum)->sum += (today); (sum)->vals[(sum)->index] = (today); (sum)->pushes += 1; (sum)->index = ((sum)->index + 1); if ((sum)->index >= (sum)->size) (sum)->index = 0; } while (0);
        const double avg = sum->sum * scale;
        if (i >= period * 2 - 2) {
            double acc = 0;
            for (j = 0; j < period; ++j) {
                acc += fabs(avg - sum->vals[j]);
            }
            double cci = acc * scale;
            cci *= .015;
            cci = (today-avg)/cci;
            *output++ = cci;
        }
    }
    ti_buffer_free(sum);
    assert(output - outputs[0] == size - ti_cci_start(options));
    return 0;
}
int ti_ceil_start(double const *options) { (void)options; return 0; } int ti_ceil(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (ceil(in1[i])); } return 0; }
int ti_cmo_start(double const *options) {
    return (int)options[0];
}
int ti_cmo(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    double *output = outputs[0];
    const int period = (int)options[0];
    if (period < 1) return 1;
    if (size <= ti_cmo_start(options)) return 0;
    double up_sum = 0, down_sum = 0;
    int i;
    for (i = 1; i <= period; ++i) {
        up_sum += (input[(i)] > input[(i)-1] ? input[(i)] - input[(i)-1] : 0);
        down_sum += (input[(i)] < input[(i)-1] ? input[(i)-1] - input[(i)] : 0);
    }
    *output++ = 100 * (up_sum - down_sum) / (up_sum + down_sum);
    for (i = period+1; i < size; ++i) {
        up_sum -= (input[(i-period)] > input[(i-period)-1] ? input[(i-period)] - input[(i-period)-1] : 0);
        down_sum -= (input[(i-period)] < input[(i-period)-1] ? input[(i-period)-1] - input[(i-period)] : 0);
        up_sum += (input[(i)] > input[(i)-1] ? input[(i)] - input[(i)-1] : 0);
        down_sum += (input[(i)] < input[(i)-1] ? input[(i)-1] - input[(i)] : 0);
        *output++ = 100 * (up_sum - down_sum) / (up_sum + down_sum);
    }
    assert(output - outputs[0] == size - ti_cmo_start(options));
    return 0;
}
int ti_cos_start(double const *options) { (void)options; return 0; } int ti_cos(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (cos(in1[i])); } return 0; }
int ti_cosh_start(double const *options) { (void)options; return 0; } int ti_cosh(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (cosh(in1[i])); } return 0; }
int ti_crossany_start(double const *options) {
    (void)options;
    return 1;
}
int ti_crossany(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *a = inputs[0];
    const double *b = inputs[1];
    (void)options;
    double *output = outputs[0];
    int i;
    for (i = 1; i < size; ++i) {
        *output++ = (a[i] > b[i] && a[i-1] <= b[i-1])
                 || (a[i] < b[i] && a[i-1] >= b[i-1]);
    }
    return 0;
}
int ti_crossover_start(double const *options) {
    (void)options;
    return 1;
}
int ti_crossover(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *a = inputs[0];
    const double *b = inputs[1];
    (void)options;
    double *output = outputs[0];
    int i;
    for (i = 1; i < size; ++i) {
        *output++ = a[i] > b[i] && a[i-1] <= b[i-1];
    }
    return 0;
}
int ti_cvi_start(double const *options) {
    const int n = (int)options[0];
    return n*2-1;
}
int ti_cvi(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_cvi_start(options)) return 0;
    const double per = 2 / ((double)period + 1);
    ti_buffer *lag = ti_buffer_new(period);
    double val = high[0]-low[0];
    int i;
    for (i = 1; i < period*2-1; ++i) {
        val = ((high[i]-low[i])-val) * per + val;
        do { (lag)->vals[(lag)->index] = (val); (lag)->index = ((lag)->index + 1); if ((lag)->index >= (lag)->size) (lag)->index = 0; } while (0);
    }
    for (i = period*2-1; i < size; ++i) {
        val = ((high[i]-low[i])-val) * per + val;
        const double old = lag->vals[lag->index];
        *output++ = 100.0 * (val - old) / old;
        do { (lag)->vals[(lag)->index] = (val); (lag)->index = ((lag)->index + 1); if ((lag)->index >= (lag)->size) (lag)->index = 0; } while (0);
    }
    ti_buffer_free(lag);
    assert(output - outputs[0] == size - ti_cvi_start(options));
    return 0;
}
int ti_decay_start(double const *options) {
    (void)options;
    return 0;
}
int ti_decay(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    double *output = outputs[0];
    const int period = (int)options[0];
    const double scale = 1.0 / period;
    *output++ = input[0];
    int i;
    for (i = 1; i < size; ++i) {
        double d = output[-1] - scale;
        *output++ = input[i] > d ? input[i] : d;
    }
    return 0;
}
int ti_dema_start(double const *options) {
    const int period = (int)options[0];
    return (period-1) * 2;
}
int ti_dema(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_dema_start(options)) return 0;
    const double per = 2 / ((double)period + 1);
    const double per1 = 1.0 - per;
    double ema = input[0];
    double ema2 = ema;
    int i;
    for (i = 0; i < size; ++i) {
        ema = ema * per1 + input[i] * per;
        if (i == period-1) {
            ema2 = ema;
        }
        if (i >= period-1) {
            ema2 = ema2 * per1 + ema * per;
            if (i >= (period-1) * 2) {
                *output = ema * 2 - ema2;
                ++output;
            }
        }
    }
    assert(output - outputs[0] == size - ti_dema_start(options));
    return 0;
}
int ti_di_start(double const *options) {
    return (int)options[0]-1;
}
int ti_di(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const int period = (int)options[0];
    double *plus_di = outputs[0];
    double *minus_di = outputs[1];
    if (period < 1) return 1;
    if (size <= ti_di_start(options)) return 0;
    const double per = ((double)period-1) / ((double)period);
    double atr = 0;
    double dmup = 0;
    double dmdown = 0;
    int i;
    for (i = 1; i < period; ++i) {
        double truerange;
        do{ const double l = low[i]; const double h = high[i]; const double c = close[i-1]; const double ych = fabs(h - c); const double ycl = fabs(l - c); double v = h - l; if (ych > v) v = ych; if (ycl > v) v = ycl; truerange = v;}while(0);
        atr += truerange;
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup += dp;
        dmdown += dm;
    }
    *plus_di++ = 100.0 * dmup / atr;
    *minus_di++ = 100.0 * dmdown / atr;
    for (i = period; i < size; ++i) {
        double truerange;
        do{ const double l = low[i]; const double h = high[i]; const double c = close[i-1]; const double ych = fabs(h - c); const double ycl = fabs(l - c); double v = h - l; if (ych > v) v = ych; if (ycl > v) v = ycl; truerange = v;}while(0);
        atr = atr * per + truerange;
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup = dmup * per + dp;
        dmdown = dmdown * per + dm;
        *plus_di++ = 100.0 * dmup / atr;
        *minus_di++ = 100.0 * dmdown / atr;
    }
    assert(plus_di - outputs[0] == size - ti_di_start(options));
    assert(minus_di - outputs[1] == size - ti_di_start(options));
    return 0;
}
int ti_div_start(double const *options) { (void)options; return 0; } int ti_div(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; const double *in2 = inputs[1]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (in1[i] / in2[i]); } return 0; }
int ti_dm_start(double const *options) {
    return (int)options[0]-1;
}
int ti_dm(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const int period = (int)options[0];
    double *plus_dm = outputs[0];
    double *minus_dm = outputs[1];
    if (period < 1) return 1;
    if (size <= ti_dm_start(options)) return 0;
    const double per = ((double)period-1) / ((double)period);
    double dmup = 0;
    double dmdown = 0;
    int i;
    for (i = 1; i < period; ++i) {
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup += dp;
        dmdown += dm;
    }
    *plus_dm++ = dmup;
    *minus_dm++ = dmdown;
    for (i = period; i < size; ++i) {
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup = dmup * per + dp;
        dmdown = dmdown * per + dm;
        *plus_dm++ = dmup;
        *minus_dm++ = dmdown;
    }
    assert(plus_dm - outputs[0] == size - ti_dm_start(options));
    assert(minus_dm - outputs[1] == size - ti_dm_start(options));
    return 0;
}
int ti_dpo_start(double const *options) {
    return (int)options[0]-1;
}
int ti_dpo(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    const int back = period / 2 + 1;
    double *output = outputs[0];
    const double scale = 1.0 / period;
    if (period < 1) return 1;
    if (size <= ti_dpo_start(options)) return 0;
    double sum = 0;
    int i;
    for (i = 0; i < period; ++i) {
        sum += input[i];
    }
    *output++ = input[period-1-back] - (sum * scale);
    for (i = period; i < size; ++i) {
        sum += input[i];
        sum -= input[i-period];
        *output++ = input[i-back] - (sum * scale);
    }
    assert(output - outputs[0] == size - ti_dpo_start(options));
    return 0;
}
int ti_dx_start(double const *options) {
    return (int)options[0]-1;
}
int ti_dx(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_dx_start(options)) return 0;
    const double per = ((double)period-1) / ((double)period);
    double dmup = 0;
    double dmdown = 0;
    int i;
    for (i = 1; i < period; ++i) {
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup += dp;
        dmdown += dm;
    }
    {
        double di_up = dmup;
        double di_down = dmdown;
        double dm_diff = fabs(di_up - di_down);
        double dm_sum = di_up + di_down;
        double dx = dm_diff / dm_sum * 100;
        *output++ = dx;
    }
    for (i = period; i < size; ++i) {
        double dp, dm;
        do { dp = high[i] - high[i-1]; dm = low[i-1] - low[i]; if (dp < 0) dp = 0; else if (dp > dm) dm = 0; if (dm < 0) dm = 0; else if (dm > dp) dp = 0;} while (0);
        dmup = dmup * per + dp;
        dmdown = dmdown * per + dm;
        double di_up = dmup;
        double di_down = dmdown;
        double dm_diff = fabs(di_up - di_down);
        double dm_sum = di_up + di_down;
        double dx = dm_diff / dm_sum * 100;
        *output++ = dx;
    }
    assert(output - outputs[0] == size - ti_dx_start(options));
    return 0;
}
int ti_edecay_start(double const *options) {
    (void)options;
    return 0;
}
int ti_edecay(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    const double scale = 1.0 - 1.0 / period;
    *output++ = input[0];
    int i;
    for (i = 1; i < size; ++i) {
        double d = output[-1] * scale;
        *output++ = input[i] > d ? input[i] : d;
    }
    return 0;
}
int ti_ema_start(double const *options) {
    (void)options;
    return 0;
}
int ti_ema(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_ema_start(options)) return 0;
    const double per = 2 / ((double)period + 1);
    double val = input[0];
    *output++ = val;
    int i;
    for (i = 1; i < size; ++i) {
        val = (input[i]-val) * per + val;
        *output++ = val;
    }
    assert(output - outputs[0] == size - ti_ema_start(options));
    return 0;
}
int ti_emv_start(double const *options) {
    (void)options;
    return 1;
}
int ti_emv(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *volume = inputs[2];
    (void)options;
    double *output = outputs[0];
    if (size <= ti_emv_start(options)) return 0;
    double last = (high[0] + low[0]) * 0.5;
    int i;
    for (i = 1; i < size; ++i) {
        double hl = (high[i] + low[i]) * 0.5;
        double br = volume[i] / 10000.0 / (high[i] - low[i]);
        *output++ = (hl - last) / br;
        last = hl;
    }
    assert(output - outputs[0] == size - ti_emv_start(options));
    return 0;
}
int ti_exp_start(double const *options) { (void)options; return 0; } int ti_exp(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (exp(in1[i])); } return 0; }
int ti_fisher_start(double const *options) {
    return (int)options[0]-1;
}
int ti_fisher(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    double *fisher = outputs[0];
    double *signal = outputs[1];
    const int period = (int)options[0];
    if (period < 1) return 1;
    if (size <= ti_fisher_start(options)) return 0;
    int trail = 0, maxi = -1, mini = -1;
    double max = (0.5 * (high[(0)] + low[(0)]));
    double min = (0.5 * (high[(0)] + low[(0)]));
    double val1 = 0.0;
    double bar;
    double fish = 0.0;
    int i, j;
    for (i = period-1; i < size; ++i, ++trail) {
        bar = (0.5 * (high[(i)] + low[(i)]));
        if (maxi < trail) {
            maxi = trail;
            max = (0.5 * (high[(maxi)] + low[(maxi)]));
            j = trail;
            while(++j <= i) {
                bar = (0.5 * (high[(j)] + low[(j)]));
                if (bar >= max) {
                    max = bar;
                    maxi = j;
                }
            }
        } else if (bar >= max) {
            maxi = i;
            max = bar;
        }
        bar = (0.5 * (high[(i)] + low[(i)]));
        if (mini < trail) {
            mini = trail;
            min = (0.5 * (high[(mini)] + low[(mini)]));
            j = trail;
            while(++j <= i) {
                bar = (0.5 * (high[(j)] + low[(j)]));
                if (bar <= min) {
                    min = bar;
                    mini = j;
                }
            }
        } else if (bar <= min) {
            mini = i;
            min = bar;
        }
        double mm = max - min;
        if (mm == 0.0) mm = 0.001;
        val1 = 0.33 * 2.0 * ( ((0.5 * (high[(i)] + low[(i)]))-min) / (mm) - 0.5) + 0.67 * val1;
        if (val1 > 0.99) val1 = .999;
        if (val1 < -0.99) val1 = -.999;
        *signal++ = fish;
        fish = 0.5 * log((1.0+val1)/(1.0-val1)) + 0.5 * fish;
        *fisher++ = fish;
    }
    assert(fisher - outputs[0] == size - ti_fisher_start(options));
    assert(signal - outputs[1] == size - ti_fisher_start(options));
    return 0;
}
int ti_floor_start(double const *options) { (void)options; return 0; } int ti_floor(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (floor(in1[i])); } return 0; }
int ti_fosc_start(double const *options) {
    return (int)options[0];
}
int ti_fosc(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_fosc_start(options)) return 0;
    do { double x = 0; double x2 = 0; double y = 0; double xy = 0; const double p = (1.0 / (period)); double tsf = 0;; int i; for (i = 0; i < (period)-1; ++i) { x += i+1; x2 += (i+1)*(i+1); xy += (input)[i] * (i+1); y += (input)[i]; } x += (period); x2 += (period) * (period); const double bd = 1.0 / ((period) * x2 - x * x); for (i = (period)-1; i < (size); ++i) { xy += (input)[i] * (period); y += (input)[i]; const double b = ((period) * xy - x * y) * bd; do { const double a = (y - b * x) * p; if (i >= (period)) {*output++ = 100 * (input[i] - tsf) / input[i];} tsf = (a + b * ((period+1))); } while (0); xy -= y; y -= (input)[i-(period)+1]; } } while (0);
    assert(output - outputs[0] == size - ti_fosc_start(options));
    return 0;
}
int ti_hma_start(double const *options) {
    const int period = (int)options[0];
    const int periodsqrt = (int)(sqrt(period));
    return period + periodsqrt - 2;
}
int ti_hma(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_hma_start(options)) return 0;
    const int period2 = (int)(period / 2);
    const int periodsqrt = (int)(sqrt(period));
    const double weights = period * (period+1) / 2;
    const double weights2 = period2 * (period2+1) / 2;
    const double weightssqrt = periodsqrt * (periodsqrt+1) / 2;
    double sum = 0;
    double weight_sum = 0;
    double sum2 = 0;
    double weight_sum2 = 0;
    double sumsqrt = 0;
    double weight_sumsqrt = 0;
    int i;
    for (i = 0; i < period-1; ++i) {
        weight_sum += input[i] * (i+1);
        sum += input[i];
        if (i >= period - period2) {
            weight_sum2 += input[i] * (i+1-(period-period2));
            sum2 += input[i];
        }
    }
    ti_buffer *buff = ti_buffer_new(periodsqrt);
    for (i = period-1; i < size; ++i) {
        weight_sum += input[i] * period;
        sum += input[i];
        weight_sum2 += input[i] * period2;
        sum2 += input[i];
        const double wma = weight_sum / weights;
        const double wma2 = weight_sum2 / weights2;
        const double diff = 2 * wma2 - wma;
        weight_sumsqrt += diff * periodsqrt;
        sumsqrt += diff;
        do { (buff)->vals[(buff)->index] = (diff); (buff)->index = ((buff)->index + 1); if ((buff)->index >= (buff)->size) (buff)->index = 0; } while (0);
        if (i >= (period-1) + (periodsqrt-1)) {
            *output++ = weight_sumsqrt / weightssqrt;
            weight_sumsqrt -= sumsqrt;
            sumsqrt -= ((buff)->vals[((buff)->index + (buff)->size - 1 + (1)) % (buff)->size]);
        } else {
            weight_sumsqrt -= sumsqrt;
        }
        weight_sum -= sum;
        sum -= input[i-period+1];
        weight_sum2 -= sum2;
        sum2 -= input[i-period2+1];
    }
    ti_buffer_free(buff);
    assert(output - outputs[0] == size - ti_hma_start(options));
    return 0;
}
int ti_kama_start(double const *options) {
    return (int)options[0]-1;
}
int ti_kama(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_kama_start(options)) return 0;
    const double short_per = 2 / (2.0 + 1);
    const double long_per = 2 / (30.0 + 1);
    double sum = 0;
    int i;
    for (i = 1; i < period; ++i) {
        sum += fabs(input[i] - input[i-1]);
    }
    double kama = input[period-1];
    *output++ = kama;
    double er, sc;
    for (i = period; i < size; ++i) {
        sum += fabs(input[i] - input[i-1]);
        if (i > period) {
            sum -= fabs(input[i-period] - input[i-period-1]);
        }
        if (sum != 0.0) {
            er = fabs(input[i] - input[i-period]) / sum;
        } else {
            er = 1.0;
        }
        sc = pow(er * (short_per - long_per) + long_per, 2);
        kama = kama + sc * (input[i] - kama);
        *output++ = kama;
    }
    assert(output - outputs[0] == size - ti_kama_start(options));
    return 0;
}
int ti_kvo_start(double const *options) {
    (void)options;
    return 1;
}
int ti_kvo(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const double *volume = inputs[3];
    const int short_period = (int)options[0];
    const int long_period = (int)options[1];
    if (short_period < 1) return 1;
    if (long_period < short_period) return 1;
    if (size <= ti_kvo_start(options)) return 0;
    const double short_per = 2 / ((double)short_period + 1);
    const double long_per = 2 / ((double)long_period + 1);
    double *output = outputs[0];
    double cm = 0;
    double prev_hlc = high[0] + low[0] + close[0];
    int trend = -1;
    double short_ema = 0, long_ema = 0;
    int i;
    for (i = 1; i < size; ++i) {
        const double hlc = high[i] + low[i] + close[i];
        const double dm = high[i] - low[i];
        if (hlc > prev_hlc && trend != 1) {
            trend = 1;
            cm = high[i-1] - low[i-1];
        } else if (hlc < prev_hlc && trend != 0) {
            trend = 0;
            cm = high[i-1] - low[i-1];
        }
        cm += dm;
        const double vf = volume[i] * fabs(dm / cm * 2 - 1) * 100 * (trend ? 1.0 : -1.0);
        if (i == 1) {
            short_ema = vf;
            long_ema = vf;
        } else {
            short_ema = (vf-short_ema) * short_per + short_ema;
            long_ema = (vf-long_ema) * long_per + long_ema;
        }
        *output++ = short_ema - long_ema;
        prev_hlc = hlc;
    }
    assert(output - outputs[0] == size - ti_kvo_start(options));
    return 0;
}
int ti_lag_start(double const *options) {
    return (int)options[0];
}
int ti_lag(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 0) return 1;
    if (size <= ti_lag_start(options)) return 0;
    int i;
    for (i = period; i < size; ++i) {
        *output++ = input[i-period];
    }
    assert(output - outputs[0] == size - ti_lag_start(options));
    return 0;
}
int ti_linreg_start(double const *options) {
    return (int)options[0]-1;
}
int ti_linreg(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_linreg_start(options)) return 0;
    do { double x = 0; double x2 = 0; double y = 0; double xy = 0; const double p = (1.0 / (period)); int i; for (i = 0; i < (period)-1; ++i) { x += i+1; x2 += (i+1)*(i+1); xy += (input)[i] * (i+1); y += (input)[i]; } x += (period); x2 += (period) * (period); const double bd = 1.0 / ((period) * x2 - x * x); for (i = (period)-1; i < (size); ++i) { xy += (input)[i] * (period); y += (input)[i]; const double b = ((period) * xy - x * y) * bd; do { const double a = (y - b * x) * p; *output++ = (a + b * ((period))); } while (0); xy -= y; y -= (input)[i-(period)+1]; } } while (0);
    assert(output - outputs[0] == size - ti_linreg_start(options));
    return 0;
}
int ti_linregintercept_start(double const *options) {
    return (int)options[0]-1;
}
int ti_linregintercept(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_linregintercept_start(options)) return 0;
    do { double x = 0; double x2 = 0; double y = 0; double xy = 0; const double p = (1.0 / (period)); int i; for (i = 0; i < (period)-1; ++i) { x += i+1; x2 += (i+1)*(i+1); xy += (input)[i] * (i+1); y += (input)[i]; } x += (period); x2 += (period) * (period); const double bd = 1.0 / ((period) * x2 - x * x); for (i = (period)-1; i < (size); ++i) { xy += (input)[i] * (period); y += (input)[i]; const double b = ((period) * xy - x * y) * bd; do { const double a = (y - b * x) * p; *output++ = (a + b * ((1))); } while (0); xy -= y; y -= (input)[i-(period)+1]; } } while (0);
    assert(output - outputs[0] == size - ti_linregintercept_start(options));
    return 0;
}
int ti_linregslope_start(double const *options) {
    return (int)options[0]-1;
}
int ti_linregslope(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_linregslope_start(options)) return 0;
    do { double x = 0; double x2 = 0; double y = 0; double xy = 0; do{}while(0); int i; for (i = 0; i < (period)-1; ++i) { x += i+1; x2 += (i+1)*(i+1); xy += (input)[i] * (i+1); y += (input)[i]; } x += (period); x2 += (period) * (period); const double bd = 1.0 / ((period) * x2 - x * x); for (i = (period)-1; i < (size); ++i) { xy += (input)[i] * (period); y += (input)[i]; const double b = ((period) * xy - x * y) * bd; do { *output++ = b; } while (0); xy -= y; y -= (input)[i-(period)+1]; } } while (0);
    assert(output - outputs[0] == size - ti_linregslope_start(options));
    return 0;
}
int ti_ln_start(double const *options) { (void)options; return 0; } int ti_ln(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (log(in1[i])); } return 0; }
int ti_log10_start(double const *options) { (void)options; return 0; } int ti_log10(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (log10(in1[i])); } return 0; }
int ti_macd_start(double const *options) {
    const int long_period = (int)options[1];
    return (long_period-1);
}
int ti_macd(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    double *macd = outputs[0];
    double *signal = outputs[1];
    double *hist = outputs[2];
    const int short_period = (int)options[0];
    const int long_period = (int)options[1];
    const int signal_period = (int)options[2];
    if (short_period < 1) return 1;
    if (long_period < 2) return 1;
    if (long_period < short_period) return 1;
    if (signal_period < 1) return 1;
    if (size <= ti_macd_start(options)) return 0;
    double short_per = 2 / ((double)short_period + 1);
    double long_per = 2 / ((double)long_period + 1);
    double signal_per = 2 / ((double)signal_period + 1);
    if (short_period == 12 && long_period == 26) {
        short_per = 0.15;
        long_per = 0.075;
    }
    double short_ema = input[0];
    double long_ema = input[0];
    double signal_ema = 0;
    int i;
    for (i = 1; i < size; ++i) {
        short_ema = (input[i]-short_ema) * short_per + short_ema;
        long_ema = (input[i]-long_ema) * long_per + long_ema;
        const double out = short_ema - long_ema;
        if (i == long_period-1) {
            signal_ema = out;
        }
        if (i >= long_period-1) {
            signal_ema = (out-signal_ema) * signal_per + signal_ema;
            *macd++ = out;
            *signal++ = signal_ema;
            *hist++ = out - signal_ema;
        }
    }
    assert(macd - outputs[0] == size - ti_macd_start(options));
    assert(signal - outputs[1] == size - ti_macd_start(options));
    assert(hist - outputs[2] == size - ti_macd_start(options));
    return 0;
}
int ti_marketfi_start(double const *options) {
    (void)options;
    return 0;
}
int ti_marketfi(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *volume = inputs[2];
    (void)options;
    double *output = outputs[0];
    if (size <= ti_marketfi_start(options)) return 0;
    int i;
    for (i = 0; i < size; ++i) {
        *output++ = (high[i] - low[i]) / volume[i];
    }
    assert(output - outputs[0] == size - ti_marketfi_start(options));
    return 0;
}
int ti_mass_start(double const *options) {
    int sum_p = (int)options[0]-1;
    return 16 + sum_p;
}
int ti_mass(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_mass_start(options)) return 0;
    const double per = 2 / (9.0 + 1);
    const double per1 = 1.0 - per;
    double ema = high[0] - low[0];
    double ema2 = ema;
    ti_buffer *sum = ti_buffer_new(period);
    int i;
    for (i = 0; i < size; ++i) {
        double hl = high[i] - low[i];
        ema = ema * per1 + hl * per;
        if (i == 8) {
            ema2 = ema;
        }
        if (i >= 8) {
            ema2 = ema2 * per1 + ema * per;
            if (i >= 16) {
                do { if ((sum)->pushes >= (sum)->size) { (sum)->sum -= (sum)->vals[(sum)->index]; } (sum)->sum += (ema/ema2); (sum)->vals[(sum)->index] = (ema/ema2); (sum)->pushes += 1; (sum)->index = ((sum)->index + 1); if ((sum)->index >= (sum)->size) (sum)->index = 0; } while (0);
                if (i >= 16 + period - 1) {
                    *output++ = sum->sum;
                }
            }
        }
    }
    ti_buffer_free(sum);
    assert(output - outputs[0] == size - ti_mass_start(options));
    return 0;
}
int ti_max_start(double const *options) {
    return (int)options[0]-1;
}
int ti_max(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_max_start(options)) return 0;
    int trail = 0, maxi = -1;
    double max = input[0];
    int i, j;
    for (i = period-1; i < size; ++i, ++trail) {
        double bar = input[i];
        if (maxi < trail) {
            maxi = trail;
            max = input[maxi];
            j = trail;
            while(++j <= i) {
                bar = input[j];
                if (bar >= max) {
                    max = bar;
                    maxi = j;
                }
            }
        } else if (bar >= max) {
            maxi = i;
            max = bar;
        }
        *output++ = max;
    }
    assert(output - outputs[0] == size - ti_max_start(options));
    return 0;
}
int ti_max_ref(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_max_start(options)) return 0;
    for (int i = period-1; i < size; ++i) {
        double max = input[i-period+1];
        for (int j = i-period+2; j <= i; ++j) {
            max = ((max) > (input[j]) ? (max) : (input[j]));
        }
        *output++ = max;
    }
    return 0;
}
int ti_md_start(double const *options) {
    return (int)options[0]-1;
}
int ti_md(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    const double scale = 1.0 / period;
    if (period < 1) return 1;
    if (size <= ti_md_start(options)) return 0;
    double sum = 0;
    int i, j;
    for (i = 0; i < size; ++i) {
        const double today = input[i];
        sum += today;
        if (i >= period) sum -= input[i-period];
        const double avg = sum * scale;
        if (i >= period - 1) {
            double acc = 0;
            for (j = 0; j < period; ++j) {
                acc += fabs(avg - input[i-j]);
            }
            *output++ = acc * scale;
        }
    }
    assert(output - outputs[0] == size - ti_md_start(options));
    return 0;
}
int ti_medprice_start(double const *options) {
    (void)options;
    return 0;
}
int ti_medprice(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    (void)options;
    double *output = outputs[0];
    int i;
    for (i = 0; i < size; ++i) {
        output[i] = (high[i] + low[i]) * 0.5;
    }
    return 0;
}
int ti_mfi_start(double const *options) {
    return (int)options[0];
}
int ti_mfi(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const double *volume = inputs[3];
    const int period = (int)options[0];
    if (period < 1) return 1;
    if (size <= ti_mfi_start(options)) return 0;
    double *output = outputs[0];
    double ytyp = ((high[(0)] + low[(0)] + close[(0)]) * (1.0/3.0));
    int i;
    ti_buffer *up = ti_buffer_new(period);
    ti_buffer *down = ti_buffer_new(period);
    for (i = 1; i < size; ++i) {
        const double typ = ((high[(i)] + low[(i)] + close[(i)]) * (1.0/3.0));
        const double bar = typ * volume[i];
        if (typ > ytyp) {
            do { if ((up)->pushes >= (up)->size) { (up)->sum -= (up)->vals[(up)->index]; } (up)->sum += (bar); (up)->vals[(up)->index] = (bar); (up)->pushes += 1; (up)->index = ((up)->index + 1); if ((up)->index >= (up)->size) (up)->index = 0; } while (0);
            do { if ((down)->pushes >= (down)->size) { (down)->sum -= (down)->vals[(down)->index]; } (down)->sum += (0.0); (down)->vals[(down)->index] = (0.0); (down)->pushes += 1; (down)->index = ((down)->index + 1); if ((down)->index >= (down)->size) (down)->index = 0; } while (0);
        } else if (typ < ytyp) {
            do { if ((down)->pushes >= (down)->size) { (down)->sum -= (down)->vals[(down)->index]; } (down)->sum += (bar); (down)->vals[(down)->index] = (bar); (down)->pushes += 1; (down)->index = ((down)->index + 1); if ((down)->index >= (down)->size) (down)->index = 0; } while (0);
            do { if ((up)->pushes >= (up)->size) { (up)->sum -= (up)->vals[(up)->index]; } (up)->sum += (0.0); (up)->vals[(up)->index] = (0.0); (up)->pushes += 1; (up)->index = ((up)->index + 1); if ((up)->index >= (up)->size) (up)->index = 0; } while (0);
        } else {
            do { if ((up)->pushes >= (up)->size) { (up)->sum -= (up)->vals[(up)->index]; } (up)->sum += (0.0); (up)->vals[(up)->index] = (0.0); (up)->pushes += 1; (up)->index = ((up)->index + 1); if ((up)->index >= (up)->size) (up)->index = 0; } while (0);
            do { if ((down)->pushes >= (down)->size) { (down)->sum -= (down)->vals[(down)->index]; } (down)->sum += (0.0); (down)->vals[(down)->index] = (0.0); (down)->pushes += 1; (down)->index = ((down)->index + 1); if ((down)->index >= (down)->size) (down)->index = 0; } while (0);
        }
        ytyp = typ;
        if (i >= period) {
            *output++ = up->sum / (up->sum + down->sum) * 100.0;
        }
    }
    ti_buffer_free(up);
    ti_buffer_free(down);
    assert(output - outputs[0] == size - ti_mfi_start(options));
    return 0;
}
int ti_min_start(double const *options) {
    return (int)options[0]-1;
}
int ti_min(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_min_start(options)) return 0;
    int trail = 0, mini = -1;
    double min = input[0];
    int i, j;
    for (i = period-1; i < size; ++i, ++trail) {
        double bar = input[i];
        if (mini < trail) {
            mini = trail;
            min = input[mini];
            j = trail;
            while(++j <= i) {
                bar = input[j];
                if (bar <= min) {
                    min = bar;
                    mini = j;
                }
            }
        } else if (bar <= min) {
            mini = i;
            min = bar;
        }
        *output++ = min;
    }
    assert(output - outputs[0] == size - ti_min_start(options));
    return 0;
}
int ti_min_ref(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_min_start(options)) return 0;
    for (int i = period-1; i < size; ++i) {
        double min = input[i-period+1];
        for (int j = i-period+2; j <= i; ++j) {
            min = ((min) < (input[j]) ? (min) : (input[j]));
        }
        *output++ = min;
    }
    assert(output - outputs[0] == size - ti_min_start(options));
    return 0;
}
int ti_mom_start(double const *options) {
    return (int)options[0];
}
int ti_mom(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_mom_start(options)) return 0;
    int i;
    for (i = period; i < size; ++i) {
        *output++ = input[i] - input[i-period];
    }
    assert(output - outputs[0] == size - ti_mom_start(options));
    return 0;
}
int ti_msw_start(double const *options) {
    return (int)options[0];
}
int ti_msw(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    double *sine = outputs[0];
    double *lead = outputs[1];
    const int period = (int)options[0];
    if (period < 1) return 1;
    if (size <= ti_msw_start(options)) return 0;
    const double pi = 3.1415926;
    const double tpi = 2 * pi;
    double weight = 0, phase;
    double rp, ip;
    int i, j;
    for (i = period; i < size; ++i) {
        rp = 0;
        ip = 0;
        for (j = 0; j < period; ++j) {
            weight = input[i-j];
            rp = rp + cos(tpi * j / period) * weight;
            ip = ip + sin(tpi * j / period) * weight;
        }
        if (fabs(rp) > .001) {
            phase = atan(ip/rp);
        } else {
            phase = tpi / 2.0 * (ip < 0 ? -1.0 : 1.0);
        }
        if (rp < 0.0) phase += pi;
        phase += pi/2.0;
        if (phase < 0.0) phase += tpi;
        if (phase > tpi) phase -= tpi;
        *sine++ = sin(phase);
        *lead++ = sin(phase + pi/4.0);
    }
    assert(sine - outputs[0] == size - ti_msw_start(options));
    assert(lead - outputs[1] == size - ti_msw_start(options));
    return 0;
}
int ti_mul_start(double const *options) { (void)options; return 0; } int ti_mul(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; const double *in2 = inputs[1]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (in1[i] * in2[i]); } return 0; }
int ti_natr_start(double const *options) {
    return (int)options[0]-1;
}
int ti_natr(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_natr_start(options)) return 0;
    const double per = 1.0 / ((double)period);
    double sum = 0;
    double truerange;
    sum += high[0] - low[0];
    int i;
    for (i = 1; i < period; ++i) {
        do{ const double l = low[i]; const double h = high[i]; const double c = close[i-1]; const double ych = fabs(h - c); const double ycl = fabs(l - c); double v = h - l; if (ych > v) v = ych; if (ycl > v) v = ycl; truerange = v;}while(0);
        sum += truerange;
    }
    double val = sum / period;
    *output++ = 100 * (val) / close[period-1];
    for (i = period; i < size; ++i) {
        do{ const double l = low[i]; const double h = high[i]; const double c = close[i-1]; const double ych = fabs(h - c); const double ycl = fabs(l - c); double v = h - l; if (ych > v) v = ych; if (ycl > v) v = ycl; truerange = v;}while(0);
        val = (truerange-val) * per + val;
        *output++ = 100 * (val) / close[i];
    }
    assert(output - outputs[0] == size - ti_natr_start(options));
    return 0;
}
int ti_nvi_start(double const *options) {
    (void)options;
    return 0;
}
int ti_nvi(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *close = inputs[0];
    const double *volume = inputs[1];
    (void)options;
    double *output = outputs[0];
    if (size <= ti_nvi_start(options)) return 0;
    double nvi = 1000;
    *output++ = nvi;
    int i;
    for (i = 1; i < size; ++i) {
        if (volume[i] < volume[i-1]) {
            nvi += ((close[i] - close[i-1])/close[i-1]) * nvi;
        }
        *output++ = nvi;
    }
    assert(output - outputs[0] == size - ti_nvi_start(options));
    return 0;
}
int ti_obv_start(double const *options) {
    (void)options;
    return 0;
}
int ti_obv(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *close = inputs[0];
    const double *volume = inputs[1];
    (void)options;
    double *output = outputs[0];
    double sum = 0;
    *output++ = sum;
    double prev = close[0];
    int i;
    for (i = 1; i < size; ++i) {
        if (close[i] > prev) {
            sum += volume[i];
        } else if (close[i] < prev) {
            sum -= volume[i];
        } else {
        }
        prev = close[i];
        *output++ = sum;
    }
    return 0;
}
int ti_ppo_start(double const *options) {
    (void)options;
    return 1;
}
int ti_ppo(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    double *ppo = outputs[0];
    const int short_period = (int)options[0];
    const int long_period = (int)options[1];
    if (short_period < 1) return 1;
    if (long_period < 2) return 1;
    if (long_period < short_period) return 1;
    if (size <= ti_ppo_start(options)) return 0;
    double short_per = 2 / ((double)short_period + 1);
    double long_per = 2 / ((double)long_period + 1);
    double short_ema = input[0];
    double long_ema = input[0];
    int i;
    for (i = 1; i < size; ++i) {
        short_ema = (input[i]-short_ema) * short_per + short_ema;
        long_ema = (input[i]-long_ema) * long_per + long_ema;
        const double out = 100.0 * (short_ema - long_ema) / long_ema;
        *ppo++ = out;
    }
    assert(ppo - outputs[0] == size - ti_ppo_start(options));
    return 0;
}
int ti_psar_start(double const *options) {
    (void)options;
    return 1;
}
int ti_psar(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double accel_step = options[0];
    const double accel_max = options[1];
    double *output = outputs[0];
    if (accel_step <= 0) return 1;
    if (accel_max <= accel_step) return 1;
    if (size < 2) return 0;
    int lng;
    if (high[0] + low[0] <= high[1] + low[1])
        lng = 1;
    else
        lng = 0;
    double sar, extreme;
    if (lng) {
        extreme = high[0];
        sar = low[0];
    } else {
        extreme = low[0];
        sar = high[0];
    }
    double accel = accel_step;
    int i;
    for (i = 1; i < size; ++i) {
        sar = (extreme - sar) * accel + sar;
        if (lng) {
            if (i >= 2 && (sar > low[i-2])) sar = low[i-2];
            if ((sar > low[i-1])) sar = low[i-1];
            if (accel < accel_max && high[i] > extreme) {
                accel += accel_step;
                if (accel > accel_max) accel = accel_max;
            }
            if (high[i] > extreme) extreme = high[i];
        } else {
            if (i >= 2 && (sar < high[i-2])) sar = high[i-2];
            if ((sar < high[i-1])) sar = high[i-1];
            if (accel < accel_max && low[i] < extreme) {
                accel += accel_step;
                if (accel > accel_max) accel = accel_max;
            }
            if (low[i] < extreme) extreme = low[i];
        }
        if ((lng && low[i] < sar) || (!lng && high[i] > sar)) {
            accel = accel_step;
            sar = extreme;
            lng = !lng;
            if (!lng) extreme = low[i];
            else extreme = high[i];
        }
        *output++ = sar;
    }
    assert(output - outputs[0] == size - ti_psar_start(options));
    return 0;
}
int ti_pvi_start(double const *options) {
    (void)options;
    return 0;
}
int ti_pvi(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *close = inputs[0];
    const double *volume = inputs[1];
    (void)options;
    double *output = outputs[0];
    if (size <= ti_pvi_start(options)) return 0;
    double pvi = 1000;
    *output++ = pvi;
    int i;
    for (i = 1; i < size; ++i) {
        if (volume[i] > volume[i-1]) {
            pvi += ((close[i] - close[i-1])/close[i-1]) * pvi;
        }
        *output++ = pvi;
    }
    assert(output - outputs[0] == size - ti_pvi_start(options));
    return 0;
}
int ti_qstick_start(double const *options) {
    return (int)options[0]-1;
}
int ti_qstick(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *open = inputs[0];
    const double *close = inputs[1];
    double *output = outputs[0];
    const int period = (int)options[0];
    const double scale = 1.0 / period;
    if (period < 1) return 1;
    if (size <= ti_qstick_start(options)) return 0;
    double sum = 0;
    int i;
    for (i = 0; i < period; ++i) {
        sum += close[i] - open[i];
    }
    *output++ = sum * scale;
    for (i = period; i < size; ++i) {
        sum += close[i] - open[i];
        sum -= close[i-period] - open[i-period];
        *output++ = sum * scale;
    }
    assert(output - outputs[0] == size - ti_qstick_start(options));
    return 0;
}
int ti_roc_start(double const *options) {
    return (int)options[0];
}
int ti_roc(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_roc_start(options)) return 0;
    int i;
    for (i = period; i < size; ++i) {
        *output++ = (input[i] - input[i-period]) / input[i-period];
    }
    assert(output - outputs[0] == size - ti_roc_start(options));
    return 0;
}
int ti_rocr_start(double const *options) {
    return (int)options[0];
}
int ti_rocr(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_rocr_start(options)) return 0;
    int i;
    for (i = period; i < size; ++i) {
        *output++ = input[i] / input[i-period];
    }
    assert(output - outputs[0] == size - ti_rocr_start(options));
    return 0;
}
int ti_round_start(double const *options) { (void)options; return 0; } int ti_round(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (floor(in1[i] + 0.5)); } return 0; }
int ti_rsi_start(double const *options) {
    return (int)options[0];
}
int ti_rsi(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    const double per = 1.0 / ((double)period);
    if (period < 1) return 1;
    if (size <= ti_rsi_start(options)) return 0;
    double smooth_up = 0, smooth_down = 0;
    int i;
    for (i = 1; i <= period; ++i) {
        const double upward = input[i] > input[i-1] ? input[i] - input[i-1] : 0;
        const double downward = input[i] < input[i-1] ? input[i-1] - input[i] : 0;
        smooth_up += upward;
        smooth_down += downward;
    }
    smooth_up /= period;
    smooth_down /= period;
    *output++ = 100.0 * (smooth_up / (smooth_up + smooth_down));
    for (i = period+1; i < size; ++i) {
        const double upward = input[i] > input[i-1] ? input[i] - input[i-1] : 0;
        const double downward = input[i] < input[i-1] ? input[i-1] - input[i] : 0;
        smooth_up = (upward-smooth_up) * per + smooth_up;
        smooth_down = (downward-smooth_down) * per + smooth_down;
        *output++ = 100.0 * (smooth_up / (smooth_up + smooth_down));
    }
    assert(output - outputs[0] == size - ti_rsi_start(options));
    return 0;
}
int ti_sin_start(double const *options) { (void)options; return 0; } int ti_sin(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (sin(in1[i])); } return 0; }
int ti_sinh_start(double const *options) { (void)options; return 0; } int ti_sinh(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (sinh(in1[i])); } return 0; }
int ti_sma_start(double const *options) {
    return (int)options[0]-1;
}
int ti_sma(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    const double scale = 1.0 / period;
    if (period < 1) return 1;
    if (size <= ti_sma_start(options)) return 0;
    double sum = 0;
    int i;
    for (i = 0; i < period; ++i) {
        sum += input[i];
    }
    *output++ = sum * scale;
    for (i = period; i < size; ++i) {
        sum += input[i];
        sum -= input[i-period];
        *output++ = sum * scale;
    }
    assert(output - outputs[0] == size - ti_sma_start(options));
    return 0;
}
typedef struct ti_stream_sma {
    int index;
    int progress;
    int period;
    double per;
    double sum;
    int buffer_idx;
    double buffer[];
} ti_stream_sma;
int ti_sma_stream_new(double const *options, ti_stream **stream_in) {
    ti_stream_sma **stream = (ti_stream_sma**)stream_in;
    int period = (int)options[0];
    if (period < 1) return 1;
    *stream = malloc(sizeof(ti_stream_sma) + sizeof(double) * period);
    if (!stream) {
        return 2;
    }
    (*stream)->index = 72;
    (*stream)->progress = -ti_sma_start(options);
    (*stream)->period = period;
    (*stream)->per = 1. / period;
    (*stream)->sum = 0.;
    (*stream)->buffer_idx = -1;
    return 0;
}
int ti_sma_stream_run(ti_stream *stream_in, int size, double const *const *inputs, double *const *outputs) {
    ti_stream_sma *stream = (ti_stream_sma*)stream_in;
    int progress = stream->progress;
    const double *real = inputs[0];
    int period = stream->period;
    double *sma = outputs[0];
    double per = stream->per;
    double sum = stream->sum;
    int buffer_idx = stream->buffer_idx;
    double *buffer = stream->buffer;
    if (progress == -period + 1) {} else {}
    int i;
    for (i = 0; progress < 1 && i < size; ++i, ++progress) {
        { ++buffer_idx; sum += buffer[buffer_idx] = real[i] * per; };
    }
    if (i > 0 && progress == 1) {
        *sma++ = sum;
    }
    for (; i < size; ++i, ++progress) {
        { ++buffer_idx; if (buffer_idx == period) { buffer_idx = 0; } sum -= buffer[buffer_idx]; sum += buffer[buffer_idx] = real[i] * per; };
        *sma++ = sum;
    }
    stream->progress = progress;
    stream->sum = sum;
    stream->buffer_idx = buffer_idx;
    return 0;
}
void ti_sma_stream_free(ti_stream *stream) {
    free(stream);
}
int ti_sqrt_start(double const *options) { (void)options; return 0; } int ti_sqrt(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (sqrt(in1[i])); } return 0; }
int ti_stddev_start(double const *options) {
    return (int)options[0]-1;
}
int ti_stddev(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    const double scale = 1.0 / period;
    if (period < 1) return 1;
    if (size <= ti_stddev_start(options)) return 0;
    double sum = 0;
    double sum2 = 0;
    int i;
    for (i = 0; i < period; ++i) {
        sum += input[i];
        sum2 += input[i] * input[i];
    }
    {
        double s2s2 = (sum2 * scale - (sum * scale) * (sum * scale));
        if (s2s2 > 0.0) s2s2 = sqrt(s2s2);
        *output++ = s2s2;
    }
    for (i = period; i < size; ++i) {
        sum += input[i];
        sum2 += input[i] * input[i];
        sum -= input[i-period];
        sum2 -= input[i-period] * input[i-period];
        double s2s2 = (sum2 * scale - (sum * scale) * (sum * scale));
        if (s2s2 > 0.0) s2s2 = sqrt(s2s2);
        *output++ = s2s2;
    }
    assert(output - outputs[0] == size - ti_stddev_start(options));
    return 0;
}
int ti_stderr_start(double const *options) {
    return (int)options[0]-1;
}
int ti_stderr(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    const double scale = 1.0 / period;
    if (period < 1) return 1;
    if (size <= ti_stderr_start(options)) return 0;
    double sum = 0;
    double sum2 = 0;
    const double mul = 1.0 / sqrt(period);
    int i;
    for (i = 0; i < period; ++i) {
        sum += input[i];
        sum2 += input[i] * input[i];
    }
    {
        double s2s2 = (sum2 * scale - (sum * scale) * (sum * scale));
        if (s2s2 > 0.0) s2s2 = sqrt(s2s2);
        *output++ = mul * s2s2;
    }
    for (i = period; i < size; ++i) {
        sum += input[i];
        sum2 += input[i] * input[i];
        sum -= input[i-period];
        sum2 -= input[i-period] * input[i-period];
        double s2s2 = (sum2 * scale - (sum * scale) * (sum * scale));
        if (s2s2 > 0.0) s2s2 = sqrt(s2s2);
        *output++ = mul * s2s2;
    }
    assert(output - outputs[0] == size - ti_stderr_start(options));
    return 0;
}
int ti_stoch_start(double const *options) {
    const int kperiod = (int)options[0];
    const int kslow = (int)options[1];
    const int dperiod = (int)options[2];
    return kperiod + kslow + dperiod - 3;
}
int ti_stoch(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const int kperiod = (int)options[0];
    const int kslow = (int)options[1];
    const int dperiod = (int)options[2];
    const double kper = 1.0 / kslow;
    const double dper = 1.0 / dperiod;
    double *stoch = outputs[0];
    double *stoch_ma = outputs[1];
    if (kperiod < 1) return 1;
    if (kslow < 1) return 1;
    if (dperiod < 1) return 1;
    if (size <= ti_stoch_start(options)) return 0;
    int trail = 0, maxi = -1, mini = -1;
    double max = high[0];
    double min = low[0];
    double bar;
    ti_buffer *k_sum = ti_buffer_new(kslow);
    ti_buffer *d_sum = ti_buffer_new(dperiod);
    int i, j;
    for (i = 0; i < size; ++i) {
        if (i >= kperiod) ++trail;
        bar = high[i];
        if (maxi < trail) {
            maxi = trail;
            max = high[maxi];
            j = trail;
            while(++j <= i) {
                bar = high[j];
                if (bar >= max) {
                    max = bar;
                    maxi = j;
                }
            }
        } else if (bar >= max) {
            maxi = i;
            max = bar;
        }
        bar = low[i];
        if (mini < trail) {
            mini = trail;
            min = low[mini];
            j = trail;
            while(++j <= i) {
                bar = low[j];
                if (bar <= min) {
                    min = bar;
                    mini = j;
                }
            }
        } else if (bar <= min) {
            mini = i;
            min = bar;
        }
        const double kdiff = (max - min);
        const double kfast = kdiff == 0.0 ? 0.0 : 100 * ((close[i] - min) / kdiff);
        do { if ((k_sum)->pushes >= (k_sum)->size) { (k_sum)->sum -= (k_sum)->vals[(k_sum)->index]; } (k_sum)->sum += (kfast); (k_sum)->vals[(k_sum)->index] = (kfast); (k_sum)->pushes += 1; (k_sum)->index = ((k_sum)->index + 1); if ((k_sum)->index >= (k_sum)->size) (k_sum)->index = 0; } while (0);
        if (i >= kperiod-1 + kslow-1) {
            const double k = k_sum->sum * kper;
            do { if ((d_sum)->pushes >= (d_sum)->size) { (d_sum)->sum -= (d_sum)->vals[(d_sum)->index]; } (d_sum)->sum += (k); (d_sum)->vals[(d_sum)->index] = (k); (d_sum)->pushes += 1; (d_sum)->index = ((d_sum)->index + 1); if ((d_sum)->index >= (d_sum)->size) (d_sum)->index = 0; } while (0);
            if (i >= kperiod-1 + kslow-1 + dperiod-1) {
                *stoch++ = k;
                *stoch_ma++ = d_sum->sum * dper;
            }
        }
    }
    ti_buffer_free(k_sum);
    ti_buffer_free(d_sum);
    assert(stoch - outputs[0] == size - ti_stoch_start(options));
    assert(stoch_ma - outputs[1] == size - ti_stoch_start(options));
    return 0;
}
int ti_stochrsi_start(double const *options) {
    return ((int)options[0]) * 2 - 1;
}
int ti_stochrsi(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    const double per = 1.0 / ((double)period);
    if (period < 2) return 1;
    if (size <= ti_stochrsi_start(options)) return 0;
    ti_buffer *rsi = ti_buffer_new(period);
    double smooth_up = 0, smooth_down = 0;
    int i;
    for (i = 1; i <= period; ++i) {
        const double upward = input[i] > input[i-1] ? input[i] - input[i-1] : 0;
        const double downward = input[i] < input[i-1] ? input[i-1] - input[i] : 0;
        smooth_up += upward;
        smooth_down += downward;
    }
    smooth_up /= period;
    smooth_down /= period;
    double r = 100.0 * (smooth_up / (smooth_up + smooth_down));
    do { if ((rsi)->pushes >= (rsi)->size) { (rsi)->sum -= (rsi)->vals[(rsi)->index]; } (rsi)->sum += (r); (rsi)->vals[(rsi)->index] = (r); (rsi)->pushes += 1; (rsi)->index = ((rsi)->index + 1); if ((rsi)->index >= (rsi)->size) (rsi)->index = 0; } while (0);
    double min = r;
    double max = r;
    int mini = 0;
    int maxi = 0;
    for (i = period+1; i < size; ++i) {
        const double upward = input[i] > input[i-1] ? input[i] - input[i-1] : 0;
        const double downward = input[i] < input[i-1] ? input[i-1] - input[i] : 0;
        smooth_up = (upward-smooth_up) * per + smooth_up;
        smooth_down = (downward-smooth_down) * per + smooth_down;
        r = 100.0 * (smooth_up / (smooth_up + smooth_down));
        if (r > max) {
            max = r;
            maxi = rsi->index;
        } else if (maxi == rsi->index) {
            max = r;
            int j;
            for (j = 0; j < rsi->size; ++j) {
                if (j == rsi->index) continue;
                if (rsi->vals[j] > max) {
                    max = rsi->vals[j];
                    maxi = j;
                }
            }
        }
        if (r < min) {
            min = r;
            mini = rsi->index;
        } else if (mini == rsi->index) {
            min = r;
            int j;
            for (j = 0; j < rsi->size; ++j) {
                if (j == rsi->index) continue;
                if (rsi->vals[j] < min) {
                    min = rsi->vals[j];
                    mini = j;
                }
            }
        }
        do { (rsi)->vals[(rsi)->index] = (r); (rsi)->index = ((rsi)->index + 1); if ((rsi)->index >= (rsi)->size) (rsi)->index = 0; } while (0);
        if (i > period*2 - 2) {
            const double diff = max - min;
            if (diff == 0.0) {
                *output++ = 0.0;
            } else {
                *output++ = (r - min) / (diff);
            }
        }
    }
    ti_buffer_free(rsi);
    assert(output - outputs[0] == size - ti_stochrsi_start(options));
    return 0;
}
int ti_sub_start(double const *options) { (void)options; return 0; } int ti_sub(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; const double *in2 = inputs[1]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (in1[i] - in2[i]); } return 0; }
int ti_sum_start(double const *options) {
    return (int)options[0]-1;
}
int ti_sum(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_sum_start(options)) return 0;
    double sum = 0;
    int i;
    for (i = 0; i < period; ++i) {
        sum += input[i];
    }
    *output++ = sum;
    for (i = period; i < size; ++i) {
        sum += input[i];
        sum -= input[i-period];
        *output++ = sum;
    }
    assert(output - outputs[0] == size - ti_sum_start(options));
    return 0;
}
int ti_tan_start(double const *options) { (void)options; return 0; } int ti_tan(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (tan(in1[i])); } return 0; }
int ti_tanh_start(double const *options) { (void)options; return 0; } int ti_tanh(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = (tanh(in1[i])); } return 0; }
int ti_tema_start(double const *options) {
    const int period = (int)options[0];
    return (period-1) * 3;
}
int ti_tema(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_tema_start(options)) return 0;
    const double per = 2 / ((double)period + 1);
    const double per1 = 1.0 - per;
    double ema = input[0];
    double ema2 = 0;
    double ema3 = 0;
    int i;
    for (i = 0; i < size; ++i) {
        ema = ema * per1 + input[i] * per;
        if (i == period-1) {
            ema2 = ema;
        }
        if (i >= period-1) {
            ema2 = ema2 * per1 + ema * per;
            if (i == (period-1) * 2) {
                ema3 = ema2;
            }
            if (i >= (period-1) * 2) {
                ema3 = ema3 * per1 + ema2 * per;
                if (i >= (period-1) * 3) {
                    *output = 3 * ema - 3 * ema2 + ema3;
                    ++output;
                }
            }
        }
    }
    assert(output - outputs[0] == size - ti_tema_start(options));
    return 0;
}
int ti_todeg_start(double const *options) { (void)options; return 0; } int ti_todeg(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = ((in1[i] * (180.0 / 3.14159265358979323846))); } return 0; }
int ti_torad_start(double const *options) { (void)options; return 0; } int ti_torad(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = ((in1[i] * (3.14159265358979323846 / 180.0))); } return 0; }
int ti_tr_start(double const *options) {
    (void)options;
    return 0;
}
int ti_tr(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    (void)options;
    double *output = outputs[0];
    double truerange;
    output[0] = high[0] - low[0];
    int i;
    for (i = 1; i < size; ++i) {
        do{ const double l = low[i]; const double h = high[i]; const double c = close[i-1]; const double ych = fabs(h - c); const double ycl = fabs(l - c); double v = h - l; if (ych > v) v = ych; if (ycl > v) v = ycl; truerange = v;}while(0);
        output[i] = truerange;
    }
    return 0;
}
int ti_trima_start(double const *options) {
    return (int)options[0]-1;
}
int ti_trima(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_trima_start(options)) return 0;
    if (period <= 2) return ti_sma(size, inputs, options, outputs);
    double weights = 1 / (double) ((period%2) ?
        ((period/2+1) * (period/2+1)):
        ((period/2+1) * (period/2)));
    double weight_sum = 0;
    double lead_sum = 0;
    double trail_sum = 0;
    const int lead_period = period%2 ? period/2 : period/2-1;
    const int trail_period = lead_period + 1;
    int i, w = 1;
    for (i = 0; i < period-1; ++i) {
        weight_sum += input[i] * w;
        if (i+1 > period-lead_period) lead_sum += input[i];
        if (i+1 <= trail_period) trail_sum += input[i];
        if (i+1 < trail_period) ++w;
        if (i+1 >= period-lead_period) --w;
    }
    int lsi = (period-1)-lead_period+1;
    int tsi1 = (period-1)-period+1+trail_period;
    int tsi2 = (period-1)-period+1;
    for (i = period-1; i < size; ++i) {
        weight_sum += input[i];
        *output++ = weight_sum * weights;
        lead_sum += input[i];
        weight_sum += lead_sum;
        weight_sum -= trail_sum;
        lead_sum -= input[lsi++];
        trail_sum += input[tsi1++];
        trail_sum -= input[tsi2++];
    }
    assert(output - outputs[0] == size - ti_trima_start(options));
    return 0;
}
int ti_trix_start(double const *options) {
    const int period = (int)options[0];
    return ((period-1)*3)+1;
}
int ti_trix(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_trix_start(options)) return 0;
    const int start = (period*3)-2;
    assert(start == ti_trix_start(options));
    const double per = 2 / ((double)period + 1);
    double ema1 = input[0];
    double ema2 = 0, ema3 = 0;
    int i;
    for (i = 1; i < start; ++i) {
        ema1 = (input[i]-ema1) * per + ema1;
        if (i == period-1) {
            ema2 = ema1;
        } else if (i > period-1) {
            ema2 = (ema1-ema2) * per + ema2;
            if (i == period * 2 - 2) {
                ema3 = ema2;
            } else if (i > period * 2 - 2) {
                ema3 = (ema2-ema3) * per + ema3;
            }
        }
    }
    for (i = start; i < size; ++i) {
        ema1 = (input[i]-ema1) * per + ema1;
        ema2 = (ema1-ema2) * per + ema2;
        const double last = ema3;
        ema3 = (ema2-ema3) * per + ema3;
        *output++ = (ema3-last)/ema3 * 100.0;
    }
    assert(output - outputs[0] == size - ti_trix_start(options));
    return 0;
}
int ti_trunc_start(double const *options) { (void)options; return 0; } int ti_trunc(int size, double const *const *inputs, double const *options, double *const *outputs) { const double *in1 = inputs[0]; (void)options; double *output = outputs[0]; int i; for (i = 0; i < size; ++i) { output[i] = ((int)(in1[i])); } return 0; }
int ti_tsf_start(double const *options) {
    return (int)options[0]-1;
}
int ti_tsf(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_tsf_start(options)) return 0;
    do { double x = 0; double x2 = 0; double y = 0; double xy = 0; const double p = (1.0 / (period)); int i; for (i = 0; i < (period)-1; ++i) { x += i+1; x2 += (i+1)*(i+1); xy += (input)[i] * (i+1); y += (input)[i]; } x += (period); x2 += (period) * (period); const double bd = 1.0 / ((period) * x2 - x * x); for (i = (period)-1; i < (size); ++i) { xy += (input)[i] * (period); y += (input)[i]; const double b = ((period) * xy - x * y) * bd; do { const double a = (y - b * x) * p; *output++ = (a + b * ((period+1))); } while (0); xy -= y; y -= (input)[i-(period)+1]; } } while (0);
    assert(output - outputs[0] == size - ti_tsf_start(options));
    return 0;
}
int ti_typprice_start(double const *options) {
    (void)options;
    return 0;
}
int ti_typprice(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    (void)options;
    double *output = outputs[0];
    int i;
    for (i = 0; i < size; ++i) {
        output[i] = (high[i] + low[i] + close[i]) * (1.0/3.0);
    }
    return 0;
}
int ti_ultosc_start(double const *options) {
    return (int)options[2];
}
int ti_ultosc(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const int short_period = (int)options[0];
    const int medium_period = (int)options[1];
    const int long_period = (int)options[2];
    double *output = outputs[0];
    if (short_period < 1) return 1;
    if (medium_period < short_period) return 1;
    if (long_period < medium_period) return 1;
    if (size <= ti_ultosc_start(options)) return 0;
    ti_buffer *bp_buf = ti_buffer_new(long_period);
    ti_buffer *r_buf = ti_buffer_new(long_period);
    double bp_short_sum = 0, bp_medium_sum = 0;
    double r_short_sum = 0, r_medium_sum = 0;
    int i;
    for (i = 1; i < size; ++i) {
        const double true_low = ((low[i])<(close[i-1])?(low[i]):(close[i-1]));
        const double true_high = ((high[i])>(close[i-1])?(high[i]):(close[i-1]));
        const double bp = close[i] - true_low;
        const double r = true_high - true_low;
        bp_short_sum += bp;
        bp_medium_sum += bp;
        r_short_sum += r;
        r_medium_sum += r;
        do { if ((bp_buf)->pushes >= (bp_buf)->size) { (bp_buf)->sum -= (bp_buf)->vals[(bp_buf)->index]; } (bp_buf)->sum += (bp); (bp_buf)->vals[(bp_buf)->index] = (bp); (bp_buf)->pushes += 1; (bp_buf)->index = ((bp_buf)->index + 1); if ((bp_buf)->index >= (bp_buf)->size) (bp_buf)->index = 0; } while (0);
        do { if ((r_buf)->pushes >= (r_buf)->size) { (r_buf)->sum -= (r_buf)->vals[(r_buf)->index]; } (r_buf)->sum += (r); (r_buf)->vals[(r_buf)->index] = (r); (r_buf)->pushes += 1; (r_buf)->index = ((r_buf)->index + 1); if ((r_buf)->index >= (r_buf)->size) (r_buf)->index = 0; } while (0);
        if (i > short_period) {
            int short_index = bp_buf->index - short_period - 1;
            if (short_index < 0) short_index += long_period;
            bp_short_sum -= bp_buf->vals[short_index];
            r_short_sum -= r_buf->vals[short_index];
            if (i > medium_period) {
                int medium_index = bp_buf->index - medium_period - 1;
                if (medium_index < 0) medium_index += long_period;
                bp_medium_sum -= bp_buf->vals[medium_index];
                r_medium_sum -= r_buf->vals[medium_index];
            }
        }
        if (i >= long_period) {
            const double first = 4 * bp_short_sum / r_short_sum;
            const double second = 2 * bp_medium_sum / r_medium_sum;
            const double third = 1 * bp_buf->sum / r_buf->sum;
            const double ult = (first + second + third) * 100.0 / 7.0;
            *output++ = ult;
        }
    }
    ti_buffer_free(bp_buf);
    ti_buffer_free(r_buf);
    assert(output - outputs[0] == size - ti_ultosc_start(options));
    return 0;
}
int ti_var_start(double const *options) {
    return (int)options[0]-1;
}
int ti_var(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    const double scale = 1.0 / period;
    if (period < 1) return 1;
    if (size <= ti_var_start(options)) return 0;
    double sum = 0;
    double sum2 = 0;
    int i;
    for (i = 0; i < period; ++i) {
        sum += input[i];
        sum2 += input[i] * input[i];
    }
    *output++ = sum2 * scale - (sum * scale) * (sum * scale);
    for (i = period; i < size; ++i) {
        sum += input[i];
        sum2 += input[i] * input[i];
        sum -= input[i-period];
        sum2 -= input[i-period] * input[i-period];
        *output++ = sum2 * scale - (sum * scale) * (sum * scale);
    }
    assert(output - outputs[0] == size - ti_var_start(options));
    return 0;
}
int ti_vhf_start(double const *options) {
    return (int)options[0];
}
int ti_vhf(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *in = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_vhf_start(options)) return 0;
    int trail = 1, maxi = -1, mini = -1;
    double max = in[0], min = in[0];
    double bar;
    double sum = 0;
    int i, j;
    double yc = in[0];
    double c;
    for (i = 1; i < period; ++i) {
        c = in[i];
        sum += fabs(c - yc);
        yc = c;
    }
    for (i = period; i < size; ++i, ++trail) {
        c = in[i];
        sum += fabs(c - yc);
        yc = c;
        if (i > period) {
            sum -= fabs(in[i-period] - in[i-period-1]);
        }
        bar = c;
        if (maxi < trail) {
            maxi = trail;
            max = in[maxi];
            j = trail;
            while(++j <= i) {
                bar = in[j];
                if (bar >= max) {
                    max = bar;
                    maxi = j;
                }
            }
        } else if (bar >= max) {
            maxi = i;
            max = bar;
        }
        bar = c;
        if (mini < trail) {
            mini = trail;
            min = in[mini];
            j = trail;
            while(++j <= i) {
                bar = in[j];
                if (bar <= min) {
                    min = bar;
                    mini = j;
                }
            }
        } else if (bar <= min) {
            mini = i;
            min = bar;
        }
        *output++ = fabs(max - min) / sum;
    }
    assert(output - outputs[0] == size - ti_vhf_start(options));
    return 0;
}
int ti_vidya_start(double const *options) {
    return ((int)(options[1])) - 2;
}
int ti_vidya(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int short_period = (int)options[0];
    const int long_period = (int)options[1];
    const double alpha = options[2];
    double *output = outputs[0];
    const double short_div = 1.0 / short_period;
    const double long_div = 1.0 / long_period;
    if (short_period < 1) return 1;
    if (long_period < short_period) return 1;
    if (long_period < 2) return 1;
    if (alpha < 0.0 || alpha > 1.0) return 1;
    if (size <= ti_vidya_start(options)) return 0;
    double short_sum = 0;
    double short_sum2 = 0;
    double long_sum = 0;
    double long_sum2 = 0;
    int i;
    for (i = 0; i < long_period; ++i) {
        long_sum += input[i];
        long_sum2 += input[i] * input[i];
        if (i >= long_period - short_period) {
            short_sum += input[i];
            short_sum2 += input[i] * input[i];
        }
    }
    double val = input[long_period-2];
    *output++ = val;
    if (long_period - 1 < size) {
        double short_stddev = sqrt(short_sum2 * short_div - (short_sum * short_div) * (short_sum * short_div));
        double long_stddev = sqrt(long_sum2 * long_div - (long_sum * long_div) * (long_sum * long_div));
        double k = short_stddev / long_stddev;
        if (k != k) k = 0;
        k *= alpha;
        val = (input[long_period-1]-val) * k + val;
        *output++ = val;
    }
    for (i = long_period; i < size; ++i) {
        long_sum += input[i];
        long_sum2 += input[i] * input[i];
        short_sum += input[i];
        short_sum2 += input[i] * input[i];
        long_sum -= input[i-long_period];
        long_sum2 -= input[i-long_period] * input[i-long_period];
        short_sum -= input[i-short_period];
        short_sum2 -= input[i-short_period] * input[i-short_period];
        {
            double short_stddev = sqrt(short_sum2 * short_div - (short_sum * short_div) * (short_sum * short_div));
            double long_stddev = sqrt(long_sum2 * long_div - (long_sum * long_div) * (long_sum * long_div));
            double k = short_stddev / long_stddev;
            if (k != k) k = 0;
            k *= alpha;
            val = (input[i]-val) * k + val;
            *output++ = val;
        }
    }
    assert(output - outputs[0] == size - ti_vidya_start(options));
    return 0;
}
int ti_volatility_start(double const *options) {
    return (int)options[0];
}
int ti_volatility(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    double *output = outputs[0];
    const int period = (int)options[0];
    const double scale = 1.0 / period;
    const double annual = sqrt(252);
    if (period < 1) return 1;
    if (size <= ti_volatility_start(options)) return 0;
    double sum = 0;
    double sum2 = 0;
    int i;
    for (i = 1; i <= period; ++i) {
        const double c = (input[i]/input[i-1]-1.0);
        sum += c;
        sum2 += c * c;
    }
    *output++ = sqrt(sum2 * scale - (sum * scale) * (sum * scale)) * annual;
    for (i = period+1; i < size; ++i) {
        const double c = (input[i]/input[i-1]-1.0);
        sum += c;
        sum2 += c * c;
        const double cp = (input[i-period]/input[i-period-1]-1.0);
        sum -= cp;
        sum2 -= cp * cp;
        *output++ = sqrt(sum2 * scale - (sum * scale) * (sum * scale)) * annual;
    }
    assert(output - outputs[0] == size - ti_volatility_start(options));
    return 0;
}
int ti_vosc_start(double const *options) {
    return (int)options[1]-1;
}
int ti_vosc(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    double *output = outputs[0];
    const int short_period = (int)options[0];
    const int long_period = (int)options[1];
    const double short_div = 1.0 / short_period;
    const double long_div = 1.0 / long_period;
    if (short_period < 1) return 1;
    if (long_period < short_period) return 1;
    if (size <= ti_vosc_start(options)) return 0;
    double short_sum = 0;
    double long_sum = 0;
    int i;
    for (i = 0; i < long_period; ++i) {
        if (i >= (long_period - short_period)) {
            short_sum += input[i];
        }
        long_sum += input[i];
    }
    {
        const double savg = short_sum * short_div;
        const double lavg = long_sum * long_div;
        *output++ = 100.0 * (savg - lavg) / lavg;
    }
    for (i = long_period; i < size; ++i) {
        short_sum += input[i];
        short_sum -= input[i-short_period];
        long_sum += input[i];
        long_sum -= input[i-long_period];
        const double savg = short_sum * short_div;
        const double lavg = long_sum * long_div;
        *output++ = 100.0 * (savg - lavg) / lavg;
    }
    assert(output - outputs[0] == size - ti_vosc_start(options));
    return 0;
}
int ti_vwma_start(double const *options) {
    return (int)options[0]-1;
}
int ti_vwma(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const double *volume = inputs[1];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_vwma_start(options)) return 0;
    double sum = 0;
    double vsum = 0;
    int i;
    for (i = 0; i < period; ++i) {
        sum += input[i] * volume[i];
        vsum += volume[i];
    }
    *output++ = sum / vsum;
    for (i = period; i < size; ++i) {
        sum += input[i] * volume[i];
        sum -= input[i-period] * volume[i-period];
        vsum += volume[i];
        vsum -= volume[i-period];
        *output++ = sum / vsum;
    }
    assert(output - outputs[0] == size - ti_vwma_start(options));
    return 0;
}
int ti_wad_start(double const *options) {
    (void)options;
    return 1;
}
int ti_wad(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    (void)options;
    if (size <= ti_wad_start(options)) return 0;
    double *output = outputs[0];
    double sum = 0;
    double yc = close[0];
    int i;
    for (i = 1; i < size; ++i) {
        const double c = close[i];
        if (c > yc) {
            sum += c - ((yc)<(low[i])?(yc):(low[i]));
        } else if (c < yc) {
            sum += c - ((yc)>(high[i])?(yc):(high[i]));
        } else {
        }
        *output++ = sum;
        yc = close[i];
    }
    assert(output - outputs[0] == size - ti_wad_start(options));
    return 0;
}
int ti_wcprice_start(double const *options) {
    (void)options;
    return 0;
}
int ti_wcprice(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    (void)options;
    double *output = outputs[0];
    int i;
    for (i = 0; i < size; ++i) {
        output[i] = (high[i] + low[i] + close[i] + close[i]) * 0.25;
    }
    return 0;
}
int ti_wilders_start(double const *options) {
    return (int)options[0]-1;
}
int ti_wilders(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_wilders_start(options)) return 0;
    const double per = 1.0 / ((double)period);
    double sum = 0;
    int i;
    for (i = 0; i < period; ++i) {
        sum += input[i];
    }
    double val = sum / period;
    *output++ = val;
    for (i = period; i < size; ++i) {
        val = (input[i]-val) * per + val;
        *output++ = val;
    }
    assert(output - outputs[0] == size - ti_wilders_start(options));
    return 0;
}
int ti_willr_start(double const *options) {
    return (int)options[0]-1;
}
int ti_willr(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *high = inputs[0];
    const double *low = inputs[1];
    const double *close = inputs[2];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_willr_start(options)) return 0;
    int trail = 0, maxi = -1, mini = -1;
    double max = high[0];
    double min = low[0];
    double bar;
    int i, j;
    for (i = period-1; i < size; ++i, ++trail) {
        bar = high[i];
        if (maxi < trail) {
            maxi = trail;
            max = high[maxi];
            j = trail;
            while(++j <= i) {
                bar = high[j];
                if (bar >= max) {
                    max = bar;
                    maxi = j;
                }
            }
        } else if (bar >= max) {
            maxi = i;
            max = bar;
        }
        bar = low[i];
        if (mini < trail) {
            mini = trail;
            min = low[mini];
            j = trail;
            while(++j <= i) {
                bar = low[j];
                if (bar <= min) {
                    min = bar;
                    mini = j;
                }
            }
        } else if (bar <= min) {
            mini = i;
            min = bar;
        }
        const double highlow = (max - min);
        const double r = highlow == 0.0 ? 0.0 : -100 * ((max - close[i]) / highlow);
        *output++ = r;
    }
    assert(output - outputs[0] == size - ti_willr_start(options));
    return 0;
}
int ti_wma_start(double const *options) {
    return (int)options[0]-1;
}
int ti_wma(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_wma_start(options)) return 0;
    const double weights = period * (period+1) / 2;
    double sum = 0;
    double weight_sum = 0;
    int i;
    for (i = 0; i < period-1; ++i) {
        weight_sum += input[i] * (i+1);
        sum += input[i];
    }
    for (i = period-1; i < size; ++i) {
        weight_sum += input[i] * period;
        sum += input[i];
        *output++ = weight_sum / weights;
        weight_sum -= sum;
        sum -= input[i-period+1];
    }
    assert(output - outputs[0] == size - ti_wma_start(options));
    return 0;
}
int ti_zlema_start(double const *options) {
    return ((int)options[0] - 1) / 2 - 1;
}
int ti_zlema(int size, double const *const *inputs, double const *options, double *const *outputs) {
    const double *input = inputs[0];
    const int period = (int)options[0];
    const int lag = (period - 1) / 2;
    double *output = outputs[0];
    if (period < 1) return 1;
    if (size <= ti_zlema_start(options)) return 0;
    const double per = 2 / ((double)period + 1);
    double val = input[lag-1];
    *output++ = val;
    int i;
    for (i = lag; i < size; ++i) {
        double c = input[i];
        double l = input[i-lag];
        val = ((c + (c-l))-val) * per + val;
        *output++ = val;
    }
    assert(output - outputs[0] == size - ti_zlema_start(options));
    return 0;
}
ti_buffer *ti_buffer_new(int size) {
    const int s = (int)sizeof(ti_buffer) + (size-1) * (int)sizeof(double);
    ti_buffer *ret = (ti_buffer*)malloc((unsigned int)s);
    ret->size = size;
    ret->pushes = 0;
    ret->index = 0;
    ret->sum = 0;
    return ret;
}
void ti_buffer_free(ti_buffer *buffer) {
    free(buffer);
}
const char* ti_version(void) {return "0.9.2";}
long int ti_build(void) {return 1746800254;}
int ti_indicator_count(void) {return 104;}
struct ti_indicator_info ti_indicators[] = { {"abs", "Vector Absolute Value", ti_abs_start, ti_abs, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"abs",0}, 0, 0, 0}, {"acos", "Vector Arccosine", ti_acos_start, ti_acos, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"acos",0}, 0, 0, 0}, {"ad", "Accumulation/Distribution Line", ti_ad_start, ti_ad, 0, 2, 4, 0, 1, {"high","low","close","volume",0}, {"",0}, {"ad",0}, 0, 0, 0}, {"add", "Vector Addition", ti_add_start, ti_add, 0, 4, 2, 0, 1, {"real","real",0}, {"",0}, {"add",0}, 0, 0, 0}, {"adosc", "Accumulation/Distribution Oscillator", ti_adosc_start, ti_adosc, 0, 2, 4, 2, 1, {"high","low","close","volume",0}, {"short_period","long_period",0}, {"adosc",0}, 0, 0, 0}, {"adx", "Average Directional Movement Index", ti_adx_start, ti_adx, 0, 2, 2, 1, 1, {"high","low",0}, {"period",0}, {"adx",0}, 0, 0, 0}, {"adxr", "Average Directional Movement Rating", ti_adxr_start, ti_adxr, 0, 2, 2, 1, 1, {"high","low",0}, {"period",0}, {"adxr",0}, 0, 0, 0}, {"ao", "Awesome Oscillator", ti_ao_start, ti_ao, 0, 2, 2, 0, 1, {"high","low",0}, {"",0}, {"ao",0}, 0, 0, 0}, {"apo", "Absolute Price Oscillator", ti_apo_start, ti_apo, 0, 2, 1, 2, 1, {"real",0}, {"short_period","long_period",0}, {"apo",0}, 0, 0, 0}, {"aroon", "Aroon", ti_aroon_start, ti_aroon, 0, 2, 2, 1, 2, {"high","low",0}, {"period",0}, {"aroon_down","aroon_up",0}, 0, 0, 0}, {"aroonosc", "Aroon Oscillator", ti_aroonosc_start, ti_aroonosc, 0, 2, 2, 1, 1, {"high","low",0}, {"period",0}, {"aroonosc",0}, 0, 0, 0}, {"asin", "Vector Arcsine", ti_asin_start, ti_asin, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"asin",0}, 0, 0, 0}, {"atan", "Vector Arctangent", ti_atan_start, ti_atan, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"atan",0}, 0, 0, 0}, {"atr", "Average True Range", ti_atr_start, ti_atr, ti_atr_ref, 2, 3, 1, 1, {"high","low","close",0}, {"period",0}, {"atr",0}, ti_atr_stream_new, ti_atr_stream_run, ti_atr_stream_free}, {"avgprice", "Average Price", ti_avgprice_start, ti_avgprice, 0, 1, 4, 0, 1, {"open","high","low","close",0}, {"",0}, {"avgprice",0}, 0, 0, 0}, {"bbands", "Bollinger Bands", ti_bbands_start, ti_bbands, 0, 1, 1, 2, 3, {"real",0}, {"period","stddev",0}, {"bbands_lower","bbands_middle","bbands_upper",0}, 0, 0, 0}, {"bop", "Balance of Power", ti_bop_start, ti_bop, 0, 2, 4, 0, 1, {"open","high","low","close",0}, {"",0}, {"bop",0}, 0, 0, 0}, {"cci", "Commodity Channel Index", ti_cci_start, ti_cci, 0, 2, 3, 1, 1, {"high","low","close",0}, {"period",0}, {"cci",0}, 0, 0, 0}, {"ceil", "Vector Ceiling", ti_ceil_start, ti_ceil, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"ceil",0}, 0, 0, 0}, {"cmo", "Chande Momentum Oscillator", ti_cmo_start, ti_cmo, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"cmo",0}, 0, 0, 0}, {"cos", "Vector Cosine", ti_cos_start, ti_cos, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"cos",0}, 0, 0, 0}, {"cosh", "Vector Hyperbolic Cosine", ti_cosh_start, ti_cosh, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"cosh",0}, 0, 0, 0}, {"crossany", "Crossany", ti_crossany_start, ti_crossany, 0, 3, 2, 0, 1, {"real","real",0}, {"",0}, {"crossany",0}, 0, 0, 0}, {"crossover", "Crossover", ti_crossover_start, ti_crossover, 0, 3, 2, 0, 1, {"real","real",0}, {"",0}, {"crossover",0}, 0, 0, 0}, {"cvi", "Chaikins Volatility", ti_cvi_start, ti_cvi, 0, 2, 2, 1, 1, {"high","low",0}, {"period",0}, {"cvi",0}, 0, 0, 0}, {"decay", "Linear Decay", ti_decay_start, ti_decay, 0, 3, 1, 1, 1, {"real",0}, {"period",0}, {"decay",0}, 0, 0, 0}, {"dema", "Double Exponential Moving Average", ti_dema_start, ti_dema, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"dema",0}, 0, 0, 0}, {"di", "Directional Indicator", ti_di_start, ti_di, 0, 2, 3, 1, 2, {"high","low","close",0}, {"period",0}, {"plus_di","minus_di",0}, 0, 0, 0}, {"div", "Vector Division", ti_div_start, ti_div, 0, 4, 2, 0, 1, {"real","real",0}, {"",0}, {"div",0}, 0, 0, 0}, {"dm", "Directional Movement", ti_dm_start, ti_dm, 0, 2, 2, 1, 2, {"high","low",0}, {"period",0}, {"plus_dm","minus_dm",0}, 0, 0, 0}, {"dpo", "Detrended Price Oscillator", ti_dpo_start, ti_dpo, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"dpo",0}, 0, 0, 0}, {"dx", "Directional Movement Index", ti_dx_start, ti_dx, 0, 2, 2, 1, 1, {"high","low",0}, {"period",0}, {"dx",0}, 0, 0, 0}, {"edecay", "Exponential Decay", ti_edecay_start, ti_edecay, 0, 3, 1, 1, 1, {"real",0}, {"period",0}, {"edecay",0}, 0, 0, 0}, {"ema", "Exponential Moving Average", ti_ema_start, ti_ema, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"ema",0}, 0, 0, 0}, {"emv", "Ease of Movement", ti_emv_start, ti_emv, 0, 2, 3, 0, 1, {"high","low","volume",0}, {"",0}, {"emv",0}, 0, 0, 0}, {"exp", "Vector Exponential", ti_exp_start, ti_exp, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"exp",0}, 0, 0, 0}, {"fisher", "Fisher Transform", ti_fisher_start, ti_fisher, 0, 2, 2, 1, 2, {"high","low",0}, {"period",0}, {"fisher","fisher_signal",0}, 0, 0, 0}, {"floor", "Vector Floor", ti_floor_start, ti_floor, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"floor",0}, 0, 0, 0}, {"fosc", "Forecast Oscillator", ti_fosc_start, ti_fosc, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"fosc",0}, 0, 0, 0}, {"hma", "Hull Moving Average", ti_hma_start, ti_hma, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"hma",0}, 0, 0, 0}, {"kama", "Kaufman Adaptive Moving Average", ti_kama_start, ti_kama, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"kama",0}, 0, 0, 0}, {"kvo", "Klinger Volume Oscillator", ti_kvo_start, ti_kvo, 0, 2, 4, 2, 1, {"high","low","close","volume",0}, {"short_period","long_period",0}, {"kvo",0}, 0, 0, 0}, {"lag", "Lag", ti_lag_start, ti_lag, 0, 3, 1, 1, 1, {"real",0}, {"period",0}, {"lag",0}, 0, 0, 0}, {"linreg", "Linear Regression", ti_linreg_start, ti_linreg, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"linreg",0}, 0, 0, 0}, {"linregintercept", "Linear Regression Intercept", ti_linregintercept_start, ti_linregintercept, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"linregintercept",0}, 0, 0, 0}, {"linregslope", "Linear Regression Slope", ti_linregslope_start, ti_linregslope, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"linregslope",0}, 0, 0, 0}, {"ln", "Vector Natural Log", ti_ln_start, ti_ln, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"ln",0}, 0, 0, 0}, {"log10", "Vector Base-10 Log", ti_log10_start, ti_log10, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"log10",0}, 0, 0, 0}, {"macd", "Moving Average Convergence/Divergence", ti_macd_start, ti_macd, 0, 2, 1, 3, 3, {"real",0}, {"short_period","long_period","signal_period",0}, {"macd","macd_signal","macd_histogram",0}, 0, 0, 0}, {"marketfi", "Market Facilitation Index", ti_marketfi_start, ti_marketfi, 0, 2, 3, 0, 1, {"high","low","volume",0}, {"",0}, {"marketfi",0}, 0, 0, 0}, {"mass", "Mass Index", ti_mass_start, ti_mass, 0, 2, 2, 1, 1, {"high","low",0}, {"period",0}, {"mass",0}, 0, 0, 0}, {"max", "Maximum In Period", ti_max_start, ti_max, ti_max_ref, 3, 1, 1, 1, {"real",0}, {"period",0}, {"max",0}, 0, 0, 0}, {"md", "Mean Deviation Over Period", ti_md_start, ti_md, 0, 3, 1, 1, 1, {"real",0}, {"period",0}, {"md",0}, 0, 0, 0}, {"medprice", "Median Price", ti_medprice_start, ti_medprice, 0, 1, 2, 0, 1, {"high","low",0}, {"",0}, {"medprice",0}, 0, 0, 0}, {"mfi", "Money Flow Index", ti_mfi_start, ti_mfi, 0, 2, 4, 1, 1, {"high","low","close","volume",0}, {"period",0}, {"mfi",0}, 0, 0, 0}, {"min", "Minimum In Period", ti_min_start, ti_min, ti_min_ref, 3, 1, 1, 1, {"real",0}, {"period",0}, {"min",0}, 0, 0, 0}, {"mom", "Momentum", ti_mom_start, ti_mom, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"mom",0}, 0, 0, 0}, {"msw", "Mesa Sine Wave", ti_msw_start, ti_msw, 0, 2, 1, 1, 2, {"real",0}, {"period",0}, {"msw_sine","msw_lead",0}, 0, 0, 0}, {"mul", "Vector Multiplication", ti_mul_start, ti_mul, 0, 4, 2, 0, 1, {"real","real",0}, {"",0}, {"mul",0}, 0, 0, 0}, {"natr", "Normalized Average True Range", ti_natr_start, ti_natr, 0, 2, 3, 1, 1, {"high","low","close",0}, {"period",0}, {"natr",0}, 0, 0, 0}, {"nvi", "Negative Volume Index", ti_nvi_start, ti_nvi, 0, 2, 2, 0, 1, {"close","volume",0}, {"",0}, {"nvi",0}, 0, 0, 0}, {"obv", "On Balance Volume", ti_obv_start, ti_obv, 0, 2, 2, 0, 1, {"close","volume",0}, {"",0}, {"obv",0}, 0, 0, 0}, {"ppo", "Percentage Price Oscillator", ti_ppo_start, ti_ppo, 0, 2, 1, 2, 1, {"real",0}, {"short_period","long_period",0}, {"ppo",0}, 0, 0, 0}, {"psar", "Parabolic SAR", ti_psar_start, ti_psar, 0, 1, 2, 2, 1, {"high","low",0}, {"acceleration_factor_step","acceleration_factor_maximum",0}, {"psar",0}, 0, 0, 0}, {"pvi", "Positive Volume Index", ti_pvi_start, ti_pvi, 0, 2, 2, 0, 1, {"close","volume",0}, {"",0}, {"pvi",0}, 0, 0, 0}, {"qstick", "Qstick", ti_qstick_start, ti_qstick, 0, 2, 2, 1, 1, {"open","close",0}, {"period",0}, {"qstick",0}, 0, 0, 0}, {"roc", "Rate of Change", ti_roc_start, ti_roc, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"roc",0}, 0, 0, 0}, {"rocr", "Rate of Change Ratio", ti_rocr_start, ti_rocr, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"rocr",0}, 0, 0, 0}, {"round", "Vector Round", ti_round_start, ti_round, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"round",0}, 0, 0, 0}, {"rsi", "Relative Strength Index", ti_rsi_start, ti_rsi, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"rsi",0}, 0, 0, 0}, {"sin", "Vector Sine", ti_sin_start, ti_sin, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"sin",0}, 0, 0, 0}, {"sinh", "Vector Hyperbolic Sine", ti_sinh_start, ti_sinh, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"sinh",0}, 0, 0, 0}, {"sma", "Simple Moving Average", ti_sma_start, ti_sma, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"sma",0}, ti_sma_stream_new, ti_sma_stream_run, ti_sma_stream_free}, {"sqrt", "Vector Square Root", ti_sqrt_start, ti_sqrt, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"sqrt",0}, 0, 0, 0}, {"stddev", "Standard Deviation Over Period", ti_stddev_start, ti_stddev, 0, 3, 1, 1, 1, {"real",0}, {"period",0}, {"stddev",0}, 0, 0, 0}, {"stderr", "Standard Error Over Period", ti_stderr_start, ti_stderr, 0, 3, 1, 1, 1, {"real",0}, {"period",0}, {"stderr",0}, 0, 0, 0}, {"stoch", "Stochastic Oscillator", ti_stoch_start, ti_stoch, 0, 2, 3, 3, 2, {"high","low","close",0}, {"k_period","k_slowing_period","d_period",0}, {"stoch_k","stoch_d",0}, 0, 0, 0}, {"stochrsi", "Stochastic RSI", ti_stochrsi_start, ti_stochrsi, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"stochrsi",0}, 0, 0, 0}, {"sub", "Vector Subtraction", ti_sub_start, ti_sub, 0, 4, 2, 0, 1, {"real","real",0}, {"",0}, {"sub",0}, 0, 0, 0}, {"sum", "Sum Over Period", ti_sum_start, ti_sum, 0, 3, 1, 1, 1, {"real",0}, {"period",0}, {"sum",0}, 0, 0, 0}, {"tan", "Vector Tangent", ti_tan_start, ti_tan, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"tan",0}, 0, 0, 0}, {"tanh", "Vector Hyperbolic Tangent", ti_tanh_start, ti_tanh, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"tanh",0}, 0, 0, 0}, {"tema", "Triple Exponential Moving Average", ti_tema_start, ti_tema, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"tema",0}, 0, 0, 0}, {"todeg", "Vector Degree Conversion", ti_todeg_start, ti_todeg, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"degrees",0}, 0, 0, 0}, {"torad", "Vector Radian Conversion", ti_torad_start, ti_torad, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"radians",0}, 0, 0, 0}, {"tr", "True Range", ti_tr_start, ti_tr, 0, 2, 3, 0, 1, {"high","low","close",0}, {"",0}, {"tr",0}, 0, 0, 0}, {"trima", "Triangular Moving Average", ti_trima_start, ti_trima, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"trima",0}, 0, 0, 0}, {"trix", "Trix", ti_trix_start, ti_trix, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"trix",0}, 0, 0, 0}, {"trunc", "Vector Truncate", ti_trunc_start, ti_trunc, 0, 4, 1, 0, 1, {"real",0}, {"",0}, {"trunc",0}, 0, 0, 0}, {"tsf", "Time Series Forecast", ti_tsf_start, ti_tsf, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"tsf",0}, 0, 0, 0}, {"typprice", "Typical Price", ti_typprice_start, ti_typprice, 0, 1, 3, 0, 1, {"high","low","close",0}, {"",0}, {"typprice",0}, 0, 0, 0}, {"ultosc", "Ultimate Oscillator", ti_ultosc_start, ti_ultosc, 0, 2, 3, 3, 1, {"high","low","close",0}, {"short_period","medium_period","long_period",0}, {"ultosc",0}, 0, 0, 0}, {"var", "Variance Over Period", ti_var_start, ti_var, 0, 3, 1, 1, 1, {"real",0}, {"period",0}, {"var",0}, 0, 0, 0}, {"vhf", "Vertical Horizontal Filter", ti_vhf_start, ti_vhf, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"vhf",0}, 0, 0, 0}, {"vidya", "Variable Index Dynamic Average", ti_vidya_start, ti_vidya, 0, 1, 1, 3, 1, {"real",0}, {"short_period","long_period","alpha",0}, {"vidya",0}, 0, 0, 0}, {"volatility", "Annualized Historical Volatility", ti_volatility_start, ti_volatility, 0, 2, 1, 1, 1, {"real",0}, {"period",0}, {"volatility",0}, 0, 0, 0}, {"vosc", "Volume Oscillator", ti_vosc_start, ti_vosc, 0, 2, 1, 2, 1, {"volume",0}, {"short_period","long_period",0}, {"vosc",0}, 0, 0, 0}, {"vwma", "Volume Weighted Moving Average", ti_vwma_start, ti_vwma, 0, 1, 2, 1, 1, {"close","volume",0}, {"period",0}, {"vwma",0}, 0, 0, 0}, {"wad", "Williams Accumulation/Distribution", ti_wad_start, ti_wad, 0, 2, 3, 0, 1, {"high","low","close",0}, {"",0}, {"wad",0}, 0, 0, 0}, {"wcprice", "Weighted Close Price", ti_wcprice_start, ti_wcprice, 0, 1, 3, 0, 1, {"high","low","close",0}, {"",0}, {"wcprice",0}, 0, 0, 0}, {"wilders", "Wilders Smoothing", ti_wilders_start, ti_wilders, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"wilders",0}, 0, 0, 0}, {"willr", "Williams %R", ti_willr_start, ti_willr, 0, 2, 3, 1, 1, {"high","low","close",0}, {"period",0}, {"willr",0}, 0, 0, 0}, {"wma", "Weighted Moving Average", ti_wma_start, ti_wma, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"wma",0}, 0, 0, 0}, {"zlema", "Zero-Lag Exponential Moving Average", ti_zlema_start, ti_zlema, 0, 1, 1, 1, 1, {"real",0}, {"period",0}, {"zlema",0}, 0, 0, 0}, {0,0,0,0,0,0,0,0,0,{0,0},{0,0},{0,0},0,0,0}};
struct ti_stream {
    int index;
    int progress;
};
int ti_stream_run(ti_stream *stream, int size, double const *const *inputs, double *const *outputs) {
    return ti_indicators[stream->index].stream_run(stream, size, inputs, outputs);
}
ti_indicator_info *ti_stream_get_info(ti_stream *stream) {
    return ti_indicators + stream->index;
}
int ti_stream_get_progress(ti_stream *stream) {
    return stream->progress;
}
void ti_stream_free(ti_stream *stream) {
    ti_indicators[stream->index].stream_free(stream);
}
const ti_indicator_info *ti_find_indicator(const char *name) {
    int imin = 0;
    int imax = sizeof(ti_indicators) / sizeof(ti_indicator_info) - 2;
    while (imax >= imin) {
        const int i = (imin + ((imax-imin)/2));
        const int c = strcmp(name, ti_indicators[i].name);
        if (c == 0) {
            return ti_indicators + i;
        } else if (c > 0) {
            imin = i + 1;
        } else {
            imax = i - 1;
        }
    }
    return 0;
}
const char* tc_version(void) {return "0.9.2";}
long int tc_build(void) {return 1746800254;}
int tc_candle_count(void) {return 26;}
struct tc_result {
    int progress;
    int space;
    int count;
    int pattern_count;
    tc_hit *hits;
};
tc_config const *tc_config_default() {
    static tc_config default_config = {
        .period = 10,
        .body_none = 0.05,
        .body_short = 0.5,
        .body_long = 1.4,
        .wick_none = 0.05,
        .wick_long = 0.6,
        .near = 0.3
    };
    return &default_config;
}
tc_candle_info tc_candles[] = {
{"abandoned_baby_bear", "Abandoned Baby Bear", (1L<<0), tc_abandoned_baby_bear},
{"abandoned_baby_bull", "Abandoned Baby Bull", (1L<<1), tc_abandoned_baby_bull},
{"big_black_candle", "Big Black Candle", (1L<<2), tc_big_black_candle},
{"big_white_candle", "Big White Candle", (1L<<3), tc_big_white_candle},
{"black_marubozu", "Black Marubozu", (1L<<4), tc_black_marubozu},
{"doji", "Doji", (1L<<5), tc_doji},
{"dragonfly_doji", "Dragonfly Doji", (1L<<6), tc_dragonfly_doji},
{"engulfing_bear", "Engulfing Bear", (1L<<7), tc_engulfing_bear},
{"engulfing_bull", "Engulfing Bull", (1L<<8), tc_engulfing_bull},
{"evening_doji_star", "Evening Doji Star", (1L<<9), tc_evening_doji_star},
{"evening_star", "Evening Star", (1L<<10), tc_evening_star},
{"four_price_doji", "Four Price Doji", (1L<<11), tc_four_price_doji},
{"gravestone_doji", "Gravestone Doji", (1L<<12), tc_gravestone_doji},
{"hammer", "Hammer", (1L<<13), tc_hammer},
{"hanging_man", "Hanging Man", (1L<<14), tc_hanging_man},
{"inverted_hammer", "Inverted Hammer", (1L<<15), tc_inverted_hammer},
{"long_legged_doji", "Long Legged Doji", (1L<<16), tc_long_legged_doji},
{"marubozu", "Marubozu", (1L<<17), tc_marubozu},
{"morning_doji_star", "Morning Doji Star", (1L<<18), tc_morning_doji_star},
{"morning_star", "Morning Star", (1L<<19), tc_morning_star},
{"shooting_star", "Shooting Star", (1L<<20), tc_shooting_star},
{"spinning_top", "Spinning Top", (1L<<21), tc_spinning_top},
{"star", "Star", (1L<<22), tc_star},
{"three_black_crows", "Three Black Crows", (1L<<23), tc_three_black_crows},
{"three_white_soldiers", "Three White Soldiers", (1L<<24), tc_three_white_soldiers},
{"white_marubozu", "White Marubozu", (1L<<25), tc_white_marubozu},
{0,0,0,0}
};
const tc_candle_info *tc_find_candle(const char *name) {
    int imin = 0;
    int imax = sizeof(tc_candles) / sizeof(tc_candle_info) - 2;
    while (imax >= imin) {
        const int i = (imin + ((imax-imin)/2));
        const int c = strcmp(name, tc_candles[i].name);
        if (c == 0) {
            return tc_candles + i;
        } else if (c > 0) {
            imin = i + 1;
        } else {
            imax = i - 1;
        }
    }
    return 0;
}
const tc_candle_info *tc_get_info(tc_set pattern) {
    if (!pattern) return 0;
    tc_set k = pattern & ~(pattern-1);
    int imin = 0;
    int imax = sizeof(tc_candles) / sizeof(tc_candle_info) - 2;
    while (imax >= imin) {
        const int i = (imin + ((imax-imin)/2));
        if (k == tc_candles[i].pattern) {
            return tc_candles + i;
        } else if (k > tc_candles[i].pattern) {
            imin = i + 1;
        } else {
            imax = i - 1;
        }
    }
    return 0;
}
void tc_config_set_to_default(tc_config *config) {
    memcpy(config, tc_config_default(), sizeof(tc_config));
}
tc_result *tc_result_new() {
    tc_result *k = malloc(sizeof(tc_result));
    if (!k) return 0;
    memset(k, 0, sizeof(tc_result));
    return k;
}
static void tc_result_reset(tc_result *result) {
    result->progress = 0;
    result->count = 0;
    result->pattern_count = 0;
}
void tc_result_free(tc_result *result) {
    if (!result) return;
    free(result->hits);
    free(result);
}
int tc_result_count(const tc_result *result) {
    return result->count;
}
int tc_result_pattern_count(const tc_result *result) {
    return result->pattern_count;
}
tc_hit tc_result_get(const tc_result *result, int index) {
    if (index < result->count) {
        return result->hits[index];
    }
    tc_hit hit = {0};
    return hit;
}
tc_set tc_result_at(const tc_result *result, int index) {
    int imin = 0;
    int imax = result->count - 1;
    if (!imax) return 0;
    while (imax >= imin) {
        const int i = (imin + ((imax-imin)/2));
        assert(i >= 0);
        assert(i < result->count);
        if (index == result->hits[i].index) {
            return result->hits[i].patterns;
        } else if (index > result->hits[i].index) {
            imin = i + 1;
        } else {
            imax = i - 1;
        }
    }
    return 0;
}
static int tc_result_add(tc_result *result, tc_hit hit) {
    ++result->pattern_count;
    if (result->count > 0) {
        if (result->hits[result->count-1].index == hit.index) {
            do {result->hits[result->count-1].patterns |= hit.patterns;} while (0);
            return 0;
        }
    }
    if (result->space == 0) {
        result->space = 2048;
        result->count = 0;
        result->hits = malloc(sizeof(tc_hit) * (unsigned int)result->space);
    } else if (result->space == result->count) {
        result->space *= 2;
        tc_hit *hits = realloc(result->hits, sizeof(tc_hit) * (unsigned int)result->space);
        if (!hits) {
            return 2;
        }
        result->hits = hits;
    }
    result->hits[result->count] = hit;
    ++result->count;
    return 0;
}
int tc_run(tc_set patterns, int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
    tc_result_reset(output);
    {
        if ((patterns & (patterns-1)) == 0) {
if (patterns == (1L<<0)) return tc_abandoned_baby_bear(size, inputs, options, output);
if (patterns == (1L<<1)) return tc_abandoned_baby_bull(size, inputs, options, output);
if (patterns == (1L<<2)) return tc_big_black_candle(size, inputs, options, output);
if (patterns == (1L<<3)) return tc_big_white_candle(size, inputs, options, output);
if (patterns == (1L<<4)) return tc_black_marubozu(size, inputs, options, output);
if (patterns == (1L<<5)) return tc_doji(size, inputs, options, output);
if (patterns == (1L<<6)) return tc_dragonfly_doji(size, inputs, options, output);
if (patterns == (1L<<7)) return tc_engulfing_bear(size, inputs, options, output);
if (patterns == (1L<<8)) return tc_engulfing_bull(size, inputs, options, output);
if (patterns == (1L<<9)) return tc_evening_doji_star(size, inputs, options, output);
if (patterns == (1L<<10)) return tc_evening_star(size, inputs, options, output);
if (patterns == (1L<<11)) return tc_four_price_doji(size, inputs, options, output);
if (patterns == (1L<<12)) return tc_gravestone_doji(size, inputs, options, output);
if (patterns == (1L<<13)) return tc_hammer(size, inputs, options, output);
if (patterns == (1L<<14)) return tc_hanging_man(size, inputs, options, output);
if (patterns == (1L<<15)) return tc_inverted_hammer(size, inputs, options, output);
if (patterns == (1L<<16)) return tc_long_legged_doji(size, inputs, options, output);
if (patterns == (1L<<17)) return tc_marubozu(size, inputs, options, output);
if (patterns == (1L<<18)) return tc_morning_doji_star(size, inputs, options, output);
if (patterns == (1L<<19)) return tc_morning_star(size, inputs, options, output);
if (patterns == (1L<<20)) return tc_shooting_star(size, inputs, options, output);
if (patterns == (1L<<21)) return tc_spinning_top(size, inputs, options, output);
if (patterns == (1L<<22)) return tc_star(size, inputs, options, output);
if (patterns == (1L<<23)) return tc_three_black_crows(size, inputs, options, output);
if (patterns == (1L<<24)) return tc_three_white_soldiers(size, inputs, options, output);
if (patterns == (1L<<25)) return tc_white_marubozu(size, inputs, options, output);
        }
    }
    const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
    while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((1L<<0) & patterns) && i>=2 && (open[i-2]<close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && (low[i-1] >= high[(i-1)-1]) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_none * avg_total)) && (open[i]>close[i]) && (high[i] <= low[(i)-1]) && (close[i] <= close[i-2])) { do { const tc_hit hit = {i, (1L<<0)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<1) & patterns) && i>=2 && (open[i-2]>close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && (high[i-1] <= low[(i-1)-1]) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_none * avg_total)) && (open[i]<close[i]) && (low[i] >= high[(i)-1]) && (close[i] >= close[i-2])) { do { const tc_hit hit = {i, (1L<<1)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<2) & patterns) && (open[i]>close[i]) && ((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body))) { do { const tc_hit hit = {i, (1L<<2)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<3) & patterns) && (open[i]<close[i]) && ((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body))) { do { const tc_hit hit = {i, (1L<<3)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<4) & patterns) && ((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) < (options->wick_none * avg_total)) && (open[i]>close[i])) { do { const tc_hit hit = {i, (1L<<4)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<5) & patterns) && ((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total))) { do { const tc_hit hit = {i, (1L<<5)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<6) & patterns) && ((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) > (options->wick_long * avg_body))) { do { const tc_hit hit = {i, (1L<<6)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<7) & patterns) && i>=1 && (open[i]>close[i]) && (open[i-1]<close[i-1]) && close[i] < open[i-1] && open[i] > close[i-1]) { do { const tc_hit hit = {i, (1L<<7)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<8) & patterns) && i>=1 && (open[i]<close[i]) && (open[i-1]>close[i-1]) && close[i] > open[i-1] && open[i] < close[i-1]) { do { const tc_hit hit = {i, (1L<<8)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<9) & patterns) && i>=2 && (open[i-2]<close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && ((open[(i-1)] < close[(i-1)] ? open[(i-1)] : close[(i-1)]) >= (open[((i-1)-1)] > close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_none * avg_total)) && (open[i]>close[i]) && ((open[(i)] > close[(i)] ? open[(i)] : close[(i)]) <= (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)])) && (close[i] <= close[i-2])) { do { const tc_hit hit = {i, (1L<<9)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<10) & patterns) && i>=2 && (open[i-2]<close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && ((open[(i-1)] < close[(i-1)] ? open[(i-1)] : close[(i-1)]) >= (open[((i-1)-1)] > close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_short * avg_body)) && (open[i]>close[i]) && ((open[(i)] > close[(i)] ? open[(i)] : close[(i)]) <= (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)])) && (close[i] <= close[i-2])) { do { const tc_hit hit = {i, (1L<<10)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<11) & patterns) && ((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) < (options->wick_none * avg_total))) { do { const tc_hit hit = {i, (1L<<11)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<12) & patterns) && ((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total)) && ((high[(i)] - top) > (options->wick_long * avg_body)) && ((bottom - low[(i)]) < (options->wick_none * avg_total))) { do { const tc_hit hit = {i, (1L<<12)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<13) & patterns) && i>=1 && ((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) > (options->wick_long * avg_body)) && (open[(i)] < close[(i)] ? open[(i)] : close[(i)]) <= low[i-1] + (options->near * avg_total)) { do { const tc_hit hit = {i, (1L<<13)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<14) & patterns) && i>=1 && ((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) > (options->wick_long * avg_body)) && (open[(i)] < close[(i)] ? open[(i)] : close[(i)]) >= high[i-1] - (options->near * avg_total)) { do { const tc_hit hit = {i, (1L<<14)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<15) & patterns) && i>=1 && ((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) > (options->wick_long * avg_body)) && ((bottom - low[(i)]) < (options->wick_none * avg_total)) && ((open[(i)] > close[(i)] ? open[(i)] : close[(i)]) <= (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]))) { do { const tc_hit hit = {i, (1L<<15)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<16) & patterns) && ((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total)) && ((high[(i)] - top) > (options->wick_long * avg_body)) && ((bottom - low[(i)]) > (options->wick_long * avg_body))) { do { const tc_hit hit = {i, (1L<<16)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<17) & patterns) && ((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) < (options->wick_none * avg_total))) { do { const tc_hit hit = {i, (1L<<17)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<18) & patterns) && i>=2 && (open[i-2]>close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && ((open[(i-1)] > close[(i-1)] ? open[(i-1)] : close[(i-1)]) <= (open[((i-1)-1)] < close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_none * avg_total)) && (open[i]<close[i]) && ((open[(i)] < close[(i)] ? open[(i)] : close[(i)]) >= (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)])) && (close[i] >= close[i-2])) { do { const tc_hit hit = {i, (1L<<18)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<19) & patterns) && i>=2 && (open[i-2]>close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && ((open[(i-1)] > close[(i-1)] ? open[(i-1)] : close[(i-1)]) <= (open[((i-1)-1)] < close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_short * avg_body)) && (open[i]<close[i]) && ((open[(i)] < close[(i)] ? open[(i)] : close[(i)]) >= (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)])) && (close[i] >= close[i-2])) { do { const tc_hit hit = {i, (1L<<19)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<20) & patterns) && i>=1 && ((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) > (options->wick_long * avg_body)) && ((bottom - low[(i)]) < (options->wick_none * avg_total)) && ((open[(i)] < close[(i)] ? open[(i)] : close[(i)]) >= (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]))) { do { const tc_hit hit = {i, (1L<<20)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<21) & patterns) && ((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) > (fabs(open[(i)] - close[(i)]))) && ((bottom - low[(i)]) > (fabs(open[(i)] - close[(i)])))) { do { const tc_hit hit = {i, (1L<<21)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<22) & patterns) && i>=1 && ((low[i] >= high[(i)-1]) || (high[i] <= low[(i)-1]))) { do { const tc_hit hit = {i, (1L<<22)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<23) & patterns) && i>=2 && (open[i-2]>close[i-2]) && (open[i-1]>close[i-1]) && (open[i]>close[i]) && (open[i-1] < (open[((i-1)-1)] > close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)]) && open[i-1] > (open[((i-1)-1)] < close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && (open[i] < (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]) && open[i] > (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]))) { do { const tc_hit hit = {i, (1L<<23)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<24) & patterns) && i>=2 && (open[i-2]<close[i-2]) && (open[i-1]<close[i-1]) && (open[i]<close[i]) && (open[i-1] < (open[((i-1)-1)] > close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)]) && open[i-1] > (open[((i-1)-1)] < close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && (open[i] < (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]) && open[i] > (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]))) { do { const tc_hit hit = {i, (1L<<24)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } if (((1L<<25) & patterns) && ((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) < (options->wick_none * avg_total)) && (open[i]<close[i])) { do { const tc_hit hit = {i, (1L<<25)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
    return 0;
}
int tc_abandoned_baby_bear(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=2 && (open[i-2]<close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && (low[i-1] >= high[(i-1)-1]) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_none * avg_total)) && (open[i]>close[i]) && (high[i] <= low[(i)-1]) && (close[i] <= close[i-2])) { do { const tc_hit hit = {i, (1L<<0)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_abandoned_baby_bull(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=2 && (open[i-2]>close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && (high[i-1] <= low[(i-1)-1]) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_none * avg_total)) && (open[i]<close[i]) && (low[i] >= high[(i)-1]) && (close[i] >= close[i-2])) { do { const tc_hit hit = {i, (1L<<1)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_big_black_candle(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if ((open[i]>close[i]) && ((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body))) { do { const tc_hit hit = {i, (1L<<2)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_big_white_candle(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if ((open[i]<close[i]) && ((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body))) { do { const tc_hit hit = {i, (1L<<3)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_black_marubozu(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) < (options->wick_none * avg_total)) && (open[i]>close[i])) { do { const tc_hit hit = {i, (1L<<4)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total))) { do { const tc_hit hit = {i, (1L<<5)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_dragonfly_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) > (options->wick_long * avg_body))) { do { const tc_hit hit = {i, (1L<<6)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_engulfing_bear(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=1 && (open[i]>close[i]) && (open[i-1]<close[i-1]) && close[i] < open[i-1] && open[i] > close[i-1]) { do { const tc_hit hit = {i, (1L<<7)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_engulfing_bull(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=1 && (open[i]<close[i]) && (open[i-1]>close[i-1]) && close[i] > open[i-1] && open[i] < close[i-1]) { do { const tc_hit hit = {i, (1L<<8)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_evening_doji_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=2 && (open[i-2]<close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && ((open[(i-1)] < close[(i-1)] ? open[(i-1)] : close[(i-1)]) >= (open[((i-1)-1)] > close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_none * avg_total)) && (open[i]>close[i]) && ((open[(i)] > close[(i)] ? open[(i)] : close[(i)]) <= (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)])) && (close[i] <= close[i-2])) { do { const tc_hit hit = {i, (1L<<9)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_evening_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=2 && (open[i-2]<close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && ((open[(i-1)] < close[(i-1)] ? open[(i-1)] : close[(i-1)]) >= (open[((i-1)-1)] > close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_short * avg_body)) && (open[i]>close[i]) && ((open[(i)] > close[(i)] ? open[(i)] : close[(i)]) <= (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)])) && (close[i] <= close[i-2])) { do { const tc_hit hit = {i, (1L<<10)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_four_price_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) < (options->wick_none * avg_total))) { do { const tc_hit hit = {i, (1L<<11)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_gravestone_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total)) && ((high[(i)] - top) > (options->wick_long * avg_body)) && ((bottom - low[(i)]) < (options->wick_none * avg_total))) { do { const tc_hit hit = {i, (1L<<12)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_hammer(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=1 && ((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) > (options->wick_long * avg_body)) && (open[(i)] < close[(i)] ? open[(i)] : close[(i)]) <= low[i-1] + (options->near * avg_total)) { do { const tc_hit hit = {i, (1L<<13)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_hanging_man(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=1 && ((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) > (options->wick_long * avg_body)) && (open[(i)] < close[(i)] ? open[(i)] : close[(i)]) >= high[i-1] - (options->near * avg_total)) { do { const tc_hit hit = {i, (1L<<14)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_inverted_hammer(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=1 && ((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) > (options->wick_long * avg_body)) && ((bottom - low[(i)]) < (options->wick_none * avg_total)) && ((open[(i)] > close[(i)] ? open[(i)] : close[(i)]) <= (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]))) { do { const tc_hit hit = {i, (1L<<15)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_long_legged_doji(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((fabs(open[(i)] - close[(i)])) < (options->body_none * avg_total)) && ((high[(i)] - top) > (options->wick_long * avg_body)) && ((bottom - low[(i)]) > (options->wick_long * avg_body))) { do { const tc_hit hit = {i, (1L<<16)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_marubozu(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) < (options->wick_none * avg_total))) { do { const tc_hit hit = {i, (1L<<17)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_morning_doji_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=2 && (open[i-2]>close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && ((open[(i-1)] > close[(i-1)] ? open[(i-1)] : close[(i-1)]) <= (open[((i-1)-1)] < close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_none * avg_total)) && (open[i]<close[i]) && ((open[(i)] < close[(i)] ? open[(i)] : close[(i)]) >= (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)])) && (close[i] >= close[i-2])) { do { const tc_hit hit = {i, (1L<<18)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_morning_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=2 && (open[i-2]>close[i-2]) && ((fabs(open[(i-2)] - close[(i-2)])) > (options->body_long * avg_body)) && ((open[(i-1)] > close[(i-1)] ? open[(i-1)] : close[(i-1)]) <= (open[((i-1)-1)] < close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && ((fabs(open[(i-1)] - close[(i-1)])) < (options->body_short * avg_body)) && (open[i]<close[i]) && ((open[(i)] < close[(i)] ? open[(i)] : close[(i)]) >= (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)])) && (close[i] >= close[i-2])) { do { const tc_hit hit = {i, (1L<<19)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_shooting_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=1 && ((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) > (options->wick_long * avg_body)) && ((bottom - low[(i)]) < (options->wick_none * avg_total)) && ((open[(i)] < close[(i)] ? open[(i)] : close[(i)]) >= (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]))) { do { const tc_hit hit = {i, (1L<<20)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_spinning_top(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((fabs(open[(i)] - close[(i)])) < (options->body_short * avg_body)) && ((high[(i)] - top) > (fabs(open[(i)] - close[(i)]))) && ((bottom - low[(i)]) > (fabs(open[(i)] - close[(i)])))) { do { const tc_hit hit = {i, (1L<<21)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_star(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=1 && ((low[i] >= high[(i)-1]) || (high[i] <= low[(i)-1]))) { do { const tc_hit hit = {i, (1L<<22)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_three_black_crows(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=2 && (open[i-2]>close[i-2]) && (open[i-1]>close[i-1]) && (open[i]>close[i]) && (open[i-1] < (open[((i-1)-1)] > close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)]) && open[i-1] > (open[((i-1)-1)] < close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && (open[i] < (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]) && open[i] > (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]))) { do { const tc_hit hit = {i, (1L<<23)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_three_white_soldiers(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (i>=2 && (open[i-2]<close[i-2]) && (open[i-1]<close[i-1]) && (open[i]<close[i]) && (open[i-1] < (open[((i-1)-1)] > close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)]) && open[i-1] > (open[((i-1)-1)] < close[((i-1)-1)] ? open[((i-1)-1)] : close[((i-1)-1)])) && (open[i] < (open[((i)-1)] > close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]) && open[i] > (open[((i)-1)] < close[((i)-1)] ? open[((i)-1)] : close[((i)-1)]))) { do { const tc_hit hit = {i, (1L<<24)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
int tc_white_marubozu(int size, TC_REAL const *const *inputs, tc_config const *options, tc_result *output) {
        const TC_REAL *open = inputs[0]; const TC_REAL *high = inputs[1]; const TC_REAL *low = inputs[2]; const TC_REAL *close = inputs[3]; const int period = options->period; const TC_REAL div = 1.0 / period; TC_REAL avg_body_sum = 0; TC_REAL avg_total_sum = 0; if (period < 1) return 1; if (size < period) return 0; int i; for (i = 0; i < period; ++i) { avg_body_sum += (fabs(open[(i)] - close[(i)])); avg_total_sum += (high[(i)] - low[(i)]); }
        while(i < size) { const TC_REAL top = (open[(i)] > close[(i)] ? open[(i)] : close[(i)]); const TC_REAL bottom = (open[(i)] < close[(i)] ? open[(i)] : close[(i)]); const TC_REAL body = (fabs(open[(i)] - close[(i)])); const TC_REAL total = (high[(i)] - low[(i)]); const TC_REAL upper = (high[(i)] - top); const TC_REAL lower = (bottom - low[(i)]); const TC_REAL avg_body = avg_body_sum * div; const TC_REAL avg_total = avg_total_sum * div; (void)top;(void)bottom;(void)body;(void)total; (void)upper;(void)lower;(void)avg_body;(void)avg_total; if (((fabs(open[(i)] - close[(i)])) > (options->body_long * avg_body)) && ((high[(i)] - top) < (options->wick_none * avg_total)) && ((bottom - low[(i)]) < (options->wick_none * avg_total)) && (open[i]<close[i])) { do { const tc_hit hit = {i, (1L<<25)}; const int r = tc_result_add(output, hit); if (r != 0) return r; } while (0); } avg_body_sum += body; avg_body_sum -= (fabs(open[(i-period)] - close[(i-period)])); avg_total_sum += total; avg_total_sum -= (high[(i-period)] - low[(i-period)]); ++i; };
        return 0;
    }
