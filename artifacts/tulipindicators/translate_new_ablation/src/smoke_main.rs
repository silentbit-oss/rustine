use crate::globals::BESTOF;
use crate::globals::FAILS;
use crate::globals::TC_CANDLES;
use crate::globals::TI_INDICATORS;
use lazy_static::lazy_static;
use std::env;
use std::ffi::CStr;
use std::ffi::c_char;
use std::ffi::c_int;
use std::fs::File;
use std::io::Write;
use std::process;
use std::sync::atomic::Ordering;
use std::time::Instant;
use std::time::SystemTime;
use std::time::UNIX_EPOCH;
use translate_without_break_down::*;
fn main() {
    
    println!("Tulip Charts Indicator benchmark.");
    println!("Using real size of: {}.\n", std::mem::size_of::<f64>());
    generate_inputs();
    
    let args: Vec<String> = std::env::args().collect();
    let argc = args.len();
    
    let mut ind_info = TI_INDICATORS.lock().unwrap();
    let mut cnd_info = TC_CANDLES.lock().unwrap();
    
    let candles_only = (argc > 1) && (args[1] != "tc");
    
    if ((argc > 1) && (!args[1].chars().next().unwrap().is_ascii_digit())) && (!candles_only) {
        if argc > 2 {
            let bestof_val = args[2].parse::<i32>().unwrap_or(0);
            if bestof_val == 0 {
                BESTOF.store(1, Ordering::SeqCst);
            } else {
                BESTOF.store(bestof_val, Ordering::SeqCst);
            }
        }
        let found_ind = ti_find_indicator(Some(&args[1]));
        if let Some(info) = found_ind {
            bench_indicator(Option::None, Some(info));
        }
        let found_cnd = tc_find_candle(Some(&args[1]));
        if let Some(info) = found_cnd {
            bench_candle(Option::None, Some(&info));
        }
    } else {
        if (argc > 1) && args[1].chars().next().unwrap().is_ascii_digit() {
            let bestof_val = args[1].parse::<i32>().unwrap_or(1);
            BESTOF.store(bestof_val, Ordering::SeqCst);
        }
        let log = std::fs::File::create("docs/benchmark.php");
        if log.is_err() {
            println!("Couldn't open results file for output. Make sure ./docs/ exists.");
            std::process::exit(1);
        }
        let mut log = log.unwrap();
        writeln!(log, "<?php").unwrap();
        writeln!(log, "#GENERATED BY benchmark.c").unwrap();
        writeln!(log, "#DO NOT MODIFY DIRECTLY").unwrap();
        writeln!(log, "$benchmark = array(").unwrap();
        writeln!(log, "  \"worksize\" => {},", (1 * ((150 - 4) + 1)) * 4000).unwrap();
        writeln!(log, "  \"bestof\" => {}", BESTOF.load(Ordering::SeqCst)).unwrap();
        if !candles_only {
            for info in ind_info.iter() {
                if info.name.as_deref().unwrap_or("") == "msw" {
                    continue;
                }
                bench_indicator(Some(&mut log), Some(info));
            }
        }
        for info in cnd_info.iter() {
            bench_candle(Some(&mut log), Some(info));
        }
        let first_candle = &cnd_info[0];
        let cnd_all = TcCandleInfo {
            name: Some("all".to_string()),
            full_name: Some("All Candle Patterns".to_string()),
            pattern: (1 << 26) - 1,
            candle: first_candle.candle,
        };
        bench_candle(Some(&mut log), Some(&cnd_all));
        writeln!(log, ");").unwrap();
    }
    if FAILS.load(Ordering::SeqCst) == 0 {
        println!("All comparisons passed.");
    } else {
        println!("{} comparisons failed.", FAILS.load(Ordering::SeqCst));
    }
}
