use translate::*;
use std::env;
use std::fs::File;
use std::process::exit;
use std::io::Write;
pub fn main() {
    println!("Tulip Charts Indicator benchmark.");
    println!("Using real size of: {}.\n", std::mem::size_of::<f64>());
    
    generate_inputs();
    
    let args: Vec<String> = std::env::args().collect();
    let argc = args.len();
    let candles_only = (argc > 1) && (args[1] == "tc");
    
    if ((argc > 1) && (!args[1].chars().next().unwrap().is_ascii_digit())) && (!candles_only) {
        if argc > 2 {
            let bestof = args[2].parse::<i32>().unwrap_or(1);
            BESTOF.store(bestof, std::sync::atomic::Ordering::Relaxed);
        }
        
        if let Ok(mut indicators) = TI_INDICATORS.lock() {
            if let Some(ind_info) = indicators.iter_mut().find(|ind| {
                if let Some(name) = &ind.name {
                    name == &args[1]
                } else {
                    false
                }
            }) {
                bench_indicator(None, Some(ind_info));
            }
        }
        
        let cnd_info = tc_find_candle(Some(&args[1]));
        if let Some(info) = cnd_info {
            bench_candle(None, Some(info));
        }
    } else {
        if (argc > 1) && args[1].chars().next().unwrap().is_ascii_digit() {
            let bestof = args[1].parse::<i32>().unwrap_or(1);
            BESTOF.store(bestof, std::sync::atomic::Ordering::Relaxed);
        }
        
        let mut log = match File::create("docs/benchmark.php") {
            Ok(file) => file,
            Err(_) => {
                println!("Couldn't open results file for output. Make sure ./docs/ exists.");
                exit(1);
            }
        };
        
        writeln!(log, "<?php").unwrap();
        writeln!(log, "#GENERATED BY benchmark.c").unwrap();
        writeln!(log, "#DO NOT MODIFY DIRECTLY").unwrap();
        writeln!(log, "$benchmark = array(").unwrap();
        writeln!(log, "  \"worksize\" => {},", (1 * ((150 - 4) + 1)) * 4000).unwrap();
        writeln!(log, "  \"bestof\" => {}", BESTOF.load(std::sync::atomic::Ordering::Relaxed)).unwrap();
        
        if !candles_only {
            if let Ok(mut indicators) = TI_INDICATORS.lock() {
                for ind_info in indicators.iter_mut() {
                    if let Some(name) = &ind_info.name {
                        if name == "msw" {
                            continue;
                        }
                        bench_indicator(Some(&mut log), Some(ind_info));
                    }
                }
            }
        }
        
        if let Ok(candles) = TC_CANDLES.lock() {
            for cnd_info in candles.iter() {
                bench_candle(Some(&mut log), Some(cnd_info));
            }
        }
        
        let cnd_all = TcCandleInfo {
            name: Some("all".to_string()),
            full_name: Some("All Candle Patterns".to_string()),
            pattern: (1 << 26) - 1,
            candle: |_, _, _, _| 0,
        };
        bench_candle(Some(&mut log), Some(&cnd_all));
        
        writeln!(log, ");").unwrap();
    }
    
    let fails = FAILS.load(std::sync::atomic::Ordering::Relaxed);
    if fails == 0 {
        println!("All comparisons passed.");
    } else {
        println!("{} comparisons failed.", fails);
    }
}
