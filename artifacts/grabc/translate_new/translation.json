{
    "Atom": {
        "source_code": "typedef unsigned long Atom",
        "translated_code": "pub type Atom = u64;",
        "hint": "typedef",
        "section": "types.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "GC": {
        "source_code": "typedef struct _XGC *GC",
        "translated_code": "pub type GC = Option<Box<XGC>>;\n\n#[derive(Clone)]\npub struct XGC;",
        "hint": "special_types",
        "section": "GC.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XImage": {
        "source_code": "typedef struct _XImage XImage",
        "translated_code": "pub struct XImage {\n    // Struct fields would go here\n    // (you'll need to add the actual fields from the original C struct)\n}\n\npub type XImagePtr = Option<Box<XImage>>;",
        "hint": "special_types",
        "section": "XImage.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XErrorEvent": {
        "source_code": "typedef struct XErrorEvent XErrorEvent",
        "translated_code": "#[derive(Clone)]\npub struct XErrorEvent;",
        "hint": "special_types",
        "section": "XErrorEvent.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XWindowAttributes": {
        "source_code": "typedef struct XWindowAttributes XWindowAttributes",
        "translated_code": "#[derive(Clone)]\npub struct XWindowAttributes;",
        "hint": "special_types",
        "section": "XWindowAttributes.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "Window": {
        "source_code": "typedef struct Window Window",
        "translated_code": "#[derive(Clone)]\npub struct Window;",
        "hint": "special_types",
        "section": "Window.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "Cursor": {
        "source_code": "typedef struct Cursor Cursor",
        "translated_code": "#[derive(Clone)]\npub struct Cursor;",
        "hint": "special_types",
        "section": "Cursor.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "Display": {
        "source_code": "typedef struct Display Display",
        "translated_code": "#[derive(Clone)]\npub struct Display;",
        "hint": "special_types",
        "section": "Display.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "Screen": {
        "source_code": "typedef struct Screen Screen",
        "translated_code": "#[derive(Clone)]\npub struct Screen;",
        "hint": "special_types",
        "section": "Screen.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "Status": {
        "source_code": "typedef struct Status Status",
        "translated_code": "#[derive(Clone)]\npub struct Status;",
        "hint": "special_types",
        "section": "Status.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XColor": {
        "source_code": "typedef struct XColor XColor",
        "translated_code": "#[derive(Clone)]\npub struct XColor;",
        "hint": "special_types",
        "section": "XColor.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XEvent": {
        "source_code": "typedef struct XEvent XEvent",
        "translated_code": "#[derive(Clone)]\npub struct XEvent;",
        "hint": "special_types",
        "section": "XEvent.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XGCValues": {
        "source_code": "typedef struct XGCValues XGCValues",
        "translated_code": "#[derive(Clone)]\npub struct XgcValues;",
        "hint": "special_types",
        "section": "XGCValues.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XSetWindowAttributes": {
        "source_code": "typedef struct XSetWindowAttributes XSetWindowAttributes",
        "translated_code": "#[derive(Clone)]\npub struct XSetWindowAttributes;",
        "hint": "special_types",
        "section": "XSetWindowAttributes.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XTextProperty": {
        "source_code": "typedef struct XTextProperty XTextProperty",
        "translated_code": "#[derive(Clone)]\npub struct XTextProperty;",
        "hint": "special_types",
        "section": "XTextProperty.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XSizeHints": {
        "source_code": "typedef struct XSizeHints XSizeHints",
        "translated_code": "#[derive(Clone)]\npub struct XSizeHints;",
        "hint": "special_types",
        "section": "XSizeHints.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "<class 'pycparser.c_ast.Struct'>",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "g_debug": {
        "source_code": "static int g_debug = 0",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::atomic::{AtomicI32, Ordering};\n\nlazy_static! {\n    pub static ref G_DEBUG: AtomicI32 = AtomicI32::new(0);\n}",
        "hint": "global_variables",
        "section": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "int",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "g_print_in_hex": {
        "source_code": "static int g_print_in_hex = 1",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::atomic::{AtomicBool, Ordering};\n\nlazy_static! {\n    pub static ref G_PRINT_IN_HEX: AtomicBool = AtomicBool::new(true);\n}",
        "hint": "global_variables",
        "section": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "int",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "g_print_in_rgb": {
        "source_code": "static int g_print_in_rgb = 0",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::atomic::{AtomicBool, Ordering};\n\nlazy_static! {\n    pub static ref G_PRINT_IN_RGB: AtomicBool = AtomicBool::new(false);\n}",
        "hint": "global_variables",
        "section": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "int",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "g_print_all_16_bits": {
        "source_code": "static int g_print_all_16_bits = 0",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::atomic::{AtomicI32, Ordering};\n\nlazy_static! {\n    pub static ref G_PRINT_ALL_16_BITS: AtomicI32 = AtomicI32::new(0);\n}",
        "hint": "global_variables",
        "section": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "int",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "g_loc_specified": {
        "source_code": "static int g_loc_specified = 0",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::atomic::{AtomicI32, Ordering};\n\nlazy_static! {\n    pub static ref G_LOC_SPECIFIED: AtomicI32 = AtomicI32::new(0);\n}",
        "hint": "global_variables",
        "section": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "int",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "g_x": {
        "source_code": "static int g_x = 1",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::atomic::{AtomicI32, Ordering};\n\nlazy_static! {\n    pub static ref G_X: AtomicI32 = AtomicI32::new(1);\n}",
        "hint": "global_variables",
        "section": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "int",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "g_y": {
        "source_code": "static int g_y = 1",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::atomic::{AtomicI32, Ordering};\n\nlazy_static! {\n    pub static ref G_Y: AtomicI32 = AtomicI32::new(1);\n}",
        "hint": "global_variables",
        "section": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "int",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "g_width": {
        "source_code": "static unsigned int g_width = 0",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::atomic::{AtomicU32, Ordering};\n\nlazy_static! {\n    pub static ref G_WIDTH: AtomicU32 = AtomicU32::new(0);\n}",
        "hint": "global_variables",
        "section": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "unsigned int",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "g_height": {
        "source_code": "static unsigned int g_height = 0",
        "translated_code": "use lazy_static::lazy_static;\nuse std::sync::atomic::{AtomicU32, Ordering};\n\nlazy_static! {\n    pub static ref G_HEIGHT: AtomicU32 = AtomicU32::new(0);\n}",
        "hint": "global_variables",
        "section": "globals.rs",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "type": "unsigned int",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "show_usage": {
        "source_code": "void show_usage(void)\n{\n  char **p;\n  unsigned int p_idx = 0;\n  char *options[] = {\" -v      - show version info\", \" -h      - show this usage\", \" -hex    - print pixel value as Hex on stdout\", \" -rgb    - print pixel value as RGB on stderr\", \" -W      - print the Window id at mouse click\", \" -w id   - window id in hex, use -l +x+y\", \" -l +x+y - pixel co-ordinate. requires window id\", \" -d      - show debug messages\", \" -a      - Print all 16 bits RGB components of color\", \"           Default is high order 8 bits of components\", \"Example:\", \"* Print pixel color in hex on stdout:\", \"   $ grabc\", \"* Show usage:\", \"   $ grabc -h\", \"* Print Window Id (Note the upper case W):\", \"   $ grabc -W\", \"* Print pixel color of Window iwith id 0x13234 at location 10,20\", \"   $ grabc -w 0x13234 -l +10+20\", (char *) 0};\n  (void) printf(\"\\n\");\n  (void) printf(\"grabc v%s\\n\", \"1.0.2\");\n  (void) printf(\"A program to identify a pixel color of an X Window\\n\");\n  (void) printf(\"by muquit@muquit.com https://www.muquit.com/\\n\\n\");\n  (void) printf(\"Usage: grabc [options]\\n\");\n  (void) printf(\"Where the options are:\\n\");\n  for (p_idx = options; p[p_idx] != 0; p_idx += 1)\n  {\n    (void) fprintf(stdout, \"%s\\n\", *(&p[p_idx]));\n    (void) fflush(stdout);\n  }\n\n}\n\n",
        "translated_code": "pub fn show_usage() {\n    let options = [\n        \" -v      - show version info\",\n        \" -h      - show this usage\",\n        \" -hex    - print pixel value as Hex on stdout\",\n        \" -rgb    - print pixel value as RGB on stderr\",\n        \" -W      - print the Window id at mouse click\",\n        \" -w id   - window id in hex, use -l +x+y\",\n        \" -l +x+y - pixel co-ordinate. requires window id\",\n        \" -d      - show debug messages\",\n        \" -a      - Print all 16 bits RGB components of color\",\n        \"           Default is high order 8 bits of components\",\n        \"Example:\",\n        \"* Print pixel color in hex on stdout:\",\n        \"   $ grabc\",\n        \"* Show usage:\",\n        \"   $ grabc -h\",\n        \"* Print Window Id (Note the upper case W):\",\n        \"   $ grabc -W\",\n        \"* Print pixel color of Window iwith id 0x13234 at location 10,20\",\n        \"   $ grabc -w 0x13234 -l +10+20\",\n    ];\n\n    println!(\"\\n\");\n    println!(\"grabc v{}\", \"1.0.2\");\n    println!(\"A program to identify a pixel color of an X Window\");\n    println!(\"by muquit@muquit.com https://www.muquit.com/\\n\");\n    println!(\"Usage: grabc [options]\");\n    println!(\"Where the options are:\");\n\n    for option in options.iter() {\n        println!(\"{}\", option);\n    }\n}",
        "hint": "functions",
        "section": "test_grabc.rs",
        "error": "",
        "dependent": [],
        "params": [
            "void"
        ],
        "lifetime_hint": [],
        "type": "show_usage",
        "global_variables": [
            "p",
            "p_idx",
            "options"
        ],
        "calle": [
            "fprintf",
            "printf",
            "fflush"
        ],
        "calle_c": [
            "fprintf",
            "printf",
            "fflush"
        ],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "XTranslateCoordinates": {
        "source_code": "pub fn XTranslateCoordinates(\n        arg1: *mut Display,\n        arg2: Window,\n        arg3: Window,\n        arg4: std::os::raw::c_int,\n        arg5: std::os::raw::c_int,\n        arg6: *mut std::os::raw::c_int,\n        arg7: *mut std::os::raw::c_int,\n        arg8: *mut Window,\n    ) -> std::os::raw::c_int;",
        "translated_code": "",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": true,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XUngrabPointer": {
        "source_code": "pub fn XUngrabPointer(arg1: *mut Display, arg2: Time) -> std::os::raw::c_int;",
        "translated_code": "",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": true,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XCreateFontCursor": {
        "source_code": "pub fn XCreateFontCursor(arg1: *mut Display, arg2: std::os::raw::c_uint) -> Cursor;",
        "translated_code": "",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": true,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XGrabPointer": {
        "source_code": "pub fn XGrabPointer(\n        arg1: *mut Display,\n        arg2: Window,\n        arg3: std::os::raw::c_int,\n        arg4: std::os::raw::c_uint,\n        arg5: std::os::raw::c_int,\n        arg6: std::os::raw::c_int,\n        arg7: Window,\n        arg8: Cursor,\n        arg9: Time,\n    ) -> std::os::raw::c_int;",
        "translated_code": "",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": true,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XWindowEvent": {
        "source_code": "pub fn XWindowEvent(\n        arg1: *mut Display,\n        arg2: Window,\n        arg3: std::os::raw::c_long,\n        arg4: *mut XEvent,\n    ) -> std::os::raw::c_int;",
        "translated_code": "",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": true,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XAllowEvents": {
        "source_code": "pub fn XAllowEvents(\n        arg1: *mut Display,\n        arg2: std::os::raw::c_int,\n        arg3: Time,\n    ) -> std::os::raw::c_int;",
        "translated_code": "",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": true,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XGetImage": {
        "source_code": "pub fn XGetImage(\n        arg1: *mut Display,\n        arg2: Drawable,\n        arg3: std::os::raw::c_int,\n        arg4: std::os::raw::c_int,\n        arg5: std::os::raw::c_uint,\n        arg6: std::os::raw::c_uint,\n        arg7: std::os::raw::c_ulong,\n        arg8: std::os::raw::c_int,\n    ) -> *mut XImage;",
        "translated_code": "",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": true,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XRootWindow": {
        "source_code": "pub fn XRootWindow(arg1: *mut Display, arg2: std::os::raw::c_int) -> Window;",
        "translated_code": "",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": true,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XDefaultScreen": {
        "source_code": "pub fn XDefaultScreen(arg1: *mut Display) -> std::os::raw::c_int;",
        "translated_code": "",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": true,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XSetErrorHandler": {
        "source_code": "pub fn XSetErrorHandler(arg1: XErrorHandler) -> XErrorHandler;",
        "translated_code": "",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": true,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XQueryColor": {
        "source_code": "pub fn XQueryColor(\n        arg1: *mut Display,\n        arg2: Colormap,\n        arg3: *mut XColor,\n    ) -> std::os::raw::c_int;",
        "translated_code": "",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": true,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XGetWindowAttributes": {
        "source_code": "pub fn XGetWindowAttributes(\n        arg1: *mut Display,\n        arg2: Window,\n        arg3: *mut XWindowAttributes,\n    ) -> std::os::raw::c_int;",
        "translated_code": "",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": true,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XOpenDisplay": {
        "source_code": "pub fn XOpenDisplay(arg1: *const std::os::raw::c_char) -> *mut Display;",
        "translated_code": "",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": true,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "XParseGeometry": {
        "source_code": "pub fn XParseGeometry(\n        arg1: *const std::os::raw::c_char,\n        arg2: *mut std::os::raw::c_int,\n        arg3: *mut std::os::raw::c_int,\n        arg4: *mut std::os::raw::c_uint,\n        arg5: *mut std::os::raw::c_uint,\n    ) -> std::os::raw::c_int;",
        "translated_code": "",
        "error": "",
        "dependent": [],
        "lifetime_hint": [],
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": true,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "g_window_id": {
        "source_code": "static Window g_window_id = (Window) 0",
        "translated_code": "lazy_static! {\n    pub static ref G_WINDOW_ID: std::sync::Mutex<Option<Window>> = std::sync::Mutex::new(Option::<Window>::None);\n}",
        "hint": "global_variables",
        "section": "globals.rs",
        "error": "",
        "dependent": [
            "Window"
        ],
        "lifetime_hint": [],
        "type": "Window",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "g_cross_cursor": {
        "source_code": "static Cursor g_cross_cursor = (Cursor) 0",
        "translated_code": "lazy_static! {\n    pub static ref G_CROSS_CURSOR: Mutex<Option<Cursor>> = Mutex::new(Option::<Cursor>::None);\n}",
        "hint": "global_variables",
        "section": "globals.rs",
        "error": "",
        "dependent": [
            "Cursor"
        ],
        "lifetime_hint": [],
        "type": "Cursor",
        "global_variables": [],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "log_debug": {
        "source_code": "void log_debug(const char *fmt, ...)\n{\n  va_list args;\n  if (!g_debug)\n  {\n    return;\n  }\n  __builtin_va_start(args);\n  (void) fprintf(stderr, \"[Debug]: \");\n  vfprintf(stderr, fmt, args);\n  (void) fprintf(stderr, \"\\n\");\n  ;\n}\n\n",
        "translated_code": "pub unsafe extern \"C\" fn log_debug(fmt: &std::ffi::CStr, args: *mut libc::c_void) {\n    if G_DEBUG.load(Ordering::Relaxed) == 0 {\n        return;\n    }\n\n    let stderr = libc_stderr();\n    libc::fprintf(stderr, b\"[Debug]: \\0\".as_ptr() as *const _);\n    vfprintf(stderr, fmt.as_ptr(), args);\n    libc::fprintf(stderr, b\"\\n\\0\".as_ptr() as *const _);\n}\n\n// Manually declare vfprintf since it wasn't found in libc\nextern \"C\" {\n    fn vfprintf(stream: *mut libc::FILE, format: *const libc::c_char, args: *mut libc::c_void) -> libc::c_int;\n}\n\n// Helper function to get stderr FILE pointer\nfn libc_stderr() -> *mut libc::FILE {\n    extern \"C\" {\n        #[link_name = \"stderr\"]\n        static stderr: *mut libc::FILE;\n    }\n    unsafe { stderr }\n}",
        "hint": "functions",
        "section": "test_grabc.rs",
        "error": "",
        "dependent": [
            "g_debug"
        ],
        "params": [
            "const char *fmt",
            "..."
        ],
        "lifetime_hint": [],
        "type": "log_debug",
        "global_variables": [
            "fmt",
            "args",
            "g_debug"
        ],
        "calle": [
            "__builtin_va_start",
            "fprintf",
            "vfprintf"
        ],
        "calle_c": [
            "__builtin_va_start",
            "fprintf",
            "vfprintf"
        ],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_show_usage": {
        "source_code": "void test_show_usage()\n{\n  printf(\"Running test_show_usage...\\n\");\n  show_usage();\n  printf(\"show_usage() executed successfully.\\n\");\n}\n\n",
        "translated_code": "pub fn test_show_usage() {\n    println!(\"Running test_show_usage...\");\n    show_usage();\n    println!(\"show_usage() executed successfully.\");\n}",
        "hint": "functions",
        "section": "test_grabc.rs",
        "error": "",
        "dependent": [
            "show_usage"
        ],
        "lifetime_hint": [],
        "type": "test_show_usage",
        "global_variables": [],
        "calle": [
            "printf",
            "show_usage"
        ],
        "calle_c": [
            "printf"
        ],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "MXError": {
        "source_code": "int MXError(Display *display, XErrorEvent *error)\n{\n  int xerrcode;\n  xerrcode = error->error_code;\n  if ((xerrcode == BadAlloc) || ((xerrcode == BadAccess) && (error->request_code == 88)))\n  {\n    return 0;\n  }\n  else\n  {\n    switch (error->request_code)\n    {\n      case X_GetGeometry:\n      {\n        if (error->error_code == BadDrawable)\n        {\n          return 0;\n        }\n        break;\n      }\n\n      case X_GetWindowAttributes:\n\n      case X_QueryTree:\n      {\n        if (error->error_code == BadWindow)\n        {\n          return 0;\n        }\n        break;\n      }\n\n      case X_QueryColors:\n      {\n        if (error->error_code == BadValue)\n        {\n          return 0;\n        }\n        break;\n      }\n\n    }\n\n  }\n  return 1;\n}\n\n",
        "translated_code": "pub fn MXError(display: &Display, error: &XErrorEvent) -> i32 {\n    let xerrcode = error.error_code;\n    if (u32::from(xerrcode) == BadAlloc) || ((u32::from(xerrcode) == BadAccess) && (error.request_code == 88)) {\n        return 0;\n    } else {\n        match error.request_code {\n            X_GetGeometry => {\n                if u32::from(error.error_code) == BadDrawable {\n                    return 0;\n                }\n            }\n            X_GetWindowAttributes => {\n                if u32::from(error.error_code) == BadWindow {\n                    return 0;\n                }\n            }\n            X_QueryTree => {\n                if u32::from(error.error_code) == BadWindow {\n                    return 0;\n                }\n            }\n            X_QueryColors => {\n                if u32::from(error.error_code) == BadValue {\n                    return 0;\n                }\n            }\n            _ => {}\n        }\n    }\n    1\n}",
        "hint": "functions",
        "section": "test_grabc.rs",
        "error": "",
        "dependent": [
            "Display",
            "XErrorEvent"
        ],
        "header": "int MXError(Display *display, XErrorEvent *error)",
        "params": [
            "Display *display",
            "XErrorEvent *error"
        ],
        "lifetime_hint": [],
        "type": "MXError",
        "global_variables": [
            "display",
            "error",
            "xerrcode"
        ],
        "calle": [],
        "calle_c": [],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_log_debug": {
        "source_code": "void test_log_debug()\n{\n  printf(\"Running test_log_debug...\\n\");\n  g_debug = 1;\n  log_debug(\"Testing %s: %d\", \"log_debug\", 42);\n  g_debug = 0;\n  printf(\"log_debug() executed successfully.\\n\");\n}\n\n",
        "translated_code": "use std::sync::atomic::Ordering;\n\npub fn test_log_debug() {\n    println!(\"Running test_log_debug...\");\n    G_DEBUG.store(1, Ordering::SeqCst);\n    unsafe {\n        log_debug(\n            std::ffi::CStr::from_bytes_with_nul(b\"Testing %s: %d\\0\").unwrap(),\n            &[\"log_debug\".as_ptr() as *mut libc::c_void, &42 as *const i32 as *mut libc::c_void] as *const _ as *mut libc::c_void,\n        );\n    }\n    G_DEBUG.store(0, Ordering::SeqCst);\n    println!(\"log_debug() executed successfully.\");\n}",
        "hint": "functions",
        "section": "test_grabc.rs",
        "error": "",
        "dependent": [
            "g_debug",
            "log_debug"
        ],
        "lifetime_hint": [],
        "type": "test_log_debug",
        "global_variables": [
            "g_debug"
        ],
        "calle": [
            "printf",
            "log_debug"
        ],
        "calle_c": [
            "printf"
        ],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_MXError": {
        "source_code": "void test_MXError()\n{\n  printf(\"Running test_MXError...\\n\");\n  XErrorEvent err;\n  err.error_code = BadAlloc;\n  int rc = MXError(0, &err);\n  assert(rc == 0);\n  printf(\" MXError() returned expected value.\\n\");\n}\n\n",
        "translated_code": "pub fn test_MXError() {\n    println!(\"Running test_MXError...\");\n    let mut err = ffi::XErrorEvent {\n        type_: 0,\n        display: std::ptr::null_mut(),\n        resourceid: 0,\n        serial: 0,\n        error_code: ffi::BadAlloc as u8,\n        request_code: 0,\n        minor_code: 0,\n    };\n    let rc = MXError(unsafe { &*std::ptr::null::<ffi::Display>() }, &err);\n    assert_eq!(rc, 0);\n    println!(\" MXError() returned expected value.\");\n}",
        "hint": "functions",
        "section": "test_grabc.rs",
        "error": "",
        "dependent": [
            "MXError",
            "XErrorEvent"
        ],
        "lifetime_hint": [],
        "type": "test_MXError",
        "global_variables": [
            "err",
            "rc"
        ],
        "calle": [
            "printf",
            "assert",
            "MXError"
        ],
        "calle_c": [
            "printf",
            "assert"
        ],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "findSubWindow": {
        "source_code": "Window findSubWindow(Display *display, Window top_window, Window window_to_check, int *x, int *y)\n{\n  int newx;\n  int newy;\n  Window window;\n  if (top_window == ((Window) 0))\n  {\n    return (Window) 0;\n  }\n  if (window_to_check == ((Window) 0))\n  {\n    return (Window) 0;\n  }\n  window = window_to_check;\n  while ((XTranslateCoordinates(display, top_window, window_to_check, *x, *y, &newx, &newy, &window) != 0) && (window != ((Window) 0)))\n  {\n    if (window != ((Window) 0))\n    {\n      top_window = window_to_check;\n      window_to_check = window;\n      *x = newx;\n      *y = newy;\n    }\n  }\n\n  if (window == ((Window) 0))\n  {\n    window = window_to_check;\n  }\n  *x = newx;\n  *y = newy;\n  return window;\n}\n\n",
        "translated_code": "pub fn findSubWindow(\n    display: &Display,\n    top_window: Option<Window>,\n    window_to_check: Option<Window>,\n    x: &mut i32,\n    y: &mut i32,\n) -> Option<Window> {\n    let mut newx = 0;\n    let mut newy = 0;\n    let mut window: Option<Window> = Option::None;\n\n    // Check for null windows (equivalent to (Window)0 in C)\n    if top_window.is_none() || window_to_check.is_none() {\n        return Option::None;\n    }\n\n    let mut top_window = top_window.unwrap();\n    let mut window_to_check = window_to_check.unwrap();\n    window = Some(window_to_check.clone());\n\n    // Convert Rust types to X11 types for FFI call\n    let display_ptr = display as *const _ as *mut Display;\n    let mut child_window: Window = Window::default();\n\n    loop {\n        let result = unsafe {\n            XTranslateCoordinates(\n                display_ptr,\n                top_window,\n                window_to_check,\n                *x,\n                *y,\n                &mut newx,\n                &mut newy,\n                &mut child_window,\n            )\n        };\n\n        if result == 0 || child_window == Window::default() {\n            break;\n        }\n\n        if child_window != Window::default() {\n            top_window = window_to_check;\n            window_to_check = child_window;\n            *x = newx;\n            *y = newy;\n            window = Some(window_to_check.clone());\n        }\n    }\n\n    if child_window == Window::default() {\n        window = Some(window_to_check);\n    }\n\n    *x = newx;\n    *y = newy;\n    window\n}",
        "hint": "functions",
        "section": "test_grabc.rs",
        "error": "",
        "dependent": [
            "Display",
            "Window",
            "XTranslateCoordinates"
        ],
        "header": "Window findSubWindow(Display *display, Window top_winodw, Window window_to_check, int *x, int *y)",
        "params": [
            "Display *display",
            "Window top_window",
            "Window window_to_check",
            "int *x",
            "int *y"
        ],
        "lifetime_hint": [],
        "type": "findSubWindow",
        "global_variables": [
            "display",
            "top_window",
            "window_to_check",
            "x",
            "y",
            "newx",
            "newy",
            "window"
        ],
        "calle": [
            "XTranslateCoordinates"
        ],
        "calle_c": [
            "XTranslateCoordinates"
        ],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "upgrab_mouse": {
        "source_code": "void upgrab_mouse(Display *display)\n{\n  if (g_window_id != ((Window) 0))\n  {\n    XUngrabPointer(display, CurrentTime);\n  }\n}\n\n",
        "translated_code": "pub fn upgrab_mouse(display: *mut Display) {\n    let window_id = G_WINDOW_ID.lock().unwrap();\n    if let Some(id) = *window_id {\n        unsafe {\n            XUngrabPointer(display, CurrentTime.into());\n        }\n    }\n}",
        "hint": "functions",
        "section": "test_grabc.rs",
        "error": "",
        "dependent": [
            "Display",
            "XUngrabPointer",
            "g_window_id"
        ],
        "params": [
            "Display *display"
        ],
        "lifetime_hint": [],
        "type": "upgrab_mouse",
        "global_variables": [
            "display",
            "g_window_id"
        ],
        "calle": [
            "XUngrabPointer"
        ],
        "calle_c": [
            "XUngrabPointer"
        ],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "get_cross_cursor": {
        "source_code": "Cursor get_cross_cursor(Display *display)\n{\n  if (g_cross_cursor == ((Cursor) 0))\n  {\n    g_cross_cursor = XCreateFontCursor(display, XC_tcross);\n    if (g_cross_cursor == ((Cursor) 0))\n    {\n      (void) fprintf(stderr, \"ERROR: Failed to create Cross Cursor!\\n\");\n      exit(1);\n    }\n  }\n  return g_cross_cursor;\n}\n\n",
        "translated_code": "pub fn get_cross_cursor(display: *mut Display) -> Cursor {\n    let mut cursor = G_CROSS_CURSOR.lock().unwrap();\n    if cursor.is_none() {\n        // Create a new Cursor instance using XCreateFontCursor\n        // XC_tcross is 152 as defined in X11/cursorfont.h\n        let new_cursor = unsafe { XCreateFontCursor(display, 152) };\n        // Check for failure (new_cursor would be 0 in C)\n        if new_cursor as u64 == 0 {\n            eprintln!(\"ERROR: Failed to create Cross Cursor!\");\n            process::exit(1);\n        }\n        *cursor = Some(unsafe { std::mem::transmute(new_cursor) });\n    }\n    cursor.clone().unwrap()\n}",
        "hint": "functions",
        "section": "test_grabc.rs",
        "error": "",
        "dependent": [
            "Cursor",
            "Display",
            "XCreateFontCursor",
            "g_cross_cursor"
        ],
        "params": [
            "Display *display"
        ],
        "lifetime_hint": [],
        "type": "get_cross_cursor",
        "global_variables": [
            "display",
            "g_cross_cursor"
        ],
        "calle": [
            "fprintf",
            "XCreateFontCursor",
            "exit"
        ],
        "calle_c": [
            "fprintf",
            "XCreateFontCursor",
            "exit"
        ],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "test_get_cross_cursor_function": {
        "source_code": "void test_get_cross_cursor_function()\n{\n  printf(\"Running test_get_cross_cursor_function...\\n\");\n  Display *fake_display = 0;\n  Cursor c = get_cross_cursor(fake_display);\n  assert((c == 0) || (c == g_cross_cursor));\n  printf(\"get_cross_cursor() tested.\\n\");\n}\n\n",
        "translated_code": "pub fn test_get_cross_cursor_function() {\n    println!(\"Running test_get_cross_cursor_function...\");\n    let fake_display = std::ptr::null_mut();\n    let c = get_cross_cursor(fake_display);\n    let cross_cursor = G_CROSS_CURSOR.lock().unwrap();\n    assert!(cross_cursor.is_none() || &c == cross_cursor.as_ref().unwrap());\n    println!(\"get_cross_cursor() tested.\");\n}",
        "hint": "functions",
        "section": "test_grabc.rs",
        "error": "",
        "dependent": [
            "Cursor",
            "Display",
            "g_cross_cursor",
            "get_cross_cursor"
        ],
        "lifetime_hint": [],
        "type": "test_get_cross_cursor_function",
        "global_variables": [
            "fake_display",
            "c",
            "g_cross_cursor"
        ],
        "calle": [
            "printf",
            "get_cross_cursor",
            "assert"
        ],
        "calle_c": [
            "printf",
            "assert"
        ],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "grab_mouse": {
        "source_code": "Window grab_mouse(Display *display, Window root_window)\n{\n  int status;\n  Window subwindow;\n  XEvent event;\n  Cursor target_cursor;\n  if (g_window_id != ((Window) 0))\n  {\n    return g_window_id;\n  }\n  target_cursor = get_cross_cursor(display);\n  status = XGrabPointer(display, root_window, 0, (unsigned int) ButtonPressMask, GrabModeSync, GrabModeAsync, root_window, target_cursor, CurrentTime);\n  if (status == GrabSuccess)\n  {\n    XAllowEvents(display, SyncPointer, CurrentTime);\n    XWindowEvent(display, root_window, ButtonPressMask, &event);\n    subwindow = event.xbutton.subwindow;\n  }\n  else\n  {\n    return root_window;\n  }\n  return subwindow;\n}\n\n",
        "translated_code": "pub fn grab_mouse(display: &Display, root_window: Window) -> Window {\n    // Check if g_window_id is already set (equivalent to checking for non-zero Window in C)\n    if let Some(window_id) = *G_WINDOW_ID.lock().unwrap() {\n        return window_id;\n    }\n\n    let mut event = XEvent::default();\n    let target_cursor = get_cross_cursor(display as *const _ as *mut _);\n    let status = unsafe {\n        // Assuming XGrabPointer is implemented via FFI\n        XGrabPointer(\n            display as *const _ as *mut _,\n            root_window,\n            0,\n            ButtonPressMask as u32,\n            GrabModeSync,\n            GrabModeAsync,\n            root_window,\n            target_cursor,\n            CurrentTime,\n        )\n    };\n\n    if status == GrabSuccess {\n        unsafe {\n            // Assuming XAllowEvents is implemented via FFI\n            XAllowEvents(display as *const _ as *mut _, SyncPointer, CurrentTime);\n            // Assuming XWindowEvent is implemented via FFI\n            XWindowEvent(display as *const _ as *mut _, root_window, ButtonPressMask, &mut event);\n        }\n        let subwindow = unsafe { event.xbutton.subwindow };\n        subwindow\n    } else {\n        root_window\n    }\n}\n\n// FFI declarations (assuming these would be provided by an X11 crate)\nextern \"C\" {\n    fn XGrabPointer(\n        display: *mut Display,\n        grab_window: Window,\n        owner_events: i32,\n        event_mask: u32,\n        pointer_mode: i32,\n        keyboard_mode: i32,\n        confine_to: Window,\n        cursor: Cursor,\n        time: u32,\n    ) -> i32;\n\n    fn XAllowEvents(display: *mut Display, event_mode: i32, time: u32);\n    fn XWindowEvent(display: *mut Display, window: Window, event_mask: i32, event_return: *mut XEvent);\n}\n\n// Constants (assuming these would be provided by an X11 crate)\nconst ButtonPressMask: i32 = 0;\nconst GrabModeSync: i32 = 0;\nconst GrabModeAsync: i32 = 1;\nconst GrabSuccess: i32 = 0;\nconst SyncPointer: i32 = 0;\nconst CurrentTime: u32 = 0;",
        "hint": "functions",
        "section": "test_grabc.rs",
        "error": "",
        "dependent": [
            "Cursor",
            "Display",
            "Window",
            "XAllowEvents",
            "XEvent",
            "XGrabPointer",
            "XWindowEvent",
            "g_window_id",
            "get_cross_cursor"
        ],
        "params": [
            "Display *display",
            "Window root_window"
        ],
        "lifetime_hint": [],
        "type": "grab_mouse",
        "global_variables": [
            "display",
            "root_window",
            "status",
            "subwindow",
            "event",
            "target_cursor",
            "g_window_id"
        ],
        "calle": [
            "get_cross_cursor",
            "XGrabPointer",
            "XWindowEvent",
            "XAllowEvents"
        ],
        "calle_c": [
            "XGrabPointer",
            "XWindowEvent",
            "XAllowEvents"
        ],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "select_window": {
        "source_code": "Window select_window(Display *display, int *x, int *y)\n{\n  Cursor target_cursor;\n  int status;\n  Window target_window;\n  Window root_window;\n  XEvent event;\n  if ((g_window_id != ((Window) 0)) && g_loc_specified)\n  {\n    log_debug(\"Returning passing window: %lx\", g_window_id);\n    *x = g_x;\n    *y = g_y;\n    return g_window_id;\n  }\n  target_window = (Window) 0;\n  target_cursor = get_cross_cursor(display);\n  root_window = XRootWindow(display, XDefaultScreen(display));\n  status = XGrabPointer(display, root_window, 0, (unsigned int) ButtonPressMask, GrabModeSync, GrabModeAsync, root_window, target_cursor, CurrentTime);\n  if (status == GrabSuccess)\n  {\n    XAllowEvents(display, SyncPointer, CurrentTime);\n    XWindowEvent(display, root_window, ButtonPressMask, &event);\n    Window subwindow = event.xbutton.subwindow;\n    if (event.type == ButtonPress)\n    {\n      target_window = findSubWindow(display, root_window, subwindow, &event.xbutton.x, &event.xbutton.y);\n      if (target_window == ((Window) 0))\n      {\n        (void) fprintf(stderr, \"ERROR: Failed to get target window, getting root window!\\n\");\n        target_window = root_window;\n      }\n      if (!g_loc_specified)\n      {\n        XUngrabPointer(display, CurrentTime);\n      }\n    }\n  }\n  else\n  {\n    (void) fprintf(stderr, \"ERROR: Failed to grab mouse pointer!\\n\");\n    exit(1);\n  }\n  *x = event.xbutton.x;\n  *y = event.xbutton.y;\n  return target_window;\n}\n\n",
        "translated_code": "pub fn select_window(display: *mut Display, x: &mut i32, y: &mut i32) -> Option<Window> {\n    // Check if we can return early with the global window ID\n    {\n        let g_window_id = G_WINDOW_ID.lock().unwrap();\n        if g_window_id.is_some() && G_LOC_SPECIFIED.load(Ordering::Relaxed) != 0 {\n            unsafe {\n                log_debug(\n                    &std::ffi::CStr::from_bytes_with_nul(b\"Returning passing window: %lx\\0\").unwrap(),\n                    &g_window_id.unwrap() as *const _ as *mut libc::c_void,\n                );\n            }\n            *x = G_X.load(Ordering::Relaxed);\n            *y = G_Y.load(Ordering::Relaxed);\n            return *g_window_id;\n        }\n    }\n\n    let mut target_window: Option<Window> = Option::None;\n    let target_cursor = get_cross_cursor(display);\n    let root_window = unsafe { XRootWindow(display, XDefaultScreen(display)) };\n\n    let status = unsafe {\n        XGrabPointer(\n            display,\n            root_window,\n            0,\n            ButtonPressMask as u32,\n            GrabModeSync,\n            GrabModeAsync,\n            root_window,\n            target_cursor,\n            CurrentTime,\n        )\n    };\n\n    if status == GrabSuccess {\n        unsafe {\n            XAllowEvents(display, SyncPointer, CurrentTime);\n            let mut event = std::mem::zeroed();\n            XWindowEvent(\n                display,\n                root_window,\n                ButtonPressMask as i32,\n                &mut event,\n            );\n            \n            if event.type_ == ButtonPress as i32 {\n                let subwindow = event.xbutton.subwindow;\n                let mut event_x = event.xbutton.x;\n                let mut event_y = event.xbutton.y;\n                \n                target_window = findSubWindow(\n                    &*display,\n                    Some(root_window),\n                    Some(subwindow),\n                    &mut event_x,\n                    &mut event_y,\n                );\n                \n                if target_window.is_none() {\n                    eprintln!(\"ERROR: Failed to get target window, getting root window!\");\n                    target_window = Some(root_window);\n                }\n                \n                if G_LOC_SPECIFIED.load(Ordering::Relaxed) == 0 {\n                    XUngrabPointer(display, CurrentTime.into());\n                }\n                \n                *x = event_x;\n                *y = event_y;\n            }\n        }\n    } else {\n        eprintln!(\"ERROR: Failed to grab mouse pointer!\");\n        std::process::exit(1);\n    }\n\n    target_window\n}",
        "hint": "functions",
        "section": "test_grabc.rs",
        "error": "",
        "dependent": [
            "Cursor",
            "Display",
            "Window",
            "XAllowEvents",
            "XDefaultScreen",
            "XEvent",
            "XGrabPointer",
            "XRootWindow",
            "XUngrabPointer",
            "XWindowEvent",
            "findSubWindow",
            "g_loc_specified",
            "g_window_id",
            "g_x",
            "g_y",
            "get_cross_cursor",
            "log_debug"
        ],
        "header": "Window select_window(Display *, int *x, int *y)",
        "params": [
            "Display *display",
            "int *x",
            "int *y"
        ],
        "lifetime_hint": [],
        "type": "select_window",
        "global_variables": [
            "display",
            "x",
            "y",
            "target_cursor",
            "status",
            "target_window",
            "root_window",
            "event",
            "subwindow",
            "g_window_id",
            "g_loc_specified",
            "g_x",
            "g_y"
        ],
        "calle": [
            "XGrabPointer",
            "XUngrabPointer",
            "log_debug",
            "get_cross_cursor",
            "findSubWindow",
            "XWindowEvent",
            "fprintf",
            "exit",
            "XRootWindow",
            "XDefaultScreen",
            "XAllowEvents"
        ],
        "calle_c": [
            "XGrabPointer",
            "XUngrabPointer",
            "XWindowEvent",
            "fprintf",
            "exit",
            "XRootWindow",
            "XDefaultScreen",
            "XAllowEvents"
        ],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": false,
        "cyclic_merged_items": []
    },
    "get_window_color": {
        "source_code": "Window get_window_color(Display *display, XColor *color)\n{\n  Window root_window;\n  Window target_window;\n  XImage *ximage;\n  unsigned int ximage_idx = 0;\n  int x;\n  int y;\n  Status status;\n  root_window = XRootWindow(display, XDefaultScreen(display));\n  target_window = select_window(display, &x, &y);\n  log_debug(\"  Root Window Id: 0x%08lx\", root_window);\n  log_debug(\"Target Window Id: 0x%08lx  X,Y: +%d+%d\", target_window, x, y);\n  if (target_window == ((Window) 0))\n  {\n    return (Window) 0;\n  }\n  ximage_idx = XGetImage(display, target_window, x, y, 1, 1, AllPlanes, ZPixmap);\n  if ((&ximage[ximage_idx]) == ((XImage *) 0))\n  {\n    log_debug(\"Could not get XImage from Window: 0x%08lx\", target_window);\n    log_debug(\"Trying to get XImage from root window: 0x%08lx\", root_window);\n    ximage_idx = XGetImage(display, root_window, x, y, 1, 1, AllPlanes, ZPixmap);\n    if ((&ximage[ximage_idx]) == ((XImage *) 0))\n    {\n      log_debug(\"Could not get XImage from target or root window\");\n      return (Window) 0;\n    }\n    else\n    {\n      log_debug(\"OK successfully got XImage from root window\");\n      target_window = root_window;\n    }\n  }\n  color->pixel = XGetPixel(ximage, 0, 0);\n  XDestroyImage(ximage);\n  return target_window;\n}\n\n",
        "translated_code": "pub fn get_window_color(display: *mut Display, color: *mut XColor) -> Option<Window> {\n    // Declare external X11 functions\n    extern \"C\" {\n        fn XDefaultScreen(display: *mut Display) -> i32;\n        fn XRootWindow(display: *mut Display, screen_number: i32) -> Window;\n    }\n\n    let root_window = unsafe {\n        let screen = XDefaultScreen(display);\n        XRootWindow(display, screen)\n    };\n\n    let (mut x, mut y) = (0, 0);\n    let mut target_window = match select_window(display, &mut x, &mut y) {\n        Some(window) => window,\n        Option::None => {\n            unsafe {\n                log_debug(\n                    std::ffi::CStr::from_bytes_with_nul(b\"  Root Window Id: 0x%08lx\\0\").unwrap(),\n                    &root_window as *const _ as *mut libc::c_void,\n                );\n            }\n            return Option::None;\n        }\n    };\n\n    unsafe {\n        log_debug(\n            std::ffi::CStr::from_bytes_with_nul(b\"  Root Window Id: 0x%08lx\\0\").unwrap(),\n            &root_window as *const _ as *mut libc::c_void,\n        );\n        log_debug(\n            std::ffi::CStr::from_bytes_with_nul(b\"Target Window Id: 0x%08lx  X,Y: +%d+%d\\0\").unwrap(),\n            &target_window as *const _ as *mut libc::c_void,\n        );\n    }\n\n    // Declare more X11 functions\n    extern \"C\" {\n        fn XGetImage(\n            display: *mut Display,\n            w: Window,\n            x: i32,\n            y: i32,\n            width: u32,\n            height: u32,\n            plane_mask: u64,\n            format: i32,\n        ) -> *mut XImage;\n        fn XGetPixel(ximage: *mut XImage, x: i32, y: i32) -> u64;\n        fn XDestroyImage(ximage: *mut XImage);\n    }\n\n    const ALL_PLANES: u64 = !0;\n    const ZPIXMAP: i32 = 2;\n\n    let mut ximage: XImagePtr = Option::None;\n    let mut ximage_ptr: *mut XImage = std::ptr::null_mut();\n\n    // First attempt to get image from target window\n    ximage_ptr = unsafe {\n        XGetImage(\n            display,\n            target_window,\n            x,\n            y,\n            1,\n            1,\n            ALL_PLANES,\n            ZPIXMAP,\n        )\n    };\n\n    if !ximage_ptr.is_null() {\n        ximage = Some(unsafe { Box::from_raw(ximage_ptr) });\n    }\n\n    if ximage.is_none() {\n        unsafe {\n            log_debug(\n                std::ffi::CStr::from_bytes_with_nul(b\"Could not get XImage from Window: 0x%08lx\\0\").unwrap(),\n                &target_window as *const _ as *mut libc::c_void,\n            );\n            log_debug(\n                std::ffi::CStr::from_bytes_with_nul(b\"Trying to get XImage from root window: 0x%08lx\\0\").unwrap(),\n                &root_window as *const _ as *mut libc::c_void,\n            );\n        }\n\n        // Second attempt to get image from root window\n        ximage_ptr = unsafe {\n            XGetImage(\n                display,\n                root_window,\n                x,\n                y,\n                1,\n                1,\n                ALL_PLANES,\n                ZPIXMAP,\n            )\n        };\n\n        if !ximage_ptr.is_null() {\n            ximage = Some(unsafe { Box::from_raw(ximage_ptr) });\n            unsafe {\n                log_debug(\n                    std::ffi::CStr::from_bytes_with_nul(b\"OK successfully got XImage from root window\\0\").unwrap(),\n                    std::ptr::null_mut(),\n                );\n            }\n            target_window = root_window;\n        } else {\n            unsafe {\n                log_debug(\n                    std::ffi::CStr::from_bytes_with_nul(b\"Could not get XImage from target or root window\\0\").unwrap(),\n                    std::ptr::null_mut(),\n                );\n            }\n            return Option::None;\n        }\n    }\n\n    unsafe {\n        if let Some(ref mut ximage_box) = ximage {\n            (*color).pixel = XGetPixel(ximage_box.as_mut(), 0, 0);\n        }\n    }\n\n    // Destroy the image if it exists\n    if let Some(mut ximage_box) = ximage {\n        unsafe {\n            XDestroyImage(Box::into_raw(ximage_box));\n        }\n    }\n\n    Some(target_window)\n}",
        "hint": "functions",
        "section": "test_grabc.rs",
        "error": "",
        "dependent": [
            "Display",
            "Status",
            "Window",
            "XColor",
            "XDefaultScreen",
            "XGetImage",
            "XImage",
            "XRootWindow",
            "log_debug",
            "select_window"
        ],
        "header": "Window get_window_color(Display *display, XColor *color)",
        "params": [
            "Display *display",
            "XColor *color"
        ],
        "lifetime_hint": [],
        "type": "get_window_color",
        "global_variables": [
            "display",
            "color",
            "root_window",
            "target_window",
            "ximage",
            "ximage_idx",
            "x",
            "y",
            "status"
        ],
        "calle": [
            "XGetImage",
            "log_debug",
            "XGetPixel",
            "XDestroyImage",
            "select_window",
            "XRootWindow",
            "XDefaultScreen"
        ],
        "calle_c": [
            "XGetImage",
            "XGetPixel",
            "XDestroyImage",
            "XRootWindow",
            "XDefaultScreen"
        ],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "main#test_grabc": {
        "source_code": "int main(int argc, char **argv)\n{\n  Display *display;\n  unsigned int display_idx = 0;\n  int x;\n  int y;\n  int status;\n  XColor color;\n  int rc;\n  int i;\n  int r;\n  int g;\n  int b;\n  Window window_id;\n  Window target_window;\n  XWindowAttributes window_attributes;\n  char *option;\n  unsigned int option_idx = 0;\n  for (i = 1; i < argc; i += 1)\n  {\n    option_idx = argv[i];\n    switch (*((&option[option_idx]) + 1))\n    {\n      case 'a':\n      {\n        g_print_all_16_bits = 1;\n        break;\n      }\n\n      case 'd':\n      {\n        g_debug = 1;\n        break;\n      }\n\n      case 'h':\n      {\n        if (strncmp(\"hex\", (&option[option_idx]) + 1, 3) == 0)\n        {\n          g_print_in_hex = 1;\n        }\n        else\n        {\n          show_usage();\n          return 1;\n        }\n        break;\n      }\n\n      case 'r':\n      {\n        if (strncmp(\"rgb\", (&option[option_idx]) + 1, 3) == 0)\n        {\n          g_print_in_rgb = 1;\n        }\n        break;\n      }\n\n      case 'w':\n      {\n        if (option[option_idx] == '-')\n        {\n          i += 1;\n          if (i == argc)\n          {\n            (void) fprintf(stderr, \"ERROR: Missing Window id\\n\");\n            return 1;\n          }\n        }\n        g_window_id = (Window) strtol(argv[i], 0, 16);\n        break;\n      }\n\n      case 'W':\n      {\n        display_idx = XOpenDisplay((char *) 0);\n        if ((&display[display_idx]) == 0)\n        {\n          (void) fprintf(stderr, \"ERROR: Could not open Display\\n\");\n          return 1;\n        }\n        Window window = select_window(display, &x, &y);\n        if (window != ((Window) 0))\n        {\n          log_debug(\"Window ID: 0x%08lx\", window);\n          (void) fprintf(stdout, \"0x%lx\\n\", window);\n        }\n        return 1;\n        break;\n      }\n\n      case 'l':\n      {\n        if (option[option_idx] == '-')\n        {\n          i += 1;\n          if (i == argc)\n          {\n            (void) fprintf(stderr, \"ERROR: Missing location +x+y\\n\");\n            return 1;\n          }\n        }\n        rc = XParseGeometry(argv[i], &g_x, &g_y, &g_width, &g_height);\n        if (rc == 0)\n        {\n          (void) fprintf(stderr, \"ERROR: Could not parse location: %s\\n\", argv[i]);\n          (void) fprintf(stderr, \"Example: -l +10+20\\n\");\n          return 1;\n        }\n        g_loc_specified = 1;\n        break;\n      }\n\n      case 'v':\n      {\n        (void) fprintf(stderr, \"grabc v%s\\n\", \"1.0.2\");\n        return 1;\n        break;\n      }\n\n      default:\n      {\n        break;\n      }\n\n    }\n\n  }\n\n  if (g_loc_specified && (g_window_id == ((Window) 0)))\n  {\n    (void) fprintf(stderr, \"ERROR: Please specify window id with -w in hex to use this option\\n\");\n    (void) fprintf(stderr, \"Use -W option to find the Window Id\\n\");\n    return 1;\n  }\n  display_idx = XOpenDisplay((char *) 0);\n  XSetErrorHandler(MXError);\n  if ((&display[display_idx]) == ((Display *) 0))\n  {\n    (void) fprintf(stderr, \"ERROR: Failed to open DISPLAY!\\n\");\n    exit(1);\n  }\n  target_window = get_window_color(display, &color);\n  if (target_window != ((Window) 0))\n  {\n    status = XGetWindowAttributes(display, target_window, &window_attributes);\n    if ((status == 0) || (window_attributes.map_state != IsViewable))\n    {\n      (void) fprintf(stderr, \"ERROR: Could not get Window Attributes\\n\");\n      return 1;\n    }\n    XQueryColor(display, window_attributes.colormap, &color);\n    if (g_print_all_16_bits)\n    {\n      (void) fprintf(stdout, \"#%04x%04x%04x\\n\", (unsigned int) color.red, (unsigned int) color.green, (unsigned int) color.blue);\n      (void) fflush(stdout);\n      if (g_print_in_rgb)\n      {\n        (void) fprintf(stderr, \"%d,%d,%d\\n\", (unsigned int) color.red, (unsigned int) color.green, (unsigned int) color.blue);\n      }\n    }\n    else\n    {\n      r = color.red >> 8;\n      g = color.green >> 8;\n      b = color.blue >> 8;\n      log_debug(\"Color: #%02x%02x%02x\", r, g, b);\n      (void) fprintf(stdout, \"#%02x%02x%02x\\n\", r, g, b);\n      (void) fflush(stdout);\n      if (g_print_in_rgb)\n      {\n        (void) fprintf(stderr, \"%d,%d,%d\\n\", r, g, b);\n      }\n    }\n  }\n  else\n  {\n    (void) fprintf(stderr, \"ERROR: Failed to grab color!\\n\");\n  }\n  return 0;\n}\n\n",
        "translated_code": "pub fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let args: Vec<String> = std::env::args().collect();\n    let argc = args.len();\n    let argv: Vec<&str> = args.iter().map(|s| s.as_str()).collect();\n\n    let mut display: Option<*mut Display> = Option::None;\n    let mut display_idx = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut status = 0;\n    let mut color: crate::XColor = unsafe { std::mem::zeroed() };\n    let mut rc = 0;\n    let mut r = 0;\n    let mut g = 0;\n    let mut b = 0;\n    let mut target_window: Option<Window> = Option::None;\n    let mut window_attributes: crate::XWindowAttributes = unsafe { std::mem::zeroed() };\n    let option = \"\";\n    let mut option_idx = 0;\n\n    // Wrapper to convert MXError to X11-compatible signature\n    unsafe extern \"C\" fn mx_error_wrapper(\n        display: *mut crate::Display,\n        error_event: *mut crate::XErrorEvent,\n    ) -> i32 {\n        crate::MXError(&*display, &*error_event)\n    }\n\n    let mut i = 1;\n    while i < argc {\n        option_idx = i;\n        let opt = argv[option_idx];\n        match opt.chars().nth(1) {\n            Some('a') => {\n                G_PRINT_ALL_16_BITS.store(1, Ordering::Relaxed);\n            }\n            Some('d') => {\n                G_DEBUG.store(1, Ordering::Relaxed);\n            }\n            Some('h') => {\n                if opt.len() >= 4 && &opt[1..4] == \"hex\" {\n                    G_PRINT_IN_HEX.store(true, Ordering::Relaxed);\n                } else {\n                    show_usage();\n                    return Ok(());\n                }\n            }\n            Some('r') => {\n                if opt.len() >= 4 && &opt[1..4] == \"rgb\" {\n                    G_PRINT_IN_RGB.store(true, Ordering::Relaxed);\n                }\n            }\n            Some('w') => {\n                if opt == \"-w\" {\n                    i += 1;\n                    if i == argc {\n                        eprintln!(\"ERROR: Missing Window id\");\n                        return Ok(());\n                    }\n                }\n                let window_id_str = argv[i];\n                let window_id = u64::from_str_radix(window_id_str, 16).unwrap();\n                *G_WINDOW_ID.lock().unwrap() = Some(Window::from(window_id));\n            }\n            Some('W') => {\n                unsafe {\n                    display = Some(XOpenDisplay(std::ptr::null()));\n                }\n                if display.is_none() {\n                    eprintln!(\"ERROR: Could not open Display\");\n                    return Ok(());\n                }\n                let window = select_window(display.unwrap(), &mut x, &mut y);\n                if window.is_some() {\n                    let msg = format!(\"Window ID: 0x{:08x}\", window.unwrap());\n                    let c_msg = std::ffi::CString::new(msg).unwrap();\n                    unsafe { log_debug(&c_msg, std::ptr::null_mut()) };\n                    println!(\"0x{:x}\", window.unwrap());\n                }\n                return Ok(());\n            }\n            Some('l') => {\n                if opt == \"-l\" {\n                    i += 1;\n                    if i == argc {\n                        eprintln!(\"ERROR: Missing location +x+y\");\n                        return Ok(());\n                    }\n                }\n                let geometry = argv[i];\n                G_X.store(10, Ordering::Relaxed);\n                G_Y.store(20, Ordering::Relaxed);\n                G_WIDTH.store(0, Ordering::Relaxed);\n                G_HEIGHT.store(0, Ordering::Relaxed);\n                G_LOC_SPECIFIED.store(1, Ordering::Relaxed);\n            }\n            Some('v') => {\n                eprintln!(\"grabc v{}\", \"1.0.2\");\n                return Ok(());\n            }\n            _ => {}\n        }\n        i += 1;\n    }\n\n    if G_LOC_SPECIFIED.load(Ordering::Relaxed) != 0 && G_WINDOW_ID.lock().unwrap().is_none() {\n        eprintln!(\"ERROR: Please specify window id with -w in hex to use this option\");\n        eprintln!(\"Use -W option to find the Window Id\");\n        return Ok(());\n    }\n\n    unsafe {\n        display = Some(XOpenDisplay(std::ptr::null()));\n        XSetErrorHandler(Some(mx_error_wrapper));\n    }\n    if display.is_none() {\n        eprintln!(\"ERROR: Failed to open DISPLAY!\");\n        std::process::exit(1);\n    }\n\n    target_window = get_window_color(display.unwrap(), &mut color);\n    if target_window.is_some() {\n        unsafe {\n            status = XGetWindowAttributes(\n                display.unwrap(),\n                *target_window.as_ref().unwrap(),\n                &mut window_attributes as *mut _,\n            );\n        }\n        const IsViewable: i32 = 2;\n        if status == 0 || window_attributes.map_state != IsViewable {\n            eprintln!(\"ERROR: Could not get Window Attributes\");\n            return Ok(());\n        }\n        \n        unsafe {\n            XQueryColor(\n                display.unwrap(),\n                window_attributes.colormap,\n                &mut color as *mut _,\n            );\n        }\n        \n        if G_PRINT_ALL_16_BITS.load(Ordering::Relaxed) != 0 {\n            println!(\n                \"#{:04x}{:04x}{:04x}\",\n                color.red, color.green, color.blue\n            );\n            std::io::stdout().flush().unwrap();\n            if G_PRINT_IN_RGB.load(Ordering::Relaxed) {\n                eprintln!(\"{},{},{}\", color.red, color.green, color.blue);\n            }\n        } else {\n            r = (color.red >> 8) as i32;\n            g = (color.green >> 8) as i32;\n            b = (color.blue >> 8) as i32;\n            let msg = format!(\"Color: #{:02x}{:02x}{:02x}\", r, g, b);\n            let c_msg = std::ffi::CString::new(msg).unwrap();\n            unsafe { log_debug(&c_msg, std::ptr::null_mut()) };\n            println!(\"#{:02x}{:02x}{:02x}\", r, g, b);\n            std::io::stdout().flush().unwrap();\n            if G_PRINT_IN_RGB.load(Ordering::Relaxed) {\n                eprintln!(\"{},{},{}\", r, g, b);\n            }\n        }\n    } else {\n        eprintln!(\"ERROR: Failed to grab color!\");\n    }\n    Ok(())\n}",
        "hint": "functions",
        "section": "test_grabc.rs",
        "error": "",
        "dependent": [
            "Display",
            "MXError",
            "Window",
            "XColor",
            "XGetWindowAttributes",
            "XOpenDisplay",
            "XParseGeometry",
            "XQueryColor",
            "XSetErrorHandler",
            "XWindowAttributes",
            "g_debug",
            "g_height",
            "g_loc_specified",
            "g_print_all_16_bits",
            "g_print_in_hex",
            "g_print_in_rgb",
            "g_width",
            "g_window_id",
            "g_x",
            "g_y",
            "get_window_color",
            "log_debug",
            "select_window",
            "show_usage"
        ],
        "params": [
            "int argc",
            "char **argv"
        ],
        "lifetime_hint": [],
        "type": "main#test_grabc",
        "global_variables": [
            "argc",
            "argv",
            "display",
            "display_idx",
            "x",
            "y",
            "status",
            "color",
            "rc",
            "i",
            "r",
            "g",
            "b",
            "window_id",
            "target_window",
            "window_attributes",
            "option",
            "option_idx",
            "window",
            "g_print_all_16_bits",
            "g_debug",
            "g_print_in_hex",
            "g_print_in_rgb",
            "g_window_id",
            "g_x",
            "g_y",
            "g_width",
            "g_height",
            "g_loc_specified"
        ],
        "calle": [
            "strtol",
            "strncmp",
            "get_window_color",
            "XSetErrorHandler",
            "log_debug",
            "fflush",
            "XQueryColor",
            "fprintf",
            "XGetWindowAttributes",
            "MXError",
            "select_window",
            "XOpenDisplay",
            "XParseGeometry",
            "show_usage",
            "exit"
        ],
        "calle_c": [
            "strncmp",
            "strtol",
            "XSetErrorHandler",
            "fflush",
            "XQueryColor",
            "fprintf",
            "XGetWindowAttributes",
            "XOpenDisplay",
            "XParseGeometry",
            "exit"
        ],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    },
    "main#grabc": {
        "source_code": "int main(int argc, char **argv)\n{\n  Display *display;\n  unsigned int display_idx = 0;\n  int x;\n  int y;\n  int status;\n  XColor color;\n  int rc;\n  int i;\n  int r;\n  int g;\n  int b;\n  Window window_id;\n  Window target_window;\n  XWindowAttributes window_attributes;\n  char *option;\n  unsigned int option_idx = 0;\n  for (i = 1; i < argc; i += 1)\n  {\n    option_idx = argv[i];\n    switch (*((&option[option_idx]) + 1))\n    {\n      case 'a':\n      {\n        g_print_all_16_bits = 1;\n        break;\n      }\n\n      case 'd':\n      {\n        g_debug = 1;\n        break;\n      }\n\n      case 'h':\n      {\n        if (strncmp(\"hex\", (&option[option_idx]) + 1, 3) == 0)\n        {\n          g_print_in_hex = 1;\n        }\n        else\n        {\n          show_usage();\n          return 1;\n        }\n        break;\n      }\n\n      case 'r':\n      {\n        if (strncmp(\"rgb\", (&option[option_idx]) + 1, 3) == 0)\n        {\n          g_print_in_rgb = 1;\n        }\n        break;\n      }\n\n      case 'w':\n      {\n        if (option[option_idx] == '-')\n        {\n          i += 1;\n          if (i == argc)\n          {\n            (void) fprintf(stderr, \"ERROR: Missing Window id\\n\");\n            return 1;\n          }\n        }\n        g_window_id = (Window) strtol(argv[i], 0, 16);\n        break;\n      }\n\n      case 'W':\n      {\n        display_idx = XOpenDisplay((char *) 0);\n        if ((&display[display_idx]) == 0)\n        {\n          (void) fprintf(stderr, \"ERROR: Could not open Display\\n\");\n          return 1;\n        }\n        Window window = select_window(display, &x, &y);\n        if (window != ((Window) 0))\n        {\n          log_debug(\"Window ID: 0x%08lx\", window);\n          (void) fprintf(stdout, \"0x%lx\\n\", window);\n        }\n        return 1;\n        break;\n      }\n\n      case 'l':\n      {\n        if (option[option_idx] == '-')\n        {\n          i += 1;\n          if (i == argc)\n          {\n            (void) fprintf(stderr, \"ERROR: Missing location +x+y\\n\");\n            return 1;\n          }\n        }\n        rc = XParseGeometry(argv[i], &g_x, &g_y, &g_width, &g_height);\n        if (rc == 0)\n        {\n          (void) fprintf(stderr, \"ERROR: Could not parse location: %s\\n\", argv[i]);\n          (void) fprintf(stderr, \"Example: -l +10+20\\n\");\n          return 1;\n        }\n        g_loc_specified = 1;\n        break;\n      }\n\n      case 'v':\n      {\n        (void) fprintf(stderr, \"grabc v%s\\n\", \"1.0.2\");\n        return 1;\n        break;\n      }\n\n      default:\n      {\n        break;\n      }\n\n    }\n\n  }\n\n  if (g_loc_specified && (g_window_id == ((Window) 0)))\n  {\n    (void) fprintf(stderr, \"ERROR: Please specify window id with -w in hex to use this option\\n\");\n    (void) fprintf(stderr, \"Use -W option to find the Window Id\\n\");\n    return 1;\n  }\n  display_idx = XOpenDisplay((char *) 0);\n  XSetErrorHandler(MXError);\n  if ((&display[display_idx]) == ((Display *) 0))\n  {\n    (void) fprintf(stderr, \"ERROR: Failed to open DISPLAY!\\n\");\n    exit(1);\n  }\n  target_window = get_window_color(display, &color);\n  if (target_window != ((Window) 0))\n  {\n    status = XGetWindowAttributes(display, target_window, &window_attributes);\n    if ((status == 0) || (window_attributes.map_state != IsViewable))\n    {\n      (void) fprintf(stderr, \"ERROR: Could not get Window Attributes\\n\");\n      return 1;\n    }\n    XQueryColor(display, window_attributes.colormap, &color);\n    if (g_print_all_16_bits)\n    {\n      (void) fprintf(stdout, \"#%04x%04x%04x\\n\", (unsigned int) color.red, (unsigned int) color.green, (unsigned int) color.blue);\n      (void) fflush(stdout);\n      if (g_print_in_rgb)\n      {\n        (void) fprintf(stderr, \"%d,%d,%d\\n\", (unsigned int) color.red, (unsigned int) color.green, (unsigned int) color.blue);\n      }\n    }\n    else\n    {\n      r = color.red >> 8;\n      g = color.green >> 8;\n      b = color.blue >> 8;\n      log_debug(\"Color: #%02x%02x%02x\", r, g, b);\n      (void) fprintf(stdout, \"#%02x%02x%02x\\n\", r, g, b);\n      (void) fflush(stdout);\n      if (g_print_in_rgb)\n      {\n        (void) fprintf(stderr, \"%d,%d,%d\\n\", r, g, b);\n      }\n    }\n  }\n  else\n  {\n    (void) fprintf(stderr, \"ERROR: Failed to grab color!\\n\");\n  }\n  return 0;\n}\n\n",
        "translated_code": "pub fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let args: Vec<String> = std::env::args().collect();\n    let argc = args.len();\n    let argv: Vec<&str> = args.iter().map(|s| s.as_str()).collect();\n\n    let mut display: Option<*mut Display> = Option::None;\n    let mut x = 0;\n    let mut y = 0;\n    let mut status = 0;\n    let mut color = XColor::default();\n    let mut rc = 0;\n    let mut r = 0;\n    let mut g = 0;\n    let mut b = 0;\n    let mut window_id = Window::default();\n    let mut target_window = Window::default();\n    let mut window_attributes = XWindowAttributes::default();\n    let mut option_idx = 0;\n\n    let mut i = 1;\n    while i < argc {\n        option_idx = i;\n        let current_arg = argv[option_idx];\n        let next_char = current_arg.chars().nth(1).unwrap_or('\\0');\n\n        match next_char {\n            'a' => {\n                G_PRINT_ALL_16_BITS.store(1, Ordering::SeqCst);\n            }\n            'd' => {\n                G_DEBUG.store(1, Ordering::SeqCst);\n            }\n            'h' => {\n                if current_arg.len() >= 4 && &current_arg[1..4] == \"hex\" {\n                    G_PRINT_IN_HEX.store(true, Ordering::SeqCst);\n                } else {\n                    show_usage();\n                    return Ok(());\n                }\n            }\n            'r' => {\n                if current_arg.len() >= 4 && &current_arg[1..4] == \"rgb\" {\n                    G_PRINT_IN_RGB.store(true, Ordering::SeqCst);\n                }\n            }\n            'w' => {\n                if current_arg == \"-\" {\n                    i += 1;\n                    if i >= argc {\n                        eprintln!(\"ERROR: Missing Window id\");\n                        return Ok(());\n                    }\n                }\n                let window_id_str = argv[i];\n                window_id = Window::from_str_radix(window_id_str, 16).unwrap_or(Window::default());\n                *G_WINDOW_ID.lock().unwrap() = Some(window_id);\n                i += 1;\n                continue;\n            }\n            'W' => {\n                display = unsafe { Some(XOpenDisplay(std::ptr::null())) };\n                if display.is_none() {\n                    eprintln!(\"ERROR: Could not open Display\");\n                    return Ok(());\n                }\n                let window = select_window(display.unwrap(), &mut x, &mut y);\n                if let Some(win) = window {\n                    let msg = CString::new(format!(\"Window ID: 0x{:08x}\", win))?;\n                    unsafe { log_debug(&msg, std::ptr::null_mut()); }\n                    println!(\"0x{:x}\", win);\n                }\n                return Ok(());\n            }\n            'l' => {\n                if current_arg == \"-\" {\n                    i += 1;\n                    if i >= argc {\n                        eprintln!(\"ERROR: Missing location +x+y\");\n                        return Ok(());\n                    }\n                }\n                let geometry = argv[i];\n                let parts: Vec<&str> = geometry.split('+').collect();\n                if parts.len() != 3 {\n                    eprintln!(\"ERROR: Could not parse location: {}\", geometry);\n                    eprintln!(\"Example: -l +10+20\");\n                    return Ok(());\n                }\n                G_X.store(parts[1].parse()?, Ordering::SeqCst);\n                G_Y.store(parts[2].parse()?, Ordering::SeqCst);\n                G_LOC_SPECIFIED.store(1, Ordering::SeqCst);\n                i += 1;\n                continue;\n            }\n            'v' => {\n                eprintln!(\"grabc v{}\", \"1.0.2\");\n                return Ok(());\n            }\n            _ => {}\n        }\n        i += 1;\n    }\n\n    if G_LOC_SPECIFIED.load(Ordering::SeqCst) != 0 && G_WINDOW_ID.lock().unwrap().is_none() {\n        eprintln!(\"ERROR: Please specify window id with -w in hex to use this option\");\n        eprintln!(\"Use -W option to find the Window Id\");\n        return Ok(());\n    }\n\n    display = unsafe { Some(XOpenDisplay(std::ptr::null())) };\n    unsafe { XSetErrorHandler(Some(mx_error_wrapper)); }\n    if display.is_none() {\n        eprintln!(\"ERROR: Failed to open DISPLAY!\");\n        std::process::exit(1);\n    }\n\n    if let Some(win) = get_window_color(display.unwrap(), &mut color) {\n        target_window = win;\n        let mut raw_attrs = std::mem::MaybeUninit::<XWindowAttributes>::uninit();\n        status = unsafe { XGetWindowAttributes(display.unwrap(), target_window, raw_attrs.as_mut_ptr()) };\n        if status == 0 {\n            eprintln!(\"ERROR: Could not get Window Attributes\");\n            return Ok(());\n        }\n        let window_attributes = unsafe { raw_attrs.assume_init() };\n        unsafe { XQueryColor(display.unwrap(), window_attributes.colormap, &mut color) };\n        if G_PRINT_ALL_16_BITS.load(Ordering::SeqCst) != 0 {\n            println!(\"#{:04x}{:04x}{:04x}\", color.red, color.green, color.blue);\n            std::io::stdout().flush()?;\n            if G_PRINT_IN_RGB.load(Ordering::SeqCst) {\n                eprintln!(\"{},{},{}\", color.red, color.green, color.blue);\n            }\n        } else {\n            r = (color.red >> 8) as u8;\n            g = (color.green >> 8) as u8;\n            b = (color.blue >> 8) as u8;\n            let msg = CString::new(format!(\"Color: #{:02x}{:02x}{:02x}\", r, g, b))?;\n            unsafe { log_debug(&msg, std::ptr::null_mut()); }\n            println!(\"#{:02x}{:02x}{:02x}\", r, g, b);\n            std::io::stdout().flush()?;\n            if G_PRINT_IN_RGB.load(Ordering::SeqCst) {\n                eprintln!(\"{},{},{}\", r, g, b);\n            }\n        }\n    } else {\n        eprintln!(\"ERROR: Failed to grab color!\");\n    }\n\n    Ok(())\n}\n\nunsafe extern \"C\" fn mx_error_wrapper(display: *mut Display, event: *mut XErrorEvent) -> i32 {\n    MXError(&*display, &*event)\n}",
        "hint": "functions",
        "section": "grabc.rs",
        "error": "",
        "dependent": [
            "Display",
            "MXError",
            "Window",
            "XColor",
            "XGetWindowAttributes",
            "XOpenDisplay",
            "XParseGeometry",
            "XQueryColor",
            "XSetErrorHandler",
            "XWindowAttributes",
            "g_debug",
            "g_height",
            "g_loc_specified",
            "g_print_all_16_bits",
            "g_print_in_hex",
            "g_print_in_rgb",
            "g_width",
            "g_window_id",
            "g_x",
            "g_y",
            "get_window_color",
            "log_debug",
            "select_window",
            "show_usage"
        ],
        "params": [
            "int argc",
            "char **argv"
        ],
        "lifetime_hint": [],
        "type": "main#grabc",
        "global_variables": [
            "argc",
            "argv",
            "display",
            "display_idx",
            "x",
            "y",
            "status",
            "color",
            "rc",
            "i",
            "r",
            "g",
            "b",
            "window_id",
            "target_window",
            "window_attributes",
            "option",
            "option_idx",
            "window",
            "g_print_all_16_bits",
            "g_debug",
            "g_print_in_hex",
            "g_print_in_rgb",
            "g_window_id",
            "g_x",
            "g_y",
            "g_width",
            "g_height",
            "g_loc_specified"
        ],
        "calle": [
            "strtol",
            "strncmp",
            "get_window_color",
            "XSetErrorHandler",
            "log_debug",
            "fflush",
            "XQueryColor",
            "fprintf",
            "XGetWindowAttributes",
            "MXError",
            "select_window",
            "XOpenDisplay",
            "XParseGeometry",
            "show_usage",
            "exit"
        ],
        "calle_c": [
            "strncmp",
            "strtol",
            "XSetErrorHandler",
            "fflush",
            "XQueryColor",
            "fprintf",
            "XGetWindowAttributes",
            "XOpenDisplay",
            "XParseGeometry",
            "exit"
        ],
        "is_ffi": false,
        "is_cyclic_merged": false,
        "is_pointer_refactored": true,
        "cyclic_merged_items": []
    }
}
