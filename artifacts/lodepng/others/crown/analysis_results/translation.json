{"fn_data":{"src::lodepng::addChunk_iTXt":"unsafe extern \"C\" fn addChunk_iTXt(\n    mut out: *mut ucvector,\n    mut compress: libc::c_uint,\n    mut keyword: *const libc::c_char,\n    mut langtag: *const libc::c_char,\n    mut transkey: *const libc::c_char,\n    mut textstring: *const libc::c_char,\n    mut zlibsettings: *mut LodePNGCompressSettings,\n) -> libc::c_uint {\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut chunk = 0 as *mut libc::c_uchar;\n    let mut compressed = 0 as *mut libc::c_uchar;\n    let mut compressedsize = 0 as libc::c_int as size_t;\n    let mut textsize = lodepng_strlen(textstring);\n    let mut keysize = lodepng_strlen(keyword);\n    let mut langsize = lodepng_strlen(langtag);\n    let mut transsize = lodepng_strlen(transkey);\n    if keysize < 1 as libc::c_int as libc::c_ulong\n        || keysize > 79 as libc::c_int as libc::c_ulong\n    {\n        return 89 as libc::c_int as libc::c_uint;\n    }\n    if compress != 0 {\n        error= zlib_compress(\n            core::ptr::addr_of_mut!(compressed),\n            core::ptr::addr_of_mut!(compressedsize),\n            textstring as *const libc::c_uchar,\n            textsize,\n            zlibsettings,\n        );\n    }\n    if error == 0 {\n        let mut size = keysize\n            .wrapping_add(3 as libc::c_int as libc::c_ulong)\n            .wrapping_add(langsize)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            .wrapping_add(transsize)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            .wrapping_add((if compress != 0 { compressedsize } else { textsize }));\n        error= lodepng_chunk_init(\n            core::ptr::addr_of_mut!(chunk),\n            out,\n            size as libc::c_uint,\n            b\"iTXt\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if error == 0 {\n        let mut pos = 8 as libc::c_int as size_t;\n        lodepng_memcpy(\n            chunk.offset(pos as isize) as *mut libc::c_void,\n            keyword as *const libc::c_void,\n            keysize,\n        );\n        pos= (pos as libc::c_ulong).wrapping_add(keysize) as size_t as size_t;\n        let fresh185 = pos;\n        pos= pos.wrapping_add(1);\n        *chunk.offset(fresh185 as isize) = 0 as libc::c_int as libc::c_uchar;\n        let fresh186 = pos;\n        pos= pos.wrapping_add(1);\n        *chunk\n            .offset(\n                fresh186 as isize,\n            ) = (if compress != 0 { 1 as libc::c_int } else { 0 as libc::c_int })\n            as libc::c_uchar;\n        let fresh187 = pos;\n        pos= pos.wrapping_add(1);\n        *chunk.offset(fresh187 as isize) = 0 as libc::c_int as libc::c_uchar;\n        lodepng_memcpy(\n            chunk.offset(pos as isize) as *mut libc::c_void,\n            langtag as *const libc::c_void,\n            langsize,\n        );\n        pos= (pos as libc::c_ulong).wrapping_add(langsize) as size_t as size_t;\n        let fresh188 = pos;\n        pos= pos.wrapping_add(1);\n        *chunk.offset(fresh188 as isize) = 0 as libc::c_int as libc::c_uchar;\n        lodepng_memcpy(\n            chunk.offset(pos as isize) as *mut libc::c_void,\n            transkey as *const libc::c_void,\n            transsize,\n        );\n        pos= (pos as libc::c_ulong).wrapping_add(transsize) as size_t as size_t;\n        let fresh189 = pos;\n        pos= pos.wrapping_add(1);\n        *chunk.offset(fresh189 as isize) = 0 as libc::c_int as libc::c_uchar;\n        if compress != 0 {\n            lodepng_memcpy(\n                chunk.offset(pos as isize) as *mut libc::c_void,\n                compressed as *const libc::c_void,\n                compressedsize,\n            );\n        } else {\n            lodepng_memcpy(\n                chunk.offset(pos as isize) as *mut libc::c_void,\n                textstring as *const libc::c_void,\n                textsize,\n            );\n        }\n        lodepng_chunk_generate_crc(chunk);\n    }\n    lodepng_free(compressed as *mut libc::c_void);\n    return error;\n}","src::lodepng::lodepng_can_have_alpha":"pub unsafe extern \"C\" fn lodepng_can_have_alpha(\n    mut info: *const LodePNGColorMode,\n) -> libc::c_uint {\n    return ((*info).key_defined != 0 || lodepng_is_alpha_type(info) != 0\n        || lodepng_has_palette_alpha(info) != 0) as libc::c_int as libc::c_uint;\n}","src::lodepng::zlib_decompress":"unsafe extern \"C\" fn zlib_decompress(\n    mut out: *mut *mut libc::c_uchar,\n    mut outsize: *mut size_t,\n    mut expected_size: size_t,\n    mut in_0: *const libc::c_uchar,\n    mut insize: size_t,\n    mut settings: *const LodePNGDecompressSettings,\n) -> libc::c_uint {\n    let mut error: libc::c_uint = 0;\n    if (*settings).custom_zlib.is_some() {\n        error= (*settings).custom_zlib\n            .expect(\"non-null function pointer\")(out, outsize, in_0, insize, settings);\n        if error != 0 {\n            error= 110 as libc::c_int as libc::c_uint;\n            if (*settings).max_output_size != 0 && (*outsize) > (*settings).max_output_size\n            {\n                error= 109 as libc::c_int as libc::c_uint;\n            }\n        }\n    } else {\n        let mut v = ucvector_init((*out), (*outsize));\n        if expected_size != 0 {\n            ucvector_resize(Some(&mut v), (*outsize).wrapping_add(expected_size));\n            v.size= (*outsize);\n        }\n        error= lodepng_zlib_decompressv(core::ptr::addr_of_mut!(v), in_0, insize, settings);\n        *out= v.data;\n        *outsize= v.size;\n    }\n    return error;\n}","src::lodepng::lodepng_deflate":"pub unsafe extern \"C\" fn lodepng_deflate(\n    mut out: Option<&mut *mut libc::c_uchar>,\n    mut outsize: Option<&mut size_t>,\n    mut in_0: *const libc::c_uchar,\n    mut insize: size_t,\n    mut settings: *const LodePNGCompressSettings,\n) -> libc::c_uint {\n    let mut v = ucvector_init((*out.as_deref().unwrap()), (*outsize.as_deref().unwrap()));\n    let mut error = lodepng_deflatev(core::ptr::addr_of_mut!(v), in_0, insize, settings);\n    *out.as_deref_mut().unwrap()= v.data;\n    *outsize.as_deref_mut().unwrap()= v.size;\n    return error;\n}","src::lodepng::ilog2i":"unsafe extern \"C\" fn ilog2i(mut i: size_t) -> size_t {\n    let mut l: size_t = 0;\n    if i == 0 as libc::c_int as libc::c_ulong {\n        return 0 as libc::c_int as size_t;\n    }\n    l= ilog2(i);\n    return i\n        .wrapping_mul(l)\n        .wrapping_add(\n            i.wrapping_sub(((1 as libc::c_uint) << l) as libc::c_ulong)\n                << 1 as libc::c_uint,\n        );\n}","src::lodepng::lodepng_is_greyscale_type":"pub unsafe extern \"C\" fn lodepng_is_greyscale_type(\n    mut info: *const LodePNGColorMode,\n) -> libc::c_uint {\n    return ((*info).colortype as libc::c_uint == LCT_GREY as libc::c_int as libc::c_uint\n        || (*info).colortype as libc::c_uint\n            == LCT_GREY_ALPHA as libc::c_int as libc::c_uint) as libc::c_int\n        as libc::c_uint;\n}","src::lodepng::countZeros":"unsafe extern \"C\" fn countZeros(\n    mut data: *const libc::c_uchar,\n    mut size: size_t,\n    mut pos: size_t,\n) -> libc::c_uint {\n    let mut start = data.offset(pos as isize);\n    let mut end = start.offset(crate::src::lodepng::MAX_SUPPORTED_DEFLATE_LENGTH as isize);\n    if end > data.offset(size as isize) {\n        end= data.offset(size as isize);\n    }\n    data= start;\n    while data != end && (*data) as libc::c_int == 0 as libc::c_int {\n        data= data.offset(1);\n    }\n    return data.offset_from(start) as libc::c_long as libc::c_uint;\n}","src::lodepng::lodepng_color_mode_copy":"pub unsafe extern \"C\" fn lodepng_color_mode_copy(\n    mut dest: *mut LodePNGColorMode,\n    mut source: *const LodePNGColorMode,\n) -> libc::c_uint {\n    lodepng_color_mode_cleanup(dest.as_mut());\n    lodepng_memcpy(\n        dest as *mut libc::c_void,\n        source as *const libc::c_void,\n        ::std::mem::size_of::<LodePNGColorMode>() as libc::c_ulong,\n    );\n    if !(*source).palette.is_null() {\n        (*dest).palette= lodepng_malloc(1024 as libc::c_int as size_t) as *mut libc::c_uchar;\n        if (*dest).palette.is_null() && (*source).palettesize != 0 {\n            return 83 as libc::c_int as libc::c_uint;\n        }\n        lodepng_memcpy(\n            (*dest).palette as *mut libc::c_void,\n            (*source).palette as *const libc::c_void,\n            (*source).palettesize.wrapping_mul(4 as libc::c_int as libc::c_ulong),\n        );\n    }else { (); }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_clear_icc":"pub unsafe extern \"C\" fn lodepng_clear_icc(mut info: *mut LodePNGInfo) {\n    string_cleanup(core::ptr::addr_of_mut!((*info).iccp_name));\n    lodepng_free((*info).iccp_profile as *mut libc::c_void);\n    (*info).iccp_profile= 0 as *mut libc::c_uchar;\n    (*info).iccp_profile_size= 0 as libc::c_int as libc::c_uint;\n    (*info).iccp_defined= 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::addChunk_bKGD":"unsafe extern \"C\" fn addChunk_bKGD(\n    mut out: *mut ucvector,\n    mut info: *const LodePNGInfo,\n) -> libc::c_uint {\n    let mut chunk = 0 as *mut libc::c_uchar;\n    if (*info).color.colortype as libc::c_uint == LCT_GREY as libc::c_int as libc::c_uint\n        || (*info).color.colortype as libc::c_uint\n            == LCT_GREY_ALPHA as libc::c_int as libc::c_uint\n    {\n        let mut error = lodepng_chunk_init(\n            core::ptr::addr_of_mut!(chunk),\n            out,\n            2 as libc::c_int as libc::c_uint,\n            b\"bKGD\\0\" as *const u8 as *const libc::c_char,\n        );\n        if error != 0 {\n            return error;\n        }\n        *chunk\n            .offset(\n                8 as libc::c_int as isize,\n            ) = ((*info).background_r >> 8 as libc::c_int) as libc::c_uchar;\n        *chunk\n            .offset(\n                9 as libc::c_int as isize,\n            ) = ((*info).background_r & 255 as libc::c_int as libc::c_uint)\n            as libc::c_uchar;\n    } else if (*info).color.colortype as libc::c_uint\n        == LCT_RGB as libc::c_int as libc::c_uint\n        || (*info).color.colortype as libc::c_uint\n            == LCT_RGBA as libc::c_int as libc::c_uint\n    {\n        let mut error_0 = lodepng_chunk_init(\n            core::ptr::addr_of_mut!(chunk),\n            out,\n            6 as libc::c_int as libc::c_uint,\n            b\"bKGD\\0\" as *const u8 as *const libc::c_char,\n        );\n        if error_0 != 0 {\n            return error_0;\n        }\n        *chunk\n            .offset(\n                8 as libc::c_int as isize,\n            ) = ((*info).background_r >> 8 as libc::c_int) as libc::c_uchar;\n        *chunk\n            .offset(\n                9 as libc::c_int as isize,\n            ) = ((*info).background_r & 255 as libc::c_int as libc::c_uint)\n            as libc::c_uchar;\n        *chunk\n            .offset(\n                10 as libc::c_int as isize,\n            ) = ((*info).background_g >> 8 as libc::c_int) as libc::c_uchar;\n        *chunk\n            .offset(\n                11 as libc::c_int as isize,\n            ) = ((*info).background_g & 255 as libc::c_int as libc::c_uint)\n            as libc::c_uchar;\n        *chunk\n            .offset(\n                12 as libc::c_int as isize,\n            ) = ((*info).background_b >> 8 as libc::c_int) as libc::c_uchar;\n        *chunk\n            .offset(\n                13 as libc::c_int as isize,\n            ) = ((*info).background_b & 255 as libc::c_int as libc::c_uint)\n            as libc::c_uchar;\n    } else if (*info).color.colortype as libc::c_uint\n        == LCT_PALETTE as libc::c_int as libc::c_uint\n    {\n        let mut error_1 = lodepng_chunk_init(\n            core::ptr::addr_of_mut!(chunk),\n            out,\n            1 as libc::c_int as libc::c_uint,\n            b\"bKGD\\0\" as *const u8 as *const libc::c_char,\n        );\n        if error_1 != 0 {\n            return error_1;\n        }\n        *chunk\n            .offset(\n                8 as libc::c_int as isize,\n            ) = ((*info).background_r & 255 as libc::c_int as libc::c_uint)\n            as libc::c_uchar;\n    }\n    if !chunk.is_null() {\n        lodepng_chunk_generate_crc(chunk);\n    }else { (); }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_is_palette_type":"pub unsafe extern \"C\" fn lodepng_is_palette_type(\n    mut info: *const LodePNGColorMode,\n) -> libc::c_uint {\n    return ((*info).colortype as libc::c_uint\n        == LCT_PALETTE as libc::c_int as libc::c_uint) as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_convert_rgb":"pub unsafe extern \"C\" fn lodepng_convert_rgb(\n    mut r_out: *mut libc::c_uint,\n    mut g_out: *mut libc::c_uint,\n    mut b_out: *mut libc::c_uint,\n    mut r_in: libc::c_uint,\n    mut g_in: libc::c_uint,\n    mut b_in: libc::c_uint,\n    mut mode_out: *const LodePNGColorMode,\n    mut mode_in: *const LodePNGColorMode,\n) -> libc::c_uint {\n    let mut r = 0 as libc::c_int as libc::c_uint;\n    let mut g = 0 as libc::c_int as libc::c_uint;\n    let mut b = 0 as libc::c_int as libc::c_uint;\n    let mut mul = (65535 as libc::c_int as libc::c_uint)\n        .wrapping_div(\n            ((1 as libc::c_uint) << (*mode_in).bitdepth).wrapping_sub(1 as libc::c_uint),\n        );\n    let mut shift = (16 as libc::c_int as libc::c_uint)\n        .wrapping_sub((*mode_out).bitdepth);\n    if (*mode_in).colortype as libc::c_uint == LCT_GREY as libc::c_int as libc::c_uint\n        || (*mode_in).colortype as libc::c_uint\n            == LCT_GREY_ALPHA as libc::c_int as libc::c_uint\n    {\n        b= r_in.wrapping_mul(mul);\n        g= b;\n        r= g;\n    } else if (*mode_in).colortype as libc::c_uint\n        == LCT_RGB as libc::c_int as libc::c_uint\n        || (*mode_in).colortype as libc::c_uint\n            == LCT_RGBA as libc::c_int as libc::c_uint\n    {\n        r= r_in.wrapping_mul(mul);\n        g= g_in.wrapping_mul(mul);\n        b= b_in.wrapping_mul(mul);\n    } else if (*mode_in).colortype as libc::c_uint\n        == LCT_PALETTE as libc::c_int as libc::c_uint\n    {\n        if r_in as libc::c_ulong >= (*mode_in).palettesize {\n            return 82 as libc::c_int as libc::c_uint;\n        }\n        r= (*(*mode_in).palette\n            .offset(\n                r_in\n                    .wrapping_mul(4 as libc::c_int as libc::c_uint)\n                    .wrapping_add(0 as libc::c_int as libc::c_uint) as isize,\n            ) as libc::c_uint)\n            .wrapping_mul(257 as libc::c_uint);\n        g= (*(*mode_in).palette\n            .offset(\n                r_in\n                    .wrapping_mul(4 as libc::c_int as libc::c_uint)\n                    .wrapping_add(1 as libc::c_int as libc::c_uint) as isize,\n            ) as libc::c_uint)\n            .wrapping_mul(257 as libc::c_uint);\n        b= (*(*mode_in).palette\n            .offset(\n                r_in\n                    .wrapping_mul(4 as libc::c_int as libc::c_uint)\n                    .wrapping_add(2 as libc::c_int as libc::c_uint) as isize,\n            ) as libc::c_uint)\n            .wrapping_mul(257 as libc::c_uint);\n    } else {\n        return 31 as libc::c_int as libc::c_uint\n    }\n    if (*mode_out).colortype as libc::c_uint == LCT_GREY as libc::c_int as libc::c_uint\n        || (*mode_out).colortype as libc::c_uint\n            == LCT_GREY_ALPHA as libc::c_int as libc::c_uint\n    {\n        *r_out= r >> shift;\n    } else if (*mode_out).colortype as libc::c_uint\n        == LCT_RGB as libc::c_int as libc::c_uint\n        || (*mode_out).colortype as libc::c_uint\n            == LCT_RGBA as libc::c_int as libc::c_uint\n    {\n        *r_out= r >> shift;\n        *g_out= g >> shift;\n        *b_out= b >> shift;\n    } else if (*mode_out).colortype as libc::c_uint\n        == LCT_PALETTE as libc::c_int as libc::c_uint\n    {\n        let mut i: libc::c_uint = 0;\n        if r >> 8 as libc::c_int != r & 255 as libc::c_int as libc::c_uint\n            || g >> 8 as libc::c_int != g & 255 as libc::c_int as libc::c_uint\n            || b >> 8 as libc::c_int != b & 255 as libc::c_int as libc::c_uint\n        {\n            return 82 as libc::c_int as libc::c_uint;\n        }\n        i= 0 as libc::c_int as libc::c_uint;\n        while (i as libc::c_ulong) < (*mode_out).palettesize {\n            let mut j = i.wrapping_mul(4 as libc::c_int as libc::c_uint);\n            if r >> 8 as libc::c_int\n                == *(*mode_out).palette\n                    .offset(j.wrapping_add(0 as libc::c_int as libc::c_uint) as isize)\n                    as libc::c_uint\n                && g >> 8 as libc::c_int\n                    == *(*mode_out).palette\n                        .offset(\n                            j.wrapping_add(1 as libc::c_int as libc::c_uint) as isize,\n                        ) as libc::c_uint\n                && b >> 8 as libc::c_int\n                    == *(*mode_out).palette\n                        .offset(\n                            j.wrapping_add(2 as libc::c_int as libc::c_uint) as isize,\n                        ) as libc::c_uint\n            {\n                *r_out= i;\n                return 0 as libc::c_int as libc::c_uint;\n            }\n            i= i.wrapping_add(1);\n        }\n        return 82 as libc::c_int as libc::c_uint;\n    } else {\n        return 31 as libc::c_int as libc::c_uint\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_state_copy":"pub unsafe extern \"C\" fn lodepng_state_copy(\n    mut dest: *mut LodePNGState,\n    mut source: *const LodePNGState,\n) {\n    lodepng_state_cleanup(dest.as_mut());\n    *dest= (*source);\n    lodepng_color_mode_init(Some(&mut (*dest).info_raw));\n    lodepng_info_init(Some(&mut (*dest).info_png));\n    (*dest).error= lodepng_color_mode_copy(core::ptr::addr_of_mut!((*dest).info_raw), &(*source).info_raw);\n    if (*dest).error != 0 {\n        return;\n    }\n    (*dest).error= lodepng_info_copy(core::ptr::addr_of_mut!((*dest).info_png), &(*source).info_png);\n    if (*dest).error != 0 {\n        return;\n    }\n}","src::lodepng::addPaddingBits":"unsafe extern \"C\" fn addPaddingBits(\n    mut out: *mut libc::c_uchar,\n    mut in_0: *const libc::c_uchar,\n    mut olinebits: size_t,\n    mut ilinebits: size_t,\n    mut h: libc::c_uint,\n) {\n    let mut y: libc::c_uint = 0;\n    let mut diff = olinebits.wrapping_sub(ilinebits);\n    let mut obp = 0 as libc::c_int as size_t;\n    let mut ibp = 0 as libc::c_int as size_t;\n    y= 0 as libc::c_int as libc::c_uint;\n    while y != h {\n        let mut x: size_t = 0;\n        x= 0 as libc::c_int as size_t;\n        while x < ilinebits {\n            let mut bit = readBitFromReversedStream(Some(&mut ibp), in_0);\n            setBitOfReversedStream(Some(&mut obp), out, bit);\n            x= x.wrapping_add(1);\n        }\n        x= 0 as libc::c_int as size_t;\n        while x != diff {\n            setBitOfReversedStream(Some(&mut obp), out, 0 as libc::c_int as libc::c_uchar);\n            x= x.wrapping_add(1);\n        }\n        y= y.wrapping_add(1);\n    }\n}","src::lodepng::lodepng_chunk_check_crc":"pub unsafe extern \"C\" fn lodepng_chunk_check_crc(\n    mut chunk: *const libc::c_uchar,\n) -> libc::c_uint {\n    let mut length = lodepng_chunk_length(chunk);\n    let mut CRC = lodepng_read32bitInt(\n        &*chunk.offset(length.wrapping_add(8 as libc::c_int as libc::c_uint) as isize),\n    );\n    let mut checksum = lodepng_crc32(\n        &*chunk.offset(4 as libc::c_int as isize),\n        length.wrapping_add(4 as libc::c_int as libc::c_uint) as size_t,\n    );\n    if CRC != checksum {\n        return 1 as libc::c_int as libc::c_uint\n    } else {\n        return 0 as libc::c_int as libc::c_uint\n    };\n}","src::lodepng::lodepng_assign_icc":"unsafe extern \"C\" fn lodepng_assign_icc(\n    mut info: *mut LodePNGInfo,\n    mut name: *const libc::c_char,\n    mut profile: *const libc::c_uchar,\n    mut profile_size: libc::c_uint,\n) -> libc::c_uint {\n    if profile_size == 0 as libc::c_int as libc::c_uint {\n        return 100 as libc::c_int as libc::c_uint;\n    }\n    (*info).iccp_name= alloc_string(name);\n    (*info).iccp_profile= lodepng_malloc(profile_size as size_t) as *mut libc::c_uchar;\n    if (*info).iccp_name.is_null() || (*info).iccp_profile.is_null() {\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    lodepng_memcpy(\n        (*info).iccp_profile as *mut libc::c_void,\n        profile as *const libc::c_void,\n        profile_size as size_t,\n    );\n    (*info).iccp_profile_size= profile_size;\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::readChunk_tIME":"unsafe extern \"C\" fn readChunk_tIME(\n    mut info: *mut LodePNGInfo,\n    mut data: *const libc::c_uchar,\n    mut chunkLength: size_t,\n) -> libc::c_uint {\n    if chunkLength != 7 as libc::c_int as libc::c_ulong {\n        return 73 as libc::c_int as libc::c_uint;\n    }\n    (*info).time_defined= 1 as libc::c_int as libc::c_uint;\n    (*info).time.year= (256 as libc::c_uint)\n        .wrapping_mul(*data.offset(0 as libc::c_int as isize) as libc::c_uint)\n        .wrapping_add(*data.offset(1 as libc::c_int as isize) as libc::c_uint);\n    (*info).time.month= *data.offset(2 as libc::c_int as isize) as libc::c_uint;\n    (*info).time.day= *data.offset(3 as libc::c_int as isize) as libc::c_uint;\n    (*info).time.hour= *data.offset(4 as libc::c_int as isize) as libc::c_uint;\n    (*info).time.minute= *data.offset(5 as libc::c_int as isize) as libc::c_uint;\n    (*info).time.second= *data.offset(6 as libc::c_int as isize) as libc::c_uint;\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::HuffmanTree_makeFromLengths":"unsafe extern \"C\" fn HuffmanTree_makeFromLengths(\n    mut tree: Option<&mut HuffmanTree>,\n    mut bitlen: *const libc::c_uint,\n    mut numcodes: size_t,\n    mut maxbitlen: libc::c_uint,\n) -> libc::c_uint {\n    let mut i: libc::c_uint = 0;\n    (*tree.as_deref_mut().unwrap()).lengths= lodepng_malloc(\n        numcodes.wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong),\n    ) as *mut libc::c_uint;\n    if (*tree.as_deref().unwrap()).lengths.is_null() {();\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    i= 0 as libc::c_int as libc::c_uint;\n    while i as libc::c_ulong != numcodes {\n        *(*tree.as_deref().unwrap()).lengths.offset(i as isize) = *bitlen.offset(i as isize);\n        i= i.wrapping_add(1);\n    }\n    (*tree.as_deref_mut().unwrap()).numcodes= numcodes as libc::c_uint;\n    (*tree.as_deref_mut().unwrap()).maxbitlen= maxbitlen;\n    return HuffmanTree_makeFromLengths2(tree.as_deref_mut());\n}","src::lodepng::readChunk_iCCP":"unsafe extern \"C\" fn readChunk_iCCP(\n    mut info: *mut LodePNGInfo,\n    mut decoder: *const LodePNGDecoderSettings,\n    mut data: *const libc::c_uchar,\n    mut chunkLength: size_t,\n) -> libc::c_uint {\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut i: libc::c_uint = 0;\n    let mut size = 0 as libc::c_int as size_t;\n    let mut zlibsettings = (*decoder).zlibsettings;\n    let mut length: libc::c_uint = 0;\n    let mut string2_begin: libc::c_uint = 0;\n    (*info).iccp_defined= 1 as libc::c_int as libc::c_uint;\n    if !(*info).iccp_name.is_null() {\n        lodepng_clear_icc(info);\n    }else { (); }\n    length= 0 as libc::c_int as libc::c_uint;\n    while (length as libc::c_ulong) < chunkLength\n        && *data.offset(length as isize) as libc::c_int != 0 as libc::c_int\n    {\n        length= length.wrapping_add(1);\n    }\n    if length.wrapping_add(2 as libc::c_int as libc::c_uint) as libc::c_ulong\n        >= chunkLength\n    {\n        return 75 as libc::c_int as libc::c_uint;\n    }\n    if length < 1 as libc::c_int as libc::c_uint\n        || length > 79 as libc::c_int as libc::c_uint\n    {\n        return 89 as libc::c_int as libc::c_uint;\n    }\n    (*info).iccp_name= lodepng_malloc(\n        length.wrapping_add(1 as libc::c_int as libc::c_uint) as size_t,\n    ) as *mut libc::c_char;\n    if (*info).iccp_name.is_null() {();\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    *(*info).iccp_name.offset(length as isize) = 0 as libc::c_int as libc::c_char;\n    i= 0 as libc::c_int as libc::c_uint;\n    while i != length {\n        *(*info).iccp_name\n            .offset(i as isize) = *data.offset(i as isize) as libc::c_char;\n        i= i.wrapping_add(1);\n    }\n    if *data.offset(length.wrapping_add(1 as libc::c_int as libc::c_uint) as isize)\n        as libc::c_int != 0 as libc::c_int\n    {\n        return 72 as libc::c_int as libc::c_uint;\n    }\n    string2_begin= length.wrapping_add(2 as libc::c_int as libc::c_uint);\n    if string2_begin as libc::c_ulong > chunkLength {\n        return 75 as libc::c_int as libc::c_uint;\n    }\n    length= (chunkLength as libc::c_uint).wrapping_sub(string2_begin);\n    zlibsettings.max_output_size= (*decoder).max_icc_size;\n    error= zlib_decompress(\n        core::ptr::addr_of_mut!((*info).iccp_profile),\n        core::ptr::addr_of_mut!(size),\n        0 as libc::c_int as size_t,\n        &*data.offset(string2_begin as isize),\n        length as size_t,\n        core::ptr::addr_of!(zlibsettings),\n    );\n    if error != 0 && size > zlibsettings.max_output_size {\n        error= 113 as libc::c_int as libc::c_uint;\n    }\n    (*info).iccp_profile_size= size as libc::c_uint;\n    if error == 0 && (*info).iccp_profile_size == 0 {\n        error= 100 as libc::c_int as libc::c_uint;\n    }\n    return error;\n}","src::lodepng::isGrayICCProfile":"unsafe extern \"C\" fn isGrayICCProfile(\n    mut profile: *const libc::c_uchar,\n    mut size: libc::c_uint,\n) -> libc::c_uint {\n    if size < 20 as libc::c_int as libc::c_uint {\n        return 0 as libc::c_int as libc::c_uint;\n    }\n    return (*profile.offset(16 as libc::c_int as isize) as libc::c_int == 'G' as i32\n        && *profile.offset(17 as libc::c_int as isize) as libc::c_int == 'R' as i32\n        && *profile.offset(18 as libc::c_int as isize) as libc::c_int == 'A' as i32\n        && *profile.offset(19 as libc::c_int as isize) as libc::c_int == 'Y' as i32)\n        as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_encoder_settings_init":"pub unsafe extern \"C\" fn lodepng_encoder_settings_init(\n    mut settings: Option<&mut LodePNGEncoderSettings>,\n) {\n    lodepng_compress_settings_init(Some(&mut (*settings.as_deref_mut().unwrap()).zlibsettings));\n    (*settings.as_deref_mut().unwrap()).filter_palette_zero= 1 as libc::c_int as libc::c_uint;\n    (*settings.as_deref_mut().unwrap()).filter_strategy= LFS_MINSUM;\n    (*settings.as_deref_mut().unwrap()).auto_convert= 1 as libc::c_int as libc::c_uint;\n    (*settings.as_deref_mut().unwrap()).force_palette= 0 as libc::c_int as libc::c_uint;\n    (*settings.as_deref_mut().unwrap()).predefined_filters= 0 as *const libc::c_uchar;\n    (*settings.as_deref_mut().unwrap()).add_id= 0 as libc::c_int as libc::c_uint;\n    (*settings.as_deref_mut().unwrap()).text_compression= 1 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_set32bitInt":"unsafe extern \"C\" fn lodepng_set32bitInt(\n    mut buffer: *mut libc::c_uchar,\n    mut value: libc::c_uint,\n) {\n    *buffer\n        .offset(\n            0 as libc::c_int as isize,\n        ) = (value >> 24 as libc::c_int & 0xff as libc::c_int as libc::c_uint)\n        as libc::c_uchar;\n    *buffer\n        .offset(\n            1 as libc::c_int as isize,\n        ) = (value >> 16 as libc::c_int & 0xff as libc::c_int as libc::c_uint)\n        as libc::c_uchar;\n    *buffer\n        .offset(\n            2 as libc::c_int as isize,\n        ) = (value >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint)\n        as libc::c_uchar;\n    *buffer\n        .offset(\n            3 as libc::c_int as isize,\n        ) = (value & 0xff as libc::c_int as libc::c_uint) as libc::c_uchar;\n}","src::lodepng::Adam7_getpassvalues":"unsafe extern \"C\" fn Adam7_getpassvalues(\n    mut passw: *mut libc::c_uint,\n    mut passh: *mut libc::c_uint,\n    mut filter_passstart: *mut size_t,\n    mut padded_passstart: *mut size_t,\n    mut passstart: *mut size_t,\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n    mut bpp: libc::c_uint,\n) {\n    let mut i: libc::c_uint = 0;\n    i= 0 as libc::c_int as libc::c_uint;\n    while i != 7 as libc::c_int as libc::c_uint {\n        *passw\n            .offset(\n                i as isize,\n            ) = w\n            .wrapping_add(crate::src::lodepng::ADAM7_DX[i as usize])\n            .wrapping_sub(crate::src::lodepng::ADAM7_IX[i as usize])\n            .wrapping_sub(1 as libc::c_int as libc::c_uint)\n            .wrapping_div(crate::src::lodepng::ADAM7_DX[i as usize]);\n        *passh\n            .offset(\n                i as isize,\n            ) = h\n            .wrapping_add(crate::src::lodepng::ADAM7_DY[i as usize])\n            .wrapping_sub(crate::src::lodepng::ADAM7_IY[i as usize])\n            .wrapping_sub(1 as libc::c_int as libc::c_uint)\n            .wrapping_div(crate::src::lodepng::ADAM7_DY[i as usize]);\n        if *passw.offset(i as isize) == 0 as libc::c_int as libc::c_uint {\n            *passh.offset(i as isize) = 0 as libc::c_int as libc::c_uint;\n        }\n        if *passh.offset(i as isize) == 0 as libc::c_int as libc::c_uint {\n            *passw.offset(i as isize) = 0 as libc::c_int as libc::c_uint;\n        }\n        i= i.wrapping_add(1);\n    }\n    *passstart.offset(0 as libc::c_int as isize) = 0 as libc::c_int as size_t; *padded_passstart.offset(0 as libc::c_int as isize) = *passstart.offset(0 as libc::c_int as isize); *filter_passstart.offset(0 as libc::c_int as isize) = *padded_passstart.offset(0 as libc::c_int as isize);\n    i= 0 as libc::c_int as libc::c_uint;\n    while i != 7 as libc::c_int as libc::c_uint {\n        *filter_passstart\n            .offset(\n                i.wrapping_add(1 as libc::c_int as libc::c_uint) as isize,\n            ) = (*filter_passstart.offset(i as isize))\n            .wrapping_add(\n                (if *passw.offset(i as isize) != 0 && *passh.offset(i as isize) != 0 {\n                    (*passh.offset(i as isize))\n                        .wrapping_mul(\n                            (1 as libc::c_uint)\n                                .wrapping_add(\n                                    (*passw.offset(i as isize))\n                                        .wrapping_mul(bpp)\n                                        .wrapping_add(7 as libc::c_uint)\n                                        .wrapping_div(8 as libc::c_uint),\n                                ),\n                        )\n                } else {\n                    0 as libc::c_int as libc::c_uint\n                }) as libc::c_ulong,\n            );\n        *padded_passstart\n            .offset(\n                i.wrapping_add(1 as libc::c_int as libc::c_uint) as isize,\n            ) = (*padded_passstart.offset(i as isize))\n            .wrapping_add(\n                (*passh.offset(i as isize))\n                    .wrapping_mul(\n                        (*passw.offset(i as isize))\n                            .wrapping_mul(bpp)\n                            .wrapping_add(7 as libc::c_uint)\n                            .wrapping_div(8 as libc::c_uint),\n                    ) as libc::c_ulong,\n            );\n        *passstart\n            .offset(\n                i.wrapping_add(1 as libc::c_int as libc::c_uint) as isize,\n            ) = (*passstart.offset(i as isize))\n            .wrapping_add(\n                (*passh.offset(i as isize))\n                    .wrapping_mul(*passw.offset(i as isize))\n                    .wrapping_mul(bpp)\n                    .wrapping_add(7 as libc::c_uint)\n                    .wrapping_div(8 as libc::c_uint) as libc::c_ulong,\n            );\n        i= i.wrapping_add(1);\n    }\n}","src::lodepng::lodepng_decode":"pub unsafe extern \"C\" fn lodepng_decode(\n    mut out: *mut *mut libc::c_uchar,\n    mut w: *mut libc::c_uint,\n    mut h: *mut libc::c_uint,\n    mut state: *mut LodePNGState,\n    mut in_0: *const libc::c_uchar,\n    mut insize: size_t,\n) -> libc::c_uint {\n    *out= 0 as *mut libc::c_uchar;\n    decodeGeneric(out, w, h, state, in_0, insize);\n    if (*state).error != 0 {\n        return (*state).error;\n    }\n    if (*state).decoder.color_convert == 0\n        || lodepng_color_mode_equal(core::ptr::addr_of!((*state).info_raw), core::ptr::addr_of!((*state).info_png.color))\n            != 0\n    {\n        if (*state).decoder.color_convert == 0 {\n            (*state).error= lodepng_color_mode_copy(\n                core::ptr::addr_of_mut!((*state).info_raw),\n                core::ptr::addr_of!((*state).info_png.color),\n            );\n            if (*state).error != 0 {\n                return (*state).error;\n            }\n        }\n    } else {\n        let mut data = (*out);\n        let mut outsize: size_t = 0;\n        if !((*state).info_raw.colortype as libc::c_uint\n            == LCT_RGB as libc::c_int as libc::c_uint\n            || (*state).info_raw.colortype as libc::c_uint\n                == LCT_RGBA as libc::c_int as libc::c_uint)\n            && !((*state).info_raw.bitdepth == 8 as libc::c_int as libc::c_uint)\n        {\n            return 56 as libc::c_int as libc::c_uint;\n        }\n        outsize= lodepng_get_raw_size((*w), (*h), core::ptr::addr_of!((*state).info_raw));\n        *out= lodepng_malloc(outsize) as *mut libc::c_uchar;\n        if (*out).is_null() {();\n            (*state).error= 83 as libc::c_int as libc::c_uint;\n        } else {\n            (*state).error= lodepng_convert(\n                (*out),\n                data,\n                core::ptr::addr_of!((*state).info_raw),\n                core::ptr::addr_of!((*state).info_png.color),\n                (*w),\n                (*h),\n            );\n        }\n        lodepng_free(data as *mut libc::c_void);\n    }\n    return (*state).error;\n}","src::lodepng::lodepng_decoder_settings_init":"pub unsafe extern \"C\" fn lodepng_decoder_settings_init(\n    mut settings: Option<&mut LodePNGDecoderSettings>,\n) {\n    (*settings.as_deref_mut().unwrap()).color_convert= 1 as libc::c_int as libc::c_uint;\n    (*settings.as_deref_mut().unwrap()).read_text_chunks= 1 as libc::c_int as libc::c_uint;\n    (*settings.as_deref_mut().unwrap()).remember_unknown_chunks= 0 as libc::c_int as libc::c_uint;\n    (*settings.as_deref_mut().unwrap()).max_text_size= 16777216 as libc::c_int as size_t;\n    (*settings.as_deref_mut().unwrap()).max_icc_size= 16777216 as libc::c_int as size_t;\n    (*settings.as_deref_mut().unwrap()).ignore_crc= 0 as libc::c_int as libc::c_uint;\n    (*settings.as_deref_mut().unwrap()).ignore_critical= 0 as libc::c_int as libc::c_uint;\n    (*settings.as_deref_mut().unwrap()).ignore_end= 0 as libc::c_int as libc::c_uint;\n    lodepng_decompress_settings_init(Some(&mut (*settings.as_deref_mut().unwrap()).zlibsettings));\n}","src::lodepng::lodepng_palette_add":"pub unsafe extern \"C\" fn lodepng_palette_add(\n    mut info: *mut LodePNGColorMode,\n    mut r: libc::c_uchar,\n    mut g: libc::c_uchar,\n    mut b: libc::c_uchar,\n    mut a: libc::c_uchar,\n) -> libc::c_uint {\n    if (*info).palette.is_null() {();\n        lodepng_color_mode_alloc_palette(info);\n        if (*info).palette.is_null() {();\n            return 83 as libc::c_int as libc::c_uint;\n        }\n    }\n    if (*info).palettesize >= 256 as libc::c_int as libc::c_ulong {\n        return 108 as libc::c_int as libc::c_uint;\n    }\n    *(*info).palette\n        .offset(\n            (4 as libc::c_int as libc::c_ulong)\n                .wrapping_mul((*info).palettesize)\n                .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n        ) = r;\n    *(*info).palette\n        .offset(\n            (4 as libc::c_int as libc::c_ulong)\n                .wrapping_mul((*info).palettesize)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n        ) = g;\n    *(*info).palette\n        .offset(\n            (4 as libc::c_int as libc::c_ulong)\n                .wrapping_mul((*info).palettesize)\n                .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n        ) = b;\n    *(*info).palette\n        .offset(\n            (4 as libc::c_int as libc::c_ulong)\n                .wrapping_mul((*info).palettesize)\n                .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n        ) = a;\n    (*info).palettesize= (*info).palettesize.wrapping_add(1);\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::readChunk_iTXt":"unsafe extern \"C\" fn readChunk_iTXt(\n    mut info: *mut LodePNGInfo,\n    mut decoder: *const LodePNGDecoderSettings,\n    mut data: *const libc::c_uchar,\n    mut chunkLength: size_t,\n) -> libc::c_uint {\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut i: libc::c_uint = 0;\n    let mut zlibsettings = (*decoder).zlibsettings;\n    let mut length: libc::c_uint = 0;\n    let mut begin: libc::c_uint = 0;\n    let mut compressed: libc::c_uint = 0;\n    let mut key = 0 as *mut libc::c_char;\n    let mut langtag = 0 as *mut libc::c_char;\n    let mut transkey = 0 as *mut libc::c_char;\n    if error == 0 {\n        if chunkLength < 5 as libc::c_int as libc::c_ulong {\n            error= 30 as libc::c_int as libc::c_uint;\n        } else {\n            length= 0 as libc::c_int as libc::c_uint;\n            while (length as libc::c_ulong) < chunkLength\n                && *data.offset(length as isize) as libc::c_int != 0 as libc::c_int\n            {\n                length= length.wrapping_add(1);\n            }\n            if length.wrapping_add(3 as libc::c_int as libc::c_uint) as libc::c_ulong\n                >= chunkLength\n            {\n                error= 75 as libc::c_int as libc::c_uint;\n            } else if length < 1 as libc::c_int as libc::c_uint\n                || length > 79 as libc::c_int as libc::c_uint\n            {\n                error= 89 as libc::c_int as libc::c_uint;\n            } else {\n                key= lodepng_malloc(\n                    length.wrapping_add(1 as libc::c_int as libc::c_uint) as size_t,\n                ) as *mut libc::c_char;\n                if key.is_null() {();\n                    error= 83 as libc::c_int as libc::c_uint;\n                } else {\n                    lodepng_memcpy(\n                        key as *mut libc::c_void,\n                        data as *const libc::c_void,\n                        length as size_t,\n                    );\n                    *key.offset(length as isize) = 0 as libc::c_int as libc::c_char;\n                    compressed= *data\n                        .offset(\n                            length.wrapping_add(1 as libc::c_int as libc::c_uint)\n                                as isize,\n                        ) as libc::c_uint;\n                    if *data\n                        .offset(\n                            length.wrapping_add(2 as libc::c_int as libc::c_uint)\n                                as isize,\n                        ) as libc::c_int != 0 as libc::c_int\n                    {\n                        error= 72 as libc::c_int as libc::c_uint;\n                    } else {\n                        begin= length.wrapping_add(3 as libc::c_int as libc::c_uint);\n                        length= 0 as libc::c_int as libc::c_uint;\n                        i= begin;\n                        while (i as libc::c_ulong) < chunkLength\n                            && *data.offset(i as isize) as libc::c_int\n                                != 0 as libc::c_int\n                        {\n                            length= length.wrapping_add(1);\n                            i= i.wrapping_add(1);\n                        }\n                        langtag= lodepng_malloc(\n                            length.wrapping_add(1 as libc::c_int as libc::c_uint)\n                                as size_t,\n                        ) as *mut libc::c_char;\n                        if langtag.is_null() {();\n                            error= 83 as libc::c_int as libc::c_uint;\n                        } else {\n                            lodepng_memcpy(\n                                langtag as *mut libc::c_void,\n                                data.offset(begin as isize) as *const libc::c_void,\n                                length as size_t,\n                            );\n                            *langtag\n                                .offset(length as isize) = 0 as libc::c_int as libc::c_char;\n                            begin= begin\n                                .wrapping_add(\n                                    length.wrapping_add(1 as libc::c_int as libc::c_uint),\n                                );\n                            length= 0 as libc::c_int as libc::c_uint;\n                            i= begin;\n                            while (i as libc::c_ulong) < chunkLength\n                                && *data.offset(i as isize) as libc::c_int\n                                    != 0 as libc::c_int\n                            {\n                                length= length.wrapping_add(1);\n                                i= i.wrapping_add(1);\n                            }\n                            transkey= lodepng_malloc(\n                                length.wrapping_add(1 as libc::c_int as libc::c_uint)\n                                    as size_t,\n                            ) as *mut libc::c_char;\n                            if transkey.is_null() {();\n                                error= 83 as libc::c_int as libc::c_uint;\n                            } else {\n                                lodepng_memcpy(\n                                    transkey as *mut libc::c_void,\n                                    data.offset(begin as isize) as *const libc::c_void,\n                                    length as size_t,\n                                );\n                                *transkey\n                                    .offset(length as isize) = 0 as libc::c_int as libc::c_char;\n                                begin= begin\n                                    .wrapping_add(\n                                        length.wrapping_add(1 as libc::c_int as libc::c_uint),\n                                    );\n                                length= if (chunkLength as libc::c_uint) < begin {\n                                    0 as libc::c_int as libc::c_uint\n                                } else {\n                                    (chunkLength as libc::c_uint).wrapping_sub(begin)\n                                };\n                                if compressed != 0 {\n                                    let mut str = 0 as *mut libc::c_uchar;\n                                    let mut size = 0 as libc::c_int as size_t;\n                                    zlibsettings.max_output_size= (*decoder).max_text_size;\n                                    error= zlib_decompress(\n                                        core::ptr::addr_of_mut!(str),\n                                        core::ptr::addr_of_mut!(size),\n                                        0 as libc::c_int as size_t,\n                                        &*data.offset(begin as isize),\n                                        length as size_t,\n                                        core::ptr::addr_of!(zlibsettings),\n                                    );\n                                    if error != 0 && size > zlibsettings.max_output_size {\n                                        error= 112 as libc::c_int as libc::c_uint;\n                                    }\n                                    if error == 0 {\n                                        error= lodepng_add_itext_sized(\n                                            info,\n                                            key,\n                                            langtag,\n                                            transkey,\n                                            str as *mut libc::c_char,\n                                            size,\n                                        );\n                                    }\n                                    lodepng_free(str as *mut libc::c_void);\n                                } else {\n                                    error= lodepng_add_itext_sized(\n                                        info,\n                                        key,\n                                        langtag,\n                                        transkey,\n                                        data.offset(begin as isize) as *mut libc::c_char,\n                                        length as size_t,\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    lodepng_free(key as *mut libc::c_void);\n    lodepng_free(langtag as *mut libc::c_void);\n    lodepng_free(transkey as *mut libc::c_void);\n    return error;\n}","src::lodepng::boundaryPM":"unsafe extern \"C\" fn boundaryPM(\n    mut lists: Option<&mut BPMLists>,\n    mut leaves: *mut BPMNode,\n    mut numpresent: size_t,\n    mut c: libc::c_int,\n    mut num: libc::c_int,\n) {\n    let mut lastindex = (**(*lists.as_deref().unwrap()).chains1.offset(c as isize)).index;\n    if c == 0 as libc::c_int {\n        if lastindex as libc::c_ulong >= numpresent {\n            return;\n        }\n        *(*lists.as_deref().unwrap()).chains0.offset(c as isize) = *(*lists.as_deref().unwrap()).chains1.offset(c as isize);\n        *(*lists.as_deref().unwrap()).chains1.offset(c as isize) = bpmnode_create(\n            lists.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()),\n            (*leaves.offset(lastindex as isize)).weight,\n            lastindex.wrapping_add(1 as libc::c_int as libc::c_uint),\n            0 as *mut BPMNode,\n        );\n    } else {\n        let mut sum = (**(*lists.as_deref().unwrap()).chains0.offset((c - 1 as libc::c_int) as isize))\n            .weight\n            + (**(*lists.as_deref().unwrap()).chains1.offset((c - 1 as libc::c_int) as isize)).weight;\n        *(*lists.as_deref().unwrap()).chains0.offset(c as isize) = *(*lists.as_deref().unwrap()).chains1.offset(c as isize);\n        if (lastindex as libc::c_ulong) < numpresent\n            && sum > (*leaves.offset(lastindex as isize)).weight\n        {\n            *(*lists.as_deref().unwrap()).chains1.offset(c as isize) = bpmnode_create(\n                lists.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()),\n                (*leaves.offset(lastindex as isize)).weight,\n                lastindex.wrapping_add(1 as libc::c_int as libc::c_uint),\n                (**(*lists.as_deref().unwrap()).chains1.offset(c as isize)).tail,\n            );\n            return;\n        }\n        *(*lists.as_deref().unwrap()).chains1.offset(c as isize) = bpmnode_create(\n            lists.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()),\n            sum,\n            lastindex,\n            *(*lists.as_deref().unwrap()).chains1.offset((c - 1 as libc::c_int) as isize),\n        );\n        if (num + 1 as libc::c_int)\n            < (2 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(numpresent)\n                .wrapping_sub(2 as libc::c_int as libc::c_ulong) as libc::c_int\n        {\n            boundaryPM(lists.as_deref_mut(), leaves, numpresent, c - 1 as libc::c_int, num);\n            boundaryPM(lists.as_deref_mut(), leaves, numpresent, c - 1 as libc::c_int, num);\n        }\n    };\n}","src::lodepng::lodepng_info_copy":"pub unsafe extern \"C\" fn lodepng_info_copy(\n    mut dest: *mut LodePNGInfo,\n    mut source: *const LodePNGInfo,\n) -> libc::c_uint {\n    lodepng_info_cleanup(dest.as_mut());\n    lodepng_memcpy(\n        dest as *mut libc::c_void,\n        source as *const libc::c_void,\n        ::std::mem::size_of::<LodePNGInfo>() as libc::c_ulong,\n    );\n    lodepng_color_mode_init(Some(&mut (*dest).color));\n    let mut error = lodepng_color_mode_copy(core::ptr::addr_of_mut!((*dest).color), &(*source).color);\n    if error != 0 {\n        return error;\n    }\n    let mut error_0 = LodePNGText_copy(dest, source);\n    if error_0 != 0 {\n        return error_0;\n    }\n    let mut error_1 = LodePNGIText_copy(dest, source);\n    if error_1 != 0 {\n        return error_1;\n    }\n    if (*source).iccp_defined != 0 {\n        let mut error_2 = lodepng_assign_icc(\n            dest,\n            (*source).iccp_name,\n            (*source).iccp_profile,\n            (*source).iccp_profile_size,\n        );\n        if error_2 != 0 {\n            return error_2;\n        }\n    }\n    LodePNGUnknownChunks_init(dest.as_mut());\n    let mut error_3 = LodePNGUnknownChunks_copy(dest, source);\n    if error_3 != 0 {\n        return error_3;\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::inflatev":"unsafe extern \"C\" fn inflatev(\n    mut out: *mut ucvector,\n    mut in_0: *const libc::c_uchar,\n    mut insize: size_t,\n    mut settings: *const LodePNGDecompressSettings,\n) -> libc::c_uint {\n    if (*settings).custom_inflate.is_some() {\n        let mut error = (*settings).custom_inflate\n            .expect(\n                \"non-null function pointer\",\n            )(core::ptr::addr_of_mut!((*out).data), core::ptr::addr_of_mut!((*out).size), in_0, insize, settings);\n        (*out).allocsize= (*out).size;\n        if error != 0 {\n            error= 110 as libc::c_int as libc::c_uint;\n            if (*settings).max_output_size != 0\n                && (*out).size > (*settings).max_output_size\n            {\n                error= 109 as libc::c_int as libc::c_uint;\n            }\n        }\n        return error;\n    } else {\n        return lodepng_inflatev(out, in_0, insize, settings)\n    };\n}","src::lodepng::huffmanDecodeSymbol":"unsafe extern \"C\" fn huffmanDecodeSymbol(\n    mut reader: Option<&mut LodePNGBitReader>,\n    mut codetree: *const HuffmanTree,\n) -> libc::c_uint {\n    let mut code = peekBits(reader.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), 9 as libc::c_uint as size_t) as libc::c_ushort;\n    let mut l = *(*codetree).table_len.offset(code as isize) as libc::c_ushort;\n    let mut value = *(*codetree).table_value.offset(code as isize);\n    if l as libc::c_uint <= 9 as libc::c_uint {\n        advanceBits(reader.as_deref_mut(), l as size_t);\n        return value as libc::c_uint;\n    } else {\n        advanceBits(reader.as_deref_mut(), 9 as libc::c_uint as size_t);\n        value= (value as libc::c_uint)\n            .wrapping_add(\n                peekBits(\n                    reader.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()),\n                    (l as libc::c_uint).wrapping_sub(9 as libc::c_uint) as size_t,\n                ),\n            ) as libc::c_ushort as libc::c_ushort;\n        advanceBits(\n            reader.as_deref_mut(),\n            (*(*codetree).table_len.offset(value as isize) as libc::c_uint)\n                .wrapping_sub(9 as libc::c_uint) as size_t,\n        );\n        return *(*codetree).table_value.offset(value as isize) as libc::c_uint;\n    };\n}","src::lodepng::alloc_string_sized":"unsafe extern \"C\" fn alloc_string_sized(\n    mut in_0: *const libc::c_char,\n    mut insize: size_t,\n) -> *mut /* owning */ libc::c_char {\n    let mut out = lodepng_malloc(insize.wrapping_add(1 as libc::c_int as libc::c_ulong))\n        as *mut libc::c_char;\n    if !out.is_null() {\n        lodepng_memcpy(out as *mut libc::c_void, in_0 as *const libc::c_void, insize);\n        *out.offset(insize as isize) = 0 as libc::c_int as libc::c_char;\n    }else { (); }\n    return out;\n}","src::lodepng::lodepng_encode24":"pub unsafe extern \"C\" fn lodepng_encode24(\n    mut out: Option<&mut *mut /* owning */ libc::c_uchar>,\n    mut outsize: Option<&mut size_t>,\n    mut image: *const libc::c_uchar,\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n) -> libc::c_uint {\n    return lodepng_encode_memory(\n        out.as_deref_mut(),\n        outsize.as_deref_mut(),\n        image,\n        w,\n        h,\n        LCT_RGB,\n        8 as libc::c_int as libc::c_uint,\n    );\n}","src::lodepng::writeBitsReversed":"unsafe extern \"C\" fn writeBitsReversed(\n    mut writer: Option<&mut LodePNGBitWriter>,\n    mut value: libc::c_uint,\n    mut nbits: size_t,\n) {\n    let mut i: size_t = 0;\n    i= 0 as libc::c_int as size_t;\n    while i != nbits {\n        if (*writer.as_deref().unwrap()).bp as libc::c_uint & 7 as libc::c_uint\n            == 0 as libc::c_int as libc::c_uint\n        {\n            if ucvector_resize(\n                (*writer.as_deref().unwrap()).data.as_mut(),\n                (*(*writer.as_deref().unwrap()).data).size.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            ) == 0\n            {\n                return;\n            }\n            *(*(*writer.as_deref().unwrap()).data).data\n                .offset(\n                    (*(*writer.as_deref().unwrap()).data).size\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                ) = 0 as libc::c_int as libc::c_uchar;\n        }\n        *(*(*writer.as_deref().unwrap()).data).data\n            .offset(\n                (*(*writer.as_deref().unwrap()).data).size.wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    as isize,\n            ) = (*(*(*writer.as_deref().unwrap()).data).data\n            .offset(\n                (*(*writer.as_deref().unwrap()).data).size.wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    as isize,\n            ) as libc::c_int\n            | ((value\n                >> nbits.wrapping_sub(1 as libc::c_uint as libc::c_ulong).wrapping_sub(i)\n                & 1 as libc::c_uint) as libc::c_uchar as libc::c_int)\n                << ((*writer.as_deref().unwrap()).bp as libc::c_uint & 7 as libc::c_uint)) as libc::c_uchar;\n        (*writer.as_deref_mut().unwrap()).bp= (*writer.as_deref().unwrap()).bp.wrapping_add(1);\n        i= i.wrapping_add(1);\n    }\n}","src::lodepng::lodepng_add_itext":"pub unsafe extern \"C\" fn lodepng_add_itext(\n    mut info: *mut LodePNGInfo,\n    mut key: *const libc::c_char,\n    mut langtag: *const libc::c_char,\n    mut transkey: *const libc::c_char,\n    mut str: *const libc::c_char,\n) -> libc::c_uint {\n    return {let crown_promoted_local_0 = lodepng_strlen(str);lodepng_add_itext_sized(\n        info,\n        key,\n        langtag,\n        transkey,\n        str,\n        crown_promoted_local_0,\n    )};\n}","src::lodepng::lodepng_mulofl":"unsafe extern \"C\" fn lodepng_mulofl(\n    mut a: size_t,\n    mut b: size_t,\n    mut result: Option<&mut size_t>,\n) -> libc::c_int {\n    *result.as_deref_mut().unwrap()= a.wrapping_mul(b);\n    return (a != 0 as libc::c_int as libc::c_ulong && (*result.as_deref().unwrap()).wrapping_div(a) != b)\n        as libc::c_int;\n}","src::lodepng::deflateFixed":"unsafe extern \"C\" fn deflateFixed(\n    mut writer: Option<&mut LodePNGBitWriter>,\n    mut hash: Option<&mut Hash>,\n    mut data: *const libc::c_uchar,\n    mut datapos: size_t,\n    mut dataend: size_t,\n    mut settings: *const LodePNGCompressSettings,\n    mut final_0: libc::c_uint,\n) -> libc::c_uint {\n    let mut tree_ll = HuffmanTree {\n        codes: 0 as *mut libc::c_uint,\n        lengths: 0 as *mut libc::c_uint,\n        maxbitlen: 0,\n        numcodes: 0,\n        table_len: 0 as *mut libc::c_uchar,\n        table_value: 0 as *mut libc::c_ushort,\n    };\n    let mut tree_d = HuffmanTree {\n        codes: 0 as *mut libc::c_uint,\n        lengths: 0 as *mut libc::c_uint,\n        maxbitlen: 0,\n        numcodes: 0,\n        table_len: 0 as *mut libc::c_uchar,\n        table_value: 0 as *mut libc::c_ushort,\n    };\n    let mut BFINAL = final_0;\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut i: size_t = 0;\n    HuffmanTree_init(Some(&mut tree_ll));\n    HuffmanTree_init(Some(&mut tree_d));\n    error= generateFixedLitLenTree(Some(&mut tree_ll));\n    if error == 0 {\n        error= generateFixedDistanceTree(Some(&mut tree_d));\n    }\n    if error == 0 {\n        writeBits(writer.as_deref_mut(), BFINAL, 1 as libc::c_int as size_t);\n        writeBits(writer.as_deref_mut(), 1 as libc::c_int as libc::c_uint, 1 as libc::c_int as size_t);\n        writeBits(writer.as_deref_mut(), 0 as libc::c_int as libc::c_uint, 1 as libc::c_int as size_t);\n        if (*settings).use_lz77 != 0 {\n            let mut lz77_encoded = uivector {\n                data: 0 as *mut libc::c_uint,\n                size: 0,\n                allocsize: 0,\n            };\n            uivector_init(Some(&mut lz77_encoded));\n            error= encodeLZ77(\n                Some(&mut lz77_encoded),\n                hash.as_deref_mut(),\n                data,\n                datapos,\n                dataend,\n                (*settings).windowsize,\n                (*settings).minmatch,\n                (*settings).nicematch,\n                (*settings).lazymatching,\n            );\n            if error == 0 {\n                writeLZ77data(writer.as_deref_mut(), core::ptr::addr_of!(lz77_encoded), core::ptr::addr_of!(tree_ll), core::ptr::addr_of!(tree_d));\n            }\n            uivector_cleanup(core::ptr::addr_of_mut!(lz77_encoded) as *mut uivector as *mut libc::c_void);\n        } else {\n            i= datapos;\n            while i < dataend {\n                writeBitsReversed(\n                    writer.as_deref_mut(),\n                    *tree_ll.codes.offset(*data.offset(i as isize) as isize),\n                    *tree_ll.lengths.offset(*data.offset(i as isize) as isize)\n                        as size_t,\n                );\n                i= i.wrapping_add(1);\n            }\n        }\n        if error == 0 {\n            writeBitsReversed(\n                writer.as_deref_mut(),\n                *tree_ll.codes.offset(256 as libc::c_int as isize),\n                *tree_ll.lengths.offset(256 as libc::c_int as isize) as size_t,\n            );\n        }\n    }\n    HuffmanTree_cleanup(Some(&mut tree_ll));\n    HuffmanTree_cleanup(Some(&mut tree_d));\n    return error;\n}","src::lodepng::getNumColorChannels":"unsafe extern \"C\" fn getNumColorChannels(\n    mut colortype: LodePNGColorType,\n) -> libc::c_uint {\n    match  colortype as libc::c_uint {\n        0 => return 1 as libc::c_int as libc::c_uint,\n        2 => return 3 as libc::c_int as libc::c_uint,\n        3 => return 1 as libc::c_int as libc::c_uint,\n        4 => return 2 as libc::c_int as libc::c_uint,\n        6 => return 4 as libc::c_int as libc::c_uint,\n        255 => return 0 as libc::c_int as libc::c_uint,\n        _ => return 0 as libc::c_int as libc::c_uint,\n    };\n}","src::lodepng::lodepng_color_mode_alloc_palette":"unsafe extern \"C\" fn lodepng_color_mode_alloc_palette(mut info: *mut LodePNGColorMode) {\n    let mut i: size_t = 0;\n    if (*info).palette.is_null() {();\n        (*info).palette= lodepng_malloc(1024 as libc::c_int as size_t) as *mut libc::c_uchar;\n    }\n    if (*info).palette.is_null() {();\n        return;\n    }\n    i= 0 as libc::c_int as size_t;\n    while i != 256 as libc::c_int as libc::c_ulong {\n        *(*info).palette\n            .offset(\n                i\n                    .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n            ) = 0 as libc::c_int as libc::c_uchar;\n        *(*info).palette\n            .offset(\n                i\n                    .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n            ) = 0 as libc::c_int as libc::c_uchar;\n        *(*info).palette\n            .offset(\n                i\n                    .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n            ) = 0 as libc::c_int as libc::c_uchar;\n        *(*info).palette\n            .offset(\n                i\n                    .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n            ) = 255 as libc::c_int as libc::c_uchar;\n        i= i.wrapping_add(1);\n    }\n}","src::lodepng::lodepng_chunk_find":"pub unsafe extern \"C\" fn lodepng_chunk_find(\n    mut chunk: *mut libc::c_uchar,\n    mut end: *mut libc::c_uchar,\n    mut type_0: *const libc::c_char,\n) -> *mut libc::c_uchar {\n    loop {\n        if chunk >= end\n            || (end.offset_from(chunk) as libc::c_long)\n                < 12 as libc::c_int as libc::c_long\n        {\n            return 0 as *mut libc::c_uchar;\n        }\n        if lodepng_chunk_type_equals(chunk, type_0) != 0 {\n            return chunk;\n        }\n        chunk= lodepng_chunk_next(chunk, end);\n    };\n}","src::lodepng::lodepng_chunk_init":"unsafe extern \"C\" fn lodepng_chunk_init(\n    mut chunk: *mut *mut libc::c_uchar,\n    mut out: *mut ucvector,\n    mut length: libc::c_uint,\n    mut type_0: *const libc::c_char,\n) -> libc::c_uint {\n    let mut new_length = (*out).size;\n    if lodepng_addofl(new_length, length as size_t, Some(&mut new_length)) != 0 {\n        return 77 as libc::c_int as libc::c_uint;\n    }\n    if lodepng_addofl(new_length, 12 as libc::c_int as size_t, Some(&mut new_length)) != 0 {\n        return 77 as libc::c_int as libc::c_uint;\n    }\n    if ucvector_resize(out.as_mut(), new_length) == 0 {\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    *chunk= (*out).data\n        .offset(new_length as isize)\n        .offset(-(length as isize))\n        .offset(-(12 as libc::c_uint as isize));\n    lodepng_set32bitInt((*chunk), length);\n    lodepng_memcpy(\n        (*chunk).offset(4 as libc::c_int as isize) as *mut libc::c_void,\n        type_0 as *const libc::c_void,\n        4 as libc::c_int as size_t,\n    );\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::addChunk_iCCP":"unsafe extern \"C\" fn addChunk_iCCP(\n    mut out: *mut ucvector,\n    mut info: *const LodePNGInfo,\n    mut zlibsettings: *mut LodePNGCompressSettings,\n) -> libc::c_uint {\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut chunk = 0 as *mut libc::c_uchar;\n    let mut compressed = 0 as *mut libc::c_uchar;\n    let mut compressedsize = 0 as libc::c_int as size_t;\n    let mut keysize = lodepng_strlen((*info).iccp_name);\n    if keysize < 1 as libc::c_int as libc::c_ulong\n        || keysize > 79 as libc::c_int as libc::c_ulong\n    {\n        return 89 as libc::c_int as libc::c_uint;\n    }\n    error= zlib_compress(\n        core::ptr::addr_of_mut!(compressed),\n        core::ptr::addr_of_mut!(compressedsize),\n        (*info).iccp_profile,\n        (*info).iccp_profile_size as size_t,\n        zlibsettings,\n    );\n    if error == 0 {\n        let mut size = keysize\n            .wrapping_add(2 as libc::c_int as libc::c_ulong)\n            .wrapping_add(compressedsize);\n        error= lodepng_chunk_init(\n            core::ptr::addr_of_mut!(chunk),\n            out,\n            size as libc::c_uint,\n            b\"iCCP\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if error == 0 {\n        lodepng_memcpy(\n            chunk.offset(8 as libc::c_int as isize) as *mut libc::c_void,\n            (*info).iccp_name as *const libc::c_void,\n            keysize,\n        );\n        *chunk\n            .offset(\n                (8 as libc::c_int as libc::c_ulong).wrapping_add(keysize) as isize,\n            ) = 0 as libc::c_int as libc::c_uchar;\n        *chunk\n            .offset(\n                (9 as libc::c_int as libc::c_ulong).wrapping_add(keysize) as isize,\n            ) = 0 as libc::c_int as libc::c_uchar;\n        lodepng_memcpy(\n            chunk.offset(10 as libc::c_int as isize).offset(keysize as isize)\n                as *mut libc::c_void,\n            compressed as *const u8 as *const libc::c_void,\n            compressedsize,\n        );\n        lodepng_chunk_generate_crc(chunk);\n    }\n    lodepng_free(compressed as *mut libc::c_void);\n    return error;\n}","src::lodepng::lodepng_decompress_settings_init":"pub unsafe extern \"C\" fn lodepng_decompress_settings_init(\n    mut settings: Option<&mut LodePNGDecompressSettings>,\n) {\n    (*settings.as_deref_mut().unwrap()).ignore_adler32= 0 as libc::c_int as libc::c_uint;\n    (*settings.as_deref_mut().unwrap()).ignore_nlen= 0 as libc::c_int as libc::c_uint;\n    (*settings.as_deref_mut().unwrap()).max_output_size= 0 as libc::c_int as size_t;\n    (*settings.as_deref_mut().unwrap()).custom_zlib= None;\n    (*settings.as_deref_mut().unwrap()).custom_inflate= None;\n    (*settings.as_deref_mut().unwrap()).custom_context= 0 as *const libc::c_void;\n}","src::lodepng::lodepng_color_stats_init":"pub unsafe extern \"C\" fn lodepng_color_stats_init(mut stats: Option<&mut LodePNGColorStats>) {\n    (*stats.as_deref_mut().unwrap()).colored= 0 as libc::c_int as libc::c_uint;\n    (*stats.as_deref_mut().unwrap()).key= 0 as libc::c_int as libc::c_uint;\n    (*stats.as_deref_mut().unwrap()).key_b= 0 as libc::c_int as libc::c_ushort; (*stats.as_deref_mut().unwrap()).key_g= (*stats.as_deref().unwrap()).key_b; (*stats.as_deref_mut().unwrap()).key_r= (*stats.as_deref().unwrap()).key_g;\n    (*stats.as_deref_mut().unwrap()).alpha= 0 as libc::c_int as libc::c_uint;\n    (*stats.as_deref_mut().unwrap()).numcolors= 0 as libc::c_int as libc::c_uint;\n    (*stats.as_deref_mut().unwrap()).bits= 1 as libc::c_int as libc::c_uint;\n    (*stats.as_deref_mut().unwrap()).numpixels= 0 as libc::c_int as size_t;\n    (*stats.as_deref_mut().unwrap()).allow_palette= 1 as libc::c_int as libc::c_uint;\n    (*stats.as_deref_mut().unwrap()).allow_greyscale= 1 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_clear_itext":"pub unsafe extern \"C\" fn lodepng_clear_itext(mut info: Option<&mut LodePNGInfo>) {\n    LodePNGIText_cleanup(info.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()));\n}","src::lodepng::zlib_compress":"unsafe extern \"C\" fn zlib_compress(\n    mut out: *mut *mut libc::c_uchar,\n    mut outsize: *mut size_t,\n    mut in_0: *const libc::c_uchar,\n    mut insize: size_t,\n    mut settings: *const LodePNGCompressSettings,\n) -> libc::c_uint {\n    if (*settings).custom_zlib.is_some() {\n        let mut error = (*settings).custom_zlib\n            .expect(\"non-null function pointer\")(out, outsize, in_0, insize, settings);\n        return (if error != 0 { 111 as libc::c_int } else { 0 as libc::c_int })\n            as libc::c_uint;\n    } else {\n        return lodepng_zlib_compress(out.as_mut(), outsize.as_mut(), in_0, insize, settings)\n    };\n}","src::lodepng::LodePNGIText_init":"unsafe extern \"C\" fn LodePNGIText_init(mut info: Option<&mut LodePNGInfo>) {\n    (*info.as_deref_mut().unwrap()).itext_num= 0 as libc::c_int as size_t;\n    (*info.as_deref_mut().unwrap()).itext_keys= 0 as *mut *mut libc::c_char;\n    (*info.as_deref_mut().unwrap()).itext_langtags= 0 as *mut *mut libc::c_char;\n    (*info.as_deref_mut().unwrap()).itext_transkeys= 0 as *mut *mut libc::c_char;\n    (*info.as_deref_mut().unwrap()).itext_strings= 0 as *mut *mut libc::c_char;\n}","src::lodepng::ensureBits17":"unsafe extern \"C\" fn ensureBits17(mut reader: Option<&mut LodePNGBitReader>, mut nbits: size_t) {\n    let mut start = (*reader.as_deref().unwrap()).bp >> 3 as libc::c_uint;\n    let mut size = (*reader.as_deref().unwrap()).size;\n    if start.wrapping_add(2 as libc::c_uint as libc::c_ulong) < size {\n        (*reader.as_deref_mut().unwrap()).buffer= *(*reader.as_deref().unwrap()).data\n            .offset(start.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize)\n            as libc::c_uint\n            | (*(*reader.as_deref().unwrap()).data\n                .offset(start.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize)\n                as libc::c_uint) << 8 as libc::c_uint\n            | (*(*reader.as_deref().unwrap()).data\n                .offset(start.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize)\n                as libc::c_uint) << 16 as libc::c_uint;\n        (*reader.as_deref_mut().unwrap()).buffer>>= (*reader.as_deref().unwrap()).bp & 7 as libc::c_uint as libc::c_ulong;\n    } else {\n        (*reader.as_deref_mut().unwrap()).buffer= 0 as libc::c_int as libc::c_uint;\n        if start.wrapping_add(0 as libc::c_uint as libc::c_ulong) < size {\n            (*reader.as_deref_mut().unwrap()).buffer|= *(*reader.as_deref().unwrap()).data\n                    .offset(\n                        start.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint;\n        }\n        if start.wrapping_add(1 as libc::c_uint as libc::c_ulong) < size {\n            (*reader.as_deref_mut().unwrap()).buffer|= (*(*reader.as_deref().unwrap()).data\n                    .offset(\n                        start.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint) << 8 as libc::c_uint;\n        }\n        (*reader.as_deref_mut().unwrap()).buffer>>= (*reader.as_deref().unwrap()).bp & 7 as libc::c_uint as libc::c_ulong;\n    };\n}","src::lodepng::LodePNGIText_cleanup":"unsafe extern \"C\" fn LodePNGIText_cleanup(mut info: *mut LodePNGInfo) {\n    let mut i: size_t = 0;\n    i= 0 as libc::c_int as size_t;\n    while i != (*info).itext_num {\n        string_cleanup(core::ptr::addr_of_mut!(*(*info).itext_keys.offset(i as isize)));\n        string_cleanup(core::ptr::addr_of_mut!(*(*info).itext_langtags.offset(i as isize)));\n        string_cleanup(core::ptr::addr_of_mut!(*(*info).itext_transkeys.offset(i as isize)));\n        string_cleanup(core::ptr::addr_of_mut!(*(*info).itext_strings.offset(i as isize)));\n        i= i.wrapping_add(1);\n    }\n    lodepng_free((*info).itext_keys as *mut libc::c_void);\n    lodepng_free((*info).itext_langtags as *mut libc::c_void);\n    lodepng_free((*info).itext_transkeys as *mut libc::c_void);\n    lodepng_free((*info).itext_strings as *mut libc::c_void);\n}","src::lodepng::addColorBits":"unsafe extern \"C\" fn addColorBits(\n    mut out: *mut libc::c_uchar,\n    mut index: size_t,\n    mut bits: libc::c_uint,\n    mut in_0: libc::c_uint,\n) {\n    let mut m = (if bits == 1 as libc::c_int as libc::c_uint {\n        7 as libc::c_int\n    } else if bits == 2 as libc::c_int as libc::c_uint {\n        3 as libc::c_int\n    } else {\n        1 as libc::c_int\n    }) as libc::c_uint;\n    let mut p = (index & m as libc::c_ulong) as libc::c_uint;\n    in_0&= ((1 as libc::c_uint) << bits).wrapping_sub(1 as libc::c_uint);\n    in_0= in_0 << bits.wrapping_mul(m.wrapping_sub(p));\n    if p == 0 as libc::c_int as libc::c_uint {\n        *out\n            .offset(\n                index\n                    .wrapping_mul(bits as libc::c_ulong)\n                    .wrapping_div(8 as libc::c_uint as libc::c_ulong) as isize,\n            ) = in_0 as libc::c_uchar;\n    } else {\n        *out\n            .offset(\n                index\n                    .wrapping_mul(bits as libc::c_ulong)\n                    .wrapping_div(8 as libc::c_uint as libc::c_ulong) as isize,\n            ) = (*out\n            .offset(\n                index\n                    .wrapping_mul(bits as libc::c_ulong)\n                    .wrapping_div(8 as libc::c_uint as libc::c_ulong) as isize,\n            ) as libc::c_uint | in_0) as libc::c_uchar;\n    };\n}","src::lodepng::color_tree_has":"unsafe extern \"C\" fn color_tree_has(\n    mut tree: *mut ColorTree,\n    mut r: libc::c_uchar,\n    mut g: libc::c_uchar,\n    mut b: libc::c_uchar,\n    mut a: libc::c_uchar,\n) -> libc::c_int {\n    return (color_tree_get(tree, r, g, b, a) >= 0 as libc::c_int) as libc::c_int;\n}","src::lodepng::lodepng_malloc":"unsafe extern \"C\" fn lodepng_malloc(mut size: size_t) -> *mut /* owning */ libc::c_void {\n    return malloc(size);\n}","src::lodepng::alloc_string":"unsafe extern \"C\" fn alloc_string(mut in_0: *const libc::c_char) -> *mut /* owning */ libc::c_char {\n    return {let crown_promoted_local_0 = lodepng_strlen(in_0);alloc_string_sized(in_0, crown_promoted_local_0)};\n}","src::lodepng::lodepng_get_channels":"pub unsafe extern \"C\" fn lodepng_get_channels(\n    mut info: *const LodePNGColorMode,\n) -> libc::c_uint {\n    return getNumColorChannels((*info).colortype);\n}","src::lodepng::hash_cleanup":"unsafe extern \"C\" fn hash_cleanup(mut hash: Option<&mut Hash>) {\n    lodepng_free((*hash.as_deref_mut().unwrap()).head as *mut libc::c_void);\n    lodepng_free((*hash.as_deref_mut().unwrap()).val as *mut libc::c_void);\n    lodepng_free((*hash.as_deref_mut().unwrap()).chain as *mut libc::c_void);\n    lodepng_free((*hash.as_deref_mut().unwrap()).zeros as *mut libc::c_void);\n    lodepng_free((*hash.as_deref_mut().unwrap()).headz as *mut libc::c_void);\n    lodepng_free((*hash.as_deref_mut().unwrap()).chainz as *mut libc::c_void);\n}","src::lodepng::lodepng_info_init":"pub unsafe extern \"C\" fn lodepng_info_init(mut info: Option<&mut LodePNGInfo>) {\n    lodepng_color_mode_init(Some(&mut (*info.as_deref_mut().unwrap()).color));\n    (*info.as_deref_mut().unwrap()).interlace_method= 0 as libc::c_int as libc::c_uint;\n    (*info.as_deref_mut().unwrap()).compression_method= 0 as libc::c_int as libc::c_uint;\n    (*info.as_deref_mut().unwrap()).filter_method= 0 as libc::c_int as libc::c_uint;\n    (*info.as_deref_mut().unwrap()).background_defined= 0 as libc::c_int as libc::c_uint;\n    (*info.as_deref_mut().unwrap()).background_b= 0 as libc::c_int as libc::c_uint; (*info.as_deref_mut().unwrap()).background_g= (*info.as_deref().unwrap()).background_b; (*info.as_deref_mut().unwrap()).background_r= (*info.as_deref().unwrap()).background_g;\n    LodePNGText_init(info.as_deref_mut());\n    LodePNGIText_init(info.as_deref_mut());\n    (*info.as_deref_mut().unwrap()).time_defined= 0 as libc::c_int as libc::c_uint;\n    (*info.as_deref_mut().unwrap()).phys_defined= 0 as libc::c_int as libc::c_uint;\n    (*info.as_deref_mut().unwrap()).gama_defined= 0 as libc::c_int as libc::c_uint;\n    (*info.as_deref_mut().unwrap()).chrm_defined= 0 as libc::c_int as libc::c_uint;\n    (*info.as_deref_mut().unwrap()).srgb_defined= 0 as libc::c_int as libc::c_uint;\n    (*info.as_deref_mut().unwrap()).iccp_defined= 0 as libc::c_int as libc::c_uint;\n    (*info.as_deref_mut().unwrap()).iccp_name= 0 as *mut libc::c_char;\n    (*info.as_deref_mut().unwrap()).iccp_profile= 0 as *mut libc::c_uchar;\n    (*info.as_deref_mut().unwrap()).sbit_defined= 0 as libc::c_int as libc::c_uint;\n    (*info.as_deref_mut().unwrap()).sbit_a= 0 as libc::c_int as libc::c_uint; (*info.as_deref_mut().unwrap()).sbit_b= (*info.as_deref().unwrap()).sbit_a; (*info.as_deref_mut().unwrap()).sbit_g= (*info.as_deref().unwrap()).sbit_b; (*info.as_deref_mut().unwrap()).sbit_r= (*info.as_deref().unwrap()).sbit_g;\n    LodePNGUnknownChunks_init(info.as_deref_mut());\n}","src::lodepng::lodepng_chunk_createv":"unsafe extern \"C\" fn lodepng_chunk_createv(\n    mut out: *mut ucvector,\n    mut length: libc::c_uint,\n    mut type_0: *const libc::c_char,\n    mut data: *const libc::c_uchar,\n) -> libc::c_uint {\n    let mut chunk = 0 as *mut libc::c_uchar;\n    let mut error = lodepng_chunk_init(core::ptr::addr_of_mut!(chunk), out, length, type_0);\n    if error != 0 {\n        return error;\n    }\n    lodepng_memcpy(\n        chunk.offset(8 as libc::c_int as isize) as *mut libc::c_void,\n        data as *const libc::c_void,\n        length as size_t,\n    );\n    lodepng_chunk_generate_crc(chunk);\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::generateFixedLitLenTree":"unsafe extern \"C\" fn generateFixedLitLenTree(\n    mut tree: Option<&mut HuffmanTree>,\n) -> libc::c_uint {\n    let mut i: libc::c_uint = 0;\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut bitlen = lodepng_malloc(\n        (288 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong),\n    ) as *mut libc::c_uint;\n    if bitlen.is_null() {();\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    i= 0 as libc::c_int as libc::c_uint;\n    while i <= 143 as libc::c_int as libc::c_uint {\n        *bitlen.offset(i as isize) = 8 as libc::c_int as libc::c_uint;\n        i= i.wrapping_add(1);\n    }\n    i= 144 as libc::c_int as libc::c_uint;\n    while i <= 255 as libc::c_int as libc::c_uint {\n        *bitlen.offset(i as isize) = 9 as libc::c_int as libc::c_uint;\n        i= i.wrapping_add(1);\n    }\n    i= 256 as libc::c_int as libc::c_uint;\n    while i <= 279 as libc::c_int as libc::c_uint {\n        *bitlen.offset(i as isize) = 7 as libc::c_int as libc::c_uint;\n        i= i.wrapping_add(1);\n    }\n    i= 280 as libc::c_int as libc::c_uint;\n    while i <= 287 as libc::c_int as libc::c_uint {\n        *bitlen.offset(i as isize) = 8 as libc::c_int as libc::c_uint;\n        i= i.wrapping_add(1);\n    }\n    error= HuffmanTree_makeFromLengths(\n        tree.as_deref_mut(),\n        bitlen as *const u32,\n        288 as libc::c_int as size_t,\n        15 as libc::c_int as libc::c_uint,\n    );\n    lodepng_free(bitlen as *mut libc::c_void);\n    return error;\n}","src::lodepng::lodepng_convert":"pub unsafe extern \"C\" fn lodepng_convert(\n    mut out: *mut libc::c_uchar,\n    mut in_0: *const libc::c_uchar,\n    mut mode_out: *const LodePNGColorMode,\n    mut mode_in: *const LodePNGColorMode,\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n) -> libc::c_uint {\n    let mut i: size_t = 0;\n    let mut tree = ColorTree {\n        children: [0 as *mut ColorTree; 16],\n        index: 0,\n    };\n    let mut numpixels = (w as size_t).wrapping_mul(h as size_t);\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    if (*mode_in).colortype as libc::c_uint == LCT_PALETTE as libc::c_int as libc::c_uint\n        && (*mode_in).palette.is_null()\n    {\n        return 107 as libc::c_int as libc::c_uint;\n    }\n    if lodepng_color_mode_equal(mode_out, mode_in) != 0 {\n        let mut numbytes = lodepng_get_raw_size(w, h, mode_in);\n        lodepng_memcpy(out as *mut libc::c_void, in_0 as *const libc::c_void, numbytes);\n        return 0 as libc::c_int as libc::c_uint;\n    }\n    if (*mode_out).colortype as libc::c_uint\n        == LCT_PALETTE as libc::c_int as libc::c_uint\n    {\n        let mut palettesize = (*mode_out).palettesize;\n        let mut palette: *const libc::c_uchar = (*mode_out).palette;\n        let mut palsize = (1 as libc::c_uint as size_t) << (*mode_out).bitdepth;\n        if palettesize == 0 as libc::c_int as libc::c_ulong {\n            palettesize= (*mode_in).palettesize;\n            palette= (*mode_in).palette;\n            if (*mode_in).colortype as libc::c_uint\n                == LCT_PALETTE as libc::c_int as libc::c_uint\n                && (*mode_in).bitdepth == (*mode_out).bitdepth\n            {\n                let mut numbytes_0 = lodepng_get_raw_size(w, h, mode_in);\n                lodepng_memcpy(\n                    out as *mut libc::c_void,\n                    in_0 as *const libc::c_void,\n                    numbytes_0,\n                );\n                return 0 as libc::c_int as libc::c_uint;\n            }\n        }\n        if palettesize < palsize {\n            palsize= palettesize;\n        }\n        color_tree_init(core::ptr::addr_of_mut!(tree));\n        i= 0 as libc::c_int as size_t;\n        while i != palsize {\n            let mut p: *const libc::c_uchar = &*palette\n                .offset(i.wrapping_mul(4 as libc::c_int as libc::c_ulong) as isize)\n                as *const libc::c_uchar;\n            error= color_tree_add(\n                core::ptr::addr_of_mut!(tree),\n                *p.offset(0 as libc::c_int as isize),\n                *p.offset(1 as libc::c_int as isize),\n                *p.offset(2 as libc::c_int as isize),\n                *p.offset(3 as libc::c_int as isize),\n                i as libc::c_uint,\n            );\n            if error != 0 {\n                break;\n            }\n            i= i.wrapping_add(1);\n        }\n    }\n    if error == 0 {\n        if (*mode_in).bitdepth == 16 as libc::c_int as libc::c_uint\n            && (*mode_out).bitdepth == 16 as libc::c_int as libc::c_uint\n        {\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                let mut r = 0 as libc::c_int as libc::c_ushort;\n                let mut g = 0 as libc::c_int as libc::c_ushort;\n                let mut b = 0 as libc::c_int as libc::c_ushort;\n                let mut a = 0 as libc::c_int as libc::c_ushort;\n                getPixelColorRGBA16(Some(&mut r), Some(&mut g), Some(&mut b), Some(&mut a), in_0, i, mode_in);\n                rgba16ToPixel(out, i, mode_out, r, g, b, a);\n                i= i.wrapping_add(1);\n            }\n        } else if (*mode_out).bitdepth == 8 as libc::c_int as libc::c_uint\n            && (*mode_out).colortype as libc::c_uint\n                == LCT_RGBA as libc::c_int as libc::c_uint\n        {\n            getPixelColorsRGBA8(out, numpixels, in_0, mode_in);\n        } else if (*mode_out).bitdepth == 8 as libc::c_int as libc::c_uint\n            && (*mode_out).colortype as libc::c_uint\n                == LCT_RGB as libc::c_int as libc::c_uint\n        {\n            getPixelColorsRGB8(out, numpixels, in_0, mode_in);\n        } else {\n            let mut r_0 = 0 as libc::c_int as libc::c_uchar;\n            let mut g_0 = 0 as libc::c_int as libc::c_uchar;\n            let mut b_0 = 0 as libc::c_int as libc::c_uchar;\n            let mut a_0 = 0 as libc::c_int as libc::c_uchar;\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                getPixelColorRGBA8(\n                    Some(&mut r_0),\n                    Some(&mut g_0),\n                    Some(&mut b_0),\n                    Some(&mut a_0),\n                    in_0,\n                    i,\n                    mode_in,\n                );\n                error= rgba8ToPixel(out, i, mode_out, core::ptr::addr_of_mut!(tree), r_0, g_0, b_0, a_0);\n                if error != 0 {\n                    break;\n                }\n                i= i.wrapping_add(1);\n            }\n        }\n    }\n    if (*mode_out).colortype as libc::c_uint\n        == LCT_PALETTE as libc::c_int as libc::c_uint\n    {\n        color_tree_cleanup(core::ptr::addr_of_mut!(tree));\n    }\n    return error;\n}","src::lodepng::lodepng_memset":"unsafe extern \"C\" fn lodepng_memset(\n    mut dst: *mut libc::c_void,\n    mut value: libc::c_int,\n    mut num: size_t,\n) {\n    let mut i: size_t = 0;\n    i= 0 as libc::c_int as size_t;\n    while i < num {\n        *(dst as *mut libc::c_char).offset(i as isize) = value as libc::c_char;\n        i= i.wrapping_add(1);\n    }\n}","src::lodepng::bpmnode_sort":"unsafe extern \"C\" fn bpmnode_sort(mut leaves: *mut BPMNode, mut num: size_t) {\n    let mut mem = lodepng_malloc(\n        (::std::mem::size_of::<BPMNode>() as libc::c_ulong).wrapping_mul(num),\n    ) as *mut BPMNode;\n    let mut width: size_t = 0;\n    let mut counter = 0 as libc::c_int as size_t;\n    width= 1 as libc::c_int as size_t;\n    while width < num {\n        let mut a = if counter & 1 as libc::c_int as libc::c_ulong != 0 {\n            mem\n        } else {\n            leaves\n        };\n        let mut b = if counter & 1 as libc::c_int as libc::c_ulong != 0 {\n            leaves\n        } else {\n            mem\n        };\n        let mut p: size_t = 0;\n        p= 0 as libc::c_int as size_t;\n        while p < num {\n            let mut q = if p.wrapping_add(width) > num {\n                num\n            } else {\n                p.wrapping_add(width)\n            };\n            let mut r = if p\n                .wrapping_add((2 as libc::c_int as libc::c_ulong).wrapping_mul(width))\n                > num\n            {\n                num\n            } else {\n                p.wrapping_add((2 as libc::c_int as libc::c_ulong).wrapping_mul(width))\n            };\n            let mut i = p;\n            let mut j = q;\n            let mut k: size_t = 0;\n            k= p;\n            while k < r {\n                if i < q\n                    && (j >= r\n                        || (*a.offset(i as isize)).weight\n                            <= (*a.offset(j as isize)).weight)\n                {\n                    let fresh33 = i;\n                    i= i.wrapping_add(1);\n                    *b.offset(k as isize) = *a.offset(fresh33 as isize);\n                } else {\n                    let fresh34 = j;\n                    j= j.wrapping_add(1);\n                    *b.offset(k as isize) = *a.offset(fresh34 as isize);\n                }\n                k= k.wrapping_add(1);\n            }\n            p= (p as libc::c_ulong)\n                .wrapping_add((2 as libc::c_int as libc::c_ulong).wrapping_mul(width))\n                as size_t as size_t;\n        }\n        counter= counter.wrapping_add(1);\n        width= (width as libc::c_ulong).wrapping_mul(2 as libc::c_int as libc::c_ulong)\n            as size_t as size_t;\n    }\n    if counter & 1 as libc::c_int as libc::c_ulong != 0 {\n        lodepng_memcpy(\n            leaves as *mut libc::c_void,\n            mem as *const crate::src::lodepng::BPMNode as *const libc::c_void,\n            (::std::mem::size_of::<BPMNode>() as libc::c_ulong).wrapping_mul(num),\n        );\n    }\n    lodepng_free(mem as *mut libc::c_void);\n}","src::lodepng::lodepng_decode24":"pub unsafe extern \"C\" fn lodepng_decode24(\n    mut out: Option<&mut *mut libc::c_uchar>,\n    mut w: Option<&mut libc::c_uint>,\n    mut h: Option<&mut libc::c_uint>,\n    mut in_0: *const libc::c_uchar,\n    mut insize: size_t,\n) -> libc::c_uint {\n    return lodepng_decode_memory(\n        out.as_deref_mut(),\n        w.as_deref_mut(),\n        h.as_deref_mut(),\n        in_0,\n        insize,\n        LCT_RGB,\n        8 as libc::c_int as libc::c_uint,\n    );\n}","src::lodepng::lodepng_compress_settings_init":"pub unsafe extern \"C\" fn lodepng_compress_settings_init(\n    mut settings: Option<&mut LodePNGCompressSettings>,\n) {\n    (*settings.as_deref_mut().unwrap()).btype= 2 as libc::c_int as libc::c_uint;\n    (*settings.as_deref_mut().unwrap()).use_lz77= 1 as libc::c_int as libc::c_uint;\n    (*settings.as_deref_mut().unwrap()).windowsize= 2048 as libc::c_int as libc::c_uint;\n    (*settings.as_deref_mut().unwrap()).minmatch= 3 as libc::c_int as libc::c_uint;\n    (*settings.as_deref_mut().unwrap()).nicematch= 128 as libc::c_int as libc::c_uint;\n    (*settings.as_deref_mut().unwrap()).lazymatching= 1 as libc::c_int as libc::c_uint;\n    (*settings.as_deref_mut().unwrap()).custom_zlib= None;\n    (*settings.as_deref_mut().unwrap()).custom_deflate= None;\n    (*settings.as_deref_mut().unwrap()).custom_context= 0 as *const libc::c_void;\n}","src::lodepng::uivector_push_back":"unsafe extern \"C\" fn uivector_push_back(\n    mut p: Option<&mut uivector>,\n    mut c: libc::c_uint,\n) -> libc::c_uint {\n    if {let crown_promoted_local_0 = (*p.as_deref().unwrap()).size.wrapping_add(1 as libc::c_int as libc::c_ulong);uivector_resize(p.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), crown_promoted_local_0)}\n        == 0\n    {\n        return 0 as libc::c_int as libc::c_uint;\n    }\n    *(*p.as_deref().unwrap()).data\n        .offset(\n            (*p.as_deref().unwrap()).size.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n        ) = c;\n    return 1 as libc::c_int as libc::c_uint;\n}","src::lodepng::peekBits":"unsafe extern \"C\" fn peekBits(\n    mut reader: *mut LodePNGBitReader,\n    mut nbits: size_t,\n) -> libc::c_uint {\n    return (*reader).buffer\n        & ((1 as libc::c_uint) << nbits).wrapping_sub(1 as libc::c_uint);\n}","src::lodepng::lodepng_info_cleanup":"pub unsafe extern \"C\" fn lodepng_info_cleanup(mut info: Option<&mut LodePNGInfo>) {\n    lodepng_color_mode_cleanup(Some(&mut (*info.as_deref_mut().unwrap()).color));\n    LodePNGText_cleanup(info.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()));\n    LodePNGIText_cleanup(info.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()));\n    lodepng_clear_icc(info.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()));\n    LodePNGUnknownChunks_cleanup(info.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()));\n}","src::lodepng::HuffmanTree_cleanup":"unsafe extern \"C\" fn HuffmanTree_cleanup(mut tree: Option<&mut HuffmanTree>) {\n    lodepng_free((*tree.as_deref().unwrap()).codes as *mut libc::c_void);\n    lodepng_free((*tree.as_deref().unwrap()).lengths as *mut libc::c_void);\n    lodepng_free((*tree.as_deref().unwrap()).table_len as *mut libc::c_void);\n    lodepng_free((*tree.as_deref().unwrap()).table_value as *mut libc::c_void);\n}","src::lodepng::readChunk_zTXt":"unsafe extern \"C\" fn readChunk_zTXt(\n    mut info: *mut LodePNGInfo,\n    mut decoder: *const LodePNGDecoderSettings,\n    mut data: *const libc::c_uchar,\n    mut chunkLength: size_t,\n) -> libc::c_uint {\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut zlibsettings = (*decoder).zlibsettings;\n    let mut length: libc::c_uint = 0;\n    let mut string2_begin: libc::c_uint = 0;\n    let mut key = 0 as *mut libc::c_char;\n    let mut str = 0 as *mut libc::c_uchar;\n    let mut size = 0 as libc::c_int as size_t;\n    if error == 0 {\n        length= 0 as libc::c_int as libc::c_uint;\n        while (length as libc::c_ulong) < chunkLength\n            && *data.offset(length as isize) as libc::c_int != 0 as libc::c_int\n        {\n            length= length.wrapping_add(1);\n        }\n        if length.wrapping_add(2 as libc::c_int as libc::c_uint) as libc::c_ulong\n            >= chunkLength\n        {\n            error= 75 as libc::c_int as libc::c_uint;\n        } else if length < 1 as libc::c_int as libc::c_uint\n            || length > 79 as libc::c_int as libc::c_uint\n        {\n            error= 89 as libc::c_int as libc::c_uint;\n        } else {\n            key= lodepng_malloc(\n                length.wrapping_add(1 as libc::c_int as libc::c_uint) as size_t,\n            ) as *mut libc::c_char;\n            if key.is_null() {();\n                error= 83 as libc::c_int as libc::c_uint;\n            } else {\n                lodepng_memcpy(\n                    key as *mut libc::c_void,\n                    data as *const libc::c_void,\n                    length as size_t,\n                );\n                *key.offset(length as isize) = 0 as libc::c_int as libc::c_char;\n                if *data\n                    .offset(\n                        length.wrapping_add(1 as libc::c_int as libc::c_uint) as isize,\n                    ) as libc::c_int != 0 as libc::c_int\n                {\n                    error= 72 as libc::c_int as libc::c_uint;\n                } else {\n                    string2_begin= length\n                        .wrapping_add(2 as libc::c_int as libc::c_uint);\n                    if string2_begin as libc::c_ulong > chunkLength {\n                        error= 75 as libc::c_int as libc::c_uint;\n                    } else {\n                        length= (chunkLength as libc::c_uint)\n                            .wrapping_sub(string2_begin);\n                        zlibsettings.max_output_size= (*decoder).max_text_size;\n                        error= zlib_decompress(\n                            core::ptr::addr_of_mut!(str),\n                            core::ptr::addr_of_mut!(size),\n                            0 as libc::c_int as size_t,\n                            &*data.offset(string2_begin as isize),\n                            length as size_t,\n                            core::ptr::addr_of!(zlibsettings),\n                        );\n                        if error != 0 && size > zlibsettings.max_output_size {\n                            error= 112 as libc::c_int as libc::c_uint;\n                        }\n                        if !(error != 0) {\n                            error= lodepng_add_text_sized(\n                                info,\n                                key,\n                                str as *mut libc::c_char,\n                                size,\n                            );\n                        }\n                    }\n                }\n            }\n        }\n    }\n    lodepng_free(key as *mut libc::c_void);\n    lodepng_free(str as *mut libc::c_void);\n    return error;\n}","src::lodepng::lodepng_color_mode_make":"pub unsafe extern \"C\" fn lodepng_color_mode_make(\n    mut colortype: LodePNGColorType,\n    mut bitdepth: libc::c_uint,\n) -> LodePNGColorMode {\n    let mut result = LodePNGColorMode {\n        colortype: LCT_GREY,\n        bitdepth: 0,\n        palette: 0 as *mut libc::c_uchar,\n        palettesize: 0,\n        key_defined: 0,\n        key_r: 0,\n        key_g: 0,\n        key_b: 0,\n    };\n    lodepng_color_mode_init(Some(&mut result));\n    result.colortype= colortype;\n    result.bitdepth= bitdepth;\n    return result;\n}","src::lodepng::ensureBits25":"unsafe extern \"C\" fn ensureBits25(mut reader: Option<&mut LodePNGBitReader>, mut nbits: size_t) {\n    let mut start = (*reader.as_deref().unwrap()).bp >> 3 as libc::c_uint;\n    let mut size = (*reader.as_deref().unwrap()).size;\n    if start.wrapping_add(3 as libc::c_uint as libc::c_ulong) < size {\n        (*reader.as_deref_mut().unwrap()).buffer= *(*reader.as_deref().unwrap()).data\n            .offset(start.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize)\n            as libc::c_uint\n            | (*(*reader.as_deref().unwrap()).data\n                .offset(start.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize)\n                as libc::c_uint) << 8 as libc::c_uint\n            | (*(*reader.as_deref().unwrap()).data\n                .offset(start.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize)\n                as libc::c_uint) << 16 as libc::c_uint\n            | (*(*reader.as_deref().unwrap()).data\n                .offset(start.wrapping_add(3 as libc::c_int as libc::c_ulong) as isize)\n                as libc::c_uint) << 24 as libc::c_uint;\n        (*reader.as_deref_mut().unwrap()).buffer>>= (*reader.as_deref().unwrap()).bp & 7 as libc::c_uint as libc::c_ulong;\n    } else {\n        (*reader.as_deref_mut().unwrap()).buffer= 0 as libc::c_int as libc::c_uint;\n        if start.wrapping_add(0 as libc::c_uint as libc::c_ulong) < size {\n            (*reader.as_deref_mut().unwrap()).buffer|= *(*reader.as_deref().unwrap()).data\n                    .offset(\n                        start.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint;\n        }\n        if start.wrapping_add(1 as libc::c_uint as libc::c_ulong) < size {\n            (*reader.as_deref_mut().unwrap()).buffer|= (*(*reader.as_deref().unwrap()).data\n                    .offset(\n                        start.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint) << 8 as libc::c_uint;\n        }\n        if start.wrapping_add(2 as libc::c_uint as libc::c_ulong) < size {\n            (*reader.as_deref_mut().unwrap()).buffer|= (*(*reader.as_deref().unwrap()).data\n                    .offset(\n                        start.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint) << 16 as libc::c_uint;\n        }\n        (*reader.as_deref_mut().unwrap()).buffer>>= (*reader.as_deref().unwrap()).bp & 7 as libc::c_uint as libc::c_ulong;\n    };\n}","src::lodepng::lodepng_chunk_next":"pub unsafe extern \"C\" fn lodepng_chunk_next(\n    mut chunk: *mut libc::c_uchar,\n    mut end: *mut libc::c_uchar,\n) -> *mut libc::c_uchar {\n    let mut available_size = end.offset_from(chunk) as libc::c_long as size_t;\n    if chunk >= end || available_size < 12 as libc::c_int as libc::c_ulong {\n        return end;\n    }\n    if *chunk.offset(0 as libc::c_int as isize) as libc::c_int == 0x89 as libc::c_int\n        && *chunk.offset(1 as libc::c_int as isize) as libc::c_int == 0x50 as libc::c_int\n        && *chunk.offset(2 as libc::c_int as isize) as libc::c_int == 0x4e as libc::c_int\n        && *chunk.offset(3 as libc::c_int as isize) as libc::c_int == 0x47 as libc::c_int\n        && *chunk.offset(4 as libc::c_int as isize) as libc::c_int == 0xd as libc::c_int\n        && *chunk.offset(5 as libc::c_int as isize) as libc::c_int == 0xa as libc::c_int\n        && *chunk.offset(6 as libc::c_int as isize) as libc::c_int == 0x1a as libc::c_int\n        && *chunk.offset(7 as libc::c_int as isize) as libc::c_int == 0xa as libc::c_int\n    {\n        return chunk.offset(8 as libc::c_int as isize)\n    } else {\n        let mut total_chunk_length: size_t = 0;\n        if lodepng_addofl(\n            lodepng_chunk_length(chunk) as size_t,\n            12 as libc::c_int as size_t,\n            Some(&mut total_chunk_length),\n        ) != 0\n        {\n            return end;\n        }\n        if total_chunk_length > available_size {\n            return end;\n        }\n        return chunk.offset(total_chunk_length as isize);\n    };\n}","src::lodepng::lodepng_chunk_create":"pub unsafe extern \"C\" fn lodepng_chunk_create(\n    mut out: Option<&mut *mut libc::c_uchar>,\n    mut outsize: Option<&mut size_t>,\n    mut length: libc::c_uint,\n    mut type_0: *const libc::c_char,\n    mut data: *const libc::c_uchar,\n) -> libc::c_uint {\n    let mut v = ucvector_init((*out.as_deref().unwrap()), (*outsize.as_deref().unwrap()));\n    let mut error = lodepng_chunk_createv(core::ptr::addr_of_mut!(v), length, type_0, data);\n    *out.as_deref_mut().unwrap()= v.data;\n    *outsize.as_deref_mut().unwrap()= v.size;\n    return error;\n}","src::lodepng::deflate":"unsafe extern \"C\" fn deflate(\n    mut out: *mut *mut libc::c_uchar,\n    mut outsize: *mut size_t,\n    mut in_0: *const libc::c_uchar,\n    mut insize: size_t,\n    mut settings: *const LodePNGCompressSettings,\n) -> libc::c_uint {\n    if (*settings).custom_deflate.is_some() {\n        let mut error = (*settings).custom_deflate\n            .expect(\"non-null function pointer\")(out, outsize, in_0, insize, settings);\n        return (if error != 0 { 111 as libc::c_int } else { 0 as libc::c_int })\n            as libc::c_uint;\n    } else {\n        return lodepng_deflate(out.as_mut(), outsize.as_mut(), in_0, insize, settings)\n    };\n}","src::lodepng::lodepng_compute_color_stats":"pub unsafe extern \"C\" fn lodepng_compute_color_stats(\n    mut stats: *mut LodePNGColorStats,\n    mut in_0: *const libc::c_uchar,\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n    mut mode_in: *const LodePNGColorMode,\n) -> libc::c_uint {\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut tree = ColorTree {\n        children: [0 as *mut ColorTree; 16],\n        index: 0,\n    };\n    let mut numpixels = (w as size_t).wrapping_mul(h as size_t);\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut colored_done = (if lodepng_is_greyscale_type(mode_in) != 0 {\n        1 as libc::c_int\n    } else {\n        0 as libc::c_int\n    }) as libc::c_uint;\n    let mut alpha_done = (if lodepng_can_have_alpha(mode_in) != 0 {\n        0 as libc::c_int\n    } else {\n        1 as libc::c_int\n    }) as libc::c_uint;\n    let mut numcolors_done = 0 as libc::c_int as libc::c_uint;\n    let mut bpp = lodepng_get_bpp(mode_in);\n    let mut bits_done = (if (*stats).bits == 1 as libc::c_int as libc::c_uint\n        && bpp == 1 as libc::c_int as libc::c_uint\n    {\n        1 as libc::c_int\n    } else {\n        0 as libc::c_int\n    }) as libc::c_uint;\n    let mut sixteen = 0 as libc::c_int as libc::c_uint;\n    let mut maxnumcolors = 257 as libc::c_int as libc::c_uint;\n    if bpp <= 8 as libc::c_int as libc::c_uint {\n        maxnumcolors= if (257 as libc::c_int as libc::c_uint)\n            < (*stats).numcolors.wrapping_add((1 as libc::c_uint) << bpp)\n        {\n            257 as libc::c_int as libc::c_uint\n        } else {\n            (*stats).numcolors.wrapping_add((1 as libc::c_uint) << bpp)\n        };\n    }\n    (*stats).numpixels= ((*stats).numpixels as libc::c_ulong).wrapping_add(numpixels) as size_t as size_t;\n    if (*stats).allow_palette == 0 {\n        numcolors_done= 1 as libc::c_int as libc::c_uint;\n    }\n    color_tree_init(core::ptr::addr_of_mut!(tree));\n    if (*stats).alpha != 0 {\n        alpha_done= 1 as libc::c_int as libc::c_uint;\n    }\n    if (*stats).colored != 0 {\n        colored_done= 1 as libc::c_int as libc::c_uint;\n    }\n    if (*stats).bits == 16 as libc::c_int as libc::c_uint {\n        numcolors_done= 1 as libc::c_int as libc::c_uint;\n    }\n    if (*stats).bits >= bpp {\n        bits_done= 1 as libc::c_int as libc::c_uint;\n    }\n    if (*stats).numcolors >= maxnumcolors {\n        numcolors_done= 1 as libc::c_int as libc::c_uint;\n    }\n    if numcolors_done == 0 {\n        i= 0 as libc::c_int as size_t;\n        loop {\n            if !(i < (*stats).numcolors as libc::c_ulong) {\n                current_block= 15925075030174552612;\n                break;\n            }\n            let mut color: *const libc::c_uchar = core::ptr::addr_of_mut!(*(*stats).palette.as_mut_ptr()\n                .offset(i.wrapping_mul(4 as libc::c_int as libc::c_ulong) as isize))\n                as *mut libc::c_uchar;\n            error= color_tree_add(\n                core::ptr::addr_of_mut!(tree),\n                *color.offset(0 as libc::c_int as isize),\n                *color.offset(1 as libc::c_int as isize),\n                *color.offset(2 as libc::c_int as isize),\n                *color.offset(3 as libc::c_int as isize),\n                i as libc::c_uint,\n            );\n            if error != 0 {\n                current_block= 2485031591849961683;\n                break;\n            }\n            i= i.wrapping_add(1);\n        }\n    } else {\n        current_block= 15925075030174552612;\n    }\n    match current_block {\n        15925075030174552612 => {\n            if (*mode_in).bitdepth == 16 as libc::c_int as libc::c_uint && sixteen == 0 {\n                let mut r = 0 as libc::c_int as libc::c_ushort;\n                let mut g = 0 as libc::c_int as libc::c_ushort;\n                let mut b = 0 as libc::c_int as libc::c_ushort;\n                let mut a = 0 as libc::c_int as libc::c_ushort;\n                i= 0 as libc::c_int as size_t;\n                while i != numpixels {\n                    getPixelColorRGBA16(\n                        Some(&mut r),\n                        Some(&mut g),\n                        Some(&mut b),\n                        Some(&mut a),\n                        in_0,\n                        i,\n                        mode_in,\n                    );\n                    if r as libc::c_int & 255 as libc::c_int\n                        != r as libc::c_int >> 8 as libc::c_int & 255 as libc::c_int\n                        || g as libc::c_int & 255 as libc::c_int\n                            != g as libc::c_int >> 8 as libc::c_int & 255 as libc::c_int\n                        || b as libc::c_int & 255 as libc::c_int\n                            != b as libc::c_int >> 8 as libc::c_int & 255 as libc::c_int\n                        || a as libc::c_int & 255 as libc::c_int\n                            != a as libc::c_int >> 8 as libc::c_int & 255 as libc::c_int\n                    {\n                        (*stats).bits= 16 as libc::c_int as libc::c_uint;\n                        sixteen= 1 as libc::c_int as libc::c_uint;\n                        bits_done= 1 as libc::c_int as libc::c_uint;\n                        numcolors_done= 1 as libc::c_int as libc::c_uint;\n                        break;\n                    } else {\n                        i= i.wrapping_add(1);\n                    }\n                }\n            }\n            if sixteen != 0 {\n                let mut r_0 = 0 as libc::c_int as libc::c_ushort;\n                let mut g_0 = 0 as libc::c_int as libc::c_ushort;\n                let mut b_0 = 0 as libc::c_int as libc::c_ushort;\n                let mut a_0 = 0 as libc::c_int as libc::c_ushort;\n                i= 0 as libc::c_int as size_t;\n                while i != numpixels {\n                    getPixelColorRGBA16(\n                        Some(&mut r_0),\n                        Some(&mut g_0),\n                        Some(&mut b_0),\n                        Some(&mut a_0),\n                        in_0,\n                        i,\n                        mode_in,\n                    );\n                    if colored_done == 0\n                        && (r_0 as libc::c_int != g_0 as libc::c_int\n                            || r_0 as libc::c_int != b_0 as libc::c_int)\n                    {\n                        (*stats).colored= 1 as libc::c_int as libc::c_uint;\n                        colored_done= 1 as libc::c_int as libc::c_uint;\n                    }\n                    if alpha_done == 0 {\n                        let mut matchkey = (r_0 as libc::c_int\n                            == (*stats).key_r as libc::c_int\n                            && g_0 as libc::c_int == (*stats).key_g as libc::c_int\n                            && b_0 as libc::c_int == (*stats).key_b as libc::c_int)\n                            as libc::c_int as libc::c_uint;\n                        if a_0 as libc::c_int != 65535 as libc::c_int\n                            && (a_0 as libc::c_int != 0 as libc::c_int\n                                || (*stats).key != 0 && matchkey == 0)\n                        {\n                            (*stats).alpha= 1 as libc::c_int as libc::c_uint;\n                            (*stats).key= 0 as libc::c_int as libc::c_uint;\n                            alpha_done= 1 as libc::c_int as libc::c_uint;\n                        } else if a_0 as libc::c_int == 0 as libc::c_int\n                            && (*stats).alpha == 0 && (*stats).key == 0\n                        {\n                            (*stats).key= 1 as libc::c_int as libc::c_uint;\n                            (*stats).key_r= r_0;\n                            (*stats).key_g= g_0;\n                            (*stats).key_b= b_0;\n                        } else if a_0 as libc::c_int == 65535 as libc::c_int\n                            && (*stats).key != 0 && matchkey != 0\n                        {\n                            (*stats).alpha= 1 as libc::c_int as libc::c_uint;\n                            (*stats).key= 0 as libc::c_int as libc::c_uint;\n                            alpha_done= 1 as libc::c_int as libc::c_uint;\n                        }\n                    }\n                    if alpha_done != 0 && numcolors_done != 0 && colored_done != 0\n                        && bits_done != 0\n                    {\n                        break;\n                    }\n                    i= i.wrapping_add(1);\n                }\n                if (*stats).key != 0 && (*stats).alpha == 0 {\n                    i= 0 as libc::c_int as size_t;\n                    while i != numpixels {\n                        getPixelColorRGBA16(\n                            Some(&mut r_0),\n                            Some(&mut g_0),\n                            Some(&mut b_0),\n                            Some(&mut a_0),\n                            in_0,\n                            i,\n                            mode_in,\n                        );\n                        if a_0 as libc::c_int != 0 as libc::c_int\n                            && r_0 as libc::c_int == (*stats).key_r as libc::c_int\n                            && g_0 as libc::c_int == (*stats).key_g as libc::c_int\n                            && b_0 as libc::c_int == (*stats).key_b as libc::c_int\n                        {\n                            (*stats).alpha= 1 as libc::c_int as libc::c_uint;\n                            (*stats).key= 0 as libc::c_int as libc::c_uint;\n                            alpha_done= 1 as libc::c_int as libc::c_uint;\n                        }\n                        i= i.wrapping_add(1);\n                    }\n                }\n            } else {\n                let mut r_1 = 0 as libc::c_int as libc::c_uchar;\n                let mut g_1 = 0 as libc::c_int as libc::c_uchar;\n                let mut b_1 = 0 as libc::c_int as libc::c_uchar;\n                let mut a_1 = 0 as libc::c_int as libc::c_uchar;\n                i= 0 as libc::c_int as size_t;\n                loop {\n                    if !(i != numpixels) {\n                        current_block= 17736998403848444560;\n                        break;\n                    }\n                    getPixelColorRGBA8(\n                        Some(&mut r_1),\n                        Some(&mut g_1),\n                        Some(&mut b_1),\n                        Some(&mut a_1),\n                        in_0,\n                        i,\n                        mode_in,\n                    );\n                    if bits_done == 0 && (*stats).bits < 8 as libc::c_int as libc::c_uint\n                    {\n                        let mut bits = getValueRequiredBits(r_1);\n                        if bits > (*stats).bits {\n                            (*stats).bits= bits;\n                        }\n                    }\n                    bits_done= ((*stats).bits >= bpp) as libc::c_int as libc::c_uint;\n                    if colored_done == 0\n                        && (r_1 as libc::c_int != g_1 as libc::c_int\n                            || r_1 as libc::c_int != b_1 as libc::c_int)\n                    {\n                        (*stats).colored= 1 as libc::c_int as libc::c_uint;\n                        colored_done= 1 as libc::c_int as libc::c_uint;\n                        if (*stats).bits < 8 as libc::c_int as libc::c_uint {\n                            (*stats).bits= 8 as libc::c_int as libc::c_uint;\n                        }\n                    }\n                    if alpha_done == 0 {\n                        let mut matchkey_0 = (r_1 as libc::c_int\n                            == (*stats).key_r as libc::c_int\n                            && g_1 as libc::c_int == (*stats).key_g as libc::c_int\n                            && b_1 as libc::c_int == (*stats).key_b as libc::c_int)\n                            as libc::c_int as libc::c_uint;\n                        if a_1 as libc::c_int != 255 as libc::c_int\n                            && (a_1 as libc::c_int != 0 as libc::c_int\n                                || (*stats).key != 0 && matchkey_0 == 0)\n                        {\n                            (*stats).alpha= 1 as libc::c_int as libc::c_uint;\n                            (*stats).key= 0 as libc::c_int as libc::c_uint;\n                            alpha_done= 1 as libc::c_int as libc::c_uint;\n                            if (*stats).bits < 8 as libc::c_int as libc::c_uint {\n                                (*stats).bits= 8 as libc::c_int as libc::c_uint;\n                            }\n                        } else if a_1 as libc::c_int == 0 as libc::c_int\n                            && (*stats).alpha == 0 && (*stats).key == 0\n                        {\n                            (*stats).key= 1 as libc::c_int as libc::c_uint;\n                            (*stats).key_r= r_1 as libc::c_ushort;\n                            (*stats).key_g= g_1 as libc::c_ushort;\n                            (*stats).key_b= b_1 as libc::c_ushort;\n                        } else if a_1 as libc::c_int == 255 as libc::c_int\n                            && (*stats).key != 0 && matchkey_0 != 0\n                        {\n                            (*stats).alpha= 1 as libc::c_int as libc::c_uint;\n                            (*stats).key= 0 as libc::c_int as libc::c_uint;\n                            alpha_done= 1 as libc::c_int as libc::c_uint;\n                            if (*stats).bits < 8 as libc::c_int as libc::c_uint {\n                                (*stats).bits= 8 as libc::c_int as libc::c_uint;\n                            }\n                        }\n                    }\n                    if numcolors_done == 0 {\n                        if color_tree_has(core::ptr::addr_of_mut!(tree), r_1, g_1, b_1, a_1) == 0 {\n                            error= color_tree_add(\n                                core::ptr::addr_of_mut!(tree),\n                                r_1,\n                                g_1,\n                                b_1,\n                                a_1,\n                                (*stats).numcolors,\n                            );\n                            if error != 0 {\n                                current_block= 2485031591849961683;\n                                break;\n                            }\n                            if (*stats).numcolors < 256 as libc::c_int as libc::c_uint {\n                                let mut p = (*stats).palette.as_mut_ptr();\n                                let mut n = (*stats).numcolors;\n                                *p\n                                    .offset(\n                                        n\n                                            .wrapping_mul(4 as libc::c_int as libc::c_uint)\n                                            .wrapping_add(0 as libc::c_int as libc::c_uint) as isize,\n                                    ) = r_1;\n                                *p\n                                    .offset(\n                                        n\n                                            .wrapping_mul(4 as libc::c_int as libc::c_uint)\n                                            .wrapping_add(1 as libc::c_int as libc::c_uint) as isize,\n                                    ) = g_1;\n                                *p\n                                    .offset(\n                                        n\n                                            .wrapping_mul(4 as libc::c_int as libc::c_uint)\n                                            .wrapping_add(2 as libc::c_int as libc::c_uint) as isize,\n                                    ) = b_1;\n                                *p\n                                    .offset(\n                                        n\n                                            .wrapping_mul(4 as libc::c_int as libc::c_uint)\n                                            .wrapping_add(3 as libc::c_int as libc::c_uint) as isize,\n                                    ) = a_1;\n                            }\n                            (*stats).numcolors= (*stats).numcolors.wrapping_add(1);\n                            numcolors_done= ((*stats).numcolors >= maxnumcolors)\n                                as libc::c_int as libc::c_uint;\n                        }\n                    }\n                    if alpha_done != 0 && numcolors_done != 0 && colored_done != 0\n                        && bits_done != 0\n                    {\n                        current_block= 17736998403848444560;\n                        break;\n                    }\n                    i= i.wrapping_add(1);\n                }\n                match current_block {\n                    2485031591849961683 => {}\n                    _ => {\n                        if (*stats).key != 0 && (*stats).alpha == 0 {\n                            i= 0 as libc::c_int as size_t;\n                            while i != numpixels {\n                                getPixelColorRGBA8(\n                                    Some(&mut r_1),\n                                    Some(&mut g_1),\n                                    Some(&mut b_1),\n                                    Some(&mut a_1),\n                                    in_0,\n                                    i,\n                                    mode_in,\n                                );\n                                if a_1 as libc::c_int != 0 as libc::c_int\n                                    && r_1 as libc::c_int == (*stats).key_r as libc::c_int\n                                    && g_1 as libc::c_int == (*stats).key_g as libc::c_int\n                                    && b_1 as libc::c_int == (*stats).key_b as libc::c_int\n                                {\n                                    (*stats).alpha= 1 as libc::c_int as libc::c_uint;\n                                    (*stats).key= 0 as libc::c_int as libc::c_uint;\n                                    alpha_done= 1 as libc::c_int as libc::c_uint;\n                                    if (*stats).bits < 8 as libc::c_int as libc::c_uint {\n                                        (*stats).bits= 8 as libc::c_int as libc::c_uint;\n                                    }\n                                }\n                                i= i.wrapping_add(1);\n                            }\n                        }\n                        (*stats).key_r= ((*stats).key_r as libc::c_int\n                            + (((*stats).key_r as libc::c_int) << 8 as libc::c_int))\n                            as libc::c_ushort;\n                        (*stats).key_g= ((*stats).key_g as libc::c_int\n                            + (((*stats).key_g as libc::c_int) << 8 as libc::c_int))\n                            as libc::c_ushort;\n                        (*stats).key_b= ((*stats).key_b as libc::c_int\n                            + (((*stats).key_b as libc::c_int) << 8 as libc::c_int))\n                            as libc::c_ushort;\n                    }\n                }\n            }\n        }\n        _ => {}\n    }\n    color_tree_cleanup(core::ptr::addr_of_mut!(tree));\n    return error;\n}","src::lodepng::ensureBits32":"unsafe extern \"C\" fn ensureBits32(mut reader: Option<&mut LodePNGBitReader>, mut nbits: size_t) {\n    let mut start = (*reader.as_deref().unwrap()).bp >> 3 as libc::c_uint;\n    let mut size = (*reader.as_deref().unwrap()).size;\n    if start.wrapping_add(4 as libc::c_uint as libc::c_ulong) < size {\n        (*reader.as_deref_mut().unwrap()).buffer= *(*reader.as_deref().unwrap()).data\n            .offset(start.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize)\n            as libc::c_uint\n            | (*(*reader.as_deref().unwrap()).data\n                .offset(start.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize)\n                as libc::c_uint) << 8 as libc::c_uint\n            | (*(*reader.as_deref().unwrap()).data\n                .offset(start.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize)\n                as libc::c_uint) << 16 as libc::c_uint\n            | (*(*reader.as_deref().unwrap()).data\n                .offset(start.wrapping_add(3 as libc::c_int as libc::c_ulong) as isize)\n                as libc::c_uint) << 24 as libc::c_uint;\n        (*reader.as_deref_mut().unwrap()).buffer>>= (*reader.as_deref().unwrap()).bp & 7 as libc::c_uint as libc::c_ulong;\n        (*reader.as_deref_mut().unwrap()).buffer|= ((*(*reader.as_deref().unwrap()).data\n                .offset(start.wrapping_add(4 as libc::c_int as libc::c_ulong) as isize)\n                as libc::c_uint) << 24 as libc::c_uint)\n                << (8 as libc::c_uint as libc::c_ulong)\n                    .wrapping_sub((*reader.as_deref().unwrap()).bp & 7 as libc::c_uint as libc::c_ulong);\n    } else {\n        (*reader.as_deref_mut().unwrap()).buffer= 0 as libc::c_int as libc::c_uint;\n        if start.wrapping_add(0 as libc::c_uint as libc::c_ulong) < size {\n            (*reader.as_deref_mut().unwrap()).buffer|= *(*reader.as_deref().unwrap()).data\n                    .offset(\n                        start.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint;\n        }\n        if start.wrapping_add(1 as libc::c_uint as libc::c_ulong) < size {\n            (*reader.as_deref_mut().unwrap()).buffer|= (*(*reader.as_deref().unwrap()).data\n                    .offset(\n                        start.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint) << 8 as libc::c_uint;\n        }\n        if start.wrapping_add(2 as libc::c_uint as libc::c_ulong) < size {\n            (*reader.as_deref_mut().unwrap()).buffer|= (*(*reader.as_deref().unwrap()).data\n                    .offset(\n                        start.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint) << 16 as libc::c_uint;\n        }\n        if start.wrapping_add(3 as libc::c_uint as libc::c_ulong) < size {\n            (*reader.as_deref_mut().unwrap()).buffer|= (*(*reader.as_deref().unwrap()).data\n                    .offset(\n                        start.wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint) << 24 as libc::c_uint;\n        }\n        (*reader.as_deref_mut().unwrap()).buffer>>= (*reader.as_deref().unwrap()).bp & 7 as libc::c_uint as libc::c_ulong;\n    };\n}","src::lodepng::rgba8ToPixel":"unsafe extern \"C\" fn rgba8ToPixel(\n    mut out: *mut libc::c_uchar,\n    mut i: size_t,\n    mut mode: *const LodePNGColorMode,\n    mut tree: *mut ColorTree,\n    mut r: libc::c_uchar,\n    mut g: libc::c_uchar,\n    mut b: libc::c_uchar,\n    mut a: libc::c_uchar,\n) -> libc::c_uint {\n    if (*mode).colortype as libc::c_uint == LCT_GREY as libc::c_int as libc::c_uint {\n        let mut gray = r;\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            *out.offset(i as isize) = gray;\n        } else if (*mode).bitdepth == 16 as libc::c_int as libc::c_uint {\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                ) = gray; *out\n                .offset(\n                    i\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                )  = *out\n                .offset(\n                    i\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                );\n        } else {\n            gray= (gray as libc::c_uint\n                >> (8 as libc::c_uint).wrapping_sub((*mode).bitdepth)\n                & ((1 as libc::c_uint) << (*mode).bitdepth)\n                    .wrapping_sub(1 as libc::c_uint)) as libc::c_uchar;\n            addColorBits(out, i, (*mode).bitdepth, gray as libc::c_uint);\n        }\n    } else if (*mode).colortype as libc::c_uint == LCT_RGB as libc::c_int as libc::c_uint\n    {\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(3 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                ) = r;\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(3 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                ) = g;\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(3 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                ) = b;\n        } else {\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                ) = r; *out\n                .offset(\n                    i\n                        .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                )  = *out\n                .offset(\n                    i\n                        .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                ) = g; *out\n                .offset(\n                    i\n                        .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                )  = *out\n                .offset(\n                    i\n                        .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(5 as libc::c_int as libc::c_ulong) as isize,\n                ) = b; *out\n                .offset(\n                    i\n                        .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(4 as libc::c_int as libc::c_ulong) as isize,\n                )  = *out\n                .offset(\n                    i\n                        .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(5 as libc::c_int as libc::c_ulong) as isize,\n                );\n        }\n    } else if (*mode).colortype as libc::c_uint\n        == LCT_PALETTE as libc::c_int as libc::c_uint\n    {\n        let mut index = color_tree_get(tree, r, g, b, a);\n        if index < 0 as libc::c_int {\n            return 82 as libc::c_int as libc::c_uint;\n        }\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            *out.offset(i as isize) = index as libc::c_uchar;\n        } else {\n            addColorBits(out, i, (*mode).bitdepth, index as libc::c_uint);\n        }\n    } else if (*mode).colortype as libc::c_uint\n        == LCT_GREY_ALPHA as libc::c_int as libc::c_uint\n    {\n        let mut gray_0 = r;\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                ) = gray_0;\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                ) = a;\n        } else if (*mode).bitdepth == 16 as libc::c_int as libc::c_uint {\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                ) = gray_0; *out\n                .offset(\n                    i\n                        .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                )  = *out\n                .offset(\n                    i\n                        .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                ) = a; *out\n                .offset(\n                    i\n                        .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                )  = *out\n                .offset(\n                    i\n                        .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                );\n        }\n    } else if (*mode).colortype as libc::c_uint\n        == LCT_RGBA as libc::c_int as libc::c_uint\n    {\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                ) = r;\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                ) = g;\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                ) = b;\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                ) = a;\n        } else {\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                ) = r; *out\n                .offset(\n                    i\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                )  = *out\n                .offset(\n                    i\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                ) = g; *out\n                .offset(\n                    i\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                )  = *out\n                .offset(\n                    i\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(5 as libc::c_int as libc::c_ulong) as isize,\n                ) = b; *out\n                .offset(\n                    i\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(4 as libc::c_int as libc::c_ulong) as isize,\n                )  = *out\n                .offset(\n                    i\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(5 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *out\n                .offset(\n                    i\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(7 as libc::c_int as libc::c_ulong) as isize,\n                ) = a; *out\n                .offset(\n                    i\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(6 as libc::c_int as libc::c_ulong) as isize,\n                )  = *out\n                .offset(\n                    i\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(7 as libc::c_int as libc::c_ulong) as isize,\n                );\n        }\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_add_text":"pub unsafe extern \"C\" fn lodepng_add_text(\n    mut info: *mut LodePNGInfo,\n    mut key: *const libc::c_char,\n    mut str: *const libc::c_char,\n) -> libc::c_uint {\n    return {let crown_promoted_local_0 = lodepng_strlen(str);lodepng_add_text_sized(info, key, str, crown_promoted_local_0)};\n}","src::lodepng::addChunk_tRNS":"unsafe extern \"C\" fn addChunk_tRNS(\n    mut out: *mut ucvector,\n    mut info: *const LodePNGColorMode,\n) -> libc::c_uint {\n    let mut chunk = 0 as *mut libc::c_uchar;\n    if (*info).colortype as libc::c_uint == LCT_PALETTE as libc::c_int as libc::c_uint {\n        let mut i: size_t = 0;\n        let mut amount = (*info).palettesize;\n        i= (*info).palettesize;\n        while i != 0 as libc::c_int as libc::c_ulong {\n            if *(*info).palette\n                .offset(\n                    (4 as libc::c_int as libc::c_ulong)\n                        .wrapping_mul(i.wrapping_sub(1 as libc::c_int as libc::c_ulong))\n                        .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                ) as libc::c_int != 255 as libc::c_int\n            {\n                break;\n            }\n            amount= amount.wrapping_sub(1);\n            i= i.wrapping_sub(1);\n        }\n        if amount != 0 {\n            let mut error = lodepng_chunk_init(\n                core::ptr::addr_of_mut!(chunk),\n                out,\n                amount as libc::c_uint,\n                b\"tRNS\\0\" as *const u8 as *const libc::c_char,\n            );\n            if error != 0 {\n                return error;\n            }\n            i= 0 as libc::c_int as size_t;\n            while i != amount {\n                *chunk\n                    .offset(\n                        (8 as libc::c_int as libc::c_ulong).wrapping_add(i) as isize,\n                    ) = *(*info).palette\n                    .offset(\n                        (4 as libc::c_int as libc::c_ulong)\n                            .wrapping_mul(i)\n                            .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                    );\n                i= i.wrapping_add(1);\n            }\n        }\n    } else if (*info).colortype as libc::c_uint\n        == LCT_GREY as libc::c_int as libc::c_uint\n    {\n        if (*info).key_defined != 0 {\n            let mut error_0 = lodepng_chunk_init(\n                core::ptr::addr_of_mut!(chunk),\n                out,\n                2 as libc::c_int as libc::c_uint,\n                b\"tRNS\\0\" as *const u8 as *const libc::c_char,\n            );\n            if error_0 != 0 {\n                return error_0;\n            }\n            *chunk\n                .offset(\n                    8 as libc::c_int as isize,\n                ) = ((*info).key_r >> 8 as libc::c_int) as libc::c_uchar;\n            *chunk\n                .offset(\n                    9 as libc::c_int as isize,\n                ) = ((*info).key_r & 255 as libc::c_int as libc::c_uint)\n                as libc::c_uchar;\n        }\n    } else if (*info).colortype as libc::c_uint == LCT_RGB as libc::c_int as libc::c_uint\n    {\n        if (*info).key_defined != 0 {\n            let mut error_1 = lodepng_chunk_init(\n                core::ptr::addr_of_mut!(chunk),\n                out,\n                6 as libc::c_int as libc::c_uint,\n                b\"tRNS\\0\" as *const u8 as *const libc::c_char,\n            );\n            if error_1 != 0 {\n                return error_1;\n            }\n            *chunk\n                .offset(\n                    8 as libc::c_int as isize,\n                ) = ((*info).key_r >> 8 as libc::c_int) as libc::c_uchar;\n            *chunk\n                .offset(\n                    9 as libc::c_int as isize,\n                ) = ((*info).key_r & 255 as libc::c_int as libc::c_uint)\n                as libc::c_uchar;\n            *chunk\n                .offset(\n                    10 as libc::c_int as isize,\n                ) = ((*info).key_g >> 8 as libc::c_int) as libc::c_uchar;\n            *chunk\n                .offset(\n                    11 as libc::c_int as isize,\n                ) = ((*info).key_g & 255 as libc::c_int as libc::c_uint)\n                as libc::c_uchar;\n            *chunk\n                .offset(\n                    12 as libc::c_int as isize,\n                ) = ((*info).key_b >> 8 as libc::c_int) as libc::c_uchar;\n            *chunk\n                .offset(\n                    13 as libc::c_int as isize,\n                ) = ((*info).key_b & 255 as libc::c_int as libc::c_uint)\n                as libc::c_uchar;\n        }\n    }\n    if !chunk.is_null() {\n        lodepng_chunk_generate_crc(chunk);\n    }else { (); }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::LodePNGBitWriter_init":"unsafe extern \"C\" fn LodePNGBitWriter_init(\n    mut writer: Option<&mut LodePNGBitWriter>,\n    mut data: *mut ucvector,\n) {\n    (*writer.as_deref_mut().unwrap()).data= data;\n    (*writer.as_deref_mut().unwrap()).bp= 0 as libc::c_int as libc::c_uchar;\n}","src::lodepng::auto_choose_color":"unsafe extern \"C\" fn auto_choose_color(\n    mut mode_out: *mut LodePNGColorMode,\n    mut mode_in: *const LodePNGColorMode,\n    mut stats: *const LodePNGColorStats,\n) -> libc::c_uint {\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut palettebits: libc::c_uint = 0;\n    let mut i: size_t = 0;\n    let mut n: size_t = 0;\n    let mut numpixels = (*stats).numpixels;\n    let mut palette_ok: libc::c_uint = 0;\n    let mut gray_ok: libc::c_uint = 0;\n    let mut alpha = (*stats).alpha;\n    let mut key = (*stats).key;\n    let mut bits = (*stats).bits;\n    (*mode_out).key_defined= 0 as libc::c_int as libc::c_uint;\n    if key != 0 && numpixels <= 16 as libc::c_int as libc::c_ulong {\n        alpha= 1 as libc::c_int as libc::c_uint;\n        key= 0 as libc::c_int as libc::c_uint;\n        if bits < 8 as libc::c_int as libc::c_uint {\n            bits= 8 as libc::c_int as libc::c_uint;\n        }\n    }\n    gray_ok= ((*stats).colored == 0) as libc::c_int as libc::c_uint;\n    if (*stats).allow_greyscale == 0 {\n        gray_ok= 0 as libc::c_int as libc::c_uint;\n    }\n    if gray_ok == 0 && bits < 8 as libc::c_int as libc::c_uint {\n        bits= 8 as libc::c_int as libc::c_uint;\n    }\n    n= (*stats).numcolors as size_t;\n    palettebits= (if n <= 2 as libc::c_int as libc::c_ulong {\n        1 as libc::c_int\n    } else if n <= 4 as libc::c_int as libc::c_ulong {\n        2 as libc::c_int\n    } else if n <= 16 as libc::c_int as libc::c_ulong {\n        4 as libc::c_int\n    } else {\n        8 as libc::c_int\n    }) as libc::c_uint;\n    palette_ok= (n <= 256 as libc::c_int as libc::c_ulong\n        && bits <= 8 as libc::c_int as libc::c_uint\n        && n != 0 as libc::c_int as libc::c_ulong) as libc::c_int as libc::c_uint;\n    if numpixels < n.wrapping_mul(2 as libc::c_int as libc::c_ulong) {\n        palette_ok= 0 as libc::c_int as libc::c_uint;\n    }\n    if gray_ok != 0 && alpha == 0 && bits <= palettebits {\n        palette_ok= 0 as libc::c_int as libc::c_uint;\n    }\n    if (*stats).allow_palette == 0 {\n        palette_ok= 0 as libc::c_int as libc::c_uint;\n    }\n    if palette_ok != 0 {\n        let mut p = ((*stats).palette).as_ptr();\n        lodepng_palette_clear(mode_out);\n        i= 0 as libc::c_int as size_t;\n        while i != (*stats).numcolors as libc::c_ulong {\n            error= lodepng_palette_add(\n                mode_out,\n                *p\n                    .offset(\n                        i\n                            .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                    ),\n                *p\n                    .offset(\n                        i\n                            .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                    ),\n                *p\n                    .offset(\n                        i\n                            .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                    ),\n                *p\n                    .offset(\n                        i\n                            .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                    ),\n            );\n            if error != 0 {\n                break;\n            }\n            i= i.wrapping_add(1);\n        }\n        (*mode_out).colortype= LCT_PALETTE;\n        (*mode_out).bitdepth= palettebits;\n        if (*mode_in).colortype as libc::c_uint\n            == LCT_PALETTE as libc::c_int as libc::c_uint\n            && (*mode_in).palettesize >= (*mode_out).palettesize\n            && (*mode_in).bitdepth == (*mode_out).bitdepth\n        {\n            lodepng_color_mode_cleanup(mode_out.as_mut());\n            lodepng_color_mode_copy(mode_out, mode_in);\n        }\n    } else {\n        (*mode_out).bitdepth= bits;\n        (*mode_out).colortype= (if alpha != 0 {\n            if gray_ok != 0 {\n                LCT_GREY_ALPHA as libc::c_int\n            } else {\n                LCT_RGBA as libc::c_int\n            }\n        } else if gray_ok != 0 {\n            LCT_GREY as libc::c_int\n        } else {\n            LCT_RGB as libc::c_int\n        }) as LodePNGColorType;\n        if key != 0 {\n            let mut mask_0 = ((1 as libc::c_uint) << (*mode_out).bitdepth)\n                .wrapping_sub(1 as libc::c_uint);\n            (*mode_out).key_r= (*stats).key_r as libc::c_uint & mask_0;\n            (*mode_out).key_g= (*stats).key_g as libc::c_uint & mask_0;\n            (*mode_out).key_b= (*stats).key_b as libc::c_uint & mask_0;\n            (*mode_out).key_defined= 1 as libc::c_int as libc::c_uint;\n        }\n    }\n    return error;\n}","src::lodepng::getHash":"unsafe extern \"C\" fn getHash(\n    mut data: *const libc::c_uchar,\n    mut size: size_t,\n    mut pos: size_t,\n) -> libc::c_uint {\n    let mut result = 0 as libc::c_int as libc::c_uint;\n    if pos.wrapping_add(2 as libc::c_int as libc::c_ulong) < size {\n        result^= (*data\n                .offset(pos.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize)\n                as libc::c_uint) << 0 as libc::c_uint;\n        result^= (*data\n                .offset(pos.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize)\n                as libc::c_uint) << 4 as libc::c_uint;\n        result^= (*data\n                .offset(pos.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize)\n                as libc::c_uint) << 8 as libc::c_uint;\n    } else {\n        let mut amount: size_t = 0;\n        let mut i: size_t = 0;\n        if pos >= size {\n            return 0 as libc::c_int as libc::c_uint;\n        }\n        amount= size.wrapping_sub(pos);\n        i= 0 as libc::c_int as size_t;\n        while i != amount {\n            result^= (*data.offset(pos.wrapping_add(i) as isize) as libc::c_uint)\n                    << i.wrapping_mul(8 as libc::c_uint as libc::c_ulong);\n            i= i.wrapping_add(1);\n        }\n    }\n    return result & crate::src::lodepng::HASH_BIT_MASK;\n}","src::lodepng::lodepng_error_text":"pub unsafe extern \"C\" fn lodepng_error_text(\n    mut code: libc::c_uint,\n) -> *const libc::c_char {\n    match code {\n        0 => return b\"no error, everything went ok\\0\" as *const u8 as *const libc::c_char,\n        1 => return b\"nothing done yet\\0\" as *const u8 as *const libc::c_char,\n        10 => {\n            return b\"end of input memory reached without huffman end code\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        11 => {\n            return b\"error in code tree made it jump outside of huffman tree\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        13 => {\n            return b\"problem while processing dynamic deflate block\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        14 => {\n            return b\"problem while processing dynamic deflate block\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        15 => {\n            return b\"problem while processing dynamic deflate block\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        16 => {\n            return b\"invalid code while processing dynamic deflate block\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        17 => {\n            return b\"end of out buffer memory reached while inflating\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        18 => {\n            return b\"invalid distance code while inflating\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        19 => {\n            return b\"end of out buffer memory reached while inflating\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        20 => {\n            return b\"invalid deflate block BTYPE encountered while decoding\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        21 => {\n            return b\"NLEN is not ones complement of LEN in a deflate block\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        22 => {\n            return b\"end of out buffer memory reached while inflating\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        23 => {\n            return b\"end of in buffer memory reached while inflating\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        24 => {\n            return b\"invalid FCHECK in zlib header\\0\" as *const u8 as *const libc::c_char;\n        }\n        25 => {\n            return b\"invalid compression method in zlib header\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        26 => {\n            return b\"FDICT encountered in zlib header while it's not used for PNG\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        27 => {\n            return b\"PNG file is smaller than a PNG header\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        28 => {\n            return b\"incorrect PNG signature, it's no PNG or corrupted\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        29 => {\n            return b\"first chunk is not the header chunk\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        30 => {\n            return b\"chunk length too large, chunk broken off at end of file\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        31 => {\n            return b\"illegal PNG color type or bpp\\0\" as *const u8 as *const libc::c_char;\n        }\n        32 => {\n            return b\"illegal PNG compression method\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        33 => return b\"illegal PNG filter method\\0\" as *const u8 as *const libc::c_char,\n        34 => {\n            return b\"illegal PNG interlace method\\0\" as *const u8 as *const libc::c_char;\n        }\n        35 => {\n            return b\"chunk length of a chunk is too large or the chunk too small\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        36 => {\n            return b\"illegal PNG filter type encountered\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        37 => {\n            return b\"illegal bit depth for this color type given\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        38 => {\n            return b\"the palette is too small or too big\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        39 => {\n            return b\"tRNS chunk before PLTE or has more entries than palette size\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        40 => {\n            return b\"tRNS chunk has wrong size for grayscale image\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        41 => {\n            return b\"tRNS chunk has wrong size for RGB image\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        42 => {\n            return b\"tRNS chunk appeared while it was not allowed for this color type\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        43 => {\n            return b\"bKGD chunk has wrong size for palette image\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        44 => {\n            return b\"bKGD chunk has wrong size for grayscale image\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        45 => {\n            return b\"bKGD chunk has wrong size for RGB image\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        48 => {\n            return b\"empty input buffer given to decoder. Maybe caused by non-existing file?\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        49 => {\n            return b\"jumped past memory while generating dynamic huffman tree\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        50 => {\n            return b\"jumped past memory while generating dynamic huffman tree\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        51 => {\n            return b\"jumped past memory while inflating huffman block\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        52 => {\n            return b\"jumped past memory while inflating\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        53 => return b\"size of zlib data too small\\0\" as *const u8 as *const libc::c_char,\n        54 => {\n            return b\"repeat symbol in tree while there was no value symbol yet\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        55 => {\n            return b\"jumped past tree while generating huffman tree\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        56 => {\n            return b\"given output image colortype or bitdepth not supported for color conversion\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        57 => {\n            return b\"invalid CRC encountered (checking CRC can be disabled)\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        58 => {\n            return b\"invalid ADLER32 encountered (checking ADLER32 can be disabled)\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        59 => {\n            return b\"requested color conversion not supported\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        60 => {\n            return b\"invalid window size given in the settings of the encoder (must be 0-32768)\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        61 => {\n            return b\"invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        62 => {\n            return b\"conversion from color to grayscale not supported\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        63 => {\n            return b\"length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        64 => {\n            return b\"the length of the END symbol 256 in the Huffman tree is 0\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        66 => {\n            return b\"the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        67 => {\n            return b\"the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        68 => {\n            return b\"tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        69 => {\n            return b\"unknown chunk type with 'critical' flag encountered by the decoder\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        71 => {\n            return b\"invalid interlace mode given to encoder (must be 0 or 1)\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        72 => {\n            return b\"while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        73 => return b\"invalid tIME chunk size\\0\" as *const u8 as *const libc::c_char,\n        74 => return b\"invalid pHYs chunk size\\0\" as *const u8 as *const libc::c_char,\n        75 => {\n            return b\"no null termination char found while decoding text chunk\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        76 => {\n            return b\"iTXt chunk too short to contain required bytes\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        77 => {\n            return b\"integer overflow in buffer size\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        78 => {\n            return b\"failed to open file for reading\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        79 => {\n            return b\"failed to open file for writing\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        80 => {\n            return b\"tried creating a tree of 0 symbols\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        81 => {\n            return b\"lazy matching at pos 0 is impossible\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        82 => {\n            return b\"color conversion to palette requested while a color isn't in palette, or index out of bounds\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        83 => return b\"memory allocation failed\\0\" as *const u8 as *const libc::c_char,\n        84 => {\n            return b\"given image too small to contain all pixels to be encoded\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        86 => {\n            return b\"impossible offset in lz77 encoding (internal bug)\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        87 => {\n            return b\"must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        88 => {\n            return b\"invalid filter strategy given for LodePNGEncoderSettings.filter_strategy\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        89 => {\n            return b\"text chunk keyword too short or long: must have size 1-79\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        90 => {\n            return b\"windowsize must be a power of two\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        91 => {\n            return b\"invalid decompressed idat size\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        92 => {\n            return b\"integer overflow due to too many pixels\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        93 => {\n            return b\"zero width or height is invalid\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        94 => {\n            return b\"header chunk must have a size of 13 bytes\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        95 => {\n            return b\"integer overflow with combined idat chunk size\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        96 => return b\"invalid gAMA chunk size\\0\" as *const u8 as *const libc::c_char,\n        97 => return b\"invalid cHRM chunk size\\0\" as *const u8 as *const libc::c_char,\n        98 => return b\"invalid sRGB chunk size\\0\" as *const u8 as *const libc::c_char,\n        99 => {\n            return b\"invalid sRGB rendering intent\\0\" as *const u8 as *const libc::c_char;\n        }\n        100 => {\n            return b\"invalid ICC profile color type, the PNG specification only allows RGB or GRAY\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        101 => {\n            return b\"PNG specification does not allow RGB ICC profile on gray color types and vice versa\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        102 => {\n            return b\"not allowed to set grayscale ICC profile with colored pixels by PNG specification\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        103 => {\n            return b\"invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        104 => {\n            return b\"invalid bKGD color while encoding (e.g. palette index out of range)\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        105 => {\n            return b\"integer overflow of bitsize\\0\" as *const u8 as *const libc::c_char;\n        }\n        106 => {\n            return b\"PNG file must have PLTE chunk if color type is palette\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        107 => {\n            return b\"color convert from palette mode requested without setting the palette data in it\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        108 => {\n            return b\"tried to add more than 256 values to a palette\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        109 => {\n            return b\"tried to decompress zlib or deflate data larger than desired max_output_size\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        110 => {\n            return b\"custom zlib or inflate decompression failed\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        111 => {\n            return b\"custom zlib or deflate compression failed\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        112 => {\n            return b\"compressed text unreasonably large\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        113 => {\n            return b\"ICC profile unreasonably large\\0\" as *const u8\n                as *const libc::c_char;\n        }\n        114 => {\n            return b\"sBIT chunk has wrong size for the color type of the image\\0\"\n                as *const u8 as *const libc::c_char;\n        }\n        115 => return b\"sBIT value out of range\\0\" as *const u8 as *const libc::c_char,\n        _ => {}\n    }\n    return b\"unknown error code\\0\" as *const u8 as *const libc::c_char;\n}","src::lodepng::adler32":"unsafe extern \"C\" fn adler32(\n    mut data: *const libc::c_uchar,\n    mut len: libc::c_uint,\n) -> libc::c_uint {\n    return update_adler32(1 as libc::c_uint, data, len);\n}","src::lodepng::HuffmanTree_init":"unsafe extern \"C\" fn HuffmanTree_init(mut tree: Option<&mut HuffmanTree>) {\n    (*tree.as_deref_mut().unwrap()).codes= 0 as *mut libc::c_uint;\n    (*tree.as_deref_mut().unwrap()).lengths= 0 as *mut libc::c_uint;\n    (*tree.as_deref_mut().unwrap()).table_len= 0 as *mut libc::c_uchar;\n    (*tree.as_deref_mut().unwrap()).table_value= 0 as *mut libc::c_ushort;\n}","src::lodepng::lodepng_zlib_decompressv":"unsafe extern \"C\" fn lodepng_zlib_decompressv(\n    mut out: *mut ucvector,\n    mut in_0: *const libc::c_uchar,\n    mut insize: size_t,\n    mut settings: *const LodePNGDecompressSettings,\n) -> libc::c_uint {\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut CM: libc::c_uint = 0;\n    let mut CINFO: libc::c_uint = 0;\n    let mut FDICT: libc::c_uint = 0;\n    if insize < 2 as libc::c_int as libc::c_ulong {\n        return 53 as libc::c_int as libc::c_uint;\n    }\n    if (*in_0.offset(0 as libc::c_int as isize) as libc::c_int * 256 as libc::c_int\n        + *in_0.offset(1 as libc::c_int as isize) as libc::c_int) % 31 as libc::c_int\n        != 0 as libc::c_int\n    {\n        return 24 as libc::c_int as libc::c_uint;\n    }\n    CM= (*in_0.offset(0 as libc::c_int as isize) as libc::c_int & 15 as libc::c_int)\n        as libc::c_uint;\n    CINFO= (*in_0.offset(0 as libc::c_int as isize) as libc::c_int >> 4 as libc::c_int\n        & 15 as libc::c_int) as libc::c_uint;\n    FDICT= (*in_0.offset(1 as libc::c_int as isize) as libc::c_int >> 5 as libc::c_int\n        & 1 as libc::c_int) as libc::c_uint;\n    if CM != 8 as libc::c_int as libc::c_uint || CINFO > 7 as libc::c_int as libc::c_uint\n    {\n        return 25 as libc::c_int as libc::c_uint;\n    }\n    if FDICT != 0 as libc::c_int as libc::c_uint {\n        return 26 as libc::c_int as libc::c_uint;\n    }\n    error= inflatev(\n        out,\n        in_0.offset(2 as libc::c_int as isize),\n        insize.wrapping_sub(2 as libc::c_int as libc::c_ulong),\n        settings,\n    );\n    if error != 0 {\n        return error;\n    }\n    if (*settings).ignore_adler32 == 0 {\n        let mut ADLER32 = lodepng_read32bitInt(\n            &*in_0\n                .offset(insize.wrapping_sub(4 as libc::c_int as libc::c_ulong) as isize),\n        );\n        let mut checksum = adler32((*out).data, (*out).size as libc::c_uint);\n        if checksum != ADLER32 {\n            return 58 as libc::c_int as libc::c_uint;\n        }\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_encode32":"pub unsafe extern \"C\" fn lodepng_encode32(\n    mut out: Option<&mut *mut /* owning */ libc::c_uchar>,\n    mut outsize: Option<&mut size_t>,\n    mut image: *const libc::c_uchar,\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n) -> libc::c_uint {\n    return lodepng_encode_memory(\n        out.as_deref_mut(),\n        outsize.as_deref_mut(),\n        image,\n        w,\n        h,\n        LCT_RGBA,\n        8 as libc::c_int as libc::c_uint,\n    );\n}","src::lodepng::color_tree_init":"unsafe extern \"C\" fn color_tree_init(mut tree: *mut ColorTree) {\n    lodepng_memset(\n        (*tree).children.as_mut_ptr() as *mut libc::c_void,\n        0 as libc::c_int,\n        (16 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<*mut ColorTree>() as libc::c_ulong),\n    );\n    (*tree).index= -(1 as libc::c_int);\n}","src::lodepng::run_static_initializers":"unsafe extern \"C\" fn run_static_initializers() {\n    crate::src::lodepng::mask= ((1 as libc::c_uint) << 9 as libc::c_uint).wrapping_sub(1 as libc::c_uint);\n}","src::lodepng::lodepng_chunk_type_equals":"pub unsafe extern \"C\" fn lodepng_chunk_type_equals(\n    mut chunk: *const libc::c_uchar,\n    mut type_0: *const libc::c_char,\n) -> libc::c_uchar {\n    if lodepng_strlen(type_0) != 4 as libc::c_int as libc::c_ulong {\n        return 0 as libc::c_int as libc::c_uchar;\n    }\n    return (*chunk.offset(4 as libc::c_int as isize) as libc::c_int\n        == *type_0.offset(0 as libc::c_int as isize) as libc::c_int\n        && *chunk.offset(5 as libc::c_int as isize) as libc::c_int\n            == *type_0.offset(1 as libc::c_int as isize) as libc::c_int\n        && *chunk.offset(6 as libc::c_int as isize) as libc::c_int\n            == *type_0.offset(2 as libc::c_int as isize) as libc::c_int\n        && *chunk.offset(7 as libc::c_int as isize) as libc::c_int\n            == *type_0.offset(3 as libc::c_int as isize) as libc::c_int) as libc::c_int\n        as libc::c_uchar;\n}","src::lodepng::string_cleanup":"unsafe extern \"C\" fn string_cleanup(mut out: *mut *mut /* owning */ libc::c_char) {\n    lodepng_free((*out) as *mut libc::c_void);\n    *out= 0 as *mut libc::c_char;\n}","src::lodepng::lodepng_chunk_safetocopy":"pub unsafe extern \"C\" fn lodepng_chunk_safetocopy(\n    mut chunk: *const libc::c_uchar,\n) -> libc::c_uchar {\n    return (*chunk.offset(7 as libc::c_int as isize) as libc::c_int & 32 as libc::c_int\n        != 0 as libc::c_int) as libc::c_int as libc::c_uchar;\n}","src::lodepng::lodepng_memcpy":"unsafe extern \"C\" fn lodepng_memcpy(\n    mut dst: *mut libc::c_void,\n    mut src: *const libc::c_void,\n    mut size: size_t,\n) {\n    let mut i: size_t = 0;\n    i= 0 as libc::c_int as size_t;\n    while i < size {\n        *(dst as *mut libc::c_char)\n            .offset(i as isize) = *(src as *const libc::c_char).offset(i as isize);\n        i= i.wrapping_add(1);\n    }\n}","src::lodepng::lodepng_chunk_append":"pub unsafe extern \"C\" fn lodepng_chunk_append(\n    mut out: *mut *mut libc::c_uchar,\n    mut outsize: *mut size_t,\n    mut chunk: *const libc::c_uchar,\n) -> libc::c_uint {\n    let mut i: libc::c_uint = 0;\n    let mut total_chunk_length: size_t = 0;\n    let mut new_length: size_t = 0;\n    let mut chunk_start = 0 as *mut libc::c_uchar;\n    let mut new_buffer = 0 as *mut libc::c_uchar;\n    if lodepng_addofl(\n        lodepng_chunk_length(chunk) as size_t,\n        12 as libc::c_int as size_t,\n        Some(&mut total_chunk_length),\n    ) != 0\n    {\n        return 77 as libc::c_int as libc::c_uint;\n    }\n    if lodepng_addofl((*outsize), total_chunk_length, Some(&mut new_length)) != 0 {\n        return 77 as libc::c_int as libc::c_uint;\n    }\n    new_buffer= lodepng_realloc((*out) as *mut libc::c_void, new_length)\n        as *mut libc::c_uchar;\n    if new_buffer.is_null() {();\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    *out= new_buffer;\n    *outsize= new_length;\n    chunk_start= core::ptr::addr_of_mut!(*(*out)\n        .offset(new_length.wrapping_sub(total_chunk_length) as isize))\n        as *mut libc::c_uchar;\n    i= 0 as libc::c_int as libc::c_uint;\n    while i as libc::c_ulong != total_chunk_length {\n        *chunk_start.offset(i as isize) = *chunk.offset(i as isize);\n        i= i.wrapping_add(1);\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::ucvector_resize":"unsafe extern \"C\" fn ucvector_resize(\n    mut p: Option<&mut ucvector>,\n    mut size: size_t,\n) -> libc::c_uint {\n    (*p.as_deref_mut().unwrap()).size= size;\n    return ucvector_reserve(p.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), size);\n}","src::lodepng::writeBits":"unsafe extern \"C\" fn writeBits(\n    mut writer: Option<&mut LodePNGBitWriter>,\n    mut value: libc::c_uint,\n    mut nbits: size_t,\n) {\n    if nbits == 1 as libc::c_int as libc::c_ulong {\n        if (*writer.as_deref().unwrap()).bp as libc::c_uint & 7 as libc::c_uint\n            == 0 as libc::c_int as libc::c_uint\n        {\n            if ucvector_resize(\n                (*writer.as_deref().unwrap()).data.as_mut(),\n                (*(*writer.as_deref().unwrap()).data).size.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            ) == 0\n            {\n                return;\n            }\n            *(*(*writer.as_deref().unwrap()).data).data\n                .offset(\n                    (*(*writer.as_deref().unwrap()).data).size\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                ) = 0 as libc::c_int as libc::c_uchar;\n        }\n        *(*(*writer.as_deref().unwrap()).data).data\n            .offset(\n                (*(*writer.as_deref().unwrap()).data).size.wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    as isize,\n            ) = (*(*(*writer.as_deref().unwrap()).data).data\n            .offset(\n                (*(*writer.as_deref().unwrap()).data).size.wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    as isize,\n            ) as libc::c_uint\n            | value << ((*writer.as_deref().unwrap()).bp as libc::c_uint & 7 as libc::c_uint))\n            as libc::c_uchar;\n        (*writer.as_deref_mut().unwrap()).bp= (*writer.as_deref().unwrap()).bp.wrapping_add(1);\n    } else {\n        let mut i: size_t = 0;\n        i= 0 as libc::c_int as size_t;\n        while i != nbits {\n            if (*writer.as_deref().unwrap()).bp as libc::c_uint & 7 as libc::c_uint\n                == 0 as libc::c_int as libc::c_uint\n            {\n                if ucvector_resize(\n                    (*writer.as_deref().unwrap()).data.as_mut(),\n                    (*(*writer.as_deref().unwrap()).data).size\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong),\n                ) == 0\n                {\n                    return;\n                }\n                *(*(*writer.as_deref().unwrap()).data).data\n                    .offset(\n                        (*(*writer.as_deref().unwrap()).data).size\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) = 0 as libc::c_int as libc::c_uchar;\n            }\n            *(*(*writer.as_deref().unwrap()).data).data\n                .offset(\n                    (*(*writer.as_deref().unwrap()).data).size\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                ) = (*(*(*writer.as_deref().unwrap()).data).data\n                .offset(\n                    (*(*writer.as_deref().unwrap()).data).size\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                ) as libc::c_int\n                | ((value >> i & 1 as libc::c_int as libc::c_uint) as libc::c_uchar\n                    as libc::c_int)\n                    << ((*writer.as_deref().unwrap()).bp as libc::c_uint & 7 as libc::c_uint))\n                as libc::c_uchar;\n            (*writer.as_deref_mut().unwrap()).bp= (*writer.as_deref().unwrap()).bp.wrapping_add(1);\n            i= i.wrapping_add(1);\n        }\n    };\n}","src::lodepng::HuffmanTree_makeTable":"unsafe extern \"C\" fn HuffmanTree_makeTable(mut tree: Option<&mut HuffmanTree>) -> libc::c_uint {\n    static mut headsize: libc::c_uint = (1 as libc::c_uint) << 9 as libc::c_uint;\n    let mut i: size_t = 0;\n    let mut numpresent: size_t = 0;\n    let mut pointer: size_t = 0;\n    let mut size: size_t = 0;\n    let mut maxlens = lodepng_malloc(\n        (headsize as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong),\n    ) as *mut libc::c_uint;\n    if maxlens.is_null() {();\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    lodepng_memset(\n        maxlens as *mut libc::c_void,\n        0 as libc::c_int,\n        (headsize as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong),\n    );\n    i= 0 as libc::c_int as size_t;\n    while i < (*tree.as_deref().unwrap()).numcodes as libc::c_ulong {\n        let mut symbol = *(*tree.as_deref().unwrap()).codes.offset(i as isize);\n        let mut l = *(*tree.as_deref().unwrap()).lengths.offset(i as isize);\n        let mut index: libc::c_uint = 0;\n        if !(l <= 9 as libc::c_uint) {\n            index= reverseBits(\n                symbol >> l.wrapping_sub(9 as libc::c_uint),\n                9 as libc::c_uint,\n            );\n            *maxlens\n                .offset(\n                    index as isize,\n                ) = if *maxlens.offset(index as isize) > l {\n                *maxlens.offset(index as isize)\n            } else {\n                l\n            };\n        }\n        i= i.wrapping_add(1);\n    }\n    size= headsize as size_t;\n    i= 0 as libc::c_int as size_t;\n    while i < headsize as libc::c_ulong {\n        let mut l_0 = *maxlens.offset(i as isize);\n        if l_0 > 9 as libc::c_uint {\n            size= (size as libc::c_ulong)\n                .wrapping_add(\n                    ((1 as libc::c_uint) << l_0.wrapping_sub(9 as libc::c_uint))\n                        as libc::c_ulong,\n                ) as size_t as size_t;\n        }\n        i= i.wrapping_add(1);\n    }\n    (*tree.as_deref_mut().unwrap()).table_len= lodepng_malloc(\n        size.wrapping_mul(::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong),\n    ) as *mut libc::c_uchar;\n    (*tree.as_deref_mut().unwrap()).table_value= lodepng_malloc(\n        size.wrapping_mul(::std::mem::size_of::<libc::c_ushort>() as libc::c_ulong),\n    ) as *mut libc::c_ushort;\n    if (*tree.as_deref().unwrap()).table_len.is_null() || (*tree.as_deref().unwrap()).table_value.is_null() {\n        lodepng_free(maxlens as *mut libc::c_void);\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    i= 0 as libc::c_int as size_t;\n    while i < size {\n        *(*tree.as_deref().unwrap()).table_len.offset(i as isize) = 16 as libc::c_int as libc::c_uchar;\n        i= i.wrapping_add(1);\n    }\n    pointer= headsize as size_t;\n    i= 0 as libc::c_int as size_t;\n    while i < headsize as libc::c_ulong {\n        let mut l_1 = *maxlens.offset(i as isize);\n        if !(l_1 <= 9 as libc::c_uint) {\n            *(*tree.as_deref().unwrap()).table_len.offset(i as isize) = l_1 as libc::c_uchar;\n            *(*tree.as_deref().unwrap()).table_value.offset(i as isize) = pointer as libc::c_ushort;\n            pointer= (pointer as libc::c_ulong)\n                .wrapping_add(\n                    ((1 as libc::c_uint) << l_1.wrapping_sub(9 as libc::c_uint))\n                        as libc::c_ulong,\n                ) as size_t as size_t;\n        }\n        i= i.wrapping_add(1);\n    }\n    lodepng_free(maxlens as *mut libc::c_void);\n    numpresent= 0 as libc::c_int as size_t;\n    i= 0 as libc::c_int as size_t;\n    while i < (*tree.as_deref().unwrap()).numcodes as libc::c_ulong {\n        let mut l_2 = *(*tree.as_deref().unwrap()).lengths.offset(i as isize);\n        let mut symbol_0: libc::c_uint = 0;\n        let mut reverse: libc::c_uint = 0;\n        if !(l_2 == 0 as libc::c_int as libc::c_uint) {\n            symbol_0= *(*tree.as_deref().unwrap()).codes.offset(i as isize);\n            reverse= reverseBits(symbol_0, l_2);\n            numpresent= numpresent.wrapping_add(1);\n            if l_2 <= 9 as libc::c_uint {\n                let mut num = (1 as libc::c_uint)\n                    << (9 as libc::c_uint).wrapping_sub(l_2);\n                let mut j: libc::c_uint = 0;\n                j= 0 as libc::c_int as libc::c_uint;\n                while j < num {\n                    let mut index_0 = reverse | j << l_2;\n                    if *(*tree.as_deref().unwrap()).table_len.offset(index_0 as isize) as libc::c_int\n                        != 16 as libc::c_int\n                    {\n                        return 55 as libc::c_int as libc::c_uint;\n                    }\n                    *(*tree.as_deref().unwrap()).table_len.offset(index_0 as isize) = l_2 as libc::c_uchar;\n                    *(*tree.as_deref().unwrap()).table_value\n                        .offset(index_0 as isize) = i as libc::c_ushort;\n                    j= j.wrapping_add(1);\n                }\n            } else {\n                let mut index_1 = reverse & crate::src::lodepng::mask;\n                let mut maxlen = *(*tree.as_deref().unwrap()).table_len.offset(index_1 as isize)\n                    as libc::c_uint;\n                let mut tablelen = maxlen.wrapping_sub(9 as libc::c_uint);\n                let mut start = *(*tree.as_deref().unwrap()).table_value.offset(index_1 as isize)\n                    as libc::c_uint;\n                let mut num_0 = (1 as libc::c_uint)\n                    << tablelen.wrapping_sub(l_2.wrapping_sub(9 as libc::c_uint));\n                let mut j_0: libc::c_uint = 0;\n                if maxlen < l_2 {\n                    return 55 as libc::c_int as libc::c_uint;\n                }\n                j_0= 0 as libc::c_int as libc::c_uint;\n                while j_0 < num_0 {\n                    let mut reverse2 = reverse >> 9 as libc::c_uint;\n                    let mut index2 = start\n                        .wrapping_add(\n                            reverse2 | j_0 << l_2.wrapping_sub(9 as libc::c_uint),\n                        );\n                    *(*tree.as_deref().unwrap()).table_len.offset(index2 as isize) = l_2 as libc::c_uchar;\n                    *(*tree.as_deref().unwrap()).table_value.offset(index2 as isize) = i as libc::c_ushort;\n                    j_0= j_0.wrapping_add(1);\n                }\n            }\n        }\n        i= i.wrapping_add(1);\n    }\n    if numpresent < 2 as libc::c_int as libc::c_ulong {\n        i= 0 as libc::c_int as size_t;\n        while i < size {\n            if *(*tree.as_deref().unwrap()).table_len.offset(i as isize) as libc::c_int\n                == 16 as libc::c_int\n            {\n                *(*tree.as_deref().unwrap()).table_len\n                    .offset(\n                        i as isize,\n                    ) = (if i < headsize as libc::c_ulong {\n                    1 as libc::c_int as libc::c_uint\n                } else {\n                    (9 as libc::c_uint).wrapping_add(1 as libc::c_int as libc::c_uint)\n                }) as libc::c_uchar;\n                *(*tree.as_deref().unwrap()).table_value\n                    .offset(i as isize) = 65535 as libc::c_uint as libc::c_ushort;\n            }\n            i= i.wrapping_add(1);\n        }\n    } else {\n        i= 0 as libc::c_int as size_t;\n        while i < size {\n            if *(*tree.as_deref().unwrap()).table_len.offset(i as isize) as libc::c_int\n                == 16 as libc::c_int\n            {\n                return 55 as libc::c_int as libc::c_uint;\n            }\n            i= i.wrapping_add(1);\n        }\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_filesize":"unsafe extern \"C\" fn lodepng_filesize(\n    mut filename: *const libc::c_char,\n) -> libc::c_long {\n    let mut file = 0 as *mut FILE;\n    let mut size: libc::c_long = 0;\n    file= fopen(filename, b\"rb\\0\" as *const u8 as *const libc::c_char);\n    if file.is_null() {();\n        return -(1 as libc::c_int) as libc::c_long;\n    }\n    if fseek(file, 0 as libc::c_int as libc::c_long, 2 as libc::c_int)\n        != 0 as libc::c_int\n    {\n        fclose(file);\n        return -(1 as libc::c_int) as libc::c_long;\n    }\n    size= ftell(file);\n    if size == 9223372036854775807 as libc::c_long {\n        size= -(1 as libc::c_int) as libc::c_long;\n    }\n    fclose(file);\n    return size;\n}","src::lodepng::readChunk_sRGB":"unsafe extern \"C\" fn readChunk_sRGB(\n    mut info: *mut LodePNGInfo,\n    mut data: *const libc::c_uchar,\n    mut chunkLength: size_t,\n) -> libc::c_uint {\n    if chunkLength != 1 as libc::c_int as libc::c_ulong {\n        return 98 as libc::c_int as libc::c_uint;\n    }\n    (*info).srgb_defined= 1 as libc::c_int as libc::c_uint;\n    (*info).srgb_intent= *data.offset(0 as libc::c_int as isize) as libc::c_uint;\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::addChunk_sBIT":"unsafe extern \"C\" fn addChunk_sBIT(\n    mut out: *mut ucvector,\n    mut info: *const LodePNGInfo,\n) -> libc::c_uint {\n    let mut bitdepth = if (*info).color.colortype as libc::c_uint\n        == LCT_PALETTE as libc::c_int as libc::c_uint\n    {\n        8 as libc::c_int as libc::c_uint\n    } else {\n        (*info).color.bitdepth\n    };\n    let mut chunk = 0 as *mut libc::c_uchar;\n    if (*info).color.colortype as libc::c_uint == LCT_GREY as libc::c_int as libc::c_uint\n    {\n        if (*info).sbit_r == 0 as libc::c_int as libc::c_uint\n            || (*info).sbit_r > bitdepth\n        {\n            return 115 as libc::c_int as libc::c_uint;\n        }\n        let mut error = lodepng_chunk_init(\n            core::ptr::addr_of_mut!(chunk),\n            out,\n            1 as libc::c_int as libc::c_uint,\n            b\"sBIT\\0\" as *const u8 as *const libc::c_char,\n        );\n        if error != 0 {\n            return error;\n        }\n        *chunk.offset(8 as libc::c_int as isize) = (*info).sbit_r as libc::c_uchar;\n    } else if (*info).color.colortype as libc::c_uint\n        == LCT_RGB as libc::c_int as libc::c_uint\n        || (*info).color.colortype as libc::c_uint\n            == LCT_PALETTE as libc::c_int as libc::c_uint\n    {\n        if (*info).sbit_r == 0 as libc::c_int as libc::c_uint\n            || (*info).sbit_g == 0 as libc::c_int as libc::c_uint\n            || (*info).sbit_b == 0 as libc::c_int as libc::c_uint\n        {\n            return 115 as libc::c_int as libc::c_uint;\n        }\n        if (*info).sbit_r > bitdepth || (*info).sbit_g > bitdepth\n            || (*info).sbit_b > bitdepth\n        {\n            return 115 as libc::c_int as libc::c_uint;\n        }\n        let mut error_0 = lodepng_chunk_init(\n            core::ptr::addr_of_mut!(chunk),\n            out,\n            3 as libc::c_int as libc::c_uint,\n            b\"sBIT\\0\" as *const u8 as *const libc::c_char,\n        );\n        if error_0 != 0 {\n            return error_0;\n        }\n        *chunk.offset(8 as libc::c_int as isize) = (*info).sbit_r as libc::c_uchar;\n        *chunk.offset(9 as libc::c_int as isize) = (*info).sbit_g as libc::c_uchar;\n        *chunk.offset(10 as libc::c_int as isize) = (*info).sbit_b as libc::c_uchar;\n    } else if (*info).color.colortype as libc::c_uint\n        == LCT_GREY_ALPHA as libc::c_int as libc::c_uint\n    {\n        if (*info).sbit_r == 0 as libc::c_int as libc::c_uint\n            || (*info).sbit_a == 0 as libc::c_int as libc::c_uint\n        {\n            return 115 as libc::c_int as libc::c_uint;\n        }\n        if (*info).sbit_r > bitdepth || (*info).sbit_a > bitdepth {\n            return 115 as libc::c_int as libc::c_uint;\n        }\n        let mut error_1 = lodepng_chunk_init(\n            core::ptr::addr_of_mut!(chunk),\n            out,\n            2 as libc::c_int as libc::c_uint,\n            b\"sBIT\\0\" as *const u8 as *const libc::c_char,\n        );\n        if error_1 != 0 {\n            return error_1;\n        }\n        *chunk.offset(8 as libc::c_int as isize) = (*info).sbit_r as libc::c_uchar;\n        *chunk.offset(9 as libc::c_int as isize) = (*info).sbit_a as libc::c_uchar;\n    } else if (*info).color.colortype as libc::c_uint\n        == LCT_RGBA as libc::c_int as libc::c_uint\n    {\n        if (*info).sbit_r == 0 as libc::c_int as libc::c_uint\n            || (*info).sbit_g == 0 as libc::c_int as libc::c_uint\n            || (*info).sbit_b == 0 as libc::c_int as libc::c_uint\n            || (*info).sbit_a == 0 as libc::c_int as libc::c_uint\n            || (*info).sbit_r > bitdepth || (*info).sbit_g > bitdepth\n            || (*info).sbit_b > bitdepth || (*info).sbit_a > bitdepth\n        {\n            return 115 as libc::c_int as libc::c_uint;\n        }\n        let mut error_2 = lodepng_chunk_init(\n            core::ptr::addr_of_mut!(chunk),\n            out,\n            4 as libc::c_int as libc::c_uint,\n            b\"sBIT\\0\" as *const u8 as *const libc::c_char,\n        );\n        if error_2 != 0 {\n            return error_2;\n        }\n        *chunk.offset(8 as libc::c_int as isize) = (*info).sbit_r as libc::c_uchar;\n        *chunk.offset(9 as libc::c_int as isize) = (*info).sbit_g as libc::c_uchar;\n        *chunk.offset(10 as libc::c_int as isize) = (*info).sbit_b as libc::c_uchar;\n        *chunk.offset(11 as libc::c_int as isize) = (*info).sbit_a as libc::c_uchar;\n    }\n    if !chunk.is_null() {\n        lodepng_chunk_generate_crc(chunk);\n    }else { (); }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::color_tree_add":"unsafe extern \"C\" fn color_tree_add(\n    mut tree: *mut ColorTree,\n    mut r: libc::c_uchar,\n    mut g: libc::c_uchar,\n    mut b: libc::c_uchar,\n    mut a: libc::c_uchar,\n    mut index: libc::c_uint,\n) -> libc::c_uint {\n    let mut bit: libc::c_int = 0;\n    bit= 0 as libc::c_int;\n    while bit < 8 as libc::c_int {\n        let mut i = 8 as libc::c_int * (r as libc::c_int >> bit & 1 as libc::c_int)\n            + 4 as libc::c_int * (g as libc::c_int >> bit & 1 as libc::c_int)\n            + 2 as libc::c_int * (b as libc::c_int >> bit & 1 as libc::c_int)\n            + 1 as libc::c_int * (a as libc::c_int >> bit & 1 as libc::c_int);\n        if (*tree).children[i as usize].is_null() {();\n            (*tree).children[i as usize]= lodepng_malloc(\n                ::std::mem::size_of::<ColorTree>() as libc::c_ulong,\n            ) as *mut ColorTree;\n            if (*tree).children[i as usize].is_null() {();\n                return 83 as libc::c_int as libc::c_uint;\n            }\n            color_tree_init((*tree).children[i as usize]);\n        }\n        tree= (*tree).children[i as usize];\n        bit+= 1;\n    }\n    (*tree).index= index as libc::c_int;\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_deflatev":"unsafe extern \"C\" fn lodepng_deflatev(\n    mut out: *mut ucvector,\n    mut in_0: *const libc::c_uchar,\n    mut insize: size_t,\n    mut settings: *const LodePNGCompressSettings,\n) -> libc::c_uint {\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut i: size_t = 0;\n    let mut blocksize: size_t = 0;\n    let mut numdeflateblocks: size_t = 0;\n    let mut hash = Hash {\n        head: 0 as *mut libc::c_int,\n        chain: 0 as *mut libc::c_ushort,\n        val: 0 as *mut libc::c_int,\n        headz: 0 as *mut libc::c_int,\n        chainz: 0 as *mut libc::c_ushort,\n        zeros: 0 as *mut libc::c_ushort,\n    };\n    let mut writer = LodePNGBitWriter {\n        data: 0 as *mut ucvector,\n        bp: 0,\n    };\n    LodePNGBitWriter_init(Some(&mut writer), out);\n    if (*settings).btype > 2 as libc::c_int as libc::c_uint {\n        return 61 as libc::c_int as libc::c_uint\n    } else {\n        if (*settings).btype == 0 as libc::c_int as libc::c_uint {\n            return deflateNoCompression(out, in_0, insize)\n        } else {\n            if (*settings).btype == 1 as libc::c_int as libc::c_uint {\n                blocksize= insize;\n            } else {\n                blocksize= insize\n                    .wrapping_div(8 as libc::c_uint as libc::c_ulong)\n                    .wrapping_add(8 as libc::c_int as libc::c_ulong);\n                if blocksize < 65536 as libc::c_int as libc::c_ulong {\n                    blocksize= 65536 as libc::c_int as size_t;\n                }\n                if blocksize > 262144 as libc::c_int as libc::c_ulong {\n                    blocksize= 262144 as libc::c_int as size_t;\n                }\n            }\n        }\n    }\n    numdeflateblocks= insize\n        .wrapping_add(blocksize)\n        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n        .wrapping_div(blocksize);\n    if numdeflateblocks == 0 as libc::c_int as libc::c_ulong {\n        numdeflateblocks= 1 as libc::c_int as size_t;\n    }\n    error= hash_init(Some(&mut hash), (*settings).windowsize);\n    if error == 0 {\n        i= 0 as libc::c_int as size_t;\n        while i != numdeflateblocks && error == 0 {\n            let mut final_0 = (i\n                == numdeflateblocks.wrapping_sub(1 as libc::c_int as libc::c_ulong))\n                as libc::c_int as libc::c_uint;\n            let mut start = i.wrapping_mul(blocksize);\n            let mut end = start.wrapping_add(blocksize);\n            if end > insize {\n                end= insize;\n            }\n            if (*settings).btype == 1 as libc::c_int as libc::c_uint {\n                error= deflateFixed(\n                    Some(&mut writer),\n                    Some(&mut hash),\n                    in_0,\n                    start,\n                    end,\n                    settings,\n                    final_0,\n                );\n            } else if (*settings).btype == 2 as libc::c_int as libc::c_uint {\n                error= deflateDynamic(\n                    core::ptr::addr_of_mut!(writer),\n                    core::ptr::addr_of_mut!(hash),\n                    in_0,\n                    start,\n                    end,\n                    settings,\n                    final_0,\n                );\n            }\n            i= i.wrapping_add(1);\n        }\n    }\n    hash_cleanup(Some(&mut hash));\n    return error;\n}","src::lodepng::filterScanline":"unsafe extern \"C\" fn filterScanline(\n    mut out: *mut libc::c_uchar,\n    mut scanline: *const libc::c_uchar,\n    mut prevline: *const libc::c_uchar,\n    mut length: size_t,\n    mut bytewidth: size_t,\n    mut filterType: libc::c_uchar,\n) {\n    let mut i: size_t = 0;\n    match  filterType as libc::c_int {\n        0 => {\n            i= 0 as libc::c_int as size_t;\n            while i != length {\n                *out.offset(i as isize) = *scanline.offset(i as isize);\n                i= i.wrapping_add(1);\n            }\n        }\n        1 => {\n            i= 0 as libc::c_int as size_t;\n            while i != bytewidth {\n                *out.offset(i as isize) = *scanline.offset(i as isize);\n                i= i.wrapping_add(1);\n            }\n            i= bytewidth;\n            while i < length {\n                *out\n                    .offset(\n                        i as isize,\n                    ) = (*scanline.offset(i as isize) as libc::c_int\n                    - *scanline.offset(i.wrapping_sub(bytewidth) as isize)\n                        as libc::c_int) as libc::c_uchar;\n                i= i.wrapping_add(1);\n            }\n        }\n        2 => {\n            if !prevline.is_null() {\n                i= 0 as libc::c_int as size_t;\n                while i != length {\n                    *out\n                        .offset(\n                            i as isize,\n                        ) = (*scanline.offset(i as isize) as libc::c_int\n                        - *prevline.offset(i as isize) as libc::c_int) as libc::c_uchar;\n                    i= i.wrapping_add(1);\n                }\n            } else {();\n                i= 0 as libc::c_int as size_t;\n                while i != length {\n                    *out.offset(i as isize) = *scanline.offset(i as isize);\n                    i= i.wrapping_add(1);\n                }\n            }\n        }\n        3 => {\n            if !prevline.is_null() {\n                i= 0 as libc::c_int as size_t;\n                while i != bytewidth {\n                    *out\n                        .offset(\n                            i as isize,\n                        ) = (*scanline.offset(i as isize) as libc::c_int\n                        - (*prevline.offset(i as isize) as libc::c_int\n                            >> 1 as libc::c_int)) as libc::c_uchar;\n                    i= i.wrapping_add(1);\n                }\n                i= bytewidth;\n                while i < length {\n                    *out\n                        .offset(\n                            i as isize,\n                        ) = (*scanline.offset(i as isize) as libc::c_int\n                        - (*scanline.offset(i.wrapping_sub(bytewidth) as isize)\n                            as libc::c_int + *prevline.offset(i as isize) as libc::c_int\n                            >> 1 as libc::c_int)) as libc::c_uchar;\n                    i= i.wrapping_add(1);\n                }\n            } else {();\n                i= 0 as libc::c_int as size_t;\n                while i != bytewidth {\n                    *out.offset(i as isize) = *scanline.offset(i as isize);\n                    i= i.wrapping_add(1);\n                }\n                i= bytewidth;\n                while i < length {\n                    *out\n                        .offset(\n                            i as isize,\n                        ) = (*scanline.offset(i as isize) as libc::c_int\n                        - (*scanline.offset(i.wrapping_sub(bytewidth) as isize)\n                            as libc::c_int >> 1 as libc::c_int)) as libc::c_uchar;\n                    i= i.wrapping_add(1);\n                }\n            }\n        }\n        4 => {\n            if !prevline.is_null() {\n                i= 0 as libc::c_int as size_t;\n                while i != bytewidth {\n                    *out\n                        .offset(\n                            i as isize,\n                        ) = (*scanline.offset(i as isize) as libc::c_int\n                        - *prevline.offset(i as isize) as libc::c_int) as libc::c_uchar;\n                    i= i.wrapping_add(1);\n                }\n                i= bytewidth;\n                while i < length {\n                    *out\n                        .offset(\n                            i as isize,\n                        ) = (*scanline.offset(i as isize) as libc::c_int\n                        - paethPredictor(\n                            *scanline.offset(i.wrapping_sub(bytewidth) as isize)\n                                as libc::c_short,\n                            *prevline.offset(i as isize) as libc::c_short,\n                            *prevline.offset(i.wrapping_sub(bytewidth) as isize)\n                                as libc::c_short,\n                        ) as libc::c_int) as libc::c_uchar;\n                    i= i.wrapping_add(1);\n                }\n            } else {();\n                i= 0 as libc::c_int as size_t;\n                while i != bytewidth {\n                    *out.offset(i as isize) = *scanline.offset(i as isize);\n                    i= i.wrapping_add(1);\n                }\n                i= bytewidth;\n                while i < length {\n                    *out\n                        .offset(\n                            i as isize,\n                        ) = (*scanline.offset(i as isize) as libc::c_int\n                        - *scanline.offset(i.wrapping_sub(bytewidth) as isize)\n                            as libc::c_int) as libc::c_uchar;\n                    i= i.wrapping_add(1);\n                }\n            }\n        }\n        _ => return,\n    };\n}","src::lodepng::lodepng_color_mode_init":"pub unsafe extern \"C\" fn lodepng_color_mode_init(mut info: Option<&mut LodePNGColorMode>) {\n    (*info.as_deref_mut().unwrap()).key_defined= 0 as libc::c_int as libc::c_uint;\n    (*info.as_deref_mut().unwrap()).key_b= 0 as libc::c_int as libc::c_uint; (*info.as_deref_mut().unwrap()).key_g= (*info.as_deref().unwrap()).key_b; (*info.as_deref_mut().unwrap()).key_r= (*info.as_deref().unwrap()).key_g;\n    (*info.as_deref_mut().unwrap()).colortype= LCT_RGBA;\n    (*info.as_deref_mut().unwrap()).bitdepth= 8 as libc::c_int as libc::c_uint;\n    (*info.as_deref_mut().unwrap()).palette= 0 as *mut libc::c_uchar;\n    (*info.as_deref_mut().unwrap()).palettesize= 0 as libc::c_int as size_t;\n}","src::lodepng::lodepng_decode32_file":"pub unsafe extern \"C\" fn lodepng_decode32_file(\n    mut out: Option<&mut *mut libc::c_uchar>,\n    mut w: Option<&mut libc::c_uint>,\n    mut h: Option<&mut libc::c_uint>,\n    mut filename: *const libc::c_char,\n) -> libc::c_uint {\n    return lodepng_decode_file(\n        out.as_deref_mut(),\n        w.as_deref_mut(),\n        h.as_deref_mut(),\n        filename,\n        LCT_RGBA,\n        8 as libc::c_int as libc::c_uint,\n    );\n}","src::lodepng::uivector_cleanup":"unsafe extern \"C\" fn uivector_cleanup(mut p: *mut libc::c_void) {\n    (*(p as *mut uivector)).allocsize = 0 as libc::c_int as size_t; (*(p as *mut uivector)).size  = (*(p as *mut uivector)).allocsize;\n    lodepng_free((*(p as *mut uivector)).data as *mut libc::c_void);\n    (*(p as *mut uivector)).data = 0 as *mut libc::c_uint;\n}","src::lodepng::readChunk_bKGD":"unsafe extern \"C\" fn readChunk_bKGD(\n    mut info: *mut LodePNGInfo,\n    mut data: *const libc::c_uchar,\n    mut chunkLength: size_t,\n) -> libc::c_uint {\n    if (*info).color.colortype as libc::c_uint\n        == LCT_PALETTE as libc::c_int as libc::c_uint\n    {\n        if chunkLength != 1 as libc::c_int as libc::c_ulong {\n            return 43 as libc::c_int as libc::c_uint;\n        }\n        if *data.offset(0 as libc::c_int as isize) as libc::c_ulong\n            >= (*info).color.palettesize\n        {\n            return 103 as libc::c_int as libc::c_uint;\n        }\n        (*info).background_defined= 1 as libc::c_int as libc::c_uint;\n        (*info).background_b= *data.offset(0 as libc::c_int as isize) as libc::c_uint; (*info).background_g= (*info).background_b; (*info).background_r= (*info).background_g;\n    } else if (*info).color.colortype as libc::c_uint\n        == LCT_GREY as libc::c_int as libc::c_uint\n        || (*info).color.colortype as libc::c_uint\n            == LCT_GREY_ALPHA as libc::c_int as libc::c_uint\n    {\n        if chunkLength != 2 as libc::c_int as libc::c_ulong {\n            return 44 as libc::c_int as libc::c_uint;\n        }\n        (*info).background_defined= 1 as libc::c_int as libc::c_uint;\n        (*info).background_b= (256 as libc::c_uint)\n            .wrapping_mul(*data.offset(0 as libc::c_int as isize) as libc::c_uint)\n            .wrapping_add(*data.offset(1 as libc::c_int as isize) as libc::c_uint); (*info).background_g= (*info).background_b; (*info).background_r= (*info).background_g;\n    } else if (*info).color.colortype as libc::c_uint\n        == LCT_RGB as libc::c_int as libc::c_uint\n        || (*info).color.colortype as libc::c_uint\n            == LCT_RGBA as libc::c_int as libc::c_uint\n    {\n        if chunkLength != 6 as libc::c_int as libc::c_ulong {\n            return 45 as libc::c_int as libc::c_uint;\n        }\n        (*info).background_defined= 1 as libc::c_int as libc::c_uint;\n        (*info).background_r= (256 as libc::c_uint)\n            .wrapping_mul(*data.offset(0 as libc::c_int as isize) as libc::c_uint)\n            .wrapping_add(*data.offset(1 as libc::c_int as isize) as libc::c_uint);\n        (*info).background_g= (256 as libc::c_uint)\n            .wrapping_mul(*data.offset(2 as libc::c_int as isize) as libc::c_uint)\n            .wrapping_add(*data.offset(3 as libc::c_int as isize) as libc::c_uint);\n        (*info).background_b= (256 as libc::c_uint)\n            .wrapping_mul(*data.offset(4 as libc::c_int as isize) as libc::c_uint)\n            .wrapping_add(*data.offset(5 as libc::c_int as isize) as libc::c_uint);\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::getTreeInflateDynamic":"unsafe extern \"C\" fn getTreeInflateDynamic(\n    mut tree_ll: *mut HuffmanTree,\n    mut tree_d: *mut HuffmanTree,\n    mut reader: *mut LodePNGBitReader,\n) -> libc::c_uint {\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut n: libc::c_uint = 0;\n    let mut HLIT: libc::c_uint = 0;\n    let mut HDIST: libc::c_uint = 0;\n    let mut HCLEN: libc::c_uint = 0;\n    let mut i: libc::c_uint = 0;\n    let mut bitlen_ll = 0 as *mut libc::c_uint;\n    let mut bitlen_d = 0 as *mut libc::c_uint;\n    let mut bitlen_cl = 0 as *mut libc::c_uint;\n    let mut tree_cl = HuffmanTree {\n        codes: 0 as *mut libc::c_uint,\n        lengths: 0 as *mut libc::c_uint,\n        maxbitlen: 0,\n        numcodes: 0,\n        table_len: 0 as *mut libc::c_uchar,\n        table_value: 0 as *mut libc::c_ushort,\n    };\n    if (*reader).bitsize.wrapping_sub((*reader).bp)\n        < 14 as libc::c_int as libc::c_ulong\n    {\n        return 49 as libc::c_int as libc::c_uint;\n    }\n    ensureBits17(reader.as_mut(), 14 as libc::c_int as size_t);\n    HLIT= (readBits(reader.as_mut(), 5 as libc::c_int as size_t))\n        .wrapping_add(257 as libc::c_int as libc::c_uint);\n    HDIST= (readBits(reader.as_mut(), 5 as libc::c_int as size_t))\n        .wrapping_add(1 as libc::c_int as libc::c_uint);\n    HCLEN= (readBits(reader.as_mut(), 4 as libc::c_int as size_t))\n        .wrapping_add(4 as libc::c_int as libc::c_uint);\n    bitlen_cl= lodepng_malloc(\n        (19 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong),\n    ) as *mut libc::c_uint;\n    if bitlen_cl.is_null() {();\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    HuffmanTree_init(Some(&mut tree_cl));\n    if error == 0 {\n        if lodepng_gtofl(\n            (*reader).bp,\n            HCLEN.wrapping_mul(3 as libc::c_int as libc::c_uint) as size_t,\n            (*reader).bitsize,\n        ) != 0\n        {\n            error= 50 as libc::c_int as libc::c_uint;\n        } else {\n            i= 0 as libc::c_int as libc::c_uint;\n            while i != HCLEN {\n                ensureBits9(reader.as_mut(), 3 as libc::c_int as size_t);\n                *bitlen_cl\n                    .offset(\n                        crate::src::lodepng::CLCL_ORDER[i as usize] as isize,\n                    ) = readBits(reader.as_mut(), 3 as libc::c_int as size_t);\n                i= i.wrapping_add(1);\n            }\n            i= HCLEN;\n            while i != 19 as libc::c_int as libc::c_uint {\n                *bitlen_cl\n                    .offset(\n                        crate::src::lodepng::CLCL_ORDER[i as usize] as isize,\n                    ) = 0 as libc::c_int as libc::c_uint;\n                i= i.wrapping_add(1);\n            }\n            error= HuffmanTree_makeFromLengths(\n                Some(&mut tree_cl),\n                bitlen_cl,\n                19 as libc::c_int as size_t,\n                7 as libc::c_int as libc::c_uint,\n            );\n            if !(error != 0) {\n                bitlen_ll= lodepng_malloc(\n                    (288 as libc::c_int as libc::c_ulong)\n                        .wrapping_mul(\n                            ::std::mem::size_of::<libc::c_uint>() as libc::c_ulong,\n                        ),\n                ) as *mut libc::c_uint;\n                bitlen_d= lodepng_malloc(\n                    (32 as libc::c_int as libc::c_ulong)\n                        .wrapping_mul(\n                            ::std::mem::size_of::<libc::c_uint>() as libc::c_ulong,\n                        ),\n                ) as *mut libc::c_uint;\n                if bitlen_ll.is_null() || bitlen_d.is_null() {\n                    error= 83 as libc::c_int as libc::c_uint;\n                } else {\n                    lodepng_memset(\n                        bitlen_ll as *mut libc::c_void,\n                        0 as libc::c_int,\n                        (288 as libc::c_int as libc::c_ulong)\n                            .wrapping_mul(\n                                ::std::mem::size_of::<libc::c_uint>() as libc::c_ulong,\n                            ),\n                    );\n                    lodepng_memset(\n                        bitlen_d as *mut libc::c_void,\n                        0 as libc::c_int,\n                        (32 as libc::c_int as libc::c_ulong)\n                            .wrapping_mul(\n                                ::std::mem::size_of::<libc::c_uint>() as libc::c_ulong,\n                            ),\n                    );\n                    i= 0 as libc::c_int as libc::c_uint;\n                    while i < HLIT.wrapping_add(HDIST) {\n                        let mut code: libc::c_uint = 0;\n                        ensureBits25(reader.as_mut(), 22 as libc::c_int as size_t);\n                        code= huffmanDecodeSymbol(reader.as_mut(), core::ptr::addr_of!(tree_cl));\n                        if code <= 15 as libc::c_int as libc::c_uint {\n                            if i < HLIT {\n                                *bitlen_ll.offset(i as isize) = code;\n                            } else {\n                                *bitlen_d.offset(i.wrapping_sub(HLIT) as isize) = code;\n                            }\n                            i= i.wrapping_add(1);\n                        } else if code == 16 as libc::c_int as libc::c_uint {\n                            let mut replength = 3 as libc::c_int as libc::c_uint;\n                            let mut value: libc::c_uint = 0;\n                            if i == 0 as libc::c_int as libc::c_uint {\n                                error= 54 as libc::c_int as libc::c_uint;\n                                break;\n                            } else {\n                                replength= replength\n                                    .wrapping_add(readBits(reader.as_mut(), 2 as libc::c_int as size_t));\n                                if i < HLIT.wrapping_add(1 as libc::c_int as libc::c_uint) {\n                                    value= *bitlen_ll\n                                        .offset(\n                                            i.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,\n                                        );\n                                } else {\n                                    value= *bitlen_d\n                                        .offset(\n                                            i\n                                                .wrapping_sub(HLIT)\n                                                .wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,\n                                        );\n                                }\n                                n= 0 as libc::c_int as libc::c_uint;\n                                while n < replength {\n                                    if i >= HLIT.wrapping_add(HDIST) {\n                                        error= 13 as libc::c_int as libc::c_uint;\n                                        break;\n                                    } else {\n                                        if i < HLIT {\n                                            *bitlen_ll.offset(i as isize) = value;\n                                        } else {\n                                            *bitlen_d.offset(i.wrapping_sub(HLIT) as isize) = value;\n                                        }\n                                        i= i.wrapping_add(1);\n                                        n= n.wrapping_add(1);\n                                    }\n                                }\n                            }\n                        } else if code == 17 as libc::c_int as libc::c_uint {\n                            let mut replength_0 = 3 as libc::c_int as libc::c_uint;\n                            replength_0= replength_0\n                                .wrapping_add(readBits(reader.as_mut(), 3 as libc::c_int as size_t));\n                            n= 0 as libc::c_int as libc::c_uint;\n                            while n < replength_0 {\n                                if i >= HLIT.wrapping_add(HDIST) {\n                                    error= 14 as libc::c_int as libc::c_uint;\n                                    break;\n                                } else {\n                                    if i < HLIT {\n                                        *bitlen_ll\n                                            .offset(i as isize) = 0 as libc::c_int as libc::c_uint;\n                                    } else {\n                                        *bitlen_d\n                                            .offset(\n                                                i.wrapping_sub(HLIT) as isize,\n                                            ) = 0 as libc::c_int as libc::c_uint;\n                                    }\n                                    i= i.wrapping_add(1);\n                                    n= n.wrapping_add(1);\n                                }\n                            }\n                        } else if code == 18 as libc::c_int as libc::c_uint {\n                            let mut replength_1 = 11 as libc::c_int as libc::c_uint;\n                            replength_1= replength_1\n                                .wrapping_add(readBits(reader.as_mut(), 7 as libc::c_int as size_t));\n                            n= 0 as libc::c_int as libc::c_uint;\n                            while n < replength_1 {\n                                if i >= HLIT.wrapping_add(HDIST) {\n                                    error= 15 as libc::c_int as libc::c_uint;\n                                    break;\n                                } else {\n                                    if i < HLIT {\n                                        *bitlen_ll\n                                            .offset(i as isize) = 0 as libc::c_int as libc::c_uint;\n                                    } else {\n                                        *bitlen_d\n                                            .offset(\n                                                i.wrapping_sub(HLIT) as isize,\n                                            ) = 0 as libc::c_int as libc::c_uint;\n                                    }\n                                    i= i.wrapping_add(1);\n                                    n= n.wrapping_add(1);\n                                }\n                            }\n                        } else {\n                            error= 16 as libc::c_int as libc::c_uint;\n                            break;\n                        }\n                        if !((*reader).bp > (*reader).bitsize) {\n                            continue;\n                        }\n                        error= 50 as libc::c_int as libc::c_uint;\n                        break;\n                    }\n                    if !(error != 0) {\n                        if *bitlen_ll.offset(256 as libc::c_int as isize)\n                            == 0 as libc::c_int as libc::c_uint\n                        {\n                            error= 64 as libc::c_int as libc::c_uint;\n                        } else {\n                            error= HuffmanTree_makeFromLengths(\n                                tree_ll.as_mut(),\n                                bitlen_ll,\n                                288 as libc::c_int as size_t,\n                                15 as libc::c_int as libc::c_uint,\n                            );\n                            if !(error != 0) {\n                                error= HuffmanTree_makeFromLengths(\n                                    tree_d.as_mut(),\n                                    bitlen_d,\n                                    32 as libc::c_int as size_t,\n                                    15 as libc::c_int as libc::c_uint,\n                                );\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    lodepng_free(bitlen_cl as *mut libc::c_void);\n    lodepng_free(bitlen_ll as *mut libc::c_void);\n    lodepng_free(bitlen_d as *mut libc::c_void);\n    HuffmanTree_cleanup(Some(&mut tree_cl));\n    return error;\n}","src::lodepng::addChunk_IDAT":"unsafe extern \"C\" fn addChunk_IDAT(\n    mut out: *mut ucvector,\n    mut data: *const libc::c_uchar,\n    mut datasize: size_t,\n    mut zlibsettings: *mut LodePNGCompressSettings,\n) -> libc::c_uint {\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut zlib = 0 as *mut libc::c_uchar;\n    let mut zlibsize = 0 as libc::c_int as size_t;\n    error= zlib_compress(core::ptr::addr_of_mut!(zlib), core::ptr::addr_of_mut!(zlibsize), data, datasize, zlibsettings);\n    if error == 0 {\n        error= lodepng_chunk_createv(\n            out,\n            zlibsize as libc::c_uint,\n            b\"IDAT\\0\" as *const u8 as *const libc::c_char,\n            zlib as *const u8,\n        );\n    }\n    lodepng_free(zlib as *mut libc::c_void);\n    return error;\n}","src::lodepng::lodepng_encode_file":"pub unsafe extern \"C\" fn lodepng_encode_file(\n    mut filename: *const libc::c_char,\n    mut image: *const libc::c_uchar,\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n    mut colortype: LodePNGColorType,\n    mut bitdepth: libc::c_uint,\n) -> libc::c_uint {\n    let mut buffer = 0 as *mut libc::c_uchar;\n    let mut buffersize: size_t = 0;\n    let mut error = lodepng_encode_memory(\n        Some(&mut buffer),\n        Some(&mut buffersize),\n        image,\n        w,\n        h,\n        colortype,\n        bitdepth,\n    );\n    if error == 0 {\n        error= lodepng_save_file(buffer as *const u8, buffersize, filename);\n    }\n    lodepng_free(buffer as *mut libc::c_void);\n    return error;\n}","src::lodepng::lodepng_get_bpp_lct":"unsafe extern \"C\" fn lodepng_get_bpp_lct(\n    mut colortype: LodePNGColorType,\n    mut bitdepth: libc::c_uint,\n) -> libc::c_uint {\n    return (getNumColorChannels(colortype)).wrapping_mul(bitdepth);\n}","src::lodepng::lodepng_zlib_compress":"pub unsafe extern \"C\" fn lodepng_zlib_compress(\n    mut out: Option<&mut *mut libc::c_uchar>,\n    mut outsize: Option<&mut size_t>,\n    mut in_0: *const libc::c_uchar,\n    mut insize: size_t,\n    mut settings: *const LodePNGCompressSettings,\n) -> libc::c_uint {\n    let mut i: size_t = 0;\n    let mut error: libc::c_uint = 0;\n    let mut deflatedata = 0 as *mut libc::c_uchar;\n    let mut deflatesize = 0 as libc::c_int as size_t;\n    error= deflate(core::ptr::addr_of_mut!(deflatedata), core::ptr::addr_of_mut!(deflatesize), in_0, insize, settings);\n    *out.as_deref_mut().unwrap()= 0 as *mut libc::c_uchar;\n    *outsize.as_deref_mut().unwrap()= 0 as libc::c_int as size_t;\n    if error == 0 {\n        *outsize.as_deref_mut().unwrap()= deflatesize.wrapping_add(6 as libc::c_int as libc::c_ulong);\n        *out.as_deref_mut().unwrap()= lodepng_malloc((*outsize.as_deref().unwrap())) as *mut libc::c_uchar;\n        if (*out.as_deref().unwrap()).is_null() {();\n            error= 83 as libc::c_int as libc::c_uint;\n        }\n    }\n    if error == 0 {\n        let mut ADLER32 = adler32(in_0, insize as libc::c_uint);\n        let mut CMF = 120 as libc::c_int as libc::c_uint;\n        let mut FLEVEL = 0 as libc::c_int as libc::c_uint;\n        let mut FDICT = 0 as libc::c_int as libc::c_uint;\n        let mut CMFFLG = (256 as libc::c_int as libc::c_uint)\n            .wrapping_mul(CMF)\n            .wrapping_add(FDICT.wrapping_mul(32 as libc::c_int as libc::c_uint))\n            .wrapping_add(FLEVEL.wrapping_mul(64 as libc::c_int as libc::c_uint));\n        let mut FCHECK = (31 as libc::c_int as libc::c_uint)\n            .wrapping_sub(CMFFLG.wrapping_rem(31 as libc::c_int as libc::c_uint));\n        CMFFLG= CMFFLG.wrapping_add(FCHECK);\n        *(*out.as_deref().unwrap())\n            .offset(\n                0 as libc::c_int as isize,\n            ) = (CMFFLG >> 8 as libc::c_int) as libc::c_uchar;\n        *(*out.as_deref().unwrap())\n            .offset(\n                1 as libc::c_int as isize,\n            ) = (CMFFLG & 255 as libc::c_int as libc::c_uint) as libc::c_uchar;\n        i= 0 as libc::c_int as size_t;\n        while i != deflatesize {\n            *(*out.as_deref().unwrap())\n                .offset(\n                    i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                ) = *deflatedata.offset(i as isize);\n            i= i.wrapping_add(1);\n        }\n        lodepng_set32bitInt(\n            core::ptr::addr_of_mut!(*(*out.as_deref().unwrap())\n                .offset(\n                    (*outsize.as_deref().unwrap()).wrapping_sub(4 as libc::c_int as libc::c_ulong) as isize,\n                )),\n            ADLER32,\n        );\n    }\n    lodepng_free(deflatedata as *mut libc::c_void);\n    return error;\n}","src::lodepng::LodePNGBitReader_init":"unsafe extern \"C\" fn LodePNGBitReader_init(\n    mut reader: Option<&mut LodePNGBitReader>,\n    mut data: *const libc::c_uchar,\n    mut size: size_t,\n) -> libc::c_uint {\n    let mut temp: size_t = 0;\n    (*reader.as_deref_mut().unwrap()).data= data;\n    (*reader.as_deref_mut().unwrap()).size= size;\n    if lodepng_mulofl(size, 8 as libc::c_uint as size_t, Some(&mut (*reader.as_deref_mut().unwrap()).bitsize)) != 0 {\n        return 105 as libc::c_int as libc::c_uint;\n    }\n    if lodepng_addofl((*reader.as_deref().unwrap()).bitsize, 64 as libc::c_uint as size_t, Some(&mut temp)) != 0 {\n        return 105 as libc::c_int as libc::c_uint;\n    }\n    (*reader.as_deref_mut().unwrap()).bp= 0 as libc::c_int as size_t;\n    (*reader.as_deref_mut().unwrap()).buffer= 0 as libc::c_int as libc::c_uint;\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::addChunk_gAMA":"unsafe extern \"C\" fn addChunk_gAMA(\n    mut out: *mut ucvector,\n    mut info: *const LodePNGInfo,\n) -> libc::c_uint {\n    let mut chunk = 0 as *mut libc::c_uchar;\n    let mut error = lodepng_chunk_init(\n        core::ptr::addr_of_mut!(chunk),\n        out,\n        4 as libc::c_int as libc::c_uint,\n        b\"gAMA\\0\" as *const u8 as *const libc::c_char,\n    );\n    if error != 0 {\n        return error;\n    }\n    lodepng_set32bitInt(chunk.offset(8 as libc::c_int as isize), (*info).gama_gamma);\n    lodepng_chunk_generate_crc(chunk);\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::readChunk_gAMA":"unsafe extern \"C\" fn readChunk_gAMA(\n    mut info: *mut LodePNGInfo,\n    mut data: *const libc::c_uchar,\n    mut chunkLength: size_t,\n) -> libc::c_uint {\n    if chunkLength != 4 as libc::c_int as libc::c_ulong {\n        return 96 as libc::c_int as libc::c_uint;\n    }\n    (*info).gama_defined= 1 as libc::c_int as libc::c_uint;\n    (*info).gama_gamma= (16777216 as libc::c_uint)\n        .wrapping_mul(*data.offset(0 as libc::c_int as isize) as libc::c_uint)\n        .wrapping_add(\n            (65536 as libc::c_uint)\n                .wrapping_mul(*data.offset(1 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(\n            (256 as libc::c_uint)\n                .wrapping_mul(*data.offset(2 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(*data.offset(3 as libc::c_int as isize) as libc::c_uint);\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_decode32":"pub unsafe extern \"C\" fn lodepng_decode32(\n    mut out: Option<&mut *mut libc::c_uchar>,\n    mut w: Option<&mut libc::c_uint>,\n    mut h: Option<&mut libc::c_uint>,\n    mut in_0: *const libc::c_uchar,\n    mut insize: size_t,\n) -> libc::c_uint {\n    return lodepng_decode_memory(\n        out.as_deref_mut(),\n        w.as_deref_mut(),\n        h.as_deref_mut(),\n        in_0,\n        insize,\n        LCT_RGBA,\n        8 as libc::c_int as libc::c_uint,\n    );\n}","src::lodepng::lodepng_read32bitInt":"unsafe extern \"C\" fn lodepng_read32bitInt(\n    mut buffer: *const libc::c_uchar,\n) -> libc::c_uint {\n    return (*buffer.offset(0 as libc::c_int as isize) as libc::c_uint)\n        << 24 as libc::c_uint\n        | (*buffer.offset(1 as libc::c_int as isize) as libc::c_uint)\n            << 16 as libc::c_uint\n        | (*buffer.offset(2 as libc::c_int as isize) as libc::c_uint)\n            << 8 as libc::c_uint\n        | *buffer.offset(3 as libc::c_int as isize) as libc::c_uint;\n}","src::lodepng::readChunk_PLTE":"unsafe extern \"C\" fn readChunk_PLTE(\n    mut color: *mut LodePNGColorMode,\n    mut data: *const libc::c_uchar,\n    mut chunkLength: size_t,\n) -> libc::c_uint {\n    let mut pos = 0 as libc::c_int as libc::c_uint;\n    let mut i: libc::c_uint = 0;\n    (*color).palettesize= chunkLength.wrapping_div(3 as libc::c_uint as libc::c_ulong);\n    if (*color).palettesize == 0 as libc::c_int as libc::c_ulong\n        || (*color).palettesize > 256 as libc::c_int as libc::c_ulong\n    {\n        return 38 as libc::c_int as libc::c_uint;\n    }\n    lodepng_color_mode_alloc_palette(color);\n    if (*color).palette.is_null() && (*color).palettesize != 0 {\n        (*color).palettesize= 0 as libc::c_int as size_t;\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    i= 0 as libc::c_int as libc::c_uint;\n    while i as libc::c_ulong != (*color).palettesize {\n        let fresh168 = pos;\n        pos= pos.wrapping_add(1);\n        *(*color).palette\n            .offset(\n                (4 as libc::c_int as libc::c_uint)\n                    .wrapping_mul(i)\n                    .wrapping_add(0 as libc::c_int as libc::c_uint) as isize,\n            ) = *data.offset(fresh168 as isize);\n        let fresh169 = pos;\n        pos= pos.wrapping_add(1);\n        *(*color).palette\n            .offset(\n                (4 as libc::c_int as libc::c_uint)\n                    .wrapping_mul(i)\n                    .wrapping_add(1 as libc::c_int as libc::c_uint) as isize,\n            ) = *data.offset(fresh169 as isize);\n        let fresh170 = pos;\n        pos= pos.wrapping_add(1);\n        *(*color).palette\n            .offset(\n                (4 as libc::c_int as libc::c_uint)\n                    .wrapping_mul(i)\n                    .wrapping_add(2 as libc::c_int as libc::c_uint) as isize,\n            ) = *data.offset(fresh170 as isize);\n        *(*color).palette\n            .offset(\n                (4 as libc::c_int as libc::c_uint)\n                    .wrapping_mul(i)\n                    .wrapping_add(3 as libc::c_int as libc::c_uint) as isize,\n            ) = 255 as libc::c_int as libc::c_uchar;\n        i= i.wrapping_add(1);\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::getPixelColorsRGB8":"unsafe extern \"C\" fn getPixelColorsRGB8(\n    mut buffer: *mut libc::c_uchar,\n    mut numpixels: size_t,\n    mut in_0: *const libc::c_uchar,\n    mut mode: *const LodePNGColorMode,\n) {\n    let num_channels = 3 as libc::c_int as libc::c_uint;\n    let mut i: size_t = 0;\n    if (*mode).colortype as libc::c_uint == LCT_GREY as libc::c_int as libc::c_uint {\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                *buffer.offset(2 as libc::c_int as isize) = *in_0.offset(i as isize); *buffer.offset(1 as libc::c_int as isize) = *buffer.offset(2 as libc::c_int as isize); *buffer.offset(0 as libc::c_int as isize) = *buffer.offset(1 as libc::c_int as isize);\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n        } else if (*mode).bitdepth == 16 as libc::c_int as libc::c_uint {\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                *buffer.offset(2 as libc::c_int as isize) = *in_0\n                    .offset(i.wrapping_mul(2 as libc::c_int as libc::c_ulong) as isize); *buffer.offset(1 as libc::c_int as isize) = *buffer.offset(2 as libc::c_int as isize); *buffer.offset(0 as libc::c_int as isize) = *buffer.offset(1 as libc::c_int as isize);\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n        } else {\n            let mut highest = ((1 as libc::c_uint) << (*mode).bitdepth)\n                .wrapping_sub(1 as libc::c_uint);\n            let mut j = 0 as libc::c_int as size_t;\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                let mut value = readBitsFromReversedStream(\n                    Some(&mut j),\n                    in_0,\n                    (*mode).bitdepth as size_t,\n                );\n                *buffer.offset(2 as libc::c_int as isize) = value\n                    .wrapping_mul(255 as libc::c_int as libc::c_uint)\n                    .wrapping_div(highest) as libc::c_uchar; *buffer.offset(1 as libc::c_int as isize) = *buffer.offset(2 as libc::c_int as isize); *buffer.offset(0 as libc::c_int as isize) = *buffer.offset(1 as libc::c_int as isize);\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n        }\n    } else if (*mode).colortype as libc::c_uint == LCT_RGB as libc::c_int as libc::c_uint\n    {\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            lodepng_memcpy(\n                buffer as *mut libc::c_void,\n                in_0 as *const libc::c_void,\n                numpixels.wrapping_mul(3 as libc::c_int as libc::c_ulong),\n            );\n        } else {\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                *buffer\n                    .offset(\n                        0 as libc::c_int as isize,\n                    ) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                    );\n                *buffer\n                    .offset(\n                        1 as libc::c_int as isize,\n                    ) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                    );\n                *buffer\n                    .offset(\n                        2 as libc::c_int as isize,\n                    ) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(4 as libc::c_int as libc::c_ulong) as isize,\n                    );\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n        }\n    } else if (*mode).colortype as libc::c_uint\n        == LCT_PALETTE as libc::c_int as libc::c_uint\n    {\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                let mut index = *in_0.offset(i as isize) as libc::c_uint;\n                lodepng_memcpy(\n                    buffer as *mut libc::c_void,\n                    core::ptr::addr_of_mut!(*(*mode).palette\n                        .offset(\n                            index.wrapping_mul(4 as libc::c_int as libc::c_uint) as isize,\n                        )) as *mut libc::c_uchar as *const libc::c_void,\n                    3 as libc::c_int as size_t,\n                );\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n        } else {\n            let mut j_0 = 0 as libc::c_int as size_t;\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                let mut index_0 = readBitsFromReversedStream(\n                    Some(&mut j_0),\n                    in_0,\n                    (*mode).bitdepth as size_t,\n                );\n                lodepng_memcpy(\n                    buffer as *mut libc::c_void,\n                    core::ptr::addr_of_mut!(*(*mode).palette\n                        .offset(\n                            index_0.wrapping_mul(4 as libc::c_int as libc::c_uint)\n                                as isize,\n                        )) as *mut libc::c_uchar as *const libc::c_void,\n                    3 as libc::c_int as size_t,\n                );\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n        }\n    } else if (*mode).colortype as libc::c_uint\n        == LCT_GREY_ALPHA as libc::c_int as libc::c_uint\n    {\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                *buffer.offset(2 as libc::c_int as isize) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                    ); *buffer.offset(1 as libc::c_int as isize) = *buffer.offset(2 as libc::c_int as isize); *buffer.offset(0 as libc::c_int as isize) = *buffer.offset(1 as libc::c_int as isize);\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n        } else {\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                *buffer.offset(2 as libc::c_int as isize) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                    ); *buffer.offset(1 as libc::c_int as isize) = *buffer.offset(2 as libc::c_int as isize); *buffer.offset(0 as libc::c_int as isize) = *buffer.offset(1 as libc::c_int as isize);\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n        }\n    } else if (*mode).colortype as libc::c_uint\n        == LCT_RGBA as libc::c_int as libc::c_uint\n    {\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                lodepng_memcpy(\n                    buffer as *mut libc::c_void,\n                    &*in_0\n                        .offset(\n                            i.wrapping_mul(4 as libc::c_int as libc::c_ulong) as isize,\n                        ) as *const libc::c_uchar as *const libc::c_void,\n                    3 as libc::c_int as size_t,\n                );\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n        } else {\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                *buffer\n                    .offset(\n                        0 as libc::c_int as isize,\n                    ) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                    );\n                *buffer\n                    .offset(\n                        1 as libc::c_int as isize,\n                    ) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                    );\n                *buffer\n                    .offset(\n                        2 as libc::c_int as isize,\n                    ) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(4 as libc::c_int as libc::c_ulong) as isize,\n                    );\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n        }\n    }\n}","src::lodepng::addChunk_IHDR":"unsafe extern \"C\" fn addChunk_IHDR(\n    mut out: *mut ucvector,\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n    mut colortype: LodePNGColorType,\n    mut bitdepth: libc::c_uint,\n    mut interlace_method: libc::c_uint,\n) -> libc::c_uint {\n    let mut chunk = 0 as *mut libc::c_uchar;\n    let mut data = 0 as *mut libc::c_uchar;\n    let mut error = lodepng_chunk_init(\n        core::ptr::addr_of_mut!(chunk),\n        out,\n        13 as libc::c_int as libc::c_uint,\n        b\"IHDR\\0\" as *const u8 as *const libc::c_char,\n    );\n    if error != 0 {\n        return error;\n    }\n    data= chunk.offset(8 as libc::c_int as isize);\n    lodepng_set32bitInt(data.offset(0 as libc::c_int as isize), w);\n    lodepng_set32bitInt(data.offset(4 as libc::c_int as isize), h);\n    *data.offset(8 as libc::c_int as isize) = bitdepth as libc::c_uchar;\n    *data.offset(9 as libc::c_int as isize) = colortype as libc::c_uchar;\n    *data.offset(10 as libc::c_int as isize) = 0 as libc::c_int as libc::c_uchar;\n    *data.offset(11 as libc::c_int as isize) = 0 as libc::c_int as libc::c_uchar;\n    *data.offset(12 as libc::c_int as isize) = interlace_method as libc::c_uchar;\n    lodepng_chunk_generate_crc(chunk);\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::checkColorValidity":"unsafe extern \"C\" fn checkColorValidity(\n    mut colortype: LodePNGColorType,\n    mut bd: libc::c_uint,\n) -> libc::c_uint {\n    match  colortype as libc::c_uint {\n        0 => {\n            if !(bd == 1 as libc::c_int as libc::c_uint\n                || bd == 2 as libc::c_int as libc::c_uint\n                || bd == 4 as libc::c_int as libc::c_uint\n                || bd == 8 as libc::c_int as libc::c_uint\n                || bd == 16 as libc::c_int as libc::c_uint)\n            {\n                return 37 as libc::c_int as libc::c_uint;\n            }\n        }\n        2 => {\n            if !(bd == 8 as libc::c_int as libc::c_uint\n                || bd == 16 as libc::c_int as libc::c_uint)\n            {\n                return 37 as libc::c_int as libc::c_uint;\n            }\n        }\n        3 => {\n            if !(bd == 1 as libc::c_int as libc::c_uint\n                || bd == 2 as libc::c_int as libc::c_uint\n                || bd == 4 as libc::c_int as libc::c_uint\n                || bd == 8 as libc::c_int as libc::c_uint)\n            {\n                return 37 as libc::c_int as libc::c_uint;\n            }\n        }\n        4 => {\n            if !(bd == 8 as libc::c_int as libc::c_uint\n                || bd == 16 as libc::c_int as libc::c_uint)\n            {\n                return 37 as libc::c_int as libc::c_uint;\n            }\n        }\n        6 => {\n            if !(bd == 8 as libc::c_int as libc::c_uint\n                || bd == 16 as libc::c_int as libc::c_uint)\n            {\n                return 37 as libc::c_int as libc::c_uint;\n            }\n        }\n        255 => return 31 as libc::c_int as libc::c_uint,\n        _ => return 31 as libc::c_int as libc::c_uint,\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_load_file":"pub unsafe extern \"C\" fn lodepng_load_file(\n    mut out: Option<&mut *mut libc::c_uchar>,\n    mut outsize: Option<&mut size_t>,\n    mut filename: *const libc::c_char,\n) -> libc::c_uint {\n    let mut size = lodepng_filesize(filename);\n    if size < 0 as libc::c_int as libc::c_long {\n        return 78 as libc::c_int as libc::c_uint;\n    }\n    *outsize.as_deref_mut().unwrap()= size as size_t;\n    *out.as_deref_mut().unwrap()= lodepng_malloc(size as size_t) as *mut libc::c_uchar;\n    if (*out.as_deref().unwrap()).is_null() && size > 0 as libc::c_int as libc::c_long {\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    return lodepng_buffer_file((*out.as_deref().unwrap()), size as size_t, filename);\n}","src::lodepng::hash_init":"unsafe extern \"C\" fn hash_init(\n    mut hash: Option<&mut Hash>,\n    mut windowsize: libc::c_uint,\n) -> libc::c_uint {\n    let mut i: libc::c_uint = 0;\n    (*hash.as_deref_mut().unwrap()).head= lodepng_malloc(\n        (::std::mem::size_of::<libc::c_int>() as libc::c_ulong)\n            .wrapping_mul(crate::src::lodepng::HASH_NUM_VALUES as libc::c_ulong),\n    ) as *mut libc::c_int;\n    (*hash.as_deref_mut().unwrap()).val= lodepng_malloc(\n        (::std::mem::size_of::<libc::c_int>() as libc::c_ulong)\n            .wrapping_mul(windowsize as libc::c_ulong),\n    ) as *mut libc::c_int;\n    (*hash.as_deref_mut().unwrap()).chain= lodepng_malloc(\n        (::std::mem::size_of::<libc::c_ushort>() as libc::c_ulong)\n            .wrapping_mul(windowsize as libc::c_ulong),\n    ) as *mut libc::c_ushort;\n    (*hash.as_deref_mut().unwrap()).zeros= lodepng_malloc(\n        (::std::mem::size_of::<libc::c_ushort>() as libc::c_ulong)\n            .wrapping_mul(windowsize as libc::c_ulong),\n    ) as *mut libc::c_ushort;\n    (*hash.as_deref_mut().unwrap()).headz= lodepng_malloc(\n        (::std::mem::size_of::<libc::c_int>() as libc::c_ulong)\n            .wrapping_mul(\n                crate::src::lodepng::MAX_SUPPORTED_DEFLATE_LENGTH\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong),\n            ),\n    ) as *mut libc::c_int;\n    (*hash.as_deref_mut().unwrap()).chainz= lodepng_malloc(\n        (::std::mem::size_of::<libc::c_ushort>() as libc::c_ulong)\n            .wrapping_mul(windowsize as libc::c_ulong),\n    ) as *mut libc::c_ushort;\n    if (*hash.as_deref().unwrap()).head.is_null() || (*hash.as_deref().unwrap()).chain.is_null() || (*hash.as_deref().unwrap()).val.is_null()\n        || (*hash.as_deref().unwrap()).headz.is_null() || (*hash.as_deref().unwrap()).chainz.is_null()\n        || (*hash.as_deref().unwrap()).zeros.is_null()\n    {\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    i= 0 as libc::c_int as libc::c_uint;\n    while i != crate::src::lodepng::HASH_NUM_VALUES {\n        *(*hash.as_deref().unwrap()).head.offset(i as isize) = -(1 as libc::c_int);\n        i= i.wrapping_add(1);\n    }\n    i= 0 as libc::c_int as libc::c_uint;\n    while i != windowsize {\n        *(*hash.as_deref().unwrap()).val.offset(i as isize) = -(1 as libc::c_int);\n        i= i.wrapping_add(1);\n    }\n    i= 0 as libc::c_int as libc::c_uint;\n    while i != windowsize {\n        *(*hash.as_deref().unwrap()).chain.offset(i as isize) = i as libc::c_ushort;\n        i= i.wrapping_add(1);\n    }\n    i= 0 as libc::c_int as libc::c_uint;\n    while i as libc::c_ulong <= crate::src::lodepng::MAX_SUPPORTED_DEFLATE_LENGTH {\n        *(*hash.as_deref().unwrap()).headz.offset(i as isize) = -(1 as libc::c_int);\n        i= i.wrapping_add(1);\n    }\n    i= 0 as libc::c_int as libc::c_uint;\n    while i != windowsize {\n        *(*hash.as_deref().unwrap()).chainz.offset(i as isize) = i as libc::c_ushort;\n        i= i.wrapping_add(1);\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_gtofl":"unsafe extern \"C\" fn lodepng_gtofl(\n    mut a: size_t,\n    mut b: size_t,\n    mut c: size_t,\n) -> libc::c_int {\n    let mut d: size_t = 0;\n    if lodepng_addofl(a, b, Some(&mut d)) != 0 {\n        return 1 as libc::c_int;\n    }\n    return (d > c) as libc::c_int;\n}","src::lodepng::readBits":"unsafe extern \"C\" fn readBits(\n    mut reader: Option<&mut LodePNGBitReader>,\n    mut nbits: size_t,\n) -> libc::c_uint {\n    let mut result = peekBits(reader.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), nbits);\n    advanceBits(reader.as_deref_mut(), nbits);\n    return result;\n}","src::lodepng::lodepng_chunk_data":"pub unsafe extern \"C\" fn lodepng_chunk_data(\n    mut chunk: *mut libc::c_uchar,\n) -> *mut libc::c_uchar {\n    return core::ptr::addr_of_mut!(*chunk.offset(8 as libc::c_int as isize)) as *mut libc::c_uchar;\n}","src::lodepng::lodepng_decode_memory":"pub unsafe extern \"C\" fn lodepng_decode_memory(\n    mut out: Option<&mut *mut libc::c_uchar>,\n    mut w: Option<&mut libc::c_uint>,\n    mut h: Option<&mut libc::c_uint>,\n    mut in_0: *const libc::c_uchar,\n    mut insize: size_t,\n    mut colortype: LodePNGColorType,\n    mut bitdepth: libc::c_uint,\n) -> libc::c_uint {\n    let mut error: libc::c_uint = 0;\n    let mut state = LodePNGState {\n        decoder: LodePNGDecoderSettings {\n            zlibsettings: LodePNGDecompressSettings {\n                ignore_adler32: 0,\n                ignore_nlen: 0,\n                max_output_size: 0,\n                custom_zlib: None,\n                custom_inflate: None,\n                custom_context: 0 as *const libc::c_void,\n            },\n            ignore_crc: 0,\n            ignore_critical: 0,\n            ignore_end: 0,\n            color_convert: 0,\n            read_text_chunks: 0,\n            remember_unknown_chunks: 0,\n            max_text_size: 0,\n            max_icc_size: 0,\n        },\n        encoder: LodePNGEncoderSettings {\n            zlibsettings: LodePNGCompressSettings {\n                btype: 0,\n                use_lz77: 0,\n                windowsize: 0,\n                minmatch: 0,\n                nicematch: 0,\n                lazymatching: 0,\n                custom_zlib: None,\n                custom_deflate: None,\n                custom_context: 0 as *const libc::c_void,\n            },\n            auto_convert: 0,\n            filter_palette_zero: 0,\n            filter_strategy: LFS_ZERO,\n            predefined_filters: 0 as *const libc::c_uchar,\n            force_palette: 0,\n            add_id: 0,\n            text_compression: 0,\n        },\n        info_raw: LodePNGColorMode {\n            colortype: LCT_GREY,\n            bitdepth: 0,\n            palette: 0 as *mut libc::c_uchar,\n            palettesize: 0,\n            key_defined: 0,\n            key_r: 0,\n            key_g: 0,\n            key_b: 0,\n        },\n        info_png: LodePNGInfo {\n            compression_method: 0,\n            filter_method: 0,\n            interlace_method: 0,\n            color: LodePNGColorMode {\n                colortype: LCT_GREY,\n                bitdepth: 0,\n                palette: 0 as *mut libc::c_uchar,\n                palettesize: 0,\n                key_defined: 0,\n                key_r: 0,\n                key_g: 0,\n                key_b: 0,\n            },\n            background_defined: 0,\n            background_r: 0,\n            background_g: 0,\n            background_b: 0,\n            text_num: 0,\n            text_keys: 0 as *mut *mut libc::c_char,\n            text_strings: 0 as *mut *mut libc::c_char,\n            itext_num: 0,\n            itext_keys: 0 as *mut *mut libc::c_char,\n            itext_langtags: 0 as *mut *mut libc::c_char,\n            itext_transkeys: 0 as *mut *mut libc::c_char,\n            itext_strings: 0 as *mut *mut libc::c_char,\n            time_defined: 0,\n            time: LodePNGTime {\n                year: 0,\n                month: 0,\n                day: 0,\n                hour: 0,\n                minute: 0,\n                second: 0,\n            },\n            phys_defined: 0,\n            phys_x: 0,\n            phys_y: 0,\n            phys_unit: 0,\n            gama_defined: 0,\n            gama_gamma: 0,\n            chrm_defined: 0,\n            chrm_white_x: 0,\n            chrm_white_y: 0,\n            chrm_red_x: 0,\n            chrm_red_y: 0,\n            chrm_green_x: 0,\n            chrm_green_y: 0,\n            chrm_blue_x: 0,\n            chrm_blue_y: 0,\n            srgb_defined: 0,\n            srgb_intent: 0,\n            iccp_defined: 0,\n            iccp_name: 0 as *mut libc::c_char,\n            iccp_profile: 0 as *mut libc::c_uchar,\n            iccp_profile_size: 0,\n            sbit_defined: 0,\n            sbit_r: 0,\n            sbit_g: 0,\n            sbit_b: 0,\n            sbit_a: 0,\n            unknown_chunks_data: [0 as *mut libc::c_uchar; 3],\n            unknown_chunks_size: [0; 3],\n        },\n        error: 0,\n    };\n    lodepng_state_init(Some(&mut state));\n    state.info_raw.colortype= colortype;\n    state.info_raw.bitdepth= bitdepth;\n    state.decoder.read_text_chunks= 0 as libc::c_int as libc::c_uint;\n    state.decoder.remember_unknown_chunks= 0 as libc::c_int as libc::c_uint;\n    error= lodepng_decode(out.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), w.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), h.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), core::ptr::addr_of_mut!(state), in_0, insize);\n    lodepng_state_cleanup(Some(&mut state));\n    return error;\n}","src::lodepng::lodepng_save_file":"pub unsafe extern \"C\" fn lodepng_save_file(\n    mut buffer: *const libc::c_uchar,\n    mut buffersize: size_t,\n    mut filename: *const libc::c_char,\n) -> libc::c_uint {\n    let mut file = 0 as *mut FILE;\n    file= fopen(filename, b\"wb\\0\" as *const u8 as *const libc::c_char);\n    if file.is_null() {();\n        return 79 as libc::c_int as libc::c_uint;\n    }\n    fwrite(\n        buffer as *const libc::c_void,\n        1 as libc::c_int as libc::c_ulong,\n        buffersize,\n        file,\n    );\n    fclose(file);\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::readChunk_cHRM":"unsafe extern \"C\" fn readChunk_cHRM(\n    mut info: *mut LodePNGInfo,\n    mut data: *const libc::c_uchar,\n    mut chunkLength: size_t,\n) -> libc::c_uint {\n    if chunkLength != 32 as libc::c_int as libc::c_ulong {\n        return 97 as libc::c_int as libc::c_uint;\n    }\n    (*info).chrm_defined= 1 as libc::c_int as libc::c_uint;\n    (*info).chrm_white_x= (16777216 as libc::c_uint)\n        .wrapping_mul(*data.offset(0 as libc::c_int as isize) as libc::c_uint)\n        .wrapping_add(\n            (65536 as libc::c_uint)\n                .wrapping_mul(*data.offset(1 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(\n            (256 as libc::c_uint)\n                .wrapping_mul(*data.offset(2 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(*data.offset(3 as libc::c_int as isize) as libc::c_uint);\n    (*info).chrm_white_y= (16777216 as libc::c_uint)\n        .wrapping_mul(*data.offset(4 as libc::c_int as isize) as libc::c_uint)\n        .wrapping_add(\n            (65536 as libc::c_uint)\n                .wrapping_mul(*data.offset(5 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(\n            (256 as libc::c_uint)\n                .wrapping_mul(*data.offset(6 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(*data.offset(7 as libc::c_int as isize) as libc::c_uint);\n    (*info).chrm_red_x= (16777216 as libc::c_uint)\n        .wrapping_mul(*data.offset(8 as libc::c_int as isize) as libc::c_uint)\n        .wrapping_add(\n            (65536 as libc::c_uint)\n                .wrapping_mul(*data.offset(9 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(\n            (256 as libc::c_uint)\n                .wrapping_mul(*data.offset(10 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(*data.offset(11 as libc::c_int as isize) as libc::c_uint);\n    (*info).chrm_red_y= (16777216 as libc::c_uint)\n        .wrapping_mul(*data.offset(12 as libc::c_int as isize) as libc::c_uint)\n        .wrapping_add(\n            (65536 as libc::c_uint)\n                .wrapping_mul(*data.offset(13 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(\n            (256 as libc::c_uint)\n                .wrapping_mul(*data.offset(14 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(*data.offset(15 as libc::c_int as isize) as libc::c_uint);\n    (*info).chrm_green_x= (16777216 as libc::c_uint)\n        .wrapping_mul(*data.offset(16 as libc::c_int as isize) as libc::c_uint)\n        .wrapping_add(\n            (65536 as libc::c_uint)\n                .wrapping_mul(*data.offset(17 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(\n            (256 as libc::c_uint)\n                .wrapping_mul(*data.offset(18 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(*data.offset(19 as libc::c_int as isize) as libc::c_uint);\n    (*info).chrm_green_y= (16777216 as libc::c_uint)\n        .wrapping_mul(*data.offset(20 as libc::c_int as isize) as libc::c_uint)\n        .wrapping_add(\n            (65536 as libc::c_uint)\n                .wrapping_mul(*data.offset(21 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(\n            (256 as libc::c_uint)\n                .wrapping_mul(*data.offset(22 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(*data.offset(23 as libc::c_int as isize) as libc::c_uint);\n    (*info).chrm_blue_x= (16777216 as libc::c_uint)\n        .wrapping_mul(*data.offset(24 as libc::c_int as isize) as libc::c_uint)\n        .wrapping_add(\n            (65536 as libc::c_uint)\n                .wrapping_mul(*data.offset(25 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(\n            (256 as libc::c_uint)\n                .wrapping_mul(*data.offset(26 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(*data.offset(27 as libc::c_int as isize) as libc::c_uint);\n    (*info).chrm_blue_y= (16777216 as libc::c_uint)\n        .wrapping_mul(*data.offset(28 as libc::c_int as isize) as libc::c_uint)\n        .wrapping_add(\n            (65536 as libc::c_uint)\n                .wrapping_mul(*data.offset(29 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(\n            (256 as libc::c_uint)\n                .wrapping_mul(*data.offset(30 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(*data.offset(31 as libc::c_int as isize) as libc::c_uint);\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::readBitsFromReversedStream":"unsafe extern \"C\" fn readBitsFromReversedStream(\n    mut bitpointer: Option<&mut size_t>,\n    mut bitstream: *const libc::c_uchar,\n    mut nbits: size_t,\n) -> libc::c_uint {\n    let mut result = 0 as libc::c_int as libc::c_uint;\n    let mut i: size_t = 0;\n    i= 0 as libc::c_int as size_t;\n    while i < nbits {\n        result<<= 1 as libc::c_uint;\n        result|= readBitFromReversedStream(bitpointer.as_deref_mut(), bitstream) as libc::c_uint;\n        i= i.wrapping_add(1);\n    }\n    return result;\n}","src::lodepng::readChunk_tRNS":"unsafe extern \"C\" fn readChunk_tRNS(\n    mut color: *mut LodePNGColorMode,\n    mut data: *const libc::c_uchar,\n    mut chunkLength: size_t,\n) -> libc::c_uint {\n    let mut i: libc::c_uint = 0;\n    if (*color).colortype as libc::c_uint == LCT_PALETTE as libc::c_int as libc::c_uint {\n        if chunkLength > (*color).palettesize {\n            return 39 as libc::c_int as libc::c_uint;\n        }\n        i= 0 as libc::c_int as libc::c_uint;\n        while i as libc::c_ulong != chunkLength {\n            *(*color).palette\n                .offset(\n                    (4 as libc::c_int as libc::c_uint)\n                        .wrapping_mul(i)\n                        .wrapping_add(3 as libc::c_int as libc::c_uint) as isize,\n                ) = *data.offset(i as isize);\n            i= i.wrapping_add(1);\n        }\n    } else if (*color).colortype as libc::c_uint\n        == LCT_GREY as libc::c_int as libc::c_uint\n    {\n        if chunkLength != 2 as libc::c_int as libc::c_ulong {\n            return 30 as libc::c_int as libc::c_uint;\n        }\n        (*color).key_defined= 1 as libc::c_int as libc::c_uint;\n        (*color).key_b= (256 as libc::c_uint)\n            .wrapping_mul(*data.offset(0 as libc::c_int as isize) as libc::c_uint)\n            .wrapping_add(*data.offset(1 as libc::c_int as isize) as libc::c_uint); (*color).key_g= (*color).key_b; (*color).key_r= (*color).key_g;\n    } else if (*color).colortype as libc::c_uint\n        == LCT_RGB as libc::c_int as libc::c_uint\n    {\n        if chunkLength != 6 as libc::c_int as libc::c_ulong {\n            return 41 as libc::c_int as libc::c_uint;\n        }\n        (*color).key_defined= 1 as libc::c_int as libc::c_uint;\n        (*color).key_r= (256 as libc::c_uint)\n            .wrapping_mul(*data.offset(0 as libc::c_int as isize) as libc::c_uint)\n            .wrapping_add(*data.offset(1 as libc::c_int as isize) as libc::c_uint);\n        (*color).key_g= (256 as libc::c_uint)\n            .wrapping_mul(*data.offset(2 as libc::c_int as isize) as libc::c_uint)\n            .wrapping_add(*data.offset(3 as libc::c_int as isize) as libc::c_uint);\n        (*color).key_b= (256 as libc::c_uint)\n            .wrapping_mul(*data.offset(4 as libc::c_int as isize) as libc::c_uint)\n            .wrapping_add(*data.offset(5 as libc::c_int as isize) as libc::c_uint);\n    } else {\n        return 42 as libc::c_int as libc::c_uint\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::deflateNoCompression":"unsafe extern \"C\" fn deflateNoCompression(\n    mut out: *mut ucvector,\n    mut data: *const libc::c_uchar,\n    mut datasize: size_t,\n) -> libc::c_uint {\n    let mut i: size_t = 0;\n    let mut numdeflateblocks = datasize\n        .wrapping_add(65534 as libc::c_uint as libc::c_ulong)\n        .wrapping_div(65535 as libc::c_uint as libc::c_ulong);\n    let mut datapos = 0 as libc::c_int as libc::c_uint;\n    i= 0 as libc::c_int as size_t;\n    while i != numdeflateblocks {\n        let mut BFINAL: libc::c_uint = 0;\n        let mut BTYPE: libc::c_uint = 0;\n        let mut LEN: libc::c_uint = 0;\n        let mut NLEN: libc::c_uint = 0;\n        let mut firstbyte: libc::c_uchar = 0;\n        let mut pos = (*out).size;\n        BFINAL= (i == numdeflateblocks.wrapping_sub(1 as libc::c_int as libc::c_ulong))\n            as libc::c_int as libc::c_uint;\n        BTYPE= 0 as libc::c_int as libc::c_uint;\n        LEN= 65535 as libc::c_int as libc::c_uint;\n        if datasize.wrapping_sub(datapos as libc::c_ulong)\n            < 65535 as libc::c_uint as libc::c_ulong\n        {\n            LEN= (datasize as libc::c_uint).wrapping_sub(datapos);\n        }\n        NLEN= (65535 as libc::c_int as libc::c_uint).wrapping_sub(LEN);\n        if {let crown_promoted_local_0 = (*out).size\n                .wrapping_add(LEN as libc::c_ulong)\n                .wrapping_add(5 as libc::c_int as libc::c_ulong);ucvector_resize(\n            out.as_mut(),\n            crown_promoted_local_0,\n        )} == 0\n        {\n            return 83 as libc::c_int as libc::c_uint;\n        }\n        firstbyte= BFINAL\n            .wrapping_add((BTYPE & 1 as libc::c_uint) << 1 as libc::c_uint)\n            .wrapping_add((BTYPE & 2 as libc::c_uint) << 1 as libc::c_uint)\n            as libc::c_uchar;\n        *(*out).data\n            .offset(\n                pos.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n            ) = firstbyte;\n        *(*out).data\n            .offset(\n                pos.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n            ) = (LEN & 255 as libc::c_int as libc::c_uint) as libc::c_uchar;\n        *(*out).data\n            .offset(\n                pos.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n            ) = (LEN >> 8 as libc::c_uint) as libc::c_uchar;\n        *(*out).data\n            .offset(\n                pos.wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n            ) = (NLEN & 255 as libc::c_int as libc::c_uint) as libc::c_uchar;\n        *(*out).data\n            .offset(\n                pos.wrapping_add(4 as libc::c_int as libc::c_ulong) as isize,\n            ) = (NLEN >> 8 as libc::c_uint) as libc::c_uchar;\n        lodepng_memcpy(\n            (*out).data.offset(pos as isize).offset(5 as libc::c_int as isize)\n                as *mut libc::c_void,\n            data.offset(datapos as isize) as *const libc::c_void,\n            LEN as size_t,\n        );\n        datapos= datapos.wrapping_add(LEN);\n        i= i.wrapping_add(1);\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::color_tree_get":"unsafe extern \"C\" fn color_tree_get(\n    mut tree: *mut ColorTree,\n    mut r: libc::c_uchar,\n    mut g: libc::c_uchar,\n    mut b: libc::c_uchar,\n    mut a: libc::c_uchar,\n) -> libc::c_int {\n    let mut bit = 0 as libc::c_int;\n    bit= 0 as libc::c_int;\n    while bit < 8 as libc::c_int {\n        let mut i = 8 as libc::c_int * (r as libc::c_int >> bit & 1 as libc::c_int)\n            + 4 as libc::c_int * (g as libc::c_int >> bit & 1 as libc::c_int)\n            + 2 as libc::c_int * (b as libc::c_int >> bit & 1 as libc::c_int)\n            + 1 as libc::c_int * (a as libc::c_int >> bit & 1 as libc::c_int);\n        if (*tree).children[i as usize].is_null() {();\n            return -(1 as libc::c_int)\n        } else {\n            tree= (*tree).children[i as usize];\n        }\n        bit+= 1;\n    }\n    return if !tree.is_null() { (*tree).index } else {(); -(1 as libc::c_int) };\n}","src::lodepng::lodepng_palette_clear":"pub unsafe extern \"C\" fn lodepng_palette_clear(mut info: *mut LodePNGColorMode) {\n    if !(*info).palette.is_null() {\n        lodepng_free((*info).palette as *mut libc::c_void);\n    }else { (); }\n    (*info).palette= 0 as *mut libc::c_uchar;\n    (*info).palettesize= 0 as libc::c_int as size_t;\n}","src::lodepng::bpmnode_create":"unsafe extern \"C\" fn bpmnode_create(\n    mut lists: *mut BPMLists,\n    mut weight: libc::c_int,\n    mut index: libc::c_uint,\n    mut tail: *mut BPMNode,\n) -> *mut BPMNode {\n    let mut i: libc::c_uint = 0;\n    let mut result = 0 as *mut BPMNode;\n    if (*lists).nextfree >= (*lists).numfree {\n        i= 0 as libc::c_int as libc::c_uint;\n        while i != (*lists).memsize {\n            (*(*lists).memory.offset(i as isize)).in_use = 0 as libc::c_int;\n            i= i.wrapping_add(1);\n        }\n        i= 0 as libc::c_int as libc::c_uint;\n        while i != (*lists).listsize {\n            let mut node = 0 as *mut BPMNode;\n            node= *(*lists).chains0.offset(i as isize);\n            while !node.is_null() {\n                (*node).in_use= 1 as libc::c_int;\n                node= (*node).tail;\n            }();\n            node= *(*lists).chains1.offset(i as isize);\n            while !node.is_null() {\n                (*node).in_use= 1 as libc::c_int;\n                node= (*node).tail;\n            }();\n            i= i.wrapping_add(1);\n        }\n        (*lists).numfree= 0 as libc::c_int as libc::c_uint;\n        i= 0 as libc::c_int as libc::c_uint;\n        while i != (*lists).memsize {\n            if (*(*lists).memory.offset(i as isize)).in_use == 0 {\n                let fresh28 = (*lists).numfree;(*lists).numfree= (*lists).numfree.wrapping_add(1);\n                *(*lists).freelist.offset(fresh28 as isize) = core::ptr::addr_of_mut!(*(*lists).memory.offset(i as isize)) as *mut BPMNode;\n            }\n            i= i.wrapping_add(1);\n        }\n        (*lists).nextfree= 0 as libc::c_int as libc::c_uint;\n    }\n    let fresh31 = (*lists).nextfree;(*lists).nextfree= (*lists).nextfree.wrapping_add(1);\n    result= *(*lists).freelist.offset(fresh31 as isize);\n    (*result).weight= weight;\n    (*result).index= index;\n    (*result).tail= tail;\n    return result;\n}","src::lodepng::updateHashChain":"unsafe extern \"C\" fn updateHashChain(\n    mut hash: Option<&mut Hash>,\n    mut wpos: size_t,\n    mut hashval: libc::c_uint,\n    mut numzeros: libc::c_ushort,\n) {\n    *(*hash.as_deref().unwrap()).val.offset(wpos as isize) = hashval as libc::c_int;\n    if *(*hash.as_deref().unwrap()).head.offset(hashval as isize) != -(1 as libc::c_int) {\n        *(*hash.as_deref().unwrap()).chain\n            .offset(\n                wpos as isize,\n            ) = *(*hash.as_deref().unwrap()).head.offset(hashval as isize) as libc::c_ushort;\n    }\n    *(*hash.as_deref().unwrap()).head.offset(hashval as isize) = wpos as libc::c_int;\n    *(*hash.as_deref().unwrap()).zeros.offset(wpos as isize) = numzeros;\n    if *(*hash.as_deref().unwrap()).headz.offset(numzeros as isize) != -(1 as libc::c_int) {\n        *(*hash.as_deref().unwrap()).chainz\n            .offset(\n                wpos as isize,\n            ) = *(*hash.as_deref().unwrap()).headz.offset(numzeros as isize) as libc::c_ushort;\n    }\n    *(*hash.as_deref().unwrap()).headz.offset(numzeros as isize) = wpos as libc::c_int;\n}","src::lodepng::lodepng_chunk_find_const":"pub unsafe extern \"C\" fn lodepng_chunk_find_const(\n    mut chunk: *const libc::c_uchar,\n    mut end: *const libc::c_uchar,\n    mut type_0: *const libc::c_char,\n) -> *const libc::c_uchar {\n    loop {\n        if chunk >= end\n            || (end.offset_from(chunk) as libc::c_long)\n                < 12 as libc::c_int as libc::c_long\n        {\n            return 0 as *const libc::c_uchar;\n        }\n        if lodepng_chunk_type_equals(chunk, type_0) != 0 {\n            return chunk;\n        }\n        chunk= lodepng_chunk_next_const(chunk, end);\n    };\n}","src::lodepng::writeSignature":"unsafe extern \"C\" fn writeSignature(mut out: *mut ucvector) -> libc::c_uint {\n    let mut pos = (*out).size;\n    let signature: [libc::c_uchar; 8] = [\n        137 as libc::c_int as libc::c_uchar,\n        80 as libc::c_int as libc::c_uchar,\n        78 as libc::c_int as libc::c_uchar,\n        71 as libc::c_int as libc::c_uchar,\n        13 as libc::c_int as libc::c_uchar,\n        10 as libc::c_int as libc::c_uchar,\n        26 as libc::c_int as libc::c_uchar,\n        10 as libc::c_int as libc::c_uchar,\n    ];\n    if {let crown_promoted_local_0 = (*out).size.wrapping_add(8 as libc::c_int as libc::c_ulong);ucvector_resize(\n        out.as_mut(),\n        crown_promoted_local_0,\n    )} == 0\n    {\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    lodepng_memcpy(\n        (*out).data.offset(pos as isize) as *mut libc::c_void,\n        signature.as_ptr() as *const libc::c_void,\n        8 as libc::c_int as size_t,\n    );\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::ilog2":"unsafe extern \"C\" fn ilog2(mut i: size_t) -> size_t {\n    let mut result = 0 as libc::c_int as size_t;\n    if i >= 65536 as libc::c_int as libc::c_ulong {\n        result= (result as libc::c_ulong)\n            .wrapping_add(16 as libc::c_int as libc::c_ulong) as size_t as size_t;\n        i>>= 16 as libc::c_int;\n    }\n    if i >= 256 as libc::c_int as libc::c_ulong {\n        result= (result as libc::c_ulong)\n            .wrapping_add(8 as libc::c_int as libc::c_ulong) as size_t as size_t;\n        i>>= 8 as libc::c_int;\n    }\n    if i >= 16 as libc::c_int as libc::c_ulong {\n        result= (result as libc::c_ulong)\n            .wrapping_add(4 as libc::c_int as libc::c_ulong) as size_t as size_t;\n        i>>= 4 as libc::c_int;\n    }\n    if i >= 4 as libc::c_int as libc::c_ulong {\n        result= (result as libc::c_ulong)\n            .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t as size_t;\n        i>>= 2 as libc::c_int;\n    }\n    if i >= 2 as libc::c_int as libc::c_ulong {\n        result= (result as libc::c_ulong)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong) as size_t as size_t;\n    }\n    return result;\n}","src::lodepng::lodepng_crc32":"pub unsafe extern \"C\" fn lodepng_crc32(\n    mut data: *const libc::c_uchar,\n    mut length: size_t,\n) -> libc::c_uint {\n    let mut r = 0xffffffff as libc::c_uint;\n    let mut i: size_t = 0;\n    i= 0 as libc::c_int as size_t;\n    while i < length {\n        r= lodepng_crc32_table[((r ^ *data.offset(i as isize) as libc::c_uint)\n            & 0xff as libc::c_uint) as usize] ^ r >> 8 as libc::c_uint;\n        i= i.wrapping_add(1);\n    }\n    return r ^ 0xffffffff as libc::c_uint;\n}","src::lodepng::addChunk_tEXt":"unsafe extern \"C\" fn addChunk_tEXt(\n    mut out: *mut ucvector,\n    mut keyword: *const libc::c_char,\n    mut textstring: *const libc::c_char,\n) -> libc::c_uint {\n    let mut chunk = 0 as *mut libc::c_uchar;\n    let mut keysize = lodepng_strlen(keyword);\n    let mut textsize = lodepng_strlen(textstring);\n    let mut size = keysize\n        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n        .wrapping_add(textsize);\n    if keysize < 1 as libc::c_int as libc::c_ulong\n        || keysize > 79 as libc::c_int as libc::c_ulong\n    {\n        return 89 as libc::c_int as libc::c_uint;\n    }\n    let mut error = lodepng_chunk_init(\n        core::ptr::addr_of_mut!(chunk),\n        out,\n        size as libc::c_uint,\n        b\"tEXt\\0\" as *const u8 as *const libc::c_char,\n    );\n    if error != 0 {\n        return error;\n    }\n    lodepng_memcpy(\n        chunk.offset(8 as libc::c_int as isize) as *mut libc::c_void,\n        keyword as *const libc::c_void,\n        keysize,\n    );\n    *chunk\n        .offset(\n            (8 as libc::c_int as libc::c_ulong).wrapping_add(keysize) as isize,\n        ) = 0 as libc::c_int as libc::c_uchar;\n    lodepng_memcpy(\n        chunk.offset(9 as libc::c_int as isize).offset(keysize as isize)\n            as *mut libc::c_void,\n        textstring as *const libc::c_void,\n        textsize,\n    );\n    lodepng_chunk_generate_crc(chunk);\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::ensureBits9":"unsafe extern \"C\" fn ensureBits9(mut reader: Option<&mut LodePNGBitReader>, mut nbits: size_t) {\n    let mut start = (*reader.as_deref().unwrap()).bp >> 3 as libc::c_uint;\n    let mut size = (*reader.as_deref().unwrap()).size;\n    if start.wrapping_add(1 as libc::c_uint as libc::c_ulong) < size {\n        (*reader.as_deref_mut().unwrap()).buffer= *(*reader.as_deref().unwrap()).data\n            .offset(start.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize)\n            as libc::c_uint\n            | (*(*reader.as_deref().unwrap()).data\n                .offset(start.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize)\n                as libc::c_uint) << 8 as libc::c_uint;\n        (*reader.as_deref_mut().unwrap()).buffer>>= (*reader.as_deref().unwrap()).bp & 7 as libc::c_uint as libc::c_ulong;\n    } else {\n        (*reader.as_deref_mut().unwrap()).buffer= 0 as libc::c_int as libc::c_uint;\n        if start.wrapping_add(0 as libc::c_uint as libc::c_ulong) < size {\n            (*reader.as_deref_mut().unwrap()).buffer= *(*reader.as_deref().unwrap()).data\n                .offset(start.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize)\n                as libc::c_uint;\n        }\n        (*reader.as_deref_mut().unwrap()).buffer>>= (*reader.as_deref().unwrap()).bp & 7 as libc::c_uint as libc::c_ulong;\n    };\n}","src::lodepng::reverseBits":"unsafe extern \"C\" fn reverseBits(\n    mut bits: libc::c_uint,\n    mut num: libc::c_uint,\n) -> libc::c_uint {\n    let mut i: libc::c_uint = 0;\n    let mut result = 0 as libc::c_int as libc::c_uint;\n    i= 0 as libc::c_int as libc::c_uint;\n    while i < num {\n        result|= (bits >> num.wrapping_sub(i).wrapping_sub(1 as libc::c_uint)\n                & 1 as libc::c_uint) << i;\n        i= i.wrapping_add(1);\n    }\n    return result;\n}","src::lodepng::lodepng_free":"unsafe extern \"C\" fn lodepng_free(mut ptr: *mut /* owning */ libc::c_void) {\n    free(ptr);\n}","src::lodepng::removePaddingBits":"unsafe extern \"C\" fn removePaddingBits(\n    mut out: *mut libc::c_uchar,\n    mut in_0: *const libc::c_uchar,\n    mut olinebits: size_t,\n    mut ilinebits: size_t,\n    mut h: libc::c_uint,\n) {\n    let mut y: libc::c_uint = 0;\n    let mut diff = ilinebits.wrapping_sub(olinebits);\n    let mut ibp = 0 as libc::c_int as size_t;\n    let mut obp = 0 as libc::c_int as size_t;\n    y= 0 as libc::c_int as libc::c_uint;\n    while y < h {\n        let mut x: size_t = 0;\n        x= 0 as libc::c_int as size_t;\n        while x < olinebits {\n            let mut bit = readBitFromReversedStream(Some(&mut ibp), in_0);\n            setBitOfReversedStream(Some(&mut obp), out, bit);\n            x= x.wrapping_add(1);\n        }\n        ibp= (ibp as libc::c_ulong).wrapping_add(diff) as size_t as size_t;\n        y= y.wrapping_add(1);\n    }\n}","src::lodepng::addChunk_pHYs":"unsafe extern \"C\" fn addChunk_pHYs(\n    mut out: *mut ucvector,\n    mut info: *const LodePNGInfo,\n) -> libc::c_uint {\n    let mut chunk = 0 as *mut libc::c_uchar;\n    let mut error = lodepng_chunk_init(\n        core::ptr::addr_of_mut!(chunk),\n        out,\n        9 as libc::c_int as libc::c_uint,\n        b\"pHYs\\0\" as *const u8 as *const libc::c_char,\n    );\n    if error != 0 {\n        return error;\n    }\n    lodepng_set32bitInt(chunk.offset(8 as libc::c_int as isize), (*info).phys_x);\n    lodepng_set32bitInt(chunk.offset(12 as libc::c_int as isize), (*info).phys_y);\n    *chunk.offset(16 as libc::c_int as isize) = (*info).phys_unit as libc::c_uchar;\n    lodepng_chunk_generate_crc(chunk);\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::deflateDynamic":"unsafe extern \"C\" fn deflateDynamic(\n    mut writer: *mut LodePNGBitWriter,\n    mut hash: *mut Hash,\n    mut data: *const libc::c_uchar,\n    mut datapos: size_t,\n    mut dataend: size_t,\n    mut settings: *const LodePNGCompressSettings,\n    mut final_0: libc::c_uint,\n) -> libc::c_uint {\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut lz77_encoded = uivector {\n        data: 0 as *mut libc::c_uint,\n        size: 0,\n        allocsize: 0,\n    };\n    let mut tree_ll = HuffmanTree {\n        codes: 0 as *mut libc::c_uint,\n        lengths: 0 as *mut libc::c_uint,\n        maxbitlen: 0,\n        numcodes: 0,\n        table_len: 0 as *mut libc::c_uchar,\n        table_value: 0 as *mut libc::c_ushort,\n    };\n    let mut tree_d = HuffmanTree {\n        codes: 0 as *mut libc::c_uint,\n        lengths: 0 as *mut libc::c_uint,\n        maxbitlen: 0,\n        numcodes: 0,\n        table_len: 0 as *mut libc::c_uchar,\n        table_value: 0 as *mut libc::c_ushort,\n    };\n    let mut tree_cl = HuffmanTree {\n        codes: 0 as *mut libc::c_uint,\n        lengths: 0 as *mut libc::c_uint,\n        maxbitlen: 0,\n        numcodes: 0,\n        table_len: 0 as *mut libc::c_uchar,\n        table_value: 0 as *mut libc::c_ushort,\n    };\n    let mut frequencies_ll = 0 as *mut libc::c_uint;\n    let mut frequencies_d = 0 as *mut libc::c_uint;\n    let mut frequencies_cl = 0 as *mut libc::c_uint;\n    let mut bitlen_lld = 0 as *mut libc::c_uint;\n    let mut bitlen_lld_e = 0 as *mut libc::c_uint;\n    let mut datasize = dataend.wrapping_sub(datapos);\n    let mut BFINAL = final_0;\n    let mut i: size_t = 0;\n    let mut numcodes_ll: size_t = 0;\n    let mut numcodes_d: size_t = 0;\n    let mut numcodes_lld: size_t = 0;\n    let mut numcodes_lld_e: size_t = 0;\n    let mut numcodes_cl: size_t = 0;\n    let mut HLIT: libc::c_uint = 0;\n    let mut HDIST: libc::c_uint = 0;\n    let mut HCLEN: libc::c_uint = 0;\n    uivector_init(Some(&mut lz77_encoded));\n    HuffmanTree_init(Some(&mut tree_ll));\n    HuffmanTree_init(Some(&mut tree_d));\n    HuffmanTree_init(Some(&mut tree_cl));\n    frequencies_ll= lodepng_malloc(\n        (286 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong),\n    ) as *mut libc::c_uint;\n    frequencies_d= lodepng_malloc(\n        (30 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong),\n    ) as *mut libc::c_uint;\n    frequencies_cl= lodepng_malloc(\n        (19 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong),\n    ) as *mut libc::c_uint;\n    if frequencies_ll.is_null() || frequencies_d.is_null() || frequencies_cl.is_null() {\n        error= 83 as libc::c_int as libc::c_uint;\n    }\n    let mut current_block_113: u64;\n    if error == 0 {\n        lodepng_memset(\n            frequencies_ll as *mut libc::c_void,\n            0 as libc::c_int,\n            (286 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong),\n        );\n        lodepng_memset(\n            frequencies_d as *mut libc::c_void,\n            0 as libc::c_int,\n            (30 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong),\n        );\n        lodepng_memset(\n            frequencies_cl as *mut libc::c_void,\n            0 as libc::c_int,\n            (19 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong),\n        );\n        if (*settings).use_lz77 != 0 {\n            error= encodeLZ77(\n                Some(&mut lz77_encoded),\n                hash.as_mut(),\n                data,\n                datapos,\n                dataend,\n                (*settings).windowsize,\n                (*settings).minmatch,\n                (*settings).nicematch,\n                (*settings).lazymatching,\n            );\n            if error != 0 {\n                current_block_113= 6988365858197790817;\n            } else {\n                current_block_113= 17788412896529399552;\n            }\n        } else if uivector_resize(core::ptr::addr_of_mut!(lz77_encoded), datasize) == 0 {\n            error= 83 as libc::c_int as libc::c_uint;\n            current_block_113= 6988365858197790817;\n        } else {\n            i= datapos;\n            while i < dataend {\n                *lz77_encoded.data\n                    .offset(\n                        i.wrapping_sub(datapos) as isize,\n                    ) = *data.offset(i as isize) as libc::c_uint;\n                i= i.wrapping_add(1);\n            }\n            current_block_113= 17788412896529399552;\n        }\n        match current_block_113 {\n            6988365858197790817 => {}\n            _ => {\n                i= 0 as libc::c_int as size_t;\n                while i != lz77_encoded.size {\n                    let mut symbol = *lz77_encoded.data.offset(i as isize);\n                    *frequencies_ll.offset(symbol as isize) = (*frequencies_ll.offset(symbol as isize)).wrapping_add(1);\n                    if symbol > 256 as libc::c_int as libc::c_uint {\n                        let mut dist = *lz77_encoded.data\n                            .offset(\n                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        *frequencies_d.offset(dist as isize) = (*frequencies_d.offset(dist as isize)).wrapping_add(1);\n                        i= (i as libc::c_ulong)\n                            .wrapping_add(3 as libc::c_int as libc::c_ulong) as size_t\n                            as size_t;\n                    }\n                    i= i.wrapping_add(1);\n                }\n                *frequencies_ll\n                    .offset(\n                        256 as libc::c_int as isize,\n                    ) = 1 as libc::c_int as libc::c_uint;\n                error= HuffmanTree_makeFromFrequencies(\n                    Some(&mut tree_ll),\n                    frequencies_ll,\n                    257 as libc::c_int as size_t,\n                    286 as libc::c_int as size_t,\n                    15 as libc::c_int as libc::c_uint,\n                );\n                if !(error != 0) {\n                    error= HuffmanTree_makeFromFrequencies(\n                        Some(&mut tree_d),\n                        frequencies_d,\n                        2 as libc::c_int as size_t,\n                        30 as libc::c_int as size_t,\n                        15 as libc::c_int as libc::c_uint,\n                    );\n                    if !(error != 0) {\n                        numcodes_ll= (if tree_ll.numcodes\n                            < 286 as libc::c_int as libc::c_uint\n                        {\n                            tree_ll.numcodes\n                        } else {\n                            286 as libc::c_int as libc::c_uint\n                        }) as size_t;\n                        numcodes_d= (if tree_d.numcodes\n                            < 30 as libc::c_int as libc::c_uint\n                        {\n                            tree_d.numcodes\n                        } else {\n                            30 as libc::c_int as libc::c_uint\n                        }) as size_t;\n                        numcodes_lld= numcodes_ll.wrapping_add(numcodes_d);\n                        bitlen_lld= lodepng_malloc(\n                            numcodes_lld\n                                .wrapping_mul(\n                                    ::std::mem::size_of::<libc::c_uint>() as libc::c_ulong,\n                                ),\n                        ) as *mut libc::c_uint;\n                        bitlen_lld_e= lodepng_malloc(\n                            numcodes_lld\n                                .wrapping_mul(\n                                    ::std::mem::size_of::<libc::c_uint>() as libc::c_ulong,\n                                ),\n                        ) as *mut libc::c_uint;\n                        if bitlen_lld.is_null() || bitlen_lld_e.is_null() {\n                            error= 83 as libc::c_int as libc::c_uint;\n                        } else {\n                            numcodes_lld_e= 0 as libc::c_int as size_t;\n                            i= 0 as libc::c_int as size_t;\n                            while i != numcodes_ll {\n                                *bitlen_lld\n                                    .offset(i as isize) = *tree_ll.lengths.offset(i as isize);\n                                i= i.wrapping_add(1);\n                            }\n                            i= 0 as libc::c_int as size_t;\n                            while i != numcodes_d {\n                                *bitlen_lld\n                                    .offset(\n                                        numcodes_ll.wrapping_add(i) as isize,\n                                    ) = *tree_d.lengths.offset(i as isize);\n                                i= i.wrapping_add(1);\n                            }\n                            i= 0 as libc::c_int as size_t;\n                            while i != numcodes_lld {\n                                let mut j = 0 as libc::c_int as libc::c_uint;\n                                while i\n                                    .wrapping_add(j as libc::c_ulong)\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                    < numcodes_lld\n                                    && *bitlen_lld\n                                        .offset(\n                                            i\n                                                .wrapping_add(j as libc::c_ulong)\n                                                .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                        ) == *bitlen_lld.offset(i as isize)\n                                {\n                                    j= j.wrapping_add(1);\n                                }\n                                if *bitlen_lld.offset(i as isize)\n                                    == 0 as libc::c_int as libc::c_uint\n                                    && j >= 2 as libc::c_int as libc::c_uint\n                                {\n                                    j= j.wrapping_add(1);\n                                    if j <= 10 as libc::c_int as libc::c_uint {\n                                        let fresh62 = numcodes_lld_e;\n                                        numcodes_lld_e= numcodes_lld_e.wrapping_add(1);\n                                        *bitlen_lld_e\n                                            .offset(\n                                                fresh62 as isize,\n                                            ) = 17 as libc::c_int as libc::c_uint;\n                                        let fresh63 = numcodes_lld_e;\n                                        numcodes_lld_e= numcodes_lld_e.wrapping_add(1);\n                                        *bitlen_lld_e\n                                            .offset(\n                                                fresh63 as isize,\n                                            ) = j.wrapping_sub(3 as libc::c_int as libc::c_uint);\n                                    } else {\n                                        if j > 138 as libc::c_int as libc::c_uint {\n                                            j= 138 as libc::c_int as libc::c_uint;\n                                        }\n                                        let fresh64 = numcodes_lld_e;\n                                        numcodes_lld_e= numcodes_lld_e.wrapping_add(1);\n                                        *bitlen_lld_e\n                                            .offset(\n                                                fresh64 as isize,\n                                            ) = 18 as libc::c_int as libc::c_uint;\n                                        let fresh65 = numcodes_lld_e;\n                                        numcodes_lld_e= numcodes_lld_e.wrapping_add(1);\n                                        *bitlen_lld_e\n                                            .offset(\n                                                fresh65 as isize,\n                                            ) = j.wrapping_sub(11 as libc::c_int as libc::c_uint);\n                                    }\n                                    i= (i as libc::c_ulong)\n                                        .wrapping_add(\n                                            j.wrapping_sub(1 as libc::c_int as libc::c_uint)\n                                                as libc::c_ulong,\n                                        ) as size_t as size_t;\n                                } else if j >= 3 as libc::c_int as libc::c_uint {\n                                    let mut k: size_t = 0;\n                                    let mut num = j.wrapping_div(6 as libc::c_uint);\n                                    let mut rest = j.wrapping_rem(6 as libc::c_uint);\n                                    let fresh66 = numcodes_lld_e;\n                                    numcodes_lld_e= numcodes_lld_e.wrapping_add(1);\n                                    *bitlen_lld_e\n                                        .offset(fresh66 as isize) = *bitlen_lld.offset(i as isize);\n                                    k= 0 as libc::c_int as size_t;\n                                    while k < num as libc::c_ulong {\n                                        let fresh67 = numcodes_lld_e;\n                                        numcodes_lld_e= numcodes_lld_e.wrapping_add(1);\n                                        *bitlen_lld_e\n                                            .offset(\n                                                fresh67 as isize,\n                                            ) = 16 as libc::c_int as libc::c_uint;\n                                        let fresh68 = numcodes_lld_e;\n                                        numcodes_lld_e= numcodes_lld_e.wrapping_add(1);\n                                        *bitlen_lld_e\n                                            .offset(\n                                                fresh68 as isize,\n                                            ) = (6 as libc::c_int - 3 as libc::c_int) as libc::c_uint;\n                                        k= k.wrapping_add(1);\n                                    }\n                                    if rest >= 3 as libc::c_int as libc::c_uint {\n                                        let fresh69 = numcodes_lld_e;\n                                        numcodes_lld_e= numcodes_lld_e.wrapping_add(1);\n                                        *bitlen_lld_e\n                                            .offset(\n                                                fresh69 as isize,\n                                            ) = 16 as libc::c_int as libc::c_uint;\n                                        let fresh70 = numcodes_lld_e;\n                                        numcodes_lld_e= numcodes_lld_e.wrapping_add(1);\n                                        *bitlen_lld_e\n                                            .offset(\n                                                fresh70 as isize,\n                                            ) = rest.wrapping_sub(3 as libc::c_int as libc::c_uint);\n                                    } else {\n                                        j= j.wrapping_sub(rest);\n                                    }\n                                    i= (i as libc::c_ulong).wrapping_add(j as libc::c_ulong)\n                                        as size_t as size_t;\n                                } else {\n                                    let fresh71 = numcodes_lld_e;\n                                    numcodes_lld_e= numcodes_lld_e.wrapping_add(1);\n                                    *bitlen_lld_e\n                                        .offset(fresh71 as isize) = *bitlen_lld.offset(i as isize);\n                                }\n                                i= i.wrapping_add(1);\n                            }\n                            i= 0 as libc::c_int as size_t;\n                            while i != numcodes_lld_e {\n                                *frequencies_cl\n                                    .offset(*bitlen_lld_e.offset(i as isize) as isize) = (*frequencies_cl\n                                    .offset(*bitlen_lld_e.offset(i as isize) as isize)).wrapping_add(1);\n                                if *bitlen_lld_e.offset(i as isize)\n                                    >= 16 as libc::c_int as libc::c_uint\n                                {\n                                    i= i.wrapping_add(1);\n                                }\n                                i= i.wrapping_add(1);\n                            }\n                            error= HuffmanTree_makeFromFrequencies(\n                                Some(&mut tree_cl),\n                                frequencies_cl,\n                                19 as libc::c_int as size_t,\n                                19 as libc::c_int as size_t,\n                                7 as libc::c_int as libc::c_uint,\n                            );\n                            if !(error != 0) {\n                                numcodes_cl= 19 as libc::c_int as size_t;\n                                while numcodes_cl > 4 as libc::c_uint as libc::c_ulong\n                                    && *tree_cl.lengths\n                                        .offset(\n                                            crate::src::lodepng::CLCL_ORDER[numcodes_cl\n                                                .wrapping_sub(1 as libc::c_uint as libc::c_ulong) as usize]\n                                                as isize,\n                                        ) == 0 as libc::c_int as libc::c_uint\n                                {\n                                    numcodes_cl= numcodes_cl.wrapping_sub(1);\n                                }\n                                writeBits(writer.as_mut(), BFINAL, 1 as libc::c_int as size_t);\n                                writeBits(\n                                    writer.as_mut(),\n                                    0 as libc::c_int as libc::c_uint,\n                                    1 as libc::c_int as size_t,\n                                );\n                                writeBits(\n                                    writer.as_mut(),\n                                    1 as libc::c_int as libc::c_uint,\n                                    1 as libc::c_int as size_t,\n                                );\n                                HLIT= numcodes_ll\n                                    .wrapping_sub(257 as libc::c_int as libc::c_ulong)\n                                    as libc::c_uint;\n                                HDIST= numcodes_d\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                    as libc::c_uint;\n                                HCLEN= numcodes_cl\n                                    .wrapping_sub(4 as libc::c_int as libc::c_ulong)\n                                    as libc::c_uint;\n                                writeBits(writer.as_mut(), HLIT, 5 as libc::c_int as size_t);\n                                writeBits(writer.as_mut(), HDIST, 5 as libc::c_int as size_t);\n                                writeBits(writer.as_mut(), HCLEN, 4 as libc::c_int as size_t);\n                                i= 0 as libc::c_int as size_t;\n                                while i != numcodes_cl {\n                                    writeBits(\n                                        writer.as_mut(),\n                                        *tree_cl.lengths.offset(crate::src::lodepng::CLCL_ORDER[i as usize] as isize),\n                                        3 as libc::c_int as size_t,\n                                    );\n                                    i= i.wrapping_add(1);\n                                }\n                                i= 0 as libc::c_int as size_t;\n                                while i != numcodes_lld_e {\n                                    writeBitsReversed(\n                                        writer.as_mut(),\n                                        *tree_cl.codes\n                                            .offset(*bitlen_lld_e.offset(i as isize) as isize),\n                                        *tree_cl.lengths\n                                            .offset(*bitlen_lld_e.offset(i as isize) as isize) as size_t,\n                                    );\n                                    if *bitlen_lld_e.offset(i as isize)\n                                        == 16 as libc::c_int as libc::c_uint\n                                    {\n                                        i= i.wrapping_add(1);\n                                        writeBits(\n                                            writer.as_mut(),\n                                            *bitlen_lld_e.offset(i as isize),\n                                            2 as libc::c_int as size_t,\n                                        );\n                                    } else if *bitlen_lld_e.offset(i as isize)\n                                        == 17 as libc::c_int as libc::c_uint\n                                    {\n                                        i= i.wrapping_add(1);\n                                        writeBits(\n                                            writer.as_mut(),\n                                            *bitlen_lld_e.offset(i as isize),\n                                            3 as libc::c_int as size_t,\n                                        );\n                                    } else if *bitlen_lld_e.offset(i as isize)\n                                        == 18 as libc::c_int as libc::c_uint\n                                    {\n                                        i= i.wrapping_add(1);\n                                        writeBits(\n                                            writer.as_mut(),\n                                            *bitlen_lld_e.offset(i as isize),\n                                            7 as libc::c_int as size_t,\n                                        );\n                                    }\n                                    i= i.wrapping_add(1);\n                                }\n                                writeLZ77data(\n                                    writer.as_mut(),\n                                    core::ptr::addr_of!(lz77_encoded),\n                                    core::ptr::addr_of!(tree_ll),\n                                    core::ptr::addr_of!(tree_d),\n                                );\n                                if *tree_ll.lengths.offset(256 as libc::c_int as isize)\n                                    == 0 as libc::c_int as libc::c_uint\n                                {\n                                    error= 64 as libc::c_int as libc::c_uint;\n                                } else {\n                                    writeBitsReversed(\n                                        writer.as_mut(),\n                                        *tree_ll.codes.offset(256 as libc::c_int as isize),\n                                        *tree_ll.lengths.offset(256 as libc::c_int as isize)\n                                            as size_t,\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    uivector_cleanup(core::ptr::addr_of_mut!(lz77_encoded) as *mut uivector as *mut libc::c_void);\n    HuffmanTree_cleanup(Some(&mut tree_ll));\n    HuffmanTree_cleanup(Some(&mut tree_d));\n    HuffmanTree_cleanup(Some(&mut tree_cl));\n    lodepng_free(frequencies_ll as *mut libc::c_void);\n    lodepng_free(frequencies_d as *mut libc::c_void);\n    lodepng_free(frequencies_cl as *mut libc::c_void);\n    lodepng_free(bitlen_lld as *mut libc::c_void);\n    lodepng_free(bitlen_lld_e as *mut libc::c_void);\n    return error;\n}","src::lodepng::lodepng_state_cleanup":"pub unsafe extern \"C\" fn lodepng_state_cleanup(mut state: Option<&mut LodePNGState>) {\n    lodepng_color_mode_cleanup(Some(&mut (*state.as_deref_mut().unwrap()).info_raw));\n    lodepng_info_cleanup(Some(&mut (*state.as_deref_mut().unwrap()).info_png));\n}","src::lodepng::lodepng_huffman_code_lengths":"pub unsafe extern \"C\" fn lodepng_huffman_code_lengths(\n    mut lengths: *mut libc::c_uint,\n    mut frequencies: *const libc::c_uint,\n    mut numcodes: size_t,\n    mut maxbitlen: libc::c_uint,\n) -> libc::c_uint {\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut i: libc::c_uint = 0;\n    let mut numpresent = 0 as libc::c_int as size_t;\n    let mut leaves = 0 as *mut BPMNode;\n    if numcodes == 0 as libc::c_int as libc::c_ulong {\n        return 80 as libc::c_int as libc::c_uint;\n    }\n    if (1 as libc::c_uint) << maxbitlen < numcodes as libc::c_uint {\n        return 80 as libc::c_int as libc::c_uint;\n    }\n    leaves= lodepng_malloc(\n        numcodes.wrapping_mul(::std::mem::size_of::<BPMNode>() as libc::c_ulong),\n    ) as *mut BPMNode;\n    if leaves.is_null() {();\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    i= 0 as libc::c_int as libc::c_uint;\n    while i as libc::c_ulong != numcodes {\n        if *frequencies.offset(i as isize) > 0 as libc::c_int as libc::c_uint {\n            (*leaves.offset(numpresent as isize))\n                .weight = *frequencies.offset(i as isize) as libc::c_int;\n            (*leaves.offset(numpresent as isize)).index = i;\n            numpresent= numpresent.wrapping_add(1);\n        }\n        i= i.wrapping_add(1);\n    }\n    lodepng_memset(\n        lengths as *mut libc::c_void,\n        0 as libc::c_int,\n        numcodes.wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong),\n    );\n    if numpresent == 0 as libc::c_int as libc::c_ulong {\n        *lengths.offset(1 as libc::c_int as isize) = 1 as libc::c_int as libc::c_uint; *lengths.offset(0 as libc::c_int as isize)  = *lengths.offset(1 as libc::c_int as isize);\n    } else if numpresent == 1 as libc::c_int as libc::c_ulong {\n        *lengths\n            .offset(\n                (*leaves.offset(0 as libc::c_int as isize)).index as isize,\n            ) = 1 as libc::c_int as libc::c_uint;\n        *lengths\n            .offset(\n                (if (*leaves.offset(0 as libc::c_int as isize)).index\n                    == 0 as libc::c_int as libc::c_uint\n                {\n                    1 as libc::c_int\n                } else {\n                    0 as libc::c_int\n                }) as isize,\n            ) = 1 as libc::c_int as libc::c_uint;\n    } else {\n        let mut lists = BPMLists {\n            memsize: 0,\n            memory: 0 as *mut BPMNode,\n            numfree: 0,\n            nextfree: 0,\n            freelist: 0 as *mut *mut BPMNode,\n            listsize: 0,\n            chains0: 0 as *mut *mut BPMNode,\n            chains1: 0 as *mut *mut BPMNode,\n        };\n        let mut node = 0 as *mut BPMNode;\n        bpmnode_sort(leaves, numpresent);\n        lists.listsize= maxbitlen;\n        lists.memsize= (2 as libc::c_int as libc::c_uint)\n            .wrapping_mul(maxbitlen)\n            .wrapping_mul(maxbitlen.wrapping_add(1 as libc::c_int as libc::c_uint));\n        lists.nextfree= 0 as libc::c_int as libc::c_uint;\n        lists.numfree= lists.memsize;\n        lists.memory= lodepng_malloc(\n            (lists.memsize as libc::c_ulong)\n                .wrapping_mul(::std::mem::size_of::<BPMNode>() as libc::c_ulong),\n        ) as *mut BPMNode;\n        lists.freelist= lodepng_malloc(\n            (lists.memsize as libc::c_ulong)\n                .wrapping_mul(::std::mem::size_of::<*mut BPMNode>() as libc::c_ulong),\n        ) as *mut *mut BPMNode;\n        lists.chains0= lodepng_malloc(\n            (lists.listsize as libc::c_ulong)\n                .wrapping_mul(::std::mem::size_of::<*mut BPMNode>() as libc::c_ulong),\n        ) as *mut *mut BPMNode;\n        lists.chains1= lodepng_malloc(\n            (lists.listsize as libc::c_ulong)\n                .wrapping_mul(::std::mem::size_of::<*mut BPMNode>() as libc::c_ulong),\n        ) as *mut *mut BPMNode;\n        if lists.memory.is_null() || lists.freelist.is_null()\n            || lists.chains0.is_null() || lists.chains1.is_null()\n        {\n            error= 83 as libc::c_int as libc::c_uint;\n        }\n        if error == 0 {\n            i= 0 as libc::c_int as libc::c_uint;\n            while i != lists.memsize {\n                *lists.freelist.offset(i as isize) = core::ptr::addr_of_mut!(*lists.memory.offset(i as isize)) as *mut BPMNode;\n                i= i.wrapping_add(1);\n            }\n            bpmnode_create(\n                core::ptr::addr_of_mut!(lists),\n                (*leaves.offset(0 as libc::c_int as isize)).weight,\n                1 as libc::c_int as libc::c_uint,\n                0 as *mut BPMNode,\n            );\n            bpmnode_create(\n                core::ptr::addr_of_mut!(lists),\n                (*leaves.offset(1 as libc::c_int as isize)).weight,\n                2 as libc::c_int as libc::c_uint,\n                0 as *mut BPMNode,\n            );\n            i= 0 as libc::c_int as libc::c_uint;\n            while i != lists.listsize {\n                *lists.chains0.offset(i as isize) = core::ptr::addr_of_mut!(*lists.memory.offset(0 as libc::c_int as isize))\n                    as *mut BPMNode;\n                *lists.chains1.offset(i as isize) = core::ptr::addr_of_mut!(*lists.memory.offset(1 as libc::c_int as isize))\n                    as *mut BPMNode;\n                i= i.wrapping_add(1);\n            }\n            i= 2 as libc::c_int as libc::c_uint;\n            while i as libc::c_ulong\n                != (2 as libc::c_int as libc::c_ulong)\n                    .wrapping_mul(numpresent)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong)\n            {\n                boundaryPM(\n                    Some(&mut lists),\n                    leaves,\n                    numpresent,\n                    maxbitlen as libc::c_int - 1 as libc::c_int,\n                    i as libc::c_int,\n                );\n                i= i.wrapping_add(1);\n            }\n            node= *lists.chains1\n                .offset(\n                    maxbitlen.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,\n                );\n            while !node.is_null() {\n                i= 0 as libc::c_int as libc::c_uint;\n                while i != (*node).index {\n                    *lengths\n                        .offset((*leaves.offset(i as isize)).index as isize) = (*lengths\n                        .offset((*leaves.offset(i as isize)).index as isize)).wrapping_add(1);\n                    i= i.wrapping_add(1);\n                }\n                node= (*node).tail;\n            }();\n        }\n        lodepng_free(lists.memory as *mut libc::c_void);\n        lodepng_free(lists.freelist as *mut libc::c_void);\n        lodepng_free(lists.chains0 as *mut libc::c_void);\n        lodepng_free(lists.chains1 as *mut libc::c_void);\n    }\n    lodepng_free(leaves as *mut libc::c_void);\n    return error;\n}","src::lodepng::writeLZ77data":"unsafe extern \"C\" fn writeLZ77data(\n    mut writer: Option<&mut LodePNGBitWriter>,\n    mut lz77_encoded: *const uivector,\n    mut tree_ll: *const HuffmanTree,\n    mut tree_d: *const HuffmanTree,\n) {\n    let mut i = 0 as libc::c_int as size_t;\n    i= 0 as libc::c_int as size_t;\n    while i != (*lz77_encoded).size {\n        let mut val = *(*lz77_encoded).data.offset(i as isize);\n        writeBitsReversed(\n            writer.as_deref_mut(),\n            *(*tree_ll).codes.offset(val as isize),\n            *(*tree_ll).lengths.offset(val as isize) as size_t,\n        );\n        if val > 256 as libc::c_int as libc::c_uint {\n            let mut length_index = val.wrapping_sub(257 as libc::c_int as libc::c_uint);\n            let mut n_length_extra_bits = crate::src::lodepng::LENGTHEXTRA[length_index as usize];\n            i= i.wrapping_add(1);\n            let mut length_extra_bits = *(*lz77_encoded).data.offset(i as isize);\n            i= i.wrapping_add(1);\n            let mut distance_code = *(*lz77_encoded).data.offset(i as isize);\n            let mut distance_index = distance_code;\n            let mut n_distance_extra_bits = crate::src::lodepng::DISTANCEEXTRA[distance_index as usize];\n            i= i.wrapping_add(1);\n            let mut distance_extra_bits = *(*lz77_encoded).data.offset(i as isize);\n            writeBits(writer.as_deref_mut(), length_extra_bits, n_length_extra_bits as size_t);\n            writeBitsReversed(\n                writer.as_deref_mut(),\n                *(*tree_d).codes.offset(distance_code as isize),\n                *(*tree_d).lengths.offset(distance_code as isize) as size_t,\n            );\n            writeBits(writer.as_deref_mut(), distance_extra_bits, n_distance_extra_bits as size_t);\n        }\n        i= i.wrapping_add(1);\n    }\n}","src::lodepng::lodepng_encode32_file":"pub unsafe extern \"C\" fn lodepng_encode32_file(\n    mut filename: *const libc::c_char,\n    mut image: *const libc::c_uchar,\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n) -> libc::c_uint {\n    return lodepng_encode_file(\n        filename,\n        image,\n        w,\n        h,\n        LCT_RGBA,\n        8 as libc::c_int as libc::c_uint,\n    );\n}","src::lodepng::color_tree_cleanup":"unsafe extern \"C\" fn color_tree_cleanup(mut tree: *mut ColorTree) {\n    let mut i: libc::c_int = 0;\n    i= 0 as libc::c_int;\n    while i != 16 as libc::c_int {\n        if !(*tree).children[i as usize].is_null() {\n            color_tree_cleanup((*tree).children[i as usize]);\n            lodepng_free((*tree).children[i as usize] as *mut libc::c_void);\n        }else { (); }\n        i+= 1;\n    }\n}","src::lodepng::Adam7_deinterlace":"unsafe extern \"C\" fn Adam7_deinterlace(\n    mut out: *mut libc::c_uchar,\n    mut in_0: *const libc::c_uchar,\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n    mut bpp: libc::c_uint,\n) {\n    let mut passw: [libc::c_uint; 7] = [0; 7];\n    let mut passh: [libc::c_uint; 7] = [0; 7];\n    let mut filter_passstart: [size_t; 8] = [0; 8];\n    let mut padded_passstart: [size_t; 8] = [0; 8];\n    let mut passstart: [size_t; 8] = [0; 8];\n    let mut i: libc::c_uint = 0;\n    Adam7_getpassvalues(\n        passw.as_mut_ptr(),\n        passh.as_mut_ptr(),\n        filter_passstart.as_mut_ptr(),\n        padded_passstart.as_mut_ptr(),\n        passstart.as_mut_ptr(),\n        w,\n        h,\n        bpp,\n    );\n    if bpp >= 8 as libc::c_int as libc::c_uint {\n        i= 0 as libc::c_int as libc::c_uint;\n        while i != 7 as libc::c_int as libc::c_uint {\n            let mut x: libc::c_uint = 0;\n            let mut y: libc::c_uint = 0;\n            let mut b: libc::c_uint = 0;\n            let mut bytewidth = bpp.wrapping_div(8 as libc::c_uint) as size_t;\n            y= 0 as libc::c_int as libc::c_uint;\n            while y < passh[i as usize] {\n                x= 0 as libc::c_int as libc::c_uint;\n                while x < passw[i as usize] {\n                    let mut pixelinstart = passstart[i as usize]\n                        .wrapping_add(\n                            (y.wrapping_mul(passw[i as usize]).wrapping_add(x)\n                                as libc::c_ulong)\n                                .wrapping_mul(bytewidth),\n                        );\n                    let mut pixeloutstart = (crate::src::lodepng::ADAM7_IY[i as usize] as libc::c_ulong)\n                        .wrapping_add(\n                            (y as size_t)\n                                .wrapping_mul(crate::src::lodepng::ADAM7_DY[i as usize] as libc::c_ulong),\n                        )\n                        .wrapping_mul(w as size_t)\n                        .wrapping_add(crate::src::lodepng::ADAM7_IX[i as usize] as libc::c_ulong)\n                        .wrapping_add(\n                            (x as size_t)\n                                .wrapping_mul(crate::src::lodepng::ADAM7_DX[i as usize] as libc::c_ulong),\n                        )\n                        .wrapping_mul(bytewidth);\n                    b= 0 as libc::c_int as libc::c_uint;\n                    while (b as libc::c_ulong) < bytewidth {\n                        *out\n                            .offset(\n                                pixeloutstart.wrapping_add(b as libc::c_ulong) as isize,\n                            ) = *in_0\n                            .offset(\n                                pixelinstart.wrapping_add(b as libc::c_ulong) as isize,\n                            );\n                        b= b.wrapping_add(1);\n                    }\n                    x= x.wrapping_add(1);\n                }\n                y= y.wrapping_add(1);\n            }\n            i= i.wrapping_add(1);\n        }\n    } else {\n        i= 0 as libc::c_int as libc::c_uint;\n        while i != 7 as libc::c_int as libc::c_uint {\n            let mut x_0: libc::c_uint = 0;\n            let mut y_0: libc::c_uint = 0;\n            let mut b_0: libc::c_uint = 0;\n            let mut ilinebits = bpp.wrapping_mul(passw[i as usize]);\n            let mut olinebits = bpp.wrapping_mul(w);\n            let mut obp: size_t = 0;\n            let mut ibp: size_t = 0;\n            y_0= 0 as libc::c_int as libc::c_uint;\n            while y_0 < passh[i as usize] {\n                x_0= 0 as libc::c_int as libc::c_uint;\n                while x_0 < passw[i as usize] {\n                    ibp= (8 as libc::c_int as libc::c_ulong)\n                        .wrapping_mul(passstart[i as usize])\n                        .wrapping_add(\n                            y_0\n                                .wrapping_mul(ilinebits)\n                                .wrapping_add(x_0.wrapping_mul(bpp)) as libc::c_ulong,\n                        );\n                    obp= (crate::src::lodepng::ADAM7_IY[i as usize] as libc::c_ulong)\n                        .wrapping_add(\n                            (y_0 as size_t)\n                                .wrapping_mul(crate::src::lodepng::ADAM7_DY[i as usize] as libc::c_ulong),\n                        )\n                        .wrapping_mul(olinebits as libc::c_ulong)\n                        .wrapping_add(\n                            (crate::src::lodepng::ADAM7_IX[i as usize] as libc::c_ulong)\n                                .wrapping_add(\n                                    (x_0 as size_t)\n                                        .wrapping_mul(crate::src::lodepng::ADAM7_DX[i as usize] as libc::c_ulong),\n                                )\n                                .wrapping_mul(bpp as libc::c_ulong),\n                        );\n                    b_0= 0 as libc::c_int as libc::c_uint;\n                    while b_0 < bpp {\n                        let mut bit = readBitFromReversedStream(Some(&mut ibp), in_0);\n                        setBitOfReversedStream(Some(&mut obp), out, bit);\n                        b_0= b_0.wrapping_add(1);\n                    }\n                    x_0= x_0.wrapping_add(1);\n                }\n                y_0= y_0.wrapping_add(1);\n            }\n            i= i.wrapping_add(1);\n        }\n    };\n}","src::lodepng::readBitFromReversedStream":"unsafe extern \"C\" fn readBitFromReversedStream(\n    mut bitpointer: Option<&mut size_t>,\n    mut bitstream: *const libc::c_uchar,\n) -> libc::c_uchar {\n    let mut result = (*bitstream.offset(((*bitpointer.as_deref().unwrap()) >> 3 as libc::c_int) as isize)\n        as libc::c_int\n        >> (7 as libc::c_int as libc::c_ulong)\n            .wrapping_sub((*bitpointer.as_deref().unwrap()) & 0x7 as libc::c_int as libc::c_ulong)\n        & 1 as libc::c_int) as libc::c_uchar;\n    *bitpointer.as_deref_mut().unwrap()= (*bitpointer.as_deref().unwrap()).wrapping_add(1);\n    return result;\n}","src::lodepng::lodepng_chunk_ancillary":"pub unsafe extern \"C\" fn lodepng_chunk_ancillary(\n    mut chunk: *const libc::c_uchar,\n) -> libc::c_uchar {\n    return (*chunk.offset(4 as libc::c_int as isize) as libc::c_int & 32 as libc::c_int\n        != 0 as libc::c_int) as libc::c_int as libc::c_uchar;\n}","src::lodepng::addUnknownChunks":"unsafe extern \"C\" fn addUnknownChunks(\n    mut out: *mut ucvector,\n    mut data: *mut libc::c_uchar,\n    mut datasize: size_t,\n) -> libc::c_uint {\n    let mut inchunk = data;\n    while (inchunk.offset_from(data) as libc::c_long as size_t) < datasize {\n        let mut error = lodepng_chunk_append(\n            core::ptr::addr_of_mut!((*out).data),\n            core::ptr::addr_of_mut!((*out).size),\n            inchunk,\n        );\n        if error != 0 {\n            return error;\n        }\n        (*out).allocsize= (*out).size;\n        inchunk= lodepng_chunk_next(inchunk, data.offset(datasize as isize));\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::uivector_resize":"unsafe extern \"C\" fn uivector_resize(\n    mut p: *mut uivector,\n    mut size: size_t,\n) -> libc::c_uint {\n    let mut allocsize = size\n        .wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong);\n    if allocsize > (*p).allocsize {\n        let mut newsize = allocsize.wrapping_add((*p).allocsize >> 1 as libc::c_uint);\n        let mut data = lodepng_realloc((*p).data as *mut libc::c_void, newsize);\n        if !data.is_null() {\n            (*p).allocsize= newsize;\n            (*p).data= data as *mut libc::c_uint;\n        } else {();\n            return 0 as libc::c_int as libc::c_uint\n        }\n    }\n    (*p).size= size;\n    return 1 as libc::c_int as libc::c_uint;\n}","src::lodepng::addChunk_zTXt":"unsafe extern \"C\" fn addChunk_zTXt(\n    mut out: *mut ucvector,\n    mut keyword: *const libc::c_char,\n    mut textstring: *const libc::c_char,\n    mut zlibsettings: *mut LodePNGCompressSettings,\n) -> libc::c_uint {\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut chunk = 0 as *mut libc::c_uchar;\n    let mut compressed = 0 as *mut libc::c_uchar;\n    let mut compressedsize = 0 as libc::c_int as size_t;\n    let mut textsize = lodepng_strlen(textstring);\n    let mut keysize = lodepng_strlen(keyword);\n    if keysize < 1 as libc::c_int as libc::c_ulong\n        || keysize > 79 as libc::c_int as libc::c_ulong\n    {\n        return 89 as libc::c_int as libc::c_uint;\n    }\n    error= zlib_compress(\n        core::ptr::addr_of_mut!(compressed),\n        core::ptr::addr_of_mut!(compressedsize),\n        textstring as *const libc::c_uchar,\n        textsize,\n        zlibsettings,\n    );\n    if error == 0 {\n        let mut size = keysize\n            .wrapping_add(2 as libc::c_int as libc::c_ulong)\n            .wrapping_add(compressedsize);\n        error= lodepng_chunk_init(\n            core::ptr::addr_of_mut!(chunk),\n            out,\n            size as libc::c_uint,\n            b\"zTXt\\0\" as *const u8 as *const libc::c_char,\n        );\n    }\n    if error == 0 {\n        lodepng_memcpy(\n            chunk.offset(8 as libc::c_int as isize) as *mut libc::c_void,\n            keyword as *const libc::c_void,\n            keysize,\n        );\n        *chunk\n            .offset(\n                (8 as libc::c_int as libc::c_ulong).wrapping_add(keysize) as isize,\n            ) = 0 as libc::c_int as libc::c_uchar;\n        *chunk\n            .offset(\n                (9 as libc::c_int as libc::c_ulong).wrapping_add(keysize) as isize,\n            ) = 0 as libc::c_int as libc::c_uchar;\n        lodepng_memcpy(\n            chunk.offset(10 as libc::c_int as isize).offset(keysize as isize)\n                as *mut libc::c_void,\n            compressed as *const u8 as *const libc::c_void,\n            compressedsize,\n        );\n        lodepng_chunk_generate_crc(chunk);\n    }\n    lodepng_free(compressed as *mut libc::c_void);\n    return error;\n}","src::lodepng::uivector_init":"unsafe extern \"C\" fn uivector_init(mut p: Option<&mut uivector>) {\n    (*p.as_deref_mut().unwrap()).data= 0 as *mut libc::c_uint;\n    (*p.as_deref_mut().unwrap()).allocsize= 0 as libc::c_int as size_t; (*p.as_deref_mut().unwrap()).size= (*p.as_deref().unwrap()).allocsize;\n}","src::lodepng::getValueRequiredBits":"unsafe extern \"C\" fn getValueRequiredBits(mut value: libc::c_uchar) -> libc::c_uint {\n    if value as libc::c_int == 0 as libc::c_int\n        || value as libc::c_int == 255 as libc::c_int\n    {\n        return 1 as libc::c_int as libc::c_uint;\n    }\n    if value as libc::c_int % 17 as libc::c_int == 0 as libc::c_int {\n        return (if value as libc::c_int % 85 as libc::c_int == 0 as libc::c_int {\n            2 as libc::c_int\n        } else {\n            4 as libc::c_int\n        }) as libc::c_uint;\n    }\n    return 8 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_state_init":"pub unsafe extern \"C\" fn lodepng_state_init(mut state: Option<&mut LodePNGState>) {\n    lodepng_decoder_settings_init(Some(&mut (*state.as_deref_mut().unwrap()).decoder));\n    lodepng_encoder_settings_init(Some(&mut (*state.as_deref_mut().unwrap()).encoder));\n    lodepng_color_mode_init(Some(&mut (*state.as_deref_mut().unwrap()).info_raw));\n    lodepng_info_init(Some(&mut (*state.as_deref_mut().unwrap()).info_png));\n    (*state.as_deref_mut().unwrap()).error= 1 as libc::c_int as libc::c_uint;\n}","src::lodepng::addChunk_tIME":"unsafe extern \"C\" fn addChunk_tIME(\n    mut out: *mut ucvector,\n    mut time: *const LodePNGTime,\n) -> libc::c_uint {\n    let mut chunk = 0 as *mut libc::c_uchar;\n    let mut error = lodepng_chunk_init(\n        core::ptr::addr_of_mut!(chunk),\n        out,\n        7 as libc::c_int as libc::c_uint,\n        b\"tIME\\0\" as *const u8 as *const libc::c_char,\n    );\n    if error != 0 {\n        return error;\n    }\n    *chunk\n        .offset(\n            8 as libc::c_int as isize,\n        ) = ((*time).year >> 8 as libc::c_int) as libc::c_uchar;\n    *chunk\n        .offset(\n            9 as libc::c_int as isize,\n        ) = ((*time).year & 255 as libc::c_int as libc::c_uint) as libc::c_uchar;\n    *chunk.offset(10 as libc::c_int as isize) = (*time).month as libc::c_uchar;\n    *chunk.offset(11 as libc::c_int as isize) = (*time).day as libc::c_uchar;\n    *chunk.offset(12 as libc::c_int as isize) = (*time).hour as libc::c_uchar;\n    *chunk.offset(13 as libc::c_int as isize) = (*time).minute as libc::c_uchar;\n    *chunk.offset(14 as libc::c_int as isize) = (*time).second as libc::c_uchar;\n    lodepng_chunk_generate_crc(chunk);\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::postProcessScanlines":"unsafe extern \"C\" fn postProcessScanlines(\n    mut out: *mut libc::c_uchar,\n    mut in_0: *mut libc::c_uchar,\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n    mut info_png: *const LodePNGInfo,\n) -> libc::c_uint {\n    let mut bpp = lodepng_get_bpp(&(*info_png).color);\n    if bpp == 0 as libc::c_int as libc::c_uint {\n        return 31 as libc::c_int as libc::c_uint;\n    }\n    if (*info_png).interlace_method == 0 as libc::c_int as libc::c_uint {\n        if bpp < 8 as libc::c_int as libc::c_uint\n            && w.wrapping_mul(bpp)\n                != w\n                    .wrapping_mul(bpp)\n                    .wrapping_add(7 as libc::c_uint)\n                    .wrapping_div(8 as libc::c_uint)\n                    .wrapping_mul(8 as libc::c_uint)\n        {\n            let mut error = unfilter(in_0, in_0, w, h, bpp);\n            if error != 0 {\n                return error;\n            }\n            removePaddingBits(\n                out,\n                in_0,\n                w.wrapping_mul(bpp) as size_t,\n                w\n                    .wrapping_mul(bpp)\n                    .wrapping_add(7 as libc::c_uint)\n                    .wrapping_div(8 as libc::c_uint)\n                    .wrapping_mul(8 as libc::c_uint) as size_t,\n                h,\n            );\n        } else {\n            let mut error_0 = unfilter(out, in_0, w, h, bpp);\n            if error_0 != 0 {\n                return error_0;\n            }\n        }\n    } else {\n        let mut passw: [libc::c_uint; 7] = [0; 7];\n        let mut passh: [libc::c_uint; 7] = [0; 7];\n        let mut filter_passstart: [size_t; 8] = [0; 8];\n        let mut padded_passstart: [size_t; 8] = [0; 8];\n        let mut passstart: [size_t; 8] = [0; 8];\n        let mut i: libc::c_uint = 0;\n        Adam7_getpassvalues(\n            passw.as_mut_ptr(),\n            passh.as_mut_ptr(),\n            filter_passstart.as_mut_ptr(),\n            padded_passstart.as_mut_ptr(),\n            passstart.as_mut_ptr(),\n            w,\n            h,\n            bpp,\n        );\n        i= 0 as libc::c_int as libc::c_uint;\n        while i != 7 as libc::c_int as libc::c_uint {\n            let mut error_1 = unfilter(\n                core::ptr::addr_of_mut!(*in_0\n                    .offset(*padded_passstart.as_mut_ptr().offset(i as isize) as isize)),\n                core::ptr::addr_of_mut!(*in_0\n                    .offset(*filter_passstart.as_mut_ptr().offset(i as isize) as isize)),\n                passw[i as usize],\n                passh[i as usize],\n                bpp,\n            );\n            if error_1 != 0 {\n                return error_1;\n            }\n            if bpp < 8 as libc::c_int as libc::c_uint {\n                removePaddingBits(\n                    core::ptr::addr_of_mut!(*in_0\n                        .offset(*passstart.as_mut_ptr().offset(i as isize) as isize)),\n                    core::ptr::addr_of_mut!(*in_0\n                        .offset(\n                            *padded_passstart.as_mut_ptr().offset(i as isize) as isize,\n                        )),\n                    passw[i as usize].wrapping_mul(bpp) as size_t,\n                    passw[i as usize]\n                        .wrapping_mul(bpp)\n                        .wrapping_add(7 as libc::c_uint)\n                        .wrapping_div(8 as libc::c_uint)\n                        .wrapping_mul(8 as libc::c_uint) as size_t,\n                    passh[i as usize],\n                );\n            }\n            i= i.wrapping_add(1);\n        }\n        Adam7_deinterlace(out, in_0, w, h, bpp);\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::preProcessScanlines":"unsafe extern \"C\" fn preProcessScanlines(\n    mut out: Option<&mut *mut /* owning */ libc::c_uchar>,\n    mut outsize: Option<&mut size_t>,\n    mut in_0: *const libc::c_uchar,\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n    mut info_png: *const LodePNGInfo,\n    mut settings: *const LodePNGEncoderSettings,\n) -> libc::c_uint {\n    let mut bpp = lodepng_get_bpp(&(*info_png).color);\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    if (*info_png).interlace_method == 0 as libc::c_int as libc::c_uint {\n        *outsize.as_deref_mut().unwrap()= h\n            .wrapping_add(\n                h\n                    .wrapping_mul(\n                        w\n                            .wrapping_mul(bpp)\n                            .wrapping_add(7 as libc::c_uint)\n                            .wrapping_div(8 as libc::c_uint),\n                    ),\n            ) as size_t;\n        *out.as_deref_mut().unwrap()= lodepng_malloc((*outsize.as_deref().unwrap())) as *mut libc::c_uchar;\n        if (*out.as_deref().unwrap()).is_null() && (*outsize.as_deref().unwrap()) != 0 {\n            error= 83 as libc::c_int as libc::c_uint;\n        }\n        if error == 0 {\n            if bpp < 8 as libc::c_int as libc::c_uint\n                && w.wrapping_mul(bpp)\n                    != w\n                        .wrapping_mul(bpp)\n                        .wrapping_add(7 as libc::c_uint)\n                        .wrapping_div(8 as libc::c_uint)\n                        .wrapping_mul(8 as libc::c_uint)\n            {\n                let mut padded = lodepng_malloc(\n                    h\n                        .wrapping_mul(\n                            w\n                                .wrapping_mul(bpp)\n                                .wrapping_add(7 as libc::c_uint)\n                                .wrapping_div(8 as libc::c_uint),\n                        ) as size_t,\n                ) as *mut libc::c_uchar;\n                if padded.is_null() {();\n                    error= 83 as libc::c_int as libc::c_uint;\n                }\n                if error == 0 {\n                    addPaddingBits(\n                        padded,\n                        in_0,\n                        w\n                            .wrapping_mul(bpp)\n                            .wrapping_add(7 as libc::c_uint)\n                            .wrapping_div(8 as libc::c_uint)\n                            .wrapping_mul(8 as libc::c_uint) as size_t,\n                        w.wrapping_mul(bpp) as size_t,\n                        h,\n                    );\n                    error= filter((*out.as_deref().unwrap()), padded as *const u8, w, h, &(*info_png).color, settings);\n                }\n                lodepng_free(padded as *mut libc::c_void);\n            } else {\n                error= filter((*out.as_deref().unwrap()), in_0, w, h, &(*info_png).color, settings);\n            }\n        }\n    } else {\n        let mut passw: [libc::c_uint; 7] = [0; 7];\n        let mut passh: [libc::c_uint; 7] = [0; 7];\n        let mut filter_passstart: [size_t; 8] = [0; 8];\n        let mut padded_passstart: [size_t; 8] = [0; 8];\n        let mut passstart: [size_t; 8] = [0; 8];\n        let mut adam7 = 0 as *mut libc::c_uchar;\n        Adam7_getpassvalues(\n            passw.as_mut_ptr(),\n            passh.as_mut_ptr(),\n            filter_passstart.as_mut_ptr(),\n            padded_passstart.as_mut_ptr(),\n            passstart.as_mut_ptr(),\n            w,\n            h,\n            bpp,\n        );\n        *outsize.as_deref_mut().unwrap()= filter_passstart[7 as libc::c_int as usize];\n        *out.as_deref_mut().unwrap()= lodepng_malloc((*outsize.as_deref().unwrap())) as *mut libc::c_uchar;\n        if (*out.as_deref().unwrap()).is_null() {();\n            error= 83 as libc::c_int as libc::c_uint;\n        }\n        adam7= lodepng_malloc(passstart[7 as libc::c_int as usize])\n            as *mut libc::c_uchar;\n        if adam7.is_null() && passstart[7 as libc::c_int as usize] != 0 {\n            error= 83 as libc::c_int as libc::c_uint;\n        }\n        if error == 0 {\n            let mut i: libc::c_uint = 0;\n            Adam7_interlace(adam7, in_0, w, h, bpp);\n            i= 0 as libc::c_int as libc::c_uint;\n            while i != 7 as libc::c_int as libc::c_uint {\n                if bpp < 8 as libc::c_int as libc::c_uint {\n                    let mut padded_0 = lodepng_malloc(\n                        padded_passstart[i\n                            .wrapping_add(1 as libc::c_int as libc::c_uint) as usize]\n                            .wrapping_sub(padded_passstart[i as usize]),\n                    ) as *mut libc::c_uchar;\n                    if padded_0.is_null() {();\n                        error= 83 as libc::c_int as libc::c_uint;\n                        break;\n                    } else {\n                        addPaddingBits(\n                            padded_0,\n                            core::ptr::addr_of_mut!(*adam7\n                                .offset(\n                                    *passstart.as_mut_ptr().offset(i as isize) as isize,\n                                )),\n                            passw[i as usize]\n                                .wrapping_mul(bpp)\n                                .wrapping_add(7 as libc::c_uint)\n                                .wrapping_div(8 as libc::c_uint)\n                                .wrapping_mul(8 as libc::c_uint) as size_t,\n                            passw[i as usize].wrapping_mul(bpp) as size_t,\n                            passh[i as usize],\n                        );\n                        error= filter(\n                            core::ptr::addr_of_mut!(*(*out.as_deref().unwrap())\n                                .offset(\n                                    *filter_passstart.as_mut_ptr().offset(i as isize) as isize,\n                                )),\n                            padded_0 as *const u8,\n                            passw[i as usize],\n                            passh[i as usize],\n                            &(*info_png).color,\n                            settings,\n                        );\n                        lodepng_free(padded_0 as *mut libc::c_void);\n                    }\n                } else {\n                    error= filter(\n                        core::ptr::addr_of_mut!(*(*out.as_deref().unwrap())\n                            .offset(\n                                *filter_passstart.as_mut_ptr().offset(i as isize) as isize,\n                            )),\n                        core::ptr::addr_of_mut!(*adam7\n                            .offset(\n                                *padded_passstart.as_mut_ptr().offset(i as isize) as isize,\n                            )),\n                        passw[i as usize],\n                        passh[i as usize],\n                        &(*info_png).color,\n                        settings,\n                    );\n                }\n                if error != 0 {\n                    break;\n                }\n                i= i.wrapping_add(1);\n            }\n        }\n        lodepng_free(adam7 as *mut libc::c_void);\n    }\n    return error;\n}","src::lodepng::paethPredictor":"unsafe extern \"C\" fn paethPredictor(\n    mut a: libc::c_short,\n    mut b: libc::c_short,\n    mut c: libc::c_short,\n) -> libc::c_uchar {\n    let mut pa = (if (b as libc::c_int - c as libc::c_int) < 0 as libc::c_int {\n        -(b as libc::c_int - c as libc::c_int)\n    } else {\n        b as libc::c_int - c as libc::c_int\n    }) as libc::c_short;\n    let mut pb = (if (a as libc::c_int - c as libc::c_int) < 0 as libc::c_int {\n        -(a as libc::c_int - c as libc::c_int)\n    } else {\n        a as libc::c_int - c as libc::c_int\n    }) as libc::c_short;\n    let mut pc = (if (a as libc::c_int + b as libc::c_int - c as libc::c_int\n        - c as libc::c_int) < 0 as libc::c_int\n    {\n        -(a as libc::c_int + b as libc::c_int - c as libc::c_int - c as libc::c_int)\n    } else {\n        a as libc::c_int + b as libc::c_int - c as libc::c_int - c as libc::c_int\n    }) as libc::c_short;\n    if (pb as libc::c_int) < pa as libc::c_int {\n        a= b;\n        pa= pb;\n    }\n    return (if (pc as libc::c_int) < pa as libc::c_int {\n        c as libc::c_int\n    } else {\n        a as libc::c_int\n    }) as libc::c_uchar;\n}","src::lodepng::lodepng_chunk_generate_crc":"pub unsafe extern \"C\" fn lodepng_chunk_generate_crc(mut chunk: *mut libc::c_uchar) {\n    let mut length = lodepng_chunk_length(chunk);\n    let mut CRC = lodepng_crc32(\n        core::ptr::addr_of_mut!(*chunk.offset(4 as libc::c_int as isize)),\n        length.wrapping_add(4 as libc::c_int as libc::c_uint) as size_t,\n    );\n    lodepng_set32bitInt(\n        chunk.offset(8 as libc::c_int as isize).offset(length as isize),\n        CRC,\n    );\n}","src::lodepng::Adam7_interlace":"unsafe extern \"C\" fn Adam7_interlace(\n    mut out: *mut libc::c_uchar,\n    mut in_0: *const libc::c_uchar,\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n    mut bpp: libc::c_uint,\n) {\n    let mut passw: [libc::c_uint; 7] = [0; 7];\n    let mut passh: [libc::c_uint; 7] = [0; 7];\n    let mut filter_passstart: [size_t; 8] = [0; 8];\n    let mut padded_passstart: [size_t; 8] = [0; 8];\n    let mut passstart: [size_t; 8] = [0; 8];\n    let mut i: libc::c_uint = 0;\n    Adam7_getpassvalues(\n        passw.as_mut_ptr(),\n        passh.as_mut_ptr(),\n        filter_passstart.as_mut_ptr(),\n        padded_passstart.as_mut_ptr(),\n        passstart.as_mut_ptr(),\n        w,\n        h,\n        bpp,\n    );\n    if bpp >= 8 as libc::c_int as libc::c_uint {\n        i= 0 as libc::c_int as libc::c_uint;\n        while i != 7 as libc::c_int as libc::c_uint {\n            let mut x: libc::c_uint = 0;\n            let mut y: libc::c_uint = 0;\n            let mut b: libc::c_uint = 0;\n            let mut bytewidth = bpp.wrapping_div(8 as libc::c_uint) as size_t;\n            y= 0 as libc::c_int as libc::c_uint;\n            while y < passh[i as usize] {\n                x= 0 as libc::c_int as libc::c_uint;\n                while x < passw[i as usize] {\n                    let mut pixelinstart = (crate::src::lodepng::ADAM7_IY[i as usize]\n                        .wrapping_add(y.wrapping_mul(crate::src::lodepng::ADAM7_DY[i as usize]))\n                        .wrapping_mul(w)\n                        .wrapping_add(crate::src::lodepng::ADAM7_IX[i as usize])\n                        .wrapping_add(x.wrapping_mul(crate::src::lodepng::ADAM7_DX[i as usize]))\n                        as libc::c_ulong)\n                        .wrapping_mul(bytewidth);\n                    let mut pixeloutstart = passstart[i as usize]\n                        .wrapping_add(\n                            (y.wrapping_mul(passw[i as usize]).wrapping_add(x)\n                                as libc::c_ulong)\n                                .wrapping_mul(bytewidth),\n                        );\n                    b= 0 as libc::c_int as libc::c_uint;\n                    while (b as libc::c_ulong) < bytewidth {\n                        *out\n                            .offset(\n                                pixeloutstart.wrapping_add(b as libc::c_ulong) as isize,\n                            ) = *in_0\n                            .offset(\n                                pixelinstart.wrapping_add(b as libc::c_ulong) as isize,\n                            );\n                        b= b.wrapping_add(1);\n                    }\n                    x= x.wrapping_add(1);\n                }\n                y= y.wrapping_add(1);\n            }\n            i= i.wrapping_add(1);\n        }\n    } else {\n        i= 0 as libc::c_int as libc::c_uint;\n        while i != 7 as libc::c_int as libc::c_uint {\n            let mut x_0: libc::c_uint = 0;\n            let mut y_0: libc::c_uint = 0;\n            let mut b_0: libc::c_uint = 0;\n            let mut ilinebits = bpp.wrapping_mul(passw[i as usize]);\n            let mut olinebits = bpp.wrapping_mul(w);\n            let mut obp: size_t = 0;\n            let mut ibp: size_t = 0;\n            y_0= 0 as libc::c_int as libc::c_uint;\n            while y_0 < passh[i as usize] {\n                x_0= 0 as libc::c_int as libc::c_uint;\n                while x_0 < passw[i as usize] {\n                    ibp= crate::src::lodepng::ADAM7_IY[i as usize]\n                        .wrapping_add(y_0.wrapping_mul(crate::src::lodepng::ADAM7_DY[i as usize]))\n                        .wrapping_mul(olinebits)\n                        .wrapping_add(\n                            crate::src::lodepng::ADAM7_IX[i as usize]\n                                .wrapping_add(x_0.wrapping_mul(crate::src::lodepng::ADAM7_DX[i as usize]))\n                                .wrapping_mul(bpp),\n                        ) as size_t;\n                    obp= (8 as libc::c_int as libc::c_ulong)\n                        .wrapping_mul(passstart[i as usize])\n                        .wrapping_add(\n                            y_0\n                                .wrapping_mul(ilinebits)\n                                .wrapping_add(x_0.wrapping_mul(bpp)) as libc::c_ulong,\n                        );\n                    b_0= 0 as libc::c_int as libc::c_uint;\n                    while b_0 < bpp {\n                        let mut bit = readBitFromReversedStream(Some(&mut ibp), in_0);\n                        setBitOfReversedStream(Some(&mut obp), out, bit);\n                        b_0= b_0.wrapping_add(1);\n                    }\n                    x_0= x_0.wrapping_add(1);\n                }\n                y_0= y_0.wrapping_add(1);\n            }\n            i= i.wrapping_add(1);\n        }\n    };\n}","src::lodepng::generateFixedDistanceTree":"unsafe extern \"C\" fn generateFixedDistanceTree(\n    mut tree: Option<&mut HuffmanTree>,\n) -> libc::c_uint {\n    let mut i: libc::c_uint = 0;\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut bitlen = lodepng_malloc(\n        (32 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong),\n    ) as *mut libc::c_uint;\n    if bitlen.is_null() {();\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    i= 0 as libc::c_int as libc::c_uint;\n    while i != 32 as libc::c_int as libc::c_uint {\n        *bitlen.offset(i as isize) = 5 as libc::c_int as libc::c_uint;\n        i= i.wrapping_add(1);\n    }\n    error= HuffmanTree_makeFromLengths(\n        tree.as_deref_mut(),\n        bitlen as *const u32,\n        32 as libc::c_int as size_t,\n        15 as libc::c_int as libc::c_uint,\n    );\n    lodepng_free(bitlen as *mut libc::c_void);\n    return error;\n}","src::lodepng::addChunk_sRGB":"unsafe extern \"C\" fn addChunk_sRGB(\n    mut out: *mut ucvector,\n    mut info: *const LodePNGInfo,\n) -> libc::c_uint {\n    let mut data = (*info).srgb_intent as libc::c_uchar;\n    return lodepng_chunk_createv(\n        out,\n        1 as libc::c_int as libc::c_uint,\n        b\"sRGB\\0\" as *const u8 as *const libc::c_char,\n        core::ptr::addr_of!(data),\n    );\n}","src::lodepng::LodePNGUnknownChunks_init":"unsafe extern \"C\" fn LodePNGUnknownChunks_init(mut info: Option<&mut LodePNGInfo>) {\n    let mut i: libc::c_uint = 0;\n    i= 0 as libc::c_int as libc::c_uint;\n    while i != 3 as libc::c_int as libc::c_uint {\n        (*info.as_deref_mut().unwrap()).unknown_chunks_data[i as usize]= 0 as *mut libc::c_uchar;\n        i= i.wrapping_add(1);\n    }\n    i= 0 as libc::c_int as libc::c_uint;\n    while i != 3 as libc::c_int as libc::c_uint {\n        (*info.as_deref_mut().unwrap()).unknown_chunks_size[i as usize]= 0 as libc::c_int as size_t;\n        i= i.wrapping_add(1);\n    }\n}","src::lodepng::lodepng_clear_text":"pub unsafe extern \"C\" fn lodepng_clear_text(mut info: Option<&mut LodePNGInfo>) {\n    LodePNGText_cleanup(info.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()));\n}","src::lodepng::LodePNGText_init":"unsafe extern \"C\" fn LodePNGText_init(mut info: Option<&mut LodePNGInfo>) {\n    (*info.as_deref_mut().unwrap()).text_num= 0 as libc::c_int as size_t;\n    (*info.as_deref_mut().unwrap()).text_keys= 0 as *mut *mut libc::c_char;\n    (*info.as_deref_mut().unwrap()).text_strings= 0 as *mut *mut libc::c_char;\n}","src::lodepng::lodepng_get_raw_size_idat":"unsafe extern \"C\" fn lodepng_get_raw_size_idat(\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n    mut bpp: libc::c_uint,\n) -> size_t {\n    let mut line = (w.wrapping_div(8 as libc::c_uint) as size_t)\n        .wrapping_mul(bpp as libc::c_ulong)\n        .wrapping_add(1 as libc::c_uint as libc::c_ulong)\n        .wrapping_add(\n            (w & 7 as libc::c_uint)\n                .wrapping_mul(bpp)\n                .wrapping_add(7 as libc::c_uint)\n                .wrapping_div(8 as libc::c_uint) as libc::c_ulong,\n        );\n    return (h as size_t).wrapping_mul(line);\n}","src::lodepng::lodepng_get_raw_size_lct":"unsafe extern \"C\" fn lodepng_get_raw_size_lct(\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n    mut colortype: LodePNGColorType,\n    mut bitdepth: libc::c_uint,\n) -> size_t {\n    let mut bpp = lodepng_get_bpp_lct(colortype, bitdepth) as size_t;\n    let mut n = (w as size_t).wrapping_mul(h as size_t);\n    return n\n        .wrapping_div(8 as libc::c_uint as libc::c_ulong)\n        .wrapping_mul(bpp)\n        .wrapping_add(\n            (n & 7 as libc::c_uint as libc::c_ulong)\n                .wrapping_mul(bpp)\n                .wrapping_add(7 as libc::c_uint as libc::c_ulong)\n                .wrapping_div(8 as libc::c_uint as libc::c_ulong),\n        );\n}","src::lodepng::readChunk_pHYs":"unsafe extern \"C\" fn readChunk_pHYs(\n    mut info: *mut LodePNGInfo,\n    mut data: *const libc::c_uchar,\n    mut chunkLength: size_t,\n) -> libc::c_uint {\n    if chunkLength != 9 as libc::c_int as libc::c_ulong {\n        return 74 as libc::c_int as libc::c_uint;\n    }\n    (*info).phys_defined= 1 as libc::c_int as libc::c_uint;\n    (*info).phys_x= (16777216 as libc::c_uint)\n        .wrapping_mul(*data.offset(0 as libc::c_int as isize) as libc::c_uint)\n        .wrapping_add(\n            (65536 as libc::c_uint)\n                .wrapping_mul(*data.offset(1 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(\n            (256 as libc::c_uint)\n                .wrapping_mul(*data.offset(2 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(*data.offset(3 as libc::c_int as isize) as libc::c_uint);\n    (*info).phys_y= (16777216 as libc::c_uint)\n        .wrapping_mul(*data.offset(4 as libc::c_int as isize) as libc::c_uint)\n        .wrapping_add(\n            (65536 as libc::c_uint)\n                .wrapping_mul(*data.offset(5 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(\n            (256 as libc::c_uint)\n                .wrapping_mul(*data.offset(6 as libc::c_int as isize) as libc::c_uint),\n        )\n        .wrapping_add(*data.offset(7 as libc::c_int as isize) as libc::c_uint);\n    (*info).phys_unit= *data.offset(8 as libc::c_int as isize) as libc::c_uint;\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::getTreeInflateFixed":"unsafe extern \"C\" fn getTreeInflateFixed(\n    mut tree_ll: *mut HuffmanTree,\n    mut tree_d: *mut HuffmanTree,\n) -> libc::c_uint {\n    let mut error = generateFixedLitLenTree(tree_ll.as_mut());\n    if error != 0 {\n        return error;\n    }\n    return generateFixedDistanceTree(tree_d.as_mut());\n}","src::lodepng::lodepng_get_bpp":"pub unsafe extern \"C\" fn lodepng_get_bpp(\n    mut info: *const LodePNGColorMode,\n) -> libc::c_uint {\n    return lodepng_get_bpp_lct((*info).colortype, (*info).bitdepth);\n}","src::lodepng::lodepng_color_mode_equal":"unsafe extern \"C\" fn lodepng_color_mode_equal(\n    mut a: *const LodePNGColorMode,\n    mut b: *const LodePNGColorMode,\n) -> libc::c_int {\n    let mut i: size_t = 0;\n    if (*a).colortype as libc::c_uint != (*b).colortype as libc::c_uint {\n        return 0 as libc::c_int;\n    }\n    if (*a).bitdepth != (*b).bitdepth {\n        return 0 as libc::c_int;\n    }\n    if (*a).key_defined != (*b).key_defined {\n        return 0 as libc::c_int;\n    }\n    if (*a).key_defined != 0 {\n        if (*a).key_r != (*b).key_r {\n            return 0 as libc::c_int;\n        }\n        if (*a).key_g != (*b).key_g {\n            return 0 as libc::c_int;\n        }\n        if (*a).key_b != (*b).key_b {\n            return 0 as libc::c_int;\n        }\n    }\n    if (*a).palettesize != (*b).palettesize {\n        return 0 as libc::c_int;\n    }\n    i= 0 as libc::c_int as size_t;\n    while i != (*a).palettesize.wrapping_mul(4 as libc::c_int as libc::c_ulong) {\n        if *(*a).palette.offset(i as isize) as libc::c_int\n            != *(*b).palette.offset(i as isize) as libc::c_int\n        {\n            return 0 as libc::c_int;\n        }\n        i= i.wrapping_add(1);\n    }\n    return 1 as libc::c_int;\n}","src::lodepng::lodepng_inflate":"pub unsafe extern \"C\" fn lodepng_inflate(\n    mut out: Option<&mut *mut libc::c_uchar>,\n    mut outsize: Option<&mut size_t>,\n    mut in_0: *const libc::c_uchar,\n    mut insize: size_t,\n    mut settings: *const LodePNGDecompressSettings,\n) -> libc::c_uint {\n    let mut v = ucvector_init((*out.as_deref().unwrap()), (*outsize.as_deref().unwrap()));\n    let mut error = lodepng_inflatev(core::ptr::addr_of_mut!(v), in_0, insize, settings);\n    *out.as_deref_mut().unwrap()= v.data;\n    *outsize.as_deref_mut().unwrap()= v.size;\n    return error;\n}","src::lodepng::LodePNGText_cleanup":"unsafe extern \"C\" fn LodePNGText_cleanup(mut info: *mut LodePNGInfo) {\n    let mut i: size_t = 0;\n    i= 0 as libc::c_int as size_t;\n    while i != (*info).text_num {\n        string_cleanup(core::ptr::addr_of_mut!(*(*info).text_keys.offset(i as isize)));\n        string_cleanup(core::ptr::addr_of_mut!(*(*info).text_strings.offset(i as isize)));\n        i= i.wrapping_add(1);\n    }\n    lodepng_free((*info).text_keys as *mut libc::c_void);\n    lodepng_free((*info).text_strings as *mut libc::c_void);\n}","src::lodepng::lodepng_encode24_file":"pub unsafe extern \"C\" fn lodepng_encode24_file(\n    mut filename: *const libc::c_char,\n    mut image: *const libc::c_uchar,\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n) -> libc::c_uint {\n    return lodepng_encode_file(\n        filename,\n        image,\n        w,\n        h,\n        LCT_RGB,\n        8 as libc::c_int as libc::c_uint,\n    );\n}","src::lodepng::getPixelColorRGBA8":"unsafe extern \"C\" fn getPixelColorRGBA8(\n    mut r: Option<&mut libc::c_uchar>,\n    mut g: Option<&mut libc::c_uchar>,\n    mut b: Option<&mut libc::c_uchar>,\n    mut a: Option<&mut libc::c_uchar>,\n    mut in_0: *const libc::c_uchar,\n    mut i: size_t,\n    mut mode: *const LodePNGColorMode,\n) {\n    if (*mode).colortype as libc::c_uint == LCT_GREY as libc::c_int as libc::c_uint {\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            *b.as_deref_mut().unwrap()= *in_0.offset(i as isize);\n            *g.as_deref_mut().unwrap()= (*b.as_deref().unwrap());\n            *r.as_deref_mut().unwrap()= (*g.as_deref().unwrap());\n            if (*mode).key_defined != 0 && (*r.as_deref().unwrap()) as libc::c_uint == (*mode).key_r {\n                *a.as_deref_mut().unwrap()= 0 as libc::c_int as libc::c_uchar;\n            } else {\n                *a.as_deref_mut().unwrap()= 255 as libc::c_int as libc::c_uchar;\n            }\n        } else if (*mode).bitdepth == 16 as libc::c_int as libc::c_uint {\n            *b.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *g.as_deref_mut().unwrap()= (*b.as_deref().unwrap());\n            *r.as_deref_mut().unwrap()= (*g.as_deref().unwrap());\n            if (*mode).key_defined != 0\n                && (256 as libc::c_uint)\n                    .wrapping_mul(\n                        *in_0\n                            .offset(\n                                i\n                                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            ) as libc::c_uint,\n                    )\n                    .wrapping_add(\n                        *in_0\n                            .offset(\n                                i\n                                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            ) as libc::c_uint,\n                    ) == (*mode).key_r\n            {\n                *a.as_deref_mut().unwrap()= 0 as libc::c_int as libc::c_uchar;\n            } else {\n                *a.as_deref_mut().unwrap()= 255 as libc::c_int as libc::c_uchar;\n            }\n        } else {\n            let mut highest = ((1 as libc::c_uint) << (*mode).bitdepth)\n                .wrapping_sub(1 as libc::c_uint);\n            let mut j = i.wrapping_mul((*mode).bitdepth as libc::c_ulong);\n            let mut value = readBitsFromReversedStream(\n                Some(&mut j),\n                in_0,\n                (*mode).bitdepth as size_t,\n            );\n            *b.as_deref_mut().unwrap()= value\n                .wrapping_mul(255 as libc::c_int as libc::c_uint)\n                .wrapping_div(highest) as libc::c_uchar;\n            *g.as_deref_mut().unwrap()= (*b.as_deref().unwrap());\n            *r.as_deref_mut().unwrap()= (*g.as_deref().unwrap());\n            if (*mode).key_defined != 0 && value == (*mode).key_r {\n                *a.as_deref_mut().unwrap()= 0 as libc::c_int as libc::c_uchar;\n            } else {\n                *a.as_deref_mut().unwrap()= 255 as libc::c_int as libc::c_uchar;\n            }\n        }\n    } else if (*mode).colortype as libc::c_uint == LCT_RGB as libc::c_int as libc::c_uint\n    {\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            *r.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(3 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *g.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(3 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *b.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(3 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                );\n            if (*mode).key_defined != 0 && (*r.as_deref().unwrap()) as libc::c_uint == (*mode).key_r\n                && (*g.as_deref().unwrap()) as libc::c_uint == (*mode).key_g\n                && (*b.as_deref().unwrap()) as libc::c_uint == (*mode).key_b\n            {\n                *a.as_deref_mut().unwrap()= 0 as libc::c_int as libc::c_uchar;\n            } else {\n                *a.as_deref_mut().unwrap()= 255 as libc::c_int as libc::c_uchar;\n            }\n        } else {\n            *r.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *g.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *b.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(4 as libc::c_int as libc::c_ulong) as isize,\n                );\n            if (*mode).key_defined != 0\n                && (256 as libc::c_uint)\n                    .wrapping_mul(\n                        *in_0\n                            .offset(\n                                i\n                                    .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            ) as libc::c_uint,\n                    )\n                    .wrapping_add(\n                        *in_0\n                            .offset(\n                                i\n                                    .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            ) as libc::c_uint,\n                    ) == (*mode).key_r\n                && (256 as libc::c_uint)\n                    .wrapping_mul(\n                        *in_0\n                            .offset(\n                                i\n                                    .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            ) as libc::c_uint,\n                    )\n                    .wrapping_add(\n                        *in_0\n                            .offset(\n                                i\n                                    .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                                    .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                            ) as libc::c_uint,\n                    ) == (*mode).key_g\n                && (256 as libc::c_uint)\n                    .wrapping_mul(\n                        *in_0\n                            .offset(\n                                i\n                                    .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                                    .wrapping_add(4 as libc::c_int as libc::c_ulong) as isize,\n                            ) as libc::c_uint,\n                    )\n                    .wrapping_add(\n                        *in_0\n                            .offset(\n                                i\n                                    .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                                    .wrapping_add(5 as libc::c_int as libc::c_ulong) as isize,\n                            ) as libc::c_uint,\n                    ) == (*mode).key_b\n            {\n                *a.as_deref_mut().unwrap()= 0 as libc::c_int as libc::c_uchar;\n            } else {\n                *a.as_deref_mut().unwrap()= 255 as libc::c_int as libc::c_uchar;\n            }\n        }\n    } else if (*mode).colortype as libc::c_uint\n        == LCT_PALETTE as libc::c_int as libc::c_uint\n    {\n        let mut index: libc::c_uint = 0;\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            index= *in_0.offset(i as isize) as libc::c_uint;\n        } else {\n            let mut j_0 = i.wrapping_mul((*mode).bitdepth as libc::c_ulong);\n            index= readBitsFromReversedStream(\n                Some(&mut j_0),\n                in_0,\n                (*mode).bitdepth as size_t,\n            );\n        }\n        *r.as_deref_mut().unwrap()= *(*mode).palette\n            .offset(\n                index\n                    .wrapping_mul(4 as libc::c_int as libc::c_uint)\n                    .wrapping_add(0 as libc::c_int as libc::c_uint) as isize,\n            );\n        *g.as_deref_mut().unwrap()= *(*mode).palette\n            .offset(\n                index\n                    .wrapping_mul(4 as libc::c_int as libc::c_uint)\n                    .wrapping_add(1 as libc::c_int as libc::c_uint) as isize,\n            );\n        *b.as_deref_mut().unwrap()= *(*mode).palette\n            .offset(\n                index\n                    .wrapping_mul(4 as libc::c_int as libc::c_uint)\n                    .wrapping_add(2 as libc::c_int as libc::c_uint) as isize,\n            );\n        *a.as_deref_mut().unwrap()= *(*mode).palette\n            .offset(\n                index\n                    .wrapping_mul(4 as libc::c_int as libc::c_uint)\n                    .wrapping_add(3 as libc::c_int as libc::c_uint) as isize,\n            );\n    } else if (*mode).colortype as libc::c_uint\n        == LCT_GREY_ALPHA as libc::c_int as libc::c_uint\n    {\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            *b.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *g.as_deref_mut().unwrap()= (*b.as_deref().unwrap());\n            *r.as_deref_mut().unwrap()= (*g.as_deref().unwrap());\n            *a.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                );\n        } else {\n            *b.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *g.as_deref_mut().unwrap()= (*b.as_deref().unwrap());\n            *r.as_deref_mut().unwrap()= (*g.as_deref().unwrap());\n            *a.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                );\n        }\n    } else if (*mode).colortype as libc::c_uint\n        == LCT_RGBA as libc::c_int as libc::c_uint\n    {\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            *r.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *g.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *b.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *a.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                );\n        } else {\n            *r.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *g.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *b.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(4 as libc::c_int as libc::c_ulong) as isize,\n                );\n            *a.as_deref_mut().unwrap()= *in_0\n                .offset(\n                    i\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(6 as libc::c_int as libc::c_ulong) as isize,\n                );\n        }\n    }\n}","src::lodepng::inflateNoCompression":"unsafe extern \"C\" fn inflateNoCompression(\n    mut out: *mut ucvector,\n    mut reader: *mut LodePNGBitReader,\n    mut settings: *const LodePNGDecompressSettings,\n) -> libc::c_uint {\n    let mut bytepos: size_t = 0;\n    let mut size = (*reader).size;\n    let mut LEN: libc::c_uint = 0;\n    let mut NLEN: libc::c_uint = 0;\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    bytepos= (*reader).bp.wrapping_add(7 as libc::c_uint as libc::c_ulong)\n        >> 3 as libc::c_uint;\n    if bytepos.wrapping_add(4 as libc::c_int as libc::c_ulong) >= size {\n        return 52 as libc::c_int as libc::c_uint;\n    }\n    LEN= (*(*reader).data.offset(bytepos as isize) as libc::c_uint)\n        .wrapping_add(\n            (*(*reader).data\n                .offset(bytepos.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize)\n                as libc::c_uint) << 8 as libc::c_uint,\n        );\n    bytepos= (bytepos as libc::c_ulong).wrapping_add(2 as libc::c_int as libc::c_ulong)\n        as size_t as size_t;\n    NLEN= (*(*reader).data.offset(bytepos as isize) as libc::c_uint)\n        .wrapping_add(\n            (*(*reader).data\n                .offset(bytepos.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize)\n                as libc::c_uint) << 8 as libc::c_uint,\n        );\n    bytepos= (bytepos as libc::c_ulong).wrapping_add(2 as libc::c_int as libc::c_ulong)\n        as size_t as size_t;\n    if (*settings).ignore_nlen == 0\n        && LEN.wrapping_add(NLEN) != 65535 as libc::c_int as libc::c_uint\n    {\n        return 21 as libc::c_int as libc::c_uint;\n    }\n    if {let crown_promoted_local_0 = (*out).size.wrapping_add(LEN as libc::c_ulong);ucvector_resize(out.as_mut(), crown_promoted_local_0)} == 0 {\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    if bytepos.wrapping_add(LEN as libc::c_ulong) > size {\n        return 23 as libc::c_int as libc::c_uint;\n    }\n    if LEN != 0 {\n        lodepng_memcpy(\n            (*out).data.offset((*out).size as isize).offset(-(LEN as isize))\n                as *mut libc::c_void,\n            (*reader).data.offset(bytepos as isize) as *const libc::c_void,\n            LEN as size_t,\n        );\n        bytepos= (bytepos as libc::c_ulong).wrapping_add(LEN as libc::c_ulong) as size_t\n            as size_t;\n    }\n    (*reader).bp= bytepos << 3 as libc::c_uint;\n    return error;\n}","src::lodepng::readChunk_tEXt":"unsafe extern \"C\" fn readChunk_tEXt(\n    mut info: *mut LodePNGInfo,\n    mut data: *const libc::c_uchar,\n    mut chunkLength: size_t,\n) -> libc::c_uint {\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut key = 0 as *mut libc::c_char;\n    let mut str = 0 as *mut libc::c_char;\n    if error == 0 {\n        let mut length: libc::c_uint = 0;\n        let mut string2_begin: libc::c_uint = 0;\n        length= 0 as libc::c_int as libc::c_uint;\n        while (length as libc::c_ulong) < chunkLength\n            && *data.offset(length as isize) as libc::c_int != 0 as libc::c_int\n        {\n            length= length.wrapping_add(1);\n        }\n        if length < 1 as libc::c_int as libc::c_uint\n            || length > 79 as libc::c_int as libc::c_uint\n        {\n            error= 89 as libc::c_int as libc::c_uint;\n        } else {\n            key= lodepng_malloc(\n                length.wrapping_add(1 as libc::c_int as libc::c_uint) as size_t,\n            ) as *mut libc::c_char;\n            if key.is_null() {();\n                error= 83 as libc::c_int as libc::c_uint;\n            } else {\n                lodepng_memcpy(\n                    key as *mut libc::c_void,\n                    data as *const libc::c_void,\n                    length as size_t,\n                );\n                *key.offset(length as isize) = 0 as libc::c_int as libc::c_char;\n                string2_begin= length.wrapping_add(1 as libc::c_int as libc::c_uint);\n                length= (if chunkLength < string2_begin as libc::c_ulong {\n                    0 as libc::c_int as libc::c_ulong\n                } else {\n                    chunkLength.wrapping_sub(string2_begin as libc::c_ulong)\n                }) as libc::c_uint;\n                str= lodepng_malloc(\n                    length.wrapping_add(1 as libc::c_int as libc::c_uint) as size_t,\n                ) as *mut libc::c_char;\n                if str.is_null() {();\n                    error= 83 as libc::c_int as libc::c_uint;\n                } else {\n                    lodepng_memcpy(\n                        str as *mut libc::c_void,\n                        data.offset(string2_begin as isize) as *const libc::c_void,\n                        length as size_t,\n                    );\n                    *str.offset(length as isize) = 0 as libc::c_int as libc::c_char;\n                    error= lodepng_add_text(info, key, str);\n                }\n            }\n        }\n    }\n    lodepng_free(key as *mut libc::c_void);\n    lodepng_free(str as *mut libc::c_void);\n    return error;\n}","src::lodepng::searchCodeIndex":"unsafe extern \"C\" fn searchCodeIndex(\n    mut array: *const libc::c_uint,\n    mut array_size: size_t,\n    mut value: size_t,\n) -> size_t {\n    let mut left = 1 as libc::c_int as size_t;\n    let mut right = array_size.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    while left <= right {\n        let mut mid = left.wrapping_add(right) >> 1 as libc::c_int;\n        if *array.offset(mid as isize) as libc::c_ulong >= value {\n            right= mid.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n        } else {\n            left= mid.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        }\n    }\n    if left >= array_size || *array.offset(left as isize) as libc::c_ulong > value {\n        left= left.wrapping_sub(1);\n    }\n    return left;\n}","src::lodepng::readChunk_sBIT":"unsafe extern \"C\" fn readChunk_sBIT(\n    mut info: *mut LodePNGInfo,\n    mut data: *const libc::c_uchar,\n    mut chunkLength: size_t,\n) -> libc::c_uint {\n    let mut bitdepth = if (*info).color.colortype as libc::c_uint\n        == LCT_PALETTE as libc::c_int as libc::c_uint\n    {\n        8 as libc::c_int as libc::c_uint\n    } else {\n        (*info).color.bitdepth\n    };\n    if (*info).color.colortype as libc::c_uint == LCT_GREY as libc::c_int as libc::c_uint\n    {\n        if chunkLength != 1 as libc::c_int as libc::c_ulong {\n            return 114 as libc::c_int as libc::c_uint;\n        }\n        if *data.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int\n            || *data.offset(0 as libc::c_int as isize) as libc::c_uint > bitdepth\n        {\n            return 115 as libc::c_int as libc::c_uint;\n        }\n        (*info).sbit_defined= 1 as libc::c_int as libc::c_uint;\n        (*info).sbit_b= *data.offset(0 as libc::c_int as isize) as libc::c_uint; (*info).sbit_g= (*info).sbit_b; (*info).sbit_r= (*info).sbit_g;\n    } else if (*info).color.colortype as libc::c_uint\n        == LCT_RGB as libc::c_int as libc::c_uint\n        || (*info).color.colortype as libc::c_uint\n            == LCT_PALETTE as libc::c_int as libc::c_uint\n    {\n        if chunkLength != 3 as libc::c_int as libc::c_ulong {\n            return 114 as libc::c_int as libc::c_uint;\n        }\n        if *data.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int\n            || *data.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int\n            || *data.offset(2 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int\n        {\n            return 115 as libc::c_int as libc::c_uint;\n        }\n        if *data.offset(0 as libc::c_int as isize) as libc::c_uint > bitdepth\n            || *data.offset(1 as libc::c_int as isize) as libc::c_uint > bitdepth\n            || *data.offset(2 as libc::c_int as isize) as libc::c_uint > bitdepth\n        {\n            return 115 as libc::c_int as libc::c_uint;\n        }\n        (*info).sbit_defined= 1 as libc::c_int as libc::c_uint;\n        (*info).sbit_r= *data.offset(0 as libc::c_int as isize) as libc::c_uint;\n        (*info).sbit_g= *data.offset(1 as libc::c_int as isize) as libc::c_uint;\n        (*info).sbit_b= *data.offset(2 as libc::c_int as isize) as libc::c_uint;\n    } else if (*info).color.colortype as libc::c_uint\n        == LCT_GREY_ALPHA as libc::c_int as libc::c_uint\n    {\n        if chunkLength != 2 as libc::c_int as libc::c_ulong {\n            return 114 as libc::c_int as libc::c_uint;\n        }\n        if *data.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int\n            || *data.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int\n        {\n            return 115 as libc::c_int as libc::c_uint;\n        }\n        if *data.offset(0 as libc::c_int as isize) as libc::c_uint > bitdepth\n            || *data.offset(1 as libc::c_int as isize) as libc::c_uint > bitdepth\n        {\n            return 115 as libc::c_int as libc::c_uint;\n        }\n        (*info).sbit_defined= 1 as libc::c_int as libc::c_uint;\n        (*info).sbit_b= *data.offset(0 as libc::c_int as isize) as libc::c_uint; (*info).sbit_g= (*info).sbit_b; (*info).sbit_r= (*info).sbit_g;\n        (*info).sbit_a= *data.offset(1 as libc::c_int as isize) as libc::c_uint;\n    } else if (*info).color.colortype as libc::c_uint\n        == LCT_RGBA as libc::c_int as libc::c_uint\n    {\n        if chunkLength != 4 as libc::c_int as libc::c_ulong {\n            return 114 as libc::c_int as libc::c_uint;\n        }\n        if *data.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int\n            || *data.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int\n            || *data.offset(2 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int\n            || *data.offset(3 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int\n        {\n            return 115 as libc::c_int as libc::c_uint;\n        }\n        if *data.offset(0 as libc::c_int as isize) as libc::c_uint > bitdepth\n            || *data.offset(1 as libc::c_int as isize) as libc::c_uint > bitdepth\n            || *data.offset(2 as libc::c_int as isize) as libc::c_uint > bitdepth\n            || *data.offset(3 as libc::c_int as isize) as libc::c_uint > bitdepth\n        {\n            return 115 as libc::c_int as libc::c_uint;\n        }\n        (*info).sbit_defined= 1 as libc::c_int as libc::c_uint;\n        (*info).sbit_r= *data.offset(0 as libc::c_int as isize) as libc::c_uint;\n        (*info).sbit_g= *data.offset(1 as libc::c_int as isize) as libc::c_uint;\n        (*info).sbit_b= *data.offset(2 as libc::c_int as isize) as libc::c_uint;\n        (*info).sbit_a= *data.offset(3 as libc::c_int as isize) as libc::c_uint;\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::decodeGeneric":"unsafe extern \"C\" fn decodeGeneric(\n    mut out: *mut *mut libc::c_uchar,\n    mut w: *mut libc::c_uint,\n    mut h: *mut libc::c_uint,\n    mut state: *mut LodePNGState,\n    mut in_0: *const libc::c_uchar,\n    mut insize: size_t,\n) {\n    let mut IEND = 0 as libc::c_int as libc::c_uchar;\n    let mut chunk = 0 as *const libc::c_uchar;\n    let mut idat = 0 as *mut libc::c_uchar;\n    let mut idatsize = 0 as libc::c_int as size_t;\n    let mut scanlines = 0 as *mut libc::c_uchar;\n    let mut scanlines_size = 0 as libc::c_int as size_t;\n    let mut expected_size = 0 as libc::c_int as size_t;\n    let mut outsize = 0 as libc::c_int as size_t;\n    let mut unknown = 0 as libc::c_int as libc::c_uint;\n    let mut critical_pos = 1 as libc::c_int as libc::c_uint;\n    *out= 0 as *mut libc::c_uchar;\n    *h= 0 as libc::c_int as libc::c_uint;\n    *w= (*h);\n    (*state).error= lodepng_inspect(w, h, state, in_0, insize);\n    if (*state).error != 0 {\n        return;\n    }\n    if lodepng_pixel_overflow(\n        (*w),\n        (*h),\n        core::ptr::addr_of!((*state).info_png.color),\n        core::ptr::addr_of!((*state).info_raw),\n    ) != 0\n    {\n        (*state).error= 92 as libc::c_int as libc::c_uint;\n        return;\n    }\n    idat= lodepng_malloc(insize) as *mut libc::c_uchar;\n    if idat.is_null() {();\n        (*state).error= 83 as libc::c_int as libc::c_uint;\n        return;\n    }\n    chunk= &*in_0.offset(33 as libc::c_int as isize) as *const libc::c_uchar;\n    while IEND == 0 && (*state).error == 0 {\n        let mut chunkLength: libc::c_uint = 0;\n        let mut data = 0 as *const libc::c_uchar;\n        let mut pos = chunk.offset_from(in_0) as libc::c_long as size_t;\n        if chunk < in_0 || pos.wrapping_add(12 as libc::c_int as libc::c_ulong) > insize\n        {\n            if (*state).decoder.ignore_end != 0 {\n                break;\n            }\n            (*state).error= 30 as libc::c_int as libc::c_uint;\n            break;\n        } else {\n            chunkLength= lodepng_chunk_length(chunk);\n            if chunkLength > 2147483647 as libc::c_int as libc::c_uint {\n                if (*state).decoder.ignore_end != 0 {\n                    break;\n                }\n                (*state).error= 63 as libc::c_int as libc::c_uint;\n                break;\n            } else if pos\n                .wrapping_add(chunkLength as size_t)\n                .wrapping_add(12 as libc::c_int as libc::c_ulong) > insize\n                || pos\n                    .wrapping_add(chunkLength as size_t)\n                    .wrapping_add(12 as libc::c_int as libc::c_ulong) < pos\n            {\n                (*state).error= 64 as libc::c_int as libc::c_uint;\n                break;\n            } else {\n                data= lodepng_chunk_data_const(chunk);\n                unknown= 0 as libc::c_int as libc::c_uint;\n                if lodepng_chunk_type_equals(\n                    chunk,\n                    b\"IDAT\\0\" as *const u8 as *const libc::c_char,\n                ) != 0\n                {\n                    let mut newsize: size_t = 0;\n                    if lodepng_addofl(idatsize, chunkLength as size_t, Some(&mut newsize)) != 0\n                    {\n                        (*state).error= 95 as libc::c_int as libc::c_uint;\n                        break;\n                    } else if newsize > insize {\n                        (*state).error= 95 as libc::c_int as libc::c_uint;\n                        break;\n                    } else {\n                        lodepng_memcpy(\n                            idat.offset(idatsize as isize) as *mut libc::c_void,\n                            data as *const libc::c_void,\n                            chunkLength as size_t,\n                        );\n                        idatsize= (idatsize as libc::c_ulong)\n                            .wrapping_add(chunkLength as libc::c_ulong) as size_t\n                            as size_t;\n                        critical_pos= 3 as libc::c_int as libc::c_uint;\n                    }\n                } else if lodepng_chunk_type_equals(\n                    chunk,\n                    b\"IEND\\0\" as *const u8 as *const libc::c_char,\n                ) != 0\n                {\n                    IEND= 1 as libc::c_int as libc::c_uchar;\n                } else if lodepng_chunk_type_equals(\n                    chunk,\n                    b\"PLTE\\0\" as *const u8 as *const libc::c_char,\n                ) != 0\n                {\n                    (*state).error= readChunk_PLTE(\n                        core::ptr::addr_of_mut!((*state).info_png.color),\n                        data,\n                        chunkLength as size_t,\n                    );\n                    if (*state).error != 0 {\n                        break;\n                    }\n                    critical_pos= 2 as libc::c_int as libc::c_uint;\n                } else if lodepng_chunk_type_equals(\n                    chunk,\n                    b\"tRNS\\0\" as *const u8 as *const libc::c_char,\n                ) != 0\n                {\n                    (*state).error= readChunk_tRNS(\n                        core::ptr::addr_of_mut!((*state).info_png.color),\n                        data,\n                        chunkLength as size_t,\n                    );\n                    if (*state).error != 0 {\n                        break;\n                    }\n                } else if lodepng_chunk_type_equals(\n                    chunk,\n                    b\"bKGD\\0\" as *const u8 as *const libc::c_char,\n                ) != 0\n                {\n                    (*state).error= readChunk_bKGD(\n                        core::ptr::addr_of_mut!((*state).info_png),\n                        data,\n                        chunkLength as size_t,\n                    );\n                    if (*state).error != 0 {\n                        break;\n                    }\n                } else if lodepng_chunk_type_equals(\n                    chunk,\n                    b\"tEXt\\0\" as *const u8 as *const libc::c_char,\n                ) != 0\n                {\n                    if (*state).decoder.read_text_chunks != 0 {\n                        (*state).error= readChunk_tEXt(\n                            core::ptr::addr_of_mut!((*state).info_png),\n                            data,\n                            chunkLength as size_t,\n                        );\n                        if (*state).error != 0 {\n                            break;\n                        }\n                    }\n                } else if lodepng_chunk_type_equals(\n                    chunk,\n                    b\"zTXt\\0\" as *const u8 as *const libc::c_char,\n                ) != 0\n                {\n                    if (*state).decoder.read_text_chunks != 0 {\n                        (*state).error= readChunk_zTXt(\n                            core::ptr::addr_of_mut!((*state).info_png),\n                            core::ptr::addr_of!((*state).decoder),\n                            data,\n                            chunkLength as size_t,\n                        );\n                        if (*state).error != 0 {\n                            break;\n                        }\n                    }\n                } else if lodepng_chunk_type_equals(\n                    chunk,\n                    b\"iTXt\\0\" as *const u8 as *const libc::c_char,\n                ) != 0\n                {\n                    if (*state).decoder.read_text_chunks != 0 {\n                        (*state).error= readChunk_iTXt(\n                            core::ptr::addr_of_mut!((*state).info_png),\n                            core::ptr::addr_of!((*state).decoder),\n                            data,\n                            chunkLength as size_t,\n                        );\n                        if (*state).error != 0 {\n                            break;\n                        }\n                    }\n                } else if lodepng_chunk_type_equals(\n                    chunk,\n                    b\"tIME\\0\" as *const u8 as *const libc::c_char,\n                ) != 0\n                {\n                    (*state).error= readChunk_tIME(\n                        core::ptr::addr_of_mut!((*state).info_png),\n                        data,\n                        chunkLength as size_t,\n                    );\n                    if (*state).error != 0 {\n                        break;\n                    }\n                } else if lodepng_chunk_type_equals(\n                    chunk,\n                    b\"pHYs\\0\" as *const u8 as *const libc::c_char,\n                ) != 0\n                {\n                    (*state).error= readChunk_pHYs(\n                        core::ptr::addr_of_mut!((*state).info_png),\n                        data,\n                        chunkLength as size_t,\n                    );\n                    if (*state).error != 0 {\n                        break;\n                    }\n                } else if lodepng_chunk_type_equals(\n                    chunk,\n                    b\"gAMA\\0\" as *const u8 as *const libc::c_char,\n                ) != 0\n                {\n                    (*state).error= readChunk_gAMA(\n                        core::ptr::addr_of_mut!((*state).info_png),\n                        data,\n                        chunkLength as size_t,\n                    );\n                    if (*state).error != 0 {\n                        break;\n                    }\n                } else if lodepng_chunk_type_equals(\n                    chunk,\n                    b\"cHRM\\0\" as *const u8 as *const libc::c_char,\n                ) != 0\n                {\n                    (*state).error= readChunk_cHRM(\n                        core::ptr::addr_of_mut!((*state).info_png),\n                        data,\n                        chunkLength as size_t,\n                    );\n                    if (*state).error != 0 {\n                        break;\n                    }\n                } else if lodepng_chunk_type_equals(\n                    chunk,\n                    b\"sRGB\\0\" as *const u8 as *const libc::c_char,\n                ) != 0\n                {\n                    (*state).error= readChunk_sRGB(\n                        core::ptr::addr_of_mut!((*state).info_png),\n                        data,\n                        chunkLength as size_t,\n                    );\n                    if (*state).error != 0 {\n                        break;\n                    }\n                } else if lodepng_chunk_type_equals(\n                    chunk,\n                    b\"iCCP\\0\" as *const u8 as *const libc::c_char,\n                ) != 0\n                {\n                    (*state).error= readChunk_iCCP(\n                        core::ptr::addr_of_mut!((*state).info_png),\n                        core::ptr::addr_of!((*state).decoder),\n                        data,\n                        chunkLength as size_t,\n                    );\n                    if (*state).error != 0 {\n                        break;\n                    }\n                } else if lodepng_chunk_type_equals(\n                    chunk,\n                    b\"sBIT\\0\" as *const u8 as *const libc::c_char,\n                ) != 0\n                {\n                    (*state).error= readChunk_sBIT(\n                        core::ptr::addr_of_mut!((*state).info_png),\n                        data,\n                        chunkLength as size_t,\n                    );\n                    if (*state).error != 0 {\n                        break;\n                    }\n                } else if (*state).decoder.ignore_critical == 0\n                    && lodepng_chunk_ancillary(chunk) == 0\n                {\n                    (*state).error= 69 as libc::c_int as libc::c_uint;\n                    break;\n                } else {\n                    unknown= 1 as libc::c_int as libc::c_uint;\n                    if (*state).decoder.remember_unknown_chunks != 0 {\n                        (*state).error= lodepng_chunk_append(\n                            core::ptr::addr_of_mut!(*(*state).info_png.unknown_chunks_data.as_mut_ptr()\n                                .offset(\n                                    critical_pos.wrapping_sub(1 as libc::c_int as libc::c_uint)\n                                        as isize,\n                                )),\n                            core::ptr::addr_of_mut!(*(*state).info_png.unknown_chunks_size.as_mut_ptr()\n                                .offset(\n                                    critical_pos.wrapping_sub(1 as libc::c_int as libc::c_uint)\n                                        as isize,\n                                )),\n                            chunk,\n                        );\n                        if (*state).error != 0 {\n                            break;\n                        }\n                    }\n                }\n                if (*state).decoder.ignore_crc == 0 && unknown == 0 {\n                    if lodepng_chunk_check_crc(chunk) != 0 {\n                        (*state).error= 57 as libc::c_int as libc::c_uint;\n                        break;\n                    }\n                }\n                if IEND == 0 {\n                    chunk= lodepng_chunk_next_const(\n                        chunk,\n                        in_0.offset(insize as isize),\n                    );\n                }\n            }\n        }\n    }\n    if (*state).error == 0\n        && (*state).info_png.color.colortype as libc::c_uint\n            == LCT_PALETTE as libc::c_int as libc::c_uint\n        && (*state).info_png.color.palette.is_null()\n    {\n        (*state).error= 106 as libc::c_int as libc::c_uint;\n    }\n    if (*state).error == 0 {\n        if (*state).info_png.interlace_method == 0 as libc::c_int as libc::c_uint {\n            let mut bpp = lodepng_get_bpp(core::ptr::addr_of!((*state).info_png.color)) as size_t;\n            expected_size= lodepng_get_raw_size_idat((*w), (*h), bpp as libc::c_uint);\n        } else {\n            let mut bpp_0 = lodepng_get_bpp(core::ptr::addr_of!((*state).info_png.color)) as size_t;\n            expected_size= 0 as libc::c_int as size_t;\n            expected_size= (expected_size as libc::c_ulong)\n                .wrapping_add(\n                    lodepng_get_raw_size_idat(\n                        (*w).wrapping_add(7 as libc::c_int as libc::c_uint)\n                            >> 3 as libc::c_int,\n                        (*h).wrapping_add(7 as libc::c_int as libc::c_uint)\n                            >> 3 as libc::c_int,\n                        bpp_0 as libc::c_uint,\n                    ),\n                ) as size_t as size_t;\n            if (*w) > 4 as libc::c_int as libc::c_uint {\n                expected_size= (expected_size as libc::c_ulong)\n                    .wrapping_add(\n                        lodepng_get_raw_size_idat(\n                            (*w).wrapping_add(3 as libc::c_int as libc::c_uint)\n                                >> 3 as libc::c_int,\n                            (*h).wrapping_add(7 as libc::c_int as libc::c_uint)\n                                >> 3 as libc::c_int,\n                            bpp_0 as libc::c_uint,\n                        ),\n                    ) as size_t as size_t;\n            }\n            expected_size= (expected_size as libc::c_ulong)\n                .wrapping_add(\n                    lodepng_get_raw_size_idat(\n                        (*w).wrapping_add(3 as libc::c_int as libc::c_uint)\n                            >> 2 as libc::c_int,\n                        (*h).wrapping_add(3 as libc::c_int as libc::c_uint)\n                            >> 3 as libc::c_int,\n                        bpp_0 as libc::c_uint,\n                    ),\n                ) as size_t as size_t;\n            if (*w) > 2 as libc::c_int as libc::c_uint {\n                expected_size= (expected_size as libc::c_ulong)\n                    .wrapping_add(\n                        lodepng_get_raw_size_idat(\n                            (*w).wrapping_add(1 as libc::c_int as libc::c_uint)\n                                >> 2 as libc::c_int,\n                            (*h).wrapping_add(3 as libc::c_int as libc::c_uint)\n                                >> 2 as libc::c_int,\n                            bpp_0 as libc::c_uint,\n                        ),\n                    ) as size_t as size_t;\n            }\n            expected_size= (expected_size as libc::c_ulong)\n                .wrapping_add(\n                    lodepng_get_raw_size_idat(\n                        (*w).wrapping_add(1 as libc::c_int as libc::c_uint)\n                            >> 1 as libc::c_int,\n                        (*h).wrapping_add(1 as libc::c_int as libc::c_uint)\n                            >> 2 as libc::c_int,\n                        bpp_0 as libc::c_uint,\n                    ),\n                ) as size_t as size_t;\n            if (*w) > 1 as libc::c_int as libc::c_uint {\n                expected_size= (expected_size as libc::c_ulong)\n                    .wrapping_add(\n                        lodepng_get_raw_size_idat(\n                            (*w).wrapping_add(0 as libc::c_int as libc::c_uint)\n                                >> 1 as libc::c_int,\n                            (*h).wrapping_add(1 as libc::c_int as libc::c_uint)\n                                >> 1 as libc::c_int,\n                            bpp_0 as libc::c_uint,\n                        ),\n                    ) as size_t as size_t;\n            }\n            expected_size= (expected_size as libc::c_ulong)\n                .wrapping_add(\n                    lodepng_get_raw_size_idat(\n                        (*w).wrapping_add(0 as libc::c_int as libc::c_uint),\n                        (*h).wrapping_add(0 as libc::c_int as libc::c_uint)\n                            >> 1 as libc::c_int,\n                        bpp_0 as libc::c_uint,\n                    ),\n                ) as size_t as size_t;\n        }\n        (*state).error= zlib_decompress(\n            core::ptr::addr_of_mut!(scanlines),\n            core::ptr::addr_of_mut!(scanlines_size),\n            expected_size,\n            idat,\n            idatsize,\n            core::ptr::addr_of!((*state).decoder.zlibsettings),\n        );\n    }\n    if (*state).error == 0 && scanlines_size != expected_size {\n        (*state).error= 91 as libc::c_int as libc::c_uint;\n    }\n    lodepng_free(idat as *mut libc::c_void);\n    if (*state).error == 0 {\n        outsize= lodepng_get_raw_size((*w), (*h), core::ptr::addr_of!((*state).info_png.color));\n        *out= lodepng_malloc(outsize) as *mut libc::c_uchar;\n        if (*out).is_null() {();\n            (*state).error= 83 as libc::c_int as libc::c_uint;\n        }\n    }\n    if (*state).error == 0 {\n        lodepng_memset((*out) as *mut libc::c_void, 0 as libc::c_int, outsize);\n        (*state).error= postProcessScanlines(\n            (*out),\n            scanlines,\n            (*w),\n            (*h),\n            core::ptr::addr_of!((*state).info_png),\n        );\n    }\n    lodepng_free(scanlines as *mut libc::c_void);\n}","src::lodepng::lodepng_chunk_type":"pub unsafe extern \"C\" fn lodepng_chunk_type(\n    mut type_0: *mut libc::c_char,\n    mut chunk: *const libc::c_uchar,\n) {\n    let mut i: libc::c_uint = 0;\n    i= 0 as libc::c_int as libc::c_uint;\n    while i != 4 as libc::c_int as libc::c_uint {\n        *type_0\n            .offset(\n                i as isize,\n            ) = *chunk\n            .offset((4 as libc::c_int as libc::c_uint).wrapping_add(i) as isize)\n            as libc::c_char;\n        i= i.wrapping_add(1);\n    }\n    *type_0.offset(4 as libc::c_int as isize) = 0 as libc::c_int as libc::c_char;\n}","src::lodepng::lodepng_chunk_next_const":"pub unsafe extern \"C\" fn lodepng_chunk_next_const(\n    mut chunk: *const libc::c_uchar,\n    mut end: *const libc::c_uchar,\n) -> *const libc::c_uchar {\n    let mut available_size = end.offset_from(chunk) as libc::c_long as size_t;\n    if chunk >= end || available_size < 12 as libc::c_int as libc::c_ulong {\n        return end;\n    }\n    if *chunk.offset(0 as libc::c_int as isize) as libc::c_int == 0x89 as libc::c_int\n        && *chunk.offset(1 as libc::c_int as isize) as libc::c_int == 0x50 as libc::c_int\n        && *chunk.offset(2 as libc::c_int as isize) as libc::c_int == 0x4e as libc::c_int\n        && *chunk.offset(3 as libc::c_int as isize) as libc::c_int == 0x47 as libc::c_int\n        && *chunk.offset(4 as libc::c_int as isize) as libc::c_int == 0xd as libc::c_int\n        && *chunk.offset(5 as libc::c_int as isize) as libc::c_int == 0xa as libc::c_int\n        && *chunk.offset(6 as libc::c_int as isize) as libc::c_int == 0x1a as libc::c_int\n        && *chunk.offset(7 as libc::c_int as isize) as libc::c_int == 0xa as libc::c_int\n    {\n        return chunk.offset(8 as libc::c_int as isize)\n    } else {\n        let mut total_chunk_length: size_t = 0;\n        if lodepng_addofl(\n            lodepng_chunk_length(chunk) as size_t,\n            12 as libc::c_int as size_t,\n            Some(&mut total_chunk_length),\n        ) != 0\n        {\n            return end;\n        }\n        if total_chunk_length > available_size {\n            return end;\n        }\n        return chunk.offset(total_chunk_length as isize);\n    };\n}","src::lodepng::lodepng_addofl":"unsafe extern \"C\" fn lodepng_addofl(\n    mut a: size_t,\n    mut b: size_t,\n    mut result: Option<&mut size_t>,\n) -> libc::c_int {\n    *result.as_deref_mut().unwrap()= a.wrapping_add(b);\n    return ((*result.as_deref().unwrap()) < a) as libc::c_int;\n}","src::lodepng::filter":"unsafe extern \"C\" fn filter(\n    mut out: *mut libc::c_uchar,\n    mut in_0: *const libc::c_uchar,\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n    mut color: *const LodePNGColorMode,\n    mut settings: *const LodePNGEncoderSettings,\n) -> libc::c_uint {\n    let mut bpp = lodepng_get_bpp(color);\n    let mut linebytes = (lodepng_get_raw_size_idat(\n        w,\n        1 as libc::c_int as libc::c_uint,\n        bpp,\n    ))\n        .wrapping_sub(1 as libc::c_uint as libc::c_ulong);\n    let mut bytewidth = bpp\n        .wrapping_add(7 as libc::c_uint)\n        .wrapping_div(8 as libc::c_uint) as size_t;\n    let mut prevline = 0 as *const libc::c_uchar;\n    let mut x: libc::c_uint = 0;\n    let mut y: libc::c_uint = 0;\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut strategy = (*settings).filter_strategy;\n    if (*settings).filter_palette_zero != 0\n        && ((*color).colortype as libc::c_uint\n            == LCT_PALETTE as libc::c_int as libc::c_uint\n            || (*color).bitdepth < 8 as libc::c_int as libc::c_uint)\n    {\n        strategy= LFS_ZERO;\n    }\n    if bpp == 0 as libc::c_int as libc::c_uint {\n        return 31 as libc::c_int as libc::c_uint;\n    }\n    if strategy as libc::c_uint >= LFS_ZERO as libc::c_int as libc::c_uint\n        && strategy as libc::c_uint <= LFS_FOUR as libc::c_int as libc::c_uint\n    {\n        let mut type_0 = strategy as libc::c_uchar;\n        y= 0 as libc::c_int as libc::c_uint;\n        while y != h {\n            let mut outindex = (1 as libc::c_int as libc::c_ulong)\n                .wrapping_add(linebytes)\n                .wrapping_mul(y as libc::c_ulong);\n            let mut inindex = linebytes.wrapping_mul(y as libc::c_ulong);\n            *out.offset(outindex as isize) = type_0;\n            filterScanline(\n                core::ptr::addr_of_mut!(*out\n                    .offset(\n                        outindex.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                    )),\n                &*in_0.offset(inindex as isize),\n                prevline,\n                linebytes,\n                bytewidth,\n                type_0,\n            );\n            prevline= &*in_0.offset(inindex as isize) as *const libc::c_uchar;\n            y= y.wrapping_add(1);\n        }\n    } else if strategy as libc::c_uint == LFS_MINSUM as libc::c_int as libc::c_uint {\n        let mut attempt: [*mut libc::c_uchar; 5] = [0 as *mut libc::c_uchar; 5];\n        let mut smallest = 0 as libc::c_int as size_t;\n        let mut type_1: libc::c_uchar = 0;\n        let mut bestType = 0 as libc::c_int as libc::c_uchar;\n        type_1= 0 as libc::c_int as libc::c_uchar;\n        while type_1 as libc::c_int != 5 as libc::c_int {\n            attempt[type_1 as usize]= lodepng_malloc(linebytes) as *mut libc::c_uchar;\n            if attempt[type_1 as usize].is_null() {();\n                error= 83 as libc::c_int as libc::c_uint;\n            }\n            type_1= type_1.wrapping_add(1);\n        }\n        if error == 0 {\n            y= 0 as libc::c_int as libc::c_uint;\n            while y != h {\n                type_1= 0 as libc::c_int as libc::c_uchar;\n                while type_1 as libc::c_int != 5 as libc::c_int {\n                    let mut sum = 0 as libc::c_int as size_t;\n                    filterScanline(\n                        attempt[type_1 as usize],\n                        &*in_0\n                            .offset(\n                                (y as libc::c_ulong).wrapping_mul(linebytes) as isize,\n                            ),\n                        prevline,\n                        linebytes,\n                        bytewidth,\n                        type_1,\n                    );\n                    if type_1 as libc::c_int == 0 as libc::c_int {\n                        x= 0 as libc::c_int as libc::c_uint;\n                        while x as libc::c_ulong != linebytes {\n                            sum= (sum as libc::c_ulong)\n                                .wrapping_add(\n                                    *attempt[type_1 as usize].offset(x as isize)\n                                        as libc::c_ulong,\n                                ) as size_t as size_t;\n                            x= x.wrapping_add(1);\n                        }\n                    } else {\n                        x= 0 as libc::c_int as libc::c_uint;\n                        while x as libc::c_ulong != linebytes {\n                            let mut s = *attempt[type_1 as usize].offset(x as isize);\n                            sum= (sum as libc::c_ulong)\n                                .wrapping_add(\n                                    (if (s as libc::c_int) < 128 as libc::c_int {\n                                        s as libc::c_uint\n                                    } else {\n                                        (255 as libc::c_uint).wrapping_sub(s as libc::c_uint)\n                                    }) as libc::c_ulong,\n                                ) as size_t as size_t;\n                            x= x.wrapping_add(1);\n                        }\n                    }\n                    if type_1 as libc::c_int == 0 as libc::c_int || sum < smallest {\n                        bestType= type_1;\n                        smallest= sum;\n                    }\n                    type_1= type_1.wrapping_add(1);\n                }\n                prevline= &*in_0\n                    .offset((y as libc::c_ulong).wrapping_mul(linebytes) as isize)\n                    as *const libc::c_uchar;\n                *out\n                    .offset(\n                        (y as libc::c_ulong)\n                            .wrapping_mul(\n                                linebytes.wrapping_add(1 as libc::c_int as libc::c_ulong),\n                            ) as isize,\n                    ) = bestType;\n                x= 0 as libc::c_int as libc::c_uint;\n                while x as libc::c_ulong != linebytes {\n                    *out\n                        .offset(\n                            (y as libc::c_ulong)\n                                .wrapping_mul(\n                                    linebytes.wrapping_add(1 as libc::c_int as libc::c_ulong),\n                                )\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                .wrapping_add(x as libc::c_ulong) as isize,\n                        ) = *attempt[bestType as usize].offset(x as isize);\n                    x= x.wrapping_add(1);\n                }\n                y= y.wrapping_add(1);\n            }\n        }\n        type_1= 0 as libc::c_int as libc::c_uchar;\n        while type_1 as libc::c_int != 5 as libc::c_int {\n            lodepng_free(attempt[type_1 as usize] as *mut libc::c_void);\n            type_1= type_1.wrapping_add(1);\n        }\n    } else if strategy as libc::c_uint == LFS_ENTROPY as libc::c_int as libc::c_uint {\n        let mut attempt_0: [*mut libc::c_uchar; 5] = [0 as *mut libc::c_uchar; 5];\n        let mut bestSum = 0 as libc::c_int as size_t;\n        let mut type_2: libc::c_uint = 0;\n        let mut bestType_0 = 0 as libc::c_int as libc::c_uint;\n        let mut count: [libc::c_uint; 256] = [0; 256];\n        type_2= 0 as libc::c_int as libc::c_uint;\n        while type_2 != 5 as libc::c_int as libc::c_uint {\n            attempt_0[type_2 as usize]= lodepng_malloc(linebytes) as *mut libc::c_uchar;\n            if attempt_0[type_2 as usize].is_null() {();\n                error= 83 as libc::c_int as libc::c_uint;\n            }\n            type_2= type_2.wrapping_add(1);\n        }\n        if error == 0 {\n            y= 0 as libc::c_int as libc::c_uint;\n            while y != h {\n                type_2= 0 as libc::c_int as libc::c_uint;\n                while type_2 != 5 as libc::c_int as libc::c_uint {\n                    let mut sum_0 = 0 as libc::c_int as size_t;\n                    filterScanline(\n                        attempt_0[type_2 as usize],\n                        &*in_0\n                            .offset(\n                                (y as libc::c_ulong).wrapping_mul(linebytes) as isize,\n                            ),\n                        prevline,\n                        linebytes,\n                        bytewidth,\n                        type_2 as libc::c_uchar,\n                    );\n                    lodepng_memset(\n                        count.as_mut_ptr() as *mut libc::c_void,\n                        0 as libc::c_int,\n                        (256 as libc::c_int as libc::c_ulong)\n                            .wrapping_mul(\n                                ::std::mem::size_of::<libc::c_uint>() as libc::c_ulong,\n                            ),\n                    );\n                    x= 0 as libc::c_int as libc::c_uint;\n                    while x as libc::c_ulong != linebytes {\n                        count[*attempt_0[type_2 as usize].offset(x as isize)\n                            as usize]= count[*attempt_0[type_2 as usize]\n                            .offset(x as isize) as usize]\n                            .wrapping_add(1);\n                        x= x.wrapping_add(1);\n                    }\n                    count[type_2 as usize]= count[type_2 as usize].wrapping_add(1);\n                    x= 0 as libc::c_int as libc::c_uint;\n                    while x != 256 as libc::c_int as libc::c_uint {\n                        sum_0= (sum_0 as libc::c_ulong)\n                            .wrapping_add(ilog2i(count[x as usize] as size_t)) as size_t\n                            as size_t;\n                        x= x.wrapping_add(1);\n                    }\n                    if type_2 == 0 as libc::c_int as libc::c_uint || sum_0 > bestSum {\n                        bestType_0= type_2;\n                        bestSum= sum_0;\n                    }\n                    type_2= type_2.wrapping_add(1);\n                }\n                prevline= &*in_0\n                    .offset((y as libc::c_ulong).wrapping_mul(linebytes) as isize)\n                    as *const libc::c_uchar;\n                *out\n                    .offset(\n                        (y as libc::c_ulong)\n                            .wrapping_mul(\n                                linebytes.wrapping_add(1 as libc::c_int as libc::c_ulong),\n                            ) as isize,\n                    ) = bestType_0 as libc::c_uchar;\n                x= 0 as libc::c_int as libc::c_uint;\n                while x as libc::c_ulong != linebytes {\n                    *out\n                        .offset(\n                            (y as libc::c_ulong)\n                                .wrapping_mul(\n                                    linebytes.wrapping_add(1 as libc::c_int as libc::c_ulong),\n                                )\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                .wrapping_add(x as libc::c_ulong) as isize,\n                        ) = *attempt_0[bestType_0 as usize].offset(x as isize);\n                    x= x.wrapping_add(1);\n                }\n                y= y.wrapping_add(1);\n            }\n        }\n        type_2= 0 as libc::c_int as libc::c_uint;\n        while type_2 != 5 as libc::c_int as libc::c_uint {\n            lodepng_free(attempt_0[type_2 as usize] as *mut libc::c_void);\n            type_2= type_2.wrapping_add(1);\n        }\n    } else if strategy as libc::c_uint == LFS_PREDEFINED as libc::c_int as libc::c_uint {\n        y= 0 as libc::c_int as libc::c_uint;\n        while y != h {\n            let mut outindex_0 = (1 as libc::c_int as libc::c_ulong)\n                .wrapping_add(linebytes)\n                .wrapping_mul(y as libc::c_ulong);\n            let mut inindex_0 = linebytes.wrapping_mul(y as libc::c_ulong);\n            let mut type_3 = *(*settings).predefined_filters.offset(y as isize);\n            *out.offset(outindex_0 as isize) = type_3;\n            filterScanline(\n                core::ptr::addr_of_mut!(*out\n                    .offset(\n                        outindex_0.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            as isize,\n                    )),\n                &*in_0.offset(inindex_0 as isize),\n                prevline,\n                linebytes,\n                bytewidth,\n                type_3,\n            );\n            prevline= &*in_0.offset(inindex_0 as isize) as *const libc::c_uchar;\n            y= y.wrapping_add(1);\n        }\n    } else if strategy as libc::c_uint == LFS_BRUTE_FORCE as libc::c_int as libc::c_uint\n    {\n        let mut size: [size_t; 5] = [0; 5];\n        let mut attempt_1: [*mut libc::c_uchar; 5] = [0 as *mut libc::c_uchar; 5];\n        let mut smallest_0 = 0 as libc::c_int as size_t;\n        let mut type_4 = 0 as libc::c_int as libc::c_uint;\n        let mut bestType_1 = 0 as libc::c_int as libc::c_uint;\n        let mut dummy = 0 as *mut libc::c_uchar;\n        let mut zlibsettings = LodePNGCompressSettings {\n            btype: 0,\n            use_lz77: 0,\n            windowsize: 0,\n            minmatch: 0,\n            nicematch: 0,\n            lazymatching: 0,\n            custom_zlib: None,\n            custom_deflate: None,\n            custom_context: 0 as *const libc::c_void,\n        };\n        lodepng_memcpy(\n            core::ptr::addr_of_mut!(zlibsettings) as *mut LodePNGCompressSettings as *mut libc::c_void,\n            &(*settings).zlibsettings as *const LodePNGCompressSettings\n                as *const libc::c_void,\n            ::std::mem::size_of::<LodePNGCompressSettings>() as libc::c_ulong,\n        );\n        zlibsettings.btype= 1 as libc::c_int as libc::c_uint;\n        zlibsettings.custom_zlib= None;\n        zlibsettings.custom_deflate= None;\n        type_4= 0 as libc::c_int as libc::c_uint;\n        while type_4 != 5 as libc::c_int as libc::c_uint {\n            attempt_1[type_4 as usize]= lodepng_malloc(linebytes) as *mut libc::c_uchar;\n            if attempt_1[type_4 as usize].is_null() {();\n                error= 83 as libc::c_int as libc::c_uint;\n            }\n            type_4= type_4.wrapping_add(1);\n        }\n        if error == 0 {\n            y= 0 as libc::c_int as libc::c_uint;\n            while y != h {\n                type_4= 0 as libc::c_int as libc::c_uint;\n                while type_4 != 5 as libc::c_int as libc::c_uint {\n                    let mut testsize = linebytes as libc::c_uint;\n                    filterScanline(\n                        attempt_1[type_4 as usize],\n                        &*in_0\n                            .offset(\n                                (y as libc::c_ulong).wrapping_mul(linebytes) as isize,\n                            ),\n                        prevline,\n                        linebytes,\n                        bytewidth,\n                        type_4 as libc::c_uchar,\n                    );\n                    size[type_4 as usize]= 0 as libc::c_int as size_t;\n                    dummy= 0 as *mut libc::c_uchar;\n                    zlib_compress(\n                        core::ptr::addr_of_mut!(dummy),\n                        core::ptr::addr_of_mut!(*size.as_mut_ptr().offset(type_4 as isize)),\n                        attempt_1[type_4 as usize],\n                        testsize as size_t,\n                        core::ptr::addr_of!(zlibsettings),\n                    );\n                    lodepng_free(dummy as *mut libc::c_void);\n                    if type_4 == 0 as libc::c_int as libc::c_uint\n                        || size[type_4 as usize] < smallest_0\n                    {\n                        bestType_1= type_4;\n                        smallest_0= size[type_4 as usize];\n                    }\n                    type_4= type_4.wrapping_add(1);\n                }\n                prevline= &*in_0\n                    .offset((y as libc::c_ulong).wrapping_mul(linebytes) as isize)\n                    as *const libc::c_uchar;\n                *out\n                    .offset(\n                        (y as libc::c_ulong)\n                            .wrapping_mul(\n                                linebytes.wrapping_add(1 as libc::c_int as libc::c_ulong),\n                            ) as isize,\n                    ) = bestType_1 as libc::c_uchar;\n                x= 0 as libc::c_int as libc::c_uint;\n                while x as libc::c_ulong != linebytes {\n                    *out\n                        .offset(\n                            (y as libc::c_ulong)\n                                .wrapping_mul(\n                                    linebytes.wrapping_add(1 as libc::c_int as libc::c_ulong),\n                                )\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                .wrapping_add(x as libc::c_ulong) as isize,\n                        ) = *attempt_1[bestType_1 as usize].offset(x as isize);\n                    x= x.wrapping_add(1);\n                }\n                y= y.wrapping_add(1);\n            }\n        }\n        type_4= 0 as libc::c_int as libc::c_uint;\n        while type_4 != 5 as libc::c_int as libc::c_uint {\n            lodepng_free(attempt_1[type_4 as usize] as *mut libc::c_void);\n            type_4= type_4.wrapping_add(1);\n        }\n    } else {\n        return 88 as libc::c_int as libc::c_uint\n    }\n    return error;\n}","src::lodepng::lodepng_is_alpha_type":"pub unsafe extern \"C\" fn lodepng_is_alpha_type(\n    mut info: *const LodePNGColorMode,\n) -> libc::c_uint {\n    return ((*info).colortype as libc::c_uint & 4 as libc::c_int as libc::c_uint\n        != 0 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_uint;\n}","src::lodepng::HuffmanTree_makeFromLengths2":"unsafe extern \"C\" fn HuffmanTree_makeFromLengths2(\n    mut tree: Option<&mut HuffmanTree>,\n) -> libc::c_uint {\n    let mut blcount = 0 as *mut libc::c_uint;\n    let mut nextcode = 0 as *mut libc::c_uint;\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut bits: libc::c_uint = 0;\n    let mut n: libc::c_uint = 0;\n    (*tree.as_deref_mut().unwrap()).codes= lodepng_malloc(\n        ((*tree.as_deref().unwrap()).numcodes as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong),\n    ) as *mut libc::c_uint;\n    blcount= lodepng_malloc(\n        ((*tree.as_deref().unwrap()).maxbitlen.wrapping_add(1 as libc::c_int as libc::c_uint)\n            as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong),\n    ) as *mut libc::c_uint;\n    nextcode= lodepng_malloc(\n        ((*tree.as_deref().unwrap()).maxbitlen.wrapping_add(1 as libc::c_int as libc::c_uint)\n            as libc::c_ulong)\n            .wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong),\n    ) as *mut libc::c_uint;\n    if (*tree.as_deref().unwrap()).codes.is_null() || blcount.is_null() || nextcode.is_null() {\n        error= 83 as libc::c_int as libc::c_uint;\n    }\n    if error == 0 {\n        n= 0 as libc::c_int as libc::c_uint;\n        while n != (*tree.as_deref().unwrap()).maxbitlen.wrapping_add(1 as libc::c_int as libc::c_uint) {\n            *nextcode.offset(n as isize) = 0 as libc::c_int as libc::c_uint; *blcount.offset(n as isize)  = *nextcode.offset(n as isize);\n            n= n.wrapping_add(1);\n        }\n        bits= 0 as libc::c_int as libc::c_uint;\n        while bits != (*tree.as_deref().unwrap()).numcodes {\n            *blcount\n                .offset(*(*tree.as_deref().unwrap()).lengths.offset(bits as isize) as isize) = (*blcount\n                .offset(*(*tree.as_deref().unwrap()).lengths.offset(bits as isize) as isize)).wrapping_add(1);\n            bits= bits.wrapping_add(1);\n        }\n        bits= 1 as libc::c_int as libc::c_uint;\n        while bits <= (*tree.as_deref().unwrap()).maxbitlen {\n            *nextcode\n                .offset(\n                    bits as isize,\n                ) = (*nextcode\n                .offset(bits.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize))\n                .wrapping_add(\n                    *blcount\n                        .offset(\n                            bits.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,\n                        ),\n                ) << 1 as libc::c_uint;\n            bits= bits.wrapping_add(1);\n        }\n        n= 0 as libc::c_int as libc::c_uint;\n        while n != (*tree.as_deref().unwrap()).numcodes {\n            if *(*tree.as_deref().unwrap()).lengths.offset(n as isize) != 0 as libc::c_int as libc::c_uint\n            {\n                let fresh25 = *nextcode\n                    .offset(*(*tree.as_deref().unwrap()).lengths.offset(n as isize) as isize);*nextcode\n                    .offset(*(*tree.as_deref().unwrap()).lengths.offset(n as isize) as isize) = (*nextcode\n                    .offset(*(*tree.as_deref().unwrap()).lengths.offset(n as isize) as isize)).wrapping_add(1);\n                *(*tree.as_deref().unwrap()).codes.offset(n as isize) = fresh25;\n                *(*tree.as_deref().unwrap()).codes.offset(n as isize)\n                    &= ((1 as libc::c_uint) << *(*tree.as_deref().unwrap()).lengths.offset(n as isize))\n                        .wrapping_sub(1 as libc::c_uint);\n            }\n            n= n.wrapping_add(1);\n        }\n    }\n    lodepng_free(blcount as *mut libc::c_void);\n    lodepng_free(nextcode as *mut libc::c_void);\n    if error == 0 {\n        error= HuffmanTree_makeTable(tree.as_deref_mut());\n    }\n    return error;\n}","src::lodepng::lodepng_add_itext_sized":"unsafe extern \"C\" fn lodepng_add_itext_sized(\n    mut info: *mut LodePNGInfo,\n    mut key: *const libc::c_char,\n    mut langtag: *const libc::c_char,\n    mut transkey: *const libc::c_char,\n    mut str: *const libc::c_char,\n    mut size: size_t,\n) -> libc::c_uint {\n    let mut new_keys = lodepng_realloc(\n        (*info).itext_keys as *mut libc::c_void,\n        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)\n            .wrapping_mul(\n                (*info).itext_num.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            ),\n    ) as *mut *mut libc::c_char;\n    let mut new_langtags = lodepng_realloc(\n        (*info).itext_langtags as *mut libc::c_void,\n        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)\n            .wrapping_mul(\n                (*info).itext_num.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            ),\n    ) as *mut *mut libc::c_char;\n    let mut new_transkeys = lodepng_realloc(\n        (*info).itext_transkeys as *mut libc::c_void,\n        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)\n            .wrapping_mul(\n                (*info).itext_num.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            ),\n    ) as *mut *mut libc::c_char;\n    let mut new_strings = lodepng_realloc(\n        (*info).itext_strings as *mut libc::c_void,\n        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)\n            .wrapping_mul(\n                (*info).itext_num.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            ),\n    ) as *mut *mut libc::c_char;\n    if !new_keys.is_null() {\n        (*info).itext_keys= new_keys;\n    }else { (); }\n    if !new_langtags.is_null() {\n        (*info).itext_langtags= new_langtags;\n    }else { (); }\n    if !new_transkeys.is_null() {\n        (*info).itext_transkeys= new_transkeys;\n    }else { (); }\n    if !new_strings.is_null() {\n        (*info).itext_strings= new_strings;\n    }else { (); }\n    if new_keys.is_null() || new_langtags.is_null() || new_transkeys.is_null()\n        || new_strings.is_null()\n    {\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    (*info).itext_num= (*info).itext_num.wrapping_add(1);\n    *(*info).itext_keys\n        .offset(\n            (*info).itext_num.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n        ) = alloc_string(key);\n    *(*info).itext_langtags\n        .offset(\n            (*info).itext_num.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n        ) = alloc_string(langtag);\n    *(*info).itext_transkeys\n        .offset(\n            (*info).itext_num.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n        ) = alloc_string(transkey);\n    *(*info).itext_strings\n        .offset(\n            (*info).itext_num.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n        ) = alloc_string_sized(str, size);\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_color_mode_cleanup":"pub unsafe extern \"C\" fn lodepng_color_mode_cleanup(mut info: Option<&mut LodePNGColorMode>) {\n    lodepng_palette_clear(info.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()));\n}","src::lodepng::lodepng_has_palette_alpha":"pub unsafe extern \"C\" fn lodepng_has_palette_alpha(\n    mut info: *const LodePNGColorMode,\n) -> libc::c_uint {\n    let mut i: size_t = 0;\n    i= 0 as libc::c_int as size_t;\n    while i != (*info).palettesize {\n        if (*(*info).palette\n            .offset(\n                i\n                    .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n            ) as libc::c_int) < 255 as libc::c_int\n        {\n            return 1 as libc::c_int as libc::c_uint;\n        }\n        i= i.wrapping_add(1);\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::HuffmanTree_makeFromFrequencies":"unsafe extern \"C\" fn HuffmanTree_makeFromFrequencies(\n    mut tree: Option<&mut HuffmanTree>,\n    mut frequencies: *const libc::c_uint,\n    mut mincodes: size_t,\n    mut numcodes: size_t,\n    mut maxbitlen: libc::c_uint,\n) -> libc::c_uint {\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    while *frequencies\n        .offset(numcodes.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize) == 0\n        && numcodes > mincodes\n    {\n        numcodes= numcodes.wrapping_sub(1);\n    }\n    (*tree.as_deref_mut().unwrap()).lengths= lodepng_malloc(\n        numcodes.wrapping_mul(::std::mem::size_of::<libc::c_uint>() as libc::c_ulong),\n    ) as *mut libc::c_uint;\n    if (*tree.as_deref().unwrap()).lengths.is_null() {();\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    (*tree.as_deref_mut().unwrap()).maxbitlen= maxbitlen;\n    (*tree.as_deref_mut().unwrap()).numcodes= numcodes as libc::c_uint;\n    error= lodepng_huffman_code_lengths(\n        (*tree.as_deref().unwrap()).lengths,\n        frequencies,\n        numcodes,\n        maxbitlen,\n    );\n    if error == 0 {\n        error= HuffmanTree_makeFromLengths2(tree.as_deref_mut());\n    }\n    return error;\n}","src::lodepng::lodepng_zlib_decompress":"pub unsafe extern \"C\" fn lodepng_zlib_decompress(\n    mut out: Option<&mut *mut libc::c_uchar>,\n    mut outsize: Option<&mut size_t>,\n    mut in_0: *const libc::c_uchar,\n    mut insize: size_t,\n    mut settings: *const LodePNGDecompressSettings,\n) -> libc::c_uint {\n    let mut v = ucvector_init((*out.as_deref().unwrap()), (*outsize.as_deref().unwrap()));\n    let mut error = lodepng_zlib_decompressv(core::ptr::addr_of_mut!(v), in_0, insize, settings);\n    *out.as_deref_mut().unwrap()= v.data;\n    *outsize.as_deref_mut().unwrap()= v.size;\n    return error;\n}","src::lodepng::lodepng_buffer_file":"unsafe extern \"C\" fn lodepng_buffer_file(\n    mut out: *mut libc::c_uchar,\n    mut size: size_t,\n    mut filename: *const libc::c_char,\n) -> libc::c_uint {\n    let mut file = 0 as *mut FILE;\n    let mut readsize: size_t = 0;\n    file= fopen(filename, b\"rb\\0\" as *const u8 as *const libc::c_char);\n    if file.is_null() {();\n        return 78 as libc::c_int as libc::c_uint;\n    }\n    readsize= fread(\n        out as *mut libc::c_void,\n        1 as libc::c_int as libc::c_ulong,\n        size,\n        file,\n    );\n    fclose(file);\n    if readsize != size {\n        return 78 as libc::c_int as libc::c_uint;\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::encodeLZ77":"unsafe extern \"C\" fn encodeLZ77(\n    mut out: Option<&mut uivector>,\n    mut hash: Option<&mut Hash>,\n    mut in_0: *const libc::c_uchar,\n    mut inpos: size_t,\n    mut insize: size_t,\n    mut windowsize: libc::c_uint,\n    mut minmatch: libc::c_uint,\n    mut nicematch: libc::c_uint,\n    mut lazymatching: libc::c_uint,\n) -> libc::c_uint {\n    let mut pos: size_t = 0;\n    let mut i: libc::c_uint = 0;\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut maxchainlength = if windowsize >= 8192 as libc::c_int as libc::c_uint {\n        windowsize\n    } else {\n        windowsize.wrapping_div(8 as libc::c_uint)\n    };\n    let mut maxlazymatch = (if windowsize >= 8192 as libc::c_int as libc::c_uint {\n        crate::src::lodepng::MAX_SUPPORTED_DEFLATE_LENGTH\n    } else {\n        64 as libc::c_int as libc::c_ulong\n    }) as libc::c_uint;\n    let mut usezeros = 1 as libc::c_int as libc::c_uint;\n    let mut numzeros = 0 as libc::c_int as libc::c_uint;\n    let mut offset: libc::c_uint = 0;\n    let mut length: libc::c_uint = 0;\n    let mut lazy = 0 as libc::c_int as libc::c_uint;\n    let mut lazylength = 0 as libc::c_int as libc::c_uint;\n    let mut lazyoffset = 0 as libc::c_int as libc::c_uint;\n    let mut hashval: libc::c_uint = 0;\n    let mut current_offset: libc::c_uint = 0;\n    let mut current_length: libc::c_uint = 0;\n    let mut prev_offset: libc::c_uint = 0;\n    let mut lastptr = 0 as *const libc::c_uchar;\n    let mut foreptr = 0 as *const libc::c_uchar;\n    let mut backptr = 0 as *const libc::c_uchar;\n    let mut hashpos: libc::c_uint = 0;\n    if windowsize == 0 as libc::c_int as libc::c_uint\n        || windowsize > 32768 as libc::c_int as libc::c_uint\n    {\n        return 60 as libc::c_int as libc::c_uint;\n    }\n    if windowsize & windowsize.wrapping_sub(1 as libc::c_int as libc::c_uint)\n        != 0 as libc::c_int as libc::c_uint\n    {\n        return 90 as libc::c_int as libc::c_uint;\n    }\n    if nicematch as libc::c_ulong > crate::src::lodepng::MAX_SUPPORTED_DEFLATE_LENGTH {\n        nicematch= crate::src::lodepng::MAX_SUPPORTED_DEFLATE_LENGTH as libc::c_uint;\n    }\n    let mut current_block_78: u64;\n    pos= inpos;\n    while pos < insize {\n        let mut wpos = pos\n            & windowsize.wrapping_sub(1 as libc::c_int as libc::c_uint) as libc::c_ulong;\n        let mut chainlength = 0 as libc::c_int as libc::c_uint;\n        hashval= getHash(in_0, insize, pos);\n        if usezeros != 0 && hashval == 0 as libc::c_int as libc::c_uint {\n            if numzeros == 0 as libc::c_int as libc::c_uint {\n                numzeros= countZeros(in_0, insize, pos);\n            } else if pos.wrapping_add(numzeros as libc::c_ulong) > insize\n                || *in_0\n                    .offset(\n                        pos\n                            .wrapping_add(numzeros as libc::c_ulong)\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_int != 0 as libc::c_int\n            {\n                numzeros= numzeros.wrapping_sub(1);\n            }\n        } else {\n            numzeros= 0 as libc::c_int as libc::c_uint;\n        }\n        updateHashChain(hash.as_deref_mut(), wpos, hashval, numzeros as libc::c_ushort);\n        length= 0 as libc::c_int as libc::c_uint;\n        offset= 0 as libc::c_int as libc::c_uint;\n        hashpos= *(*hash.as_deref().unwrap()).chain.offset(wpos as isize) as libc::c_uint;\n        lastptr= &*in_0\n            .offset(\n                (if insize < pos.wrapping_add(crate::src::lodepng::MAX_SUPPORTED_DEFLATE_LENGTH) {\n                    insize\n                } else {\n                    pos.wrapping_add(crate::src::lodepng::MAX_SUPPORTED_DEFLATE_LENGTH)\n                }) as isize,\n            ) as *const libc::c_uchar;\n        prev_offset= 0 as libc::c_int as libc::c_uint;\n        loop {\n            let fresh59 = chainlength;\n            chainlength= chainlength.wrapping_add(1);\n            if fresh59 >= maxchainlength {\n                break;\n            }\n            current_offset= (if hashpos as libc::c_ulong <= wpos {\n                wpos.wrapping_sub(hashpos as libc::c_ulong)\n            } else {\n                wpos.wrapping_sub(hashpos as libc::c_ulong)\n                    .wrapping_add(windowsize as libc::c_ulong)\n            }) as libc::c_uint;\n            if current_offset < prev_offset {\n                break;\n            }\n            prev_offset= current_offset;\n            if current_offset > 0 as libc::c_int as libc::c_uint {\n                foreptr= &*in_0.offset(pos as isize) as *const libc::c_uchar;\n                backptr= &*in_0\n                    .offset(pos.wrapping_sub(current_offset as libc::c_ulong) as isize)\n                    as *const libc::c_uchar;\n                if numzeros >= 3 as libc::c_int as libc::c_uint {\n                    let mut skip = *(*hash.as_deref().unwrap()).zeros.offset(hashpos as isize)\n                        as libc::c_uint;\n                    if skip > numzeros {\n                        skip= numzeros;\n                    }\n                    backptr= backptr.offset(skip as isize);\n                    foreptr= foreptr.offset(skip as isize);\n                }\n                while foreptr != lastptr\n                    && (*backptr) as libc::c_int == (*foreptr) as libc::c_int\n                {\n                    backptr= backptr.offset(1);\n                    foreptr= foreptr.offset(1);\n                }\n                current_length= foreptr\n                    .offset_from(&*in_0.offset(pos as isize) as *const libc::c_uchar)\n                    as libc::c_long as libc::c_uint;\n                if current_length > length {\n                    length= current_length;\n                    offset= current_offset;\n                    if current_length >= nicematch {\n                        break;\n                    }\n                }\n            }\n            if hashpos == *(*hash.as_deref().unwrap()).chain.offset(hashpos as isize) as libc::c_uint {\n                break;\n            }\n            if numzeros >= 3 as libc::c_int as libc::c_uint && length > numzeros {\n                hashpos= *(*hash.as_deref().unwrap()).chainz.offset(hashpos as isize) as libc::c_uint;\n                if *(*hash.as_deref().unwrap()).zeros.offset(hashpos as isize) as libc::c_uint != numzeros\n                {\n                    break;\n                }\n            } else {\n                hashpos= *(*hash.as_deref().unwrap()).chain.offset(hashpos as isize) as libc::c_uint;\n                if *(*hash.as_deref().unwrap()).val.offset(hashpos as isize) != hashval as libc::c_int {\n                    break;\n                }\n            }\n        }\n        if lazymatching != 0 {\n            if lazy == 0 && length >= 3 as libc::c_int as libc::c_uint\n                && length <= maxlazymatch\n                && (length as libc::c_ulong) < crate::src::lodepng::MAX_SUPPORTED_DEFLATE_LENGTH\n            {\n                lazy= 1 as libc::c_int as libc::c_uint;\n                lazylength= length;\n                lazyoffset= offset;\n                current_block_78= 8236137900636309791;\n            } else if lazy != 0 {\n                lazy= 0 as libc::c_int as libc::c_uint;\n                if pos == 0 as libc::c_int as libc::c_ulong {\n                    error= 81 as libc::c_int as libc::c_uint;\n                    break;\n                } else if length\n                    > lazylength.wrapping_add(1 as libc::c_int as libc::c_uint)\n                {\n                    if uivector_push_back(\n                        out.as_deref_mut(),\n                        *in_0\n                            .offset(\n                                pos.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                            ) as libc::c_uint,\n                    ) == 0\n                    {\n                        error= 83 as libc::c_int as libc::c_uint;\n                        break;\n                    }\n                } else {\n                    length= lazylength;\n                    offset= lazyoffset;\n                    *(*hash.as_deref().unwrap()).head.offset(hashval as isize) = -(1 as libc::c_int);\n                    *(*hash.as_deref().unwrap()).headz.offset(numzeros as isize) = -(1 as libc::c_int);\n                    pos= pos.wrapping_sub(1);\n                }\n                current_block_78= 8716029205547827362;\n            } else {\n                current_block_78= 8716029205547827362;\n            }\n        } else {\n            current_block_78= 8716029205547827362;\n        }\n        match current_block_78 {\n            8716029205547827362 => {\n                if length >= 3 as libc::c_int as libc::c_uint && offset > windowsize {\n                    error= 86 as libc::c_int as libc::c_uint;\n                    break;\n                } else if length < 3 as libc::c_int as libc::c_uint {\n                    if uivector_push_back(\n                        out.as_deref_mut(),\n                        *in_0.offset(pos as isize) as libc::c_uint,\n                    ) == 0\n                    {\n                        error= 83 as libc::c_int as libc::c_uint;\n                        break;\n                    }\n                } else if length < minmatch\n                    || length == 3 as libc::c_int as libc::c_uint\n                        && offset > 4096 as libc::c_int as libc::c_uint\n                {\n                    if uivector_push_back(\n                        out.as_deref_mut(),\n                        *in_0.offset(pos as isize) as libc::c_uint,\n                    ) == 0\n                    {\n                        error= 83 as libc::c_int as libc::c_uint;\n                        break;\n                    }\n                } else {\n                    addLengthDistance(out.as_deref_mut(), length as size_t, offset as size_t);\n                    i= 1 as libc::c_int as libc::c_uint;\n                    while i < length {\n                        pos= pos.wrapping_add(1);\n                        wpos= pos\n                            & windowsize.wrapping_sub(1 as libc::c_int as libc::c_uint)\n                                as libc::c_ulong;\n                        hashval= getHash(in_0, insize, pos);\n                        if usezeros != 0 && hashval == 0 as libc::c_int as libc::c_uint {\n                            if numzeros == 0 as libc::c_int as libc::c_uint {\n                                numzeros= countZeros(in_0, insize, pos);\n                            } else if pos.wrapping_add(numzeros as libc::c_ulong)\n                                > insize\n                                || *in_0\n                                    .offset(\n                                        pos\n                                            .wrapping_add(numzeros as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                                    ) as libc::c_int != 0 as libc::c_int\n                            {\n                                numzeros= numzeros.wrapping_sub(1);\n                            }\n                        } else {\n                            numzeros= 0 as libc::c_int as libc::c_uint;\n                        }\n                        updateHashChain(hash.as_deref_mut(), wpos, hashval, numzeros as libc::c_ushort);\n                        i= i.wrapping_add(1);\n                    }\n                }\n            }\n            _ => {}\n        }\n        pos= pos.wrapping_add(1);\n    }\n    return error;\n}","src::lodepng::lodepng_encode":"pub unsafe extern \"C\" fn lodepng_encode(\n    mut out: *mut *mut libc::c_uchar,\n    mut outsize: *mut size_t,\n    mut image: *const libc::c_uchar,\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n    mut state: *mut LodePNGState,\n) -> libc::c_uint {\n    let mut current_block: u64;\n    let mut data = 0 as *mut libc::c_uchar;\n    let mut datasize = 0 as libc::c_int as size_t;\n    let mut outv = ucvector_init(0 as *mut libc::c_uchar, 0 as libc::c_int as size_t);\n    let mut info = LodePNGInfo {\n        compression_method: 0,\n        filter_method: 0,\n        interlace_method: 0,\n        color: LodePNGColorMode {\n            colortype: LCT_GREY,\n            bitdepth: 0,\n            palette: 0 as *mut libc::c_uchar,\n            palettesize: 0,\n            key_defined: 0,\n            key_r: 0,\n            key_g: 0,\n            key_b: 0,\n        },\n        background_defined: 0,\n        background_r: 0,\n        background_g: 0,\n        background_b: 0,\n        text_num: 0,\n        text_keys: 0 as *mut *mut libc::c_char,\n        text_strings: 0 as *mut *mut libc::c_char,\n        itext_num: 0,\n        itext_keys: 0 as *mut *mut libc::c_char,\n        itext_langtags: 0 as *mut *mut libc::c_char,\n        itext_transkeys: 0 as *mut *mut libc::c_char,\n        itext_strings: 0 as *mut *mut libc::c_char,\n        time_defined: 0,\n        time: LodePNGTime {\n            year: 0,\n            month: 0,\n            day: 0,\n            hour: 0,\n            minute: 0,\n            second: 0,\n        },\n        phys_defined: 0,\n        phys_x: 0,\n        phys_y: 0,\n        phys_unit: 0,\n        gama_defined: 0,\n        gama_gamma: 0,\n        chrm_defined: 0,\n        chrm_white_x: 0,\n        chrm_white_y: 0,\n        chrm_red_x: 0,\n        chrm_red_y: 0,\n        chrm_green_x: 0,\n        chrm_green_y: 0,\n        chrm_blue_x: 0,\n        chrm_blue_y: 0,\n        srgb_defined: 0,\n        srgb_intent: 0,\n        iccp_defined: 0,\n        iccp_name: 0 as *mut libc::c_char,\n        iccp_profile: 0 as *mut libc::c_uchar,\n        iccp_profile_size: 0,\n        sbit_defined: 0,\n        sbit_r: 0,\n        sbit_g: 0,\n        sbit_b: 0,\n        sbit_a: 0,\n        unknown_chunks_data: [0 as *mut libc::c_uchar; 3],\n        unknown_chunks_size: [0; 3],\n    };\n    let mut info_png: *const LodePNGInfo = core::ptr::addr_of!((*state).info_png);\n    let mut auto_color = LodePNGColorMode {\n        colortype: LCT_GREY,\n        bitdepth: 0,\n        palette: 0 as *mut libc::c_uchar,\n        palettesize: 0,\n        key_defined: 0,\n        key_r: 0,\n        key_g: 0,\n        key_b: 0,\n    };\n    lodepng_info_init(Some(&mut info));\n    lodepng_color_mode_init(Some(&mut auto_color));\n    *out= 0 as *mut libc::c_uchar;\n    *outsize= 0 as libc::c_int as size_t;\n    (*state).error= 0 as libc::c_int as libc::c_uint;\n    if ((*info_png).color.colortype as libc::c_uint\n        == LCT_PALETTE as libc::c_int as libc::c_uint\n        || (*state).encoder.force_palette != 0)\n        && ((*info_png).color.palettesize == 0 as libc::c_int as libc::c_ulong\n            || (*info_png).color.palettesize > 256 as libc::c_int as libc::c_ulong)\n    {\n        (*state).error= 68 as libc::c_int as libc::c_uint;\n    } else if (*state).encoder.zlibsettings.btype > 2 as libc::c_int as libc::c_uint {\n        (*state).error= 61 as libc::c_int as libc::c_uint;\n    } else if (*info_png).interlace_method > 1 as libc::c_int as libc::c_uint {\n        (*state).error= 71 as libc::c_int as libc::c_uint;\n    } else {\n        (*state).error= checkColorValidity(\n            (*info_png).color.colortype,\n            (*info_png).color.bitdepth,\n        );\n        if !((*state).error != 0) {\n            (*state).error= checkColorValidity(\n                (*state).info_raw.colortype,\n                (*state).info_raw.bitdepth,\n            );\n            if !((*state).error != 0) {\n                lodepng_info_copy(core::ptr::addr_of_mut!(info), core::ptr::addr_of!((*state).info_png));\n                if (*state).encoder.auto_convert != 0 {\n                    let mut stats = LodePNGColorStats {\n                        colored: 0,\n                        key: 0,\n                        key_r: 0,\n                        key_g: 0,\n                        key_b: 0,\n                        alpha: 0,\n                        numcolors: 0,\n                        palette: [0; 1024],\n                        bits: 0,\n                        numpixels: 0,\n                        allow_palette: 0,\n                        allow_greyscale: 0,\n                    };\n                    let mut allow_convert = 1 as libc::c_int as libc::c_uint;\n                    lodepng_color_stats_init(Some(&mut stats));\n                    if (*info_png).iccp_defined != 0\n                        && isGrayICCProfile(\n                            (*info_png).iccp_profile,\n                            (*info_png).iccp_profile_size,\n                        ) != 0\n                    {\n                        stats.allow_palette= 0 as libc::c_int as libc::c_uint;\n                    }\n                    if (*info_png).iccp_defined != 0\n                        && isRGBICCProfile(\n                            (*info_png).iccp_profile,\n                            (*info_png).iccp_profile_size,\n                        ) != 0\n                    {\n                        stats.allow_greyscale= 0 as libc::c_int as libc::c_uint;\n                    }\n                    (*state).error= lodepng_compute_color_stats(\n                        core::ptr::addr_of_mut!(stats),\n                        image,\n                        w,\n                        h,\n                        core::ptr::addr_of!((*state).info_raw),\n                    );\n                    if (*state).error != 0 {\n                        current_block= 11418055246242690407;\n                    } else {\n                        if (*info_png).background_defined != 0 {\n                            let mut r = 0 as libc::c_int as libc::c_uint;\n                            let mut g = 0 as libc::c_int as libc::c_uint;\n                            let mut b = 0 as libc::c_int as libc::c_uint;\n                            let mut mode16 = lodepng_color_mode_make(\n                                LCT_RGB,\n                                16 as libc::c_int as libc::c_uint,\n                            );\n                            lodepng_convert_rgb(\n                                core::ptr::addr_of_mut!(r),\n                                core::ptr::addr_of_mut!(g),\n                                core::ptr::addr_of_mut!(b),\n                                (*info_png).background_r,\n                                (*info_png).background_g,\n                                (*info_png).background_b,\n                                core::ptr::addr_of!(mode16),\n                                &(*info_png).color,\n                            );\n                            (*state).error= lodepng_color_stats_add(\n                                Some(&mut stats),\n                                r,\n                                g,\n                                b,\n                                65535 as libc::c_int as libc::c_uint,\n                            );\n                            if (*state).error != 0 {\n                                current_block= 11418055246242690407;\n                            } else {\n                                current_block= 2604890879466389055;\n                            }\n                        } else {\n                            current_block= 2604890879466389055;\n                        }\n                        match current_block {\n                            11418055246242690407 => {}\n                            _ => {\n                                (*state).error= auto_choose_color(\n                                    core::ptr::addr_of_mut!(auto_color),\n                                    core::ptr::addr_of!((*state).info_raw),\n                                    core::ptr::addr_of!(stats),\n                                );\n                                if (*state).error != 0 {\n                                    current_block= 11418055246242690407;\n                                } else {\n                                    if (*info_png).sbit_defined != 0 {\n                                        let mut sbit_max = if (if (if (*info_png).sbit_r\n                                            > (*info_png).sbit_g\n                                        {\n                                            (*info_png).sbit_r\n                                        } else {\n                                            (*info_png).sbit_g\n                                        }) > (*info_png).sbit_b\n                                        {\n                                            (if (*info_png).sbit_r > (*info_png).sbit_g {\n                                                (*info_png).sbit_r\n                                            } else {\n                                                (*info_png).sbit_g\n                                            })\n                                        } else {\n                                            (*info_png).sbit_b\n                                        }) > (*info_png).sbit_a\n                                        {\n                                            if (if (*info_png).sbit_r > (*info_png).sbit_g {\n                                                (*info_png).sbit_r\n                                            } else {\n                                                (*info_png).sbit_g\n                                            }) > (*info_png).sbit_b\n                                            {\n                                                if (*info_png).sbit_r > (*info_png).sbit_g {\n                                                    (*info_png).sbit_r\n                                                } else {\n                                                    (*info_png).sbit_g\n                                                }\n                                            } else {\n                                                (*info_png).sbit_b\n                                            }\n                                        } else {\n                                            (*info_png).sbit_a\n                                        };\n                                        let mut equal = (((*info_png).sbit_g == 0\n                                            || (*info_png).sbit_g == (*info_png).sbit_r)\n                                            && ((*info_png).sbit_b == 0\n                                                || (*info_png).sbit_b == (*info_png).sbit_r)\n                                            && ((*info_png).sbit_a == 0\n                                                || (*info_png).sbit_a == (*info_png).sbit_r)) as libc::c_int\n                                            as libc::c_uint;\n                                        allow_convert= 0 as libc::c_int as libc::c_uint;\n                                        if info.color.colortype as libc::c_uint\n                                            == LCT_PALETTE as libc::c_int as libc::c_uint\n                                            && auto_color.colortype as libc::c_uint\n                                                == LCT_PALETTE as libc::c_int as libc::c_uint\n                                        {\n                                            allow_convert= 1 as libc::c_int as libc::c_uint;\n                                        }\n                                        if info.color.colortype as libc::c_uint\n                                            == LCT_RGB as libc::c_int as libc::c_uint\n                                            && auto_color.colortype as libc::c_uint\n                                                == LCT_PALETTE as libc::c_int as libc::c_uint\n                                            && sbit_max <= 8 as libc::c_int as libc::c_uint\n                                        {\n                                            allow_convert= 1 as libc::c_int as libc::c_uint;\n                                        }\n                                        if info.color.colortype as libc::c_uint\n                                            == LCT_RGBA as libc::c_int as libc::c_uint\n                                            && auto_color.colortype as libc::c_uint\n                                                == LCT_PALETTE as libc::c_int as libc::c_uint\n                                            && (*info_png).sbit_a == 8 as libc::c_int as libc::c_uint\n                                            && sbit_max <= 8 as libc::c_int as libc::c_uint\n                                        {\n                                            allow_convert= 1 as libc::c_int as libc::c_uint;\n                                        }\n                                        if (info.color.colortype as libc::c_uint\n                                            == LCT_RGB as libc::c_int as libc::c_uint\n                                            || info.color.colortype as libc::c_uint\n                                                == LCT_RGBA as libc::c_int as libc::c_uint)\n                                            && info.color.bitdepth == 16 as libc::c_int as libc::c_uint\n                                            && auto_color.colortype as libc::c_uint\n                                                == info.color.colortype as libc::c_uint\n                                            && auto_color.bitdepth == 8 as libc::c_int as libc::c_uint\n                                            && sbit_max <= 8 as libc::c_int as libc::c_uint\n                                        {\n                                            allow_convert= 1 as libc::c_int as libc::c_uint;\n                                        }\n                                        if info.color.colortype as libc::c_uint\n                                            != LCT_PALETTE as libc::c_int as libc::c_uint\n                                            && auto_color.colortype as libc::c_uint\n                                                != LCT_PALETTE as libc::c_int as libc::c_uint && equal != 0\n                                            && (*info_png).sbit_r == auto_color.bitdepth\n                                        {\n                                            allow_convert= 1 as libc::c_int as libc::c_uint;\n                                        }\n                                    }\n                                    if (*state).encoder.force_palette != 0 {\n                                        if info.color.colortype as libc::c_uint\n                                            != LCT_GREY as libc::c_int as libc::c_uint\n                                            && info.color.colortype as libc::c_uint\n                                                != LCT_GREY_ALPHA as libc::c_int as libc::c_uint\n                                            && (auto_color.colortype as libc::c_uint\n                                                == LCT_GREY as libc::c_int as libc::c_uint\n                                                || auto_color.colortype as libc::c_uint\n                                                    == LCT_GREY_ALPHA as libc::c_int as libc::c_uint)\n                                        {\n                                            allow_convert= 0 as libc::c_int as libc::c_uint;\n                                        }\n                                    }\n                                    if allow_convert != 0 {\n                                        lodepng_color_mode_copy(core::ptr::addr_of_mut!(info.color), core::ptr::addr_of!(auto_color));\n                                        if (*info_png).background_defined != 0 {\n                                            if lodepng_convert_rgb(\n                                                core::ptr::addr_of_mut!(info.background_r),\n                                                core::ptr::addr_of_mut!(info.background_g),\n                                                core::ptr::addr_of_mut!(info.background_b),\n                                                (*info_png).background_r,\n                                                (*info_png).background_g,\n                                                (*info_png).background_b,\n                                                core::ptr::addr_of!(info.color),\n                                                &(*info_png).color,\n                                            ) != 0\n                                            {\n                                                (*state).error= 104 as libc::c_int as libc::c_uint;\n                                                current_block= 11418055246242690407;\n                                            } else {\n                                                current_block= 10067844863897285902;\n                                            }\n                                        } else {\n                                            current_block= 10067844863897285902;\n                                        }\n                                    } else {\n                                        current_block= 10067844863897285902;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    current_block= 10067844863897285902;\n                }\n                match current_block {\n                    11418055246242690407 => {}\n                    _ => {\n                        if (*info_png).iccp_defined != 0 {\n                            let mut gray_icc = isGrayICCProfile(\n                                (*info_png).iccp_profile,\n                                (*info_png).iccp_profile_size,\n                            );\n                            let mut rgb_icc = isRGBICCProfile(\n                                (*info_png).iccp_profile,\n                                (*info_png).iccp_profile_size,\n                            );\n                            let mut gray_png = (info.color.colortype as libc::c_uint\n                                == LCT_GREY as libc::c_int as libc::c_uint\n                                || info.color.colortype as libc::c_uint\n                                    == LCT_GREY_ALPHA as libc::c_int as libc::c_uint)\n                                as libc::c_int as libc::c_uint;\n                            if gray_icc == 0 && rgb_icc == 0 {\n                                (*state).error= 100 as libc::c_int as libc::c_uint;\n                                current_block= 11418055246242690407;\n                            } else if gray_icc != gray_png {\n                                (*state).error= (if (*state).encoder.auto_convert != 0 {\n                                    102 as libc::c_int\n                                } else {\n                                    101 as libc::c_int\n                                }) as libc::c_uint;\n                                current_block= 11418055246242690407;\n                            } else {\n                                current_block= 10809827304263610514;\n                            }\n                        } else {\n                            current_block= 10809827304263610514;\n                        }\n                        match current_block {\n                            11418055246242690407 => {}\n                            _ => {\n                                if lodepng_color_mode_equal(\n                                    core::ptr::addr_of!((*state).info_raw),\n                                    core::ptr::addr_of!(info.color),\n                                ) == 0\n                                {\n                                    let mut converted = 0 as *mut libc::c_uchar;\n                                    let mut size = (w as size_t)\n                                        .wrapping_mul(h as size_t)\n                                        .wrapping_mul(lodepng_get_bpp(core::ptr::addr_of!(info.color)) as size_t)\n                                        .wrapping_add(7 as libc::c_uint as libc::c_ulong)\n                                        .wrapping_div(8 as libc::c_uint as libc::c_ulong);\n                                    converted= lodepng_malloc(size) as *mut libc::c_uchar;\n                                    if converted.is_null() && size != 0 {\n                                        (*state).error= 83 as libc::c_int as libc::c_uint;\n                                    }\n                                    if (*state).error == 0 {\n                                        (*state).error= lodepng_convert(\n                                            converted,\n                                            image,\n                                            core::ptr::addr_of!(info.color),\n                                            core::ptr::addr_of!((*state).info_raw),\n                                            w,\n                                            h,\n                                        );\n                                    }\n                                    if (*state).error == 0 {\n                                        (*state).error= preProcessScanlines(\n                                            Some(&mut data),\n                                            Some(&mut datasize),\n                                            converted,\n                                            w,\n                                            h,\n                                            core::ptr::addr_of!(info),\n                                            core::ptr::addr_of!((*state).encoder),\n                                        );\n                                    }\n                                    lodepng_free(converted as *mut libc::c_void);\n                                    if (*state).error != 0 {\n                                        current_block= 11418055246242690407;\n                                    } else {\n                                        current_block= 11071260907632769126;\n                                    }\n                                } else {\n                                    (*state).error= preProcessScanlines(\n                                        Some(&mut data),\n                                        Some(&mut datasize),\n                                        image,\n                                        w,\n                                        h,\n                                        core::ptr::addr_of!(info),\n                                        core::ptr::addr_of!((*state).encoder),\n                                    );\n                                    if (*state).error != 0 {\n                                        current_block= 11418055246242690407;\n                                    } else {\n                                        current_block= 11071260907632769126;\n                                    }\n                                }\n                                match current_block {\n                                    11418055246242690407 => {}\n                                    _ => {\n                                        let mut i: size_t = 0;\n                                        (*state).error= writeSignature(core::ptr::addr_of_mut!(outv));\n                                        if !((*state).error != 0) {\n                                            (*state).error= addChunk_IHDR(\n                                                core::ptr::addr_of_mut!(outv),\n                                                w,\n                                                h,\n                                                info.color.colortype,\n                                                info.color.bitdepth,\n                                                info.interlace_method,\n                                            );\n                                            if !((*state).error != 0) {\n                                                if !info.unknown_chunks_data[0 as libc::c_int as usize]\n                                                    .is_null()\n                                                {\n                                                    (*state).error= addUnknownChunks(\n                                                        core::ptr::addr_of_mut!(outv),\n                                                        info.unknown_chunks_data[0 as libc::c_int as usize],\n                                                        info.unknown_chunks_size[0 as libc::c_int as usize],\n                                                    );\n                                                    if (*state).error != 0 {\n                                                        current_block= 11418055246242690407;\n                                                    } else {\n                                                        current_block= 4899250571165509867;\n                                                    }\n                                                } else {();\n                                                    current_block= 4899250571165509867;\n                                                }\n                                                match current_block {\n                                                    11418055246242690407 => {}\n                                                    _ => {\n                                                        if info.iccp_defined != 0 {\n                                                            (*state).error= addChunk_iCCP(\n                                                                core::ptr::addr_of_mut!(outv),\n                                                                core::ptr::addr_of!(info),\n                                                                core::ptr::addr_of_mut!((*state).encoder.zlibsettings),\n                                                            );\n                                                            if (*state).error != 0 {\n                                                                current_block= 11418055246242690407;\n                                                            } else {\n                                                                current_block= 5265702136860997526;\n                                                            }\n                                                        } else {\n                                                            current_block= 5265702136860997526;\n                                                        }\n                                                        match current_block {\n                                                            11418055246242690407 => {}\n                                                            _ => {\n                                                                if info.srgb_defined != 0 {\n                                                                    (*state).error= addChunk_sRGB(core::ptr::addr_of_mut!(outv), core::ptr::addr_of!(info));\n                                                                    if (*state).error != 0 {\n                                                                        current_block= 11418055246242690407;\n                                                                    } else {\n                                                                        current_block= 5409161009579131794;\n                                                                    }\n                                                                } else {\n                                                                    current_block= 5409161009579131794;\n                                                                }\n                                                                match current_block {\n                                                                    11418055246242690407 => {}\n                                                                    _ => {\n                                                                        if info.gama_defined != 0 {\n                                                                            (*state).error= addChunk_gAMA(core::ptr::addr_of_mut!(outv), core::ptr::addr_of!(info));\n                                                                            if (*state).error != 0 {\n                                                                                current_block= 11418055246242690407;\n                                                                            } else {\n                                                                                current_block= 10109057886293123569;\n                                                                            }\n                                                                        } else {\n                                                                            current_block= 10109057886293123569;\n                                                                        }\n                                                                        match current_block {\n                                                                            11418055246242690407 => {}\n                                                                            _ => {\n                                                                                if info.chrm_defined != 0 {\n                                                                                    (*state).error= addChunk_cHRM(core::ptr::addr_of_mut!(outv), core::ptr::addr_of!(info));\n                                                                                    if (*state).error != 0 {\n                                                                                        current_block= 11418055246242690407;\n                                                                                    } else {\n                                                                                        current_block= 14612007084265645573;\n                                                                                    }\n                                                                                } else {\n                                                                                    current_block= 14612007084265645573;\n                                                                                }\n                                                                                match current_block {\n                                                                                    11418055246242690407 => {}\n                                                                                    _ => {\n                                                                                        if (*info_png).sbit_defined != 0 {\n                                                                                            (*state).error= addChunk_sBIT(core::ptr::addr_of_mut!(outv), core::ptr::addr_of!(info));\n                                                                                            if (*state).error != 0 {\n                                                                                                current_block= 11418055246242690407;\n                                                                                            } else {\n                                                                                                current_block= 12963528325254160332;\n                                                                                            }\n                                                                                        } else {\n                                                                                            current_block= 12963528325254160332;\n                                                                                        }\n                                                                                        match current_block {\n                                                                                            11418055246242690407 => {}\n                                                                                            _ => {\n                                                                                                if info.color.colortype as libc::c_uint\n                                                                                                    == LCT_PALETTE as libc::c_int as libc::c_uint\n                                                                                                {\n                                                                                                    (*state).error= addChunk_PLTE(core::ptr::addr_of_mut!(outv), core::ptr::addr_of!(info.color));\n                                                                                                    if (*state).error != 0 {\n                                                                                                        current_block= 11418055246242690407;\n                                                                                                    } else {\n                                                                                                        current_block= 15417752026496523887;\n                                                                                                    }\n                                                                                                } else {\n                                                                                                    current_block= 15417752026496523887;\n                                                                                                }\n                                                                                                match current_block {\n                                                                                                    11418055246242690407 => {}\n                                                                                                    _ => {\n                                                                                                        if (*state).encoder.force_palette != 0\n                                                                                                            && (info.color.colortype as libc::c_uint\n                                                                                                                == LCT_RGB as libc::c_int as libc::c_uint\n                                                                                                                || info.color.colortype as libc::c_uint\n                                                                                                                    == LCT_RGBA as libc::c_int as libc::c_uint)\n                                                                                                        {\n                                                                                                            (*state).error= addChunk_PLTE(core::ptr::addr_of_mut!(outv), core::ptr::addr_of!(info.color));\n                                                                                                            if (*state).error != 0 {\n                                                                                                                current_block= 11418055246242690407;\n                                                                                                            } else {\n                                                                                                                current_block= 17736998403848444560;\n                                                                                                            }\n                                                                                                        } else {\n                                                                                                            current_block= 17736998403848444560;\n                                                                                                        }\n                                                                                                        match current_block {\n                                                                                                            11418055246242690407 => {}\n                                                                                                            _ => {\n                                                                                                                (*state).error= addChunk_tRNS(core::ptr::addr_of_mut!(outv), core::ptr::addr_of!(info.color));\n                                                                                                                if !((*state).error != 0) {\n                                                                                                                    if info.background_defined != 0 {\n                                                                                                                        (*state).error= addChunk_bKGD(core::ptr::addr_of_mut!(outv), core::ptr::addr_of!(info));\n                                                                                                                        if (*state).error != 0 {\n                                                                                                                            current_block= 11418055246242690407;\n                                                                                                                        } else {\n                                                                                                                            current_block= 18201902862271706575;\n                                                                                                                        }\n                                                                                                                    } else {\n                                                                                                                        current_block= 18201902862271706575;\n                                                                                                                    }\n                                                                                                                    match current_block {\n                                                                                                                        11418055246242690407 => {}\n                                                                                                                        _ => {\n                                                                                                                            if info.phys_defined != 0 {\n                                                                                                                                (*state).error= addChunk_pHYs(core::ptr::addr_of_mut!(outv), core::ptr::addr_of!(info));\n                                                                                                                                if (*state).error != 0 {\n                                                                                                                                    current_block= 11418055246242690407;\n                                                                                                                                } else {\n                                                                                                                                    current_block= 12608488225262500095;\n                                                                                                                                }\n                                                                                                                            } else {\n                                                                                                                                current_block= 12608488225262500095;\n                                                                                                                            }\n                                                                                                                            match current_block {\n                                                                                                                                11418055246242690407 => {}\n                                                                                                                                _ => {\n                                                                                                                                    if !info.unknown_chunks_data[1 as libc::c_int as usize]\n                                                                                                                                        .is_null()\n                                                                                                                                    {\n                                                                                                                                        (*state).error= addUnknownChunks(\n                                                                                                                                            core::ptr::addr_of_mut!(outv),\n                                                                                                                                            info.unknown_chunks_data[1 as libc::c_int as usize],\n                                                                                                                                            info.unknown_chunks_size[1 as libc::c_int as usize],\n                                                                                                                                        );\n                                                                                                                                        if (*state).error != 0 {\n                                                                                                                                            current_block= 11418055246242690407;\n                                                                                                                                        } else {\n                                                                                                                                            current_block= 9343041660989783267;\n                                                                                                                                        }\n                                                                                                                                    } else {();\n                                                                                                                                        current_block= 9343041660989783267;\n                                                                                                                                    }\n                                                                                                                                    match current_block {\n                                                                                                                                        11418055246242690407 => {}\n                                                                                                                                        _ => {\n                                                                                                                                            (*state).error= addChunk_IDAT(\n                                                                                                                                                core::ptr::addr_of_mut!(outv),\n                                                                                                                                                data,\n                                                                                                                                                datasize,\n                                                                                                                                                core::ptr::addr_of_mut!((*state).encoder.zlibsettings),\n                                                                                                                                            );\n                                                                                                                                            if !((*state).error != 0) {\n                                                                                                                                                if info.time_defined != 0 {\n                                                                                                                                                    (*state).error= addChunk_tIME(core::ptr::addr_of_mut!(outv), core::ptr::addr_of!(info.time));\n                                                                                                                                                    if (*state).error != 0 {\n                                                                                                                                                        current_block= 11418055246242690407;\n                                                                                                                                                    } else {\n                                                                                                                                                        current_block= 5710330377809666066;\n                                                                                                                                                    }\n                                                                                                                                                } else {\n                                                                                                                                                    current_block= 5710330377809666066;\n                                                                                                                                                }\n                                                                                                                                                match current_block {\n                                                                                                                                                    11418055246242690407 => {}\n                                                                                                                                                    _ => {\n                                                                                                                                                        i= 0 as libc::c_int as size_t;\n                                                                                                                                                        loop {\n                                                                                                                                                            if !(i != info.text_num) {\n                                                                                                                                                                current_block= 5511877782510663281;\n                                                                                                                                                                break;\n                                                                                                                                                            }\n                                                                                                                                                            if lodepng_strlen(*info.text_keys.offset(i as isize))\n                                                                                                                                                                > 79 as libc::c_int as libc::c_ulong\n                                                                                                                                                            {\n                                                                                                                                                                (*state).error= 66 as libc::c_int as libc::c_uint;\n                                                                                                                                                                current_block= 11418055246242690407;\n                                                                                                                                                                break;\n                                                                                                                                                            } else if lodepng_strlen(\n                                                                                                                                                                *info.text_keys.offset(i as isize),\n                                                                                                                                                            ) < 1 as libc::c_int as libc::c_ulong\n                                                                                                                                                            {\n                                                                                                                                                                (*state).error= 67 as libc::c_int as libc::c_uint;\n                                                                                                                                                                current_block= 11418055246242690407;\n                                                                                                                                                                break;\n                                                                                                                                                            } else {\n                                                                                                                                                                if (*state).encoder.text_compression != 0 {\n                                                                                                                                                                    (*state).error= addChunk_zTXt(\n                                                                                                                                                                        core::ptr::addr_of_mut!(outv),\n                                                                                                                                                                        *info.text_keys.offset(i as isize),\n                                                                                                                                                                        *info.text_strings.offset(i as isize),\n                                                                                                                                                                        core::ptr::addr_of_mut!((*state).encoder.zlibsettings),\n                                                                                                                                                                    );\n                                                                                                                                                                    if (*state).error != 0 {\n                                                                                                                                                                        current_block= 11418055246242690407;\n                                                                                                                                                                        break;\n                                                                                                                                                                    }\n                                                                                                                                                                } else {\n                                                                                                                                                                    (*state).error= addChunk_tEXt(\n                                                                                                                                                                        core::ptr::addr_of_mut!(outv),\n                                                                                                                                                                        *info.text_keys.offset(i as isize),\n                                                                                                                                                                        *info.text_strings.offset(i as isize),\n                                                                                                                                                                    );\n                                                                                                                                                                    if (*state).error != 0 {\n                                                                                                                                                                        current_block= 11418055246242690407;\n                                                                                                                                                                        break;\n                                                                                                                                                                    }\n                                                                                                                                                                }\n                                                                                                                                                                i= i.wrapping_add(1);\n                                                                                                                                                            }\n                                                                                                                                                        }\n                                                                                                                                                        match current_block {\n                                                                                                                                                            11418055246242690407 => {}\n                                                                                                                                                            _ => {\n                                                                                                                                                                if (*state).encoder.add_id != 0 {\n                                                                                                                                                                    let mut already_added_id_text = 0 as libc::c_int\n                                                                                                                                                                        as libc::c_uint;\n                                                                                                                                                                    i= 0 as libc::c_int as size_t;\n                                                                                                                                                                    while i != info.text_num {\n                                                                                                                                                                        let mut k: *const libc::c_char = *info.text_keys\n                                                                                                                                                                            .offset(i as isize);\n                                                                                                                                                                        if *k.offset(0 as libc::c_int as isize) as libc::c_int\n                                                                                                                                                                            == 'L' as i32\n                                                                                                                                                                            && *k.offset(1 as libc::c_int as isize) as libc::c_int\n                                                                                                                                                                                == 'o' as i32\n                                                                                                                                                                            && *k.offset(2 as libc::c_int as isize) as libc::c_int\n                                                                                                                                                                                == 'd' as i32\n                                                                                                                                                                            && *k.offset(3 as libc::c_int as isize) as libc::c_int\n                                                                                                                                                                                == 'e' as i32\n                                                                                                                                                                            && *k.offset(4 as libc::c_int as isize) as libc::c_int\n                                                                                                                                                                                == 'P' as i32\n                                                                                                                                                                            && *k.offset(5 as libc::c_int as isize) as libc::c_int\n                                                                                                                                                                                == 'N' as i32\n                                                                                                                                                                            && *k.offset(6 as libc::c_int as isize) as libc::c_int\n                                                                                                                                                                                == 'G' as i32\n                                                                                                                                                                            && *k.offset(7 as libc::c_int as isize) as libc::c_int\n                                                                                                                                                                                == '\\0' as i32\n                                                                                                                                                                        {\n                                                                                                                                                                            already_added_id_text= 1 as libc::c_int as libc::c_uint;\n                                                                                                                                                                            break;\n                                                                                                                                                                        } else {\n                                                                                                                                                                            i= i.wrapping_add(1);\n                                                                                                                                                                        }\n                                                                                                                                                                    }\n                                                                                                                                                                    if already_added_id_text == 0 as libc::c_int as libc::c_uint\n                                                                                                                                                                    {\n                                                                                                                                                                        (*state).error= addChunk_tEXt(\n                                                                                                                                                                            core::ptr::addr_of_mut!(outv),\n                                                                                                                                                                            b\"LodePNG\\0\" as *const u8 as *const libc::c_char,\n                                                                                                                                                                            crate::src::lodepng::LODEPNG_VERSION_STRING,\n                                                                                                                                                                        );\n                                                                                                                                                                        if (*state).error != 0 {\n                                                                                                                                                                            current_block= 11418055246242690407;\n                                                                                                                                                                        } else {\n                                                                                                                                                                            current_block= 6880299496751257707;\n                                                                                                                                                                        }\n                                                                                                                                                                    } else {\n                                                                                                                                                                        current_block= 6880299496751257707;\n                                                                                                                                                                    }\n                                                                                                                                                                } else {\n                                                                                                                                                                    current_block= 6880299496751257707;\n                                                                                                                                                                }\n                                                                                                                                                                match current_block {\n                                                                                                                                                                    11418055246242690407 => {}\n                                                                                                                                                                    _ => {\n                                                                                                                                                                        i= 0 as libc::c_int as size_t;\n                                                                                                                                                                        loop {\n                                                                                                                                                                            if !(i != info.itext_num) {\n                                                                                                                                                                                current_block= 13796196565926322821;\n                                                                                                                                                                                break;\n                                                                                                                                                                            }\n                                                                                                                                                                            if lodepng_strlen(*info.itext_keys.offset(i as isize))\n                                                                                                                                                                                > 79 as libc::c_int as libc::c_ulong\n                                                                                                                                                                            {\n                                                                                                                                                                                (*state).error= 66 as libc::c_int as libc::c_uint;\n                                                                                                                                                                                current_block= 11418055246242690407;\n                                                                                                                                                                                break;\n                                                                                                                                                                            } else if lodepng_strlen(\n                                                                                                                                                                                *info.itext_keys.offset(i as isize),\n                                                                                                                                                                            ) < 1 as libc::c_int as libc::c_ulong\n                                                                                                                                                                            {\n                                                                                                                                                                                (*state).error= 67 as libc::c_int as libc::c_uint;\n                                                                                                                                                                                current_block= 11418055246242690407;\n                                                                                                                                                                                break;\n                                                                                                                                                                            } else {\n                                                                                                                                                                                (*state).error= addChunk_iTXt(\n                                                                                                                                                                                    core::ptr::addr_of_mut!(outv),\n                                                                                                                                                                                    (*state).encoder.text_compression,\n                                                                                                                                                                                    *info.itext_keys.offset(i as isize),\n                                                                                                                                                                                    *info.itext_langtags.offset(i as isize),\n                                                                                                                                                                                    *info.itext_transkeys.offset(i as isize),\n                                                                                                                                                                                    *info.itext_strings.offset(i as isize),\n                                                                                                                                                                                    core::ptr::addr_of_mut!((*state).encoder.zlibsettings),\n                                                                                                                                                                                );\n                                                                                                                                                                                if (*state).error != 0 {\n                                                                                                                                                                                    current_block= 11418055246242690407;\n                                                                                                                                                                                    break;\n                                                                                                                                                                                }\n                                                                                                                                                                                i= i.wrapping_add(1);\n                                                                                                                                                                            }\n                                                                                                                                                                        }\n                                                                                                                                                                        match current_block {\n                                                                                                                                                                            11418055246242690407 => {}\n                                                                                                                                                                            _ => {\n                                                                                                                                                                                if !info.unknown_chunks_data[2 as libc::c_int as usize]\n                                                                                                                                                                                    .is_null()\n                                                                                                                                                                                {\n                                                                                                                                                                                    (*state).error= addUnknownChunks(\n                                                                                                                                                                                        core::ptr::addr_of_mut!(outv),\n                                                                                                                                                                                        info.unknown_chunks_data[2 as libc::c_int as usize],\n                                                                                                                                                                                        info.unknown_chunks_size[2 as libc::c_int as usize],\n                                                                                                                                                                                    );\n                                                                                                                                                                                    if (*state).error != 0 {\n                                                                                                                                                                                        current_block= 11418055246242690407;\n                                                                                                                                                                                    } else {\n                                                                                                                                                                                        current_block= 11322929247169729670;\n                                                                                                                                                                                    }\n                                                                                                                                                                                } else {();\n                                                                                                                                                                                    current_block= 11322929247169729670;\n                                                                                                                                                                                }\n                                                                                                                                                                                match current_block {\n                                                                                                                                                                                    11418055246242690407 => {}\n                                                                                                                                                                                    _ => {\n                                                                                                                                                                                        (*state).error= addChunk_IEND(Some(&mut outv));\n                                                                                                                                                                                        (*state).error != 0;\n                                                                                                                                                                                    }\n                                                                                                                                                                                }\n                                                                                                                                                                            }\n                                                                                                                                                                        }\n                                                                                                                                                                    }\n                                                                                                                                                                }\n                                                                                                                                                            }\n                                                                                                                                                        }\n                                                                                                                                                    }\n                                                                                                                                                }\n                                                                                                                                            }\n                                                                                                                                        }\n                                                                                                                                    }\n                                                                                                                                }\n                                                                                                                            }\n                                                                                                                        }\n                                                                                                                    }\n                                                                                                                }\n                                                                                                            }\n                                                                                                        }\n                                                                                                    }\n                                                                                                }\n                                                                                            }\n                                                                                        }\n                                                                                    }\n                                                                                }\n                                                                            }\n                                                                        }\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    lodepng_info_cleanup(Some(&mut info));\n    lodepng_free(data as *mut libc::c_void);\n    lodepng_color_mode_cleanup(Some(&mut auto_color));\n    *out= outv.data;\n    *outsize= outv.size;\n    return (*state).error;\n}","src::lodepng::unfilter":"unsafe extern \"C\" fn unfilter(\n    mut out: *mut libc::c_uchar,\n    mut in_0: *const libc::c_uchar,\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n    mut bpp: libc::c_uint,\n) -> libc::c_uint {\n    let mut y: libc::c_uint = 0;\n    let mut prevline = 0 as *mut libc::c_uchar;\n    let mut bytewidth = bpp\n        .wrapping_add(7 as libc::c_uint)\n        .wrapping_div(8 as libc::c_uint) as size_t;\n    let mut linebytes = (lodepng_get_raw_size_idat(\n        w,\n        1 as libc::c_int as libc::c_uint,\n        bpp,\n    ))\n        .wrapping_sub(1 as libc::c_uint as libc::c_ulong);\n    y= 0 as libc::c_int as libc::c_uint;\n    while y < h {\n        let mut outindex = linebytes.wrapping_mul(y as libc::c_ulong);\n        let mut inindex = (1 as libc::c_int as libc::c_ulong)\n            .wrapping_add(linebytes)\n            .wrapping_mul(y as libc::c_ulong);\n        let mut filterType = *in_0.offset(inindex as isize);\n        let mut error = unfilterScanline(\n            core::ptr::addr_of_mut!(*out.offset(outindex as isize)),\n            &*in_0\n                .offset(\n                    inindex.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                ),\n            prevline,\n            bytewidth,\n            filterType,\n            linebytes,\n        );\n        if error != 0 {\n            return error;\n        }\n        prevline= core::ptr::addr_of_mut!(*out.offset(outindex as isize)) as *mut libc::c_uchar;\n        y= y.wrapping_add(1);\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_strlen":"unsafe extern \"C\" fn lodepng_strlen(mut a: *const libc::c_char) -> size_t {\n    let mut orig = a;\n    while (*a) != 0 {\n        a= a.offset(1);\n    }\n    return a.offset_from(orig) as libc::c_long as size_t;\n}","src::lodepng::advanceBits":"unsafe extern \"C\" fn advanceBits(mut reader: Option<&mut LodePNGBitReader>, mut nbits: size_t) {\n    (*reader.as_deref_mut().unwrap()).buffer>>= nbits;\n    (*reader.as_deref_mut().unwrap()).bp= ((*reader.as_deref().unwrap()).bp as libc::c_ulong).wrapping_add(nbits) as size_t as size_t;\n}","src::lodepng::lodepng_set_icc":"pub unsafe extern \"C\" fn lodepng_set_icc(\n    mut info: *mut LodePNGInfo,\n    mut name: *const libc::c_char,\n    mut profile: *const libc::c_uchar,\n    mut profile_size: libc::c_uint,\n) -> libc::c_uint {\n    if !(*info).iccp_name.is_null() {\n        lodepng_clear_icc(info);\n    }else { (); }\n    (*info).iccp_defined= 1 as libc::c_int as libc::c_uint;\n    return lodepng_assign_icc(info, name, profile, profile_size);\n}","src::lodepng::getPixelColorRGBA16":"unsafe extern \"C\" fn getPixelColorRGBA16(\n    mut r: Option<&mut libc::c_ushort>,\n    mut g: Option<&mut libc::c_ushort>,\n    mut b: Option<&mut libc::c_ushort>,\n    mut a: Option<&mut libc::c_ushort>,\n    mut in_0: *const libc::c_uchar,\n    mut i: size_t,\n    mut mode: *const LodePNGColorMode,\n) {\n    if (*mode).colortype as libc::c_uint == LCT_GREY as libc::c_int as libc::c_uint {\n        *b.as_deref_mut().unwrap()= (256 as libc::c_int\n            * *in_0\n                .offset(\n                    i\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                ) as libc::c_int\n            + *in_0\n                .offset(\n                    i\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                ) as libc::c_int) as libc::c_ushort;\n        *g.as_deref_mut().unwrap()= (*b.as_deref().unwrap());\n        *r.as_deref_mut().unwrap()= (*g.as_deref().unwrap());\n        if (*mode).key_defined != 0\n            && (256 as libc::c_uint)\n                .wrapping_mul(\n                    *in_0\n                        .offset(\n                            i\n                                .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                        ) as libc::c_uint,\n                )\n                .wrapping_add(\n                    *in_0\n                        .offset(\n                            i\n                                .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                        ) as libc::c_uint,\n                ) == (*mode).key_r\n        {\n            *a.as_deref_mut().unwrap()= 0 as libc::c_int as libc::c_ushort;\n        } else {\n            *a.as_deref_mut().unwrap()= 65535 as libc::c_int as libc::c_ushort;\n        }\n    } else if (*mode).colortype as libc::c_uint == LCT_RGB as libc::c_int as libc::c_uint\n    {\n        *r.as_deref_mut().unwrap()= (256 as libc::c_uint)\n            .wrapping_mul(\n                *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint,\n            )\n            .wrapping_add(\n                *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint,\n            ) as libc::c_ushort;\n        *g.as_deref_mut().unwrap()= (256 as libc::c_uint)\n            .wrapping_mul(\n                *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint,\n            )\n            .wrapping_add(\n                *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint,\n            ) as libc::c_ushort;\n        *b.as_deref_mut().unwrap()= (256 as libc::c_uint)\n            .wrapping_mul(\n                *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(4 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint,\n            )\n            .wrapping_add(\n                *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(5 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint,\n            ) as libc::c_ushort;\n        if (*mode).key_defined != 0\n            && (256 as libc::c_uint)\n                .wrapping_mul(\n                    *in_0\n                        .offset(\n                            i\n                                .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                                .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                        ) as libc::c_uint,\n                )\n                .wrapping_add(\n                    *in_0\n                        .offset(\n                            i\n                                .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                        ) as libc::c_uint,\n                ) == (*mode).key_r\n            && (256 as libc::c_uint)\n                .wrapping_mul(\n                    *in_0\n                        .offset(\n                            i\n                                .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                                .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                        ) as libc::c_uint,\n                )\n                .wrapping_add(\n                    *in_0\n                        .offset(\n                            i\n                                .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                                .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                        ) as libc::c_uint,\n                ) == (*mode).key_g\n            && (256 as libc::c_uint)\n                .wrapping_mul(\n                    *in_0\n                        .offset(\n                            i\n                                .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                                .wrapping_add(4 as libc::c_int as libc::c_ulong) as isize,\n                        ) as libc::c_uint,\n                )\n                .wrapping_add(\n                    *in_0\n                        .offset(\n                            i\n                                .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                                .wrapping_add(5 as libc::c_int as libc::c_ulong) as isize,\n                        ) as libc::c_uint,\n                ) == (*mode).key_b\n        {\n            *a.as_deref_mut().unwrap()= 0 as libc::c_int as libc::c_ushort;\n        } else {\n            *a.as_deref_mut().unwrap()= 65535 as libc::c_int as libc::c_ushort;\n        }\n    } else if (*mode).colortype as libc::c_uint\n        == LCT_GREY_ALPHA as libc::c_int as libc::c_uint\n    {\n        *b.as_deref_mut().unwrap()= (256 as libc::c_uint)\n            .wrapping_mul(\n                *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint,\n            )\n            .wrapping_add(\n                *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint,\n            ) as libc::c_ushort;\n        *g.as_deref_mut().unwrap()= (*b.as_deref().unwrap());\n        *r.as_deref_mut().unwrap()= (*g.as_deref().unwrap());\n        *a.as_deref_mut().unwrap()= (256 as libc::c_uint)\n            .wrapping_mul(\n                *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint,\n            )\n            .wrapping_add(\n                *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint,\n            ) as libc::c_ushort;\n    } else if (*mode).colortype as libc::c_uint\n        == LCT_RGBA as libc::c_int as libc::c_uint\n    {\n        *r.as_deref_mut().unwrap()= (256 as libc::c_uint)\n            .wrapping_mul(\n                *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint,\n            )\n            .wrapping_add(\n                *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint,\n            ) as libc::c_ushort;\n        *g.as_deref_mut().unwrap()= (256 as libc::c_uint)\n            .wrapping_mul(\n                *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint,\n            )\n            .wrapping_add(\n                *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint,\n            ) as libc::c_ushort;\n        *b.as_deref_mut().unwrap()= (256 as libc::c_uint)\n            .wrapping_mul(\n                *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(4 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint,\n            )\n            .wrapping_add(\n                *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(5 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint,\n            ) as libc::c_ushort;\n        *a.as_deref_mut().unwrap()= (256 as libc::c_uint)\n            .wrapping_mul(\n                *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(6 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint,\n            )\n            .wrapping_add(\n                *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(7 as libc::c_int as libc::c_ulong) as isize,\n                    ) as libc::c_uint,\n            ) as libc::c_ushort;\n    }\n}","src::lodepng::ucvector_init":"unsafe extern \"C\" fn ucvector_init(\n    mut buffer: *mut libc::c_uchar,\n    mut size: size_t,\n) -> ucvector {\n    let mut v = ucvector {\n        data: 0 as *mut libc::c_uchar,\n        size: 0,\n        allocsize: 0,\n    };\n    v.data= buffer;\n    v.size= size;\n    v.allocsize= v.size;\n    return v;\n}","src::lodepng::lodepng_chunk_private":"pub unsafe extern \"C\" fn lodepng_chunk_private(\n    mut chunk: *const libc::c_uchar,\n) -> libc::c_uchar {\n    return (*chunk.offset(6 as libc::c_int as isize) as libc::c_int & 32 as libc::c_int\n        != 0 as libc::c_int) as libc::c_int as libc::c_uchar;\n}","src::lodepng::getPixelColorsRGBA8":"unsafe extern \"C\" fn getPixelColorsRGBA8(\n    mut buffer: *mut libc::c_uchar,\n    mut numpixels: size_t,\n    mut in_0: *const libc::c_uchar,\n    mut mode: *const LodePNGColorMode,\n) {\n    let mut num_channels = 4 as libc::c_int as libc::c_uint;\n    let mut i: size_t = 0;\n    if (*mode).colortype as libc::c_uint == LCT_GREY as libc::c_int as libc::c_uint {\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                *buffer.offset(2 as libc::c_int as isize) = *in_0.offset(i as isize); *buffer.offset(1 as libc::c_int as isize) = *buffer.offset(2 as libc::c_int as isize); *buffer.offset(0 as libc::c_int as isize) = *buffer.offset(1 as libc::c_int as isize);\n                *buffer\n                    .offset(\n                        3 as libc::c_int as isize,\n                    ) = 255 as libc::c_int as libc::c_uchar;\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n            if (*mode).key_defined != 0 {\n                buffer= buffer\n                    .offset(\n                        -(numpixels.wrapping_mul(num_channels as libc::c_ulong) as isize),\n                    );\n                i= 0 as libc::c_int as size_t;\n                while i != numpixels {\n                    if *buffer.offset(0 as libc::c_int as isize) as libc::c_uint\n                        == (*mode).key_r\n                    {\n                        *buffer\n                            .offset(\n                                3 as libc::c_int as isize,\n                            ) = 0 as libc::c_int as libc::c_uchar;\n                    }\n                    i= i.wrapping_add(1);\n                    buffer= buffer.offset(num_channels as isize);\n                }\n            }\n        } else if (*mode).bitdepth == 16 as libc::c_int as libc::c_uint {\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                *buffer.offset(2 as libc::c_int as isize) = *in_0\n                    .offset(i.wrapping_mul(2 as libc::c_int as libc::c_ulong) as isize); *buffer.offset(1 as libc::c_int as isize) = *buffer.offset(2 as libc::c_int as isize); *buffer.offset(0 as libc::c_int as isize) = *buffer.offset(1 as libc::c_int as isize);\n                *buffer\n                    .offset(\n                        3 as libc::c_int as isize,\n                    ) = (if (*mode).key_defined != 0\n                    && (256 as libc::c_uint)\n                        .wrapping_mul(\n                            *in_0\n                                .offset(\n                                    i\n                                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                        .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_uint,\n                        )\n                        .wrapping_add(\n                            *in_0\n                                .offset(\n                                    i\n                                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_uint,\n                        ) == (*mode).key_r\n                {\n                    0 as libc::c_int\n                } else {\n                    255 as libc::c_int\n                }) as libc::c_uchar;\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n        } else {\n            let mut highest = ((1 as libc::c_uint) << (*mode).bitdepth)\n                .wrapping_sub(1 as libc::c_uint);\n            let mut j = 0 as libc::c_int as size_t;\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                let mut value = readBitsFromReversedStream(\n                    Some(&mut j),\n                    in_0,\n                    (*mode).bitdepth as size_t,\n                );\n                *buffer.offset(2 as libc::c_int as isize) = value\n                    .wrapping_mul(255 as libc::c_int as libc::c_uint)\n                    .wrapping_div(highest) as libc::c_uchar; *buffer.offset(1 as libc::c_int as isize) = *buffer.offset(2 as libc::c_int as isize); *buffer.offset(0 as libc::c_int as isize) = *buffer.offset(1 as libc::c_int as isize);\n                *buffer\n                    .offset(\n                        3 as libc::c_int as isize,\n                    ) = (if (*mode).key_defined != 0 && value == (*mode).key_r {\n                    0 as libc::c_int\n                } else {\n                    255 as libc::c_int\n                }) as libc::c_uchar;\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n        }\n    } else if (*mode).colortype as libc::c_uint == LCT_RGB as libc::c_int as libc::c_uint\n    {\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                lodepng_memcpy(\n                    buffer as *mut libc::c_void,\n                    &*in_0\n                        .offset(\n                            i.wrapping_mul(3 as libc::c_int as libc::c_ulong) as isize,\n                        ) as *const libc::c_uchar as *const libc::c_void,\n                    3 as libc::c_int as size_t,\n                );\n                *buffer\n                    .offset(\n                        3 as libc::c_int as isize,\n                    ) = 255 as libc::c_int as libc::c_uchar;\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n            if (*mode).key_defined != 0 {\n                buffer= buffer\n                    .offset(\n                        -(numpixels.wrapping_mul(num_channels as libc::c_ulong) as isize),\n                    );\n                i= 0 as libc::c_int as size_t;\n                while i != numpixels {\n                    if *buffer.offset(0 as libc::c_int as isize) as libc::c_uint\n                        == (*mode).key_r\n                        && *buffer.offset(1 as libc::c_int as isize) as libc::c_uint\n                            == (*mode).key_g\n                        && *buffer.offset(2 as libc::c_int as isize) as libc::c_uint\n                            == (*mode).key_b\n                    {\n                        *buffer\n                            .offset(\n                                3 as libc::c_int as isize,\n                            ) = 0 as libc::c_int as libc::c_uchar;\n                    }\n                    i= i.wrapping_add(1);\n                    buffer= buffer.offset(num_channels as isize);\n                }\n            }\n        } else {\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                *buffer\n                    .offset(\n                        0 as libc::c_int as isize,\n                    ) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                    );\n                *buffer\n                    .offset(\n                        1 as libc::c_int as isize,\n                    ) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                    );\n                *buffer\n                    .offset(\n                        2 as libc::c_int as isize,\n                    ) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(4 as libc::c_int as libc::c_ulong) as isize,\n                    );\n                *buffer\n                    .offset(\n                        3 as libc::c_int as isize,\n                    ) = (if (*mode).key_defined != 0\n                    && (256 as libc::c_uint)\n                        .wrapping_mul(\n                            *in_0\n                                .offset(\n                                    i\n                                        .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                                        .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_uint,\n                        )\n                        .wrapping_add(\n                            *in_0\n                                .offset(\n                                    i\n                                        .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_uint,\n                        ) == (*mode).key_r\n                    && (256 as libc::c_uint)\n                        .wrapping_mul(\n                            *in_0\n                                .offset(\n                                    i\n                                        .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                                        .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_uint,\n                        )\n                        .wrapping_add(\n                            *in_0\n                                .offset(\n                                    i\n                                        .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                                        .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_uint,\n                        ) == (*mode).key_g\n                    && (256 as libc::c_uint)\n                        .wrapping_mul(\n                            *in_0\n                                .offset(\n                                    i\n                                        .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                                        .wrapping_add(4 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_uint,\n                        )\n                        .wrapping_add(\n                            *in_0\n                                .offset(\n                                    i\n                                        .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                                        .wrapping_add(5 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_uint,\n                        ) == (*mode).key_b\n                {\n                    0 as libc::c_int\n                } else {\n                    255 as libc::c_int\n                }) as libc::c_uchar;\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n        }\n    } else if (*mode).colortype as libc::c_uint\n        == LCT_PALETTE as libc::c_int as libc::c_uint\n    {\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                let mut index = *in_0.offset(i as isize) as libc::c_uint;\n                lodepng_memcpy(\n                    buffer as *mut libc::c_void,\n                    core::ptr::addr_of_mut!(*(*mode).palette\n                        .offset(\n                            index.wrapping_mul(4 as libc::c_int as libc::c_uint) as isize,\n                        )) as *mut libc::c_uchar as *const libc::c_void,\n                    4 as libc::c_int as size_t,\n                );\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n        } else {\n            let mut j_0 = 0 as libc::c_int as size_t;\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                let mut index_0 = readBitsFromReversedStream(\n                    Some(&mut j_0),\n                    in_0,\n                    (*mode).bitdepth as size_t,\n                );\n                lodepng_memcpy(\n                    buffer as *mut libc::c_void,\n                    core::ptr::addr_of_mut!(*(*mode).palette\n                        .offset(\n                            index_0.wrapping_mul(4 as libc::c_int as libc::c_uint)\n                                as isize,\n                        )) as *mut libc::c_uchar as *const libc::c_void,\n                    4 as libc::c_int as size_t,\n                );\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n        }\n    } else if (*mode).colortype as libc::c_uint\n        == LCT_GREY_ALPHA as libc::c_int as libc::c_uint\n    {\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                *buffer.offset(2 as libc::c_int as isize) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                    ); *buffer.offset(1 as libc::c_int as isize) = *buffer.offset(2 as libc::c_int as isize); *buffer.offset(0 as libc::c_int as isize) = *buffer.offset(1 as libc::c_int as isize);\n                *buffer\n                    .offset(\n                        3 as libc::c_int as isize,\n                    ) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                    );\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n        } else {\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                *buffer.offset(2 as libc::c_int as isize) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                    ); *buffer.offset(1 as libc::c_int as isize) = *buffer.offset(2 as libc::c_int as isize); *buffer.offset(0 as libc::c_int as isize) = *buffer.offset(1 as libc::c_int as isize);\n                *buffer\n                    .offset(\n                        3 as libc::c_int as isize,\n                    ) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                    );\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n        }\n    } else if (*mode).colortype as libc::c_uint\n        == LCT_RGBA as libc::c_int as libc::c_uint\n    {\n        if (*mode).bitdepth == 8 as libc::c_int as libc::c_uint {\n            lodepng_memcpy(\n                buffer as *mut libc::c_void,\n                in_0 as *const libc::c_void,\n                numpixels.wrapping_mul(4 as libc::c_int as libc::c_ulong),\n            );\n        } else {\n            i= 0 as libc::c_int as size_t;\n            while i != numpixels {\n                *buffer\n                    .offset(\n                        0 as libc::c_int as isize,\n                    ) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                    );\n                *buffer\n                    .offset(\n                        1 as libc::c_int as isize,\n                    ) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                    );\n                *buffer\n                    .offset(\n                        2 as libc::c_int as isize,\n                    ) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(4 as libc::c_int as libc::c_ulong) as isize,\n                    );\n                *buffer\n                    .offset(\n                        3 as libc::c_int as isize,\n                    ) = *in_0\n                    .offset(\n                        i\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(6 as libc::c_int as libc::c_ulong) as isize,\n                    );\n                i= i.wrapping_add(1);\n                buffer= buffer.offset(num_channels as isize);\n            }\n        }\n    }\n}","src::lodepng::update_adler32":"unsafe extern \"C\" fn update_adler32(\n    mut adler: libc::c_uint,\n    mut data: *const libc::c_uchar,\n    mut len: libc::c_uint,\n) -> libc::c_uint {\n    let mut s1 = adler & 0xffff as libc::c_uint;\n    let mut s2 = adler >> 16 as libc::c_uint & 0xffff as libc::c_uint;\n    while len != 0 as libc::c_uint {\n        let mut i: libc::c_uint = 0;\n        let mut amount = if len > 5552 as libc::c_uint {\n            5552 as libc::c_uint\n        } else {\n            len\n        };\n        len= len.wrapping_sub(amount);\n        i= 0 as libc::c_int as libc::c_uint;\n        while i != amount {\n            let fresh73 = data;\n            data= data.offset(1);\n            s1= s1.wrapping_add((*fresh73) as libc::c_uint);\n            s2= s2.wrapping_add(s1);\n            i= i.wrapping_add(1);\n        }\n        s1= s1.wrapping_rem(65521 as libc::c_uint);\n        s2= s2.wrapping_rem(65521 as libc::c_uint);\n    }\n    return s2 << 16 as libc::c_uint | s1;\n}","src::lodepng::inflateHuffmanBlock":"unsafe extern \"C\" fn inflateHuffmanBlock(\n    mut out: *mut ucvector,\n    mut reader: Option<&mut LodePNGBitReader>,\n    mut btype: libc::c_uint,\n    mut max_output_size: size_t,\n) -> libc::c_uint {\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut tree_ll = HuffmanTree {\n        codes: 0 as *mut libc::c_uint,\n        lengths: 0 as *mut libc::c_uint,\n        maxbitlen: 0,\n        numcodes: 0,\n        table_len: 0 as *mut libc::c_uchar,\n        table_value: 0 as *mut libc::c_ushort,\n    };\n    let mut tree_d = HuffmanTree {\n        codes: 0 as *mut libc::c_uint,\n        lengths: 0 as *mut libc::c_uint,\n        maxbitlen: 0,\n        numcodes: 0,\n        table_len: 0 as *mut libc::c_uchar,\n        table_value: 0 as *mut libc::c_ushort,\n    };\n    let reserved_size = 260 as libc::c_int as size_t;\n    let mut done = 0 as libc::c_int;\n    if {let crown_promoted_local_0 = (*out).size.wrapping_add(reserved_size);ucvector_reserve(out, crown_promoted_local_0)} == 0 {\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    HuffmanTree_init(Some(&mut tree_ll));\n    HuffmanTree_init(Some(&mut tree_d));\n    if btype == 1 as libc::c_int as libc::c_uint {\n        error= getTreeInflateFixed(core::ptr::addr_of_mut!(tree_ll), core::ptr::addr_of_mut!(tree_d));\n    } else {\n        error= getTreeInflateDynamic(core::ptr::addr_of_mut!(tree_ll), core::ptr::addr_of_mut!(tree_d), reader.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()));\n    }\n    while error == 0 && done == 0 {\n        let mut code_ll: libc::c_uint = 0;\n        ensureBits32(reader.as_deref_mut(), 30 as libc::c_int as size_t);\n        code_ll= huffmanDecodeSymbol(reader.as_deref_mut(), core::ptr::addr_of!(tree_ll));\n        if code_ll <= 255 as libc::c_int as libc::c_uint {\n            let fresh47 = (*out).size;(*out).size= (*out).size.wrapping_add(1);\n            *(*out).data.offset(fresh47 as isize) = code_ll as libc::c_uchar;\n            code_ll= huffmanDecodeSymbol(reader.as_deref_mut(), core::ptr::addr_of!(tree_ll));\n        }\n        if code_ll <= 255 as libc::c_int as libc::c_uint {\n            let fresh49 = (*out).size;(*out).size= (*out).size.wrapping_add(1);\n            *(*out).data.offset(fresh49 as isize) = code_ll as libc::c_uchar;\n        } else if code_ll >= 257 as libc::c_int as libc::c_uint\n            && code_ll <= 285 as libc::c_int as libc::c_uint\n        {\n            let mut code_d: libc::c_uint = 0;\n            let mut distance: libc::c_uint = 0;\n            let mut numextrabits_l: libc::c_uint = 0;\n            let mut numextrabits_d: libc::c_uint = 0;\n            let mut start: size_t = 0;\n            let mut backward: size_t = 0;\n            let mut length: size_t = 0;\n            length= crate::src::lodepng::LENGTHBASE[code_ll.wrapping_sub(257 as libc::c_int as libc::c_uint)\n                as usize] as size_t;\n            numextrabits_l= crate::src::lodepng::LENGTHEXTRA[code_ll\n                .wrapping_sub(257 as libc::c_int as libc::c_uint) as usize];\n            if numextrabits_l != 0 as libc::c_int as libc::c_uint {\n                ensureBits25(reader.as_deref_mut(), 5 as libc::c_int as size_t);\n                length= (length as libc::c_ulong)\n                    .wrapping_add(\n                        readBits(reader.as_deref_mut(), numextrabits_l as size_t) as libc::c_ulong,\n                    ) as size_t as size_t;\n            }\n            ensureBits32(reader.as_deref_mut(), 28 as libc::c_int as size_t);\n            code_d= huffmanDecodeSymbol(reader.as_deref_mut(), core::ptr::addr_of!(tree_d));\n            if code_d > 29 as libc::c_int as libc::c_uint {\n                if code_d <= 31 as libc::c_int as libc::c_uint {\n                    error= 18 as libc::c_int as libc::c_uint;\n                    break;\n                } else {\n                    error= 16 as libc::c_int as libc::c_uint;\n                    break;\n                }\n            } else {\n                distance= crate::src::lodepng::DISTANCEBASE[code_d as usize];\n                numextrabits_d= crate::src::lodepng::DISTANCEEXTRA[code_d as usize];\n                if numextrabits_d != 0 as libc::c_int as libc::c_uint {\n                    distance= distance\n                        .wrapping_add(readBits(reader.as_deref_mut(), numextrabits_d as size_t));\n                }\n                start= (*out).size;\n                if distance as libc::c_ulong > start {\n                    error= 52 as libc::c_int as libc::c_uint;\n                    break;\n                } else {\n                    backward= start.wrapping_sub(distance as libc::c_ulong);\n                    (*out).size= ((*out).size as libc::c_ulong).wrapping_add(length) as size_t\n                        as size_t;\n                    if (distance as libc::c_ulong) < length {\n                        let mut forward: size_t = 0;\n                        lodepng_memcpy(\n                            (*out).data.offset(start as isize) as *mut libc::c_void,\n                            (*out).data.offset(backward as isize)\n                                as *const libc::c_void,\n                            distance as size_t,\n                        );\n                        start= (start as libc::c_ulong)\n                            .wrapping_add(distance as libc::c_ulong) as size_t as size_t;\n                        forward= distance as size_t;\n                        while forward < length {\n                            let fresh51 = backward;\n                            backward= backward.wrapping_add(1);\n                            let fresh52 = start;\n                            start= start.wrapping_add(1);\n                            *(*out).data\n                                .offset(\n                                    fresh52 as isize,\n                                ) = *(*out).data.offset(fresh51 as isize);\n                            forward= forward.wrapping_add(1);\n                        }\n                    } else {\n                        lodepng_memcpy(\n                            (*out).data.offset(start as isize) as *mut libc::c_void,\n                            (*out).data.offset(backward as isize)\n                                as *const libc::c_void,\n                            length,\n                        );\n                    }\n                }\n            }\n        } else if code_ll == 256 as libc::c_int as libc::c_uint {\n            done= 1 as libc::c_int;\n        } else {\n            error= 16 as libc::c_int as libc::c_uint;\n            break;\n        }\n        if (*out).allocsize.wrapping_sub((*out).size) < reserved_size {\n            if {let crown_promoted_local_1 = (*out).size.wrapping_add(reserved_size);ucvector_reserve(out, crown_promoted_local_1)} == 0 {\n                error= 83 as libc::c_int as libc::c_uint;\n                break;\n            }\n        }\n        if (*reader.as_deref().unwrap()).bp > (*reader.as_deref().unwrap()).bitsize {\n            error= 51 as libc::c_int as libc::c_uint;\n            break;\n        } else {\n            if !(max_output_size != 0 && (*out).size > max_output_size) {\n                continue;\n            }\n            error= 109 as libc::c_int as libc::c_uint;\n            break;\n        }\n    }\n    HuffmanTree_cleanup(Some(&mut tree_ll));\n    HuffmanTree_cleanup(Some(&mut tree_d));\n    return error;\n}","src::lodepng::LodePNGUnknownChunks_copy":"unsafe extern \"C\" fn LodePNGUnknownChunks_copy(\n    mut dest: *mut LodePNGInfo,\n    mut src: *const LodePNGInfo,\n) -> libc::c_uint {\n    let mut i: libc::c_uint = 0;\n    LodePNGUnknownChunks_cleanup(dest);\n    i= 0 as libc::c_int as libc::c_uint;\n    while i != 3 as libc::c_int as libc::c_uint {\n        let mut j: size_t = 0;\n        (*dest).unknown_chunks_size[i as usize]= (*src).unknown_chunks_size[i as usize];\n        (*dest).unknown_chunks_data[i as usize]= lodepng_malloc((*src).unknown_chunks_size[i as usize])\n            as *mut libc::c_uchar;\n        if (*dest).unknown_chunks_data[i as usize].is_null()\n            && (*dest).unknown_chunks_size[i as usize] != 0\n        {\n            return 83 as libc::c_int as libc::c_uint;\n        }\n        j= 0 as libc::c_int as size_t;\n        while j < (*src).unknown_chunks_size[i as usize] {\n            *(*dest).unknown_chunks_data[i as usize]\n                .offset(\n                    j as isize,\n                ) = *(*src).unknown_chunks_data[i as usize].offset(j as isize);\n            j= j.wrapping_add(1);\n        }\n        i= i.wrapping_add(1);\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_realloc":"unsafe extern \"C\" fn lodepng_realloc(\n    mut ptr: *mut /* owning */ libc::c_void,\n    mut new_size: size_t,\n) -> *mut /* owning */ libc::c_void {\n    return realloc(ptr, new_size);\n}","src::lodepng::ucvector_reserve":"unsafe extern \"C\" fn ucvector_reserve(\n    mut p: *mut ucvector,\n    mut size: size_t,\n) -> libc::c_uint {\n    if size > (*p).allocsize {\n        let mut newsize = size.wrapping_add((*p).allocsize >> 1 as libc::c_uint);\n        let mut data = lodepng_realloc((*p).data as *mut libc::c_void, newsize);\n        if !data.is_null() {\n            (*p).allocsize= newsize;\n            (*p).data= data as *mut libc::c_uchar;\n        } else {();\n            return 0 as libc::c_int as libc::c_uint\n        }\n    }\n    return 1 as libc::c_int as libc::c_uint;\n}","src::lodepng::setBitOfReversedStream":"unsafe extern \"C\" fn setBitOfReversedStream(\n    mut bitpointer: Option<&mut size_t>,\n    mut bitstream: *mut libc::c_uchar,\n    mut bit: libc::c_uchar,\n) {\n    if bit as libc::c_int == 0 as libc::c_int {\n        *bitstream\n            .offset(((*bitpointer.as_deref().unwrap()) >> 3 as libc::c_uint) as isize) = (*bitstream\n            .offset(((*bitpointer.as_deref().unwrap()) >> 3 as libc::c_uint) as isize) as libc::c_int\n            & !((1 as libc::c_uint)\n                << (7 as libc::c_uint as libc::c_ulong)\n                    .wrapping_sub((*bitpointer.as_deref().unwrap()) & 7 as libc::c_uint as libc::c_ulong))\n                as libc::c_uchar as libc::c_int) as libc::c_uchar;\n    } else {\n        *bitstream\n            .offset(((*bitpointer.as_deref().unwrap()) >> 3 as libc::c_uint) as isize) = (*bitstream\n            .offset(((*bitpointer.as_deref().unwrap()) >> 3 as libc::c_uint) as isize) as libc::c_uint\n            | (1 as libc::c_uint)\n                << (7 as libc::c_uint as libc::c_ulong)\n                    .wrapping_sub((*bitpointer.as_deref().unwrap()) & 7 as libc::c_uint as libc::c_ulong))\n            as libc::c_uchar;\n    }\n    *bitpointer.as_deref_mut().unwrap()= (*bitpointer.as_deref().unwrap()).wrapping_add(1);\n}","src::lodepng::lodepng_decode_file":"pub unsafe extern \"C\" fn lodepng_decode_file(\n    mut out: Option<&mut *mut libc::c_uchar>,\n    mut w: Option<&mut libc::c_uint>,\n    mut h: Option<&mut libc::c_uint>,\n    mut filename: *const libc::c_char,\n    mut colortype: LodePNGColorType,\n    mut bitdepth: libc::c_uint,\n) -> libc::c_uint {\n    let mut buffer = 0 as *mut libc::c_uchar;\n    let mut buffersize: size_t = 0;\n    let mut error: libc::c_uint = 0;\n    *out.as_deref_mut().unwrap()= 0 as *mut libc::c_uchar;\n    *h.as_deref_mut().unwrap()= 0 as libc::c_int as libc::c_uint;\n    *w.as_deref_mut().unwrap()= (*h.as_deref().unwrap());\n    error= lodepng_load_file(Some(&mut buffer), Some(&mut buffersize), filename);\n    if error == 0 {\n        error= lodepng_decode_memory(\n            out.as_deref_mut(),\n            w.as_deref_mut(),\n            h.as_deref_mut(),\n            buffer as *const u8,\n            buffersize,\n            colortype,\n            bitdepth,\n        );\n    }\n    lodepng_free(buffer as *mut libc::c_void);\n    return error;\n}","src::lodepng::lodepng_decode24_file":"pub unsafe extern \"C\" fn lodepng_decode24_file(\n    mut out: Option<&mut *mut libc::c_uchar>,\n    mut w: Option<&mut libc::c_uint>,\n    mut h: Option<&mut libc::c_uint>,\n    mut filename: *const libc::c_char,\n) -> libc::c_uint {\n    return lodepng_decode_file(\n        out.as_deref_mut(),\n        w.as_deref_mut(),\n        h.as_deref_mut(),\n        filename,\n        LCT_RGB,\n        8 as libc::c_int as libc::c_uint,\n    );\n}","src::lodepng::rgba16ToPixel":"unsafe extern \"C\" fn rgba16ToPixel(\n    mut out: *mut libc::c_uchar,\n    mut i: size_t,\n    mut mode: *const LodePNGColorMode,\n    mut r: libc::c_ushort,\n    mut g: libc::c_ushort,\n    mut b: libc::c_ushort,\n    mut a: libc::c_ushort,\n) {\n    if (*mode).colortype as libc::c_uint == LCT_GREY as libc::c_int as libc::c_uint {\n        let mut gray = r;\n        *out\n            .offset(\n                i\n                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n            ) = (gray as libc::c_int >> 8 as libc::c_int & 255 as libc::c_int)\n            as libc::c_uchar;\n        *out\n            .offset(\n                i\n                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n            ) = (gray as libc::c_int & 255 as libc::c_int) as libc::c_uchar;\n    } else if (*mode).colortype as libc::c_uint == LCT_RGB as libc::c_int as libc::c_uint\n    {\n        *out\n            .offset(\n                i\n                    .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n            ) = (r as libc::c_int >> 8 as libc::c_int & 255 as libc::c_int)\n            as libc::c_uchar;\n        *out\n            .offset(\n                i\n                    .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n            ) = (r as libc::c_int & 255 as libc::c_int) as libc::c_uchar;\n        *out\n            .offset(\n                i\n                    .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n            ) = (g as libc::c_int >> 8 as libc::c_int & 255 as libc::c_int)\n            as libc::c_uchar;\n        *out\n            .offset(\n                i\n                    .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n            ) = (g as libc::c_int & 255 as libc::c_int) as libc::c_uchar;\n        *out\n            .offset(\n                i\n                    .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(4 as libc::c_int as libc::c_ulong) as isize,\n            ) = (b as libc::c_int >> 8 as libc::c_int & 255 as libc::c_int)\n            as libc::c_uchar;\n        *out\n            .offset(\n                i\n                    .wrapping_mul(6 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(5 as libc::c_int as libc::c_ulong) as isize,\n            ) = (b as libc::c_int & 255 as libc::c_int) as libc::c_uchar;\n    } else if (*mode).colortype as libc::c_uint\n        == LCT_GREY_ALPHA as libc::c_int as libc::c_uint\n    {\n        let mut gray_0 = r;\n        *out\n            .offset(\n                i\n                    .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n            ) = (gray_0 as libc::c_int >> 8 as libc::c_int & 255 as libc::c_int)\n            as libc::c_uchar;\n        *out\n            .offset(\n                i\n                    .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n            ) = (gray_0 as libc::c_int & 255 as libc::c_int) as libc::c_uchar;\n        *out\n            .offset(\n                i\n                    .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n            ) = (a as libc::c_int >> 8 as libc::c_int & 255 as libc::c_int)\n            as libc::c_uchar;\n        *out\n            .offset(\n                i\n                    .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n            ) = (a as libc::c_int & 255 as libc::c_int) as libc::c_uchar;\n    } else if (*mode).colortype as libc::c_uint\n        == LCT_RGBA as libc::c_int as libc::c_uint\n    {\n        *out\n            .offset(\n                i\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n            ) = (r as libc::c_int >> 8 as libc::c_int & 255 as libc::c_int)\n            as libc::c_uchar;\n        *out\n            .offset(\n                i\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n            ) = (r as libc::c_int & 255 as libc::c_int) as libc::c_uchar;\n        *out\n            .offset(\n                i\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n            ) = (g as libc::c_int >> 8 as libc::c_int & 255 as libc::c_int)\n            as libc::c_uchar;\n        *out\n            .offset(\n                i\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n            ) = (g as libc::c_int & 255 as libc::c_int) as libc::c_uchar;\n        *out\n            .offset(\n                i\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(4 as libc::c_int as libc::c_ulong) as isize,\n            ) = (b as libc::c_int >> 8 as libc::c_int & 255 as libc::c_int)\n            as libc::c_uchar;\n        *out\n            .offset(\n                i\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(5 as libc::c_int as libc::c_ulong) as isize,\n            ) = (b as libc::c_int & 255 as libc::c_int) as libc::c_uchar;\n        *out\n            .offset(\n                i\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(6 as libc::c_int as libc::c_ulong) as isize,\n            ) = (a as libc::c_int >> 8 as libc::c_int & 255 as libc::c_int)\n            as libc::c_uchar;\n        *out\n            .offset(\n                i\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(7 as libc::c_int as libc::c_ulong) as isize,\n            ) = (a as libc::c_int & 255 as libc::c_int) as libc::c_uchar;\n    }\n}","src::lodepng::unfilterScanline":"unsafe extern \"C\" fn unfilterScanline(\n    mut recon: *mut libc::c_uchar,\n    mut scanline: *const libc::c_uchar,\n    mut precon: *const libc::c_uchar,\n    mut bytewidth: size_t,\n    mut filterType: libc::c_uchar,\n    mut length: size_t,\n) -> libc::c_uint {\n    let mut i: size_t = 0;\n    match  filterType as libc::c_int {\n        0 => {\n            i= 0 as libc::c_int as size_t;\n            while i != length {\n                *recon.offset(i as isize) = *scanline.offset(i as isize);\n                i= i.wrapping_add(1);\n            }\n        }\n        1 => {\n            let mut j = 0 as libc::c_int as size_t;\n            i= 0 as libc::c_int as size_t;\n            while i != bytewidth {\n                *recon.offset(i as isize) = *scanline.offset(i as isize);\n                i= i.wrapping_add(1);\n            }\n            i= bytewidth;\n            while i != length {\n                *recon\n                    .offset(\n                        i as isize,\n                    ) = (*scanline.offset(i as isize) as libc::c_int\n                    + *recon.offset(j as isize) as libc::c_int) as libc::c_uchar;\n                i= i.wrapping_add(1);\n                j= j.wrapping_add(1);\n            }\n        }\n        2 => {\n            if !precon.is_null() {\n                i= 0 as libc::c_int as size_t;\n                while i != length {\n                    *recon\n                        .offset(\n                            i as isize,\n                        ) = (*scanline.offset(i as isize) as libc::c_int\n                        + *precon.offset(i as isize) as libc::c_int) as libc::c_uchar;\n                    i= i.wrapping_add(1);\n                }\n            } else {();\n                i= 0 as libc::c_int as size_t;\n                while i != length {\n                    *recon.offset(i as isize) = *scanline.offset(i as isize);\n                    i= i.wrapping_add(1);\n                }\n            }\n        }\n        3 => {\n            if !precon.is_null() {\n                let mut j_0 = 0 as libc::c_int as size_t;\n                i= 0 as libc::c_int as size_t;\n                while i != bytewidth {\n                    *recon\n                        .offset(\n                            i as isize,\n                        ) = (*scanline.offset(i as isize) as libc::c_int\n                        + (*precon.offset(i as isize) as libc::c_int\n                            >> 1 as libc::c_uint)) as libc::c_uchar;\n                    i= i.wrapping_add(1);\n                }\n                if bytewidth >= 4 as libc::c_int as libc::c_ulong {\n                    while i.wrapping_add(3 as libc::c_int as libc::c_ulong) < length {\n                        let mut s0 = *scanline\n                            .offset(\n                                i.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut s1 = *scanline\n                            .offset(\n                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut s2 = *scanline\n                            .offset(\n                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut s3 = *scanline\n                            .offset(\n                                i.wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut r0 = *recon\n                            .offset(\n                                j_0.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut r1 = *recon\n                            .offset(\n                                j_0.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut r2 = *recon\n                            .offset(\n                                j_0.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut r3 = *recon\n                            .offset(\n                                j_0.wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut p0 = *precon\n                            .offset(\n                                i.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut p1 = *precon\n                            .offset(\n                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut p2 = *precon\n                            .offset(\n                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut p3 = *precon\n                            .offset(\n                                i.wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        *recon\n                            .offset(\n                                i.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            ) = (s0 as libc::c_int\n                            + (r0 as libc::c_int + p0 as libc::c_int\n                                >> 1 as libc::c_uint)) as libc::c_uchar;\n                        *recon\n                            .offset(\n                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            ) = (s1 as libc::c_int\n                            + (r1 as libc::c_int + p1 as libc::c_int\n                                >> 1 as libc::c_uint)) as libc::c_uchar;\n                        *recon\n                            .offset(\n                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            ) = (s2 as libc::c_int\n                            + (r2 as libc::c_int + p2 as libc::c_int\n                                >> 1 as libc::c_uint)) as libc::c_uchar;\n                        *recon\n                            .offset(\n                                i.wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                            ) = (s3 as libc::c_int\n                            + (r3 as libc::c_int + p3 as libc::c_int\n                                >> 1 as libc::c_uint)) as libc::c_uchar;\n                        i= (i as libc::c_ulong)\n                            .wrapping_add(4 as libc::c_int as libc::c_ulong) as size_t\n                            as size_t;\n                        j_0= (j_0 as libc::c_ulong)\n                            .wrapping_add(4 as libc::c_int as libc::c_ulong) as size_t\n                            as size_t;\n                    }\n                } else if bytewidth >= 3 as libc::c_int as libc::c_ulong {\n                    while i.wrapping_add(2 as libc::c_int as libc::c_ulong) < length {\n                        let mut s0_0 = *scanline\n                            .offset(\n                                i.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut s1_0 = *scanline\n                            .offset(\n                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut s2_0 = *scanline\n                            .offset(\n                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut r0_0 = *recon\n                            .offset(\n                                j_0.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut r1_0 = *recon\n                            .offset(\n                                j_0.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut r2_0 = *recon\n                            .offset(\n                                j_0.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut p0_0 = *precon\n                            .offset(\n                                i.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut p1_0 = *precon\n                            .offset(\n                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut p2_0 = *precon\n                            .offset(\n                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        *recon\n                            .offset(\n                                i.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            ) = (s0_0 as libc::c_int\n                            + (r0_0 as libc::c_int + p0_0 as libc::c_int\n                                >> 1 as libc::c_uint)) as libc::c_uchar;\n                        *recon\n                            .offset(\n                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            ) = (s1_0 as libc::c_int\n                            + (r1_0 as libc::c_int + p1_0 as libc::c_int\n                                >> 1 as libc::c_uint)) as libc::c_uchar;\n                        *recon\n                            .offset(\n                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            ) = (s2_0 as libc::c_int\n                            + (r2_0 as libc::c_int + p2_0 as libc::c_int\n                                >> 1 as libc::c_uint)) as libc::c_uchar;\n                        i= (i as libc::c_ulong)\n                            .wrapping_add(3 as libc::c_int as libc::c_ulong) as size_t\n                            as size_t;\n                        j_0= (j_0 as libc::c_ulong)\n                            .wrapping_add(3 as libc::c_int as libc::c_ulong) as size_t\n                            as size_t;\n                    }\n                } else if bytewidth >= 2 as libc::c_int as libc::c_ulong {\n                    while i.wrapping_add(1 as libc::c_int as libc::c_ulong) < length {\n                        let mut s0_1 = *scanline\n                            .offset(\n                                i.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut s1_1 = *scanline\n                            .offset(\n                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut r0_1 = *recon\n                            .offset(\n                                j_0.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut r1_1 = *recon\n                            .offset(\n                                j_0.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut p0_1 = *precon\n                            .offset(\n                                i.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut p1_1 = *precon\n                            .offset(\n                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        *recon\n                            .offset(\n                                i.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            ) = (s0_1 as libc::c_int\n                            + (r0_1 as libc::c_int + p0_1 as libc::c_int\n                                >> 1 as libc::c_uint)) as libc::c_uchar;\n                        *recon\n                            .offset(\n                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            ) = (s1_1 as libc::c_int\n                            + (r1_1 as libc::c_int + p1_1 as libc::c_int\n                                >> 1 as libc::c_uint)) as libc::c_uchar;\n                        i= (i as libc::c_ulong)\n                            .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                            as size_t;\n                        j_0= (j_0 as libc::c_ulong)\n                            .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                            as size_t;\n                    }\n                }\n                while i != length {\n                    *recon\n                        .offset(\n                            i as isize,\n                        ) = (*scanline.offset(i as isize) as libc::c_int\n                        + (*recon.offset(j_0 as isize) as libc::c_int\n                            + *precon.offset(i as isize) as libc::c_int\n                            >> 1 as libc::c_uint)) as libc::c_uchar;\n                    i= i.wrapping_add(1);\n                    j_0= j_0.wrapping_add(1);\n                }\n            } else {();\n                let mut j_1 = 0 as libc::c_int as size_t;\n                i= 0 as libc::c_int as size_t;\n                while i != bytewidth {\n                    *recon.offset(i as isize) = *scanline.offset(i as isize);\n                    i= i.wrapping_add(1);\n                }\n                i= bytewidth;\n                while i != length {\n                    *recon\n                        .offset(\n                            i as isize,\n                        ) = (*scanline.offset(i as isize) as libc::c_int\n                        + (*recon.offset(j_1 as isize) as libc::c_int\n                            >> 1 as libc::c_uint)) as libc::c_uchar;\n                    i= i.wrapping_add(1);\n                    j_1= j_1.wrapping_add(1);\n                }\n            }\n        }\n        4 => {\n            if !precon.is_null() {\n                let mut j_2 = 0 as libc::c_int as size_t;\n                i= 0 as libc::c_int as size_t;\n                while i != bytewidth {\n                    *recon\n                        .offset(\n                            i as isize,\n                        ) = (*scanline.offset(i as isize) as libc::c_int\n                        + *precon.offset(i as isize) as libc::c_int) as libc::c_uchar;\n                    i= i.wrapping_add(1);\n                }\n                if bytewidth >= 4 as libc::c_int as libc::c_ulong {\n                    while i.wrapping_add(3 as libc::c_int as libc::c_ulong) < length {\n                        let mut s0_2 = *scanline\n                            .offset(\n                                i.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut s1_2 = *scanline\n                            .offset(\n                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut s2_1 = *scanline\n                            .offset(\n                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut s3_0 = *scanline\n                            .offset(\n                                i.wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut r0_2 = *recon\n                            .offset(\n                                j_2.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut r1_2 = *recon\n                            .offset(\n                                j_2.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut r2_1 = *recon\n                            .offset(\n                                j_2.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut r3_0 = *recon\n                            .offset(\n                                j_2.wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut p0_2 = *precon\n                            .offset(\n                                i.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut p1_2 = *precon\n                            .offset(\n                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut p2_1 = *precon\n                            .offset(\n                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut p3_0 = *precon\n                            .offset(\n                                i.wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut q0 = *precon\n                            .offset(\n                                j_2.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut q1 = *precon\n                            .offset(\n                                j_2.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut q2 = *precon\n                            .offset(\n                                j_2.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut q3 = *precon\n                            .offset(\n                                j_2.wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        *recon\n                            .offset(\n                                i.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            ) = (s0_2 as libc::c_int\n                            + paethPredictor(\n                                r0_2 as libc::c_short,\n                                p0_2 as libc::c_short,\n                                q0 as libc::c_short,\n                            ) as libc::c_int) as libc::c_uchar;\n                        *recon\n                            .offset(\n                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            ) = (s1_2 as libc::c_int\n                            + paethPredictor(\n                                r1_2 as libc::c_short,\n                                p1_2 as libc::c_short,\n                                q1 as libc::c_short,\n                            ) as libc::c_int) as libc::c_uchar;\n                        *recon\n                            .offset(\n                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            ) = (s2_1 as libc::c_int\n                            + paethPredictor(\n                                r2_1 as libc::c_short,\n                                p2_1 as libc::c_short,\n                                q2 as libc::c_short,\n                            ) as libc::c_int) as libc::c_uchar;\n                        *recon\n                            .offset(\n                                i.wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n                            ) = (s3_0 as libc::c_int\n                            + paethPredictor(\n                                r3_0 as libc::c_short,\n                                p3_0 as libc::c_short,\n                                q3 as libc::c_short,\n                            ) as libc::c_int) as libc::c_uchar;\n                        i= (i as libc::c_ulong)\n                            .wrapping_add(4 as libc::c_int as libc::c_ulong) as size_t\n                            as size_t;\n                        j_2= (j_2 as libc::c_ulong)\n                            .wrapping_add(4 as libc::c_int as libc::c_ulong) as size_t\n                            as size_t;\n                    }\n                } else if bytewidth >= 3 as libc::c_int as libc::c_ulong {\n                    while i.wrapping_add(2 as libc::c_int as libc::c_ulong) < length {\n                        let mut s0_3 = *scanline\n                            .offset(\n                                i.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut s1_3 = *scanline\n                            .offset(\n                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut s2_2 = *scanline\n                            .offset(\n                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut r0_3 = *recon\n                            .offset(\n                                j_2.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut r1_3 = *recon\n                            .offset(\n                                j_2.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut r2_2 = *recon\n                            .offset(\n                                j_2.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut p0_3 = *precon\n                            .offset(\n                                i.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut p1_3 = *precon\n                            .offset(\n                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut p2_2 = *precon\n                            .offset(\n                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut q0_0 = *precon\n                            .offset(\n                                j_2.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut q1_0 = *precon\n                            .offset(\n                                j_2.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut q2_0 = *precon\n                            .offset(\n                                j_2.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        *recon\n                            .offset(\n                                i.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            ) = (s0_3 as libc::c_int\n                            + paethPredictor(\n                                r0_3 as libc::c_short,\n                                p0_3 as libc::c_short,\n                                q0_0 as libc::c_short,\n                            ) as libc::c_int) as libc::c_uchar;\n                        *recon\n                            .offset(\n                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            ) = (s1_3 as libc::c_int\n                            + paethPredictor(\n                                r1_3 as libc::c_short,\n                                p1_3 as libc::c_short,\n                                q1_0 as libc::c_short,\n                            ) as libc::c_int) as libc::c_uchar;\n                        *recon\n                            .offset(\n                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                            ) = (s2_2 as libc::c_int\n                            + paethPredictor(\n                                r2_2 as libc::c_short,\n                                p2_2 as libc::c_short,\n                                q2_0 as libc::c_short,\n                            ) as libc::c_int) as libc::c_uchar;\n                        i= (i as libc::c_ulong)\n                            .wrapping_add(3 as libc::c_int as libc::c_ulong) as size_t\n                            as size_t;\n                        j_2= (j_2 as libc::c_ulong)\n                            .wrapping_add(3 as libc::c_int as libc::c_ulong) as size_t\n                            as size_t;\n                    }\n                } else if bytewidth >= 2 as libc::c_int as libc::c_ulong {\n                    while i.wrapping_add(1 as libc::c_int as libc::c_ulong) < length {\n                        let mut s0_4 = *scanline\n                            .offset(\n                                i.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut s1_4 = *scanline\n                            .offset(\n                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut r0_4 = *recon\n                            .offset(\n                                j_2.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut r1_4 = *recon\n                            .offset(\n                                j_2.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut p0_4 = *precon\n                            .offset(\n                                i.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut p1_4 = *precon\n                            .offset(\n                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut q0_1 = *precon\n                            .offset(\n                                j_2.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        let mut q1_1 = *precon\n                            .offset(\n                                j_2.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            );\n                        *recon\n                            .offset(\n                                i.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n                            ) = (s0_4 as libc::c_int\n                            + paethPredictor(\n                                r0_4 as libc::c_short,\n                                p0_4 as libc::c_short,\n                                q0_1 as libc::c_short,\n                            ) as libc::c_int) as libc::c_uchar;\n                        *recon\n                            .offset(\n                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                            ) = (s1_4 as libc::c_int\n                            + paethPredictor(\n                                r1_4 as libc::c_short,\n                                p1_4 as libc::c_short,\n                                q1_1 as libc::c_short,\n                            ) as libc::c_int) as libc::c_uchar;\n                        i= (i as libc::c_ulong)\n                            .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                            as size_t;\n                        j_2= (j_2 as libc::c_ulong)\n                            .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                            as size_t;\n                    }\n                }\n                while i != length {\n                    *recon\n                        .offset(\n                            i as isize,\n                        ) = (*scanline.offset(i as isize) as libc::c_int\n                        + paethPredictor(\n                            *recon.offset(i.wrapping_sub(bytewidth) as isize)\n                                as libc::c_short,\n                            *precon.offset(i as isize) as libc::c_short,\n                            *precon.offset(j_2 as isize) as libc::c_short,\n                        ) as libc::c_int) as libc::c_uchar;\n                    i= i.wrapping_add(1);\n                    j_2= j_2.wrapping_add(1);\n                }\n            } else {();\n                let mut j_3 = 0 as libc::c_int as size_t;\n                i= 0 as libc::c_int as size_t;\n                while i != bytewidth {\n                    *recon.offset(i as isize) = *scanline.offset(i as isize);\n                    i= i.wrapping_add(1);\n                }\n                i= bytewidth;\n                while i != length {\n                    *recon\n                        .offset(\n                            i as isize,\n                        ) = (*scanline.offset(i as isize) as libc::c_int\n                        + *recon.offset(j_3 as isize) as libc::c_int) as libc::c_uchar;\n                    i= i.wrapping_add(1);\n                    j_3= j_3.wrapping_add(1);\n                }\n            }\n        }\n        _ => return 36 as libc::c_int as libc::c_uint,\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::LodePNGUnknownChunks_cleanup":"unsafe extern \"C\" fn LodePNGUnknownChunks_cleanup(mut info: *mut LodePNGInfo) {\n    let mut i: libc::c_uint = 0;\n    i= 0 as libc::c_int as libc::c_uint;\n    while i != 3 as libc::c_int as libc::c_uint {\n        lodepng_free((*info).unknown_chunks_data[i as usize] as *mut libc::c_void);\n        i= i.wrapping_add(1);\n    }\n}","src::lodepng::isRGBICCProfile":"unsafe extern \"C\" fn isRGBICCProfile(\n    mut profile: *const libc::c_uchar,\n    mut size: libc::c_uint,\n) -> libc::c_uint {\n    if size < 20 as libc::c_int as libc::c_uint {\n        return 0 as libc::c_int as libc::c_uint;\n    }\n    return (*profile.offset(16 as libc::c_int as isize) as libc::c_int == 'R' as i32\n        && *profile.offset(17 as libc::c_int as isize) as libc::c_int == 'G' as i32\n        && *profile.offset(18 as libc::c_int as isize) as libc::c_int == 'B' as i32\n        && *profile.offset(19 as libc::c_int as isize) as libc::c_int == ' ' as i32)\n        as libc::c_int as libc::c_uint;\n}","src::lodepng::addChunk_IEND":"unsafe extern \"C\" fn addChunk_IEND(mut out: Option<&mut ucvector>) -> libc::c_uint {\n    return lodepng_chunk_createv(\n        out.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()),\n        0 as libc::c_int as libc::c_uint,\n        b\"IEND\\0\" as *const u8 as *const libc::c_char,\n        0 as *const libc::c_uchar,\n    );\n}","src::lodepng::lodepng_encode_memory":"pub unsafe extern \"C\" fn lodepng_encode_memory(\n    mut out: Option<&mut *mut /* owning */ libc::c_uchar>,\n    mut outsize: Option<&mut size_t>,\n    mut image: *const libc::c_uchar,\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n    mut colortype: LodePNGColorType,\n    mut bitdepth: libc::c_uint,\n) -> libc::c_uint {\n    let mut error: libc::c_uint = 0;\n    let mut state = LodePNGState {\n        decoder: LodePNGDecoderSettings {\n            zlibsettings: LodePNGDecompressSettings {\n                ignore_adler32: 0,\n                ignore_nlen: 0,\n                max_output_size: 0,\n                custom_zlib: None,\n                custom_inflate: None,\n                custom_context: 0 as *const libc::c_void,\n            },\n            ignore_crc: 0,\n            ignore_critical: 0,\n            ignore_end: 0,\n            color_convert: 0,\n            read_text_chunks: 0,\n            remember_unknown_chunks: 0,\n            max_text_size: 0,\n            max_icc_size: 0,\n        },\n        encoder: LodePNGEncoderSettings {\n            zlibsettings: LodePNGCompressSettings {\n                btype: 0,\n                use_lz77: 0,\n                windowsize: 0,\n                minmatch: 0,\n                nicematch: 0,\n                lazymatching: 0,\n                custom_zlib: None,\n                custom_deflate: None,\n                custom_context: 0 as *const libc::c_void,\n            },\n            auto_convert: 0,\n            filter_palette_zero: 0,\n            filter_strategy: LFS_ZERO,\n            predefined_filters: 0 as *const libc::c_uchar,\n            force_palette: 0,\n            add_id: 0,\n            text_compression: 0,\n        },\n        info_raw: LodePNGColorMode {\n            colortype: LCT_GREY,\n            bitdepth: 0,\n            palette: 0 as *mut libc::c_uchar,\n            palettesize: 0,\n            key_defined: 0,\n            key_r: 0,\n            key_g: 0,\n            key_b: 0,\n        },\n        info_png: LodePNGInfo {\n            compression_method: 0,\n            filter_method: 0,\n            interlace_method: 0,\n            color: LodePNGColorMode {\n                colortype: LCT_GREY,\n                bitdepth: 0,\n                palette: 0 as *mut libc::c_uchar,\n                palettesize: 0,\n                key_defined: 0,\n                key_r: 0,\n                key_g: 0,\n                key_b: 0,\n            },\n            background_defined: 0,\n            background_r: 0,\n            background_g: 0,\n            background_b: 0,\n            text_num: 0,\n            text_keys: 0 as *mut *mut libc::c_char,\n            text_strings: 0 as *mut *mut libc::c_char,\n            itext_num: 0,\n            itext_keys: 0 as *mut *mut libc::c_char,\n            itext_langtags: 0 as *mut *mut libc::c_char,\n            itext_transkeys: 0 as *mut *mut libc::c_char,\n            itext_strings: 0 as *mut *mut libc::c_char,\n            time_defined: 0,\n            time: LodePNGTime {\n                year: 0,\n                month: 0,\n                day: 0,\n                hour: 0,\n                minute: 0,\n                second: 0,\n            },\n            phys_defined: 0,\n            phys_x: 0,\n            phys_y: 0,\n            phys_unit: 0,\n            gama_defined: 0,\n            gama_gamma: 0,\n            chrm_defined: 0,\n            chrm_white_x: 0,\n            chrm_white_y: 0,\n            chrm_red_x: 0,\n            chrm_red_y: 0,\n            chrm_green_x: 0,\n            chrm_green_y: 0,\n            chrm_blue_x: 0,\n            chrm_blue_y: 0,\n            srgb_defined: 0,\n            srgb_intent: 0,\n            iccp_defined: 0,\n            iccp_name: 0 as *mut libc::c_char,\n            iccp_profile: 0 as *mut libc::c_uchar,\n            iccp_profile_size: 0,\n            sbit_defined: 0,\n            sbit_r: 0,\n            sbit_g: 0,\n            sbit_b: 0,\n            sbit_a: 0,\n            unknown_chunks_data: [0 as *mut libc::c_uchar; 3],\n            unknown_chunks_size: [0; 3],\n        },\n        error: 0,\n    };\n    lodepng_state_init(Some(&mut state));\n    state.info_raw.colortype= colortype;\n    state.info_raw.bitdepth= bitdepth;\n    state.info_png.color.colortype= colortype;\n    state.info_png.color.bitdepth= bitdepth;\n    lodepng_encode(out.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), outsize.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()), image, w, h, core::ptr::addr_of_mut!(state));\n    error= state.error;\n    lodepng_state_cleanup(Some(&mut state));\n    return error;\n}","src::lodepng::addChunk_PLTE":"unsafe extern \"C\" fn addChunk_PLTE(\n    mut out: *mut ucvector,\n    mut info: *const LodePNGColorMode,\n) -> libc::c_uint {\n    let mut chunk = 0 as *mut libc::c_uchar;\n    let mut i: size_t = 0;\n    let mut j = 8 as libc::c_int as size_t;\n    if (*info).palettesize == 0 as libc::c_int as libc::c_ulong\n        || (*info).palettesize > 256 as libc::c_int as libc::c_ulong\n    {\n        return 68 as libc::c_int as libc::c_uint;\n    }\n    let mut error = lodepng_chunk_init(\n        core::ptr::addr_of_mut!(chunk),\n        out,\n        (*info).palettesize.wrapping_mul(3 as libc::c_int as libc::c_ulong)\n            as libc::c_uint,\n        b\"PLTE\\0\" as *const u8 as *const libc::c_char,\n    );\n    if error != 0 {\n        return error;\n    }\n    i= 0 as libc::c_int as size_t;\n    while i != (*info).palettesize {\n        let fresh182 = j;\n        j= j.wrapping_add(1);\n        *chunk\n            .offset(\n                fresh182 as isize,\n            ) = *(*info).palette\n            .offset(\n                i\n                    .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n            );\n        let fresh183 = j;\n        j= j.wrapping_add(1);\n        *chunk\n            .offset(\n                fresh183 as isize,\n            ) = *(*info).palette\n            .offset(\n                i\n                    .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n            );\n        let fresh184 = j;\n        j= j.wrapping_add(1);\n        *chunk\n            .offset(\n                fresh184 as isize,\n            ) = *(*info).palette\n            .offset(\n                i\n                    .wrapping_mul(4 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n            );\n        i= i.wrapping_add(1);\n    }\n    lodepng_chunk_generate_crc(chunk);\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::addLengthDistance":"unsafe extern \"C\" fn addLengthDistance(\n    mut values: Option<&mut uivector>,\n    mut length: size_t,\n    mut distance: size_t,\n) {\n    let mut length_code = searchCodeIndex(\n        LENGTHBASE.as_ptr(),\n        29 as libc::c_int as size_t,\n        length,\n    ) as libc::c_uint;\n    let mut extra_length = length\n        .wrapping_sub(crate::src::lodepng::LENGTHBASE[length_code as usize] as libc::c_ulong) as libc::c_uint;\n    let mut dist_code = searchCodeIndex(\n        DISTANCEBASE.as_ptr(),\n        30 as libc::c_int as size_t,\n        distance,\n    ) as libc::c_uint;\n    let mut extra_distance = distance\n        .wrapping_sub(crate::src::lodepng::DISTANCEBASE[dist_code as usize] as libc::c_ulong) as libc::c_uint;\n    let mut pos = (*values.as_deref().unwrap()).size;\n    let mut ok = {let crown_promoted_local_0 = (*values.as_deref().unwrap()).size.wrapping_add(4 as libc::c_int as libc::c_ulong);uivector_resize(\n        values.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()),\n        crown_promoted_local_0,\n    )};\n    if ok != 0 {\n        *(*values.as_deref().unwrap()).data\n            .offset(\n                pos.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,\n            ) = length_code.wrapping_add(257 as libc::c_int as libc::c_uint);\n        *(*values.as_deref().unwrap()).data\n            .offset(\n                pos.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n            ) = extra_length;\n        *(*values.as_deref().unwrap()).data\n            .offset(\n                pos.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n            ) = dist_code;\n        *(*values.as_deref().unwrap()).data\n            .offset(\n                pos.wrapping_add(3 as libc::c_int as libc::c_ulong) as isize,\n            ) = extra_distance;\n    }\n}","src::lodepng::addChunk_cHRM":"unsafe extern \"C\" fn addChunk_cHRM(\n    mut out: *mut ucvector,\n    mut info: *const LodePNGInfo,\n) -> libc::c_uint {\n    let mut chunk = 0 as *mut libc::c_uchar;\n    let mut error = lodepng_chunk_init(\n        core::ptr::addr_of_mut!(chunk),\n        out,\n        32 as libc::c_int as libc::c_uint,\n        b\"cHRM\\0\" as *const u8 as *const libc::c_char,\n    );\n    if error != 0 {\n        return error;\n    }\n    lodepng_set32bitInt(chunk.offset(8 as libc::c_int as isize), (*info).chrm_white_x);\n    lodepng_set32bitInt(chunk.offset(12 as libc::c_int as isize), (*info).chrm_white_y);\n    lodepng_set32bitInt(chunk.offset(16 as libc::c_int as isize), (*info).chrm_red_x);\n    lodepng_set32bitInt(chunk.offset(20 as libc::c_int as isize), (*info).chrm_red_y);\n    lodepng_set32bitInt(chunk.offset(24 as libc::c_int as isize), (*info).chrm_green_x);\n    lodepng_set32bitInt(chunk.offset(28 as libc::c_int as isize), (*info).chrm_green_y);\n    lodepng_set32bitInt(chunk.offset(32 as libc::c_int as isize), (*info).chrm_blue_x);\n    lodepng_set32bitInt(chunk.offset(36 as libc::c_int as isize), (*info).chrm_blue_y);\n    lodepng_chunk_generate_crc(chunk);\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::LodePNGIText_copy":"unsafe extern \"C\" fn LodePNGIText_copy(\n    mut dest: *mut LodePNGInfo,\n    mut source: *const LodePNGInfo,\n) -> libc::c_uint {\n    let mut i = 0 as libc::c_int as size_t;\n    (*dest).itext_keys= 0 as *mut *mut libc::c_char;\n    (*dest).itext_langtags= 0 as *mut *mut libc::c_char;\n    (*dest).itext_transkeys= 0 as *mut *mut libc::c_char;\n    (*dest).itext_strings= 0 as *mut *mut libc::c_char;\n    (*dest).itext_num= 0 as libc::c_int as size_t;\n    i= 0 as libc::c_int as size_t;\n    while i != (*source).itext_num {\n        let mut error = lodepng_add_itext(\n            dest,\n            *(*source).itext_keys.offset(i as isize),\n            *(*source).itext_langtags.offset(i as isize),\n            *(*source).itext_transkeys.offset(i as isize),\n            *(*source).itext_strings.offset(i as isize),\n        );\n        if error != 0 {\n            return error;\n        }\n        i= i.wrapping_add(1);\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_inflatev":"unsafe extern \"C\" fn lodepng_inflatev(\n    mut out: *mut ucvector,\n    mut in_0: *const libc::c_uchar,\n    mut insize: size_t,\n    mut settings: *const LodePNGDecompressSettings,\n) -> libc::c_uint {\n    let mut BFINAL = 0 as libc::c_int as libc::c_uint;\n    let mut reader = LodePNGBitReader {\n        data: 0 as *const libc::c_uchar,\n        size: 0,\n        bitsize: 0,\n        bp: 0,\n        buffer: 0,\n    };\n    let mut error = LodePNGBitReader_init(Some(&mut reader), in_0, insize);\n    if error != 0 {\n        return error;\n    }\n    while BFINAL == 0 {\n        let mut BTYPE: libc::c_uint = 0;\n        if reader.bitsize.wrapping_sub(reader.bp) < 3 as libc::c_int as libc::c_ulong {\n            return 52 as libc::c_int as libc::c_uint;\n        }\n        ensureBits9(Some(&mut reader), 3 as libc::c_int as size_t);\n        BFINAL= readBits(Some(&mut reader), 1 as libc::c_int as size_t);\n        BTYPE= readBits(Some(&mut reader), 2 as libc::c_int as size_t);\n        if BTYPE == 3 as libc::c_int as libc::c_uint {\n            return 20 as libc::c_int as libc::c_uint\n        } else {\n            if BTYPE == 0 as libc::c_int as libc::c_uint {\n                error= inflateNoCompression(out, core::ptr::addr_of_mut!(reader), settings);\n            } else {\n                error= inflateHuffmanBlock(\n                    out,\n                    Some(&mut reader),\n                    BTYPE,\n                    (*settings).max_output_size,\n                );\n            }\n        }\n        if error == 0 && (*settings).max_output_size != 0\n            && (*out).size > (*settings).max_output_size\n        {\n            error= 109 as libc::c_int as libc::c_uint;\n        }\n        if error != 0 {\n            break;\n        }\n    }\n    return error;\n}","src::lodepng::lodepng_chunk_length":"pub unsafe extern \"C\" fn lodepng_chunk_length(\n    mut chunk: *const libc::c_uchar,\n) -> libc::c_uint {\n    return lodepng_read32bitInt(chunk);\n}","src::lodepng::lodepng_inspect_chunk":"pub unsafe extern \"C\" fn lodepng_inspect_chunk(\n    mut state: *mut LodePNGState,\n    mut pos: size_t,\n    mut in_0: *const libc::c_uchar,\n    mut insize: size_t,\n) -> libc::c_uint {\n    let mut chunk = in_0.offset(pos as isize);\n    let mut chunkLength: libc::c_uint = 0;\n    let mut data = 0 as *const libc::c_uchar;\n    let mut unhandled = 0 as libc::c_int as libc::c_uint;\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    if pos.wrapping_add(4 as libc::c_int as libc::c_ulong) > insize {\n        return 30 as libc::c_int as libc::c_uint;\n    }\n    chunkLength= lodepng_chunk_length(chunk);\n    if chunkLength > 2147483647 as libc::c_int as libc::c_uint {\n        return 63 as libc::c_int as libc::c_uint;\n    }\n    data= lodepng_chunk_data_const(chunk);\n    if chunkLength.wrapping_add(12 as libc::c_int as libc::c_uint) as libc::c_ulong\n        > insize.wrapping_sub(pos)\n    {\n        return 30 as libc::c_int as libc::c_uint;\n    }\n    if lodepng_chunk_type_equals(chunk, b\"PLTE\\0\" as *const u8 as *const libc::c_char)\n        != 0\n    {\n        error= readChunk_PLTE(\n            core::ptr::addr_of_mut!((*state).info_png.color),\n            data,\n            chunkLength as size_t,\n        );\n    } else if lodepng_chunk_type_equals(\n        chunk,\n        b\"tRNS\\0\" as *const u8 as *const libc::c_char,\n    ) != 0\n    {\n        error= readChunk_tRNS(\n            core::ptr::addr_of_mut!((*state).info_png.color),\n            data,\n            chunkLength as size_t,\n        );\n    } else if lodepng_chunk_type_equals(\n        chunk,\n        b\"bKGD\\0\" as *const u8 as *const libc::c_char,\n    ) != 0\n    {\n        error= readChunk_bKGD(core::ptr::addr_of_mut!((*state).info_png), data, chunkLength as size_t);\n    } else if lodepng_chunk_type_equals(\n        chunk,\n        b\"tEXt\\0\" as *const u8 as *const libc::c_char,\n    ) != 0\n    {\n        error= readChunk_tEXt(core::ptr::addr_of_mut!((*state).info_png), data, chunkLength as size_t);\n    } else if lodepng_chunk_type_equals(\n        chunk,\n        b\"zTXt\\0\" as *const u8 as *const libc::c_char,\n    ) != 0\n    {\n        error= readChunk_zTXt(\n            core::ptr::addr_of_mut!((*state).info_png),\n            core::ptr::addr_of!((*state).decoder),\n            data,\n            chunkLength as size_t,\n        );\n    } else if lodepng_chunk_type_equals(\n        chunk,\n        b\"iTXt\\0\" as *const u8 as *const libc::c_char,\n    ) != 0\n    {\n        error= readChunk_iTXt(\n            core::ptr::addr_of_mut!((*state).info_png),\n            core::ptr::addr_of!((*state).decoder),\n            data,\n            chunkLength as size_t,\n        );\n    } else if lodepng_chunk_type_equals(\n        chunk,\n        b\"tIME\\0\" as *const u8 as *const libc::c_char,\n    ) != 0\n    {\n        error= readChunk_tIME(core::ptr::addr_of_mut!((*state).info_png), data, chunkLength as size_t);\n    } else if lodepng_chunk_type_equals(\n        chunk,\n        b\"pHYs\\0\" as *const u8 as *const libc::c_char,\n    ) != 0\n    {\n        error= readChunk_pHYs(core::ptr::addr_of_mut!((*state).info_png), data, chunkLength as size_t);\n    } else if lodepng_chunk_type_equals(\n        chunk,\n        b\"gAMA\\0\" as *const u8 as *const libc::c_char,\n    ) != 0\n    {\n        error= readChunk_gAMA(core::ptr::addr_of_mut!((*state).info_png), data, chunkLength as size_t);\n    } else if lodepng_chunk_type_equals(\n        chunk,\n        b\"cHRM\\0\" as *const u8 as *const libc::c_char,\n    ) != 0\n    {\n        error= readChunk_cHRM(core::ptr::addr_of_mut!((*state).info_png), data, chunkLength as size_t);\n    } else if lodepng_chunk_type_equals(\n        chunk,\n        b\"sRGB\\0\" as *const u8 as *const libc::c_char,\n    ) != 0\n    {\n        error= readChunk_sRGB(core::ptr::addr_of_mut!((*state).info_png), data, chunkLength as size_t);\n    } else if lodepng_chunk_type_equals(\n        chunk,\n        b\"iCCP\\0\" as *const u8 as *const libc::c_char,\n    ) != 0\n    {\n        error= readChunk_iCCP(\n            core::ptr::addr_of_mut!((*state).info_png),\n            core::ptr::addr_of!((*state).decoder),\n            data,\n            chunkLength as size_t,\n        );\n    } else if lodepng_chunk_type_equals(\n        chunk,\n        b\"sBIT\\0\" as *const u8 as *const libc::c_char,\n    ) != 0\n    {\n        error= readChunk_sBIT(core::ptr::addr_of_mut!((*state).info_png), data, chunkLength as size_t);\n    } else {\n        unhandled= 1 as libc::c_int as libc::c_uint;\n    }\n    if error == 0 && unhandled == 0 && (*state).decoder.ignore_crc == 0 {\n        if lodepng_chunk_check_crc(chunk) != 0 {\n            return 57 as libc::c_int as libc::c_uint;\n        }\n    }\n    return error;\n}","src::lodepng::lodepng_chunk_data_const":"pub unsafe extern \"C\" fn lodepng_chunk_data_const(\n    mut chunk: *const libc::c_uchar,\n) -> *const libc::c_uchar {\n    return &*chunk.offset(8 as libc::c_int as isize) as *const libc::c_uchar;\n}","src::lodepng::lodepng_pixel_overflow":"unsafe extern \"C\" fn lodepng_pixel_overflow(\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n    mut pngcolor: *const LodePNGColorMode,\n    mut rawcolor: *const LodePNGColorMode,\n) -> libc::c_int {\n    let mut bpp = (if lodepng_get_bpp(pngcolor) > lodepng_get_bpp(rawcolor) {\n        lodepng_get_bpp(pngcolor)\n    } else {\n        lodepng_get_bpp(rawcolor)\n    }) as size_t;\n    let mut numpixels: size_t = 0;\n    let mut total: size_t = 0;\n    let mut line: size_t = 0;\n    if lodepng_mulofl(w as size_t, h as size_t, Some(&mut numpixels)) != 0 {\n        return 1 as libc::c_int;\n    }\n    if lodepng_mulofl(numpixels, 8 as libc::c_int as size_t, Some(&mut total)) != 0 {\n        return 1 as libc::c_int;\n    }\n    if lodepng_mulofl(w.wrapping_div(8 as libc::c_uint) as size_t, bpp, Some(&mut line)) != 0 {\n        return 1 as libc::c_int;\n    }\n    if lodepng_addofl(\n        line,\n        ((w & 7 as libc::c_uint) as libc::c_ulong)\n            .wrapping_mul(bpp)\n            .wrapping_add(7 as libc::c_uint as libc::c_ulong)\n            .wrapping_div(8 as libc::c_uint as libc::c_ulong),\n        Some(&mut line),\n    ) != 0\n    {\n        return 1 as libc::c_int;\n    }\n    if lodepng_addofl(line, 5 as libc::c_int as size_t, Some(&mut line)) != 0 {\n        return 1 as libc::c_int;\n    }\n    if lodepng_mulofl(line, h as size_t, Some(&mut total)) != 0 {\n        return 1 as libc::c_int;\n    }\n    return 0 as libc::c_int;\n}","src::lodepng::lodepng_get_raw_size":"pub unsafe extern \"C\" fn lodepng_get_raw_size(\n    mut w: libc::c_uint,\n    mut h: libc::c_uint,\n    mut color: *const LodePNGColorMode,\n) -> size_t {\n    return lodepng_get_raw_size_lct(w, h, (*color).colortype, (*color).bitdepth);\n}","src::lodepng::LodePNGText_copy":"unsafe extern \"C\" fn LodePNGText_copy(\n    mut dest: *mut LodePNGInfo,\n    mut source: *const LodePNGInfo,\n) -> libc::c_uint {\n    let mut i = 0 as libc::c_int as size_t;\n    (*dest).text_keys= 0 as *mut *mut libc::c_char;\n    (*dest).text_strings= 0 as *mut *mut libc::c_char;\n    (*dest).text_num= 0 as libc::c_int as size_t;\n    i= 0 as libc::c_int as size_t;\n    while i != (*source).text_num {\n        let mut error = lodepng_add_text(\n            dest,\n            *(*source).text_keys.offset(i as isize),\n            *(*source).text_strings.offset(i as isize),\n        );\n        if error != 0 {\n            return error;\n        }\n        i= i.wrapping_add(1);\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_add_text_sized":"unsafe extern \"C\" fn lodepng_add_text_sized(\n    mut info: *mut LodePNGInfo,\n    mut key: *const libc::c_char,\n    mut str: *const libc::c_char,\n    mut size: size_t,\n) -> libc::c_uint {\n    let mut new_keys = lodepng_realloc(\n        (*info).text_keys as *mut libc::c_void,\n        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)\n            .wrapping_mul(\n                (*info).text_num.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            ),\n    ) as *mut *mut libc::c_char;\n    let mut new_strings = lodepng_realloc(\n        (*info).text_strings as *mut libc::c_void,\n        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)\n            .wrapping_mul(\n                (*info).text_num.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            ),\n    ) as *mut *mut libc::c_char;\n    if !new_keys.is_null() {\n        (*info).text_keys= new_keys;\n    }else { (); }\n    if !new_strings.is_null() {\n        (*info).text_strings= new_strings;\n    }else { (); }\n    if new_keys.is_null() || new_strings.is_null() {\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    (*info).text_num= (*info).text_num.wrapping_add(1);\n    *(*info).text_keys\n        .offset(\n            (*info).text_num.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n        ) = alloc_string(key);\n    *(*info).text_strings\n        .offset(\n            (*info).text_num.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n        ) = alloc_string_sized(str, size);\n    if (*(*info).text_keys\n        .offset(\n            (*info).text_num.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n        ))\n        .is_null()\n        || (*(*info).text_strings\n            .offset(\n                (*info).text_num.wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    as isize,\n            ))\n            .is_null()\n    {\n        return 83 as libc::c_int as libc::c_uint;\n    }\n    return 0 as libc::c_int as libc::c_uint;\n}","src::lodepng::lodepng_color_stats_add":"unsafe extern \"C\" fn lodepng_color_stats_add(\n    mut stats: Option<&mut LodePNGColorStats>,\n    mut r: libc::c_uint,\n    mut g: libc::c_uint,\n    mut b: libc::c_uint,\n    mut a: libc::c_uint,\n) -> libc::c_uint {\n    let mut error = 0 as libc::c_int as libc::c_uint;\n    let mut image: [libc::c_uchar; 8] = [0; 8];\n    let mut mode = LodePNGColorMode {\n        colortype: LCT_GREY,\n        bitdepth: 0,\n        palette: 0 as *mut libc::c_uchar,\n        palettesize: 0,\n        key_defined: 0,\n        key_r: 0,\n        key_g: 0,\n        key_b: 0,\n    };\n    lodepng_color_mode_init(Some(&mut mode));\n    image[0 as libc::c_int as usize]= (r >> 8 as libc::c_int) as libc::c_uchar;\n    image[1 as libc::c_int as usize]= r as libc::c_uchar;\n    image[2 as libc::c_int as usize]= (g >> 8 as libc::c_int) as libc::c_uchar;\n    image[3 as libc::c_int as usize]= g as libc::c_uchar;\n    image[4 as libc::c_int as usize]= (b >> 8 as libc::c_int) as libc::c_uchar;\n    image[5 as libc::c_int as usize]= b as libc::c_uchar;\n    image[6 as libc::c_int as usize]= (a >> 8 as libc::c_int) as libc::c_uchar;\n    image[7 as libc::c_int as usize]= a as libc::c_uchar;\n    mode.bitdepth= 16 as libc::c_int as libc::c_uint;\n    mode.colortype= LCT_RGBA;\n    error= lodepng_compute_color_stats(\n        stats.as_deref_mut().map(|r| r as *mut _).unwrap_or(std::ptr::null_mut()),\n        image.as_mut_ptr(),\n        1 as libc::c_int as libc::c_uint,\n        1 as libc::c_int as libc::c_uint,\n        core::ptr::addr_of!(mode),\n    );\n    lodepng_color_mode_cleanup(Some(&mut mode));\n    return error;\n}","src::lodepng::lodepng_inspect":"pub unsafe extern \"C\" fn lodepng_inspect(\n    mut w: *mut libc::c_uint,\n    mut h: *mut libc::c_uint,\n    mut state: *mut LodePNGState,\n    mut in_0: *const libc::c_uchar,\n    mut insize: size_t,\n) -> libc::c_uint {\n    let mut width: libc::c_uint = 0;\n    let mut height: libc::c_uint = 0;\n    let mut info: *mut LodePNGInfo = core::ptr::addr_of_mut!((*state).info_png);\n    if insize == 0 as libc::c_int as libc::c_ulong || in_0.is_null() {\n        (*state).error= 48 as libc::c_int as libc::c_uint;\n        return 48 as libc::c_int as libc::c_uint;\n    }\n    if insize < 33 as libc::c_int as libc::c_ulong {\n        (*state).error= 27 as libc::c_int as libc::c_uint;\n        return 27 as libc::c_int as libc::c_uint;\n    }\n    lodepng_info_cleanup(info.as_mut());\n    lodepng_info_init(info.as_mut());\n    if *in_0.offset(0 as libc::c_int as isize) as libc::c_int != 137 as libc::c_int\n        || *in_0.offset(1 as libc::c_int as isize) as libc::c_int != 80 as libc::c_int\n        || *in_0.offset(2 as libc::c_int as isize) as libc::c_int != 78 as libc::c_int\n        || *in_0.offset(3 as libc::c_int as isize) as libc::c_int != 71 as libc::c_int\n        || *in_0.offset(4 as libc::c_int as isize) as libc::c_int != 13 as libc::c_int\n        || *in_0.offset(5 as libc::c_int as isize) as libc::c_int != 10 as libc::c_int\n        || *in_0.offset(6 as libc::c_int as isize) as libc::c_int != 26 as libc::c_int\n        || *in_0.offset(7 as libc::c_int as isize) as libc::c_int != 10 as libc::c_int\n    {\n        (*state).error= 28 as libc::c_int as libc::c_uint;\n        return 28 as libc::c_int as libc::c_uint;\n    }\n    if lodepng_chunk_length(in_0.offset(8 as libc::c_int as isize))\n        != 13 as libc::c_int as libc::c_uint\n    {\n        (*state).error= 94 as libc::c_int as libc::c_uint;\n        return 94 as libc::c_int as libc::c_uint;\n    }\n    if lodepng_chunk_type_equals(\n        in_0.offset(8 as libc::c_int as isize),\n        b\"IHDR\\0\" as *const u8 as *const libc::c_char,\n    ) == 0\n    {\n        (*state).error= 29 as libc::c_int as libc::c_uint;\n        return 29 as libc::c_int as libc::c_uint;\n    }\n    width= lodepng_read32bitInt(&*in_0.offset(16 as libc::c_int as isize));\n    height= lodepng_read32bitInt(&*in_0.offset(20 as libc::c_int as isize));\n    if !w.is_null() {\n        *w= width;\n    }else { (); }\n    if !h.is_null() {\n        *h= height;\n    }else { (); }\n    (*info).color.bitdepth= *in_0.offset(24 as libc::c_int as isize) as libc::c_uint;\n    (*info).color.colortype= *in_0.offset(25 as libc::c_int as isize) as LodePNGColorType;\n    (*info).compression_method= *in_0.offset(26 as libc::c_int as isize) as libc::c_uint;\n    (*info).filter_method= *in_0.offset(27 as libc::c_int as isize) as libc::c_uint;\n    (*info).interlace_method= *in_0.offset(28 as libc::c_int as isize) as libc::c_uint;\n    if width == 0 as libc::c_int as libc::c_uint\n        || height == 0 as libc::c_int as libc::c_uint\n    {\n        (*state).error= 93 as libc::c_int as libc::c_uint;\n        return 93 as libc::c_int as libc::c_uint;\n    }\n    (*state).error= checkColorValidity((*info).color.colortype, (*info).color.bitdepth);\n    if (*state).error != 0 {\n        return (*state).error;\n    }\n    if (*info).compression_method != 0 as libc::c_int as libc::c_uint {\n        (*state).error= 32 as libc::c_int as libc::c_uint;\n        return 32 as libc::c_int as libc::c_uint;\n    }\n    if (*info).filter_method != 0 as libc::c_int as libc::c_uint {\n        (*state).error= 33 as libc::c_int as libc::c_uint;\n        return 33 as libc::c_int as libc::c_uint;\n    }\n    if (*info).interlace_method > 1 as libc::c_int as libc::c_uint {\n        (*state).error= 34 as libc::c_int as libc::c_uint;\n        return 34 as libc::c_int as libc::c_uint;\n    }\n    if (*state).decoder.ignore_crc == 0 {\n        let mut CRC = lodepng_read32bitInt(&*in_0.offset(29 as libc::c_int as isize));\n        let mut checksum = lodepng_crc32(\n            &*in_0.offset(12 as libc::c_int as isize),\n            17 as libc::c_int as size_t,\n        );\n        if CRC != checksum {\n            (*state).error= 57 as libc::c_int as libc::c_uint;\n            return 57 as libc::c_int as libc::c_uint;\n        }\n    }\n    return (*state).error;\n}"},"struct_data":{"src::lodepng::LodePNGDecoderSettings":"pub struct LodePNGDecoderSettings {\n    pub zlibsettings: LodePNGDecompressSettings,\n    pub ignore_crc: libc::c_uint,\n    pub ignore_critical: libc::c_uint,\n    pub ignore_end: libc::c_uint,\n    pub color_convert: libc::c_uint,\n    pub read_text_chunks: libc::c_uint,\n    pub remember_unknown_chunks: libc::c_uint,\n    pub max_text_size: size_t,\n    pub max_icc_size: size_t,\n}","src::lodepng::BPMNode":"pub struct BPMNode {\n    pub weight: libc::c_int,\n    pub index: libc::c_uint,\n    pub tail: *mut BPMNode,\n    pub in_use: libc::c_int,\n}","src::lodepng::LodePNGBitReader":"pub struct LodePNGBitReader {\n    pub data: *const libc::c_uchar,\n    pub size: size_t,\n    pub bitsize: size_t,\n    pub bp: size_t,\n    pub buffer: libc::c_uint,\n}","src::lodepng::ErasedByRefactorer0":"struct ErasedByRefactorer0;","src::lodepng::LodePNGInfo":"pub struct LodePNGInfo {\n    pub compression_method: libc::c_uint,\n    pub filter_method: libc::c_uint,\n    pub interlace_method: libc::c_uint,\n    pub color: LodePNGColorMode,\n    pub background_defined: libc::c_uint,\n    pub background_r: libc::c_uint,\n    pub background_g: libc::c_uint,\n    pub background_b: libc::c_uint,\n    pub text_num: size_t,\n    pub text_keys: *mut *mut libc::c_char,\n    pub text_strings: *mut *mut libc::c_char,\n    pub itext_num: size_t,\n    pub itext_keys: *mut *mut libc::c_char,\n    pub itext_langtags: *mut *mut libc::c_char,\n    pub itext_transkeys: *mut *mut libc::c_char,\n    pub itext_strings: *mut *mut libc::c_char,\n    pub time_defined: libc::c_uint,\n    pub time: LodePNGTime,\n    pub phys_defined: libc::c_uint,\n    pub phys_x: libc::c_uint,\n    pub phys_y: libc::c_uint,\n    pub phys_unit: libc::c_uint,\n    pub gama_defined: libc::c_uint,\n    pub gama_gamma: libc::c_uint,\n    pub chrm_defined: libc::c_uint,\n    pub chrm_white_x: libc::c_uint,\n    pub chrm_white_y: libc::c_uint,\n    pub chrm_red_x: libc::c_uint,\n    pub chrm_red_y: libc::c_uint,\n    pub chrm_green_x: libc::c_uint,\n    pub chrm_green_y: libc::c_uint,\n    pub chrm_blue_x: libc::c_uint,\n    pub chrm_blue_y: libc::c_uint,\n    pub srgb_defined: libc::c_uint,\n    pub srgb_intent: libc::c_uint,\n    pub iccp_defined: libc::c_uint,\n    pub iccp_name: *mut libc::c_char,\n    pub iccp_profile: *mut libc::c_uchar,\n    pub iccp_profile_size: libc::c_uint,\n    pub sbit_defined: libc::c_uint,\n    pub sbit_r: libc::c_uint,\n    pub sbit_g: libc::c_uint,\n    pub sbit_b: libc::c_uint,\n    pub sbit_a: libc::c_uint,\n    pub unknown_chunks_data: [*mut libc::c_uchar; 3],\n    pub unknown_chunks_size: [size_t; 3],\n}","src::lodepng::BPMLists":"pub struct BPMLists {\n    pub memsize: libc::c_uint,\n    pub memory: *mut /* owning */ BPMNode,\n    pub numfree: libc::c_uint,\n    pub nextfree: libc::c_uint,\n    pub freelist: *mut /* owning */ *mut BPMNode,\n    pub listsize: libc::c_uint,\n    pub chains0: *mut /* owning */ *mut BPMNode,\n    pub chains1: *mut /* owning */ *mut BPMNode,\n}","src::lodepng::uivector":"pub struct uivector {\n    pub data: *mut libc::c_uint,\n    pub size: size_t,\n    pub allocsize: size_t,\n}","src::lodepng::LodePNGState":"pub struct LodePNGState {\n    pub decoder: LodePNGDecoderSettings,\n    pub encoder: LodePNGEncoderSettings,\n    pub info_raw: LodePNGColorMode,\n    pub info_png: LodePNGInfo,\n    pub error: libc::c_uint,\n}","src::lodepng::LodePNGTime":"pub struct LodePNGTime {\n    pub year: libc::c_uint,\n    pub month: libc::c_uint,\n    pub day: libc::c_uint,\n    pub hour: libc::c_uint,\n    pub minute: libc::c_uint,\n    pub second: libc::c_uint,\n}","src::lodepng::LodePNGCompressSettings":"pub struct LodePNGCompressSettings {\n    pub btype: libc::c_uint,\n    pub use_lz77: libc::c_uint,\n    pub windowsize: libc::c_uint,\n    pub minmatch: libc::c_uint,\n    pub nicematch: libc::c_uint,\n    pub lazymatching: libc::c_uint,\n    pub custom_zlib: Option::<\n        unsafe extern \"C\" fn(\n            *mut *mut libc::c_uchar,\n            *mut size_t,\n            *const libc::c_uchar,\n            size_t,\n            *const LodePNGCompressSettings,\n        ) -> libc::c_uint,\n    >,\n    pub custom_deflate: Option::<\n        unsafe extern \"C\" fn(\n            *mut *mut libc::c_uchar,\n            *mut size_t,\n            *const libc::c_uchar,\n            size_t,\n            *const LodePNGCompressSettings,\n        ) -> libc::c_uint,\n    >,\n    pub custom_context: *const libc::c_void,\n}","src::lodepng::LodePNGDecompressSettings":"pub struct LodePNGDecompressSettings {\n    pub ignore_adler32: libc::c_uint,\n    pub ignore_nlen: libc::c_uint,\n    pub max_output_size: size_t,\n    pub custom_zlib: Option::<\n        unsafe extern \"C\" fn(\n            *mut *mut libc::c_uchar,\n            *mut size_t,\n            *const libc::c_uchar,\n            size_t,\n            *const LodePNGDecompressSettings,\n        ) -> libc::c_uint,\n    >,\n    pub custom_inflate: Option::<\n        unsafe extern \"C\" fn(\n            *mut *mut libc::c_uchar,\n            *mut size_t,\n            *const libc::c_uchar,\n            size_t,\n            *const LodePNGDecompressSettings,\n        ) -> libc::c_uint,\n    >,\n    pub custom_context: *const libc::c_void,\n}","src::lodepng::Hash":"pub struct Hash {\n    pub head: *mut /* owning */ libc::c_int,\n    pub chain: *mut /* owning */ libc::c_ushort,\n    pub val: *mut /* owning */ libc::c_int,\n    pub headz: *mut /* owning */ libc::c_int,\n    pub chainz: *mut /* owning */ libc::c_ushort,\n    pub zeros: *mut /* owning */ libc::c_ushort,\n}","src::lodepng::ErasedByRefactorer1":"struct ErasedByRefactorer1;","src::lodepng::LodePNGColorStats":"pub struct LodePNGColorStats {\n    pub colored: libc::c_uint,\n    pub key: libc::c_uint,\n    pub key_r: libc::c_ushort,\n    pub key_g: libc::c_ushort,\n    pub key_b: libc::c_ushort,\n    pub alpha: libc::c_uint,\n    pub numcolors: libc::c_uint,\n    pub palette: [libc::c_uchar; 1024],\n    pub bits: libc::c_uint,\n    pub numpixels: size_t,\n    pub allow_palette: libc::c_uint,\n    pub allow_greyscale: libc::c_uint,\n}","src::lodepng::_IO_FILE":"pub struct _IO_FILE {\n    pub _flags: libc::c_int,\n    pub _IO_read_ptr: *mut libc::c_char,\n    pub _IO_read_end: *mut libc::c_char,\n    pub _IO_read_base: *mut libc::c_char,\n    pub _IO_write_base: *mut libc::c_char,\n    pub _IO_write_ptr: *mut libc::c_char,\n    pub _IO_write_end: *mut libc::c_char,\n    pub _IO_buf_base: *mut libc::c_char,\n    pub _IO_buf_end: *mut libc::c_char,\n    pub _IO_save_base: *mut libc::c_char,\n    pub _IO_backup_base: *mut libc::c_char,\n    pub _IO_save_end: *mut libc::c_char,\n    pub _markers: *mut _IO_marker,\n    pub _chain: *mut _IO_FILE,\n    pub _fileno: libc::c_int,\n    pub _flags2: libc::c_int,\n    pub _old_offset: __off_t,\n    pub _cur_column: libc::c_ushort,\n    pub _vtable_offset: libc::c_schar,\n    pub _shortbuf: [libc::c_char; 1],\n    pub _lock: *mut libc::c_void,\n    pub _offset: __off64_t,\n    pub _codecvt: *mut _IO_codecvt,\n    pub _wide_data: *mut _IO_wide_data,\n    pub _freeres_list: *mut _IO_FILE,\n    pub _freeres_buf: *mut libc::c_void,\n    pub __pad5: size_t,\n    pub _mode: libc::c_int,\n    pub _unused2: [libc::c_char; 20],\n}","src::lodepng::LodePNGBitWriter":"pub struct LodePNGBitWriter {\n    pub data: *mut ucvector,\n    pub bp: libc::c_uchar,\n}","src::lodepng::ucvector":"pub struct ucvector {\n    pub data: *mut libc::c_uchar,\n    pub size: size_t,\n    pub allocsize: size_t,\n}","src::lodepng::HuffmanTree":"pub struct HuffmanTree {\n    pub codes: *mut libc::c_uint,\n    pub lengths: *mut libc::c_uint,\n    pub maxbitlen: libc::c_uint,\n    pub numcodes: libc::c_uint,\n    pub table_len: *mut libc::c_uchar,\n    pub table_value: *mut libc::c_ushort,\n}","src::lodepng::LodePNGColorMode":"pub struct LodePNGColorMode {\n    pub colortype: LodePNGColorType,\n    pub bitdepth: libc::c_uint,\n    pub palette: *mut libc::c_uchar,\n    pub palettesize: size_t,\n    pub key_defined: libc::c_uint,\n    pub key_r: libc::c_uint,\n    pub key_g: libc::c_uint,\n    pub key_b: libc::c_uint,\n}","src::lodepng::LodePNGEncoderSettings":"pub struct LodePNGEncoderSettings {\n    pub zlibsettings: LodePNGCompressSettings,\n    pub auto_convert: libc::c_uint,\n    pub filter_palette_zero: libc::c_uint,\n    pub filter_strategy: LodePNGFilterStrategy,\n    pub predefined_filters: *const libc::c_uchar,\n    pub force_palette: libc::c_uint,\n    pub add_id: libc::c_uint,\n    pub text_compression: libc::c_uint,\n}","src::lodepng::ColorTree":"pub struct ColorTree {\n    pub children: [*mut ColorTree; 16],\n    pub index: libc::c_int,\n}"}}