# 0 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c"





# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 1
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 2
# 7 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/string.h" 1
# 8 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 9 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/time.h" 1
# 10 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/limits.h" 1
# 11 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_bf.h" 1
# 18 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_bf.h"
enum avlbf {
 LEFTHEAVY = -1,
 BALANCED = 0,
 RIGHTHEAVY = 1
};

enum avltraversal {
 PREORDER,
 INORDER,
 POSTORDER
};

typedef struct avlnode {
 struct avlnode *left;
 struct avlnode *right;
 struct avlnode *parent;
 char bf;
 void *data;
} avlnode;

typedef struct {
 int (*compare)(const void *, const void *);
 void (*print)(void *);
 void (*destroy)(void *);

 avlnode root;
 avlnode nil;


 avlnode *min;

} avltree;
# 59 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_bf.h"
avltree *avl_create(int (*compare_func)(const void *, const void *), void (*destroy_func)(void *));
void avl_destroy(avltree *avlt);

avlnode *avl_find(avltree *avlt, void *data);
avlnode *avl_successor(avltree *avlt, avlnode *node);

int avl_apply(avltree *avlt, avlnode *node, int (*func)(void *, void *), void *cookie, enum avltraversal order);
void avl_print(avltree *avlt, void (*print_func)(void *));

avlnode *avl_insert(avltree *avlt, void *data);
void *avl_delete(avltree *avlt, avlnode *node, int keep);

int avl_check_order(avltree *avlt, void *min, void *max);
int avl_check_height(avltree *avlt);
# 12 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_data.h" 1
# 9 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_data.h"
typedef struct {
 int key;
} mydata;

mydata *makedata(int key);
int compare_func(const void *d1, const void *d2);
void destroy_func(void *d);
void print_func(void *d);
void print_char_func(void *d);
# 13 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/minunit.h" 1
# 20 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/minunit.h"
extern int mu_tests, mu_fails;
# 14 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c" 2





int mu_tests= 0, mu_fails = 0;

int permutation_error = 0;

static avltree *tree_create();
static avlnode *tree_find(avltree *avlt, int key);
static void tree_print(avltree *avlt);
static int tree_check(avltree *avlt);
static avlnode *tree_insert(avltree *avlt, int key);
static int tree_delete(avltree *avlt, int key);

static void swap(char *x, char *y);
static void permute(char *a, int start, int end, void func(char *));
static void permutation_insert(char *a);
static void permutation_delete(char *a);

static int unit_test_create();
static int unit_test_find();
static int unit_test_successor();
static int unit_test_atomic_insertion();
static int unit_test_atomic_deletion();
static int unit_test_chain_insertion();
static int unit_test_chain_deletion();
static int unit_test_permutation_insertion();
static int unit_test_permutation_deletion();
static int unit_test_random_insertion_deletion();

static int unit_test_dup();

static int unit_test_min();


void all_tests()
{
 do { printf("#%03d %s \n", ++mu_tests, "unit_test_create"); if (unit_test_create()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);

 do { printf("#%03d %s \n", ++mu_tests, "unit_test_find"); if (unit_test_find()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);

 do { printf("#%03d %s \n", ++mu_tests, "unit_test_successor"); if (unit_test_successor()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);

 do { printf("#%03d %s \n", ++mu_tests, "unit_test_atomic_insertion"); if (unit_test_atomic_insertion()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);
 do { printf("#%03d %s \n", ++mu_tests, "unit_test_atomic_deletion"); if (unit_test_atomic_deletion()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);

 do { printf("#%03d %s \n", ++mu_tests, "unit_test_chain_insertion"); if (unit_test_chain_insertion()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);
 do { printf("#%03d %s \n", ++mu_tests, "unit_test_chain_deletion"); if (unit_test_chain_deletion()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);

 do { printf("#%03d %s \n", ++mu_tests, "unit_test_permutation_insertion"); if (unit_test_permutation_insertion()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);
 do { printf("#%03d %s \n", ++mu_tests, "unit_test_permutation_deletion"); if (unit_test_permutation_deletion()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);

 do { printf("#%03d %s \n", ++mu_tests, "unit_test_random_insertion_deletion"); if (unit_test_random_insertion_deletion()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);

 do { printf("#%03d %s \n", ++mu_tests, "unit_test_dup"); if (unit_test_dup()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);


 do { printf("#%03d %s \n", ++mu_tests, "unit_test_min"); if (unit_test_min()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);

}

int main(int argc, char **argv)
{
 all_tests();

 if (mu_fails) {
  printf("*** %d/%d TESTS FAILED ***\n", mu_fails, mu_tests);
  return 1;
 } else {
  printf("ALL TESTS PASSED\n");
  return 0;
 }
}

avltree *tree_create()
{
 return avl_create(compare_func, destroy_func);
}

avlnode *tree_find(avltree *avlt, int key)
{
 mydata query;
 query.key = key;
 return avl_find(avlt, &query);
}

void tree_print(avltree *avlt)
{
 avl_print(avlt, print_func);
}

int tree_check(avltree *avlt)
{
 mydata min, max;
 int rc;

 min.key = -2147483648;
 max.key = 2147483647;
 rc = 1;

 if (avl_check_order(avlt, &min, &max) != 1) {
  fprintf(stdout, "tree_check: invalid order\n");
  rc = 0;
 }

 if (avl_check_height(avlt) != 1) {
  fprintf(stdout, "tree_check: invalid height\n");
  rc = 0;
 }

 return rc;
}

avlnode *tree_insert(avltree *avlt, int key)
{
 avlnode *node;
 mydata *data;

 if (key < -2147483648 || key > 2147483647) {
  fprintf(stdout, "tree_insert: invalid key %d\n", key);
  return 0;
 }

 if ((data = makedata(key)) == 0 || (node = avl_insert(avlt, data)) == 0) {
  fprintf(stdout, "tree_insert: insert %d failed\n", key);
  free(data);
  return 0;
 }

 return node;
}

int tree_delete(avltree *avlt, int key)
{
 avlnode *node;

 if ((node = tree_find(avlt, key)) == 0) {
  fprintf(stdout, "tree_delete: %d not found\n", key);
  return 0;
 }

 avl_delete(avlt, node, 0);

 if (tree_find(avlt, key) == node) {
  fprintf(stdout, "tree_delete: delete %d failed\n", key);
  return 0;
 }

 return 1;
}

void swap(char *x, char *y)
{
 char temp;
 temp = *x;
 *x = *y;
 *y = temp;
}

void permute(char *a, int start, int end, void func(char *))
{
 if (start == end) {
  func(a);
  return;
 }

 int i;
 for (i = start; i <= end; i++) {
  swap(a + start, a + i);
  permute(a, start + 1, end, func);
  swap(a + start, a + i);
 }
}

void permutation_insert(char *a)
{
 avltree *avlt;
 avlnode *node;
 int i;

 if ((avlt = tree_create()) == 0) {
  fprintf(stdout, "create AVL tree failed\n");
  permutation_error++;
  return;
 }

 for (i = 0; i < strlen(a); i++) {
  if ((node = tree_insert(avlt, a[i])) == 0 || tree_find(avlt, a[i]) != node || tree_check(avlt) != 1) {
   fprintf(stdout, "insert %c failed\n", a[i]);
   permutation_error++;
   return;
  }
 }

 avl_destroy(avlt);
}

void permutation_delete(char *a)
{
 avltree *avlt;
 avlnode *node;
 int i;

 if ((avlt = tree_create()) == 0) {
  fprintf(stdout, "create AVL tree failed\n");
  permutation_error++;
  return;
 }

 char b[] = "ABCDEFGHIJ";

 for (i = 0; i < strlen(b); i++) {
  if ((node = tree_insert(avlt, b[i])) == 0 || tree_find(avlt, b[i]) != node || tree_check(avlt) != 1) {
   fprintf(stdout, "insert %c failed\n", b[i]);
   permutation_error++;
   return;
  }
 }

 for (i = 0; i < strlen(a); i++) {
  if (tree_delete(avlt, a[i]) != 1 || tree_check(avlt) != 1) {
   fprintf(stdout, "delete %c failed\n", a[i]);
   permutation_error++;
   return;
  }
 }

 avl_destroy(avlt);
}

int unit_test_create()
{
 avltree *avlt;

 if ((avlt = tree_create()) == 0) {
  fprintf(stdout, "create AVL tree failed\n");
  return 0;
 }

 if (avlt->compare != compare_func ||
  avlt->destroy != destroy_func ||
  avlt->nil.left != (&(avlt)->nil) ||
  avlt->nil.right != (&(avlt)->nil) ||
  avlt->nil.parent != (&(avlt)->nil) ||
  avlt->nil.bf != 0 ||
  avlt->nil.data != 0 ||
  avlt->root.left != (&(avlt)->nil) ||
  avlt->root.right != (&(avlt)->nil) ||
  avlt->root.parent != (&(avlt)->nil) ||
  avlt->root.bf != 0 ||
  avlt->root.data != 0) {
  fprintf(stdout, "init 1\n");
  avl_destroy(avlt);
  return 0;
 }

 avl_destroy(avlt);
 return 1;
}

int unit_test_find()
{
 avltree *avlt;
 avlnode *r, *e, *d, *s, *o, *x, *c, *u, *b, *t;

 if ((avlt = tree_create()) == 0) {
  fprintf(stdout, "create AVL tree failed\n");
  goto err0;
 }

 if ((r = tree_insert(avlt, 'R')) == 0 ||
  (e = tree_insert(avlt, 'E')) == 0 ||
  (d = tree_insert(avlt, 'D')) == 0 ||
  (s = tree_insert(avlt, 'S')) == 0 ||
  (o = tree_insert(avlt, 'O')) == 0 ||
  (x = tree_insert(avlt, 'X')) == 0 ||
  (c = tree_insert(avlt, 'C')) == 0 ||
  (u = tree_insert(avlt, 'U')) == 0 ||
  (b = tree_insert(avlt, 'B')) == 0 ||
  (t = tree_insert(avlt, 'T')) == 0 ||
  tree_check(avlt) != 1) {
  fprintf(stdout, "init failed\n");
  goto err;
 }

 if (avl_find(avlt, r->data) != r ||
  avl_find(avlt, e->data) != e ||
  avl_find(avlt, d->data) != d ||
  avl_find(avlt, s->data) != s ||
  avl_find(avlt, o->data) != o ||
  avl_find(avlt, x->data) != x ||
  avl_find(avlt, c->data) != c ||
  avl_find(avlt, u->data) != u ||
  avl_find(avlt, b->data) != b ||
  avl_find(avlt, t->data) != t) {
  fprintf(stdout, "find failed\n");
  goto err;
 }

 avl_destroy(avlt);
 return 1;

err:
 avl_destroy(avlt);
err0:
 return 0;
}

int unit_test_successor()
{
 avltree *avlt;
 avlnode *r, *e, *d, *s, *o, *x, *c, *u, *b, *t;

 if ((avlt = tree_create()) == 0) {
  fprintf(stdout, "create AVL tree failed\n");
  goto err0;
 }

 if ((r = tree_insert(avlt, 'R')) == 0 ||
  (e = tree_insert(avlt, 'E')) == 0 ||
  (d = tree_insert(avlt, 'D')) == 0 ||
  (s = tree_insert(avlt, 'S')) == 0 ||
  (o = tree_insert(avlt, 'O')) == 0 ||
  (x = tree_insert(avlt, 'X')) == 0 ||
  (c = tree_insert(avlt, 'C')) == 0 ||
  (u = tree_insert(avlt, 'U')) == 0 ||
  (b = tree_insert(avlt, 'B')) == 0 ||
  (t = tree_insert(avlt, 'T')) == 0 ||
  tree_delete(avlt, 'O') != 1 ||
  tree_check(avlt) != 1) {
  fprintf(stdout, "init failed\n");
  goto err;
 }

 if (avl_successor(avlt, b) != c ||
  avl_successor(avlt, c) != d ||
  avl_successor(avlt, d) != e ||
  avl_successor(avlt, e) != r ||
  avl_successor(avlt, r) != s ||
  avl_successor(avlt, s) != t ||
  avl_successor(avlt, t) != u ||
  avl_successor(avlt, u) != x ||
  avl_successor(avlt, x) != 0) {
  fprintf(stdout, "successor failed\n");
  goto err;
 }

 avl_destroy(avlt);
 return 1;

err:
 avl_destroy(avlt);
err0:
 return 0;
}

int unit_test_atomic_insertion()
{
 avltree *avlt;
 int i, j;

 char *cases[] = {






  "P",
  "PH",
  "PX",
# 397 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c"
  "PHD"


  "PHXDLB",
  "PHXDLF",




  "PHL",


  "PHXDLJ",
  "PHXDLN",






  "PXb",


  "PHXTbZ",
  "PHXTbd",




  "PHXT",


  "PHXTbRV",
  "PHXTbR",
  "PHXTbV",


  0

 };

 for (i = 0; i < sizeof(cases) / sizeof(cases[0]) && cases[i]; i++) {
  if ((avlt = tree_create()) == 0) {
   fprintf(stdout, "%s - create AVL tree failed\n", cases[i]);
   goto err0;
  }

  for (j = 0; j < strlen(cases[i]); j++) {
   if (tree_insert(avlt, cases[i][j]) == 0 || tree_check(avlt) != 1) {
    fprintf(stdout, "%s - insert %c failed\n", cases[i], cases[i][j]);
    goto err;
   }
  }

  avl_destroy(avlt);
 }

 return 1;

err:
 avl_destroy(avlt);
err0:
 return 0;
}

int unit_test_atomic_deletion()
{
 avltree *avlt;
 int i, j;

 char *cases[] = {






  "P", "P",
  "PH", "H",
  "PH", "P",
  "PX", "P",
  "PX", "X",


  "PHX", "H",
  "PHX", "P",
  "PHX", "X",






  "PHXD", "X",


  "PHXDLTBF", "X",
  "PHXDLTB", "X",
  "PHXDLTF", "X",




  "PHXDL", "X",


  "PHXDLTBFJN", "X",
  "PHXDLTBFJ", "X",
  "PHXDLTBFN", "X",
  "PHXDLTBJN", "X",
  "PHXDLTBJ", "X",
  "PHXDLTBN", "X",
  "PHXDLTFJN", "X",
  "PHXDLTFJ", "X",
  "PHXDLTFN", "X",




  "PHXL", "X",


  "PHXDLTJN", "X",
  "PHXDLTJ", "X",
  "PHXDLTN", "X",






  "PHXb", "H",


  "PHXDTbZd", "H",
  "PHXDTbZ", "H",
  "PHXDTbd", "H",




  "PHXTb", "H",


  "PHXDTbRVZd", "H",
  "PHXDTbRVZ", "H",
  "PHXDTbRVd", "H",
  "PHXDTbRZd", "H",
  "PHXDTbRZ", "H",
  "PHXDTbRd", "H",
  "PHXDTbVZd", "H",
  "PHXDTbVZ", "H",
  "PHXDTbVd", "H",




  "PHXT", "H",


  "PHXDTbRV", "H",
  "PHXDTbR", "H",
  "PHXDTbV", "H",


  0, 0

 };

 for (i = 0; i < sizeof(cases) / sizeof(cases[0]) && cases[i] != 0; i += 2) {
  if ((avlt = tree_create()) == 0) {
   fprintf(stdout, "%s-%s - create AVL tree failed\n", cases[i], cases[i + 1]);
   goto err0;
  }

  for (j = 0; j < strlen(cases[i]); j++) {
   if (tree_insert(avlt, cases[i][j]) == 0 || tree_check(avlt) != 1) {
    fprintf(stdout, "%s-%s - insert %c failed\n", cases[i], cases[i + 1], cases[i][j]);
    goto err;
   }
  }

  for (j = 0; j < strlen(cases[i + 1]); j++) {
   if (tree_delete(avlt, cases[i + 1][j]) == 0 || tree_check(avlt) != 1) {
    fprintf(stdout, "%s-%s - delete %c failed\n", cases[i], cases[i + 1], cases[i + 1][j]);
    goto err;
   }
  }

  avl_destroy(avlt);
 }

 return 1;

err:
 avl_destroy(avlt);
err0:
 return 0;
}





int unit_test_chain_insertion()
{
 avltree *avlt;
 int i, j;

 char *cases[] = {
  "PHXDB",
  "PHXDF",
  "PHXLJ",
  "PHXLN",
  "PHXTR",
  "PHXTV",
  "PHXbZ",
  "PHXbd",
  "PHXDLB",
  "PHXDLF",
  "PHXDLJ",
  "PHXDLN",
  "PHXTbR",
  "PHXTbV",
  "PHXTbV",
  "PHXTbZ",
  "PHXTbd",
  0
 };

 for (i = 0; i < sizeof(cases) / sizeof(cases[0]) && cases[i] != 0; i++) {
  if ((avlt = tree_create()) == 0) {
   fprintf(stdout, "%s - create AVL tree failed\n", cases[i]);
   goto err0;
  }

  for (j = 0; j < strlen(cases[i]); j++) {
   if (tree_insert(avlt, cases[i][j]) == 0 || tree_check(avlt) != 1) {
    fprintf(stdout, "%s - insert %c failed\n", cases[i], cases[i][j]);
    goto err;
   }
  }

  avl_destroy(avlt);
 }

 return 1;

err:
 avl_destroy(avlt);
err0:
 return 0;
}





int unit_test_chain_deletion()
{
 avltree *avlt;
 int i, j;

 char *cases[] = {
  "PHXDLTbFJNZK", "T",
  "PHXDLTbFJNZdK", "T",
  "PHXDLTbFJNdK", "T",
  "PHXDLTbFRVZU", "L",
  "PHXDLTbBFRVZU", "L",
  "PHXDLTbBRVZU", "L",
  0, 0
 };

 for (i = 0; i < sizeof(cases) / sizeof(cases[0]) && cases[i] != 0; i += 2) {
  if ((avlt = tree_create()) == 0) {
   fprintf(stdout, "%s-%s - create AVL tree failed\n", cases[i], cases[i + 1]);
   goto err0;
  }

  for (j = 0; j < strlen(cases[i]); j++) {
   if (tree_insert(avlt, cases[i][j]) == 0 || tree_check(avlt) != 1) {
    fprintf(stdout, "%s-%s - insert %c failed\n", cases[i], cases[i + 1], cases[i][j]);
    goto err;
   }
  }

  for (j = 0; j < strlen(cases[i + 1]); j++) {
   if (tree_delete(avlt, cases[i + 1][j]) == 0 || tree_check(avlt) != 1) {
    fprintf(stdout, "%s-%s - delete %c failed\n", cases[i], cases[i + 1], cases[i + 1][j]);
    goto err;
   }
  }

  avl_destroy(avlt);
 }

 return 1;

err:
 avl_destroy(avlt);
err0:
 return 0;
}

int unit_test_permutation_insertion()
{
 char a[] = "ABCDEFGHIJ";

 permutation_error = 0;
 permute(a, 0, strlen(a) - 1, permutation_insert);
 return (permutation_error == 0);
}

int unit_test_permutation_deletion()
{
 char a[] = "ABCDEFGHIJ";

 permutation_error = 0;
 permute(a, 0, strlen(a) - 1, permutation_delete);
 return (permutation_error == 0);
}

int unit_test_random_insertion_deletion()
{
 avltree *avlt;
 int ninsert, ndelete;
 int i, key, max;

 if ((avlt = tree_create()) == 0) {
  fprintf(stdout, "create AVL tree failed\n");
  goto err0;
 }

 ninsert = 0;
 ndelete = 0;
 max = 9999;

 srand((unsigned int) time(0));

 for (i = 1; i <= 1999; i++) {
  key = rand() % max;
  if (tree_find(avlt, key) != 0)
   continue;
  ninsert++;
  if (tree_insert(avlt, key) == 0 || tree_check(avlt) != 1) {
   fprintf(stdout, "insert %d failed\n", key);
   goto err;
  }
 }

 for (i = 1; i < max; i++) {
  key = rand() % max;
  if (tree_find(avlt, key) == 0)
   continue;
  ndelete++;
  if (tree_delete(avlt, key) != 1 || tree_check(avlt) != 1) {
   fprintf(stdout, "delete %d failed\n", key);
   goto err;
  }
 }

 printf("\tstat: ninsert=%d, ndelete=%d\n", ninsert, ndelete);

 avl_destroy(avlt);
 return 1;

err:
 avl_destroy(avlt);
err0:
 return 0;
}


int unit_test_min()
{
 avltree *avlt;

 if ((avlt = tree_create()) == 0) {
  fprintf(stdout, "create AVL tree failed\n");
  goto err0;
 }

 if (((avlt)->min) != 0 ||
  tree_insert(avlt, 'B') == 0 || ((avlt)->min) != tree_find(avlt, 'B') ||
  tree_insert(avlt, 'A') == 0 || ((avlt)->min) != tree_find(avlt, 'A') ||
  tree_insert(avlt, 'C') == 0 || ((avlt)->min) != tree_find(avlt, 'A') ||
  tree_delete(avlt, 'B') != 1 || ((avlt)->min) != tree_find(avlt, 'A') ||
  tree_delete(avlt, 'A') != 1 || ((avlt)->min) != tree_find(avlt, 'C') ||
  tree_delete(avlt, 'C') != 1 || ((avlt)->min) != 0) {
  fprintf(stdout, "invalid min\n");
  goto err;
 }

 avl_destroy(avlt);
 return 1;

err:
 avl_destroy(avlt);
err0:
 return 0;
}


int unit_test_dup()
{
 avltree *avlt;
 avlnode *n1, *n2;

 if ((avlt = tree_create()) == 0) {
  fprintf(stdout, "create AVL tree failed\n");
  goto err0;
 }

 if ((n1 = tree_insert(avlt, 'N')) == 0 || (n2 = tree_insert(avlt, 'N')) == 0) {
  fprintf(stdout, "insert failed\n");
  goto err;
 }


 if (n1 == n2 || n1->right != n2) {



  fprintf(stdout, "invalid dup\n");
  goto err;
 }

 avl_destroy(avlt);
 return 1;

err:
 avl_destroy(avlt);
err0:
 return 0;
}
# 0 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c"





# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 1
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_defines.h" 1
# 2 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/_fake_typedefs.h" 1



typedef int START_DELIMETER;
typedef int socklen_t;
typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int char16_t;
typedef int char32_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;


typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;
typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;
typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef int END_DELIMETER;
# 3 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdio.h" 2
# 7 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/string.h" 1
# 8 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/stdlib.h" 1
# 9 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/time.h" 1
# 10 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/pipeline/preprocess/fake_libc_include/limits.h" 1
# 11 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_bf.h" 1
# 18 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_bf.h"
enum avlbf {
 LEFTHEAVY = -1,
 BALANCED = 0,
 RIGHTHEAVY = 1
};

enum avltraversal {
 PREORDER,
 INORDER,
 POSTORDER
};

typedef struct avlnode {
 struct avlnode *left;
 struct avlnode *right;
 struct avlnode *parent;
 char bf;
 void *data;
} avlnode;

typedef struct {
 int (*compare)(const void *, const void *);
 void (*print)(void *);
 void (*destroy)(void *);

 avlnode root;
 avlnode nil;


 avlnode *min;

} avltree;
# 59 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_bf.h"
avltree *avl_create(int (*compare_func)(const void *, const void *), void (*destroy_func)(void *));
void avl_destroy(avltree *avlt);

avlnode *avl_find(avltree *avlt, void *data);
avlnode *avl_successor(avltree *avlt, avlnode *node);

int avl_apply(avltree *avlt, avlnode *node, int (*func)(void *, void *), void *cookie, enum avltraversal order);
void avl_print(avltree *avlt, void (*print_func)(void *));

avlnode *avl_insert(avltree *avlt, void *data);
void *avl_delete(avltree *avlt, avlnode *node, int keep);

int avl_check_order(avltree *avlt, void *min, void *max);
int avl_check_height(avltree *avlt);
# 12 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_data.h" 1
# 9 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_data.h"
typedef struct {
 int key;
} mydata;

mydata *makedata(int key);
int compare_func(const void *d1, const void *d2);
void destroy_func(void *d);
void print_func(void *d);
void print_char_func(void *d);
# 13 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c" 2
# 1 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/minunit.h" 1
# 20 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/minunit.h"
extern int mu_tests, mu_fails;
# 14 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c" 2





int mu_tests= 0, mu_fails = 0;

int permutation_error = 0;

static avltree *tree_create();
static avlnode *tree_find(avltree *avlt, int key);
static void tree_print(avltree *avlt);
static int tree_check(avltree *avlt);
static avlnode *tree_insert(avltree *avlt, int key);
static int tree_delete(avltree *avlt, int key);

static void swap(char *x, char *y);
static void permute(char *a, int start, int end, void func(char *));
static void permutation_insert(char *a);
static void permutation_delete(char *a);

static int unit_test_create();
static int unit_test_find();
static int unit_test_successor();
static int unit_test_atomic_insertion();
static int unit_test_atomic_deletion();
static int unit_test_chain_insertion();
static int unit_test_chain_deletion();
static int unit_test_permutation_insertion();
static int unit_test_permutation_deletion();
static int unit_test_random_insertion_deletion();

static int unit_test_dup();

static int unit_test_min();


void all_tests()
{
 do { printf("#%03d %s \n", ++mu_tests, "unit_test_create"); if (unit_test_create()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);

 do { printf("#%03d %s \n", ++mu_tests, "unit_test_find"); if (unit_test_find()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);

 do { printf("#%03d %s \n", ++mu_tests, "unit_test_successor"); if (unit_test_successor()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);

 do { printf("#%03d %s \n", ++mu_tests, "unit_test_atomic_insertion"); if (unit_test_atomic_insertion()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);
 do { printf("#%03d %s \n", ++mu_tests, "unit_test_atomic_deletion"); if (unit_test_atomic_deletion()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);

 do { printf("#%03d %s \n", ++mu_tests, "unit_test_chain_insertion"); if (unit_test_chain_insertion()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);
 do { printf("#%03d %s \n", ++mu_tests, "unit_test_chain_deletion"); if (unit_test_chain_deletion()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);

 do { printf("#%03d %s \n", ++mu_tests, "unit_test_permutation_insertion"); if (unit_test_permutation_insertion()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);
 do { printf("#%03d %s \n", ++mu_tests, "unit_test_permutation_deletion"); if (unit_test_permutation_deletion()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);

 do { printf("#%03d %s \n", ++mu_tests, "unit_test_random_insertion_deletion"); if (unit_test_random_insertion_deletion()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);

 do { printf("#%03d %s \n", ++mu_tests, "unit_test_dup"); if (unit_test_dup()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);


 do { printf("#%03d %s \n", ++mu_tests, "unit_test_min"); if (unit_test_min()) { printf("PASSED\n"); } else { printf("FAILED\n"); mu_fails++; } } while (0);

}

int main(int argc, char **argv)
{
 all_tests();

 if (mu_fails) {
  printf("*** %d/%d TESTS FAILED ***\n", mu_fails, mu_tests);
  return 1;
 } else {
  printf("ALL TESTS PASSED\n");
  return 0;
 }
}

avltree *tree_create()
{
 return avl_create(compare_func, destroy_func);
}

avlnode *tree_find(avltree *avlt, int key)
{
 mydata query;
 query.key = key;
 return avl_find(avlt, &query);
}

void tree_print(avltree *avlt)
{
 avl_print(avlt, print_func);
}

int tree_check(avltree *avlt)
{
 mydata min, max;
 int rc;

 min.key = -2147483648;
 max.key = 2147483647;
 rc = 1;

 if (avl_check_order(avlt, &min, &max) != 1) {
  fprintf(stdout, "tree_check: invalid order\n");
  rc = 0;
 }

 if (avl_check_height(avlt) != 1) {
  fprintf(stdout, "tree_check: invalid height\n");
  rc = 0;
 }

 return rc;
}

avlnode *tree_insert(avltree *avlt, int key)
{
 avlnode *node;
 mydata *data;

 if (key < -2147483648 || key > 2147483647) {
  fprintf(stdout, "tree_insert: invalid key %d\n", key);
  return 0;
 }

 if ((data = makedata(key)) == 0 || (node = avl_insert(avlt, data)) == 0) {
  fprintf(stdout, "tree_insert: insert %d failed\n", key);
  free(data);
  return 0;
 }

 return node;
}

int tree_delete(avltree *avlt, int key)
{
 avlnode *node;

 if ((node = tree_find(avlt, key)) == 0) {
  fprintf(stdout, "tree_delete: %d not found\n", key);
  return 0;
 }

 avl_delete(avlt, node, 0);

 if (tree_find(avlt, key) == node) {
  fprintf(stdout, "tree_delete: delete %d failed\n", key);
  return 0;
 }

 return 1;
}

void swap(char *x, char *y)
{
 char temp;
 temp = *x;
 *x = *y;
 *y = temp;
}

void permute(char *a, int start, int end, void func(char *))
{
 if (start == end) {
  func(a);
  return;
 }

 int i;
 for (i = start; i <= end; i++) {
  swap(a + start, a + i);
  permute(a, start + 1, end, func);
  swap(a + start, a + i);
 }
}

void permutation_insert(char *a)
{
 avltree *avlt;
 avlnode *node;
 int i;

 if ((avlt = tree_create()) == 0) {
  fprintf(stdout, "create AVL tree failed\n");
  permutation_error++;
  return;
 }

 for (i = 0; i < strlen(a); i++) {
  if ((node = tree_insert(avlt, a[i])) == 0 || tree_find(avlt, a[i]) != node || tree_check(avlt) != 1) {
   fprintf(stdout, "insert %c failed\n", a[i]);
   permutation_error++;
   return;
  }
 }

 avl_destroy(avlt);
}

void permutation_delete(char *a)
{
 avltree *avlt;
 avlnode *node;
 int i;

 if ((avlt = tree_create()) == 0) {
  fprintf(stdout, "create AVL tree failed\n");
  permutation_error++;
  return;
 }

 char b[] = "ABCDEFGHIJ";

 for (i = 0; i < strlen(b); i++) {
  if ((node = tree_insert(avlt, b[i])) == 0 || tree_find(avlt, b[i]) != node || tree_check(avlt) != 1) {
   fprintf(stdout, "insert %c failed\n", b[i]);
   permutation_error++;
   return;
  }
 }

 for (i = 0; i < strlen(a); i++) {
  if (tree_delete(avlt, a[i]) != 1 || tree_check(avlt) != 1) {
   fprintf(stdout, "delete %c failed\n", a[i]);
   permutation_error++;
   return;
  }
 }

 avl_destroy(avlt);
}

int unit_test_create()
{
 avltree *avlt;

 if ((avlt = tree_create()) == 0) {
  fprintf(stdout, "create AVL tree failed\n");
  return 0;
 }

 if (avlt->compare != compare_func ||
  avlt->destroy != destroy_func ||
  avlt->nil.left != (&(avlt)->nil) ||
  avlt->nil.right != (&(avlt)->nil) ||
  avlt->nil.parent != (&(avlt)->nil) ||
  avlt->nil.bf != 0 ||
  avlt->nil.data != 0 ||
  avlt->root.left != (&(avlt)->nil) ||
  avlt->root.right != (&(avlt)->nil) ||
  avlt->root.parent != (&(avlt)->nil) ||
  avlt->root.bf != 0 ||
  avlt->root.data != 0) {
  fprintf(stdout, "init 1\n");
  avl_destroy(avlt);
  return 0;
 }

 avl_destroy(avlt);
 return 1;
}

int unit_test_find()
{
 avltree *avlt;
 avlnode *r, *e, *d, *s, *o, *x, *c, *u, *b, *t;

 if ((avlt = tree_create()) == 0) {
  fprintf(stdout, "create AVL tree failed\n");
  goto err0;
 }

 if ((r = tree_insert(avlt, 'R')) == 0 ||
  (e = tree_insert(avlt, 'E')) == 0 ||
  (d = tree_insert(avlt, 'D')) == 0 ||
  (s = tree_insert(avlt, 'S')) == 0 ||
  (o = tree_insert(avlt, 'O')) == 0 ||
  (x = tree_insert(avlt, 'X')) == 0 ||
  (c = tree_insert(avlt, 'C')) == 0 ||
  (u = tree_insert(avlt, 'U')) == 0 ||
  (b = tree_insert(avlt, 'B')) == 0 ||
  (t = tree_insert(avlt, 'T')) == 0 ||
  tree_check(avlt) != 1) {
  fprintf(stdout, "init failed\n");
  goto err;
 }

 if (avl_find(avlt, r->data) != r ||
  avl_find(avlt, e->data) != e ||
  avl_find(avlt, d->data) != d ||
  avl_find(avlt, s->data) != s ||
  avl_find(avlt, o->data) != o ||
  avl_find(avlt, x->data) != x ||
  avl_find(avlt, c->data) != c ||
  avl_find(avlt, u->data) != u ||
  avl_find(avlt, b->data) != b ||
  avl_find(avlt, t->data) != t) {
  fprintf(stdout, "find failed\n");
  goto err;
 }

 avl_destroy(avlt);
 return 1;

err:
 avl_destroy(avlt);
err0:
 return 0;
}

int unit_test_successor()
{
 avltree *avlt;
 avlnode *r, *e, *d, *s, *o, *x, *c, *u, *b, *t;

 if ((avlt = tree_create()) == 0) {
  fprintf(stdout, "create AVL tree failed\n");
  goto err0;
 }

 if ((r = tree_insert(avlt, 'R')) == 0 ||
  (e = tree_insert(avlt, 'E')) == 0 ||
  (d = tree_insert(avlt, 'D')) == 0 ||
  (s = tree_insert(avlt, 'S')) == 0 ||
  (o = tree_insert(avlt, 'O')) == 0 ||
  (x = tree_insert(avlt, 'X')) == 0 ||
  (c = tree_insert(avlt, 'C')) == 0 ||
  (u = tree_insert(avlt, 'U')) == 0 ||
  (b = tree_insert(avlt, 'B')) == 0 ||
  (t = tree_insert(avlt, 'T')) == 0 ||
  tree_delete(avlt, 'O') != 1 ||
  tree_check(avlt) != 1) {
  fprintf(stdout, "init failed\n");
  goto err;
 }

 if (avl_successor(avlt, b) != c ||
  avl_successor(avlt, c) != d ||
  avl_successor(avlt, d) != e ||
  avl_successor(avlt, e) != r ||
  avl_successor(avlt, r) != s ||
  avl_successor(avlt, s) != t ||
  avl_successor(avlt, t) != u ||
  avl_successor(avlt, u) != x ||
  avl_successor(avlt, x) != 0) {
  fprintf(stdout, "successor failed\n");
  goto err;
 }

 avl_destroy(avlt);
 return 1;

err:
 avl_destroy(avlt);
err0:
 return 0;
}

int unit_test_atomic_insertion()
{
 avltree *avlt;
 int i, j;

 char *cases[] = {






  "P",
  "PH",
  "PX",
# 397 "/home/enumclass/Documents/C2RustTranslation/bkp/avl-tree/avl_test.c"
  "PHD"


  "PHXDLB",
  "PHXDLF",




  "PHL",


  "PHXDLJ",
  "PHXDLN",






  "PXb",


  "PHXTbZ",
  "PHXTbd",




  "PHXT",


  "PHXTbRV",
  "PHXTbR",
  "PHXTbV",


  0

 };

 for (i = 0; i < sizeof(cases) / sizeof(cases[0]) && cases[i]; i++) {
  if ((avlt = tree_create()) == 0) {
   fprintf(stdout, "%s - create AVL tree failed\n", cases[i]);
   goto err0;
  }

  for (j = 0; j < strlen(cases[i]); j++) {
   if (tree_insert(avlt, cases[i][j]) == 0 || tree_check(avlt) != 1) {
    fprintf(stdout, "%s - insert %c failed\n", cases[i], cases[i][j]);
    goto err;
   }
  }

  avl_destroy(avlt);
 }

 return 1;

err:
 avl_destroy(avlt);
err0:
 return 0;
}

int unit_test_atomic_deletion()
{
 avltree *avlt;
 int i, j;

 char *cases[] = {






  "P", "P",
  "PH", "H",
  "PH", "P",
  "PX", "P",
  "PX", "X",


  "PHX", "H",
  "PHX", "P",
  "PHX", "X",






  "PHXD", "X",


  "PHXDLTBF", "X",
  "PHXDLTB", "X",
  "PHXDLTF", "X",




  "PHXDL", "X",


  "PHXDLTBFJN", "X",
  "PHXDLTBFJ", "X",
  "PHXDLTBFN", "X",
  "PHXDLTBJN", "X",
  "PHXDLTBJ", "X",
  "PHXDLTBN", "X",
  "PHXDLTFJN", "X",
  "PHXDLTFJ", "X",
  "PHXDLTFN", "X",




  "PHXL", "X",


  "PHXDLTJN", "X",
  "PHXDLTJ", "X",
  "PHXDLTN", "X",






  "PHXb", "H",


  "PHXDTbZd", "H",
  "PHXDTbZ", "H",
  "PHXDTbd", "H",




  "PHXTb", "H",


  "PHXDTbRVZd", "H",
  "PHXDTbRVZ", "H",
  "PHXDTbRVd", "H",
  "PHXDTbRZd", "H",
  "PHXDTbRZ", "H",
  "PHXDTbRd", "H",
  "PHXDTbVZd", "H",
  "PHXDTbVZ", "H",
  "PHXDTbVd", "H",




  "PHXT", "H",


  "PHXDTbRV", "H",
  "PHXDTbR", "H",
  "PHXDTbV", "H",


  0, 0

 };

 for (i = 0; i < sizeof(cases) / sizeof(cases[0]) && cases[i] != 0; i += 2) {
  if ((avlt = tree_create()) == 0) {
   fprintf(stdout, "%s-%s - create AVL tree failed\n", cases[i], cases[i + 1]);
   goto err0;
  }

  for (j = 0; j < strlen(cases[i]); j++) {
   if (tree_insert(avlt, cases[i][j]) == 0 || tree_check(avlt) != 1) {
    fprintf(stdout, "%s-%s - insert %c failed\n", cases[i], cases[i + 1], cases[i][j]);
    goto err;
   }
  }

  for (j = 0; j < strlen(cases[i + 1]); j++) {
   if (tree_delete(avlt, cases[i + 1][j]) == 0 || tree_check(avlt) != 1) {
    fprintf(stdout, "%s-%s - delete %c failed\n", cases[i], cases[i + 1], cases[i + 1][j]);
    goto err;
   }
  }

  avl_destroy(avlt);
 }

 return 1;

err:
 avl_destroy(avlt);
err0:
 return 0;
}





int unit_test_chain_insertion()
{
 avltree *avlt;
 int i, j;

 char *cases[] = {
  "PHXDB",
  "PHXDF",
  "PHXLJ",
  "PHXLN",
  "PHXTR",
  "PHXTV",
  "PHXbZ",
  "PHXbd",
  "PHXDLB",
  "PHXDLF",
  "PHXDLJ",
  "PHXDLN",
  "PHXTbR",
  "PHXTbV",
  "PHXTbV",
  "PHXTbZ",
  "PHXTbd",
  0
 };

 for (i = 0; i < sizeof(cases) / sizeof(cases[0]) && cases[i] != 0; i++) {
  if ((avlt = tree_create()) == 0) {
   fprintf(stdout, "%s - create AVL tree failed\n", cases[i]);
   goto err0;
  }

  for (j = 0; j < strlen(cases[i]); j++) {
   if (tree_insert(avlt, cases[i][j]) == 0 || tree_check(avlt) != 1) {
    fprintf(stdout, "%s - insert %c failed\n", cases[i], cases[i][j]);
    goto err;
   }
  }

  avl_destroy(avlt);
 }

 return 1;

err:
 avl_destroy(avlt);
err0:
 return 0;
}





int unit_test_chain_deletion()
{
 avltree *avlt;
 int i, j;

 char *cases[] = {
  "PHXDLTbFJNZK", "T",
  "PHXDLTbFJNZdK", "T",
  "PHXDLTbFJNdK", "T",
  "PHXDLTbFRVZU", "L",
  "PHXDLTbBFRVZU", "L",
  "PHXDLTbBRVZU", "L",
  0, 0
 };

 for (i = 0; i < sizeof(cases) / sizeof(cases[0]) && cases[i] != 0; i += 2) {
  if ((avlt = tree_create()) == 0) {
   fprintf(stdout, "%s-%s - create AVL tree failed\n", cases[i], cases[i + 1]);
   goto err0;
  }

  for (j = 0; j < strlen(cases[i]); j++) {
   if (tree_insert(avlt, cases[i][j]) == 0 || tree_check(avlt) != 1) {
    fprintf(stdout, "%s-%s - insert %c failed\n", cases[i], cases[i + 1], cases[i][j]);
    goto err;
   }
  }

  for (j = 0; j < strlen(cases[i + 1]); j++) {
   if (tree_delete(avlt, cases[i + 1][j]) == 0 || tree_check(avlt) != 1) {
    fprintf(stdout, "%s-%s - delete %c failed\n", cases[i], cases[i + 1], cases[i + 1][j]);
    goto err;
   }
  }

  avl_destroy(avlt);
 }

 return 1;

err:
 avl_destroy(avlt);
err0:
 return 0;
}

int unit_test_permutation_insertion()
{
 char a[] = "ABCDEFGHIJ";

 permutation_error = 0;
 permute(a, 0, strlen(a) - 1, permutation_insert);
 return (permutation_error == 0);
}

int unit_test_permutation_deletion()
{
 char a[] = "ABCDEFGHIJ";

 permutation_error = 0;
 permute(a, 0, strlen(a) - 1, permutation_delete);
 return (permutation_error == 0);
}

int unit_test_random_insertion_deletion()
{
 avltree *avlt;
 int ninsert, ndelete;
 int i, key, max;

 if ((avlt = tree_create()) == 0) {
  fprintf(stdout, "create AVL tree failed\n");
  goto err0;
 }

 ninsert = 0;
 ndelete = 0;
 max = 9999;

 srand((unsigned int) time(0));

 for (i = 1; i <= 1999; i++) {
  key = rand() % max;
  if (tree_find(avlt, key) != 0)
   continue;
  ninsert++;
  if (tree_insert(avlt, key) == 0 || tree_check(avlt) != 1) {
   fprintf(stdout, "insert %d failed\n", key);
   goto err;
  }
 }

 for (i = 1; i < max; i++) {
  key = rand() % max;
  if (tree_find(avlt, key) == 0)
   continue;
  ndelete++;
  if (tree_delete(avlt, key) != 1 || tree_check(avlt) != 1) {
   fprintf(stdout, "delete %d failed\n", key);
   goto err;
  }
 }

 printf("\tstat: ninsert=%d, ndelete=%d\n", ninsert, ndelete);

 avl_destroy(avlt);
 return 1;

err:
 avl_destroy(avlt);
err0:
 return 0;
}


int unit_test_min()
{
 avltree *avlt;

 if ((avlt = tree_create()) == 0) {
  fprintf(stdout, "create AVL tree failed\n");
  goto err0;
 }

 if (((avlt)->min) != 0 ||
  tree_insert(avlt, 'B') == 0 || ((avlt)->min) != tree_find(avlt, 'B') ||
  tree_insert(avlt, 'A') == 0 || ((avlt)->min) != tree_find(avlt, 'A') ||
  tree_insert(avlt, 'C') == 0 || ((avlt)->min) != tree_find(avlt, 'A') ||
  tree_delete(avlt, 'B') != 1 || ((avlt)->min) != tree_find(avlt, 'A') ||
  tree_delete(avlt, 'A') != 1 || ((avlt)->min) != tree_find(avlt, 'C') ||
  tree_delete(avlt, 'C') != 1 || ((avlt)->min) != 0) {
  fprintf(stdout, "invalid min\n");
  goto err;
 }

 avl_destroy(avlt);
 return 1;

err:
 avl_destroy(avlt);
err0:
 return 0;
}


int unit_test_dup()
{
 avltree *avlt;
 avlnode *n1, *n2;

 if ((avlt = tree_create()) == 0) {
  fprintf(stdout, "create AVL tree failed\n");
  goto err0;
 }

 if ((n1 = tree_insert(avlt, 'N')) == 0 || (n2 = tree_insert(avlt, 'N')) == 0) {
  fprintf(stdout, "insert failed\n");
  goto err;
 }


 if (n1 == n2 || n1->right != n2) {



  fprintf(stdout, "invalid dup\n");
  goto err;
 }

 avl_destroy(avlt);
 return 1;

err:
 avl_destroy(avlt);
err0:
 return 0;
}
